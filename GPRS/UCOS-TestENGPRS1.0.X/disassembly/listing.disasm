Disassembly Listing for os_gprs1.0
Generated From:
C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/dist/default/debug/UCOS-TestENGPRS1.0.X.debug.elf
2017-12-1 13:19:44

---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uCOS-II/Source/os_time.c  ------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                                uC/OS-II
4:                  *                                          The Real-Time Kernel
5:                  *                                             TIME MANAGEMENT
6:                  *
7:                  *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                  *                                           All Rights Reserved
9:                  *
10:                 * File    : OS_TIME.C
11:                 * By      : Jean J. Labrosse
12:                 * Version : V2.92.11
13:                 *
14:                 * LICENSING TERMS:
15:                 * ---------------
16:                 *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                 * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                 * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                 * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                 * licensing fee.
21:                 *********************************************************************************************************
22:                 */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*
31:                 *********************************************************************************************************
32:                 *                                        DELAY TASK 'n' TICKS
33:                 *
34:                 * Description: This function is called to delay execution of the currently running task until the
35:                 *              specified number of system ticks expires.  This, of course, directly equates to delaying
36:                 *              the current task for some time to expire.  No delay will result If the specified delay is
37:                 *              0.  If the specified delay is greater than 0 then, a context switch will result.
38:                 *
39:                 * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
40:                 *                        Note that by specifying 0, the task will not be delayed.
41:                 *
42:                 * Returns    : none
43:                 *********************************************************************************************************
44:                 */
45:                
46:                void OSTimeDly(INT32U ticks) {
002726  BE0100     MOV.D W0, W2
47:                    INT8U y;
48:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
49:                    OS_CPU_SR cpu_sr = 0u;
50:                #endif
51:                
52:                
53:                
54:                    if (OSIntNesting > 0u) { /* See if trying to call from an ISR                  */
002728  E24960     CP0.B OSIntNesting
00272A  3A001A     BRA NZ, 0x2760
55:                        return;
56:                    }
57:                    if (OSLockNesting > 0u) { /* See if called with scheduler locked                */
00272C  E24961     CP0.B OSLockNesting
00272E  3A0018     BRA NZ, 0x2760
58:                        return;
59:                    }
60:                    if (ticks > 0u) { /* 0 means no delay!                                  */
002730  500FE0     SUB W0, #0x0, [W15]
002732  588FE0     SUBB W1, #0x0, [W15]
002734  320015     BRA Z, 0x2760
61:                        OS_ENTER_CRITICAL();
002736  800216     MOV SR, W6
002738  200E00     MOV #0xE0, W0
00273A  B72042     IOR SR
62:                        y = OSTCBCur->OSTCBY; /* Delay current task                                 */
00273C  805361     MOV OSTCBCur, W1
63:                        OSRdyTbl[y] &= (OS_PRIO) ~OSTCBCur->OSTCBBitX;
00273E  905A21     MOV.B [W1+26], W4
002740  FB8204     ZE W4, W4
002742  209655     MOV #0x965, W5
002744  905831     MOV.B [W1+27], W0
002746  EAC000     COM.B W0, W0
002748  7A43E5     MOV.B [W5+W4], W7
00274A  604007     AND.B W0, W7, W0
00274C  7A7280     MOV.B W0, [W5+W4]
64:                        if (OSRdyTbl[y] == 0u) {
00274E  3A0003     BRA NZ, 0x2756
65:                            OSRdyGrp &= (OS_PRIO) ~OSTCBCur->OSTCBBitY;
002750  905841     MOV.B [W1+28], W0
002752  EAC000     COM.B W0, W0
002754  B66964     AND.B OSRdyGrp
66:                        }
67:                        OSTCBCur->OSTCBDly = ticks; /* Load ticks in TCB                                  */
002756  980892     MOV W2, [W1+18]
002758  9808A3     MOV W3, [W1+20]
68:                        OS_EXIT_CRITICAL();
00275A  880216     MOV W6, SR
69:                        OS_Sched(); /* Find next task to run!                             */
00275C  021D24     CALL OS_Sched
00275E  000000     NOP
002760  060000     RETURN
70:                    }
71:                }
72:                /*$PAGE*/
73:                /*
74:                 *********************************************************************************************************
75:                 *                                    DELAY TASK FOR SPECIFIED TIME
76:                 *
77:                 * Description: This function is called to delay execution of the currently running task until some time
78:                 *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
79:                 *              MILLISECONDS instead of ticks.
80:                 *
81:                 * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
82:                 *              minutes   specifies the number of minutes (max. 59)
83:                 *              seconds   specifies the number of seconds (max. 59)
84:                 *              ms        specifies the number of milliseconds (max. 999)
85:                 *
86:                 * Returns    : OS_ERR_NONE
87:                 *              OS_ERR_TIME_INVALID_MINUTES
88:                 *              OS_ERR_TIME_INVALID_SECONDS
89:                 *              OS_ERR_TIME_INVALID_MS
90:                 *              OS_ERR_TIME_ZERO_DLY
91:                 *              OS_ERR_TIME_DLY_ISR
92:                 *
93:                 * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
94:                 *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
95:                 *              set to 0.  The actual delay is rounded to the nearest tick.
96:                 *********************************************************************************************************
97:                 */
98:                
99:                #if OS_TIME_DLY_HMSM_EN > 0u
100:               
101:               INT8U OSTimeDlyHMSM(INT8U hours,
102:                       INT8U minutes,
103:                       INT8U seconds,
104:                       INT16U ms) {
002762  BE9F88     MOV.D W8, [W15++]
002764  BE9F8A     MOV.D W10, [W15++]
002766  BE9F8C     MOV.D W12, [W15++]
002768  784580     MOV.B W0, W11
00276A  784601     MOV.B W1, W12
00276C  784502     MOV.B W2, W10
105:                   INT32U ticks;
106:               
107:               
108:                   if (OSIntNesting > 0u) { /* See if trying to call from an ISR                  */
002770  E24960     CP0.B OSIntNesting
002772  3A0021     BRA NZ, 0x27B6
109:                       return (OS_ERR_TIME_DLY_ISR);
00276E  B3C551     MOV.B #0x55, W1
110:                   }
111:                   if (OSLockNesting > 0u) { /* See if called with scheduler locked                */
002776  E24961     CP0.B OSLockNesting
002778  3A001E     BRA NZ, 0x27B6
112:                       return (OS_ERR_SCHED_LOCKED);
002774  B3C321     MOV.B #0x32, W1
113:                   }
114:               #if OS_ARG_CHK_EN > 0u
115:                   if (hours == 0u) {
116:                       if (minutes == 0u) {
117:                           if (seconds == 0u) {
118:                               if (ms == 0u) {
119:                                   return (OS_ERR_TIME_ZERO_DLY);
120:                               }
121:                           }
122:                       }
123:                   }
124:                   if (minutes > 59u) {
125:                       return (OS_ERR_TIME_INVALID_MINUTES); /* Validate arguments to be within range              */
126:                   }
127:                   if (seconds > 59u) {
128:                       return (OS_ERR_TIME_INVALID_SECONDS);
129:                   }
130:                   if (ms > 999u) {
131:                       return (OS_ERR_TIME_INVALID_MS);
132:                   }
133:               #endif
134:                   /* Compute the total number of clock ticks required.. */
135:                   /* .. (rounded to the nearest tick)                   */
136:                   ticks = ((INT32U) hours * 3600uL + (INT32U) minutes * 60uL + (INT32U) seconds) * OS_TICKS_PER_SEC
002788  FB860C     ZE W12, W12
00278A  2003C0     MOV #0x3C, W0
00278C  B86600     MUL.UU W12, W0, W12
00278E  FB800B     ZE W11, W0
002790  EB0080     CLR W1
002792  20E102     MOV #0xE10, W2
002794  200003     MOV #0x0, W3
002796  020402     CALL 0x402
002798  000000     NOP
00279A  40000C     ADD W0, W12, W0
00279C  48808D     ADDC W1, W13, W1
00279E  FB850A     ZE W10, W10
0027A0  EB0580     CLR W11
0027A2  450000     ADD W10, W0, W0
0027A4  4D8081     ADDC W11, W1, W1
0027A6  203E82     MOV #0x3E8, W2
0027A8  200003     MOV #0x0, W3
0027AA  020402     CALL 0x402
0027AC  000000     NOP
0027AE  400008     ADD W0, W8, W0
137:                           + OS_TICKS_PER_SEC * ((INT32U) ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
00277A  203E80     MOV #0x3E8, W0
00277C  B81800     MUL.UU W3, W0, W0
00277E  203E82     MOV #0x3E8, W2
002780  200003     MOV #0x0, W3
002782  0203E2     CALL 0x3E2
002784  000000     NOP
002786  BE0400     MOV.D W0, W8
138:                   OSTimeDly(ticks);
0027B0  488089     ADDC W1, W9, W1
0027B2  07FFB9     RCALL OSTimeDly
139:                   return (OS_ERR_NONE);
0027B4  EB4080     CLR.B W1
140:               }
0027B6  784001     MOV.B W1, W0
0027B8  BE064F     MOV.D [--W15], W12
0027BA  BE054F     MOV.D [--W15], W10
0027BC  BE044F     MOV.D [--W15], W8
0027BE  060000     RETURN
141:               #endif
142:               /*$PAGE*/
143:               /*
144:                *********************************************************************************************************
145:                *                                        RESUME A DELAYED TASK
146:                *
147:                * Description: This function is used resume a task that has been delayed through a call to either
148:                *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
149:                *              task that is waiting for an event with timeout.  This would make the task look
150:                *              like a timeout occurred.
151:                *
152:                * Arguments  : prio                      specifies the priority of the task to resume
153:                *
154:                * Returns    : OS_ERR_NONE               Task has been resumed
155:                *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
156:                *                                        (i.e. >= OS_LOWEST_PRIO)
157:                *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
158:                *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
159:                *********************************************************************************************************
160:                */
161:               
162:               #if OS_TIME_DLY_RESUME_EN > 0u
163:               
164:               INT8U OSTimeDlyResume(INT8U prio) {
0027C0  784100     MOV.B W0, W2
165:                   OS_TCB *ptcb;
166:               #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
167:                   OS_CPU_SR cpu_sr = 0u;
168:               #endif
169:               
170:               
171:               
172:                   if (prio >= OS_LOWEST_PRIO) {
0027C4  514FE3     SUB.B W2, #0x3, [W15]
0027C6  3E0032     BRA GTU, 0x282C
173:                       return (OS_ERR_PRIO_INVALID);
0027C2  B3C2A0     MOV.B #0x2A, W0
174:                   }
175:                   OS_ENTER_CRITICAL();
0027C8  800211     MOV SR, W1
0027CA  200E00     MOV #0xE0, W0
0027CC  B72042     IOR SR
176:                   ptcb = OSTCBPrioTbl[prio]; /* Make sure that task exist            */
0027CE  FB8002     ZE W2, W0
0027D0  400000     ADD W0, W0, W0
0027D2  20A742     MOV #0xA74, W2
0027D4  7802E2     MOV [W2+W0], W5
177:                   if (ptcb == (OS_TCB *) 0) {
0027D6  E00005     CP0 W5
0027D8  320002     BRA Z, 0x27DE
178:                       OS_EXIT_CRITICAL();
179:                       return (OS_ERR_TASK_NOT_EXIST); /* The task does not exist              */
180:                   }
181:                   if (ptcb == OS_TCB_RESERVED) {
0027DA  528FE1     SUB W5, #0x1, [W15]
0027DC  3A0002     BRA NZ, 0x27E2
182:                       OS_EXIT_CRITICAL();
0027DE  880211     MOV W1, SR
183:                       return (OS_ERR_TASK_NOT_EXIST); /* The task does not exist              */
0027E0  050430     RETLW #0x43, W0
184:                   }
185:                   if (ptcb->OSTCBDly == 0u) { /* See if task is delayed               */
0027E2  900915     MOV [W5+18], W2
0027E4  9009A5     MOV [W5+20], W3
0027E6  510FE0     SUB W2, #0x0, [W15]
0027E8  598FE0     SUBB W3, #0x0, [W15]
0027EA  3A0002     BRA NZ, 0x27F0
186:                       OS_EXIT_CRITICAL();
0027EC  880211     MOV W1, SR
187:                       return (OS_ERR_TIME_NOT_DLY); /* Indicate that task was not delayed   */
0027EE  050500     RETLW #0x50, W0
188:                   }
189:               
190:                   ptcb->OSTCBDly = 0u; /* Clear the time delay                 */
0027F0  B81160     MUL.UU W2, #0, W2
0027F2  980A92     MOV W2, [W5+18]
0027F4  980AA3     MOV W3, [W5+20]
191:                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
0027F6  9051E5     MOV.B [W5+22], W3
0027F8  780103     MOV W3, W2
0027FA  B20372     AND #0x37, W2
0027FC  320004     BRA Z, 0x2806
192:                       ptcb->OSTCBStat &= ~OS_STAT_PEND_ANY; /* Yes, Clear status flag               */
0027FE  B3CC82     MOV.B #0xC8, W2
002800  61C182     AND.B W3, W2, W3
002802  9852E3     MOV.B W3, [W5+22]
193:                       ptcb->OSTCBStatPend = OS_STAT_PEND_TO; /* Indicate PEND timeout                */
002804  B3C012     MOV.B #0x1, W2
194:                   } else {
195:                       ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
002806  9852F2     MOV.B W2, [W5+23]
196:                   }
197:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) { /* Is task suspended?                   */
002808  905165     MOV.B [W5+22], W2
00280A  A33802     BTST.Z W2, #3
00280C  3A000D     BRA NZ, 0x2828
198:                       OSRdyGrp |= ptcb->OSTCBBitY; /* No,  Make ready                      */
00280E  905845     MOV.B [W5+28], W0
002810  B76964     IOR.B OSRdyGrp
199:                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
002812  905925     MOV.B [W5+26], W2
002814  FB8102     ZE W2, W2
002816  209653     MOV #0x965, W3
002818  794263     MOV.B [W3+W2], W4
00281A  905835     MOV.B [W5+27], W0
00281C  724000     IOR.B W4, W0, W0
00281E  797180     MOV.B W0, [W3+W2]
200:                       OS_EXIT_CRITICAL();
002820  880211     MOV W1, SR
201:                       OS_Sched(); /* See if this is new highest priority  */
002822  021D24     CALL OS_Sched
002824  000000     NOP
202:                   } else {
203:                       OS_EXIT_CRITICAL(); /* Task may be suspended                */
002828  880211     MOV W1, SR
204:                   }
205:                   return (OS_ERR_NONE);
002826  050000     RETLW #0x0, W0
00282A  EB4000     CLR.B W0
206:               }
00282C  060000     RETURN
207:               #endif
208:               /*$PAGE*/
209:               /*
210:                *********************************************************************************************************
211:                *                                       GET CURRENT SYSTEM TIME
212:                *
213:                * Description: This function is used by your application to obtain the current value of the 32-bit
214:                *              counter which keeps track of the number of clock ticks.
215:                *
216:                * Arguments  : none
217:                *
218:                * Returns    : The current value of OSTime
219:                *********************************************************************************************************
220:                */
221:               
222:               #if OS_TIME_GET_SET_EN > 0u
223:               
224:               INT32U OSTimeGet(void) {
225:                   INT32U ticks;
226:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
227:                   OS_CPU_SR cpu_sr = 0u;
228:               #endif
229:               
230:               
231:               
232:                   OS_ENTER_CRITICAL();
00282E  800212     MOV SR, W2
002830  200E00     MOV #0xE0, W0
002832  B72042     IOR SR
233:                   ticks = OSTime;
002834  805AC0     MOV OSTime, W0
002836  805AD1     MOV 0xB5A, W1
234:                   OS_EXIT_CRITICAL();
002838  880212     MOV W2, SR
235:                   return (ticks);
236:               }
00283A  060000     RETURN
237:               #endif
238:               
239:               /*
240:                *********************************************************************************************************
241:                *                                          SET SYSTEM CLOCK
242:                *
243:                * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
244:                *
245:                * Arguments  : ticks      specifies the new value that OSTime needs to take.
246:                *
247:                * Returns    : none
248:                *********************************************************************************************************
249:                */
250:               
251:               #if OS_TIME_GET_SET_EN > 0u
252:               
253:               void OSTimeSet(INT32U ticks) {
00283C  BE0100     MOV.D W0, W2
254:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
255:                   OS_CPU_SR cpu_sr = 0u;
256:               #endif
257:               
258:               
259:               
260:                   OS_ENTER_CRITICAL();
00283E  800211     MOV SR, W1
002840  200E00     MOV #0xE0, W0
002842  B72042     IOR SR
261:                   OSTime = ticks;
002844  885AC2     MOV W2, OSTime
002846  885AD3     MOV W3, 0xB5A
262:                   OS_EXIT_CRITICAL();
002848  880211     MOV W1, SR
263:               }
00284A  060000     RETURN
264:               #endif
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uCOS-II/Source/os_task.c  ------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                            TASK MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TASK.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*$PAGE*/
31:                /*
32:                *********************************************************************************************************
33:                *                                      CHANGE PRIORITY OF A TASK
34:                *
35:                * Description: This function allows you to change the priority of a task dynamically.  Note that the new
36:                *              priority MUST be available.
37:                *
38:                * Arguments  : oldp     is the old priority
39:                *
40:                *              newp     is the new priority
41:                *
42:                * Returns    : OS_ERR_NONE            is the call was successful
43:                *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
44:                *                                     (i.e. >= OS_LOWEST_PRIO)
45:                *              OS_ERR_PRIO_EXIST      if the new priority already exist.
46:                *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
47:                *                                     not exist.
48:                *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
49:                *********************************************************************************************************
50:                */
51:                
52:                #if OS_TASK_CHANGE_PRIO_EN > 0u
53:                INT8U  OSTaskChangePrio (INT8U  oldprio,
54:                                         INT8U  newprio)
55:                {
001F2E  4787E6     ADD W15, #0x6, W15
001F30  BE9F88     MOV.D W8, [W15++]
001F32  BE9F8A     MOV.D W10, [W15++]
001F34  BE9F8C     MOV.D W12, [W15++]
001F36  781F8E     MOV W14, [W15++]
001F38  784300     MOV.B W0, W6
56:                #if (OS_EVENT_EN)
57:                    OS_EVENT  *pevent;
58:                #if (OS_EVENT_MULTI_EN > 0u)
59:                    OS_EVENT **pevents;
60:                #endif
61:                #endif
62:                    OS_TCB    *ptcb;
63:                    INT8U      y_new;
64:                    INT8U      x_new;
65:                    INT8U      y_old;
66:                    OS_PRIO    bity_new;
67:                    OS_PRIO    bitx_new;
68:                    OS_PRIO    bity_old;
69:                    OS_PRIO    bitx_old;
70:                #if OS_CRITICAL_METHOD == 3u
71:                    OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
72:                #endif
73:                
74:                
75:                /*$PAGE*/
76:                #if OS_ARG_CHK_EN > 0u
77:                    if (oldprio >= OS_LOWEST_PRIO) {
78:                        if (oldprio != OS_PRIO_SELF) {
79:                            return (OS_ERR_PRIO_INVALID);
80:                        }
81:                    }
82:                    if (newprio >= OS_LOWEST_PRIO) {
83:                        return (OS_ERR_PRIO_INVALID);
84:                    }
85:                #endif
86:                    OS_ENTER_CRITICAL();
001F3A  800213     MOV SR, W3
001F3C  200E00     MOV #0xE0, W0
001F3E  B72042     IOR SR
87:                    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
001F40  FB8201     ZE W1, W4
001F42  420104     ADD W4, W4, W2
001F44  20A745     MOV #0xA74, W5
001F46  790165     MOV [W5+W2], W2
001F48  E00002     CP0 W2
001F4A  320003     BRA Z, 0x1F52
88:                        OS_EXIT_CRITICAL();
001F4C  880213     MOV W3, SR
89:                        return (OS_ERR_PRIO_EXIST);
001F4E  B3C280     MOV.B #0x28, W0
001F50  37004F     BRA 0x1FF0
90:                    }
91:                    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
001F52  434FE1     ADD.B W6, #0x1, [W15]
001F54  3A0002     BRA NZ, 0x1F5A
92:                        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
001F56  805360     MOV OSTCBCur, W0
001F58  905B00     MOV.B [W0+24], W6
93:                    }
94:                    ptcb = OSTCBPrioTbl[oldprio];
001F5A  FB8006     ZE W6, W0
001F5C  400000     ADD W0, W0, W0
001F5E  20A746     MOV #0xA74, W6
001F60  780166     MOV [W6+W0], W2
95:                    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
001F62  E00002     CP0 W2
001F64  3A0003     BRA NZ, 0x1F6C
96:                        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
001F66  880213     MOV W3, SR
97:                        return (OS_ERR_PRIO);
001F68  B3C290     MOV.B #0x29, W0
001F6A  370042     BRA 0x1FF0
98:                    }
99:                    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
001F6C  510FE1     SUB W2, #0x1, [W15]
001F6E  3A0003     BRA NZ, 0x1F76
100:                       OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
001F70  880213     MOV W3, SR
101:                       return (OS_ERR_TASK_NOT_EXIST);
001F72  B3C430     MOV.B #0x43, W0
001F74  37003D     BRA 0x1FF0
102:                   }
103:               #if OS_LOWEST_PRIO <= 63u
104:                   y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
001F76  FB8501     ZE W1, W10
001F78  DE5543     LSR W10, #3, W10
105:                   x_new                 = (INT8U)(newprio & 0x07u);
001F7A  60C767     AND.B W1, #0x7, W14
106:               #else
107:                   y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
108:                   x_new                 = (INT8U)(newprio & 0x0Fu);
109:               #endif
110:                   bity_new              = (OS_PRIO)(1uL << y_new);
001F7C  FB828A     ZE W10, W5
001F7E  20001C     MOV #0x1, W12
001F80  20000D     MOV #0x0, W13
001F82  BE040C     MOV.D W12, W8
001F84  780385     MOV W5, W7
001F86  E90387     DEC W7, W7
001F88  330003     BRA N, 0x1F90
001F8A  440408     ADD W8, W8, W8
001F8C  4C8489     ADDC W9, W9, W9
001F8E  37FFFB     BRA 0x1F86
001F90  9FB7F8     MOV W8, [W15-18]
001F92  9FBF89     MOV W9, [W15-16]
001F94  97EC6F     MOV.B [W15-18], W8
111:                   bitx_new              = (OS_PRIO)(1uL << x_new);
001F96  FB838E     ZE W14, W7
001F98  E90387     DEC W7, W7
001F9A  330003     BRA N, 0x1FA2
001F9C  46060C     ADD W12, W12, W12
001F9E  4E868D     ADDC W13, W13, W13
001FA0  37FFFB     BRA 0x1F98
001FA2  78438C     MOV.B W12, W7
112:               
113:                   OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
001FA4  430000     ADD W6, W0, W0
001FA6  EB0800     CLR [W0]
114:                   OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
001FA8  420204     ADD W4, W4, W4
001FAA  7A3302     MOV W2, [W6+W4]
115:                   y_old                 =  ptcb->OSTCBY;
116:                   bity_old              =  ptcb->OSTCBBitY;
001FAC  905E42     MOV.B [W2+28], W12
117:                   bitx_old              =  ptcb->OSTCBBitX;
001FAE  905832     MOV.B [W2+27], W0
118:                   if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
001FB0  905A22     MOV.B [W2+26], W4
001FB2  FB8204     ZE W4, W4
001FB4  209656     MOV #0x965, W6
001FB6  7A45E6     MOV.B [W6+W4], W11
001FB8  65C680     AND.B W11, W0, W13
001FBA  32000C     BRA Z, 0x1FD4
119:                        OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
001FBC  EAC000     COM.B W0, W0
001FBE  65C000     AND.B W11, W0, W0
001FC0  7A7300     MOV.B W0, [W6+W4]
120:                        if (OSRdyTbl[y_old] == 0u) {
001FC2  3A0002     BRA NZ, 0x1FC8
121:                            OSRdyGrp &= (OS_PRIO)~bity_old;
001FC4  EAC00C     COM.B W12, W0
001FC6  B66964     AND.B OSRdyGrp
122:                        }
123:                        OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
001FC8  784008     MOV.B W8, W0
001FCA  B76964     IOR.B OSRdyGrp
124:                        OSRdyTbl[y_new] |= bitx_new;
001FCC  209650     MOV #0x965, W0
001FCE  7AC260     MOV.B [W0+W5], W4
001FD0  73C204     IOR.B W7, W4, W4
001FD2  7AF004     MOV.B W4, [W0+W5]
125:                   }
126:               
127:               #if (OS_EVENT_EN)
128:                   pevent = ptcb->OSTCBEventPtr;
129:                   if (pevent != (OS_EVENT *)0) {
130:                       pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
131:                       if (pevent->OSEventTbl[y_old] == 0u) {
132:                           pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
133:                       }
134:                       pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
135:                       pevent->OSEventTbl[y_new] |= bitx_new;
136:                   }
137:               #if (OS_EVENT_MULTI_EN > 0u)
138:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
139:                       pevents =  ptcb->OSTCBEventMultiPtr;
140:                       pevent  = *pevents;
141:                       while (pevent != (OS_EVENT *)0) {
142:                           pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
143:                           if (pevent->OSEventTbl[y_old] == 0u) {
144:                               pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
145:                           }
146:                           pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
147:                           pevent->OSEventTbl[y_new] |= bitx_new;
148:                           pevents++;
149:                           pevent                     = *pevents;
150:                       }
151:                   }
152:               #endif
153:               #endif
154:               
155:                   ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
001FD4  985901     MOV.B W1, [W2+24]
156:                   ptcb->OSTCBY    = y_new;
001FD6  98592A     MOV.B W10, [W2+26]
157:                   ptcb->OSTCBX    = x_new;
001FD8  98591E     MOV.B W14, [W2+25]
158:                   ptcb->OSTCBBitY = bity_new;
001FDA  985948     MOV.B W8, [W2+28]
159:                   ptcb->OSTCBBitX = bitx_new;
001FDC  985937     MOV.B W7, [W2+27]
160:                   OS_EXIT_CRITICAL();
001FDE  880213     MOV W3, SR
161:                   if (OSRunning == OS_TRUE) {
001FE2  209661     MOV #0x966, W1
001FE4  784091     MOV.B [W1], W1
001FE6  50CFE1     SUB.B W1, #0x1, [W15]
001FE8  3A0003     BRA NZ, 0x1FF0
162:                       OS_Sched();                                         /* Find new highest priority task          */
001FEA  021D24     CALL OS_Sched
001FEC  000000     NOP
163:                   }
164:                   return (OS_ERR_NONE);
001FE0  EB4000     CLR.B W0
001FEE  EB4000     CLR.B W0
165:               }
001FF0  78074F     MOV [--W15], W14
001FF2  BE064F     MOV.D [--W15], W12
001FF4  BE054F     MOV.D [--W15], W10
001FF6  BE044F     MOV.D [--W15], W8
001FF8  B1006F     SUB #0x6, W15
001FFA  060000     RETURN
166:               #endif
167:               /*$PAGE*/
168:               /*
169:               *********************************************************************************************************
170:               *                                            CREATE A TASK
171:               *
172:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
173:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
174:               *              created by an ISR.
175:               *
176:               * Arguments  : task     is a pointer to the task's code
177:               *
178:               *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
179:               *                       the task when the task first executes.  Where the task is concerned it thinks
180:               *                       it was invoked and passed the argument 'p_arg' as follows:
181:               *
182:               *                           void Task (void *p_arg)
183:               *                           {
184:               *                               for (;;) {
185:               *                                   Task code;
186:               *                               }
187:               *                           }
188:               *
189:               *              ptos     is a pointer to the task's top of stack.  If the configuration constant
190:               *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
191:               *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
192:               *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
193:               *                       lowest memory location of the stack and the stack will grow with increasing
194:               *                       memory locations.
195:               *
196:               *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
197:               *                       lower the number, the higher the priority.
198:               *
199:               * Returns    : OS_ERR_NONE                      if the function was successful.
200:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
201:               *                                               (each task MUST have a unique priority).
202:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
203:               *                                               allowed (i.e. >= OS_LOWEST_PRIO)
204:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
205:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
206:               *                                               operation started.
207:               *********************************************************************************************************
208:               */
209:               
210:               #if OS_TASK_CREATE_EN > 0u
211:               INT8U  OSTaskCreate (void   (*task)(void *p_arg),
212:                                    void    *p_arg,
213:                                    OS_STK  *ptos,
214:                                    INT8U    prio)
215:               {
001FFC  BE9F88     MOV.D W8, [W15++]
001FFE  780300     MOV W0, W6
002000  784403     MOV.B W3, W8
216:                   OS_STK     *psp;
217:                   INT8U       err;
218:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
219:                   OS_CPU_SR   cpu_sr = 0u;
220:               #endif
221:               
222:               
223:               
224:               #ifdef OS_SAFETY_CRITICAL_IEC61508
225:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
226:                       OS_SAFETY_CRITICAL_EXCEPTION();
227:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
228:                   }
229:               #endif
230:               
231:               #if OS_ARG_CHK_EN > 0u
232:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
233:                       return (OS_ERR_PRIO_INVALID);
234:                   }
235:               #endif
236:                   OS_ENTER_CRITICAL();
002002  800213     MOV SR, W3
002004  200E00     MOV #0xE0, W0
002006  B72042     IOR SR
237:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
002008  E24960     CP0.B OSIntNesting
00200A  320003     BRA Z, 0x2012
238:                       OS_EXIT_CRITICAL();
00200C  880213     MOV W3, SR
239:                       return (OS_ERR_TASK_CREATE_ISR);
00200E  B3C3C8     MOV.B #0x3C, W8
002010  370026     BRA 0x205E
240:                   }
241:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
002012  FB8488     ZE W8, W9
002014  448489     ADD W9, W9, W9
002016  20A744     MOV #0xA74, W4
002018  7C82E4     MOV [W4+W9], W5
00201A  E00005     CP0 W5
00201C  3A001E     BRA NZ, 0x205A
242:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00201E  420489     ADD W4, W9, W9
002020  200014     MOV #0x1, W4
002022  780C84     MOV W4, [W9]
243:                                                            /* ... the same thing until task is created.              */
244:                       OS_EXIT_CRITICAL();
002024  880213     MOV W3, SR
245:                       psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
002026  EB0180     CLR W3
002028  780006     MOV W6, W0
00202A  022C96     CALL OSTaskStkInit
00202C  000000     NOP
246:                       err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00202E  B83360     MUL.UU W6, #0, W6
002030  B82260     MUL.UU W4, #0, W4
002032  B81160     MUL.UU W2, #0, W2
002034  780080     MOV W0, W1
002036  784008     MOV.B W8, W0
002038  021E60     CALL OS_TCBInit
00203A  000000     NOP
00203C  784400     MOV.B W0, W8
247:                       if (err == OS_ERR_NONE) {
00203E  E00408     CP0.B W8
002040  3A0006     BRA NZ, 0x204E
248:                           if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
002042  BFC966     MOV.B OSRunning, WREG
002044  504FE1     SUB.B W0, #0x1, [W15]
002046  3A000B     BRA NZ, 0x205E
249:                               OS_Sched();
002048  021D24     CALL OS_Sched
00204A  000000     NOP
00204C  370008     BRA 0x205E
250:                           }
251:                       } else {
252:                           OS_ENTER_CRITICAL();
00204E  800212     MOV SR, W2
002050  200E00     MOV #0xE0, W0
002052  B72042     IOR SR
253:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
002054  EB0C80     CLR [W9]
254:                           OS_EXIT_CRITICAL();
002056  880212     MOV W2, SR
002058  370002     BRA 0x205E
255:                       }
256:                       return (err);
257:                   }
258:                   OS_EXIT_CRITICAL();
00205A  880213     MOV W3, SR
259:                   return (OS_ERR_PRIO_EXIST);
00205C  B3C288     MOV.B #0x28, W8
260:               }
00205E  784008     MOV.B W8, W0
002060  BE044F     MOV.D [--W15], W8
002062  060000     RETURN
261:               #endif
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                  CREATE A TASK (Extended Version)
266:               *
267:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
268:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
269:               *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
270:               *              additional information about a task to be specified.
271:               *
272:               * Arguments  : task      is a pointer to the task's code
273:               *
274:               *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
275:               *                        the task when the task first executes.  Where the task is concerned it thinks
276:               *                        it was invoked and passed the argument 'p_arg' as follows:
277:               *
278:               *                            void Task (void *p_arg)
279:               *                            {
280:               *                                for (;;) {
281:               *                                    Task code;
282:               *                                }
283:               *                            }
284:               *
285:               *              ptos      is a pointer to the task's top of stack.  If the configuration constant
286:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
287:               *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
288:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
289:               *                        lowest memory location of the stack and the stack will grow with increasing
290:               *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
291:               *
292:               *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
293:               *                        lower the number, the higher the priority.
294:               *
295:               *              id        is the task's ID (0..65535)
296:               *
297:               *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
298:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
299:               *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
300:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
301:               *                        HIGHEST memory location of the stack and the stack will grow with increasing
302:               *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
303:               *
304:               *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
305:               *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
306:               *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
307:               *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
308:               *                        available on the stack.
309:               *
310:               *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
311:               *                        For example, this user memory can hold the contents of floating-point registers
312:               *                        during a context switch, the time each task takes to execute, the number of times
313:               *                        the task has been switched-in, etc.
314:               *
315:               *              opt       contains additional information (or options) about the behavior of the task.  The
316:               *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
317:               *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
318:               *
319:               *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
320:               *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
321:               *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
322:               *                                                 during a context switch.
323:               *
324:               * Returns    : OS_ERR_NONE                      if the function was successful.
325:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
326:               *                                               (each task MUST have a unique priority).
327:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
328:               *                                               allowed (i.e. > OS_LOWEST_PRIO)
329:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
330:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
331:               *                                               operation started.
332:               *********************************************************************************************************
333:               */
334:               /*$PAGE*/
335:               #if OS_TASK_CREATE_EXT_EN > 0u
336:               INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
337:                                       void    *p_arg,
338:                                       OS_STK  *ptos,
339:                                       INT8U    prio,
340:                                       INT16U   id,
341:                                       OS_STK  *pbos,
342:                                       INT32U   stk_size,
343:                                       void    *pext,
344:                                       INT16U   opt)
345:               {
0022DA  4787E8     ADD W15, #0x8, W15
0022DC  BE9F88     MOV.D W8, [W15++]
0022DE  BE9F8A     MOV.D W10, [W15++]
0022E0  BE9F8C     MOV.D W12, [W15++]
0022E2  781F8E     MOV W14, [W15++]
0022E4  9FBF80     MOV W0, [W15-16]
0022E6  9FB7F1     MOV W1, [W15-18]
0022E8  780702     MOV W2, W14
0022EA  784583     MOV.B W3, W11
0022EC  9FB7E4     MOV W4, [W15-20]
0022EE  780505     MOV W5, W10
0022F0  BE0406     MOV.D W6, W8
0022F2  97B69F     MOV [W15-30], W13
346:                   OS_STK     *psp;
347:                   INT8U       err;
348:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
349:                   OS_CPU_SR   cpu_sr = 0u;
350:               #endif
351:               
352:               
353:               
354:               #ifdef OS_SAFETY_CRITICAL_IEC61508
355:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
356:                       OS_SAFETY_CRITICAL_EXCEPTION();
357:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
358:                   }
359:               #endif
360:               
361:               #if OS_ARG_CHK_EN > 0u
362:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
363:                       return (OS_ERR_PRIO_INVALID);
364:                   }
365:               #endif
366:                   OS_ENTER_CRITICAL();
0022F4  800213     MOV SR, W3
0022F6  200E00     MOV #0xE0, W0
0022F8  B72042     IOR SR
367:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0022FA  E24960     CP0.B OSIntNesting
0022FC  320003     BRA Z, 0x2304
368:                       OS_EXIT_CRITICAL();
0022FE  880213     MOV W3, SR
369:                       return (OS_ERR_TASK_CREATE_ISR);
002300  B3C3C8     MOV.B #0x3C, W8
002302  37002E     BRA 0x2360
370:                   }
371:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
002304  FB860B     ZE W11, W12
002306  46060C     ADD W12, W12, W12
002308  20A741     MOV #0xA74, W1
00230A  7E0161     MOV [W1+W12], W2
00230C  E00002     CP0 W2
00230E  3A0026     BRA NZ, 0x235C
372:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
002310  40860C     ADD W1, W12, W12
002312  200011     MOV #0x1, W1
002314  780E01     MOV W1, [W12]
373:                                                            /* ... the same thing until task is created.              */
374:                       OS_EXIT_CRITICAL();
002316  880213     MOV W3, SR
375:               
376:               #if (OS_TASK_STAT_STK_CHK_EN > 0u)
377:                       OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
002318  78008D     MOV W13, W1
00231A  BE0106     MOV.D W6, W2
00231C  78000A     MOV W10, W0
00231E  07FFD2     RCALL OS_TaskStkClr
378:               #endif
379:               
380:                       psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
002320  78018D     MOV W13, W3
002322  78010E     MOV W14, W2
002324  97B0FF     MOV [W15-18], W1
002326  97B80F     MOV [W15-16], W0
002328  022C96     CALL OSTaskStkInit
00232A  000000     NOP
381:                       err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
00232C  78038D     MOV W13, W7
00232E  97B32F     MOV [W15-28], W6
002330  BE0208     MOV.D W8, W4
002332  97B1EF     MOV [W15-20], W3
002334  78010A     MOV W10, W2
002336  780080     MOV W0, W1
002338  78400B     MOV.B W11, W0
00233A  021E60     CALL OS_TCBInit
00233C  000000     NOP
00233E  784400     MOV.B W0, W8
382:                       if (err == OS_ERR_NONE) {
002340  E00408     CP0.B W8
002342  3A0006     BRA NZ, 0x2350
383:                           if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
002344  BFC966     MOV.B OSRunning, WREG
002346  504FE1     SUB.B W0, #0x1, [W15]
002348  3A000B     BRA NZ, 0x2360
384:                               OS_Sched();
00234A  021D24     CALL OS_Sched
00234C  000000     NOP
00234E  370008     BRA 0x2360
385:                           }
386:                       } else {
387:                           OS_ENTER_CRITICAL();
002350  800212     MOV SR, W2
002352  200E00     MOV #0xE0, W0
002354  B72042     IOR SR
388:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
002356  EB0E00     CLR [W12]
389:                           OS_EXIT_CRITICAL();
002358  880212     MOV W2, SR
00235A  370002     BRA 0x2360
390:                       }
391:                       return (err);
392:                   }
393:                   OS_EXIT_CRITICAL();
00235C  880213     MOV W3, SR
394:                   return (OS_ERR_PRIO_EXIST);
00235E  B3C288     MOV.B #0x28, W8
395:               }
002360  784008     MOV.B W8, W0
396:               #endif
397:               /*$PAGE*/
398:               /*
399:               *********************************************************************************************************
400:               *                                            DELETE A TASK
401:               *
402:               * Description: This function allows you to delete a task.  The calling task can delete itself by
403:               *              its own priority number.  The deleted task is returned to the dormant state and can be
404:               *              re-activated by creating the deleted task again.
405:               *
406:               * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
407:               *                      the current task without knowing its priority level by setting 'prio' to
408:               *                      OS_PRIO_SELF.
409:               *
410:               * Returns    : OS_ERR_NONE             if the call is successful
411:               *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
412:               *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
413:               *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
414:               *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
415:               *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
416:               *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
417:               *
418:               * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
419:               *                    a) by making it not ready
420:               *                    b) by removing it from any wait lists
421:               *                    c) by preventing OSTimeTick() from making the task ready to run.
422:               *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
423:               *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
424:               *                 the next instruction following the enable interrupt instruction is ignored.
425:               *              3) An ISR cannot delete a task.
426:               *              4) The lock nesting counter is incremented because, for a brief instant, if the current
427:               *                 task is being deleted, the current task would not be able to be rescheduled because it
428:               *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
429:               *                 from being schedule.  This means that an ISR would return to the current task which is
430:               *                 being deleted.  The rest of the deletion would thus be able to be completed.
431:               *********************************************************************************************************
432:               */
433:               
434:               #if OS_TASK_DEL_EN > 0u
435:               INT8U  OSTaskDel (INT8U prio)
436:               {
437:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
438:                   OS_FLAG_NODE *pnode;
439:               #endif
440:                   OS_TCB       *ptcb;
441:               #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
442:                   OS_CPU_SR     cpu_sr = 0u;
443:               #endif
444:               
445:               
446:               
447:                   if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
448:                       return (OS_ERR_TASK_DEL_ISR);
449:                   }
450:                   if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
451:                       return (OS_ERR_TASK_DEL_IDLE);
452:                   }
453:               #if OS_ARG_CHK_EN > 0u
454:                   if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
455:                       if (prio != OS_PRIO_SELF) {
456:                           return (OS_ERR_PRIO_INVALID);
457:                       }
458:                   }
459:               #endif
460:               
461:               /*$PAGE*/
462:                   OS_ENTER_CRITICAL();
463:                   if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
464:                       prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
465:                   }
466:                   ptcb = OSTCBPrioTbl[prio];
467:                   if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
468:                       OS_EXIT_CRITICAL();
469:                       return (OS_ERR_TASK_NOT_EXIST);
470:                   }
471:                   if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
472:                       OS_EXIT_CRITICAL();
473:                       return (OS_ERR_TASK_DEL);
474:                   }
475:               
476:                   OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
477:                   if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
478:                       OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
479:                   }
480:               
481:               #if (OS_EVENT_EN)
482:                   if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
483:                       OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
484:                   }
485:               #if (OS_EVENT_MULTI_EN > 0u)
486:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
487:                       OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
488:                   }
489:               #endif
490:               #endif
491:               
492:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
493:                   pnode = ptcb->OSTCBFlagNode;
494:                   if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
495:                       OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
496:                   }
497:               #endif
498:               
499:                   ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
500:                   ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
501:                   ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
502:                   if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
503:                       OSLockNesting++;
504:                   }
505:                   OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
506:                   OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
507:                   OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
508:                   if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
509:                       OSLockNesting--;
510:                   }
511:                   OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
512:               
513:               #if OS_TASK_CREATE_EXT_EN > 0u
514:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
515:                   OS_TLS_TaskDel(ptcb);                               /* Call TLS hook                               */
516:               #endif
517:               #endif
518:               
519:                   OSTaskCtr--;                                        /* One less task being managed                 */
520:                   OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
521:                   if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
522:                       ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
523:                       OSTCBList                  = ptcb->OSTCBNext;
524:                   } else {
525:                       ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
526:                       ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
527:                   }
528:                   ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
529:                   OSTCBFreeList       = ptcb;
530:               #if OS_TASK_NAME_EN > 0u
531:                   ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
532:               #endif
533:                   OS_EXIT_CRITICAL();
534:                   if (OSRunning == OS_TRUE) {
535:                       OS_Sched();                                     /* Find new highest priority task              */
536:                   }
537:                   return (OS_ERR_NONE);
538:               }
539:               #endif
540:               /*$PAGE*/
541:               /*
542:               *********************************************************************************************************
543:               *                                  REQUEST THAT A TASK DELETE ITSELF
544:               *
545:               * Description: This function is used to:
546:               *                   a) notify a task to delete itself.
547:               *                   b) to see if a task requested that the current task delete itself.
548:               *              This function is a little tricky to understand.  Basically, you have a task that needs
549:               *              to be deleted however, this task has resources that it has allocated (memory buffers,
550:               *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
551:               *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
552:               *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
553:               *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
554:               *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
555:               *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
556:               *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
557:               *              this:
558:               *
559:               *                   void Task(void *p_arg)
560:               *                   {
561:               *                       .
562:               *                       .
563:               *                       while (1) {
564:               *                           OSTimeDly(1);
565:               *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
566:               *                               Release any owned resources;
567:               *                               De-allocate any dynamic memory;
568:               *                               OSTaskDel(OS_PRIO_SELF);
569:               *                           }
570:               *                       }
571:               *                   }
572:               *
573:               * Arguments  : prio    is the priority of the task to request the delete from
574:               *
575:               * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
576:               *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
577:               *                                     the request has been executed.
578:               *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
579:               *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
580:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
581:               *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
582:               *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
583:               *                                     deleted.
584:               *********************************************************************************************************
585:               */
586:               /*$PAGE*/
587:               #if OS_TASK_DEL_EN > 0u
588:               INT8U  OSTaskDelReq (INT8U prio)
589:               {
590:                   INT8U      stat;
591:                   OS_TCB    *ptcb;
592:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
593:                   OS_CPU_SR  cpu_sr = 0u;
594:               #endif
595:               
596:               
597:               
598:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
599:                       return (OS_ERR_TASK_DEL_IDLE);
600:                   }
601:               #if OS_ARG_CHK_EN > 0u
602:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
603:                       if (prio != OS_PRIO_SELF) {
604:                           return (OS_ERR_PRIO_INVALID);
605:                       }
606:                   }
607:               #endif
608:                   if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
609:                       OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
610:                       stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
611:                       OS_EXIT_CRITICAL();
612:                       return (stat);
613:                   }
614:                   OS_ENTER_CRITICAL();
615:                   ptcb = OSTCBPrioTbl[prio];
616:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
617:                       OS_EXIT_CRITICAL();
618:                       return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
619:                   }
620:                   if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
621:                       OS_EXIT_CRITICAL();
622:                       return (OS_ERR_TASK_DEL);
623:                   }
624:                   ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
625:                   OS_EXIT_CRITICAL();
626:                   return (OS_ERR_NONE);
627:               }
628:               #endif
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                       GET THE NAME OF A TASK
633:               *
634:               * Description: This function is called to obtain the name of a task.
635:               *
636:               * Arguments  : prio      is the priority of the task that you want to obtain the name from.
637:               *
638:               *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
639:               *
640:               *              perr      is a pointer to an error code that can contain one of the following values:
641:               *
642:               *                        OS_ERR_NONE                if the requested task is resumed
643:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
644:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
645:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
646:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
647:               *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
648:               *
649:               *
650:               * Returns    : The length of the string or 0 if the task does not exist.
651:               *********************************************************************************************************
652:               */
653:               
654:               #if OS_TASK_NAME_EN > 0u
655:               INT8U  OSTaskNameGet (INT8U    prio,
656:                                     INT8U  **pname,
657:                                     INT8U   *perr)
658:               {
002064  BE9F88     MOV.D W8, [W15++]
002066  784180     MOV.B W0, W3
002068  780402     MOV W2, W8
659:                   OS_TCB    *ptcb;
660:                   INT8U      len;
661:               #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
662:                   OS_CPU_SR  cpu_sr = 0u;
663:               #endif
664:               
665:               
666:               
667:               #ifdef OS_SAFETY_CRITICAL
668:                   if (perr == (INT8U *)0) {
669:                       OS_SAFETY_CRITICAL_EXCEPTION();
670:                       return (0u);
671:                   }
672:               #endif
673:               
674:               #if OS_ARG_CHK_EN > 0u
675:                   if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
676:                       if (prio != OS_PRIO_SELF) {
677:                           *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
678:                           return (0u);
679:                       }
680:                   }
681:                   if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
682:                       *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
683:                       return (0u);
684:                   }
685:               #endif
686:                   if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00206C  E24960     CP0.B OSIntNesting
00206E  3A000F     BRA NZ, 0x208E
687:                       *perr = OS_ERR_NAME_GET_ISR;
00206A  B3C110     MOV.B #0x11, W0
688:                       return (0u);
689:                   }
690:                   OS_ENTER_CRITICAL();
002070  800219     MOV SR, W9
002072  200E00     MOV #0xE0, W0
002074  B72042     IOR SR
691:                   if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
002076  41CFE1     ADD.B W3, #0x1, [W15]
002078  3A0002     BRA NZ, 0x207E
692:                       prio = OSTCBCur->OSTCBPrio;
00207A  805360     MOV OSTCBCur, W0
00207C  905980     MOV.B [W0+24], W3
693:                   }
694:                   ptcb = OSTCBPrioTbl[prio];
00207E  FB8003     ZE W3, W0
002080  400000     ADD W0, W0, W0
002082  20A742     MOV #0xA74, W2
002084  780062     MOV [W2+W0], W0
695:                   if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
002086  E00000     CP0 W0
002088  3A0005     BRA NZ, 0x2094
696:                       OS_EXIT_CRITICAL();                              /* No                                         */
00208A  880219     MOV W9, SR
697:                       *perr = OS_ERR_TASK_NOT_EXIST;
00208C  B3C430     MOV.B #0x43, W0
00208E  784C00     MOV.B W0, [W8]
698:                       return (0u);
002090  EB4000     CLR.B W0
002092  370008     BRA 0x20A4
699:                   }
700:                   if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
002094  500FE1     SUB W0, #0x1, [W15]
002096  32FFF9     BRA Z, 0x208A
701:                       OS_EXIT_CRITICAL();                              /* Yes                                        */
702:                       *perr = OS_ERR_TASK_NOT_EXIST;
703:                       return (0u);
704:                   }
705:                   *pname = ptcb->OSTCBTaskName;
002098  901800     MOV [W0+48], W0
00209A  780880     MOV W0, [W1]
706:                   len    = OS_StrLen(*pname);
00209C  021D9C     CALL OS_StrLen
00209E  000000     NOP
707:                   OS_EXIT_CRITICAL();
0020A0  880219     MOV W9, SR
708:                   *perr  = OS_ERR_NONE;
0020A2  EB4C00     CLR.B [W8]
709:                   return (len);
710:               }
0020A4  BE044F     MOV.D [--W15], W8
0020A6  060000     RETURN
711:               #endif
712:               
713:               /*$PAGE*/
714:               /*
715:               *********************************************************************************************************
716:               *                                       ASSIGN A NAME TO A TASK
717:               *
718:               * Description: This function is used to set the name of a task.
719:               *
720:               * Arguments  : prio      is the priority of the task that you want the assign a name to.
721:               *
722:               *              pname     is a pointer to an ASCII string that contains the name of the task.
723:               *
724:               *              perr       is a pointer to an error code that can contain one of the following values:
725:               *
726:               *                        OS_ERR_NONE                if the requested task is resumed
727:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
728:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
729:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
730:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
731:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
732:               *
733:               * Returns    : None
734:               *********************************************************************************************************
735:               */
736:               #if OS_TASK_NAME_EN > 0u
737:               void  OSTaskNameSet (INT8U   prio,
738:                                    INT8U  *pname,
739:                                    INT8U  *perr)
740:               {
0020A8  784280     MOV.B W0, W5
741:                   OS_TCB    *ptcb;
742:               #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
743:                   OS_CPU_SR  cpu_sr = 0u;
744:               #endif
745:               
746:               
747:               
748:               #ifdef OS_SAFETY_CRITICAL
749:                   if (perr == (INT8U *)0) {
750:                       OS_SAFETY_CRITICAL_EXCEPTION();
751:                       return;
752:                   }
753:               #endif
754:               
755:               #if OS_ARG_CHK_EN > 0u
756:                   if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
757:                       if (prio != OS_PRIO_SELF) {
758:                           *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
759:                           return;
760:                       }
761:                   }
762:                   if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
763:                       *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
764:                       return;
765:                   }
766:               #endif
767:                   if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
0020AC  E24960     CP0.B OSIntNesting
0020AE  3A0011     BRA NZ, 0x20D2
768:                       *perr = OS_ERR_NAME_SET_ISR;
0020AA  B3C120     MOV.B #0x12, W0
769:                       return;
770:                   }
771:                   OS_ENTER_CRITICAL();
0020B0  800213     MOV SR, W3
0020B2  200E00     MOV #0xE0, W0
0020B4  B72042     IOR SR
772:                   if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
0020B6  42CFE1     ADD.B W5, #0x1, [W15]
0020B8  3A0002     BRA NZ, 0x20BE
773:                       prio = OSTCBCur->OSTCBPrio;
0020BA  805360     MOV OSTCBCur, W0
0020BC  905A80     MOV.B [W0+24], W5
774:                   }
775:                   ptcb = OSTCBPrioTbl[prio];
0020BE  FB8005     ZE W5, W0
0020C0  400000     ADD W0, W0, W0
0020C2  20A744     MOV #0xA74, W4
0020C4  780064     MOV [W4+W0], W0
776:                   if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
0020C6  E00000     CP0 W0
0020C8  320002     BRA Z, 0x20CE
777:                       OS_EXIT_CRITICAL();                          /* No                                             */
778:                       *perr = OS_ERR_TASK_NOT_EXIST;
779:                       return;
780:                   }
781:                   if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
0020CA  500FE1     SUB W0, #0x1, [W15]
0020CC  3A0004     BRA NZ, 0x20D6
782:                       OS_EXIT_CRITICAL();                          /* Yes                                            */
0020CE  880213     MOV W3, SR
783:                       *perr = OS_ERR_TASK_NOT_EXIST;
0020D0  B3C430     MOV.B #0x43, W0
0020D2  784900     MOV.B W0, [W2]
784:                       return;
0020D4  060000     RETURN
785:                   }
786:                   ptcb->OSTCBTaskName = pname;
0020D6  981801     MOV W1, [W0+48]
787:                   OS_EXIT_CRITICAL();
0020D8  880213     MOV W3, SR
788:                   *perr               = OS_ERR_NONE;
0020DA  EB4900     CLR.B [W2]
0020DC  060000     RETURN
789:               }
790:               #endif
791:               
792:               /*$PAGE*/
793:               /*
794:               *********************************************************************************************************
795:               *                                       RESUME A SUSPENDED TASK
796:               *
797:               * Description: This function is called to resume a previously suspended task.  This is the only call that
798:               *              will remove an explicit task suspension.
799:               *
800:               * Arguments  : prio     is the priority of the task to resume.
801:               *
802:               * Returns    : OS_ERR_NONE                if the requested task is resumed
803:               *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
804:               *                                         (i.e. >= OS_LOWEST_PRIO)
805:               *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
806:               *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
807:               *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
808:               *********************************************************************************************************
809:               */
810:               
811:               #if OS_TASK_SUSPEND_EN > 0u
812:               INT8U  OSTaskResume (INT8U prio)
813:               {
0020DE  784180     MOV.B W0, W3
814:                   OS_TCB    *ptcb;
815:               #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
816:                   OS_CPU_SR  cpu_sr = 0u;
817:               #endif
818:               
819:               
820:               
821:               #if OS_ARG_CHK_EN > 0u
822:                   if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
823:                       return (OS_ERR_PRIO_INVALID);
824:                   }
825:               #endif
826:                   OS_ENTER_CRITICAL();
0020E0  800211     MOV SR, W1
0020E2  200E00     MOV #0xE0, W0
0020E4  B72042     IOR SR
827:                   ptcb = OSTCBPrioTbl[prio];
0020E6  FB8003     ZE W3, W0
0020E8  400000     ADD W0, W0, W0
0020EA  20A742     MOV #0xA74, W2
0020EC  7802E2     MOV [W2+W0], W5
828:                   if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
0020EE  E00005     CP0 W5
0020F0  3A0002     BRA NZ, 0x20F6
829:                       OS_EXIT_CRITICAL();
0020F2  880211     MOV W1, SR
830:                       return (OS_ERR_TASK_RESUME_PRIO);
0020F4  050460     RETLW #0x46, W0
831:                   }
832:                   if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
0020F6  528FE1     SUB W5, #0x1, [W15]
0020F8  3A0002     BRA NZ, 0x20FE
833:                       OS_EXIT_CRITICAL();
0020FA  880211     MOV W1, SR
834:                       return (OS_ERR_TASK_NOT_EXIST);
0020FC  050430     RETLW #0x43, W0
835:                   }
836:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
0020FE  905165     MOV.B [W5+22], W2
002100  A33802     BTST.Z W2, #3
002102  32001D     BRA Z, 0x213E
837:                       ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
002104  A13402     BCLR.B W2, #3
002106  9852E2     MOV.B W2, [W5+22]
838:                       if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) == OS_STAT_RDY) { /* See if task is now ready         */
002108  B20372     AND #0x37, W2
00210A  3A0017     BRA NZ, 0x213A
839:                           if (ptcb->OSTCBDly == 0u) {
00210C  900915     MOV [W5+18], W2
00210E  9009A5     MOV [W5+20], W3
002110  510FE0     SUB W2, #0x0, [W15]
002112  598FE0     SUBB W3, #0x0, [W15]
002114  3A0012     BRA NZ, 0x213A
840:                               OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
002116  905845     MOV.B [W5+28], W0
002118  B76964     IOR.B OSRdyGrp
841:                               OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00211A  905925     MOV.B [W5+26], W2
00211C  FB8102     ZE W2, W2
00211E  209653     MOV #0x965, W3
002120  794263     MOV.B [W3+W2], W4
002122  905835     MOV.B [W5+27], W0
002124  724000     IOR.B W4, W0, W0
002126  797180     MOV.B W0, [W3+W2]
842:                               OS_EXIT_CRITICAL();
002128  880211     MOV W1, SR
843:                               if (OSRunning == OS_TRUE) {
00212C  209661     MOV #0x966, W1
00212E  784091     MOV.B [W1], W1
002130  50CFE1     SUB.B W1, #0x1, [W15]
002132  3A0007     BRA NZ, 0x2142
844:                                   OS_Sched();                               /* Find new highest priority task        */
002134  021D24     CALL OS_Sched
002136  000000     NOP
002138  370001     BRA 0x213C
845:                               }
846:                           } else {
847:                               OS_EXIT_CRITICAL();
848:                           }
849:                       } else {                                              /* Must be pending on event              */
850:                           OS_EXIT_CRITICAL();
00213A  880211     MOV W1, SR
851:                       }
852:                       return (OS_ERR_NONE);
00212A  EB4000     CLR.B W0
00213C  050000     RETLW #0x0, W0
853:                   }
854:                   OS_EXIT_CRITICAL();
00213E  880211     MOV W1, SR
855:                   return (OS_ERR_TASK_NOT_SUSPENDED);
002140  B3C440     MOV.B #0x44, W0
856:               }
002142  060000     RETURN
857:               #endif
858:               /*$PAGE*/
859:               /*
860:               *********************************************************************************************************
861:               *                                           STACK CHECKING
862:               *
863:               * Description: This function is called to check the amount of free memory left on the specified task's
864:               *              stack.
865:               *
866:               * Arguments  : prio          is the task priority
867:               *
868:               *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
869:               *
870:               * Returns    : OS_ERR_NONE            upon success
871:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
872:               *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
873:               *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
874:               *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
875:               *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
876:               *********************************************************************************************************
877:               */
878:               #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
879:               INT8U  OSTaskStkChk (INT8U         prio,
880:                                    OS_STK_DATA  *p_stk_data)
881:               {
002144  784200     MOV.B W0, W4
882:                   OS_TCB    *ptcb;
883:                   OS_STK    *pchk;
884:                   INT32U     nfree;
885:                   INT32U     size;
886:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
887:                   OS_CPU_SR  cpu_sr = 0u;
888:               #endif
889:               
890:               
891:               
892:               #if OS_ARG_CHK_EN > 0u
893:                   if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
894:                       if (prio != OS_PRIO_SELF) {
895:                           return (OS_ERR_PRIO_INVALID);
896:                       }
897:                   }
898:                   if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
899:                       return (OS_ERR_PDATA_NULL);
900:                   }
901:               #endif
902:                   p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
002146  EB0880     CLR [W1]
002148  7810B1     MOV [W1++], [W1--]
903:                   p_stk_data->OSUsed = 0u;
00214A  B81160     MUL.UU W2, #0, W2
00214C  9800A2     MOV W2, [W1+4]
00214E  9800B3     MOV W3, [W1+6]
904:                   OS_ENTER_CRITICAL();
002150  800213     MOV SR, W3
002152  200E00     MOV #0xE0, W0
002154  B72042     IOR SR
905:                   if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
002156  424FE1     ADD.B W4, #0x1, [W15]
002158  3A0002     BRA NZ, 0x215E
906:                       prio = OSTCBCur->OSTCBPrio;
00215A  805360     MOV OSTCBCur, W0
00215C  905A00     MOV.B [W0+24], W4
907:                   }
908:                   ptcb = OSTCBPrioTbl[prio];
00215E  FB8004     ZE W4, W0
002160  400000     ADD W0, W0, W0
002162  20A742     MOV #0xA74, W2
002164  780062     MOV [W2+W0], W0
909:                   if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
002166  E00000     CP0 W0
002168  320002     BRA Z, 0x216E
910:                       OS_EXIT_CRITICAL();
911:                       return (OS_ERR_TASK_NOT_EXIST);
912:                   }
913:                   if (ptcb == OS_TCB_RESERVED) {
00216A  500FE1     SUB W0, #0x1, [W15]
00216C  3A0002     BRA NZ, 0x2172
914:                       OS_EXIT_CRITICAL();
00216E  880213     MOV W3, SR
915:                       return (OS_ERR_TASK_NOT_EXIST);
002170  050430     RETLW #0x43, W0
916:                   }
917:                   if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
002172  900150     MOV [W0+10], W2
002174  A30802     BTST.Z W2, #0
002176  3A0002     BRA NZ, 0x217C
918:                       OS_EXIT_CRITICAL();
002178  880213     MOV W3, SR
919:                       return (OS_ERR_TASK_OPT);
00217A  050450     RETLW #0x45, W0
920:                   }
921:                   nfree = 0u;
002184  B81160     MUL.UU W2, #0, W2
922:                   size  = ptcb->OSTCBStkSize;
00217C  900230     MOV [W0+6], W4
00217E  9002C0     MOV [W0+8], W5
923:                   pchk  = ptcb->OSTCBStkBottom;
002180  900020     MOV [W0+4], W0
924:                   OS_EXIT_CRITICAL();
002182  880213     MOV W3, SR
925:               #if OS_STK_GROWTH == 1u
926:                   while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
927:                       nfree++;
928:                   }
929:               #else
930:                   while (*pchk-- == (OS_STK)0) {
002186  370002     BRA 0x218C
00218C  E00020     CP0 [W0--]
00218E  32FFFC     BRA Z, 0x2188
931:                       nfree++;
002188  410161     ADD W2, #0x1, W2
00218A  4981E0     ADDC W3, #0x0, W3
932:                   }
933:               #endif
934:                   p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
002190  BE8882     MOV.D W2, [W1]
935:                   p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
002192  520102     SUB W4, W2, W2
002194  5A8183     SUBB W5, W3, W3
002196  9800A2     MOV W2, [W1+4]
002198  9800B3     MOV W3, [W1+6]
936:                   return (OS_ERR_NONE);
00219A  050000     RETLW #0x0, W0
937:               }
938:               #endif
939:               /*$PAGE*/
940:               /*
941:               *********************************************************************************************************
942:               *                                           SUSPEND A TASK
943:               *
944:               * Description: This function is called to suspend a task.  The task can be the calling task if the
945:               *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
946:               *
947:               * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
948:               *                       calling task will suspend itself and rescheduling will occur.
949:               *
950:               * Returns    : OS_ERR_NONE               if the requested task is suspended
951:               *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
952:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
953:               *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
954:               *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
955:               *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
956:               *
957:               * Note       : You should use this function with great care.  If you suspend a task that is waiting for
958:               *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
959:               *              running when the event arrives.
960:               *********************************************************************************************************
961:               */
962:               
963:               #if OS_TASK_SUSPEND_EN > 0u
964:               INT8U  OSTaskSuspend (INT8U prio)
965:               {
00219C  784200     MOV.B W0, W4
966:                   BOOLEAN    self;
967:                   OS_TCB    *ptcb;
968:                   INT8U      y;
969:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
970:                   OS_CPU_SR  cpu_sr = 0u;
971:               #endif
972:               
973:               
974:               
975:               #if OS_ARG_CHK_EN > 0u
976:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
977:                       return (OS_ERR_TASK_SUSPEND_IDLE);
978:                   }
979:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
980:                       if (prio != OS_PRIO_SELF) {
981:                           return (OS_ERR_PRIO_INVALID);
982:                       }
983:                   }
984:               #endif
985:                   OS_ENTER_CRITICAL();
00219E  800212     MOV SR, W2
0021A0  200E00     MOV #0xE0, W0
0021A2  B72042     IOR SR
0021A4  805361     MOV OSTCBCur, W1
986:                   if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
0021A6  424FE1     ADD.B W4, #0x1, [W15]
0021A8  3A0002     BRA NZ, 0x21AE
987:                       prio = OSTCBCur->OSTCBPrio;
0021AA  905A01     MOV.B [W1+24], W4
0021AC  370004     BRA 0x21B6
988:                       self = OS_TRUE;
989:                   } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
0021AE  905981     MOV.B [W1+24], W3
0021B2  524F83     SUB.B W4, W3, [W15]
0021B4  3A0001     BRA NZ, 0x21B8
990:                       self = OS_TRUE;
0021B6  B3C011     MOV.B #0x1, W1
991:                   } else {
992:                       self = OS_FALSE;                                        /* No suspending another task          */
0021B0  EB4080     CLR.B W1
993:                   }
994:                   ptcb = OSTCBPrioTbl[prio];
0021B8  FB8004     ZE W4, W0
0021BA  400000     ADD W0, W0, W0
0021BC  20A743     MOV #0xA74, W3
0021BE  780063     MOV [W3+W0], W0
995:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
0021C0  E00000     CP0 W0
0021C2  3A0002     BRA NZ, 0x21C8
996:                       OS_EXIT_CRITICAL();
0021C4  880212     MOV W2, SR
997:                       return (OS_ERR_TASK_SUSPEND_PRIO);
0021C6  050480     RETLW #0x48, W0
998:                   }
999:                   if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
0021C8  500FE1     SUB W0, #0x1, [W15]
0021CA  3A0002     BRA NZ, 0x21D0
1000:                      OS_EXIT_CRITICAL();
0021CC  880212     MOV W2, SR
1001:                      return (OS_ERR_TASK_NOT_EXIST);
0021CE  050430     RETLW #0x43, W0
1002:                  }
1003:                  y            = ptcb->OSTCBY;
1004:                  OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
0021D0  905A20     MOV.B [W0+26], W4
0021D2  FB8204     ZE W4, W4
0021D4  209655     MOV #0x965, W5
0021D6  9059B0     MOV.B [W0+27], W3
0021D8  EAC183     COM.B W3, W3
0021DA  7A4365     MOV.B [W5+W4], W6
0021DC  61C186     AND.B W3, W6, W3
0021DE  7A7283     MOV.B W3, [W5+W4]
1005:                  if (OSRdyTbl[y] == 0u) {
0021E0  3A0004     BRA NZ, 0x21EA
1006:                      OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0021E2  9059C0     MOV.B [W0+28], W3
0021E4  EAC183     COM.B W3, W3
0021E6  209644     MOV #0x964, W4
0021E8  61CA14     AND.B W3, [W4], [W4]
1007:                  }
1008:                  ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
0021EA  9051E0     MOV.B [W0+22], W3
0021EC  A03403     BSET.B W3, #3
0021EE  985063     MOV.B W3, [W0+22]
1009:                  OS_EXIT_CRITICAL();
0021F0  880212     MOV W2, SR
1010:                  if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
0021F4  50CFE1     SUB.B W1, #0x1, [W15]
0021F6  3A0003     BRA NZ, 0x21FE
1011:                      OS_Sched();                                             /* Find new highest priority task      */
0021F8  021D24     CALL OS_Sched
0021FA  000000     NOP
1012:                  }
1013:                  return (OS_ERR_NONE);
0021F2  EB4000     CLR.B W0
0021FC  EB4000     CLR.B W0
1014:              }
0021FE  060000     RETURN
1015:              #endif
1016:              /*$PAGE*/
1017:              /*
1018:              *********************************************************************************************************
1019:              *                                            QUERY A TASK
1020:              *
1021:              * Description: This function is called to obtain a copy of the desired task's TCB.
1022:              *
1023:              * Arguments  : prio         is the priority of the task to obtain information from.
1024:              *
1025:              *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
1026:              *
1027:              * Returns    : OS_ERR_NONE            if the requested task is suspended
1028:              *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
1029:              *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
1030:              *              OS_ERR_PRIO            if the desired task has not been created
1031:              *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
1032:              *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
1033:              *********************************************************************************************************
1034:              */
1035:              
1036:              #if OS_TASK_QUERY_EN > 0u
1037:              INT8U  OSTaskQuery (INT8U    prio,
1038:                                  OS_TCB  *p_task_data)
1039:              {
002200  781F88     MOV W8, [W15++]
002202  784100     MOV.B W0, W2
002204  780181     MOV W1, W3
1040:                  OS_TCB    *ptcb;
1041:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1042:                  OS_CPU_SR  cpu_sr = 0u;
1043:              #endif
1044:              
1045:              
1046:              
1047:              #if OS_ARG_CHK_EN > 0u
1048:                  if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
1049:                      if (prio != OS_PRIO_SELF) {
1050:                          return (OS_ERR_PRIO_INVALID);
1051:                      }
1052:                  }
1053:                  if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
1054:                      return (OS_ERR_PDATA_NULL);
1055:                  }
1056:              #endif
1057:                  OS_ENTER_CRITICAL();
002206  800218     MOV SR, W8
002208  200E00     MOV #0xE0, W0
00220A  B72042     IOR SR
1058:                  if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00220C  414FE1     ADD.B W2, #0x1, [W15]
00220E  3A0002     BRA NZ, 0x2214
1059:                      prio = OSTCBCur->OSTCBPrio;
002210  805361     MOV OSTCBCur, W1
002212  905901     MOV.B [W1+24], W2
1060:                  }
1061:                  ptcb = OSTCBPrioTbl[prio];
002214  FB8102     ZE W2, W2
002216  410102     ADD W2, W2, W2
002218  20A741     MOV #0xA74, W1
00221A  7900E1     MOV [W1+W2], W1
1062:                  if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00221C  E00001     CP0 W1
00221E  3A0003     BRA NZ, 0x2226
1063:                      OS_EXIT_CRITICAL();
002220  880218     MOV W8, SR
1064:                      return (OS_ERR_PRIO);
002222  B3C290     MOV.B #0x29, W0
002224  37000B     BRA 0x223C
1065:                  }
1066:                  if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
002226  508FE1     SUB W1, #0x1, [W15]
002228  3A0003     BRA NZ, 0x2230
1067:                      OS_EXIT_CRITICAL();
00222A  880218     MOV W8, SR
1068:                      return (OS_ERR_TASK_NOT_EXIST);
00222C  B3C430     MOV.B #0x43, W0
00222E  370006     BRA 0x223C
1069:                  }
1070:                                                               /* Copy TCB into user storage area                    */
1071:                  OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
002230  200362     MOV #0x36, W2
002232  780003     MOV W3, W0
002234  021D18     CALL OS_MemCopy
002236  000000     NOP
1072:                  OS_EXIT_CRITICAL();
002238  880218     MOV W8, SR
1073:                  return (OS_ERR_NONE);
00223A  EB4000     CLR.B W0
1074:              }
00223C  78044F     MOV [--W15], W8
00223E  060000     RETURN
1075:              #endif
1076:              /*$PAGE*/
1077:              /*
1078:              *********************************************************************************************************
1079:              *                              GET THE CURRENT VALUE OF A TASK REGISTER
1080:              *
1081:              * Description: This function is called to obtain the current value of a task register.  Task registers
1082:              *              are application specific and can be used to store task specific values such as 'error
1083:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1084:              *
1085:              * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
1086:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1087:              *
1088:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1089:              *                        than OS_TASK_REG_TBL_SIZE
1090:              *
1091:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1092:              *
1093:              *                        OS_ERR_NONE            if the call was successful
1094:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1095:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1096:              *
1097:              * Returns    : The current value of the task's register or 0 if an error is detected.
1098:              *
1099:              * Note(s)    : The maximum number of task variables is 254
1100:              *********************************************************************************************************
1101:              */
1102:              
1103:              #if OS_TASK_REG_TBL_SIZE > 0u
1104:              INT32U  OSTaskRegGet (INT8U   prio,
1105:                                    INT8U   id,
1106:                                    INT8U  *perr)
1107:              {
002240  784280     MOV.B W0, W5
1108:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1109:                  OS_CPU_SR  cpu_sr = 0u;
1110:              #endif
1111:                  INT32U     value;
1112:                  OS_TCB    *ptcb;
1113:              
1114:              
1115:              
1116:              #ifdef OS_SAFETY_CRITICAL
1117:                  if (perr == (INT8U *)0) {
1118:                      OS_SAFETY_CRITICAL_EXCEPTION();
1119:                      return (0u);
1120:                  }
1121:              #endif
1122:              
1123:              #if OS_ARG_CHK_EN > 0u
1124:                  if (prio >= OS_LOWEST_PRIO) {
1125:                      if (prio != OS_PRIO_SELF) {
1126:                          *perr = OS_ERR_PRIO_INVALID;
1127:                          return (0u);
1128:                      }
1129:                  }
1130:                  if (id >= OS_TASK_REG_TBL_SIZE) {
1131:                      *perr = OS_ERR_ID_INVALID;
1132:                      return (0u);
1133:                  }
1134:              #endif
1135:                  OS_ENTER_CRITICAL();
002242  800213     MOV SR, W3
002244  200E00     MOV #0xE0, W0
002246  B72042     IOR SR
1136:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
002248  42CFE1     ADD.B W5, #0x1, [W15]
00224A  3A0002     BRA NZ, 0x2250
1137:                      ptcb = OSTCBCur;
00224C  805360     MOV OSTCBCur, W0
00224E  370004     BRA 0x2258
1138:                  } else {
1139:                      ptcb = OSTCBPrioTbl[prio];
002250  FB8005     ZE W5, W0
002252  400000     ADD W0, W0, W0
002254  20A744     MOV #0xA74, W4
002256  780064     MOV [W4+W0], W0
1140:                  }
1141:                  value = ptcb->OSTCBRegTbl[id];
002258  FB8081     ZE W1, W1
00225A  DD08C2     SL W1, #2, W1
00225C  400001     ADD W0, W1, W0
00225E  9018A0     MOV [W0+52], W1
002260  901810     MOV [W0+50], W0
1142:                  OS_EXIT_CRITICAL();
002262  880213     MOV W3, SR
1143:                  *perr = OS_ERR_NONE;
002264  EB4900     CLR.B [W2]
1144:                  return (value);
1145:              }
002266  060000     RETURN
1146:              #endif
1147:              
1148:              /*$PAGE*/
1149:              /*
1150:              ************************************************************************************************************************
1151:              *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
1152:              *
1153:              * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
1154:              *              allocated dynamically instead of statically.
1155:              *
1156:              * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
1157:              *
1158:              *                            OS_ERR_NONE               if the call was successful
1159:              *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
1160:              *                                                           have available through OS_TASK_REG_TBL_SIZE.
1161:              *
1162:              * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
1163:              ************************************************************************************************************************
1164:              */
1165:              
1166:              #if OS_TASK_REG_TBL_SIZE > 0u
1167:              INT8U  OSTaskRegGetID (INT8U  *perr)
1168:              {
002268  780280     MOV W0, W5
1169:              #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
1170:                  OS_CPU_SR  cpu_sr = 0u;
1171:              #endif
1172:                  INT8U      id;
1173:              
1174:              
1175:              #ifdef OS_SAFETY_CRITICAL
1176:                  if (perr == (INT8U *)0) {
1177:                      OS_SAFETY_CRITICAL_EXCEPTION();
1178:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
1179:                  }
1180:              #endif
1181:              
1182:                  OS_ENTER_CRITICAL();
00226A  800212     MOV SR, W2
00226C  200E00     MOV #0xE0, W0
00226E  B72042     IOR SR
1183:                  if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
002270  20B561     MOV #0xB56, W1
002272  784091     MOV.B [W1], W1
002274  E00401     CP0.B W1
002276  320004     BRA Z, 0x2280
1184:                     *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
002278  B3C961     MOV.B #0x96, W1
00227A  784A81     MOV.B W1, [W5]
1185:                      OS_EXIT_CRITICAL();
00227C  880212     MOV W2, SR
1186:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
00227E  050010     RETLW #0x1, W0
1187:                  }
1188:                   
1189:                  id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
1190:                  OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
002280  B3C013     MOV.B #0x1, W3
002282  20B564     MOV #0xB56, W4
002284  784A03     MOV.B W3, [W4]
1191:                  OS_EXIT_CRITICAL();
002286  880212     MOV W2, SR
1192:                 *perr = OS_ERR_NONE;
002288  784A81     MOV.B W1, [W5]
1193:                  return (id);
00228A  050000     RETLW #0x0, W0
1194:              }
1195:              #endif
1196:              
1197:              /*$PAGE*/
1198:              /*
1199:              *********************************************************************************************************
1200:              *                              SET THE CURRENT VALUE OF A TASK VARIABLE
1201:              *
1202:              * Description: This function is called to change the current value of a task register.  Task registers
1203:              *              are application specific and can be used to store task specific values such as 'error
1204:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1205:              *
1206:              * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
1207:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1208:              *
1209:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1210:              *                        than OS_TASK_REG_TBL_SIZE
1211:              *
1212:              *              value     is the desired value for the task register.
1213:              *
1214:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1215:              *
1216:              *                        OS_ERR_NONE            if the call was successful
1217:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1218:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1219:              *
1220:              * Returns    : The current value of the task's variable or 0 if an error is detected.
1221:              *
1222:              * Note(s)    : The maximum number of task variables is 254
1223:              *********************************************************************************************************
1224:              */
1225:              
1226:              #if OS_TASK_REG_TBL_SIZE > 0u
1227:              void  OSTaskRegSet (INT8U    prio,
1228:                                  INT8U    id,
1229:                                  INT32U   value,
1230:                                  INT8U   *perr)
1231:              {
00228C  784380     MOV.B W0, W7
1232:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1233:                  OS_CPU_SR  cpu_sr = 0u;
1234:              #endif
1235:                  OS_TCB    *ptcb;
1236:              
1237:              
1238:              #ifdef OS_SAFETY_CRITICAL
1239:                  if (perr == (INT8U *)0) {
1240:                      OS_SAFETY_CRITICAL_EXCEPTION();
1241:                      return;
1242:                  }
1243:              #endif
1244:              
1245:              #if OS_ARG_CHK_EN > 0u
1246:                  if (prio >= OS_LOWEST_PRIO) {
1247:                      if (prio != OS_PRIO_SELF) {
1248:                          *perr = OS_ERR_PRIO_INVALID;
1249:                          return;
1250:                      }
1251:                  }
1252:                  if (id >= OS_TASK_REG_TBL_SIZE) {
1253:                      *perr = OS_ERR_ID_INVALID;
1254:                      return;
1255:                  }
1256:              #endif
1257:                  OS_ENTER_CRITICAL();
00228E  800215     MOV SR, W5
002290  200E00     MOV #0xE0, W0
002292  B72042     IOR SR
1258:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
002294  43CFE1     ADD.B W7, #0x1, [W15]
002296  3A0002     BRA NZ, 0x229C
1259:                      ptcb = OSTCBCur;
002298  805360     MOV OSTCBCur, W0
00229A  370004     BRA 0x22A4
1260:                  } else {
1261:                      ptcb = OSTCBPrioTbl[prio];
00229C  FB8007     ZE W7, W0
00229E  400000     ADD W0, W0, W0
0022A0  20A746     MOV #0xA74, W6
0022A2  780066     MOV [W6+W0], W0
1262:                  }
1263:                  ptcb->OSTCBRegTbl[id] = value;
0022A4  FB8081     ZE W1, W1
0022A6  DD08C2     SL W1, #2, W1
0022A8  400001     ADD W0, W1, W0
0022AA  981812     MOV W2, [W0+50]
0022AC  981823     MOV W3, [W0+52]
1264:                  OS_EXIT_CRITICAL();
0022AE  880215     MOV W5, SR
1265:                  *perr                 = OS_ERR_NONE;
0022B0  EB4A00     CLR.B [W4]
1266:              }
0022B2  060000     RETURN
1267:              #endif
1268:              
1269:              /*$PAGE*/
1270:              /*
1271:              *********************************************************************************************************
1272:              *                                    CATCH ACCIDENTAL TASK RETURN
1273:              *
1274:              * Description: This function is called if a task accidentally returns without deleting itself.  In other
1275:              *              words, a task should either be an infinite loop or delete itself if it's done.
1276:              *
1277:              * Arguments  : none
1278:              *
1279:              * Returns    : none
1280:              *
1281:              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
1282:              *********************************************************************************************************
1283:              */
1284:              
1285:              void  OS_TaskReturn (void)
1286:              {
1287:                  OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
0022B4  805360     MOV OSTCBCur, W0
0022B6  022C8E     CALL OSTaskReturnHook
0022B8  000000     NOP
1288:              
1289:              #if OS_TASK_DEL_EN > 0u
1290:                  (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
1291:              #else
1292:                  for (;;) {
1293:                      OSTimeDly(OS_TICKS_PER_SEC);
0022BA  203E80     MOV #0x3E8, W0
0022BC  200001     MOV #0x0, W1
0022BE  022726     CALL OSTimeDly
0022C0  000000     NOP
0022C2  37FFFB     BRA 0x22BA
1294:                  }
1295:              #endif
1296:              }
1297:              
1298:              /*$PAGE*/
1299:              /*
1300:              *********************************************************************************************************
1301:              *                                          CLEAR TASK STACK
1302:              *
1303:              * Description: This function is used to clear the stack of a task (i.e. write all zeros)
1304:              *
1305:              * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
1306:              *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
1307:              *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
1308:              *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
1309:              *                       highest memory location of the stack and the stack will grow with increasing
1310:              *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
1311:              *
1312:              *              size     is the number of 'stack elements' to clear.
1313:              *
1314:              *              opt      contains additional information (or options) about the behavior of the task.  The
1315:              *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
1316:              *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
1317:              *
1318:              * Returns    : none
1319:              *********************************************************************************************************
1320:              */
1321:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1322:              void  OS_TaskStkClr (OS_STK  *pbos,
0022C4  6080E3     AND W1, #0x3, W1
1323:                                   INT32U   size,
1324:                                   INT16U   opt)
1325:              {
1326:                  if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
1327:                      if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
0022C6  508FE3     SUB W1, #0x3, [W15]
0022C8  320004     BRA Z, 0x22D2
0022CA  060000     RETURN
1328:              #if OS_STK_GROWTH == 1u
1329:                          while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
1330:                              size--;
1331:                              *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
1332:                          }
1333:              #else
1334:                          while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
0022D2  510FE0     SUB W2, #0x0, [W15]
0022D4  598FE0     SUBB W3, #0x0, [W15]
0022D6  3AFFFA     BRA NZ, 0x22CC
0022D8  060000     RETURN
1335:                              size--;
0022CC  510161     SUB W2, #0x1, W2
0022CE  5981E0     SUBB W3, #0x0, W3
1336:                              *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
0022D0  EB1000     CLR [W0--]
1337:                          }
1338:              #endif
1339:                      }
1340:                  }
1341:              }
1342:              
1343:              #endif
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uCOS-II/Source/os_core.c  ------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             CORE FUNCTIONS
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_CORE.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.10
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #define  OS_GLOBALS
28:                #include <ucos_ii.h>
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                      PRIORITY RESOLUTION TABLE
34:                *
35:                * Note: Index into table is bit pattern to resolve highest priority
36:                *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
37:                *********************************************************************************************************
38:                */
39:                
40:                INT8U  const  OSUnMapTbl[256] = {
41:                    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
42:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
43:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
44:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
45:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
46:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
47:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
48:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
49:                    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
50:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
51:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
52:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
53:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
54:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
55:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
56:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
57:                };
58:                
59:                /*$PAGE*/
60:                /*
61:                *********************************************************************************************************
62:                *                                         FUNCTION PROTOTYPES
63:                *********************************************************************************************************
64:                */
65:                
66:                static  void  OS_InitEventList(void);
67:                
68:                static  void  OS_InitMisc(void);
69:                
70:                static  void  OS_InitRdyList(void);
71:                
72:                static  void  OS_InitTaskIdle(void);
73:                
74:                #if OS_TASK_STAT_EN > 0u
75:                static  void  OS_InitTaskStat(void);
76:                #endif
77:                
78:                static  void  OS_InitTCBList(void);
79:                
80:                static  void  OS_SchedNew(void);
81:                
82:                /*$PAGE*/
83:                /*
84:                *********************************************************************************************************
85:                *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
86:                *
87:                * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
88:                *
89:                * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
90:                *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
91:                *                        type is irrelevant.
92:                *
93:                *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
94:                *                        mutex, mailbox or queue.
95:                *
96:                *              perr      is a pointer to an error code that can contain one of the following values:
97:                *
98:                *                        OS_ERR_NONE                if the name was copied to 'pname'
99:                *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
100:               *                                                   control block type.
101:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
102:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
103:               *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
104:               *
105:               * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
106:               *********************************************************************************************************
107:               */
108:               
109:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
110:               INT8U  OSEventNameGet (OS_EVENT   *pevent,
111:                                      INT8U     **pname,
112:                                      INT8U      *perr)
113:               {
114:                   INT8U      len;
115:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
116:                   OS_CPU_SR  cpu_sr = 0u;
117:               #endif
118:               
119:               
120:               
121:               #ifdef OS_SAFETY_CRITICAL
122:                   if (perr == (INT8U *)0) {
123:                       OS_SAFETY_CRITICAL_EXCEPTION();
124:                       return (0u);
125:                   }
126:               #endif
127:               
128:               #if OS_ARG_CHK_EN > 0u
129:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
130:                       *perr = OS_ERR_PEVENT_NULL;
131:                       return (0u);
132:                   }
133:                   if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
134:                       *perr = OS_ERR_PNAME_NULL;
135:                       return (0u);
136:                   }
137:               #endif
138:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
139:                       *perr  = OS_ERR_NAME_GET_ISR;
140:                       return (0u);
141:                   }
142:                   switch (pevent->OSEventType) {
143:                       case OS_EVENT_TYPE_SEM:
144:                       case OS_EVENT_TYPE_MUTEX:
145:                       case OS_EVENT_TYPE_MBOX:
146:                       case OS_EVENT_TYPE_Q:
147:                            break;
148:               
149:                       default:
150:                            *perr = OS_ERR_EVENT_TYPE;
151:                            return (0u);
152:                   }
153:                   OS_ENTER_CRITICAL();
154:                   *pname = pevent->OSEventName;
155:                   len    = OS_StrLen(*pname);
156:                   OS_EXIT_CRITICAL();
157:                   *perr  = OS_ERR_NONE;
158:                   return (len);
159:               }
160:               #endif
161:               
162:               /*$PAGE*/
163:               /*
164:               *********************************************************************************************************
165:               *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
166:               *
167:               * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
168:               *
169:               * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
170:               *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
171:               *                        matter the actual type.
172:               *
173:               *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
174:               *                        mutex, mailbox or queue.
175:               *
176:               *              perr      is a pointer to an error code that can contain one of the following values:
177:               *
178:               *                        OS_ERR_NONE                if the requested task is resumed
179:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
180:               *                                                   control block type.
181:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
182:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
183:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
184:               *
185:               * Returns    : None
186:               *********************************************************************************************************
187:               */
188:               
189:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
190:               void  OSEventNameSet (OS_EVENT  *pevent,
191:                                     INT8U     *pname,
192:                                     INT8U     *perr)
193:               {
194:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
195:                   OS_CPU_SR  cpu_sr = 0u;
196:               #endif
197:               
198:               
199:               
200:               #ifdef OS_SAFETY_CRITICAL
201:                   if (perr == (INT8U *)0) {
202:                       OS_SAFETY_CRITICAL_EXCEPTION();
203:                       return;
204:                   }
205:               #endif
206:               
207:               #if OS_ARG_CHK_EN > 0u
208:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
209:                       *perr = OS_ERR_PEVENT_NULL;
210:                       return;
211:                   }
212:                   if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
213:                       *perr = OS_ERR_PNAME_NULL;
214:                       return;
215:                   }
216:               #endif
217:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
218:                       *perr = OS_ERR_NAME_SET_ISR;
219:                       return;
220:                   }
221:                   switch (pevent->OSEventType) {
222:                       case OS_EVENT_TYPE_SEM:
223:                       case OS_EVENT_TYPE_MUTEX:
224:                       case OS_EVENT_TYPE_MBOX:
225:                       case OS_EVENT_TYPE_Q:
226:                            break;
227:               
228:                       default:
229:                            *perr = OS_ERR_EVENT_TYPE;
230:                            return;
231:                   }
232:                   OS_ENTER_CRITICAL();
233:                   pevent->OSEventName = pname;
234:                   OS_EXIT_CRITICAL();
235:                   *perr = OS_ERR_NONE;
236:               }
237:               #endif
238:               
239:               /*$PAGE*/
240:               /*
241:               *********************************************************************************************************
242:               *                                       PEND ON MULTIPLE EVENTS
243:               *
244:               * Description: This function waits for multiple events.  If multiple events are ready at the start of the
245:               *              pend call, then all available events are returned as ready.  If the task must pend on the
246:               *              multiple events, then only the first posted or aborted event is returned as ready.
247:               *
248:               * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
249:               *
250:               *              pevents_rdy   is a pointer to an array to return which event control blocks are available
251:               *                            or ready.  The size of the array MUST be greater than or equal to the size
252:               *                            of the 'pevents_pend' array, including terminating NULL.
253:               *
254:               *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
255:               *                            events.  The size of the array MUST be greater than or equal to the size of
256:               *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
257:               *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
258:               *                            every available message-type event returns its messages in the 'pmsgs_rdy'
259:               *                            array at the same index as the event is returned in the 'pevents_rdy' array.
260:               *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
261:               *
262:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
263:               *                            wait for the resources up to the amount of time specified by this argument.
264:               *                            If you specify 0, however, your task will wait forever for the specified
265:               *                            events or, until the resources becomes available (or the events occur).
266:               *
267:               *              perr          is a pointer to where an error message will be deposited.  Possible error
268:               *                            messages are:
269:               *
270:               *                            OS_ERR_NONE         The call was successful and your task owns the resources
271:               *                                                or, the events you are waiting for occurred; check the
272:               *                                                'pevents_rdy' array for which events are available.
273:               *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
274:               *                                                'pevents_rdy' array for which events were aborted.
275:               *                            OS_ERR_TIMEOUT      The events were not received within the specified
276:               *                                                'timeout'.
277:               *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
278:               *                                                NULL pointer.
279:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
280:               *                                                mailboxes, and/or queues.
281:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
282:               *                                                would lead to a suspension.
283:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
284:               *
285:               * Returns    : >  0          the number of events returned as ready or aborted.
286:               *              == 0          if no events are returned as ready because of timeout or upon error.
287:               *
288:               * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
289:               *
290:               *                        semaphores, mailboxes, queues
291:               *
292:               *                 b. Return ALL available events and messages, if any
293:               *
294:               *                 c. Add    current task priority as pending to   each events's wait list
295:               *                      Performed in OS_EventTaskWaitMulti()
296:               *
297:               *                 d. Wait on any of multiple events
298:               *
299:               *                 e. Remove current task priority as pending from each events's wait list
300:               *                      Performed in OS_EventTaskRdy(), if events posted or aborted
301:               *
302:               *                 f. Return any event posted or aborted, if any
303:               *                      else
304:               *                    Return timeout
305:               *
306:               *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
307:               *                 case of any error(s).
308:               *********************************************************************************************************
309:               */
310:               /*$PAGE*/
311:               #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
312:               INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
313:                                         OS_EVENT  **pevents_rdy,
314:                                         void      **pmsgs_rdy,
315:                                         INT32U      timeout,
316:                                         INT8U      *perr)
317:               {
318:                   OS_EVENT  **pevents;
319:                   OS_EVENT   *pevent;
320:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
321:                   OS_Q       *pq;
322:               #endif
323:                   BOOLEAN     events_rdy;
324:                   INT16U      events_rdy_nbr;
325:                   INT8U       events_stat;
326:               #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
327:                   OS_CPU_SR   cpu_sr = 0u;
328:               #endif
329:               
330:               
331:               
332:               #ifdef OS_SAFETY_CRITICAL
333:                   if (perr == (INT8U *)0) {
334:                       OS_SAFETY_CRITICAL_EXCEPTION();
335:                       return (0u);
336:                   }
337:               #endif
338:               
339:               #if (OS_ARG_CHK_EN > 0u)
340:                   if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
341:                      *perr =  OS_ERR_PEVENT_NULL;
342:                       return (0u);
343:                   }
344:                   if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
345:                      *perr =  OS_ERR_PEVENT_NULL;
346:                       return (0u);
347:                   }
348:                   if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
349:                      *perr =  OS_ERR_PEVENT_NULL;
350:                       return (0u);
351:                   }
352:                   if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
353:                      *perr =  OS_ERR_PEVENT_NULL;
354:                       return (0u);
355:                   }
356:               #endif
357:               
358:                  *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
359:               
360:                   pevents     =  pevents_pend;
361:                   pevent      = *pevents;
362:                   while  (pevent != (OS_EVENT *)0) {
363:                       switch (pevent->OSEventType) {                  /* Validate event block types                  */
364:               #if (OS_SEM_EN  > 0u)
365:                           case OS_EVENT_TYPE_SEM:
366:                                break;
367:               #endif
368:               #if (OS_MBOX_EN > 0u)
369:                           case OS_EVENT_TYPE_MBOX:
370:                                break;
371:               #endif
372:               #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
373:                           case OS_EVENT_TYPE_Q:
374:                                break;
375:               #endif
376:               
377:                           case OS_EVENT_TYPE_MUTEX:
378:                           case OS_EVENT_TYPE_FLAG:
379:                           default:
380:                               *perr = OS_ERR_EVENT_TYPE;
381:                                return (0u);
382:                       }
383:                       pevents++;
384:                       pevent = *pevents;
385:                   }
386:               
387:                   if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
388:                      *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
389:                       return (0u);
390:                   }
391:                   if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
392:                      *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
393:                       return (0u);
394:                   }
395:               
396:               /*$PAGE*/
397:                   events_rdy     =  OS_FALSE;
398:                   events_rdy_nbr =  0u;
399:                   events_stat    =  OS_STAT_RDY;
400:                   pevents        =  pevents_pend;
401:                   pevent         = *pevents;
402:                   OS_ENTER_CRITICAL();
403:                   while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
404:                       switch (pevent->OSEventType) {
405:               #if (OS_SEM_EN > 0u)
406:                           case OS_EVENT_TYPE_SEM:
407:                                if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
408:                                    pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
409:                                   *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
410:                                     events_rdy   =  OS_TRUE;
411:                                   *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
412:                                     events_rdy_nbr++;
413:               
414:                                } else {
415:                                     events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
416:                                }
417:                                break;
418:               #endif
419:               
420:               #if (OS_MBOX_EN > 0u)
421:                           case OS_EVENT_TYPE_MBOX:
422:                                if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
423:                                                                       /* ... return available message,           ... */
424:                                   *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
425:                                    pevent->OSEventPtr  = (void *)0;
426:                                   *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
427:                                     events_rdy         =  OS_TRUE;
428:                                     events_rdy_nbr++;
429:               
430:                                } else {
431:                                     events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
432:                                }
433:                                break;
434:               #endif
435:               
436:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
437:                           case OS_EVENT_TYPE_Q:
438:                                pq = (OS_Q *)pevent->OSEventPtr;
439:                                if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
440:                                                                       /* ... return available message,           ... */
441:                                   *pmsgs_rdy++ = (void *)*pq->OSQOut++;
442:                                    if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
443:                                        pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
444:                                    }
445:                                    pq->OSQEntries--;                  /* Update number of queue entries              */
446:                                   *pevents_rdy++ = pevent;            /* ... and return available queue event        */
447:                                     events_rdy   = OS_TRUE;
448:                                     events_rdy_nbr++;
449:               
450:                                } else {
451:                                     events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
452:                                }
453:                                break;
454:               #endif
455:               
456:                           case OS_EVENT_TYPE_MUTEX:
457:                           case OS_EVENT_TYPE_FLAG:
458:                           default:
459:                                OS_EXIT_CRITICAL();
460:                               *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
461:                               *perr        =  OS_ERR_EVENT_TYPE;
462:                                return (events_rdy_nbr);
463:                       }
464:                       pevents++;
465:                       pevent = *pevents;
466:                   }
467:               
468:                   if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
469:                      *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
470:                       OS_EXIT_CRITICAL();
471:                      *perr        =  OS_ERR_NONE;
472:                       return (events_rdy_nbr);
473:                   }
474:               /*$PAGE*/
475:                                                                       /* Otherwise, must wait until any event occurs */
476:                   OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
477:                                              OS_STAT_MULTI;           /* ... pend on multiple events                 */
478:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
479:                   OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
480:                   OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
481:               
482:                   OS_EXIT_CRITICAL();
483:                   OS_Sched();                                         /* Find next highest priority task ready       */
484:                   OS_ENTER_CRITICAL();
485:               
486:                   switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
487:                       case OS_STAT_PEND_OK:
488:                       case OS_STAT_PEND_ABORT:
489:                            pevent = OSTCBCur->OSTCBEventPtr;
490:                            if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
491:                               *pevents_rdy++   =  pevent;             /* ... return available event ...              */
492:                               *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
493:                                 events_rdy_nbr =  1;
494:               
495:                            } else {                                   /* Else NO event available, handle as timeout  */
496:                                OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
497:                                OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
498:                            }
499:                            break;
500:               
501:                       case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
502:                       default:                                        /* ... remove task from events' wait lists     */
503:                            OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
504:                            break;
505:                   }
506:               
507:                   switch (OSTCBCur->OSTCBStatPend) {
508:                       case OS_STAT_PEND_OK:
509:                            switch (pevent->OSEventType) {             /* Return event's message                      */
510:               #if (OS_SEM_EN > 0u)
511:                                case OS_EVENT_TYPE_SEM:
512:                                    *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
513:                                     break;
514:               #endif
515:               
516:               #if ((OS_MBOX_EN > 0u) ||                 \
517:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
518:                                case OS_EVENT_TYPE_MBOX:
519:                                case OS_EVENT_TYPE_Q:
520:                                    *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
521:                                     break;
522:               #endif
523:               
524:                                case OS_EVENT_TYPE_MUTEX:
525:                                case OS_EVENT_TYPE_FLAG:
526:                                default:
527:                                     OS_EXIT_CRITICAL();
528:                                    *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
529:                                    *perr        =  OS_ERR_EVENT_TYPE;
530:                                     return (events_rdy_nbr);
531:                            }
532:                           *perr = OS_ERR_NONE;
533:                            break;
534:               
535:                       case OS_STAT_PEND_ABORT:
536:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
537:                           *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
538:                            break;
539:               
540:                       case OS_STAT_PEND_TO:
541:                       default:
542:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
543:                           *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
544:                            break;
545:                   }
546:               
547:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
548:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
549:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
550:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
551:               #if ((OS_MBOX_EN > 0u) ||                 \
552:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
553:                   OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
554:               #endif
555:                   OS_EXIT_CRITICAL();
556:               
557:                   return (events_rdy_nbr);
558:               }
559:               #endif
560:               
561:               /*$PAGE*/
562:               /*
563:               *********************************************************************************************************
564:               *                                           INITIALIZATION
565:               *
566:               * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
567:               *              creating any uC/OS-II object and, prior to calling OSStart().
568:               *
569:               * Arguments  : none
570:               *
571:               * Returns    : none
572:               *********************************************************************************************************
573:               */
574:               
575:               void  OSInit (void)
576:               {
577:               #if OS_TASK_CREATE_EXT_EN > 0u
578:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
579:                   INT8U  err;
580:               #endif
581:               #endif
582:               
583:                   OSInitHookBegin();                                           /* Call port specific initialization code   */
001D06  022C80     CALL OSInitHookBegin
584:               
585:                   OS_InitMisc();                                               /* Initialize miscellaneous variables       */
001D08  000000     NOP
586:               
587:                   OS_InitRdyList();                                            /* Initialize the Ready List                */
001D0A  07FECF     RCALL _OS_InitMisc
588:               
589:                   OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
001D0C  07FEDF     RCALL _OS_InitRdyList
590:               
591:                   OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
592:               
593:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
594:                   OS_FlagInit();                                               /* Initialize the event flag structures     */
595:               #endif
596:               
597:               #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
598:                   OS_MemInit();                                                /* Initialize the memory manager            */
599:               #endif
600:               
601:               #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
602:                   OS_QInit();                                                  /* Initialize the message queue structures  */
603:               #endif
604:               
605:               #if OS_TASK_CREATE_EXT_EN > 0u
606:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
607:                   OS_TLS_Init(&err);                                           /* Initialize TLS, before creating tasks    */
608:                   if (err != OS_ERR_NONE) {
609:                       return;
610:                   }
611:               #endif
612:               #endif
613:               
614:                   OS_InitTaskIdle();                                           /* Create the Idle Task                     */
001D0E  07FFE4     RCALL _OS_InitTCBList
615:               #if OS_TASK_STAT_EN > 0u
616:                   OS_InitTaskStat();                                           /* Create the Statistic Task                */
001D10  07FF01     RCALL _OS_InitTaskIdle
001D12  07FF16     RCALL _OS_InitTaskStat
617:               #endif
618:               
619:               #if OS_TMR_EN > 0u
620:                   OSTmr_Init();                                                /* Initialize the Timer Manager             */
621:               #endif
622:               
623:                   OSInitHookEnd();                                             /* Call port specific init. code            */
001D14  042C86     GOTO OSInitHookEnd
001D16  000000     NOP
624:               
625:               #if OS_DEBUG_EN > 0u
626:                   OSDebugInit();
627:               #endif
628:               }
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                              ENTER ISR
633:               *
634:               * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
635:               *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
636:               *              only perform rescheduling at the last nested ISR.
637:               *
638:               * Arguments  : none
639:               *
640:               * Returns    : none
641:               *
642:               * Notes      : 1) This function should be called with interrupts already disabled
643:               *              2) Your ISR can directly increment OSIntNesting without calling this function because
644:               *                 OSIntNesting has been declared 'global'.
645:               *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
646:               *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
647:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
648:               *                 end of the ISR.
649:               *              5) You are allowed to nest interrupts up to 255 levels deep.
650:               *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
651:               *                 OSIntEnter() is always called with interrupts disabled.
652:               *********************************************************************************************************
653:               */
654:               
655:               void  OSIntEnter (void)
656:               {
657:                   if (OSRunning == OS_TRUE) {
001B70  BFC966     MOV.B OSRunning, WREG
001B72  504FE1     SUB.B W0, #0x1, [W15]
001B74  3A0005     BRA NZ, 0x1B80
658:                       if (OSIntNesting < 255u) {
001B76  BFC960     MOV.B OSIntNesting, WREG
001B78  404FE1     ADD.B W0, #0x1, [W15]
001B7A  320002     BRA Z, 0x1B80
659:                           OSIntNesting++;                      /* Increment ISR nesting level                        */
001B7C  E84000     INC.B W0, W0
001B7E  B7E960     MOV.B WREG, OSIntNesting
001B80  060000     RETURN
660:                       }
661:                   }
662:               }
663:               /*$PAGE*/
664:               /*
665:               *********************************************************************************************************
666:               *                                              EXIT ISR
667:               *
668:               * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
669:               *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
670:               *              a new, high-priority task, is ready to run.
671:               *
672:               * Arguments  : none
673:               *
674:               * Returns    : none
675:               *
676:               * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
677:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
678:               *                 end of the ISR.
679:               *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
680:               *********************************************************************************************************
681:               */
682:               
683:               void  OSIntExit (void)
684:               {
001B82  781F88     MOV W8, [W15++]
685:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
686:                   OS_CPU_SR  cpu_sr = 0u;
687:               #endif
688:               
689:               
690:               
691:                   if (OSRunning == OS_TRUE) {
001B84  BFC966     MOV.B OSRunning, WREG
001B86  504FE1     SUB.B W0, #0x1, [W15]
001B88  3A0026     BRA NZ, 0x1BD6
692:                       OS_ENTER_CRITICAL();
001B8A  800218     MOV SR, W8
001B8C  200E00     MOV #0xE0, W0
001B8E  B72042     IOR SR
693:                       if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
001B90  BFC960     MOV.B OSIntNesting, WREG
001B92  320002     BRA Z, 0x1B98
694:                           OSIntNesting--;
001B94  E94000     DEC.B W0, W0
001B96  B7E960     MOV.B WREG, OSIntNesting
695:                       }
696:                       if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
001B98  E24960     CP0.B OSIntNesting
001B9A  3A001C     BRA NZ, 0x1BD4
697:                           if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
001B9C  E24961     CP0.B OSLockNesting
698:                               OS_SchedNew();
001B9E  3A001A     BRA NZ, 0x1BD4
001BA0  07FF9C     RCALL _OS_SchedNew
699:                               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
001BA2  209631     MOV #0x963, W1
001BA4  784091     MOV.B [W1], W1
001BA6  FB8001     ZE W1, W0
001BA8  400000     ADD W0, W0, W0
001BAA  20A742     MOV #0xA74, W2
001BAC  780062     MOV [W2+W0], W0
001BAE  885380     MOV W0, OSTCBHighRdy
700:                               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
001BB0  209622     MOV #0x962, W2
001BB2  784112     MOV.B [W2], W2
001BB4  514F81     SUB.B W2, W1, [W15]
001BB6  32000E     BRA Z, 0x1BD4
701:               #if OS_TASK_PROFILE_EN > 0u
702:                                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
001BB8  900970     MOV [W0+30], W2
001BBA  901180     MOV [W0+32], W3
001BBC  410161     ADD W2, #0x1, W2
001BBE  4981E0     ADDC W3, #0x0, W3
001BC0  980872     MOV W2, [W0+30]
001BC2  981003     MOV W3, [W0+32]
703:               #endif
704:                                   OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
001BC4  804280     MOV OSCtxSwCtr, W0
001BC6  804291     MOV 0x852, W1
001BC8  400061     ADD W0, #0x1, W0
001BCA  4880E0     ADDC W1, #0x0, W1
001BCC  884280     MOV W0, OSCtxSwCtr
001BCE  884291     MOV W1, 0x852
705:               
706:               #if OS_TASK_CREATE_EXT_EN > 0u
707:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
708:                                   OS_TLS_TaskSw();
709:               #endif
710:               #endif
711:               
712:                                   OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
001BD0  022C56     CALL 0x2C56
001BD2  000000     NOP
713:                               }
714:                           }
715:                       }
716:                       OS_EXIT_CRITICAL();
001BD4  880218     MOV W8, SR
717:                   }
718:               }
001BD6  78044F     MOV [--W15], W8
001BD8  060000     RETURN
719:               /*$PAGE*/
720:               /*
721:               *********************************************************************************************************
722:               *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
723:               *
724:               * Description: This function is called by the application code to indicate that all initialization has
725:               *              been completed and that kernel objects are no longer allowed to be created.
726:               *
727:               * Arguments  : none
728:               *
729:               * Returns    : none
730:               *
731:               * Note(s)    : 1) You should call this function when you no longer want to allow application code to
732:               *                 create kernel objects.
733:               *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
734:               *********************************************************************************************************
735:               */
736:               
737:               #ifdef OS_SAFETY_CRITICAL_IEC61508
738:               void  OSSafetyCriticalStart (void)
739:               {
740:                   OSSafetyCriticalStartFlag = OS_TRUE;
741:               }
742:               
743:               #endif
744:               
745:               /*$PAGE*/
746:               /*
747:               *********************************************************************************************************
748:               *                                         PREVENT SCHEDULING
749:               *
750:               * Description: This function is used to prevent rescheduling to take place.  This allows your application
751:               *              to prevent context switches until you are ready to permit context switching.
752:               *
753:               * Arguments  : none
754:               *
755:               * Returns    : none
756:               *
757:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
758:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
759:               *********************************************************************************************************
760:               */
761:               
762:               #if OS_SCHED_LOCK_EN > 0u
763:               void  OSSchedLock (void)
764:               {
765:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
766:                   OS_CPU_SR  cpu_sr = 0u;
767:               #endif
768:               
769:               
770:               
771:                   if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
001BDA  BFC966     MOV.B OSRunning, WREG
001BDC  504FE1     SUB.B W0, #0x1, [W15]
001BDE  3A000B     BRA NZ, 0x1BF6
772:                       OS_ENTER_CRITICAL();
001BE0  800211     MOV SR, W1
001BE2  200E00     MOV #0xE0, W0
001BE4  B72042     IOR SR
773:                       if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
001BE6  E24960     CP0.B OSIntNesting
001BE8  3A0005     BRA NZ, 0x1BF4
774:                           if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
001BEA  BFC961     MOV.B OSLockNesting, WREG
001BEC  404FE1     ADD.B W0, #0x1, [W15]
001BEE  320002     BRA Z, 0x1BF4
775:                               OSLockNesting++;                 /* Increment lock nesting level                       */
001BF0  E84000     INC.B W0, W0
001BF2  B7E961     MOV.B WREG, OSLockNesting
776:                           }
777:                       }
778:                       OS_EXIT_CRITICAL();
001BF4  880211     MOV W1, SR
001BF6  060000     RETURN
779:                   }
780:               }
781:               #endif
782:               
783:               /*$PAGE*/
784:               /*
785:               *********************************************************************************************************
786:               *                                          ENABLE SCHEDULING
787:               *
788:               * Description: This function is used to re-allow rescheduling.
789:               *
790:               * Arguments  : none
791:               *
792:               * Returns    : none
793:               *
794:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
795:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
796:               *********************************************************************************************************
797:               */
798:               
799:               #if OS_SCHED_LOCK_EN > 0u
800:               void  OSSchedUnlock (void)
801:               {
802:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
803:                   OS_CPU_SR  cpu_sr = 0u;
804:               #endif
805:               
806:               
807:               
808:                   if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
001D6E  BFC966     MOV.B OSRunning, WREG
001D70  504FE1     SUB.B W0, #0x1, [W15]
001D72  3A0013     BRA NZ, 0x1D9A
809:                       OS_ENTER_CRITICAL();
001D74  800213     MOV SR, W3
001D76  200E00     MOV #0xE0, W0
001D78  B72042     IOR SR
810:                       if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
001D7A  E24960     CP0.B OSIntNesting
001D7C  3A000D     BRA NZ, 0x1D98
811:                           if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
001D7E  209611     MOV #0x961, W1
001D80  784091     MOV.B [W1], W1
001D82  E00401     CP0.B W1
001D84  320007     BRA Z, 0x1D94
812:                               OSLockNesting--;                           /* Decrement lock nesting level             */
001D86  E94081     DEC.B W1, W1
001D88  209612     MOV #0x961, W2
001D8A  784901     MOV.B W1, [W2]
813:                               if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
001D8C  E00401     CP0.B W1
001D8E  3A0002     BRA NZ, 0x1D94
814:                                   OS_EXIT_CRITICAL();
815:                                   OS_Sched();                            /* See if a HPT is ready                    */
001D90  880213     MOV W3, SR
001D92  37FFC8     BRA OS_Sched
816:                               } else {
817:                                   OS_EXIT_CRITICAL();
818:                               }
819:                           } else {
820:                               OS_EXIT_CRITICAL();
001D94  880213     MOV W3, SR
001D96  060000     RETURN
821:                           }
822:                       } else {
823:                           OS_EXIT_CRITICAL();
001D98  880213     MOV W3, SR
001D9A  060000     RETURN
824:                       }
825:                   }
826:               }
827:               #endif
828:               
829:               /*$PAGE*/
830:               /*
831:               *********************************************************************************************************
832:               *                                         START MULTITASKING
833:               *
834:               * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
835:               *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
836:               *              and you MUST have created at least one task.
837:               *
838:               * Arguments  : none
839:               *
840:               * Returns    : none
841:               *
842:               * Note       : OSStartHighRdy() MUST:
843:               *                 a) Call OSTaskSwHook() then,
844:               *                 b) Set OSRunning to OS_TRUE.
845:               *                 c) Load the context of the task pointed to by OSTCBHighRdy.
846:               *                 d_ Execute the task.
847:               *********************************************************************************************************
848:               */
849:               
850:               void  OSStart (void)
851:               {
852:                   if (OSRunning == OS_FALSE) {
001BF8  E24966     CP0.B OSRunning
853:                       OS_SchedNew();                               /* Find highest priority's task priority number   */
001BFA  3A000B     BRA NZ, 0x1C12
001BFC  07FF6E     RCALL _OS_SchedNew
854:                       OSPrioCur     = OSPrioHighRdy;
001BFE  BFC963     MOV.B OSPrioHighRdy, WREG
001C00  B7E962     MOV.B WREG, OSPrioCur
855:                       OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
001C02  FB8000     ZE W0, W0
001C04  400000     ADD W0, W0, W0
001C06  20A741     MOV #0xA74, W1
001C08  780061     MOV [W1+W0], W0
001C0A  885380     MOV W0, OSTCBHighRdy
856:                       OSTCBCur      = OSTCBHighRdy;
001C0C  885360     MOV W0, OSTCBCur
857:                       OSStartHighRdy();                            /* Execute target specific code to start task     */
001C0E  022BDC     CALL 0x2BDC
001C10  000000     NOP
001C12  060000     RETURN
858:                   }
859:               }
860:               /*$PAGE*/
861:               /*
862:               *********************************************************************************************************
863:               *                                      STATISTICS INITIALIZATION
864:               *
865:               * Description: This function is called by your application to establish CPU usage by first determining
866:               *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
867:               *              during that time.  CPU usage is then determined by a low priority task which keeps track
868:               *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
869:               *              determined by:
870:               *
871:               *                                             OSIdleCtr
872:               *                 CPU Usage (%) = 100 * (1 - ------------)
873:               *                                            OSIdleCtrMax
874:               *
875:               * Arguments  : none
876:               *
877:               * Returns    : none
878:               *********************************************************************************************************
879:               */
880:               
881:               #if OS_TASK_STAT_EN > 0u
882:               void  OSStatInit (void)
883:               {
001C14  781F88     MOV W8, [W15++]
884:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
885:                   OS_CPU_SR  cpu_sr = 0u;
886:               #endif
887:               
888:               
889:               
890:                   OSTimeDly(2u);                               /* Synchronize with clock tick                        */
001C16  200020     MOV #0x2, W0
001C18  200001     MOV #0x0, W1
001C1A  022726     CALL OSTimeDly
001C1C  000000     NOP
891:                   OS_ENTER_CRITICAL();
001C1E  800211     MOV SR, W1
001C20  200E08     MOV #0xE0, W8
001C22  780008     MOV W8, W0
001C24  B72042     IOR SR
892:                   OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
001C26  EF2968     CLR OSIdleCtr
001C28  EF296A     CLR 0x96A
893:                   OS_EXIT_CRITICAL();
001C2A  880211     MOV W1, SR
894:                   OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
001C2C  200640     MOV #0x64, W0
001C2E  200001     MOV #0x0, W1
001C30  022726     CALL OSTimeDly
001C32  000000     NOP
895:                   OS_ENTER_CRITICAL();
001C34  800213     MOV SR, W3
001C36  780008     MOV W8, W0
001C38  B72042     IOR SR
896:                   OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
001C3A  804B40     MOV OSIdleCtr, W0
001C3C  804B51     MOV 0x96A, W1
001C3E  8842B0     MOV W0, OSIdleCtrMax
001C40  8842C1     MOV W1, 0x858
897:                   OSStatRdy    = OS_TRUE;
001C42  B3C011     MOV.B #0x1, W1
001C44  2085E2     MOV #0x85E, W2
001C46  784901     MOV.B W1, [W2]
898:                   OS_EXIT_CRITICAL();
001C48  880213     MOV W3, SR
899:               }
001C4A  78044F     MOV [--W15], W8
001C4C  060000     RETURN
900:               #endif
901:               /*$PAGE*/
902:               /*
903:               *********************************************************************************************************
904:               *                                         PROCESS SYSTEM TICK
905:               *
906:               * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
907:               *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
908:               *              called by a high priority task.
909:               *
910:               * Arguments  : none
911:               *
912:               * Returns    : none
913:               *********************************************************************************************************
914:               */
915:               
916:               void  OSTimeTick (void)
917:               {
918:                   OS_TCB    *ptcb;
919:               #if OS_TICK_STEP_EN > 0u
920:                   BOOLEAN    step;
921:               #endif
922:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
923:                   OS_CPU_SR  cpu_sr = 0u;
924:               #endif
925:               
926:               
927:               
928:               #if OS_TIME_TICK_HOOK_EN > 0u
929:                   OSTimeTickHook();                                      /* Call user definable hook                     */
930:               #endif
931:               #if OS_TIME_GET_SET_EN > 0u
932:                   OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
001C4E  800212     MOV SR, W2
001C50  200E00     MOV #0xE0, W0
001C52  B72042     IOR SR
933:                   OSTime++;
001C54  805AC0     MOV OSTime, W0
001C56  805AD1     MOV 0xB5A, W1
001C58  400061     ADD W0, #0x1, W0
001C5A  4880E0     ADDC W1, #0x0, W1
001C5C  885AC0     MOV W0, OSTime
001C5E  885AD1     MOV W1, 0xB5A
934:                   OS_EXIT_CRITICAL();
001C60  880212     MOV W2, SR
935:               #endif
936:                   if (OSRunning == OS_TRUE) {
001C62  BFC966     MOV.B OSRunning, WREG
001C64  504FE1     SUB.B W0, #0x1, [W15]
001C66  3A002F     BRA NZ, 0x1CC6
937:               #if OS_TICK_STEP_EN > 0u
938:                       switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
939:                           case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
940:                                step = OS_TRUE;
941:                                break;
942:               
943:                           case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
944:                                step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
945:                                break;
946:               
947:                           case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
948:                                step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
949:                                OSTickStepState = OS_TICK_STEP_WAIT;
950:                                break;
951:               
952:                           default:                                       /* Invalid case, correct situation              */
953:                                step            = OS_TRUE;
954:                                OSTickStepState = OS_TICK_STEP_DIS;
955:                                break;
956:                       }
957:                       if (step == OS_FALSE) {                            /* Return if waiting for step command           */
958:                           return;
959:                       }
960:               #endif
961:                       ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
001C68  805397     MOV OSTCBList, W7
001C6A  209641     MOV #0x964, W1
001C6C  784091     MOV.B [W1], W1
962:                       while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
001C6E  370026     BRA 0x1CBC
001CBC  905907     MOV.B [W7+24], W2
001CBE  514FE4     SUB.B W2, #0x4, [W15]
001CC0  3AFFD7     BRA NZ, 0x1C70
001CC2  209642     MOV #0x964, W2
001CC4  784901     MOV.B W1, [W2]
001CC6  060000     RETURN
963:                           OS_ENTER_CRITICAL();
001C70  800214     MOV SR, W4
001C72  200E00     MOV #0xE0, W0
001C74  B72042     IOR SR
964:                           if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
001C76  900917     MOV [W7+18], W2
001C78  9009A7     MOV [W7+20], W3
001C7A  510FE0     SUB W2, #0x0, [W15]
001C7C  598FE0     SUBB W3, #0x0, [W15]
001C7E  32001C     BRA Z, 0x1CB8
965:                               ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
001C80  510161     SUB W2, #0x1, W2
001C82  5981E0     SUBB W3, #0x0, W3
001C84  980B92     MOV W2, [W7+18]
001C86  980BA3     MOV W3, [W7+20]
966:                               if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
001C88  510FE0     SUB W2, #0x0, [W15]
001C8A  598FE0     SUBB W3, #0x0, [W15]
001C8C  3A0015     BRA NZ, 0x1CB8
967:               
968:                                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
001C8E  9051E7     MOV.B [W7+22], W3
001C90  780103     MOV W3, W2
001C92  B20372     AND #0x37, W2
001C94  320004     BRA Z, 0x1C9E
969:                                       ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
001C96  B3CC82     MOV.B #0xC8, W2
001C98  61C182     AND.B W3, W2, W3
001C9A  9853E3     MOV.B W3, [W7+22]
970:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
001C9C  B3C012     MOV.B #0x1, W2
971:                                   } else {
972:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
001C9E  9853F2     MOV.B W2, [W7+23]
973:                                   }
974:               
975:                                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
001CA0  905167     MOV.B [W7+22], W2
001CA2  A33802     BTST.Z W2, #3
001CA4  3A0009     BRA NZ, 0x1CB8
976:                                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
001CA6  905947     MOV.B [W7+28], W2
001CA8  70C082     IOR.B W1, W2, W1
977:                                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
001CAA  905927     MOV.B [W7+26], W2
001CAC  FB8102     ZE W2, W2
001CAE  209653     MOV #0x965, W3
001CB0  794363     MOV.B [W3+W2], W6
001CB2  905AB7     MOV.B [W7+27], W5
001CB4  734285     IOR.B W6, W5, W5
001CB6  797185     MOV.B W5, [W3+W2]
978:                                   }
979:                               }
980:                           }
981:                           ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
001CB8  9003F7     MOV [W7+14], W7
982:                           OS_EXIT_CRITICAL();
001CBA  880214     MOV W4, SR
983:                       }
984:                   }
985:               }
986:               
987:               /*$PAGE*/
988:               /*
989:               *********************************************************************************************************
990:               *                                             GET VERSION
991:               *
992:               * Description: This function is used to return the version number of uC/OS-II.  The returned value 
993:               *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
994:               *              2.01.00 would be returned as 20100.
995:               *
996:               * Arguments  : none
997:               *
998:               * Returns    : The version number of uC/OS-II multiplied by 10000.
999:               *********************************************************************************************************
1000:              */
1001:              
1002:              INT16U  OSVersion (void)
1003:              {
1004:                  return (OS_VERSION);
1005:              }
001CC8  2721B0     MOV #0x721B, W0
001CCA  060000     RETURN
1006:              
1007:              /*$PAGE*/
1008:              /*
1009:              *********************************************************************************************************
1010:              *                                           DUMMY FUNCTION
1011:              *
1012:              * Description: This function doesn't do anything.  It is called by OSTaskDel().
1013:              *
1014:              * Arguments  : none
1015:              *
1016:              * Returns    : none
1017:              *********************************************************************************************************
1018:              */
1019:              
1020:              #if OS_TASK_DEL_EN > 0u
1021:              void  OS_Dummy (void)
1022:              {
1023:              }
1024:              #endif
1025:              
1026:              /*$PAGE*/
1027:              /*
1028:              *********************************************************************************************************
1029:              *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
1030:              *
1031:              * Description: This function is called by other uC/OS-II services and is used to ready a task that was
1032:              *              waiting for an event to occur.
1033:              *
1034:              * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
1035:              *
1036:              *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
1037:              *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
1038:              *                          service functions.
1039:              *
1040:              *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
1041:              *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
1042:              *
1043:              *              pend_stat   is used to indicate the readied task's pending status:
1044:              *
1045:              *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
1046:              *                                               an abort.
1047:              *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
1048:              *
1049:              * Returns    : none
1050:              *
1051:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1052:              *********************************************************************************************************
1053:              */
1054:              #if (OS_EVENT_EN)
1055:              INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
1056:                                      void      *pmsg,
1057:                                      INT8U      msk,
1058:                                      INT8U      pend_stat)
1059:              {
1060:                  OS_TCB   *ptcb;
1061:                  INT8U     y;
1062:                  INT8U     x;
1063:                  INT8U     prio;
1064:              #if OS_LOWEST_PRIO > 63u
1065:                  OS_PRIO  *ptbl;
1066:              #endif
1067:              
1068:              
1069:              #if OS_LOWEST_PRIO <= 63u
1070:                  y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
1071:                  x    = OSUnMapTbl[pevent->OSEventTbl[y]];
1072:                  prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
1073:              #else
1074:                  if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
1075:                      y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
1076:                  } else {
1077:                      y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
1078:                  }
1079:                  ptbl = &pevent->OSEventTbl[y];
1080:                  if ((*ptbl & 0xFFu) != 0u) {
1081:                      x = OSUnMapTbl[*ptbl & 0xFFu];
1082:                  } else {
1083:                      x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
1084:                  }
1085:                  prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
1086:              #endif
1087:              
1088:                  ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
1089:                  ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
1090:              #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
1091:                  ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
1092:              #else
1093:                  pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
1094:              #endif
1095:                  ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
1096:                  ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
1097:                                                                      /* See if task is ready (could be susp'd)      */
1098:                  if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
1099:                      OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
1100:                      OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
1101:                  }
1102:              
1103:                  OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
1104:              #if (OS_EVENT_MULTI_EN > 0u)
1105:                  if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
1106:                      OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
1107:                      ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
1108:                  }
1109:              #endif
1110:              
1111:                  return (prio);
1112:              }
1113:              #endif
1114:              /*$PAGE*/
1115:              /*
1116:              *********************************************************************************************************
1117:              *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
1118:              *
1119:              * Description: This function is called by other uC/OS-II services to suspend a task because an event has
1120:              *              not occurred.
1121:              *
1122:              * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
1123:              *
1124:              * Returns    : none
1125:              *
1126:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1127:              *********************************************************************************************************
1128:              */
1129:              #if (OS_EVENT_EN)
1130:              void  OS_EventTaskWait (OS_EVENT *pevent)
1131:              {
1132:                  INT8U  y;
1133:              
1134:              
1135:                  OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
1136:              
1137:                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
1138:                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
1139:              
1140:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
1141:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
1142:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
1143:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
1144:                  }
1145:              }
1146:              #endif
1147:              /*$PAGE*/
1148:              /*
1149:              *********************************************************************************************************
1150:              *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
1151:              *
1152:              * Description: This function is called by other uC/OS-II services to suspend a task because any one of
1153:              *              multiple events has not occurred.
1154:              *
1155:              * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
1156:              *                               which the task will be waiting for.
1157:              *
1158:              * Returns    : none.
1159:              *
1160:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1161:              *********************************************************************************************************
1162:              */
1163:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1164:              void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
1165:              {
1166:                  OS_EVENT **pevents;
1167:                  OS_EVENT  *pevent;
1168:                  INT8U      y;
1169:              
1170:              
1171:                  OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
1172:                  OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
1173:              
1174:                  pevents =  pevents_wait;
1175:                  pevent  = *pevents;
1176:                  while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
1177:                      pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
1178:                      pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
1179:                      pevents++;
1180:                      pevent = *pevents;
1181:                  }
1182:              
1183:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
1184:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
1185:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
1186:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
1187:                  }
1188:              }
1189:              #endif
1190:              /*$PAGE*/
1191:              /*
1192:              *********************************************************************************************************
1193:              *                                  REMOVE TASK FROM EVENT WAIT LIST
1194:              *
1195:              * Description: Remove a task from an event's wait list.
1196:              *
1197:              * Arguments  : ptcb     is a pointer to the task to remove.
1198:              *
1199:              *              pevent   is a pointer to the event control block.
1200:              *
1201:              * Returns    : none
1202:              *
1203:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1204:              *********************************************************************************************************
1205:              */
1206:              #if (OS_EVENT_EN)
1207:              void  OS_EventTaskRemove (OS_TCB   *ptcb,
1208:                                        OS_EVENT *pevent)
1209:              {
1210:                  INT8U  y;
1211:              
1212:              
1213:                  y                       =  ptcb->OSTCBY;
1214:                  pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
1215:                  if (pevent->OSEventTbl[y] == 0u) {
1216:                      pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
1217:                  }
1218:                  ptcb->OSTCBEventPtr     = (OS_EVENT  *)0;               /* Unlink OS_EVENT from OS_TCB             */
1219:              }
1220:              #endif
1221:              /*$PAGE*/
1222:              /*
1223:              *********************************************************************************************************
1224:              *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
1225:              *
1226:              * Description: Remove a task from multiple events' wait lists.
1227:              *
1228:              * Arguments  : ptcb             is a pointer to the task to remove.
1229:              *
1230:              *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
1231:              *
1232:              * Returns    : none
1233:              *
1234:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1235:              *********************************************************************************************************
1236:              */
1237:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1238:              void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
1239:                                             OS_EVENT **pevents_multi)
1240:              {
1241:                  OS_EVENT **pevents;
1242:                  OS_EVENT  *pevent;
1243:                  INT8U      y;
1244:                  OS_PRIO    bity;
1245:                  OS_PRIO    bitx;
1246:              
1247:              
1248:                  y       =  ptcb->OSTCBY;
1249:                  bity    =  ptcb->OSTCBBitY;
1250:                  bitx    =  ptcb->OSTCBBitX;
1251:                  pevents =  pevents_multi;
1252:                  pevent  = *pevents;
1253:                  while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
1254:                      pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
1255:                      if (pevent->OSEventTbl[y] == 0u) {
1256:                          pevent->OSEventGrp &= (OS_PRIO)~bity;
1257:                      }
1258:                      pevents++;
1259:                      pevent = *pevents;
1260:                  }
1261:              }
1262:              #endif
1263:              /*$PAGE*/
1264:              /*
1265:              *********************************************************************************************************
1266:              *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
1267:              *
1268:              * Description: This function is called by other uC/OS-II services to initialize the event wait list.
1269:              *
1270:              * Arguments  : pevent    is a pointer to the event control block allocated to the event.
1271:              *
1272:              * Returns    : none
1273:              *
1274:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1275:              *********************************************************************************************************
1276:              */
1277:              #if (OS_EVENT_EN)
1278:              void  OS_EventWaitListInit (OS_EVENT *pevent)
1279:              {
1280:                  INT8U  i;
1281:              
1282:              
1283:                  pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
1284:                  for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
1285:                      pevent->OSEventTbl[i] = 0u;
1286:                  }
1287:              }
1288:              #endif
1289:              /*$PAGE*/
1290:              /*
1291:              *********************************************************************************************************
1292:              *                                             INITIALIZATION
1293:              *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
1294:              *
1295:              * Description: This function is called by OSInit() to initialize the free list of event control blocks.
1296:              *
1297:              * Arguments  : none
1298:              *
1299:              * Returns    : none
1300:              *********************************************************************************************************
1301:              */
1302:              
1303:              static  void  OS_InitEventList (void)
1304:              {
1305:              #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
1306:              #if (OS_MAX_EVENTS > 1u)
1307:                  INT16U     ix;
1308:                  INT16U     ix_next;
1309:                  OS_EVENT  *pevent1;
1310:                  OS_EVENT  *pevent2;
1311:              
1312:              
1313:                  OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
1314:                  for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
1315:                      ix_next = ix + 1u;
1316:                      pevent1 = &OSEventTbl[ix];
1317:                      pevent2 = &OSEventTbl[ix_next];
1318:                      pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
1319:                      pevent1->OSEventPtr     = pevent2;
1320:              #if OS_EVENT_NAME_EN > 0u
1321:                      pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
1322:              #endif
1323:                  }
1324:                  pevent1                         = &OSEventTbl[ix];
1325:                  pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
1326:                  pevent1->OSEventPtr             = (OS_EVENT *)0;
1327:              #if OS_EVENT_NAME_EN > 0u
1328:                  pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
1329:              #endif
1330:                  OSEventFreeList                 = &OSEventTbl[0];
1331:              #else
1332:                  OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
1333:                  OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
1334:                  OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
1335:              #if OS_EVENT_NAME_EN > 0u
1336:                  OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
1337:              #endif
1338:              #endif
1339:              #endif
1340:              }
1341:              /*$PAGE*/
1342:              /*
1343:              *********************************************************************************************************
1344:              *                                             INITIALIZATION
1345:              *                                    INITIALIZE MISCELLANEOUS VARIABLES
1346:              *
1347:              * Description: This function is called by OSInit() to initialize miscellaneous variables.
1348:              *
1349:              * Arguments  : none
1350:              *
1351:              * Returns    : none
1352:              *********************************************************************************************************
1353:              */
1354:              
1355:              static  void  OS_InitMisc (void)
1356:              {
1357:              #if OS_TIME_GET_SET_EN > 0u
1358:                  OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
001AAA  EF2B58     CLR OSTime
001AAC  EF2B5A     CLR 0xB5A
1359:              #endif
1360:              
1361:                  OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
001AAE  EF6960     CLR.B OSIntNesting
1362:                  OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
001AB0  EF6961     CLR.B OSLockNesting
1363:              
1364:                  OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
001AB2  EF6967     CLR.B OSTaskCtr
1365:              
1366:                  OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
001AB4  EF6966     CLR.B OSRunning
1367:              
1368:                  OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
001AB6  EF2850     CLR OSCtxSwCtr
001AB8  EF2852     CLR 0x852
1369:                  OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
001ABA  EF2968     CLR OSIdleCtr
001ABC  EF296A     CLR 0x96A
1370:              
1371:              #if OS_TASK_STAT_EN > 0u
1372:                  OSIdleCtrRun              = 0uL;
001ABE  EF285A     CLR OSIdleCtrRun
001AC0  EF285C     CLR 0x85C
1373:                  OSIdleCtrMax              = 0uL;
001AC2  EF2856     CLR OSIdleCtrMax
001AC4  EF2858     CLR 0x858
1374:                  OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
001AC6  EF685E     CLR.B OSStatRdy
1375:              #endif
1376:              
1377:              #ifdef OS_SAFETY_CRITICAL_IEC61508
1378:                  OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
1379:              #endif
1380:              
1381:              #if OS_TASK_REG_TBL_SIZE > 0u
1382:                  OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
001AC8  EF6B56     CLR.B OSTaskRegNextAvailID
1383:              #endif
1384:              }
001ACA  060000     RETURN
1385:              /*$PAGE*/
1386:              /*
1387:              *********************************************************************************************************
1388:              *                                             INITIALIZATION
1389:              *                                       INITIALIZE THE READY LIST
1390:              *
1391:              * Description: This function is called by OSInit() to initialize the Ready List.
1392:              *
1393:              * Arguments  : none
1394:              *
1395:              * Returns    : none
1396:              *********************************************************************************************************
1397:              */
1398:              
1399:              static  void  OS_InitRdyList (void)
1400:              {
1401:                  INT8U  i;
1402:              
1403:              
1404:                  OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
001ACC  EF6964     CLR.B OSRdyGrp
1405:                  for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
1406:                      OSRdyTbl[i] = 0u;
001ACE  EF6965     CLR.B OSRdyTbl
1407:                  }
1408:              
1409:                  OSPrioCur     = 0u;
001AD0  EF6962     CLR.B OSPrioCur
1410:                  OSPrioHighRdy = 0u;
001AD2  EF6963     CLR.B OSPrioHighRdy
1411:              
1412:                  OSTCBHighRdy  = (OS_TCB *)0;
001AD4  EF2A70     CLR OSTCBHighRdy
1413:                  OSTCBCur      = (OS_TCB *)0;
001AD6  EF2A6C     CLR OSTCBCur
1414:              }
001AD8  060000     RETURN
1415:              
1416:              /*$PAGE*/
1417:              /*
1418:              *********************************************************************************************************
1419:              *                                             INITIALIZATION
1420:              *                                         CREATING THE IDLE TASK
1421:              *
1422:              * Description: This function creates the Idle Task.
1423:              *
1424:              * Arguments  : none
1425:              *
1426:              * Returns    : none
1427:              *********************************************************************************************************
1428:              */
1429:              
1430:              static  void  OS_InitTaskIdle (void)
1431:              {
001B14  FA0002     LNK #0x2
1432:              #if OS_TASK_NAME_EN > 0u
1433:                  INT8U  err;
1434:              #endif
1435:              
1436:              
1437:              #if OS_TASK_CREATE_EXT_EN > 0u
1438:                  #if OS_STK_GROWTH == 1u
1439:                  (void)OSTaskCreateExt(OS_TaskIdle,
1440:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1441:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
1442:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1443:                                        OS_TASK_IDLE_ID,
1444:                                        &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
1445:                                        OS_TASK_IDLE_STK_SIZE,
1446:                                        (void *)0,                                 /* No TCB extension                     */
1447:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1448:                  #else
1449:                  (void)OSTaskCreateExt(OS_TaskIdle,
001B16  200030     MOV #0x3, W0
001B18  781F80     MOV W0, [W15++]
001B1A  EB1F80     CLR [W15++]
001B1C  200806     MOV #0x80, W6
001B1E  200007     MOV #0x0, W7
001B20  20A6A5     MOV #0xA6A, W5
001B22  EB8200     SETM W4
001B24  B3C043     MOV.B #0x4, W3
001B26  2096C2     MOV #0x96C, W2
001B28  EB0080     CLR W1
001B2A  21AFA0     MOV #0x1AFA, W0
001B2C  0222DA     CALL OSTaskCreateExt
001B2E  000000     NOP
1450:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1451:                                        &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
1452:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1453:                                        OS_TASK_IDLE_ID,
1454:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
1455:                                        OS_TASK_IDLE_STK_SIZE,
1456:                                        (void *)0,                                 /* No TCB extension                     */
1457:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1458:                  #endif
1459:              #else
1460:                  #if OS_STK_GROWTH == 1u
1461:                  (void)OSTaskCreate(OS_TaskIdle,
1462:                                     (void *)0,
1463:                                     &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
1464:                                     OS_TASK_IDLE_PRIO);
1465:                  #else
1466:                  (void)OSTaskCreate(OS_TaskIdle,
1467:                                     (void *)0,
1468:                                     &OSTaskIdleStk[0],
1469:                                     OS_TASK_IDLE_PRIO);
1470:                  #endif
1471:              #endif
1472:              
1473:              #if OS_TASK_NAME_EN > 0u
1474:                  OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
001B30  578166     SUB W15, #0x6, W2
001B32  298881     MOV #0x9888, W1
001B34  B3C040     MOV.B #0x4, W0
001B36  0220A8     CALL OSTaskNameSet
001B38  000000     NOP
001B3A  5787E4     SUB W15, #0x4, W15
1475:              #endif
1476:              }
001B3C  FA8000     ULNK
001B3E  060000     RETURN
1477:              /*$PAGE*/
1478:              /*
1479:              *********************************************************************************************************
1480:              *                                             INITIALIZATION
1481:              *                                      CREATING THE STATISTIC TASK
1482:              *
1483:              * Description: This function creates the Statistic Task.
1484:              *
1485:              * Arguments  : none
1486:              *
1487:              * Returns    : none
1488:              *********************************************************************************************************
1489:              */
1490:              
1491:              #if OS_TASK_STAT_EN > 0u
1492:              static  void  OS_InitTaskStat (void)
1493:              {
001B40  FA0002     LNK #0x2
001B42  781F88     MOV W8, [W15++]
1494:              #if OS_TASK_NAME_EN > 0u
1495:                  INT8U  err;
1496:              #endif
1497:              
1498:              
1499:              #if OS_TASK_CREATE_EXT_EN > 0u
1500:                  #if OS_STK_GROWTH == 1u
1501:                  (void)OSTaskCreateExt(OS_TaskStat,
1502:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1503:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
1504:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1505:                                        OS_TASK_STAT_ID,
1506:                                        &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
1507:                                        OS_TASK_STAT_STK_SIZE,
1508:                                        (void *)0,                                   /* No TCB extension               */
1509:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1510:                  #else
1511:                  (void)OSTaskCreateExt(OS_TaskStat,
001B44  200038     MOV #0x3, W8
001B46  781F88     MOV W8, [W15++]
001B48  EB1F80     CLR [W15++]
001B4A  200806     MOV #0x80, W6
001B4C  200007     MOV #0x0, W7
001B4E  2095E5     MOV #0x95E, W5
001B50  2FFFE4     MOV #0xFFFE, W4
001B52  784188     MOV.B W8, W3
001B54  208602     MOV #0x860, W2
001B56  EB0080     CLR W1
001B58  21DE60     MOV #0x1DE6, W0
001B5A  0222DA     CALL OSTaskCreateExt
001B5C  000000     NOP
1512:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1513:                                        &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
1514:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1515:                                        OS_TASK_STAT_ID,
1516:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
1517:                                        OS_TASK_STAT_STK_SIZE,
1518:                                        (void *)0,                                   /* No TCB extension               */
1519:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1520:                  #endif
1521:              #else
1522:                  #if OS_STK_GROWTH == 1u
1523:                  (void)OSTaskCreate(OS_TaskStat,
1524:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1525:                                     &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
1526:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1527:                  #else
1528:                  (void)OSTaskCreate(OS_TaskStat,
1529:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1530:                                     &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
1531:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1532:                  #endif
1533:              #endif
1534:              
1535:              #if OS_TASK_NAME_EN > 0u
1536:                  OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
001B5E  578168     SUB W15, #0x8, W2
001B60  298961     MOV #0x9896, W1
001B62  784008     MOV.B W8, W0
001B64  0220A8     CALL OSTaskNameSet
001B66  000000     NOP
001B68  5787E4     SUB W15, #0x4, W15
1537:              #endif
1538:              }
001B6A  78044F     MOV [--W15], W8
001B6C  FA8000     ULNK
001B6E  060000     RETURN
1539:              #endif
1540:              /*$PAGE*/
1541:              /*
1542:              *********************************************************************************************************
1543:              *                                             INITIALIZATION
1544:              *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
1545:              *
1546:              * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
1547:              *
1548:              * Arguments  : none
1549:              *
1550:              * Returns    : none
1551:              *********************************************************************************************************
1552:              */
1553:              
1554:              static  void  OS_InitTCBList (void)
1555:              {
1556:                  INT8U    ix;
1557:                  INT8U    ix_next;
1558:                  OS_TCB  *ptcb1;
1559:                  OS_TCB  *ptcb2;
1560:              
1561:              
1562:                  OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
001CD8  200D81     MOV #0xD8, W1
001CDA  20A7E0     MOV #0xA7E, W0
001CDC  07FFF7     RCALL OS_MemClr
1563:                  OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
001CDE  2000A1     MOV #0xA, W1
001CE0  20A740     MOV #0xA74, W0
001CE2  07FFF4     RCALL OS_MemClr
001CE4  20A8C1     MOV #0xA8C, W1
001CE6  EB0000     CLR W0
001CE8  E80000     INC W0, W0
1564:                  for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
001CF8  500FE3     SUB W0, #0x3, [W15]
001CFA  3AFFF6     BRA NZ, 0x1CE8
1565:                      ix_next =  ix + 1u;
1566:                      ptcb1   = &OSTCBTbl[ix];
1567:                      ptcb2   = &OSTCBTbl[ix_next];
001CEA  200364     MOV #0x36, W4
001CEC  B98204     MUL.SS W0, W4, W4
001CEE  20A7E2     MOV #0xA7E, W2
001CF0  410884     ADD W2, W4, [W1]
1568:                      ptcb1->OSTCBNext = ptcb2;
1569:              #if OS_TASK_NAME_EN > 0u
1570:                      ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
001CF2  298A43     MOV #0x98A4, W3
001CF4  981093     MOV W3, [W1+34]
001CF6  B00361     ADD #0x36, W1
1571:              #endif
1572:                  }
1573:                  ptcb1                   = &OSTCBTbl[ix];
1574:                  ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
001CFC  EF2B2E     CLR 0xB2E
1575:              #if OS_TASK_NAME_EN > 0u
1576:                  ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
001CFE  885A83     MOV W3, 0xB50
1577:              #endif
1578:                  OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
001D00  EF2A72     CLR OSTCBList
1579:                  OSTCBFreeList           = &OSTCBTbl[0];
001D02  885372     MOV W2, OSTCBFreeList
1580:              }
001D04  060000     RETURN
1581:              /*$PAGE*/
1582:              /*
1583:              *********************************************************************************************************
1584:              *                                      CLEAR A SECTION OF MEMORY
1585:              *
1586:              * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
1587:              *
1588:              * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
1589:              *
1590:              *              size     is the number of bytes to clear.
1591:              *
1592:              * Returns    : none
1593:              *
1594:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1595:              *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
1596:              *                 of the uses of this function gets close to this limit.
1597:              *              3) The clear is done one byte at a time since this will work on any processor irrespective
1598:              *                 of the alignment of the destination.
1599:              *********************************************************************************************************
1600:              */
1601:              
1602:              void  OS_MemClr (INT8U  *pdest,
1603:                               INT16U  size)
1604:              {
1605:                  while (size > 0u) {
001CCC  370002     BRA 0x1CD2
001CD2  E00001     CP0 W1
001CD4  3AFFFC     BRA NZ, 0x1CCE
1606:                      *pdest++ = (INT8U)0;
001CCE  EB5800     CLR.B [W0++]
1607:                      size--;
001CD0  E90081     DEC W1, W1
1608:                  }
1609:              }
001CD6  060000     RETURN
1610:              /*$PAGE*/
1611:              /*
1612:              *********************************************************************************************************
1613:              *                                       COPY A BLOCK OF MEMORY
1614:              *
1615:              * Description: This function is called by other uC/OS-II services to copy a block of memory from one
1616:              *              location to another.
1617:              *
1618:              * Arguments  : pdest    is a pointer to the 'destination' memory block
1619:              *
1620:              *              psrc     is a pointer to the 'source'      memory block
1621:              *
1622:              *              size     is the number of bytes to copy.
1623:              *
1624:              * Returns    : none
1625:              *
1626:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
1627:              *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
1628:              *                 is not a situation that will happen.
1629:              *              2) Note that we can only copy up to 64K bytes of RAM
1630:              *              3) The copy is done one byte at a time since this will work on any processor irrespective
1631:              *                 of the alignment of the source and destination.
1632:              *********************************************************************************************************
1633:              */
1634:              
1635:              void  OS_MemCopy (INT8U  *pdest,
1636:                                INT8U  *psrc,
1637:                                INT16U  size)
1638:              {
1639:                  while (size > 0u) {
001D18  370002     BRA 0x1D1E
001D1E  E00002     CP0 W2
001D20  3AFFFC     BRA NZ, 0x1D1A
1640:                      *pdest++ = *psrc++;
001D1A  785831     MOV.B [W1++], [W0++]
1641:                      size--;
001D1C  E90102     DEC W2, W2
1642:                  }
1643:              }
001D22  060000     RETURN
1644:              /*$PAGE*/
1645:              /*
1646:              *********************************************************************************************************
1647:              *                                              SCHEDULER
1648:              *
1649:              * Description: This function is called by other uC/OS-II services to determine whether a new, high
1650:              *              priority task has been made ready to run.  This function is invoked by TASK level code
1651:              *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
1652:              *
1653:              * Arguments  : none
1654:              *
1655:              * Returns    : none
1656:              *
1657:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1658:              *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
1659:              *********************************************************************************************************
1660:              */
1661:              
1662:              void  OS_Sched (void)
1663:              {
001D24  781F88     MOV W8, [W15++]
1664:              #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
1665:                  OS_CPU_SR  cpu_sr = 0u;
1666:              #endif
1667:              
1668:              
1669:              
1670:                  OS_ENTER_CRITICAL();
001D26  800218     MOV SR, W8
001D28  200E00     MOV #0xE0, W0
001D2A  B72042     IOR SR
1671:                  if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
001D2C  E24960     CP0.B OSIntNesting
001D2E  3A001C     BRA NZ, 0x1D68
1672:                      if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
001D30  E24961     CP0.B OSLockNesting
1673:                          OS_SchedNew();
001D32  3A001A     BRA NZ, 0x1D68
001D34  07FED2     RCALL _OS_SchedNew
1674:                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
001D36  209631     MOV #0x963, W1
001D38  784091     MOV.B [W1], W1
001D3A  FB8001     ZE W1, W0
001D3C  400000     ADD W0, W0, W0
001D3E  20A742     MOV #0xA74, W2
001D40  780062     MOV [W2+W0], W0
001D42  885380     MOV W0, OSTCBHighRdy
1675:                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
001D44  209622     MOV #0x962, W2
001D46  784112     MOV.B [W2], W2
001D48  514F81     SUB.B W2, W1, [W15]
001D4A  32000E     BRA Z, 0x1D68
1676:              #if OS_TASK_PROFILE_EN > 0u
1677:                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
001D4C  900970     MOV [W0+30], W2
001D4E  901180     MOV [W0+32], W3
001D50  410161     ADD W2, #0x1, W2
001D52  4981E0     ADDC W3, #0x0, W3
001D54  980872     MOV W2, [W0+30]
001D56  981003     MOV W3, [W0+32]
1678:              #endif
1679:                              OSCtxSwCtr++;                          /* Increment context switch counter             */
001D58  804280     MOV OSCtxSwCtr, W0
001D5A  804291     MOV 0x852, W1
001D5C  400061     ADD W0, #0x1, W0
001D5E  4880E0     ADDC W1, #0x0, W1
001D60  884280     MOV W0, OSCtxSwCtr
001D62  884291     MOV W1, 0x852
1680:              
1681:              #if OS_TASK_CREATE_EXT_EN > 0u
1682:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1683:                              OS_TLS_TaskSw();
1684:              #endif
1685:              #endif
1686:              
1687:                              OS_TASK_SW();                          /* Perform a context switch                     */
001D64  022C04     CALL 0x2C04
001D66  000000     NOP
1688:                          }
1689:                      }
1690:                  }
1691:                  OS_EXIT_CRITICAL();
001D68  880218     MOV W8, SR
1692:              }
001D6A  78044F     MOV [--W15], W8
001D6C  060000     RETURN
1693:              
1694:              
1695:              /*
1696:              *********************************************************************************************************
1697:              *                               FIND HIGHEST PRIORITY TASK READY TO RUN
1698:              *
1699:              * Description: This function is called by other uC/OS-II services to determine the highest priority task
1700:              *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
1701:              *
1702:              * Arguments  : none
1703:              *
1704:              * Returns    : none
1705:              *
1706:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1707:              *              2) Interrupts are assumed to be disabled when this function is called.
1708:              *********************************************************************************************************
1709:              */
1710:              
1711:              static  void  OS_SchedNew (void)
1712:              {
1713:              #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
1714:                  INT8U   y;
1715:              
1716:              
1717:                  y             = OSUnMapTbl[OSRdyGrp];
001ADA  209641     MOV #0x964, W1
001ADC  784091     MOV.B [W1], W1
001ADE  FB8081     ZE W1, W1
001AE0  298A60     MOV #0x98A6, W0
001AE2  78C0E0     MOV.B [W0+W1], W1
1718:                  OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
001AE4  FB8101     ZE W1, W2
001AE6  209653     MOV #0x965, W3
001AE8  794163     MOV.B [W3+W2], W2
001AEA  FB8102     ZE W2, W2
001AEC  200033     MOV #0x3, W3
001AEE  DD0883     SL W1, W3, W1
001AF0  794060     MOV.B [W0+W2], W0
001AF2  404081     ADD.B W0, W1, W1
001AF4  209630     MOV #0x963, W0
001AF6  784801     MOV.B W1, [W0]
1719:              #else                                            /* We support up to 256 tasks                         */
1720:                  INT8U     y;
1721:                  OS_PRIO  *ptbl;
1722:              
1723:              
1724:                  if ((OSRdyGrp & 0xFFu) != 0u) {
1725:                      y = OSUnMapTbl[OSRdyGrp & 0xFFu];
1726:                  } else {
1727:                      y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
1728:                  }
1729:                  ptbl = &OSRdyTbl[y];
1730:                  if ((*ptbl & 0xFFu) != 0u) {
1731:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
1732:                  } else {
1733:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
1734:                  }
1735:              #endif
1736:              }
001AF8  060000     RETURN
1737:              
1738:              /*$PAGE*/
1739:              /*
1740:              *********************************************************************************************************
1741:              *                               DETERMINE THE LENGTH OF AN ASCII STRING
1742:              *
1743:              * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
1744:              *              (excluding the NUL character).
1745:              *
1746:              * Arguments  : psrc     is a pointer to the string for which we need to know the size.
1747:              *
1748:              * Returns    : The size of the string (excluding the NUL terminating character)
1749:              *
1750:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1751:              *              2) The string to check must be less than 255 characters long.
1752:              *********************************************************************************************************
1753:              */
1754:              
1755:              #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
1756:              INT8U  OS_StrLen (INT8U *psrc)
1757:              {
1758:                  INT8U  len;
1759:              
1760:              
1761:              #if OS_ARG_CHK_EN > 0u
1762:                  if (psrc == (INT8U *)0) {
1763:                      return (0u);
1764:                  }
1765:              #endif
1766:              
1767:                  len = 0u;
1768:                  while (*psrc != OS_ASCII_NUL) {
001D9C  780080     MOV W0, W1
001D9E  50C100     SUB.B W1, W0, W2
001DA0  E00431     CP0.B [W1++]
001DA2  3AFFFD     BRA NZ, 0x1D9E
1769:                      psrc++;
1770:                      len++;
1771:                  }
1772:                  return (len);
1773:              }
001DA4  784002     MOV.B W2, W0
001DA6  060000     RETURN
1774:              #endif
1775:              /*$PAGE*/
1776:              /*
1777:              *********************************************************************************************************
1778:              *                                              IDLE TASK
1779:              *
1780:              * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
1781:              *              executes because they are ALL waiting for event(s) to occur.
1782:              *
1783:              * Arguments  : none
1784:              *
1785:              * Returns    : none
1786:              *
1787:              * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
1788:              *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
1789:              *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
1790:              *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
1791:              *                 interrupts.
1792:              *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
1793:              *                 power.
1794:              *********************************************************************************************************
1795:              */
1796:              
1797:              void  OS_TaskIdle (void *p_arg)
1798:              {
1799:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1800:                  OS_CPU_SR  cpu_sr = 0u;
1801:              #endif
1802:              
1803:              
1804:              
1805:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1806:                  for (;;) {
1807:                      OS_ENTER_CRITICAL();
001AFA  800212     MOV SR, W2
001AFC  200E00     MOV #0xE0, W0
001AFE  B72042     IOR SR
1808:                      OSIdleCtr++;
001B00  804B40     MOV OSIdleCtr, W0
001B02  804B51     MOV 0x96A, W1
001B04  400061     ADD W0, #0x1, W0
001B06  4880E0     ADDC W1, #0x0, W1
001B08  884B40     MOV W0, OSIdleCtr
001B0A  884B51     MOV W1, 0x96A
1809:                      OS_EXIT_CRITICAL();
001B0C  880212     MOV W2, SR
1810:                      OSTaskIdleHook();                        /* Call user definable HOOK                           */
001B0E  022C8C     CALL OSTaskIdleHook
001B10  000000     NOP
001B12  37FFF3     BRA OS_TaskIdle
1811:                  }
1812:              }
1813:              /*$PAGE*/
1814:              /*
1815:              *********************************************************************************************************
1816:              *                                           STATISTICS TASK
1817:              *
1818:              * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
1819:              *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
1820:              *              CPU usage is determined by:
1821:              *
1822:              *                                          OSIdleCtr
1823:              *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
1824:              *                                         OSIdleCtrMax
1825:              *
1826:              * Arguments  : parg     this pointer is not used at this time.
1827:              *
1828:              * Returns    : none
1829:              *
1830:              * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
1831:              *                 next higher priority, OS_TASK_IDLE_PRIO-1.
1832:              *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
1833:              *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
1834:              *                 maximum value for the idle counter.
1835:              *********************************************************************************************************
1836:              */
1837:              
1838:              #if OS_TASK_STAT_EN > 0u
1839:              void  OS_TaskStat (void *p_arg)
1840:              {
001DE6  781F88     MOV W8, [W15++]
1841:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1842:                  OS_CPU_SR  cpu_sr = 0u;
1843:              #endif
1844:              
1845:              
1846:              
1847:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1848:                  while (OSStatRdy == OS_FALSE) {
001DE8  370004     BRA 0x1DF2
001DF2  E2485E     CP0.B OSStatRdy
001DF4  32FFFA     BRA Z, 0x1DEA
1849:                      OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
001DEA  200C80     MOV #0xC8, W0
001DEC  200001     MOV #0x0, W1
001DEE  022726     CALL OSTimeDly
001DF0  000000     NOP
1850:                  }
1851:                  OSIdleCtrMax /= 100uL;
001DF6  200642     MOV #0x64, W2
001DF8  200003     MOV #0x0, W3
001DFA  8042B0     MOV OSIdleCtrMax, W0
001DFC  8042C1     MOV 0x858, W1
001DFE  0203E2     CALL 0x3E2
001E00  000000     NOP
001E02  8842B0     MOV W0, OSIdleCtrMax
001E04  8842C1     MOV W1, 0x858
1852:                  if (OSIdleCtrMax == 0uL) {
001E06  500FE0     SUB W0, #0x0, [W15]
001E08  588FE0     SUBB W1, #0x0, [W15]
001E0A  3A0004     BRA NZ, 0x1E14
1853:                      OSCPUUsage = 0u;
001E0C  EF6854     CLR.B OSCPUUsage
1854:              #if OS_TASK_SUSPEND_EN > 0u
1855:                      (void)OSTaskSuspend(OS_PRIO_SELF);
001E0E  EBC000     SETM.B W0
001E10  02219C     CALL OSTaskSuspend
001E12  000000     NOP
1856:              #else
1857:                      for (;;) {
1858:                          OSTimeDly(OS_TICKS_PER_SEC);
1859:                      }
1860:              #endif
1861:                  }
1862:                  OS_ENTER_CRITICAL();
001E14  800218     MOV SR, W8
001E16  200E00     MOV #0xE0, W0
001E18  B72042     IOR SR
1863:                  OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
001E1A  200642     MOV #0x64, W2
001E1C  200003     MOV #0x0, W3
001E1E  8042B0     MOV OSIdleCtrMax, W0
001E20  8042C1     MOV 0x858, W1
001E22  020402     CALL 0x402
001E24  000000     NOP
001E26  884B40     MOV W0, OSIdleCtr
001E28  884B51     MOV W1, 0x96A
1864:                  OS_EXIT_CRITICAL();
001E2A  880218     MOV W8, SR
1865:                  for (;;) {
1866:                      OS_ENTER_CRITICAL();
001E2C  800212     MOV SR, W2
001E2E  200E00     MOV #0xE0, W0
001E30  B72042     IOR SR
1867:                      OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
001E32  804B40     MOV OSIdleCtr, W0
001E34  804B51     MOV 0x96A, W1
001E36  8842D0     MOV W0, OSIdleCtrRun
001E38  8842E1     MOV W1, 0x85C
1868:                      OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
001E3A  EF2968     CLR OSIdleCtr
001E3C  EF296A     CLR 0x96A
1869:                      OS_EXIT_CRITICAL();
001E3E  880212     MOV W2, SR
1870:                      OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
001E40  8042B2     MOV OSIdleCtrMax, W2
001E42  8042C3     MOV 0x858, W3
001E44  0203E2     CALL 0x3E2
001E46  000000     NOP
001E48  B3C642     MOV.B #0x64, W2
001E4A  514080     SUB.B W2, W0, W1
001E4C  208540     MOV #0x854, W0
001E4E  784801     MOV.B W1, [W0]
1871:                      OSTaskStatHook();                        /* Invoke user definable hook                         */
001E50  022C90     CALL OSTaskStatHook
1872:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1873:                      OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
001E52  000000     NOP
001E54  07FFA9     RCALL OS_TaskStatStkChk
1874:              #endif
1875:                      OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
001E56  200640     MOV #0x64, W0
001E58  200001     MOV #0x0, W1
001E5A  022726     CALL OSTimeDly
001E5C  000000     NOP
001E5E  37FFE6     BRA 0x1E2C
1876:                  }
1877:              }
1878:              #endif
1879:              /*$PAGE*/
1880:              /*
1881:              *********************************************************************************************************
1882:              *                                        CHECK ALL TASK STACKS
1883:              *
1884:              * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
1885:              *
1886:              * Arguments  : none
1887:              *
1888:              * Returns    : none
1889:              *********************************************************************************************************
1890:              */
1891:              
1892:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1893:              void  OS_TaskStatStkChk (void)
1894:              {
001DA8  FA0008     LNK #0x8
001DAA  BE9F88     MOV.D W8, [W15++]
1895:                  OS_TCB      *ptcb;
1896:                  OS_STK_DATA  stk_data;
1897:                  INT8U        err;
1898:                  INT8U        prio;
1899:              
1900:              
1901:                  for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
001DAC  20A749     MOV #0xA74, W9
001DAE  EB4400     CLR.B W8
001DD8  E84408     INC.B W8, W8
001DDA  E88489     INC2 W9, W9
001DDC  544FE5     SUB.B W8, #0x5, [W15]
001DDE  3AFFE8     BRA NZ, 0x1DB0
1902:                      err = OSTaskStkChk(prio, &stk_data);
001DB0  5780EC     SUB W15, #0xC, W1
001DB2  784008     MOV.B W8, W0
001DB4  022144     CALL OSTaskStkChk
001DB6  000000     NOP
1903:                      if (err == OS_ERR_NONE) {
001DB8  E00400     CP0.B W0
001DBA  3A000E     BRA NZ, 0x1DD8
1904:                          ptcb = OSTCBPrioTbl[prio];
001DBC  780019     MOV [W9], W0
1905:                          if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
001DBE  E00000     CP0 W0
001DC0  32000B     BRA Z, 0x1DD8
1906:                              if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
001DC2  500FE1     SUB W0, #0x1, [W15]
001DC4  320009     BRA Z, 0x1DD8
1907:              #if OS_TASK_PROFILE_EN > 0u
1908:                                  #if OS_STK_GROWTH == 1u
1909:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
1910:                                  #else
1911:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
001DC6  9000B0     MOV [W0+6], W1
001DC8  408081     ADD W1, W1, W1
001DCA  900120     MOV [W0+4], W2
001DCC  510081     SUB W2, W1, W1
001DCE  981051     MOV W1, [W0+42]
1912:                                  #endif
1913:                                  ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
001DD0  97B94F     MOV [W15-8], W2
001DD2  97B9DF     MOV [W15-6], W3
001DD4  981062     MOV W2, [W0+44]
001DD6  981073     MOV W3, [W0+46]
1914:              #endif
1915:                              }
1916:                          }
1917:                      }
1918:                  }
1919:              }
001DE0  BE044F     MOV.D [--W15], W8
001DE2  FA8000     ULNK
001DE4  060000     RETURN
1920:              #endif
1921:              /*$PAGE*/
1922:              /*
1923:              *********************************************************************************************************
1924:              *                                           INITIALIZE TCB
1925:              *
1926:              * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
1927:              *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
1928:              *
1929:              * Arguments  : prio          is the priority of the task being created
1930:              *
1931:              *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
1932:              *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
1933:              *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
1934:              *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
1935:              *                            specific.
1936:              *
1937:              *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
1938:              *                            'OSTaskCreate()'.
1939:              *
1940:              *              id            is the task's ID (0..65535)
1941:              *
1942:              *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
1943:              *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
1944:              *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
1945:              *                            units are established by the #define constant OS_STK which is CPU
1946:              *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
1947:              *
1948:              *              pext          is a pointer to a user supplied memory area that is used to extend the task
1949:              *                            control block.  This allows you to store the contents of floating-point
1950:              *                            registers, MMU registers or anything else you could find useful during a
1951:              *                            context switch.  You can even assign a name to each task and store this name
1952:              *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
1953:              *
1954:              *              opt           options as passed to 'OSTaskCreateExt()' or,
1955:              *                            0 if called from 'OSTaskCreate()'.
1956:              *
1957:              * Returns    : OS_ERR_NONE              if the call was successful
1958:              *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task
1959:              *                                       cannot be created.
1960:              *
1961:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1962:              *********************************************************************************************************
1963:              */
1964:              
1965:              INT8U  OS_TCBInit (INT8U    prio,
1966:                                 OS_STK  *ptos,
1967:                                 OS_STK  *pbos,
1968:                                 INT16U   id,
1969:                                 INT32U   stk_size,
1970:                                 void    *pext,
1971:                                 INT16U   opt)
1972:              {
001E60  BE9F88     MOV.D W8, [W15++]
001E62  BE9F8A     MOV.D W10, [W15++]
001E64  784400     MOV.B W0, W8
1973:                  OS_TCB    *ptcb;
1974:              #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
1975:                  OS_CPU_SR  cpu_sr = 0u;
1976:              #endif
1977:              #if OS_TASK_REG_TBL_SIZE > 0u
1978:                  INT8U      i;
1979:              #endif
1980:              #if OS_TASK_CREATE_EXT_EN > 0u
1981:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1982:                  INT8U      j;
1983:              #endif
1984:              #endif
1985:              
1986:              
1987:                  OS_ENTER_CRITICAL();
001E66  80021A     MOV SR, W10
001E68  200E00     MOV #0xE0, W0
001E6A  B72042     IOR SR
1988:                  ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
001E6C  805379     MOV OSTCBFreeList, W9
1989:                  if (ptcb != (OS_TCB *)0) {
001E6E  E00009     CP0 W9
001E70  320059     BRA Z, 0x1F24
1990:                      OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
001E72  9005F9     MOV [W9+14], W11
001E74  88537B     MOV W11, OSTCBFreeList
1991:                      OS_EXIT_CRITICAL();
001E76  88021A     MOV W10, SR
1992:                      ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
001E78  780C81     MOV W1, [W9]
1993:                      ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
001E7A  985C88     MOV.B W8, [W9+24]
1994:                      ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
001E7C  EB4000     CLR.B W0
001E7E  9854E0     MOV.B W0, [W9+22]
1995:                      ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
001E80  9854F0     MOV.B W0, [W9+23]
1996:                      ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
001E82  B80060     MUL.UU W0, #0, W0
001E84  980C90     MOV W0, [W9+18]
001E86  980CA1     MOV W1, [W9+20]
1997:              
1998:              #if OS_TASK_CREATE_EXT_EN > 0u
1999:                      ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
001E88  980496     MOV W6, [W9+2]
2000:                      ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
001E8A  9804B4     MOV W4, [W9+6]
001E8C  9804C5     MOV W5, [W9+8]
2001:                      ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
001E8E  9804A2     MOV W2, [W9+4]
2002:                      ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
001E90  9804D7     MOV W7, [W9+10]
2003:                      ptcb->OSTCBId            = id;                     /* Store task ID                            */
001E92  9804E3     MOV W3, [W9+12]
2004:              #else
2005:                      pext                     = pext;                   /* Prevent compiler warning if not used     */
2006:                      stk_size                 = stk_size;
2007:                      pbos                     = pbos;
2008:                      opt                      = opt;
2009:                      id                       = id;
2010:              #endif
2011:              
2012:              #if OS_TASK_DEL_EN > 0u
2013:                      ptcb->OSTCBDelReq        = OS_ERR_NONE;
2014:              #endif
2015:              
2016:              #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
2017:                      ptcb->OSTCBY             = (INT8U)(prio >> 3u);
001E94  FB8508     ZE W8, W10
001E96  DE5243     LSR W10, #3, W4
001E98  985CA4     MOV.B W4, [W9+26]
2018:                      ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
001E9A  644467     AND.B W8, #0x7, W8
001E9C  985C98     MOV.B W8, [W9+25]
2019:              #else                                                             /* Pre-compute X, Y                  */
2020:                      ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
2021:                      ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
2022:              #endif
2023:                                                                                /* Pre-compute BitX and BitY         */
2024:                      ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
001E9E  200012     MOV #0x1, W2
001EA0  200003     MOV #0x0, W3
001EA2  BE0302     MOV.D W2, W6
001EA4  780584     MOV W4, W11
001EA6  E9058B     DEC W11, W11
001EA8  330003     BRA N, 0x1EB0
001EAA  430306     ADD W6, W6, W6
001EAC  4B8387     ADDC W7, W7, W7
001EAE  37FFFB     BRA 0x1EA6
001EB0  985CC6     MOV.B W6, [W9+28]
2025:                      ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
001EB2  FB8408     ZE W8, W8
001EB4  E90408     DEC W8, W8
001EB6  330003     BRA N, 0x1EBE
001EB8  410102     ADD W2, W2, W2
001EBA  498183     ADDC W3, W3, W3
001EBC  37FFFB     BRA 0x1EB4
001EBE  985CB2     MOV.B W2, [W9+27]
2026:              
2027:              #if (OS_EVENT_EN)
2028:                      ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
2029:              #if (OS_EVENT_MULTI_EN > 0u)
2030:                      ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
2031:              #endif
2032:              #endif
2033:              
2034:              #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
2035:                      ptcb->OSTCBFlagNode      = (OS_FLAG_NODE *)0;      /* Task is not pending on an event flag     */
2036:              #endif
2037:              
2038:              #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
2039:                      ptcb->OSTCBMsg           = (void *)0;              /* No message received                      */
2040:              #endif
2041:              
2042:              #if OS_TASK_PROFILE_EN > 0u
2043:                      ptcb->OSTCBCtxSwCtr      = 0uL;                    /* Initialize profiling variables           */
001EC0  980CF0     MOV W0, [W9+30]
001EC2  981481     MOV W1, [W9+32]
2044:                      ptcb->OSTCBCyclesStart   = 0uL;
001EC4  9814B0     MOV W0, [W9+38]
001EC6  9814C1     MOV W1, [W9+40]
2045:                      ptcb->OSTCBCyclesTot     = 0uL;
001EC8  981490     MOV W0, [W9+34]
001ECA  9814A1     MOV W1, [W9+36]
2046:                      ptcb->OSTCBStkBase       = (OS_STK *)0;
001ECC  EB0400     CLR W8
001ECE  9814D8     MOV W8, [W9+42]
2047:                      ptcb->OSTCBStkUsed       = 0uL;
001ED0  9814E0     MOV W0, [W9+44]
001ED2  9814F1     MOV W1, [W9+46]
2048:              #endif
2049:              
2050:              #if OS_TASK_NAME_EN > 0u
2051:                      ptcb->OSTCBTaskName      = (INT8U *)(void *)"?";
001ED4  298A42     MOV #0x98A4, W2
001ED6  981C82     MOV W2, [W9+48]
2052:              #endif
2053:              
2054:              #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
2055:                      for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
2056:                          ptcb->OSTCBRegTbl[i] = 0u;
001ED8  981C90     MOV W0, [W9+50]
001EDA  981CA1     MOV W1, [W9+52]
2057:                      }
2058:              #endif
2059:              
2060:                      OSTCBInitHook(ptcb);
001EDC  780009     MOV W9, W0
001EDE  022C94     CALL OSTCBInitHook
001EE0  000000     NOP
2061:              
2062:                      OS_ENTER_CRITICAL();
001EE2  800212     MOV SR, W2
001EE4  200E00     MOV #0xE0, W0
001EE6  B72042     IOR SR
2063:                      OSTCBPrioTbl[prio] = ptcb;
001EE8  45050A     ADD W10, W10, W10
001EEA  20A741     MOV #0xA74, W1
001EEC  7D3089     MOV W9, [W1+W10]
2064:                      OS_EXIT_CRITICAL();
001EEE  880212     MOV W2, SR
2065:              
2066:                      OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
001EF0  780009     MOV W9, W0
001EF2  022C88     CALL OSTaskCreateHook
001EF4  000000     NOP
2067:              
2068:              #if OS_TASK_CREATE_EXT_EN > 0u
2069:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
2070:                      for (j = 0u; j < OS_TLS_TBL_SIZE; j++) {
2071:                          ptcb->OSTCBTLSTbl[j] = (OS_TLS)0;
2072:                      }
2073:                      OS_TLS_TaskCreate(ptcb);                           /* Call TLS hook                            */
2074:              #endif
2075:              #endif
2076:              
2077:                      OS_ENTER_CRITICAL();
001EF6  800211     MOV SR, W1
001EF8  200E00     MOV #0xE0, W0
001EFA  B72042     IOR SR
2078:                      ptcb->OSTCBNext = OSTCBList;                       /* Link into TCB chain                      */
001EFC  805390     MOV OSTCBList, W0
001EFE  9804F0     MOV W0, [W9+14]
2079:                      ptcb->OSTCBPrev = (OS_TCB *)0;         
001F00  980C88     MOV W8, [W9+16]
2080:                      if (OSTCBList != (OS_TCB *)0) {
001F02  E00000     CP0 W0
001F04  320001     BRA Z, 0x1F08
2081:                          OSTCBList->OSTCBPrev = ptcb;
001F06  980809     MOV W9, [W0+16]
2082:                      }
2083:                      OSTCBList               = ptcb;
001F08  885399     MOV W9, OSTCBList
2084:                      OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
001F0A  905849     MOV.B [W9+28], W0
001F0C  B76964     IOR.B OSRdyGrp
2085:                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
001F0E  905829     MOV.B [W9+26], W0
001F10  FB8000     ZE W0, W0
001F12  209652     MOV #0x965, W2
001F14  784262     MOV.B [W2+W0], W4
001F16  9059B9     MOV.B [W9+27], W3
001F18  724183     IOR.B W4, W3, W3
001F1A  787103     MOV.B W3, [W2+W0]
2086:                      OSTaskCtr++;                                       /* Increment the #tasks counter             */
001F1C  EC6967     INC.B OSTaskCtr
2087:                      OS_EXIT_CRITICAL();
001F1E  880211     MOV W1, SR
2088:                      return (OS_ERR_NONE);
001F20  EB4000     CLR.B W0
001F22  370002     BRA 0x1F28
2089:                  }
2090:                  OS_EXIT_CRITICAL();
001F24  88021A     MOV W10, SR
2091:                  return (OS_ERR_TASK_NO_MORE_TCB);
001F26  B3C420     MOV.B #0x42, W0
2092:              }
001F28  BE054F     MOV.D [--W15], W10
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uCOS-II/Ports/os_cpu_c.c  ------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                               uC/OS-II
4:                 *                                         The Real-Time Kernel
5:                 *
6:                 *                               (c) Copyright 2006, Micrium, Weston, FL
7:                 *                                          All Rights Reserved
8:                 *
9:                 *
10:                *                                          dsPIC33/PIC24 MPLab Port
11:                *
12:                *
13:                * File         : OS_CPU_C.C
14:                * By           : Eric Shufro
15:                * Port Version : V2.81 (and higher)
16:                *********************************************************************************************************
17:                */
18:                
19:                #include  "uCOS_II.H"
20:                
21:                /*
22:                *********************************************************************************************************
23:                *                                             LOCALS
24:                *********************************************************************************************************
25:                */
26:                
27:                #if OS_TMR_EN > 0
28:                static  INT16U  OSTmrCtr;
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                       OS INITIALIZATION HOOK
34:                *                                            (BEGINNING)
35:                *
36:                * Description: This function is called by OSInit() at the beginning of OSInit().
37:                *
38:                * Arguments  : none
39:                *
40:                * Note(s)    : 1) Interrupts should be disabled during this call.
41:                *********************************************************************************************************
42:                */
43:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
44:                void  OSInitHookBegin (void)
45:                {
46:                #if OS_TMR_EN > 0
47:                    OSTmrCtr =      0;
48:                #endif
49:                
50:                    SPLIM    = 0xFFFE;                                                  /* Initialize the stack pointer limit register to a maximum */
002C80  2FFFE0     MOV #0xFFFE, W0
002C82  880100     MOV W0, SPLIM
51:                }                                                                       /* address thus effectively disabling stack checking        */
002C84  060000     RETURN
52:                #endif
53:                
54:                /*
55:                *********************************************************************************************************
56:                *                                       OS INITIALIZATION HOOK
57:                *                                               (END)
58:                *
59:                * Description: This function is called by OSInit() at the end of OSInit().
60:                *
61:                * Arguments  : none
62:                *
63:                * Note(s)    : 1) Interrupts should be disabled during this call.
64:                *********************************************************************************************************
65:                */
66:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
67:                void  OSInitHookEnd (void)
68:                {
69:                #if OS_CPU_INT_DIS_MEAS_EN > 0
70:                    OS_CPU_IntDisMeasInit();
71:                #endif
72:                }
002C86  060000     RETURN
73:                #endif
74:                
75:                /*$PAGE*/
76:                /*
77:                *********************************************************************************************************
78:                *                                          TASK CREATION HOOK
79:                *
80:                * Description: This function is called when a task is created.
81:                *
82:                * Arguments  : ptcb   is a pointer to the task control block of the task being created.
83:                *
84:                * Note(s)    : 1) Interrupts are disabled during this call.
85:                *********************************************************************************************************
86:                */
87:                #if OS_CPU_HOOKS_EN > 0
88:                void  OSTaskCreateHook (OS_TCB *ptcb)
89:                {
90:                #if OS_APP_HOOKS_EN > 0
91:                    App_TaskCreateHook(ptcb);
92:                #else
93:                    (void)ptcb;                                                         /* Prevent compiler warning                                 */
94:                #endif
95:                }
002C88  060000     RETURN
96:                #endif
97:                
98:                /*
99:                *********************************************************************************************************
100:               *                                           TASK DELETION HOOK
101:               *
102:               * Description: This function is called when a task is deleted.
103:               *
104:               * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
105:               *
106:               * Note(s)    : 1) Interrupts are disabled during this call.
107:               *********************************************************************************************************
108:               */
109:               #if OS_CPU_HOOKS_EN > 0
110:               void  OSTaskDelHook (OS_TCB *ptcb)
111:               {
112:               #if OS_APP_HOOKS_EN > 0
113:                   App_TaskDelHook(ptcb);
114:               #else
115:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
116:               #endif
117:               }
002C8A  060000     RETURN
118:               #endif
119:               
120:               /*
121:               *********************************************************************************************************
122:               *                                             IDLE TASK HOOK
123:               *
124:               * Description: This function is called by the idle task.  This hook has been added to allow you to do
125:               *              such things as STOP the CPU to conserve power.
126:               *
127:               * Arguments  : none
128:               *
129:               * Note(s)    : 1) Interrupts are enabled during this call.
130:               *********************************************************************************************************
131:               */
132:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
133:               void  OSTaskIdleHook (void)
134:               {
135:               #if OS_APP_HOOKS_EN > 0
136:                   App_TaskIdleHook();
137:               #endif
138:               }
002C8C  060000     RETURN
139:               #endif
140:               
141:               /*
142:               *********************************************************************************************************
143:               *                                            TASK RETURN HOOK
144:               *
145:               * Description: This function is called if a task accidentally returns.  In other words, a task should
146:               *              either be an infinite loop or delete itself when done.
147:               *
148:               * Arguments  : ptcb      is a pointer to the task control block of the task that is returning.
149:               *
150:               * Note(s)    : none
151:               *********************************************************************************************************
152:               */
153:               
154:               #if OS_CPU_HOOKS_EN > 0u
155:               void  OSTaskReturnHook (OS_TCB  *ptcb)
156:               {
157:               #if OS_APP_HOOKS_EN > 0u
158:                   App_TaskReturnHook(ptcb);
159:               #else
160:                   (void)ptcb;
161:               #endif
162:               }
002C8E  060000     RETURN
163:               #endif
164:               /*
165:               *********************************************************************************************************
166:               *                                           STATISTIC TASK HOOK
167:               *
168:               * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
169:               *              application to add functionality to the statistics task.
170:               *
171:               * Arguments  : none
172:               *********************************************************************************************************
173:               */
174:               
175:               #if OS_CPU_HOOKS_EN > 0
176:               void  OSTaskStatHook (void)
177:               {
178:               #if OS_APP_HOOKS_EN > 0
179:                   App_TaskStatHook();
180:               #endif
181:               }
002C90  060000     RETURN
182:               #endif
183:               
184:               /*$PAGE*/
185:               /*
186:               *********************************************************************************************************
187:               *                                           TASK SWITCH HOOK
188:               *
189:               * Description: This function is called when a task switch is performed.  This allows you to perform other
190:               *              operations during a context switch.
191:               *
192:               * Arguments  : none
193:               *
194:               * Note(s)    : 1) Interrupts are disabled during this call.
195:               *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
196:               *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
197:               *                 task being switched out (i.e. the preempted task).
198:               *********************************************************************************************************
199:               */
200:               #if OS_CPU_HOOKS_EN > 0
201:               void  OSTaskSwHook (void)
202:               {
203:               #if OS_APP_HOOKS_EN > 0
204:                   App_TaskSwHook();
205:               #endif
206:               }
002C92  060000     RETURN
207:               #endif
208:               
209:               /*
210:               *********************************************************************************************************
211:               *                                           OSTCBInit() HOOK
212:               *
213:               * Description: This function is called by OS_TCBInit() after setting up most of the TCB.
214:               *
215:               * Arguments  : ptcb    is a pointer to the TCB of the task being created.
216:               *
217:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
218:               *********************************************************************************************************
219:               */
220:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
221:               void  OSTCBInitHook (OS_TCB *ptcb)
222:               {
223:               #if OS_APP_HOOKS_EN > 0
224:                   App_TCBInitHook(ptcb);
225:               #else
226:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
227:               #endif
228:               }
002C94  060000     RETURN
229:               #endif
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                               TICK HOOK
234:               *
235:               * Description: This function is called every tick.
236:               *
237:               * Arguments  : none
238:               *
239:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
240:               *********************************************************************************************************
241:               */
242:               #if (OS_CPU_HOOKS_EN > 0) && (OS_TIME_TICK_HOOK_EN > 0)
243:               void  OSTimeTickHook (void)
244:               {
245:               #if OS_APP_HOOKS_EN > 0
246:                   App_TimeTickHook();
247:               #endif
248:               
249:               #if OS_TMR_EN > 0
250:                   OSTmrCtr++;
251:                   if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
252:                       OSTmrCtr = 0;
253:                       OSTmrSignal();
254:                   }
255:               #endif
256:               }
257:               #endif
258:               
259:               /*
260:               *********************************************************************************************************
261:               *                             INTERRUPT DISABLE TIME MEASUREMENT, START
262:               *********************************************************************************************************
263:               */
264:               
265:               #if OS_CPU_INT_DIS_MEAS_EN > 0u
266:               void  OS_CPU_IntDisMeasInit (void)
267:               {
268:                   OS_CPU_IntDisMeasNestingCtr = 0u;
269:                   OS_CPU_IntDisMeasCntsEnter  = 0u;
270:                   OS_CPU_IntDisMeasCntsExit   = 0u;
271:                   OS_CPU_IntDisMeasCntsMax    = 0u;
272:                   OS_CPU_IntDisMeasCntsDelta  = 0u;
273:                   OS_CPU_IntDisMeasCntsOvrhd  = 0u;
274:                   OS_CPU_IntDisMeasStart();                              /* Measure the overhead of the functions    */
275:                   OS_CPU_IntDisMeasStop();
276:                   OS_CPU_IntDisMeasCntsOvrhd  = OS_CPU_IntDisMeasCntsDelta;
277:               }
278:               
279:               
280:               void  OS_CPU_IntDisMeasStart (void)
281:               {
282:                   OS_CPU_IntDisMeasNestingCtr++;
283:                   if (OS_CPU_IntDisMeasNestingCtr == 1u) {               /* Only measure at the first nested level   */
284:                       OS_CPU_IntDisMeasCntsEnter = OS_CPU_IntDisMeasTmrRd();
285:                   }
286:               }
287:               
288:               
289:               void  OS_CPU_IntDisMeasStop (void)
290:               {
291:                   OS_CPU_IntDisMeasNestingCtr--;                                      /* Decrement nesting ctr       */
292:                   if (OS_CPU_IntDisMeasNestingCtr == 0u) {
293:                       OS_CPU_IntDisMeasCntsExit  = OS_CPU_IntDisMeasTmrRd();
294:                       OS_CPU_IntDisMeasCntsDelta = OS_CPU_IntDisMeasCntsExit - OS_CPU_IntDisMeasCntsEnter;
295:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsOvrhd) {  /* Ensure overhead < delta     */
296:                           OS_CPU_IntDisMeasCntsDelta -= OS_CPU_IntDisMeasCntsOvrhd;
297:                       } else {
298:                           OS_CPU_IntDisMeasCntsDelta  = OS_CPU_IntDisMeasCntsOvrhd;
299:                       }
300:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsMax) {    /* Track MAXIMUM               */
301:                           OS_CPU_IntDisMeasCntsMax = OS_CPU_IntDisMeasCntsDelta;
302:                       }
303:                   }
304:               }
305:               #endif
306:               /*$PAGE*/
307:               /*
308:               *********************************************************************************************************
309:               *                                        INITIALIZE A TASK'S STACK
310:               *
311:               * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
312:               *              stack frame of the task being created.  This function is highly processor specific.
313:               *
314:               * Arguments  : task          is a pointer to the task code
315:               *
316:               *              p_arg         is a pointer to a user supplied data area that will be passed to the task
317:               *                            when the task first executes.
318:               *
319:               *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
320:               *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
321:               *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
322:               *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
323:               *                            of the stack.
324:               *
325:               *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
326:               *                            (see uCOS_II.H for OS_TASK_OPT_???).
327:               *
328:               * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
329:               *              been placed on the stack in the proper order.
330:               *
331:               * Note(s)    : 1) You may pass a task creation parameters through the opt variable. You MUST only use the
332:               *                 upper 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make
333:               *                 changes to the code below, you will need to ensure that it doesn't affect the behaviour
334:               *                 of OSTaskIdle() and OSTaskStat().
335:               *              2) Registers are initialized to make them easy to differentiate with a debugger.
336:               *
337:               *              3) Setup the stack frame of the task:
338:               *
339:               *                        ptos -  0  ->
340:               *                        ptos -  2  ->  CORCON
341:               *                        ptos -  4  ->  SR (initialized to 0)
342:               *                        ptos -  6  ->  DOENDH
343:               *                        ptos -  8  ->  DOENDL
344:               *                        ptos - 10  ->  DOSTARTH
345:               *                        ptos - 12  ->  DOSTARTL
346:               *                        ptos - 14  ->  DCOUNT
347:               *                        ptos - 16  ->  RCOUNT
348:               *                        ptos - 18  ->  PSVPAG
349:               *                        ptos - 20  ->  TBLPAG
350:               *                        ptos - 22  ->  ACCBU
351:               *                        ptos - 24  ->  ACCBH
352:               *                        ptos - 26  ->  ACCBL
353:               *                        ptos - 28  ->  ACCAU
354:               *                        ptos - 30  ->  ACCAH
355:               *                        ptos - 32  ->  ACCAL
356:               *                        ptos - 34  ->  W14
357:               *                        ptos - 36  ->  W13
358:               *                        ptos - 38  ->  W12
359:               *                        ptos - 40  ->  W11
360:               *                        ptos - 42  ->  W10
361:               *                        ptos - 44  ->  W9
362:               *                        ptos - 46  ->  W8
363:               *                        ptos - 48  ->  W7
364:               *                        ptos - 50  ->  W6
365:               *                        ptos - 52  ->  W5
366:               *                        ptos - 54  ->  W4
367:               *                        ptos - 56  ->  W3
368:               *                        ptos - 58  ->  W2
369:               *                        ptos - 60  ->  W1
370:               *                        ptos - 62  ->  p_arg
371:               *                        ptos - 64  ->   0 (15..8) | CORCON.7 | PC (22..16)      Simulate ISR
372:               *                        ptos - 66  ->  PC (15..0)
373:               *                        ptos - 68  ->  PC (22..16)                              Simulate function call
374:               *                        ptos - 70  ->  PC (15..0)
375:               *********************************************************************************************************
376:               */
377:               
378:               OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
379:               {
380:                   INT16U  x;
381:                   INT16U   pc_high;
382:               
383:               
384:               	pc_high =   0;                                                      /* Upper byte of PC always 0. Pointers are 16 bit unsigned  */
385:               
386:                  *ptos++  =  (OS_STK)task;                                            /* Simulate a call to the task by putting 32 bits of data   */
002C96  781900     MOV W0, [W2++]
387:                  *ptos++  =  (OS_STK)pc_high;                                         /* data on the stack.                                       */
002C98  EB1900     CLR [W2++]
388:               
389:                                                                                       /* Simulate an interrupt                                    */
390:                  *ptos++  =  (OS_STK)task;                                            /* Put the address of this task on the stack (PC)           */
002C9A  781900     MOV W0, [W2++]
391:               
392:                   x       =  0;                                                       /* Set the SR to enable ALL interrupts                      */
002CA2  EB0180     CLR W3
393:                   if (CORCONbits.IPL3) {                                              /* Check the CPU's current interrupt level 3 bit            */
002C9E  AB6044     BTST CORCON, #3
002CA0  3A0001     BRA NZ, 0x2CA4
394:                       x  |= 0x0080;                                                   /* If set, then save the priority level bit in x bit [7]    */
002C9C  200803     MOV #0x80, W3
395:                   }
396:                  *ptos++  = (OS_STK)(x | (INT16U)pc_high);                            /* Push the SR Low, CORCON IPL3 and PC (22..16)             */
002CA4  780002     MOV W2, W0
002CA6  781803     MOV W3, [W0++]
397:               
398:                                                                                       /* Push all of the registers to stack                       */
399:                  *ptos++  = (OS_STK)p_arg;                                            /* Register W0 holds data passed to the task when started   */
002CA8  781801     MOV W1, [W0++]
400:                  *ptos++  = 0x1111;                                                   /* Initialize register W1                                   */
002CAA  211111     MOV #0x1111, W1
002CAC  781801     MOV W1, [W0++]
401:                  *ptos++  = 0x2222;                                                   /* Initialize register W2                                   */
002CAE  222221     MOV #0x2222, W1
002CB0  781801     MOV W1, [W0++]
402:                  *ptos++  = 0x3333;                                                   /* Initialize register W3                                   */
002CB2  233331     MOV #0x3333, W1
002CB4  781801     MOV W1, [W0++]
403:                  *ptos++  = 0x4444;                                                   /* Initialize register W4                                   */
002CB6  244441     MOV #0x4444, W1
002CB8  781801     MOV W1, [W0++]
404:                  *ptos++  = 0x5555;                                                   /* Initialize register W5                                   */
002CBA  255551     MOV #0x5555, W1
002CBC  781801     MOV W1, [W0++]
405:                  *ptos++  = 0x6666;                                                   /* Initialize register W6                                   */
002CBE  266661     MOV #0x6666, W1
002CC0  781801     MOV W1, [W0++]
406:                  *ptos++  = 0x7777;                                                   /* Initialize register W7                                   */
002CC2  277771     MOV #0x7777, W1
002CC4  781801     MOV W1, [W0++]
407:                  *ptos++  = 0x8888;                                                   /* Initialize register W8                                   */
002CC6  288881     MOV #0x8888, W1
002CC8  781801     MOV W1, [W0++]
408:                  *ptos++  = 0x9999;                                                   /* Initialize register W9                                   */
002CCA  299991     MOV #0x9999, W1
002CCC  781801     MOV W1, [W0++]
409:                  *ptos++  = 0xAAAA;                                                   /* Initialize register W10                                  */
002CCE  2AAAA1     MOV #0xAAAA, W1
002CD0  781801     MOV W1, [W0++]
410:                  *ptos++  = 0xBBBB;                                                   /* Initialize register W11                                  */
002CD2  2BBBB1     MOV #0xBBBB, W1
002CD4  781801     MOV W1, [W0++]
411:                  *ptos++  = 0xCCCC;                                                   /* Initialize register W12                                  */
002CD6  2CCCC1     MOV #0xCCCC, W1
002CD8  781801     MOV W1, [W0++]
412:                  *ptos++  = 0xDDDD;                                                   /* Initialize register W13                                  */
002CDA  2DDDD1     MOV #0xDDDD, W1
002CDC  781801     MOV W1, [W0++]
413:                  *ptos++  = 0xEEEE;                                                   /* Initialize register W14                                  */
002CDE  2EEEE1     MOV #0xEEEE, W1
002CE0  781801     MOV W1, [W0++]
414:               
415:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
416:                  *ptos++  = ACCAL;                                                    /* Push Accumulator A onto the stack                        */
417:                  *ptos++  = ACCAH;                                                    /* Push Accumulator A onto the stack                        */
418:                  *ptos++  = ACCAU;                                                    /* Push Accumulator A onto the stack                        */
419:                  *ptos++  = ACCBL;                                                    /* Push Accumulator B onto the stack                        */
420:                  *ptos++  = ACCBH;                                                    /* Push Accumulator B onto the stack                        */
421:                  *ptos++  = ACCBU;                                                    /* Push Accumulator B onto the stack                        */
422:               #endif
423:                  *ptos++  = TBLPAG;                                                   /* Push the Data Table Page Address onto the stack          */
002CE2  200321     MOV #0x32, W1
002CE4  784091     MOV.B [W1], W1
002CE6  FB8081     ZE W1, W1
002CE8  781801     MOV W1, [W0++]
424:               #if defined(__dsPIC33E__)
425:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
426:                  *ptos++  = DSWPAG;
427:               #elif defined (__dsPIC33F__) || defined(__PIC24F__)
428:                  *ptos++  = PSVPAG;
429:               #endif
430:                  *ptos++  = RCOUNT;                                                   /* Push the Repeat Loop Counter Register onto the stack     */
002CEA  8001B1     MOV RCOUNT, W1
002CEC  781801     MOV W1, [W0++]
431:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
432:                  *ptos++  = DCOUNT;                                                   /* Push the Do Loop     Counter Register onto the stack     */
433:                  *ptos++  = DOSTARTL;                                                 /* Push the Do Loop Start Address Register onto the stack   */
434:                  *ptos++  = DOSTARTH;                                                 /* Push the Do Loop Start Address Register onto the stack   */
435:                  *ptos++  = DOENDL;                                                   /* Push the Do Loop End   Address Register onto the stack   */
436:                  *ptos++  = DOENDH;                                                   /* Push the Do Loop End   Address Register onto the stack   */
437:               #endif
438:                  *ptos++  = 0;                                                        /* Force the SR to enable all interrupt, clear flags        */
002CEE  EB1800     CLR [W0++]
439:                  *ptos++  = CORCON;                                                   /* Push the Core Control Register on to the stack           */
002CF0  800221     MOV CORCON, W1
002CF2  781801     MOV W1, [W0++]
440:               
441:                   return (ptos);                                                      /* Return the stack pointer to the new tasks stack          */
442:               }
002CF4  060000     RETURN
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uCOS-II/Ports/os_cpu_a.s  ------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                                (c) Copyright 2006, Micrium, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                          dsPIC33/PIC24 MPLab Port
                                                  11:    ;                                                 
                                                  12:    ;
                                                  13:    ; File         : os_cpu_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ; Port Version : V2.81 (and higher)
                                                  16:    ;********************************************************************************************************
                                                  17:    ;
                                                  18:    
                                                  19:    ;
                                                  20:    ;********************************************************************************************************
                                                  21:    ;                                                CONSTANTS
                                                  22:    ;********************************************************************************************************
                                                  23:    ;
                                                  24:     
                                                  25:    ;
                                                  26:    ;********************************************************************************************************
                                                  27:    ;                                                INCLUDES
                                                  28:    ;********************************************************************************************************
                                                  29:    ;
                                                  30:    
                                                  31:    .include "xc.inc"
                                                  32:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  33:    
                                                  34:    ;
                                                  35:    ;********************************************************************************************************
                                                  36:    ;                                             LINKER SPECIFICS
                                                  37:    ;********************************************************************************************************
                                                  38:    ;
                                                  39:    
                                                  40:        .text                                         ; Locate this file in the text region of the build
                                                  41:    
                                                  42:    ;
                                                  43:    ;********************************************************************************************************
                                                  44:    ;                                                 GLOBALS
                                                  45:    ;********************************************************************************************************
                                                  46:    ;
                                                  47:    
                                                  48:        .global  _OSStartHighRdy
                                                  49:        .global  _OSCtxSw
                                                  50:        .global  _OSIntCtxSw
                                                  51:    
                                                  52:    ;
                                                  53:    ;********************************************************************************************************
                                                  54:    ;                                            OSStartHighRdy
                                                  55:    ;
                                                  56:    ; Description : This function determines the highest priority task that is ready to run after
                                                  57:    ;               OSInit() is called.
                                                  58:    ;********************************************************************************************************
                                                  59:    ;
                                                  60:    
                                                  61:    _OSStartHighRdy:
002BDC  022C92     CALL 0x2C92                    62:        call   _OSTaskSwHook                          ; Call user defined task switch hook
                                                  63:    
002BE0  200010     MOV #0x1, W0                   64:        mov    #0x0001, w0                            ; Set OSRunning to TRUE
002BE2  209661     MOV #0x966, W1                 65:        mov    #_OSRunning, w1
002BE4  784880     MOV.B W0, [W1]                 66:        mov.b  w0, [w1]                               ; Set OSRunning to TRUE
                                                  67:    
                                                  68:                                                      ; Get stack pointer of the task to resume
002BE6  805380     MOV 0xA70, W0                  69:        mov    _OSTCBHighRdy, w0                      ; Get the pointer to the stack to resume
002BE8  780790     MOV [W0], W15                  70:        mov    [w0], w15                              ; Dereference the pointer and store the data (the new stack address) W15, the stack pointer register
                                                  71:    
002BEA  F90044     POP CORCON                     72:        OS_REGS_RESTORE                               ; Restore all of this tasks registers from the stack
                                                  73:        
002C02  064000     RETFIE                         74:        retfie                                        ; Return from the interrupt, the task is now ready to run
                                                  75:    
                                                  76:    ;
                                                  77:    ;********************************************************************************************************
                                                  78:    ;                                            OSCtxSw
                                                  79:    ;
                                                  80:    ; Description : TThe code to perform a 'task level' context switch.  OSCtxSw() is called 
                                                  81:    ;               when a higher priority task is made ready to run by another task or, 
                                                  82:    ;               when the current task can no longer execute (e.g. it calls OSTimeDly(), 
                                                  83:    ;               OSSemPend() and the semaphore is not available, etc.). 
                                                  84:    ;********************************************************************************************************
                                                  85:    ;
                                                  86:        
                                                  87:    _OSCtxSw:
                                                  88:                                                      ; TRAP (interrupt) should bring us here, not 'call'.
                                                  89:                                                      ; Since dsPIC has no TRAP, it is necessary to correct the stack to simulate an interrupt
                                                  90:                                                      ; In other words, this function must also save SR and IPL3 to the stack, not just the PC.
                                                  91:    
002C04  BFC042     MOV.B SR, WREG                 92:        mov.b  SRL, wreg                              ; Load SRL
002C06  DD0048     SL W0, #8, W0                  93:        sl w0, #8, w0                                 ; Shift left by 8
002C08  AF6044     BTSC CORCON, #3                94:        btsc   CORCON, #IPL3                          ; Test IPL3 bit, skip if clear
002C0A  A07000     BSET W0, #7                    95:        bset   w0, #7;                                ; Copy IPL3 to bit7 of w0
                                                  96:        
002C0C  70004F     IOR W0, [--W15], W0            97:        ior    w0, [--w15], w0                        ; Merge bits
002C0E  781F80     MOV W0, [W15++]                98:        mov    w0, [w15++]                            ; Write back
                                                  99:    
002C10  BE9F80     MOV.D W0, [W15++]              100:       OS_REGS_SAVE                                  ; Save processor registers
                                                  101:   
                                                  102:                                                     ; Save current task's stack pointer into the currect tasks TCB
002C28  805360     MOV 0xA6C, W0                  103:       mov    _OSTCBCur, w0                          ; Get the address of the location in this tasks TCB to store the stack pointer
002C2A  78080F     MOV W15, [W0]                  104:       mov    w15, [w0]                              ; Store the stack pointer in this tasks TCB        
                                                  105:   
002C2C  022C92     CALL 0x2C92                    106:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  107:   
002C30  805381     MOV 0xA70, W1                  108:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
002C32  885361     MOV W1, 0xA6C                  109:       mov    w1, _OSTCBCur
002C34  209630     MOV #0x963, W0                 110:       mov    #_OSPrioHighRdy, w0
002C36  209622     MOV #0x962, W2                 111:       mov    #_OSPrioCur, w2
002C38  784910     MOV.B [W0], [W2]               112:       mov.b  [w0], [w2]
                                                  113:           
002C3A  780791     MOV [W1], W15                  114:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  115:   
002C3C  F90044     POP CORCON                     116:       OS_REGS_RESTORE                               ; Restore registers
                                                  117:       
002C54  064000     RETFIE                         118:       retfie                                        ; Return from interrupt
                                                  119:   
                                                  120:   ;
                                                  121:   ;********************************************************************************************************
                                                  122:   ;                                            OSIntCtxSw
                                                  123:   ;
                                                  124:   ; Description : When an ISR (Interrupt Service Routine) completes, OSIntExit() is called to 
                                                  125:   ;               determine whether a more important task than the interrupted task needs to 
                                                  126:   ;               execute.  If that's the case, OSIntExit() determines which task to run next 
                                                  127:   ;               and calls OSIntCtxSw() to perform the actual context switch to that task.  
                                                  128:   ;********************************************************************************************************
                                                  129:   ;
                                                  130:   
                                                  131:   _OSIntCtxSw:
002C56  022C92     CALL 0x2C92                    132:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  133:   
002C5A  805381     MOV 0xA70, W1                  134:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
002C5C  885361     MOV W1, 0xA6C                  135:       mov    w1, _OSTCBCur
002C5E  209630     MOV #0x963, W0                 136:       mov    #_OSPrioHighRdy, w0
002C60  209622     MOV #0x962, W2                 137:       mov    #_OSPrioCur, w2
002C62  784910     MOV.B [W0], [W2]               138:       mov.b  [w0], [w2]
                                                  139:           
002C64  780791     MOV [W1], W15                  140:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  141:   
002C66  F90044     POP CORCON                     142:       OS_REGS_RESTORE                               ; Restore registers
                                                  143:       
002C7E  064000     RETFIE                         144:       retfie                                        ; Return from interrupt
                                                  145:   
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/uC-CPU/cpu_core.c  -------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/CPU
4:                 *                                    CPU CONFIGURATION & PORT LAYER
5:                 *
6:                 *                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
7:                 *
8:                 *               All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *               uC/CPU is provided in source form to registered licensees ONLY.  It is
11:                *               illegal to distribute this source code to any third party unless you receive
12:                *               written permission by an authorized Micrium representative.  Knowledge of
13:                *               the source code may NOT be used to develop a similar product.
14:                *
15:                *               Please help us continue to provide the Embedded community with the finest
16:                *               software available.  Your honesty is greatly appreciated.
17:                *
18:                *               You can find our product's user manual, API reference, release notes and
19:                *               more information at https://doc.micrium.com.
20:                *               You can contact us at www.micrium.com.
21:                *********************************************************************************************************
22:                */
23:                
24:                /*
25:                *********************************************************************************************************
26:                *
27:                *                                           CORE CPU MODULE
28:                *
29:                * Filename      : cpu_core.c
30:                * Version       : V1.30.01
31:                * Programmer(s) : SR
32:                *                 ITJ
33:                *********************************************************************************************************
34:                */
35:                
36:                
37:                /*
38:                *********************************************************************************************************
39:                *                                            INCLUDE FILES
40:                *********************************************************************************************************
41:                */
42:                
43:                #define    MICRIUM_SOURCE
44:                #define    CPU_CORE_MODULE
45:                #include  "cpu_core.h"
46:                
47:                #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
48:                #include  "cpu_cache.h"
49:                #endif
50:                
51:                
52:                /*
53:                *********************************************************************************************************
54:                *                                            LOCAL DEFINES
55:                *********************************************************************************************************
56:                */
57:                
58:                
59:                /*
60:                *********************************************************************************************************
61:                *                                           LOCAL CONSTANTS
62:                *********************************************************************************************************
63:                */
64:                
65:                
66:                /*
67:                *********************************************************************************************************
68:                *                                          LOCAL DATA TYPES
69:                *********************************************************************************************************
70:                */
71:                
72:                
73:                /*
74:                *********************************************************************************************************
75:                *                                            LOCAL TABLES
76:                *********************************************************************************************************
77:                */
78:                
79:                /*
80:                *********************************************************************************************************
81:                *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
82:                *
83:                * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
84:                *
85:                *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
86:                *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
87:                *                          1    x    x    x    x    x    x    x            0
88:                *                          0    1    x    x    x    x    x    x            1
89:                *                          0    0    1    x    x    x    x    x            2
90:                *                          0    0    0    1    x    x    x    x            3
91:                *                          0    0    0    0    1    x    x    x            4
92:                *                          0    0    0    0    0    1    x    x            5
93:                *                          0    0    0    0    0    0    1    x            6
94:                *                          0    0    0    0    0    0    0    1            7
95:                *                          0    0    0    0    0    0    0    0            8
96:                *********************************************************************************************************
97:                */
98:                
99:                #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
100:                     (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))
101:               static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
102:               /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
103:                   8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
104:                   3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
105:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
106:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
107:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
108:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
109:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
110:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
111:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
112:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
113:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
114:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
115:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
116:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
117:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
118:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
119:               };
120:               #endif
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                       LOCAL GLOBAL VARIABLES
126:               *********************************************************************************************************
127:               */
128:               
129:               CPU_INT32U  const  CPU_EndiannessTest = 0x12345678LU;               /* Variable to test CPU endianness.                 */
130:               
131:               
132:               /*
133:               *********************************************************************************************************
134:               *                                      LOCAL FUNCTION PROTOTYPES
135:               *********************************************************************************************************
136:               */
137:               
138:               #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
139:               static  void        CPU_NameInit         (void);
140:               #endif
141:               
142:               
143:                                                                                   /* ----------------- CPU TS FNCTS ----------------- */
144:               #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
145:                      (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
146:               static  void        CPU_TS_Init          (void);
147:               #endif
148:               
149:               
150:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
151:               static  void        CPU_IntDisMeasInit   (void);
152:               
153:               static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
154:               #endif
155:               
156:               
157:               /*
158:               *********************************************************************************************************
159:               *                                     LOCAL CONFIGURATION ERRORS
160:               *********************************************************************************************************
161:               */
162:               
163:               
164:               /*
165:               *********************************************************************************************************
166:               *                                             CPU_Init()
167:               *
168:               * Description : (1) Initialize CPU module :
169:               *
170:               *                   (a) Initialize CPU timestamps
171:               *                   (b) Initialize CPU interrupts disabled time measurements
172:               *                   (c) Initialize CPU host name
173:               *
174:               *
175:               * Argument(s) : none.
176:               *
177:               * Return(s)   : none.
178:               *
179:               * Caller(s)   : Your Product's Application.
180:               *
181:               *               This function is a CPU initialization function & MAY be called by application/
182:               *               initialization function(s).
183:               *
184:               * Note(s)     : (2) CPU_Init() MUST be called ... :
185:               *
186:               *                   (a) ONLY ONCE from a product's application; ...
187:               *                   (b) BEFORE product's application calls any core CPU module function(s)
188:               *
189:               *               (3) The following initialization functions MUST be sequenced as follows :
190:               *
191:               *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
192:               *
193:               *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
194:               *                                                   & other CPU interrupts disabled time measurement functions
195:               *********************************************************************************************************
196:               */
197:               
198:               void  CPU_Init (void)
199:               {
200:                                                                               /* --------------------- INIT TS ---------------------- */
201:               #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
202:                    (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
203:                   CPU_TS_Init();                                              /* See Note #3a.                                        */
204:               #endif
205:                                                                               /* -------------- INIT INT DIS TIME MEAS -------------- */
206:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
207:                   CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
208:               #endif
209:               
210:                                                                               /* ------------------ INIT CPU NAME ------------------- */
211:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
212:                    CPU_NameInit();
213:               #endif
214:               
215:               #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
216:                    CPU_Cache_Init();
217:               #endif
218:               }
002562  060000     RETURN
219:               
220:               
221:               /*
222:               *********************************************************************************************************
223:               *                                         CPU_SW_Exception()
224:               *
225:               * Description : Trap unrecoverable software exception.
226:               *
227:               * Argument(s) : none.
228:               *
229:               * Return(s)   : none.
230:               *
231:               * Caller(s)   : various.
232:               *
233:               * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
234:               *                   -processed/-threaded or single-threaded -- when the current code execution cannot 
235:               *                   gracefully recover or report a fault or exception condition.
236:               *
237:               *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
238:               *********************************************************************************************************
239:               */
240:               
241:               void  CPU_SW_Exception (void)
242:               {
002564  37FFFF     BRA CPU_SW_Exception
243:                   while (DEF_ON) {
244:                       ;
245:                   }
246:               }
247:               
248:               
249:               /*
250:               *********************************************************************************************************
251:               *                                            CPU_NameClr()
252:               *
253:               * Description : Clear CPU Name.
254:               *
255:               * Argument(s) : none.
256:               *
257:               * Return(s)   : none.
258:               *
259:               * Caller(s)   : CPU_NameInit(),
260:               *               Application.
261:               *
262:               *               This function is a CPU module application programming interface (API) function & MAY be 
263:               *               called by application function(s).
264:               *
265:               * Note(s)     : none.
266:               *********************************************************************************************************
267:               */
268:               
269:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
270:               void  CPU_NameClr (void)
271:               {
272:                   CPU_SR_ALLOC();
273:               
274:               
275:                   CPU_CRITICAL_ENTER();
276:                   Mem_Clr((void     *)&CPU_Name[0],
277:                           (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
278:                   CPU_CRITICAL_EXIT();
279:               }
280:               #endif
281:               
282:               
283:               /*
284:               *********************************************************************************************************
285:               *                                            CPU_NameGet()
286:               *
287:               * Description : Get CPU host name.
288:               *
289:               * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
290:               *                               name ASCII string from this function (see Note #1).
291:               *
292:               *               p_err       Pointer to variable that will receive the return error code from this function :
293:               *
294:               *                               CPU_ERR_NONE                    CPU host name successfully returned.
295:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
296:               *
297:               * Return(s)   : none.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               *               This function is a CPU module application programming interface (API) function & MAY 
302:               *               be called by application function(s).
303:               *
304:               * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
305:               *                   ASCII string :
306:               *
307:               *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
308:               *                           size including the terminating NULL character;
309:               *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
310:               *********************************************************************************************************
311:               */
312:               
313:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
314:               void  CPU_NameGet (CPU_CHAR  *p_name,
315:                                  CPU_ERR   *p_err)
316:               {
317:                   CPU_SR_ALLOC();
318:               
319:               
320:                   if (p_err == (CPU_ERR *)0) {
321:                       CPU_SW_EXCEPTION(;);
322:                   }
323:               
324:                   if (p_name == (CPU_CHAR *)0) {
325:                      *p_err = CPU_ERR_NULL_PTR;
326:                       return;
327:                   }
328:               
329:                   CPU_CRITICAL_ENTER();
330:                  (void)Str_Copy_N(p_name,
331:                                  &CPU_Name[0],
332:                                   CPU_CFG_NAME_SIZE);
333:                   CPU_CRITICAL_EXIT();
334:               
335:                  *p_err = CPU_ERR_NONE;
336:               }
337:               #endif
338:               
339:               
340:               /*
341:               *********************************************************************************************************
342:               *                                            CPU_NameSet()
343:               *
344:               * Description : Set CPU host name.
345:               *
346:               * Argument(s) : p_name      Pointer to CPU host name to set.
347:               *
348:               *               p_err       Pointer to variable that will receive the return error code from this function :
349:               *
350:               *                               CPU_ERR_NONE                    CPU host name successfully set.
351:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
352:               *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
353:               *
354:               * Return(s)   : none.
355:               *
356:               * Caller(s)   : Application.
357:               *
358:               *               This function is a CPU module application programming interface (API) function & MAY be 
359:               *               called by application function(s).
360:               *
361:               * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
362:               *                    than or equal to CPU_CFG_NAME_SIZE.
363:               *********************************************************************************************************
364:               */
365:               
366:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
367:               void  CPU_NameSet (const  CPU_CHAR  *p_name,
368:                                         CPU_ERR   *p_err)
369:               {
370:                   CPU_SIZE_T  len;
371:                   CPU_SR_ALLOC();
372:               
373:               
374:                   if (p_err == (CPU_ERR *)0) {
375:                       CPU_SW_EXCEPTION(;);
376:                   }
377:               
378:                   if (p_name == (const CPU_CHAR *)0) {
379:                      *p_err = CPU_ERR_NULL_PTR;
380:                       return;
381:                   }
382:               
383:                   len = Str_Len_N(p_name,
384:                                   CPU_CFG_NAME_SIZE);
385:                   if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
386:                       CPU_CRITICAL_ENTER();
387:                      (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
388:                                        p_name,
389:                                        CPU_CFG_NAME_SIZE);
390:                       CPU_CRITICAL_EXIT();
391:                      *p_err = CPU_ERR_NONE;
392:               
393:                   } else {
394:                      *p_err = CPU_ERR_NAME_SIZE;
395:                   }
396:               }
397:               #endif
398:               
399:               
400:               /*
401:               *********************************************************************************************************
402:               *                                           CPU_TS_Get32()
403:               *
404:               * Description : Get current 32-bit CPU timestamp.
405:               *
406:               * Argument(s) : none.
407:               *
408:               * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
409:               *
410:               * Caller(s)   : Application.
411:               *
412:               *               This function is a CPU module application programming interface (API) function & MAY 
413:               *               be called by application function(s).
414:               *
415:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
416:               *                   either of the following equations :
417:               *
418:               *                       (a) Time measured  =  Number timer counts  *  Timer period
419:               *
420:               *                               where
421:               *
422:               *                                   Number timer counts     Number of timer counts measured
423:               *                                   Timer period            Timer's period in some units of
424:               *                                                               (fractional) seconds
425:               *                                   Time measured           Amount of time measured, in same
426:               *                                                               units of (fractional) seconds
427:               *                                                               as the Timer period
428:               *
429:               *                                              Number timer counts
430:               *                       (b) Time measured  =  ---------------------
431:               *                                                Timer frequency
432:               *
433:               *                               where
434:               *
435:               *                                   Number timer counts     Number of timer counts measured
436:               *                                   Timer frequency         Timer's frequency in some units
437:               *                                                               of counts per second
438:               *                                   Time measured           Amount of time measured, in seconds
439:               *
440:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
441:               *
442:               *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
443:               *                   its precision is extended via periodic updates by accumulating the deltas of the
444:               *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
445:               *
446:               *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
447:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
448:               *                   with critical sections.
449:               *********************************************************************************************************
450:               */
451:               
452:               #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
453:               CPU_TS32  CPU_TS_Get32 (void)
454:               {
455:                   CPU_TS32    ts;
456:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
457:                   CPU_TS_TMR  tmr_cur;
458:                   CPU_TS_TMR  tmr_delta;
459:                   CPU_SR_ALLOC();
460:               #endif
461:               
462:               
463:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
464:                   ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
465:               
466:               #else
467:                   CPU_INT_DIS();
468:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
469:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
470:                   CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
471:                   CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
472:                   ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
473:                   CPU_INT_EN();
474:               #endif
475:               
476:                   return (ts);
477:               }
478:               #endif
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           CPU_TS_Get64()
484:               *
485:               * Description : Get current 64-bit CPU timestamp.
486:               *
487:               * Argument(s) : none.
488:               *
489:               * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
490:               *
491:               * Caller(s)   : Application.
492:               *
493:               *               This function is a CPU module application programming interface (API) function & MAY 
494:               *               be called by application function(s).
495:               *
496:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
497:               *                   either of the following equations :
498:               *
499:               *                       (a) Time measured  =  Number timer counts  *  Timer period
500:               *
501:               *                               where
502:               *
503:               *                                   Number timer counts     Number of timer counts measured
504:               *                                   Timer period            Timer's period in some units of
505:               *                                                               (fractional) seconds
506:               *                                   Time measured           Amount of time measured, in same
507:               *                                                               units of (fractional) seconds
508:               *                                                               as the Timer period
509:               *
510:               *                                              Number timer counts
511:               *                       (b) Time measured  =  ---------------------
512:               *                                                Timer frequency
513:               *
514:               *                               where
515:               *
516:               *                                   Number timer counts     Number of timer counts measured
517:               *                                   Timer frequency         Timer's frequency in some units
518:               *                                                               of counts per second
519:               *                                   Time measured           Amount of time measured, in seconds
520:               *
521:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
522:               *
523:               *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
524:               *                   its precision is extended via periodic updates by accumulating the deltas of the
525:               *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
526:               *
527:               *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
528:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
529:               *                   with critical sections.
530:               *********************************************************************************************************
531:               */
532:               
533:               #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
534:               CPU_TS64  CPU_TS_Get64 (void)
535:               {
536:                   CPU_TS64    ts;
537:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
538:                   CPU_TS_TMR  tmr_cur;
539:                   CPU_TS_TMR  tmr_delta;
540:                   CPU_SR_ALLOC();
541:               #endif
542:               
543:               
544:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
545:                   ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
546:               
547:               #else
548:                   CPU_INT_DIS();
549:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
550:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
551:                   CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
552:                   CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
553:                   ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
554:                   CPU_INT_EN();
555:               #endif
556:               
557:                   return (ts);
558:               }
559:               #endif
560:               
561:               
562:               /*
563:               *********************************************************************************************************
564:               *                                           CPU_TS_Update()
565:               *
566:               * Description : Update current CPU timestamp(s).
567:               *
568:               * Argument(s) : none.
569:               *
570:               * Return(s)   : none.
571:               *
572:               * Caller(s)   : Application/BSP periodic time handler (see Note #1).
573:               *
574:               *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
575:               *               application/BSP function(s).
576:               *
577:               * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
578:               *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
579:               *
580:               *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
581:               *                       overflows; otherwise, CPU timestamp(s) will lose time.
582:               *
583:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
584:               *********************************************************************************************************
585:               */
586:               
587:               #if (CPU_CFG_TS_EN == DEF_ENABLED)
588:               void  CPU_TS_Update (void)
589:               {
590:               #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
591:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
592:                  (void)CPU_TS_Get32();
593:               #endif
594:               
595:               #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
596:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
597:                  (void)CPU_TS_Get64();
598:               #endif
599:               }
600:               #endif
601:               
602:               
603:               /*
604:               *********************************************************************************************************
605:               *                                         CPU_TS_TmrFreqGet()
606:               *
607:               * Description : Get CPU timestamp's timer frequency.
608:               *
609:               * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
610:               *
611:               *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
612:               *                                                                   returned.
613:               *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
614:               *                                                                   NOT yet configured.
615:               *
616:               * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
617:               *
618:               *               0,                                          otherwise.
619:               *
620:               * Caller(s)   : Application.
621:               *
622:               *               This function is a CPU module application programming interface (API) function & MAY be 
623:               *               called by application function(s).
624:               *
625:               * Note(s)     : none.
626:               *********************************************************************************************************
627:               */
628:               
629:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
630:               CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
631:               {
632:                   CPU_TS_TMR_FREQ  freq_hz;
633:               
634:               
635:                   if (p_err == (CPU_ERR *)0) {
636:                       CPU_SW_EXCEPTION(;);
637:                   }
638:               
639:                   freq_hz =  CPU_TS_TmrFreq_Hz;
640:                  *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
641:               
642:                   return (freq_hz);
643:               }
644:               #endif
645:               
646:               
647:               /*
648:               *********************************************************************************************************
649:               *                                         CPU_TS_TmrFreqSet()
650:               *
651:               * Description : Set CPU timestamp's timer frequency.
652:               *
653:               * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
654:               *
655:               * Return(s)   : none.
656:               *
657:               * Caller(s)   : CPU_TS_TmrInit(),
658:               *               Application/BSP initialization function(s).
659:               *
660:               *               This function is a CPU module BSP function & SHOULD be called only by appropriate
661:               *               application/BSP function(s) [see Note #1].
662:               *
663:               * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
664:               *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
665:               *                           application/BSP initialization functions.
666:               *
667:               *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
668:               *                           to convert CPU timestamps from timer counts into microseconds.
669:               *
670:               *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
671:               *
672:               *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
673:               *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
674:               *                       measure desired times.
675:               *
676:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
677:               *********************************************************************************************************
678:               */
679:               
680:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
681:               void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
682:               {
683:                   CPU_TS_TmrFreq_Hz = freq_hz;
684:               }
685:               #endif
686:               
687:               
688:               /*
689:               *********************************************************************************************************
690:               *                                     CPU_IntDisMeasMaxCurReset()
691:               *
692:               * Description : Reset current maximum interrupts disabled time.
693:               *
694:               * Argument(s) : none.
695:               *
696:               * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
697:               *
698:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
699:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
700:               *
701:               * Caller(s)   : Application.
702:               *
703:               *               This function is a CPU module application programming interface (API) function 
704:               *               & MAY be called by application function(s).
705:               *
706:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
707:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
708:               *********************************************************************************************************
709:               */
710:               
711:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
712:               CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
713:               {
714:                   CPU_TS_TMR  time_max_cnts;
715:                   CPU_SR_ALLOC();
716:               
717:               
718:                   time_max_cnts             = CPU_IntDisMeasMaxCurGet();
719:                   CPU_INT_DIS();
720:                   CPU_IntDisMeasMaxCur_cnts = 0u;
721:                   CPU_INT_EN();
722:               
723:                   return (time_max_cnts);
724:               }
725:               #endif
726:               
727:               
728:               /*
729:               *********************************************************************************************************
730:               *                                      CPU_IntDisMeasMaxCurGet()
731:               *
732:               * Description : Get current maximum interrupts disabled time.
733:               *
734:               * Argument(s) : none.
735:               *
736:               * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
737:               *
738:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
739:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
740:               *
741:               * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
742:               *               Application.
743:               *
744:               *               This function is a CPU module application programming interface (API) function 
745:               *               & MAY be called by application function(s).
746:               *
747:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
748:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
749:               *********************************************************************************************************
750:               */
751:               
752:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
753:               CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
754:               {
755:                   CPU_TS_TMR  time_tot_cnts;
756:                   CPU_TS_TMR  time_max_cnts;
757:                   CPU_SR_ALLOC();
758:               
759:               
760:                   CPU_INT_DIS();
761:                   time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
762:                   CPU_INT_EN();
763:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
764:               
765:                   return (time_max_cnts);
766:               }
767:               #endif
768:               
769:               
770:               /*
771:               *********************************************************************************************************
772:               *                                       CPU_IntDisMeasMaxGet()
773:               *
774:               * Description : Get (non-resetable) maximum interrupts disabled time.
775:               *
776:               * Argument(s) : none.
777:               *
778:               * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
779:               *
780:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
781:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
782:               *
783:               * Caller(s)   : CPU_IntDisMeasInit(),
784:               *               Application.
785:               *
786:               *               This function is a CPU module application programming interface (API) function 
787:               *               & MAY be called by application function(s).
788:               *
789:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
790:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
791:               *********************************************************************************************************
792:               */
793:               
794:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
795:               CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
796:               {
797:                   CPU_TS_TMR  time_tot_cnts;
798:                   CPU_TS_TMR  time_max_cnts;
799:                   CPU_SR_ALLOC();
800:               
801:               
802:                   CPU_INT_DIS();
803:                   time_tot_cnts = CPU_IntDisMeasMax_cnts;
804:                   CPU_INT_EN();
805:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
806:               
807:                   return (time_max_cnts);
808:               }
809:               #endif
810:               
811:               
812:               /*
813:               *********************************************************************************************************
814:               *                                        CPU_IntDisMeasStart()
815:               *
816:               * Description : Start interrupts disabled time measurement.
817:               *
818:               * Argument(s) : none.
819:               *
820:               * Return(s)   : none.
821:               *
822:               * Caller(s)   : CPU_CRITICAL_ENTER().
823:               *
824:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
825:               *               function(s).
826:               *
827:               * Note(s)     : none.
828:               *********************************************************************************************************
829:               */
830:               
831:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
832:               void  CPU_IntDisMeasStart (void)
833:               {
834:                   CPU_IntDisMeasCtr++;
835:                   if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
836:                       CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
837:                   }
838:                   CPU_IntDisNestCtr++;
839:               }
840:               #endif
841:               
842:               
843:               /*
844:               *********************************************************************************************************
845:               *                                        CPU_IntDisMeasStop()
846:               *
847:               * Description : Stop interrupts disabled time measurement.
848:               *
849:               * Argument(s) : none.
850:               *
851:               * Return(s)   : none.
852:               *
853:               * Caller(s)   : CPU_CRITICAL_EXIT().
854:               *
855:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
856:               *               function(s).
857:               *
858:               * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
859:               *                       during critical sections is calculated by the following equations :
860:               *
861:               *                       (1) When interrupts disabled time measurements are disabled :
862:               *
863:               *
864:               *                               |   CRITICAL  |                           |   CRITICAL  |
865:               *                               |<- SECTION ->|                           |<- SECTION ->|
866:               *                               |    ENTER    |                           |    EXIT     |
867:               *
868:               *                            Disable                                    Enable
869:               *                           Interrupts                                Interrupts
870:               *
871:               *                               ||           ||                           ||           ||
872:               *                               ||           ||                           ||           ||
873:               *                               ||       |   ||<------------------------->||       |   ||
874:               *                               ||       |<->||             |             ||<----->|   ||
875:               *                               ||       | | ||             |             ||   |   |   ||
876:               *                                        | |                |                  |   |
877:               *                                   interrupts            time                 interrupts
878:               *                                    disabled                 interrupts       |enabled
879:               *                                          |                   disabled        |
880:               *                                          |              (via application)    |
881:               *                                       time                                 time
882:               *                                           interrupts                           interrupts
883:               *                                         disabled ovrhd                        enabled ovrhd
884:               *
885:               *
886:               *                           (A) time            =  [ time            -  time           ]  -  time
887:               *                                   interrupts     [     interrupts         interrupts ]         total
888:               *                                    disabled      [      enabled            disabled  ]         ovrhd
889:               *                               (via application)
890:               *
891:               *
892:               *                           (B) time       =  time              +  time
893:               *                                   total         interrupts           interrupts
894:               *                                   ovrhd        enabled ovrhd       disabled ovrhd
895:               *
896:               *
897:               *                                   where
898:               *
899:               *                                           time                    time interrupts are disabled between
900:               *                                               interrupts              first critical section enter &
901:               *                                                disabled               last  critical section exit (i.e.
902:               *                                           (via application)           minus total overhead time)
903:               *
904:               *                                           time                    time when interrupts are disabled
905:               *                                               interrupts
906:               *                                                disabled
907:               *
908:               *                                           time                    time when interrupts are  enabled
909:               *                                               interrupts
910:               *                                                enabled
911:               *
912:               *
913:               *                                           time                    total overhead time to disable/enable
914:               *                                               total                   interrupts during critical section
915:               *                                               ovrhd                   enter & exit
916:               *
917:               *                                           time                    total overhead time to disable interrupts
918:               *                                               interrupts              during critical section enter
919:               *                                             disabled ovrhd
920:               *
921:               *                                           time                    total overhead time to enable  interrupts
922:               *                                               interrupts              during critical section exit
923:               *                                              enabled ovrhd
924:               *
925:               *
926:               *                       (2) When interrupts disabled time measurements are enabled :
927:               *
928:               *
929:               *        |                                    |                           |                                       |
930:               *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
931:               *        |                                    |                           |                                       |
932:               *
933:               *                   Time                                                 Time
934:               *     Disable    Measurement                                          Measurement                  Enable
935:               *    Interrupts     Start                                                Stop                    Interrupts
936:               *
937:               *        ||           |                      ||                           ||                         |           ||
938:               *        ||           |                      ||                           ||                         |           ||
939:               *        ||           |        |             ||<------------------------->||               |         |           ||
940:               *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
941:               *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
942:               *                 |            |      |                     |                      |       |                 |
943:               *            interrupts       get     |                   time                     |      get            interrupts
944:               *             disabled    start time  |                       interrupts           |   stop time          enabled
945:               *                            meas     |                        disabled            |     meas
946:               *                                   time                  (via application)      time
947:               *                                       start meas                                   stop meas
948:               *                                         ovrhd                                        ovrhd
949:               *
950:               *
951:               *                           (A) time            =  [ time       -  time      ]  -  time
952:               *                                   interrupts     [      stop         start ]         total meas
953:               *                                    disabled      [      meas         meas  ]           ovrhd
954:               *                               (via application)
955:               *
956:               *
957:               *                           (B) time            =  time            +  time
958:               *                                   total meas         start meas         stop meas
959:               *                                     ovrhd              ovrhd              ovrhd
960:               *
961:               *
962:               *                                   where
963:               *
964:               *                                           time                    time interrupts are disabled between first
965:               *                                               interrupts              critical section enter & last critical
966:               *                                                disabled               section exit (i.e. minus measurement
967:               *                                           (via application)           overhead time; however, this does NOT
968:               *                                                                       include any overhead time to disable
969:               *                                                                       or enable interrupts during critical
970:               *                                                                       section enter & exit)
971:               *
972:               *                                           time                    time of disable interrupts start time
973:               *                                               start                   measurement (in timer counts)
974:               *                                               meas
975:               *
976:               *                                           time                    time of disable interrupts stop  time
977:               *                                               stop                    measurement (in timer counts)
978:               *                                               meas
979:               *
980:               *
981:               *                                           time                    total overhead time to start/stop disabled
982:               *                                               total meas              interrupts time measurements (in timer
983:               *                                                 ovrhd                 counts)
984:               *
985:               *                                           time                    total overhead time after getting start
986:               *                                               start meas              time until end of start measurement
987:               *                                                 ovrhd                 function  (in timer counts)
988:               *
989:               *                                           time                    total overhead time from beginning of stop
990:               *                                               stop meas               measurement function until after getting
991:               *                                                 ovrhd                 stop time (in timer counts)
992:               *
993:               *
994:               *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times 
995:               *                               from stop times, CPU timestamp timer count values MUST be returned via 
996:               *                               word-size-configurable 'CPU_TS_TMR' data type.
997:               *
998:               *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
999:               *
1000:              *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
1001:              *                               values, timestamp timer count values MUST increase with each time count.
1002:              *
1003:              *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
1004:              *
1005:              *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
1006:              *                               subtraction of start times from stop times is performed.
1007:              *
1008:              *                           (B) The final calculations to subtract the interrupts disabled time measurement
1009:              *                               overhead is performed asynchronously in appropriate API functions.
1010:              *
1011:              *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
1012:              *********************************************************************************************************
1013:              */
1014:              
1015:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
1016:              void  CPU_IntDisMeasStop (void)
1017:              {
1018:                  CPU_TS_TMR  time_ints_disd_cnts;
1019:              
1020:              
1021:                  CPU_IntDisNestCtr--;
1022:                  if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
1023:                      CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
1024:                                                                                  /* ... calc ints dis'd tot  time (see Note #1b2A).  */
1025:                      time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
1026:                                                CPU_IntDisMeasStart_cnts;
1027:                                                                                  /* Calc max ints dis'd times.                       */
1028:                      if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
1029:                          CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
1030:                      }
1031:                      if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
1032:                          CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
1033:                      }
1034:                  }
1035:              }
1036:              #endif
1037:              
1038:              
1039:              /*
1040:              *********************************************************************************************************
1041:              *                                         CPU_CntLeadZeros()
1042:              *
1043:              * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
1044:              *
1045:              * Argument(s) : val         Data value to count leading zero bits.
1046:              *
1047:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
1048:              *
1049:              *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
1050:              *
1051:              * Caller(s)   : CPU_CntTrailZeros(),
1052:              *               Application.
1053:              *
1054:              *               This function is a CPU module application programming interface (API) function & MAY 
1055:              *               be called by application function(s).
1056:              *
1057:              * Note(s)     : (1) (a) Supports the following data value sizes :
1058:              *
1059:              *                       (1)  8-bits
1060:              *                       (2) 16-bits
1061:              *                       (3) 32-bits
1062:              *                       (4) 64-bits
1063:              *
1064:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1065:              *
1066:              *                   (b) (1) For  8-bit values :
1067:              *
1068:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1069:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1070:              *                                   1    x    x    x    x    x    x    x            0
1071:              *                                   0    1    x    x    x    x    x    x            1
1072:              *                                   0    0    1    x    x    x    x    x            2
1073:              *                                   0    0    0    1    x    x    x    x            3
1074:              *                                   0    0    0    0    1    x    x    x            4
1075:              *                                   0    0    0    0    0    1    x    x            5
1076:              *                                   0    0    0    0    0    0    1    x            6
1077:              *                                   0    0    0    0    0    0    0    1            7
1078:              *                                   0    0    0    0    0    0    0    0            8
1079:              *
1080:              *
1081:              *                       (2) For 16-bit values :
1082:              *
1083:              *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1084:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1085:              *                              1    x    x         x    x    x    x    x            0
1086:              *                              0    1    x         x    x    x    x    x            1
1087:              *                              0    0    1         x    x    x    x    x            2
1088:              *                              :    :    :         :    :    :    :    :            :
1089:              *                              :    :    :         :    :    :    :    :            :
1090:              *                              0    0    0         1    x    x    x    x           11
1091:              *                              0    0    0         0    1    x    x    x           12
1092:              *                              0    0    0         0    0    1    x    x           13
1093:              *                              0    0    0         0    0    0    1    x           14
1094:              *                              0    0    0         0    0    0    0    1           15
1095:              *                              0    0    0         0    0    0    0    0           16
1096:              *
1097:              *                       (3) For 32-bit values :
1098:              *
1099:              *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1100:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1101:              *                              1    x    x         x    x    x    x    x            0
1102:              *                              0    1    x         x    x    x    x    x            1
1103:              *                              0    0    1         x    x    x    x    x            2
1104:              *                              :    :    :         :    :    :    :    :            :
1105:              *                              :    :    :         :    :    :    :    :            :
1106:              *                              0    0    0         1    x    x    x    x           27
1107:              *                              0    0    0         0    1    x    x    x           28
1108:              *                              0    0    0         0    0    1    x    x           29
1109:              *                              0    0    0         0    0    0    1    x           30
1110:              *                              0    0    0         0    0    0    0    1           31
1111:              *                              0    0    0         0    0    0    0    0           32
1112:              *
1113:              *
1114:              *                       (4) For 64-bit values :
1115:              *
1116:              *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1117:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1118:              *                              1    x    x         x    x    x    x    x            0
1119:              *                              0    1    x         x    x    x    x    x            1
1120:              *                              0    0    1         x    x    x    x    x            2
1121:              *                              :    :    :         :    :    :    :    :            :
1122:              *                              :    :    :         :    :    :    :    :            :
1123:              *                              0    0    0         1    x    x    x    x           59
1124:              *                              0    0    0         0    1    x    x    x           60
1125:              *                              0    0    0         0    0    1    x    x           61
1126:              *                              0    0    0         0    0    0    1    x           62
1127:              *                              0    0    0         0    0    0    0    1           63
1128:              *                              0    0    0         0    0    0    0    0           64
1129:              *
1130:              *
1131:              *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1132:              *********************************************************************************************************
1133:              */
1134:              
1135:              #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
1136:              CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
1137:              {
1138:                  CPU_DATA  nbr_lead_zeros;
1139:              
1140:              
1141:              #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
1142:                  nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
1143:              
1144:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
1145:                  nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
002586  060000     RETURN
1146:              
1147:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
1148:                  nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
1149:              
1150:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
1151:                  nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
1152:              
1153:              #else                                                           /* See Note #1a.                                        */
1154:                  nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
1155:              #endif
1156:              
1157:              
1158:                  return (nbr_lead_zeros);
1159:              }
1160:              #endif
1161:              
1162:              
1163:              /*
1164:              *********************************************************************************************************
1165:              *                                        CPU_CntLeadZeros08()
1166:              *
1167:              * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
1168:              *
1169:              * Argument(s) : val         Data value to count leading zero bits.
1170:              *
1171:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1172:              *
1173:              * Caller(s)   : CPU_CntLeadZeros(),
1174:              *               CPU_CntTrailZeros08(),
1175:              *               Application.
1176:              *
1177:              *               This function is a CPU module application programming interface (API) function & MAY be 
1178:              *               called by application function(s).
1179:              *
1180:              * Note(s)     : (1) Supports  8-bit values :
1181:              *
1182:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1183:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1184:              *                                1    x    x    x    x    x    x    x            0
1185:              *                                0    1    x    x    x    x    x    x            1
1186:              *                                0    0    1    x    x    x    x    x            2
1187:              *                                0    0    0    1    x    x    x    x            3
1188:              *                                0    0    0    0    1    x    x    x            4
1189:              *                                0    0    0    0    0    1    x    x            5
1190:              *                                0    0    0    0    0    0    1    x            6
1191:              *                                0    0    0    0    0    0    0    1            7
1192:              *                                0    0    0    0    0    0    0    0            8
1193:              *
1194:              *
1195:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1196:              *********************************************************************************************************
1197:              */
1198:              
1199:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1200:              CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
1201:              {
1202:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1203:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1204:                  CPU_DATA  ix;
1205:              #endif
1206:                  CPU_DATA  nbr_lead_zeros;
1207:              
1208:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1209:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1210:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1211:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1212:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1213:              
1214:              
1215:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1216:                                                                                              /* Chk bits [07:00] :                   */
1217:                                                                                              /* .. Nbr lead zeros =               .. */
1218:                  ix              = (CPU_DATA)(val);                                          /* .. lookup tbl ix  = 'val' >>  0 bits */
002566  FB8000     ZE W0, W0
1219:                  nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                      /* .. plus nbr msb lead zeros =  0 bits.*/
002568  299AA1     MOV #0x99AA, W1
00256A  784061     MOV.B [W1+W0], W0
00256C  FB8000     ZE W0, W0
1220:              #endif
1221:              
1222:              
1223:                  return (nbr_lead_zeros);
1224:              }
00256E  060000     RETURN
1225:              #endif
1226:              
1227:              
1228:              /*
1229:              *********************************************************************************************************
1230:              *                                        CPU_CntLeadZeros16()
1231:              *
1232:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
1233:              *
1234:              * Argument(s) : val         Data value to count leading zero bits.
1235:              *
1236:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1237:              *
1238:              * Caller(s)   : CPU_CntLeadZeros(),
1239:              *               CPU_CntTrailZeros16(),
1240:              *               Application.
1241:              *
1242:              *               This function is a CPU module application programming interface (API) function & MAY be 
1243:              *               called by application function(s).
1244:              *
1245:              * Note(s)     : (1) Supports 16-bit values :
1246:              *
1247:              *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1248:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1249:              *                           1    x    x         x    x    x    x    x            0
1250:              *                           0    1    x         x    x    x    x    x            1
1251:              *                           0    0    1         x    x    x    x    x            2
1252:              *                           :    :    :         :    :    :    :    :            :
1253:              *                           :    :    :         :    :    :    :    :            :
1254:              *                           0    0    0         1    x    x    x    x           11
1255:              *                           0    0    0         0    1    x    x    x           12
1256:              *                           0    0    0         0    0    1    x    x           13
1257:              *                           0    0    0         0    0    0    1    x           14
1258:              *                           0    0    0         0    0    0    0    1           15
1259:              *                           0    0    0         0    0    0    0    0           16
1260:              *
1261:              *
1262:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1263:              *********************************************************************************************************
1264:              */
1265:              
1266:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1267:              CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
1268:              {
002570  299AA1     MOV #0x99AA, W1
1269:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1270:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1271:                  CPU_DATA  ix;
1272:              #endif
1273:                  CPU_DATA  nbr_lead_zeros;
1274:              
1275:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1276:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1277:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1278:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1279:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1280:              
1281:              
1282:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1283:                  if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
002572  200FF2     MOV #0xFF, W2
002574  500F82     SUB W0, W2, [W15]
002576  360004     BRA LEU, 0x2580
1284:                                                                                              /* .. Nbr lead zeros =               .. */
1285:                      ix             = (CPU_DATA)((CPU_DATA)val >> 8u);                       /* .. lookup tbl ix  = 'val' >>  8 bits */
002578  DE0048     LSR W0, #8, W0
1286:                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                   /* .. plus nbr msb lead zeros =  0 bits.*/
00257A  784061     MOV.B [W1+W0], W0
00257C  FB8000     ZE W0, W0
00257E  060000     RETURN
1287:              
1288:                  } else {                                                                    /* Chk bits [07:00] :                   */
1289:                                                                                              /* .. Nbr lead zeros =               .. */
1290:                      ix             = (CPU_DATA)(val);                                       /* .. lookup tbl ix  = 'val' >>  0 bits */
1291:                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);   /* .. plus nbr msb lead zeros =  8 bits.*/
002580  784061     MOV.B [W1+W0], W0
002582  FB8000     ZE W0, W0
002584  400068     ADD W0, #0x8, W0
1292:                  }
1293:              #endif
1294:              
1295:              
1296:                  return (nbr_lead_zeros);
1297:              }
1298:              #endif
1299:              
1300:              
1301:              /*
1302:              *********************************************************************************************************
1303:              *                                        CPU_CntLeadZeros32()
1304:              *
1305:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
1306:              *
1307:              * Argument(s) : val         Data value to count leading zero bits.
1308:              *
1309:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1310:              *
1311:              * Caller(s)   : CPU_CntLeadZeros(),
1312:              *               CPU_CntTrailZeros32(),
1313:              *               Application.
1314:              *
1315:              *               This function is a CPU module application programming interface (API) function & MAY be 
1316:              *               called by application function(s).
1317:              *
1318:              * Note(s)     : (1) Supports 32-bit values :
1319:              *
1320:              *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1321:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1322:              *                           1    x    x         x    x    x    x    x            0
1323:              *                           0    1    x         x    x    x    x    x            1
1324:              *                           0    0    1         x    x    x    x    x            2
1325:              *                           :    :    :         :    :    :    :    :            :
1326:              *                           :    :    :         :    :    :    :    :            :
1327:              *                           0    0    0         1    x    x    x    x           27
1328:              *                           0    0    0         0    1    x    x    x           28
1329:              *                           0    0    0         0    0    1    x    x           29
1330:              *                           0    0    0         0    0    0    1    x           30
1331:              *                           0    0    0         0    0    0    0    1           31
1332:              *                           0    0    0         0    0    0    0    0           32
1333:              *
1334:              *
1335:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1336:              *********************************************************************************************************
1337:              */
1338:              
1339:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1340:              CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
1341:              {
1342:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1343:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1344:                  CPU_DATA  ix;
1345:              #endif
1346:                  CPU_DATA  nbr_lead_zeros;
1347:              
1348:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1349:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1350:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1351:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1352:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1353:              
1354:              
1355:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1356:                  if (val > 0x0000FFFFu) {
00258A  400FE1     ADD W0, #0x1, [W15]
00258C  588FE0     SUBB W1, #0x0, [W15]
00258E  36000E     BRA LEU, 0x25AC
002590  299AA2     MOV #0x99AA, W2
1357:                      if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
002592  2FFFF4     MOV #0xFFFF, W4
002594  200FF5     MOV #0xFF, W5
002596  500F84     SUB W0, W4, [W15]
002598  588F85     SUBB W1, W5, [W15]
00259A  360004     BRA LEU, 0x25A4
1358:                                                                                              /* .. Nbr lead zeros =               .. */
1359:                          ix             = (CPU_DATA)((CPU_INT32U)val >> 24u);                  /* .. lookup tbl ix  = 'val' >> 24 bits */
00259C  DE0848     LSR W1, #8, W0
1360:                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);               /* .. plus nbr msb lead zeros =  0 bits.*/
00259E  410000     ADD W2, W0, W0
0025A0  FB8010     ZE [W0], W0
0025A2  060000     RETURN
1361:              
1362:                      } else {                                                                /* Chk bits [23:16] :                   */
1363:                                                                                              /* .. Nbr lead zeros =               .. */
1364:                          ix             = (CPU_DATA)((CPU_INT32U)val >> 16u);                  /* .. lookup tbl ix  = 'val' >> 16 bits */
1365:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
0025A4  410101     ADD W2, W1, W2
0025A6  FB8012     ZE [W2], W0
0025A8  400068     ADD W0, #0x8, W0
0025AA  060000     RETURN
0025AC  299AA2     MOV #0x99AA, W2
1366:                      }
1367:              
1368:                  } else {
1369:                      if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
0025AE  200FF3     MOV #0xFF, W3
0025B0  500F83     SUB W0, W3, [W15]
0025B2  588FE0     SUBB W1, #0x0, [W15]
0025B4  360005     BRA LEU, 0x25C0
1370:                                                                                              /* .. Nbr lead zeros =               .. */
1371:                          ix             = (CPU_DATA)((CPU_DATA)val >>  8u);                  /* .. lookup tbl ix  = 'val' >>  8 bits */
0025B6  DE0048     LSR W0, #8, W0
1372:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
0025B8  784062     MOV.B [W2+W0], W0
0025BA  FB8000     ZE W0, W0
0025BC  400070     ADD W0, #0x10, W0
0025BE  060000     RETURN
1373:              
1374:                      } else {                                                                /* Chk bits [07:00] :                   */
1375:                                                                                              /* .. Nbr lead zeros =               .. */
1376:                          ix             = (CPU_DATA)((CPU_DATA)val >>  0u);                  /* .. lookup tbl ix  = 'val' >>  0 bits */
1377:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
0025C0  410000     ADD W2, W0, W0
0025C2  FB8010     ZE [W0], W0
0025C4  400078     ADD W0, #0x18, W0
1378:                      }
1379:                  }
1380:              #endif
1381:              
1382:              
1383:                  return (nbr_lead_zeros);
1384:              }
0025C6  060000     RETURN
1385:              #endif
1386:              
1387:              
1388:              /*
1389:              *********************************************************************************************************
1390:              *                                        CPU_CntLeadZeros64()
1391:              *
1392:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
1393:              *
1394:              * Argument(s) : val         Data value to count leading zero bits.
1395:              *
1396:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1397:              *
1398:              * Caller(s)   : CPU_CntLeadZeros(),
1399:              *               CPU_CntTrailZeros64(),
1400:              *               Application.
1401:              *
1402:              *               This function is a CPU module application programming interface (API) function & MAY be 
1403:              *               called by application function(s).
1404:              *
1405:              * Note(s)     : (1) Supports 64-bit values :
1406:              *
1407:              *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1408:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1409:              *                           1    x    x         x    x    x    x    x            0
1410:              *                           0    1    x         x    x    x    x    x            1
1411:              *                           0    0    1         x    x    x    x    x            2
1412:              *                           :    :    :         :    :    :    :    :            :
1413:              *                           :    :    :         :    :    :    :    :            :
1414:              *                           0    0    0         1    x    x    x    x           59
1415:              *                           0    0    0         0    1    x    x    x           60
1416:              *                           0    0    0         0    0    1    x    x           61
1417:              *                           0    0    0         0    0    0    1    x           62
1418:              *                           0    0    0         0    0    0    0    1           63
1419:              *                           0    0    0         0    0    0    0    0           64
1420:              *
1421:              *
1422:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1423:              *********************************************************************************************************
1424:              */
1425:              
1426:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
1427:              CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
1428:              {
0025C8  BE9F88     MOV.D W8, [W15++]
0025CA  BE9F8A     MOV.D W10, [W15++]
1429:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1430:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
1431:                  CPU_DATA  ix;
1432:              #endif
1433:                  CPU_DATA  nbr_lead_zeros;
1434:              
1435:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1436:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1437:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
1438:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1439:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1440:              
1441:              
1442:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1443:                  if (val > 0x00000000FFFFFFFFu) {
0025CC  2FFFF4     MOV #0xFFFF, W4
0025CE  2FFFF5     MOV #0xFFFF, W5
0025D0  B83360     MUL.UU W6, #0, W6
0025D2  E10004     CP W0, W4
0025D4  E18805     CPB W1, W5
0025D6  E19006     CPB W2, W6
0025D8  E19807     CPB W3, W7
0025DA  360030     BRA LEU, 0x263C
1444:                      if (val > 0x0000FFFFFFFFFFFFu) {
0025DC  2FFFF4     MOV #0xFFFF, W4
0025DE  2FFFF5     MOV #0xFFFF, W5
0025E0  2FFFF6     MOV #0xFFFF, W6
0025E2  200007     MOV #0x0, W7
0025E4  E10004     CP W0, W4
0025E6  E18805     CPB W1, W5
0025E8  E19006     CPB W2, W6
0025EA  E19807     CPB W3, W7
0025EC  360012     BRA LEU, 0x2612
0025EE  299AA4     MOV #0x99AA, W4
1445:                          if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
0025F0  2FFFF8     MOV #0xFFFF, W8
0025F2  2FFFF9     MOV #0xFFFF, W9
0025F4  2FFFFA     MOV #0xFFFF, W10
0025F6  200FFB     MOV #0xFF, W11
0025F8  E10008     CP W0, W8
0025FA  E18809     CPB W1, W9
0025FC  E1900A     CPB W2, W10
0025FE  E1980B     CPB W3, W11
002600  360004     BRA LEU, 0x260A
1446:                                                                                              /* .. Nbr lead zeros =               .. */
1447:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 56u);            /* .. lookup tbl ix  = 'val' >> 56 bits */
002602  DE1848     LSR W3, #8, W0
1448:                              nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);           /* .. plus nbr msb lead zeros =  0 bits.*/
002604  420000     ADD W4, W0, W0
002606  FB8010     ZE [W0], W0
002608  370048     BRA 0x269A
1449:              
1450:                          } else {                                                            /* Chk bits [55:48] :                   */
1451:                                                                                              /* .. Nbr lead zeros =               .. */
1452:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 48u);            /* .. lookup tbl ix  = 'val' >> 48 bits */
1453:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
00260A  420203     ADD W4, W3, W4
00260C  FB8014     ZE [W4], W0
00260E  400068     ADD W0, #0x8, W0
002610  370044     BRA 0x269A
002612  299AA4     MOV #0x99AA, W4
1454:                          }
1455:              
1456:                      } else {
1457:                          if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
002614  2FFFF8     MOV #0xFFFF, W8
002616  2FFFF9     MOV #0xFFFF, W9
002618  200FFA     MOV #0xFF, W10
00261A  20000B     MOV #0x0, W11
00261C  E10008     CP W0, W8
00261E  E18809     CPB W1, W9
002620  E1900A     CPB W2, W10
002622  E1980B     CPB W3, W11
002624  360007     BRA LEU, 0x2634
1458:                                                                                              /* .. Nbr lead zeros =               .. */
1459:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 40u);            /* .. lookup tbl ix  = 'val' >> 40 bits */
002626  DE1048     LSR W2, #8, W0
002628  DD1AC8     SL W3, #8, W5
00262A  728000     IOR W5, W0, W0
1460:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
00262C  420000     ADD W4, W0, W0
00262E  FB8010     ZE [W0], W0
002630  400070     ADD W0, #0x10, W0
002632  370033     BRA 0x269A
1461:              
1462:                          } else {                                                            /* Chk bits [39:32] :                   */
1463:                                                                                              /* .. Nbr lead zeros =               .. */
1464:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 32u);            /* .. lookup tbl ix  = 'val' >> 32 bits */
1465:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
002634  420202     ADD W4, W2, W4
002636  FB8014     ZE [W4], W0
002638  400078     ADD W0, #0x18, W0
00263A  37002F     BRA 0x269A
1466:                          }
1467:                      }
1468:              
1469:                  } else {
1470:                      if (val > 0x000000000000FFFFu) {
00263C  2FFFF4     MOV #0xFFFF, W4
00263E  200005     MOV #0x0, W5
002640  B83360     MUL.UU W6, #0, W6
002642  E10004     CP W0, W4
002644  E18805     CPB W1, W5
002646  E19006     CPB W2, W6
002648  E19807     CPB W3, W7
00264A  360014     BRA LEU, 0x2674
00264C  299AA4     MOV #0x99AA, W4
1471:                          if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
00264E  2FFFF8     MOV #0xFFFF, W8
002650  200FF9     MOV #0xFF, W9
002652  B85560     MUL.UU W10, #0, W10
002654  E10008     CP W0, W8
002656  E18809     CPB W1, W9
002658  E1900A     CPB W2, W10
00265A  E1980B     CPB W3, W11
00265C  360007     BRA LEU, 0x266C
1472:                                                                                              /* .. Nbr lead zeros =               .. */
1473:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 24u);              /* .. lookup tbl ix  = 'val' >> 24 bits */
00265E  DE0848     LSR W1, #8, W0
002660  DD12C8     SL W2, #8, W5
002662  728000     IOR W5, W0, W0
1474:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);/* .. plus nbr msb lead zeros = 32 bits.*/
002664  420000     ADD W4, W0, W0
002666  FB8010     ZE [W0], W0
002668  B00200     ADD #0x20, W0
00266A  370017     BRA 0x269A
1475:              
1476:                          } else {                                                            /* Chk bits [23:16] :                   */
1477:                                                                                              /* .. Nbr lead zeros =               .. */
1478:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 16u);            /* .. lookup tbl ix  = 'val' >> 16 bits */
1479:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);/* .. plus nbr msb lead zeros = 40 bits.*/
00266C  420201     ADD W4, W1, W4
00266E  FB8014     ZE [W4], W0
002670  B00280     ADD #0x28, W0
002672  370013     BRA 0x269A
002674  299AA4     MOV #0x99AA, W4
1480:                          }
1481:              
1482:                      } else {
1483:                          if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
002676  200FF8     MOV #0xFF, W8
002678  200009     MOV #0x0, W9
00267A  B85560     MUL.UU W10, #0, W10
00267C  E10008     CP W0, W8
00267E  E18809     CPB W1, W9
002680  E1900A     CPB W2, W10
002682  E1980B     CPB W3, W11
002684  360007     BRA LEU, 0x2694
1484:                                                                                              /* .. Nbr lead zeros =               .. */
1485:                              ix             = (CPU_DATA)((CPU_INT64U)val >>  8u);            /* .. lookup tbl ix  = 'val' >>  8 bits */
002686  DE0048     LSR W0, #8, W0
002688  DD0AC8     SL W1, #8, W5
00268A  728000     IOR W5, W0, W0
1486:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);/* .. plus nbr msb lead zeros = 48 bits.*/
00268C  420000     ADD W4, W0, W0
00268E  FB8010     ZE [W0], W0
002690  B00300     ADD #0x30, W0
002692  370003     BRA 0x269A
1487:              
1488:                          } else {                                                            /* Chk bits [07:00] :                   */
1489:                                                                                              /* .. Nbr lead zeros =               .. */
1490:                              ix             = (CPU_DATA)(val);                               /* .. lookup tbl ix  = 'val' >>  0 bits */
1491:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);/* .. plus nbr msb lead zeros = 56 bits.*/
002694  420000     ADD W4, W0, W0
002696  FB8010     ZE [W0], W0
002698  B00380     ADD #0x38, W0
1492:                          }
1493:                      }
1494:                  }
1495:              #endif
1496:              
1497:              
1498:                  return (nbr_lead_zeros);
1499:              }
00269A  BE054F     MOV.D [--W15], W10
00269C  BE044F     MOV.D [--W15], W8
00269E  060000     RETURN
1500:              #endif
1501:              
1502:              
1503:              /*
1504:              *********************************************************************************************************
1505:              *                                         CPU_CntTrailZeros()
1506:              *
1507:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
1508:              *
1509:              * Argument(s) : val         Data value to count trailing zero bits.
1510:              *
1511:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1512:              *
1513:              * Caller(s)   : Application.
1514:              *
1515:              *               This function is a CPU module application programming interface (API) function & MAY 
1516:              *               be called by application function(s).
1517:              *
1518:              * Note(s)     : (1) (a) Supports the following data value sizes :
1519:              *
1520:              *                       (1)  8-bits
1521:              *                       (2) 16-bits
1522:              *                       (3) 32-bits
1523:              *                       (4) 64-bits
1524:              *
1525:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1526:              *
1527:              *                   (b) (1) For  8-bit values :
1528:              *
1529:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1530:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1531:              *                                   x    x    x    x    x    x    x    1            0
1532:              *                                   x    x    x    x    x    x    1    0            1
1533:              *                                   x    x    x    x    x    1    0    0            2
1534:              *                                   x    x    x    x    1    0    0    0            3
1535:              *                                   x    x    x    1    0    0    0    0            4
1536:              *                                   x    x    1    0    0    0    0    0            5
1537:              *                                   x    1    0    0    0    0    0    0            6
1538:              *                                   1    0    0    0    0    0    0    0            7
1539:              *                                   0    0    0    0    0    0    0    0            8
1540:              *
1541:              *
1542:              *                       (2) For 16-bit values :
1543:              *
1544:              *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1545:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1546:              *                              x    x    x    x    x         x    x    1            0
1547:              *                              x    x    x    x    x         x    1    0            1
1548:              *                              x    x    x    x    x         1    0    0            2
1549:              *                              :    :    :    :    :         :    :    :            :
1550:              *                              :    :    :    :    :         :    :    :            :
1551:              *                              x    x    x    x    1         0    0    0           11
1552:              *                              x    x    x    1    0         0    0    0           12
1553:              *                              x    x    1    0    0         0    0    0           13
1554:              *                              x    1    0    0    0         0    0    0           14
1555:              *                              1    0    0    0    0         0    0    0           15
1556:              *                              0    0    0    0    0         0    0    0           16
1557:              *
1558:              *
1559:              *                       (3) For 32-bit values :
1560:              *
1561:              *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1562:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1563:              *                              x    x    x    x    x         x    x    1            0
1564:              *                              x    x    x    x    x         x    1    0            1
1565:              *                              x    x    x    x    x         1    0    0            2
1566:              *                              :    :    :    :    :         :    :    :            :
1567:              *                              :    :    :    :    :         :    :    :            :
1568:              *                              x    x    x    x    1         0    0    0           27
1569:              *                              x    x    x    1    0         0    0    0           28
1570:              *                              x    x    1    0    0         0    0    0           29
1571:              *                              x    1    0    0    0         0    0    0           30
1572:              *                              1    0    0    0    0         0    0    0           31
1573:              *                              0    0    0    0    0         0    0    0           32
1574:              *
1575:              *
1576:              *                       (4) For 64-bit values :
1577:              *
1578:              *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1579:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1580:              *                              x    x    x    x    x         x    x    1            0
1581:              *                              x    x    x    x    x         x    1    0            1
1582:              *                              x    x    x    x    x         1    0    0            2
1583:              *                              :    :    :    :    :         :    :    :            :
1584:              *                              :    :    :    :    :         :    :    :            :
1585:              *                              x    x    x    x    1         0    0    0           59
1586:              *                              x    x    x    1    0         0    0    0           60
1587:              *                              x    x    1    0    0         0    0    0           61
1588:              *                              x    1    0    0    0         0    0    0           62
1589:              *                              1    0    0    0    0         0    0    0           63
1590:              *                              0    0    0    0    0         0    0    0           64
1591:              *
1592:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1593:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1594:              *
1595:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1596:              *
1597:              *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of 
1598:              *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's 
1599:              *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
1600:              *
1601:              *                           if (val != 0u) {
1602:              *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1603:              *                           } else {
1604:              *                               nbr_trail_zeros = nbr_lead_zeros;
1605:              *                           }
1606:              *
1607:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1608:              *                       execute the final 'if' statement.
1609:              *********************************************************************************************************
1610:              */
1611:              
1612:              #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
1613:              CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
1614:              {
1615:                  CPU_DATA  val_bit_mask;
1616:                  CPU_DATA  nbr_lead_zeros;
1617:                  CPU_DATA  nbr_trail_zeros;
1618:              
1619:              
1620:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0026A2  E00000     CP0 W0
0026A4  320004     BRA Z, 0x26AE
1621:                      return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
0026A0  200101     MOV #0x10, W1
1622:                  }
1623:              
1624:              
1625:                  val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
0026A6  EA0080     NEG W0, W1
1626:                  nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
0026A8  608000     AND W1, W0, W0
0026AA  07FF6E     RCALL CPU_CntLeadZeros
1627:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1628:                  nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0026AC  1000EF     SUBR W0, #0xF, W1
1629:              
1630:              
1631:                  return (nbr_trail_zeros);
1632:              }
0026AE  780001     MOV W1, W0
0026B0  060000     RETURN
1633:              #endif
1634:              
1635:              
1636:              /*
1637:              *********************************************************************************************************
1638:              *                                        CPU_CntTrailZeros08()
1639:              *
1640:              * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
1641:              *
1642:              * Argument(s) : val         Data value to count trailing zero bits.
1643:              *
1644:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1645:              *
1646:              * Caller(s)   : Application.
1647:              *
1648:              *               This function is a CPU module application programming interface (API) function & MAY be 
1649:              *               called by application function(s).
1650:              *
1651:              * Note(s)     : (1) Supports  8-bit values :
1652:              *
1653:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1654:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1655:              *                                x    x    x    x    x    x    x    1            0
1656:              *                                x    x    x    x    x    x    1    0            1
1657:              *                                x    x    x    x    x    1    0    0            2
1658:              *                                x    x    x    x    1    0    0    0            3
1659:              *                                x    x    x    1    0    0    0    0            4
1660:              *                                x    x    1    0    0    0    0    0            5
1661:              *                                x    1    0    0    0    0    0    0            6
1662:              *                                1    0    0    0    0    0    0    0            7
1663:              *                                0    0    0    0    0    0    0    0            8
1664:              *
1665:              *
1666:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1667:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1668:              *
1669:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1670:              *
1671:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1672:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1673:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return 
1674:              *                       data size, then the returned number of zeros must be offset by the difference 
1675:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
1676:              *
1677:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1678:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
1679:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1680:              *                           }
1681:              *
1682:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit 
1683:              *                       values would return a number of trailing zeros less than or equal to  8 bits.
1684:              *
1685:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1686:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1687:              *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
1688:              *
1689:              *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement 
1690:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s 
1691:              *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1692:              *                       initial 'val' is non-'0' :
1693:              *
1694:              *                           if (val != 0u) {
1695:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1696:              *                           } else {
1697:              *                               nbr_trail_zeros = nbr_lead_zeros;
1698:              *                           }
1699:              *
1700:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1701:              *                       execute the final 'if' statement.
1702:              *********************************************************************************************************
1703:              */
1704:              
1705:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1706:              CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
1707:              {
0026B2  784080     MOV.B W0, W1
1708:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1709:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1710:                  CPU_INT08U  val_bit_mask;
1711:                  CPU_DATA    nbr_lead_zeros;
1712:              #endif
1713:                  CPU_DATA    nbr_trail_zeros;
1714:              
1715:              
1716:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0026B6  E00401     CP0.B W1
0026B8  320004     BRA Z, 0x26C2
1717:                      return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
0026B4  200080     MOV #0x8, W0
1718:                  }
1719:              
1720:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1721:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1722:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1723:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1724:              
1725:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1726:                  val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0026BA  EA4001     NEG.B W1, W0
1727:                  nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0026BC  604001     AND.B W0, W1, W0
0026BE  07FF53     RCALL CPU_CntLeadZeros08
1728:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1729:                  nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0026C0  100067     SUBR W0, #0x7, W0
1730:              #endif
1731:              
1732:              
1733:                  return (nbr_trail_zeros);
1734:              }
0026C2  060000     RETURN
1735:              #endif
1736:              
1737:              
1738:              /*
1739:              *********************************************************************************************************
1740:              *                                        CPU_CntTrailZeros16()
1741:              *
1742:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
1743:              *
1744:              * Argument(s) : val         Data value to count trailing zero bits.
1745:              *
1746:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1747:              *
1748:              * Caller(s)   : Application.
1749:              *
1750:              *               This function is a CPU module application programming interface (API) function & MAY be 
1751:              *               called by application function(s).
1752:              *
1753:              * Note(s)     : (1) Supports 16-bit values :
1754:              *
1755:              *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1756:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1757:              *                           x    x    x    x    x         x    x    1            0
1758:              *                           x    x    x    x    x         x    1    0            1
1759:              *                           x    x    x    x    x         1    0    0            2
1760:              *                           :    :    :    :    :         :    :    :            :
1761:              *                           :    :    :    :    :         :    :    :            :
1762:              *                           x    x    x    x    1         0    0    0           11
1763:              *                           x    x    x    1    0         0    0    0           12
1764:              *                           x    x    1    0    0         0    0    0           13
1765:              *                           x    1    0    0    0         0    0    0           14
1766:              *                           1    0    0    0    0         0    0    0           15
1767:              *                           0    0    0    0    0         0    0    0           16
1768:              *
1769:              *
1770:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1771:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1772:              *
1773:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1774:              *
1775:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1776:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1777:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return 
1778:              *                       data size, then the returned number of zeros must be offset by the difference 
1779:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
1780:              *
1781:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1782:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
1783:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1784:              *                           }
1785:              *
1786:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit 
1787:              *                       values would return a number of trailing zeros less than or equal to 16 bits.
1788:              *
1789:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1790:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1791:              *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
1792:              *
1793:              *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement 
1794:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s 
1795:              *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1796:              *                       initial 'val' is non-'0' :
1797:              *
1798:              *                           if (val != 0u) {
1799:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1800:              *                           } else {
1801:              *                               nbr_trail_zeros = nbr_lead_zeros;
1802:              *                           }
1803:              *
1804:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1805:              *                       execute the final 'if' statement.
1806:              *********************************************************************************************************
1807:              */
1808:              
1809:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1810:              CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
1811:              {
1812:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1813:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1814:                  CPU_INT16U  val_bit_mask;
1815:                  CPU_DATA    nbr_lead_zeros;
1816:              #endif
1817:                  CPU_DATA    nbr_trail_zeros;
1818:              
1819:              
1820:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0026C6  E00000     CP0 W0
0026C8  320004     BRA Z, 0x26D2
1821:                      return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
0026C4  200101     MOV #0x10, W1
1822:                  }
1823:              
1824:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1825:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1826:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1827:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1828:              
1829:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1830:                  val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0026CA  EA0080     NEG W0, W1
1831:                  nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0026CC  608000     AND W1, W0, W0
0026CE  07FF50     RCALL CPU_CntLeadZeros16
1832:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1833:                  nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0026D0  1000EF     SUBR W0, #0xF, W1
1834:              #endif
1835:              
1836:              
1837:                  return (nbr_trail_zeros);
1838:              }
0026D2  780001     MOV W1, W0
0026D4  060000     RETURN
1839:              #endif
1840:              
1841:              
1842:              /*
1843:              *********************************************************************************************************
1844:              *                                        CPU_CntTrailZeros32()
1845:              *
1846:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
1847:              *
1848:              * Argument(s) : val         Data value to count trailing zero bits.
1849:              *
1850:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1851:              *
1852:              * Caller(s)   : Application.
1853:              *
1854:              *               This function is a CPU module application programming interface (API) function & MAY be 
1855:              *               called by application function(s).
1856:              *
1857:              * Note(s)     : (1) Supports 32-bit values :
1858:              *
1859:              *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1860:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1861:              *                           x    x    x    x    x         x    x    1            0
1862:              *                           x    x    x    x    x         x    1    0            1
1863:              *                           x    x    x    x    x         1    0    0            2
1864:              *                           :    :    :    :    :         :    :    :            :
1865:              *                           :    :    :    :    :         :    :    :            :
1866:              *                           x    x    x    x    1         0    0    0           27
1867:              *                           x    x    x    1    0         0    0    0           28
1868:              *                           x    x    1    0    0         0    0    0           29
1869:              *                           x    1    0    0    0         0    0    0           30
1870:              *                           1    0    0    0    0         0    0    0           31
1871:              *                           0    0    0    0    0         0    0    0           32
1872:              *
1873:              *
1874:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1875:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1876:              *
1877:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1878:              *
1879:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1880:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1881:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return 
1882:              *                       data size, then the returned number of zeros must be offset by the difference 
1883:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
1884:              *
1885:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1886:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
1887:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1888:              *                           }
1889:              *
1890:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit 
1891:              *                       values would return a number of trailing zeros less than or equal to 32 bits.
1892:              *
1893:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1894:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1895:              *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
1896:              *
1897:              *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement 
1898:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s 
1899:              *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1900:              *                       initial 'val' is non-'0' :
1901:              *
1902:              *                           if (val != 0u) {
1903:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1904:              *                           } else {
1905:              *                               nbr_trail_zeros = nbr_lead_zeros;
1906:              *                           }
1907:              *
1908:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1909:              *                       execute the final 'if' statement.
1910:              *********************************************************************************************************
1911:              */
1912:              
1913:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1914:              CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
1915:              {
1916:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1917:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1918:                  CPU_INT32U  val_bit_mask;
1919:                  CPU_DATA    nbr_lead_zeros;
1920:              #endif
1921:                  CPU_DATA    nbr_trail_zeros;
1922:              
1923:              
1924:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0026D8  500FE0     SUB W0, #0x0, [W15]
0026DA  588FE0     SUBB W1, #0x0, [W15]
0026DC  320009     BRA Z, 0x26F0
1925:                      return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
0026D6  200202     MOV #0x20, W2
1926:                  }
1927:              
1928:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1929:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1930:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1931:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1932:              
1933:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1934:                  val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0026DE  100160     SUBR W0, #0x0, W2
0026E0  1881E0     SUBBR W1, #0x0, W3
0026E2  600202     AND W0, W2, W4
0026E4  608103     AND W1, W3, W2
0026E6  780182     MOV W2, W3
0026E8  780104     MOV W4, W2
1935:                  nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0026EA  BE0002     MOV.D W2, W0
0026EC  07FF4E     RCALL CPU_CntLeadZeros32
1936:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1937:                  nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0026EE  10017F     SUBR W0, #0x1F, W2
1938:              #endif
1939:              
1940:              
1941:                  return (nbr_trail_zeros);
1942:              }
0026F0  780002     MOV W2, W0
0026F2  060000     RETURN
1943:              #endif
1944:              
1945:              
1946:              /*
1947:              *********************************************************************************************************
1948:              *                                        CPU_CntTrailZeros64()
1949:              *
1950:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
1951:              *
1952:              * Argument(s) : val         Data value to count trailing zero bits.
1953:              *
1954:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1955:              *
1956:              * Caller(s)   : Application.
1957:              *
1958:              *               This function is a CPU module application programming interface (API) function & MAY be 
1959:              *               called by application function(s).
1960:              *
1961:              * Note(s)     : (1) Supports 64-bit values :
1962:              *
1963:              *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1964:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1965:              *                           x    x    x    x    x         x    x    1            0
1966:              *                           x    x    x    x    x         x    1    0            1
1967:              *                           x    x    x    x    x         1    0    0            2
1968:              *                           :    :    :    :    :         :    :    :            :
1969:              *                           :    :    :    :    :         :    :    :            :
1970:              *                           x    x    x    x    1         0    0    0           59
1971:              *                           x    x    x    1    0         0    0    0           60
1972:              *                           x    x    1    0    0         0    0    0           61
1973:              *                           x    1    0    0    0         0    0    0           62
1974:              *                           1    0    0    0    0         0    0    0           63
1975:              *                           0    0    0    0    0         0    0    0           64
1976:              *
1977:              *
1978:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1979:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1980:              *
1981:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1982:              *
1983:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1984:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1985:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return 
1986:              *                       data size, then the returned number of zeros must be offset by the difference 
1987:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
1988:              *
1989:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1990:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
1991:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1992:              *                           }
1993:              *
1994:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit 
1995:              *                       values would return a number of trailing zeros less than or equal to 64 bits.
1996:              *
1997:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1998:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1999:              *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
2000:              *
2001:              *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement 
2002:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s 
2003:              *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the 
2004:              *                       initial 'val' is non-'0' :
2005:              *
2006:              *                           if (val != 0u) {
2007:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
2008:              *                           } else {
2009:              *                               nbr_trail_zeros = nbr_lead_zeros;
2010:              *                           }
2011:              *
2012:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
2013:              *                       execute the final 'if' statement.
2014:              *********************************************************************************************************
2015:              */
2016:              
2017:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
2018:              CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
2019:              {
0026F4  BE9F88     MOV.D W8, [W15++]
0026F6  BE9F8A     MOV.D W10, [W15++]
2020:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2021:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
2022:                  CPU_INT64U  val_bit_mask;
2023:                  CPU_DATA    nbr_lead_zeros;
2024:              #endif
2025:                  CPU_DATA    nbr_trail_zeros;
2026:              
2027:              
2028:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0026FA  500FE0     SUB W0, #0x0, [W15]
0026FC  588FE0     SUBB W1, #0x0, [W15]
0026FE  590FE0     SUBB W2, #0x0, [W15]
002700  598FE0     SUBB W3, #0x0, [W15]
002702  32000D     BRA Z, 0x271E
2029:                      return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
0026F8  200404     MOV #0x40, W4
2030:                  }
2031:              
2032:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
2033:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2034:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
2035:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
2036:              
2037:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
2038:                  val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
002704  B84460     MUL.UU W8, #0, W8
002706  B85560     MUL.UU W10, #0, W10
002708  540200     SUB W8, W0, W4
00270A  5C8281     SUBB W9, W1, W5
00270C  5D0302     SUBB W10, W2, W6
00270E  5D8383     SUBB W11, W3, W7
002710  620000     AND W4, W0, W0
002712  628081     AND W5, W1, W1
002714  630102     AND W6, W2, W2
2039:                  nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
002716  638183     AND W7, W3, W3
002718  07FF57     RCALL CPU_CntLeadZeros64
2040:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
2041:                  nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
00271A  2003F4     MOV #0x3F, W4
00271C  520200     SUB W4, W0, W4
2042:              #endif
2043:              
2044:              
2045:                  return (nbr_trail_zeros);
2046:              }
00271E  780004     MOV W4, W0
2047:              #endif
2048:              
2049:              
2050:              /*
2051:              *********************************************************************************************************
2052:              *********************************************************************************************************
2053:              *                                           LOCAL FUNCTIONS
2054:              *********************************************************************************************************
2055:              *********************************************************************************************************
2056:              */
2057:              
2058:              /*
2059:              *********************************************************************************************************
2060:              *                                           CPU_NameInit()
2061:              *
2062:              * Description : Initialize CPU Name.
2063:              *
2064:              * Argument(s) : none.
2065:              *
2066:              * Return(s)   : none.
2067:              *
2068:              * Caller(s)   : CPU_Init().
2069:              *
2070:              * Note(s)     : none.
2071:              *********************************************************************************************************
2072:              */
2073:              
2074:              #if (CPU_CFG_NAME_EN == DEF_ENABLED)
2075:              static  void  CPU_NameInit (void)
2076:              {
2077:                  CPU_NameClr();
2078:              }
2079:              #endif
2080:              
2081:              
2082:              /*
2083:              *********************************************************************************************************
2084:              *                                            CPU_TS_Init()
2085:              *
2086:              * Description : (1) Initialize CPU timestamp :
2087:              *
2088:              *                   (a) Initialize/start CPU timestamp timer                            See Note #1
2089:              *                   (b) Initialize       CPU timestamp controls
2090:              *
2091:              *
2092:              * Argument(s) : none.
2093:              *
2094:              * Return(s)   : none.
2095:              *
2096:              * Caller(s)   : CPU_Init().
2097:              *
2098:              * Note(s)     : (1) The following initialization MUST be sequenced as follows :
2099:              *
2100:              *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
2101:              *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
2102:              *                                                 otherwise, invalid time measurements may be calculated/
2103:              *                                                 returned.
2104:              *
2105:              *                   See also 'CPU_Init()  Note #3a'.
2106:              *********************************************************************************************************
2107:              */
2108:              
2109:              #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
2110:                   (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
2111:              static  void  CPU_TS_Init (void)
2112:              {
2113:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2114:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2115:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2116:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2117:                  CPU_TS_TMR  ts_tmr_cnts;
2118:              #endif
2119:              
2120:              
2121:                                                                              /* ----------------- INIT CPU TS TMR ------------------ */
2122:              #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
2123:                  CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
2124:                  CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
2125:              #endif
2126:              
2127:              
2128:                                                                              /* ------------------- INIT CPU TS -------------------- */
2129:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2130:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2131:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2132:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2133:                  ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
2134:              #endif
2135:              
2136:              #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
2137:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
2138:                  CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
2139:                  CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
2140:              #endif
2141:              
2142:              #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
2143:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
2144:                  CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
2145:                  CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
2146:              #endif
2147:              }
2148:              #endif
2149:              
2150:              
2151:              /*
2152:              *********************************************************************************************************
2153:              *                                        CPU_IntDisMeasInit()
2154:              *
2155:              * Description : (1) Initialize interrupts disabled time measurements feature :
2156:              *
2157:              *                   (a) Initialize interrupts disabled time measurement controls
2158:              *                   (b) Calculate  interrupts disabled time measurement overhead
2159:              *
2160:              *
2161:              * Argument(s) : none.
2162:              *
2163:              * Return(s)   : none.
2164:              *
2165:              * Caller(s)   : CPU_Init().
2166:              *
2167:              * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
2168:              *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
2169:              *                   disabled time measurements may be calculated/returned.
2170:              *
2171:              *                   See also 'CPU_Init()  Note #3b'.
2172:              *
2173:              *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
2174:              *                           a rounded average with better accuracy, hopefully of +/- one timer count.
2175:              *
2176:              *                       (2) However, a single overhead time measurement is recommended, even for instruction-
2177:              *                           cache-enabled CPUs, since critical sections are NOT typically called within
2178:              *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
2179:              *                           is a more realistic overhead for the majority of non-cached interrupts disabled
2180:              *                           time measurements.
2181:              *
2182:              *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
2183:              *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
2184:              *                       calculate an inflated overhead time which would then incorrectly calculate deflated
2185:              *                       interrupts disabled times.
2186:              *********************************************************************************************************
2187:              */
2188:              
2189:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2190:              static  void  CPU_IntDisMeasInit (void)
2191:              {
2192:                  CPU_TS_TMR  time_meas_tot_cnts;
2193:                  CPU_INT16U  i;
2194:                  CPU_SR_ALLOC();
2195:              
2196:                                                                              /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
2197:                  CPU_IntDisMeasCtr         = 0u;
2198:                  CPU_IntDisNestCtr         = 0u;
2199:                  CPU_IntDisMeasStart_cnts  = 0u;
2200:                  CPU_IntDisMeasStop_cnts   = 0u;
2201:                  CPU_IntDisMeasMaxCur_cnts = 0u;
2202:                  CPU_IntDisMeasMax_cnts    = 0u;
2203:                  CPU_IntDisMeasOvrhd_cnts  = 0u;
2204:              
2205:                                                                              /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
2206:                  time_meas_tot_cnts = 0u;
2207:                  CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
2208:                  for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
2209:                      CPU_IntDisMeasMaxCur_cnts = 0u;
2210:                      CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
2211:                      CPU_IntDisMeasStop();
2212:                      time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
2213:                  }
2214:                                                                              /* ... to calc avg time meas ovrhd (see Note #3a).      */
2215:                  CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
2216:                                                                  /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
2217:                  CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
2218:                  CPU_IntDisMeasMax_cnts    =  0u;
2219:                  CPU_INT_EN();
2220:              }
2221:              #endif
2222:              
2223:              
2224:              /*
2225:              *********************************************************************************************************
2226:              *                                       CPU_IntDisMeasMaxCalc()
2227:              *
2228:              * Description : Calculate maximum interrupts disabled time.
2229:              *
2230:              * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
2231:              *
2232:              * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
2233:              *
2234:              * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
2235:              *               CPU_IntDisMeasMaxGet().
2236:              *
2237:              * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
2238:              *                       during critical sections is calculated by the following equations :
2239:              *
2240:              *                       (1) time            =   [ time      -  time      ]  -  time
2241:              *                               interrupts      [     stop         start ]         total meas
2242:              *                                disabled       [     meas         meas  ]           ovrhd
2243:              *                           (via application)
2244:              *
2245:              *
2246:              *                       (2) time            =  time            +  time
2247:              *                               total meas         start meas         stop meas
2248:              *                                 ovrhd              ovrhd              ovrhd
2249:              *
2250:              *
2251:              *                               where
2252:              *
2253:              *                                       time                    time interrupts are disabled between
2254:              *                                           interrupts              first critical section enter &
2255:              *                                            disabled               last  critical section exit minus
2256:              *                                       (via application)           time measurement overhead
2257:              *
2258:              *                                       time                    time of disable interrupts start time
2259:              *                                           start                   measurement (in timer counts)
2260:              *                                           meas
2261:              *
2262:              *                                       time                    time of disable interrupts stop  time
2263:              *                                           stop                    measurement (in timer counts)
2264:              *                                           meas
2265:              *
2266:              *                                       time                    total overhead time to start/stop disabled
2267:              *                                           total meas              interrupts time measurements (in timer
2268:              *                                             ovrhd                 counts)
2269:              *
2270:              *                                       time                    total overhead time after getting start
2271:              *                                           start meas              time until end of start measurement
2272:              *                                             ovrhd                 function  (in timer counts)
2273:              *
2274:              *                                       time                    total overhead time from beginning of stop
2275:              *                                           stop meas               measurement function until after getting
2276:              *                                             ovrhd                 stop time (in timer counts)
2277:              *
2278:              *
2279:              *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final 
2280:              *                       calculations to subtract the interrupts disabled time measurement overhead is 
2281:              *                       performed asynchronously in API functions.
2282:              *
2283:              *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
2284:              *
2285:              *                   (c) The amount of time interrupts are disabled is calculated by either of the
2286:              *                       following equations :
2287:              *
2288:              *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
2289:              *
2290:              *                               where
2291:              *
2292:              *                                   Number timer counts             Number of timer counts measured
2293:              *                                   Timer period                    Timer's period in some units of
2294:              *                                                                       (fractional) seconds
2295:              *                                   Interrupts disabled time        Amount of time interrupts are
2296:              *                                                                       disabled, in same units of
2297:              *                                                                       (fractional) seconds as the
2298:              *                                                                       Timer period
2299:              *
2300:              *                                                         Number timer counts
2301:              *                       (2) Interrupts disabled time  =  ---------------------
2302:              *                                                           Timer frequency
2303:              *
2304:              *                               where
2305:              *
2306:              *                                   Number timer counts             Number of timer counts measured
2307:              *                                   Timer frequency                 Timer's frequency in some units
2308:              *                                                                       of counts per second
2309:              *                                   Interrupts disabled time        Amount of time interrupts are
2310:              *                                                                       disabled, in seconds
2311:              *
2312:              *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
2313:              *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
2314:              *
2315:              *               (2) Although it is not typical, it is possible for an interrupts disabled time
2316:              *                   measurement to be less than the interrupts disabled time measurement overhead;
2317:              *                   especially if the overhead was calculated with a single, non-cached measurement
2318:              *                   & critical sections are called within instruction-cached loops.
2319:              *********************************************************************************************************
2320:              */
2321:              
2322:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2323:              static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
2324:              {
2325:                  CPU_TS_TMR  time_max_cnts;
2326:              
2327:              
2328:                  time_max_cnts = time_tot_cnts;
2329:                  if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
2330:                      time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
2331:                  } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
2332:                      time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
2333:                  }
2334:              
2335:                  return (time_max_cnts);
2336:              }
2337:              #endif
2338:              
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/bsp.c  ---------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                
18:                /*
19:                 *********************************************************************************************************
20:                 *                                       MPLAB CONFIGURATION MACROS
21:                 *********************************************************************************************************
22:                 */
23:                #if defined(__dsPIC33E__)
24:                // FICD
25:                #pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
26:                #pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
27:                
28:                // FPOR
29:                #pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
30:                #pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
31:                #pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)
32:                
33:                // FWDT
34:                #pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
35:                #pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
36:                #pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
37:                #pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
38:                #pragma config FWDTEN = ON              // Watchdog Timer Enable bit (Watchdog timer always enabled)
39:                
40:                // FOSC
41:                #pragma config POSCMD = NONE            // Primary Oscillator Mode Select bits (Primary Oscillator disabled)
42:                #pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
43:                #pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
44:                #pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
45:                
46:                // FOSCSEL
47:                #pragma config FNOSC = FRCDIVN          // Oscillator Source Selection (Internal Fast RC (FRC) Oscillator with postscaler)
48:                #pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
49:                
50:                // FGS
51:                #pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
52:                #pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)
53:                #elif defined (__PIC24F__)
54:                _CONFIG1(JTAGEN_OFF & FWDTEN_OFF & WINDIS_OFF); /* Disable JTAG and watchdog timer. (Enables full use   ... */
55:                /* ... port A pins and prevents watchdog timer resets.      */
56:                _CONFIG2(FNOSC_FRCDIV & POSCMOD_XT); /* Select the primary (XT, HS, EC) Oscillator with PLL      */
57:                #elif defined (__PIC24E__)
58:                #pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
59:                #pragma config GSS = OFF                // General Segment Code-Protect bit (General Segment Code protect is disabled)
60:                #pragma config GSSK = OFF               // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
61:                
62:                // FOSCSEL
63:                #pragma config FNOSC = FRC           // Initial Oscillator Source Selection bits (Primary Oscillator (XT, HS, EC) with PLL)
64:                #pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
65:                
66:                // FOSC
67:                #pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
68:                #pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
69:                #pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
70:                #pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
71:                
72:                // FWDT
73:                #pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
74:                #pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
75:                #pragma config PLLKEN = ON              // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
76:                #pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
77:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
78:                
79:                // FPOR
80:                #pragma config FPWRT = PWR128           // Power-on Reset Timer Value Select bits (128ms)
81:                #pragma config BOREN = ON               // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
82:                #pragma config ALTI2C1 = OFF            // Alternate I2C pins for I2C1 (SDA1/SCK1 pins are selected as the I/O pins for I2C1)
83:                #pragma config ALTI2C2 = OFF            // Alternate I2C pins for I2C2 (SDA2/SCK2 pins are selected as the I/O pins for I2C2)
84:                
85:                // FICD
86:                #pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
87:                #pragma config RSTPRI = PF              // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
88:                #pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
89:                
90:                // FAS
91:                #pragma config AWRP = OFF               // Auxiliary Segment Write-protect bit (Aux Flash may be written)
92:                #pragma config APL = OFF                // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
93:                #pragma config APLK = OFF               // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
94:                
95:                #elif defined(__dsPIC33F__)
96:                
97:                // FBS
98:                #pragma config BWRP = WRPROTECT_OFF     // Boot Segment Write Protect (Boot Segment may be written)
99:                #pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
100:               #pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)
101:               
102:               // FSS
103:               #pragma config SWRP = WRPROTECT_OFF     // Secure Segment Program Write Protect (Secure Segment may be written)
104:               #pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
105:               #pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)
106:               
107:               // FGS
108:               #pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
109:               #pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)
110:               
111:               // FOSCSEL
112:               #pragma config FNOSC = LPRCDIVN           // Oscillator Mode (Primary Oscillator (XT, HS, EC) w/ PLL)
113:               #pragma config IESO = ON                // Two-speed Oscillator Start-Up Enable (Start up with FRC, then switch)
114:               
115:               // FOSC
116:               #pragma config POSCMD = XT              // Primary Oscillator Source (XT Oscillator Mode)
117:               #pragma config OSCIOFNC = OFF           // OSC2 Pin Function (OSC2 pin has clock out function)
118:               #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Both Clock Switching and Fail-Safe Clock Monitor are disabled)
119:               
120:               // FWDT
121:               #pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler (1:32,768)
122:               #pragma config WDTPRE = PR128           // WDT Prescaler (1:128)
123:               #pragma config WINDIS = OFF             // Watchdog Timer Window (Watchdog Timer in Non-Window mode)
124:               #pragma config FWDTEN = ON              // Watchdog Timer Enable (Watchdog timer always enabled)
125:               
126:               // FPOR
127:               #pragma config FPWRT = PWR128           // POR Timer Value (128ms)
128:               
129:               // FICD
130:               #pragma config ICS = PGD1               // Comm Channel Select (Communicate on PGC1/EMUC1 and PGD1/EMUD1)
131:               #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG is Disabled)
132:               #endif
133:               /*********************************************************************************************************
134:                *                                              CONSTANTS
135:                *********************************************************************************************************
136:                */
137:               
138:               #define  LED6   0x40                                                    /* Port A pin 6                                             */
139:               #define  LED7   0x80                                                    /* Port A pin 7                                             */
140:               
141:               /*
142:                *********************************************************************************************************
143:                *                                              VARIABLES
144:                *********************************************************************************************************
145:                */
146:               
147:               /*
148:                *********************************************************************************************************
149:                *                                              PROTOTYPES
150:                *********************************************************************************************************
151:                */
152:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
153:               static void BSP_PLL_Init(void);
154:               #endif
155:               static void Tmr_TickInit(void);
156:               
157:               /*
158:                *********************************************************************************************************
159:                *                                         BSP INITIALIZATION
160:                *
161:                * Description : This function should be called by your application code before you make use of any of the
162:                *               functions found in this module.
163:                *
164:                * Arguments   : none
165:                *********************************************************************************************************
166:                */
167:               
168:               void BSP_Init(void) {
169:                   RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
170:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
171:                   BSP_PLL_Init(); /* Initialize the PLL                                       */
172:               #endif
173:                   LED_Init(); /* Initialize the I/Os for the LED controls                 */
002ADE  A9A740     BCLR RCON, #5
174:                   Tmr_TickInit(); /* Initialize the uC/OS-II tick interrupt                   */
002AE0  07FFFB     RCALL LED_Init
002AE2  37FFE3     BRA _Tmr_TickInit
175:               }
176:               
177:               /*
178:                *********************************************************************************************************
179:                *                                      BSP_PLL_Init()
180:                *
181:                * Description : This function configures and enables the PLL with the external oscillator
182:                *               selected as the input clock to the PLL.
183:                *
184:                * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
185:                *               2) FIN is the PLL input clock frequency, defined in bsp.h as
186:                *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
187:                *                  oscillator on the Explorer 16 Evaluation Board.
188:                *               3) M is the desired PLL multiplier
189:                *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
190:                *               5) N2 is the PLL output divider (Post-Divider)
191:                *
192:                * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
193:                *                  The processor clock is (1/2) of the PLL output.
194:                *                  Performance = 40 MIPS.
195:                *********************************************************************************************************
196:                */
197:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
198:               
199:               static void BSP_PLL_Init(void) {
200:                   PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
201:                   CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
202:               }
203:               #endif
204:               
205:               /*
206:                *********************************************************************************************************
207:                *                                      BSP_CPU_ClkFrq()
208:               
209:                * Description : This function determines the CPU clock frequency (Fcy)
210:                * Returns     : The CPU frequency in (HZ)
211:                *********************************************************************************************************
212:                */
213:               
214:               CPU_INT32U BSP_CPU_ClkFrq(void) {
215:                   CPU_INT08U Clk_Selected;
216:                   CPU_INT16U FRC_Div;
217:                   CPU_INT32U CPU_Clk_Frq;
218:               
219:               
220:               #if defined (__dsPIC33E__) || defined (__dsPIC33F__)
221:                   CPU_INT08U PLL_n1;
222:                   CPU_INT08U PLL_n2;
223:                   CPU_INT16U PLL_m;
224:                   PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
225:                   PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
226:                   PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
227:                   PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
228:               #endif
229:               
230:                   FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
002A44  803A24     MOV CLKDIV, W4
002A8C  DE2148     LSR W4, #8, W2
002A8E  610167     AND W2, #0x7, W2
231:                   FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
002A90  200020     MOV #0x2, W0
002A92  DD0102     SL W0, W2, W2
232:               
233:                   Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
002A46  270002     MOV #0x7000, W2
002A48  803A10     MOV OSCCON, W0
002A4A  610100     AND W2, W0, W2
234:               
235:                   switch (Clk_Selected) {
002A4C  DE114C     LSR W2, #12, W2
002A4E  FB8102     ZE W2, W2
002A50  EB0180     CLR W3
002A52  510161     SUB W2, #0x1, W2
002A54  5981E0     SUBB W3, #0x0, W3
002A5A  510FE6     SUB W2, #0x6, [W15]
002A5C  598FE0     SUBB W3, #0x0, [W15]
002A5E  3E0022     BRA GTU, 0x2AA4
002A60  016002     BRA W2
002A62  37001E     BRA 0x2AA0
002A64  370005     BRA 0x2A70
002A66  370007     BRA 0x2A76
002A68  370009     BRA 0x2A7C
002A6A  37000B     BRA 0x2A82
002A6C  37000D     BRA 0x2A88
002A6E  37000E     BRA 0x2A8C
236:                       case 0: /* Fast Oscillator (FRC) Selected                           */
237:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
002A56  275100     MOV #0x7510, W0
002A58  200701     MOV #0x70, W1
238:                           break;
239:               
240:                       case 1:
241:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
242:                           CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
243:                                   (FRC_Div * PLL_n1 * PLL_n2));
244:               #else
245:                           /* Fast Oscillator (FRC) with PLL Selected                  */
246:                           CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
002AA0  2D4400     MOV #0xD440, W0
002AA2  201C11     MOV #0x1C1, W1
247:               #endif
248:                           break;
249:               
250:                       case 2: /* Primary External Oscillator Selected                     */
251:                           CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
002A70  212000     MOV #0x1200, W0
002A72  2007A1     MOV #0x7A, W1
252:                           break;
002A74  370017     BRA 0x2AA4
253:               
254:                       case 3:
255:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
256:                           CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
257:                                   (PLL_n1 * PLL_n2));
258:               #else
259:                           /* Primary External Oscillator with PLL Selected            */
260:                           CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
002A76  248000     MOV #0x4800, W0
002A78  201E81     MOV #0x1E8, W1
261:               #endif
262:                           break;
002A7A  370014     BRA 0x2AA4
263:               
264:                       case 4: /* Secondary Oscillator Selected (SOCS)                     */
265:                           CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
002A7C  280000     MOV #0x8000, W0
002A7E  200001     MOV #0x0, W1
266:                           break;
002A80  370011     BRA 0x2AA4
267:               
268:                       case 5: /* Low Power Oscillator (LPOSC) Selected                    */
269:                           CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
002A82  279180     MOV #0x7918, W0
002A84  200001     MOV #0x0, W1
270:                           break;
002A86  37000E     BRA 0x2AA4
271:               
272:                       case 6:
273:                           CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
002A88  B80060     MUL.UU W0, #0, W0
274:                           break;
002A8A  37000C     BRA 0x2AA4
275:               
276:                       case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
277:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
002A94  EB0180     CLR W3
002A96  275100     MOV #0x7510, W0
002A98  200701     MOV #0x70, W1
002A9A  0203C4     CALL 0x3C4
002A9C  000000     NOP
278:                           break;
002A9E  370002     BRA 0x2AA4
279:               
280:                       default:
281:                           CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
282:                           break;
283:                   }
284:               
285:                   CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
002AA4  D10081     LSR W1, W1
002AA6  D38000     RRC W0, W0
286:               
287:                   return (CPU_Clk_Frq); /* Return the operating frequency                           */
288:               }
289:               
290:               /*
291:                *********************************************************************************************************
292:                *                                     DISABLE ALL INTERRUPTS
293:                *
294:                * Description : This function disables all interrupts from the interrupt controller.
295:                *
296:                * Arguments   : none
297:                *********************************************************************************************************
298:                */
299:               
300:               void BSP_IntDisAll(void) {
301:               }
002ACE  060000     RETURN
302:               
303:               /*
304:                *********************************************************************************************************
305:                *                                         LED I/O INITIALIZATION
306:                *
307:                * Description : This function initializes the I/O Pins used by the onboard LEDs
308:                *
309:                * Arguments   : none
310:                *
311:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
312:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
313:                *********************************************************************************************************
314:                */
315:               
316:               void LED_Init(void) {
317:                   TRISBbits.TRISB8 = 0;
002AD8  A902C9     BCLR 0x2C9, #0
318:               #if defined(__dsPIC33E__)
319:                   TRISB = 0;
320:                   TRISC = 0;
321:                   TRISE = 0;
322:                   ANSELA = 0;
323:                   ANSELB = 0;
324:                   ANSELC = 0;
325:                   ANSELE = 0;
326:               #elif defined(__dsPIC33F__)
327:                   AD1PCFGH |= (LED6 | LED7); /* Set PA6 & PA7 (R9, R10) to from analog to digital I/O    */
328:               
329:               #endif
330:                   LED_Off(0); /* Shut off all LEDs                                        */
002ADA  EB4000     CLR.B W0
002ADC  37FFFB     BRA LED_Off
331:               }
332:               
333:               /*
334:                *********************************************************************************************************
335:                *                                             LED ON
336:                *
337:                * Description : This function is used to control any or all the LEDs on the board.
338:                *
339:                * Arguments   : led    is the number of the LED to control
340:                *                      0    indicates that you want ALL the LEDs to be ON
341:                *                      1    turns ON LED1
342:                *                      2    turns ON LED2
343:                *                      ...
344:                *                      8    turns ON LED8
345:                *
346:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
347:                *********************************************************************************************************
348:                */
349:               
350:               void LED_On(CPU_INT08U led) {
351:               #if defined(__dsPIC33E__)
352:                   if (led == 0) {
353:                       PORTCbits.RC0 = 1;
354:                       PORTCbits.RC1 = 1; /* Turn on all of the LEDs if a 0 is passed in              */
355:                       PORTBbits.RB4 = 1;
356:                       PORTAbits.RA8 = 1;
357:                       PORTEbits.RE12 = 1;
358:                       PORTEbits.RE13 = 1;
359:                       PORTEbits.RE14 = 1;
360:                       PORTCbits.RC8 = 1;
361:                       return;
362:                   }
363:               
364:                   if ((led >= 1) && (led <= 8)) {
365:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
366:                       /* Turn on the chosen LED                                   */
367:                       if (led == 0) {
368:                           PORTCbits.RC0 = 1;
369:                       }
370:                       if (led == 1) {
371:                           PORTCbits.RC1 = 1;
372:                       } else if (led == 2) {
373:                           PORTBbits.RB4 = 1;
374:                       } else if (led == 3) {
375:                           PORTAbits.RA8 = 1;
376:                       } else if (led == 4) {
377:                           PORTEbits.RE12 = 1;
378:                       } else if (led == 5) {
379:                           PORTEbits.RE13 = 1;
380:                       } else if (led == 6) {
381:                           PORTEbits.RE14 = 1;
382:                       } else {
383:                           PORTCbits.RC8 = 1;
384:                       }
385:               
386:                   }
387:               #elif defined(__dsPIC33F__) || defined(__PIC24F__) || defined(__PIC24E__)
388:                   if (led == 0) {
389:                       PORTA |= 0xFF; /* Turn on all of the LEDs if a 0 is passed in              */
390:                       return;
391:                   }
392:               
393:                   if ((led >= 1) && (led <= 8)) {
394:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
395:                       PORTA |= (1 << led); /* Turn on the chosen LED                                   */
396:                   }
397:               #endif
398:                   LATBbits.LATB8 = 1;
002AD0  A802CD     BSET 0x2CD, #0
399:               }
002AD2  060000     RETURN
400:               
401:               /*
402:                *********************************************************************************************************
403:                *                                             LED OFF
404:                *
405:                * Description : This function is used to control any or all the LEDs on the board.
406:                *
407:                * Arguments   : led    is the number of the LED to turn OFF
408:                *                      0    indicates that you want ALL the LEDs to be OFF
409:                *                      1    turns OFF LED1
410:                *                      2    turns OFF LED2
411:                *                      .
412:                *                      8    turns OFF LED8
413:                *
414:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
415:                *********************************************************************************************************
416:                */
417:               
418:               void LED_Off(CPU_INT08U led) {
419:               #if defined(__dsPIC33E__)
420:                   if (led == 0) {
421:                       PORTCbits.RC0 = 0;
422:                       PORTCbits.RC1 = 0; /* Turn off all of the LEDs if a 0 is passed in              */
423:                       PORTBbits.RB4 = 0;
424:                       PORTAbits.RA8 = 0;
425:                       PORTEbits.RE12 = 0;
426:                       PORTEbits.RE13 = 0;
427:                       PORTEbits.RE14 = 0;
428:                       PORTCbits.RC8 = 0;
429:                       return;
430:                   }
431:               
432:                   if ((led >= 1) && (led <= 8)) {
433:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
434:                       /* Turn on the chosen LED                                   */
435:                       if (led == 0) {
436:                           PORTCbits.RC0 = 0;
437:                       } else if (led == 1) {
438:                           PORTCbits.RC1 = 0;
439:                       } else if (led == 2) {
440:                           PORTBbits.RB4 = 0;
441:                       } else if (led == 3) {
442:                           PORTAbits.RA8 = 0;
443:                       } else if (led == 4) {
444:                           PORTEbits.RE12 = 0;
445:                       } else if (led == 5) {
446:                           PORTEbits.RE13 = 0;
447:                       } else if (led == 6) {
448:                           PORTEbits.RE14 = 0;
449:                       } else {
450:                           PORTCbits.RC8 = 0;
451:                       }
452:                   }
453:               #elif defined(__dsPIC33F__) || defined(__PIC24F__) || defined(__PIC24E__)
454:                   if (led == 0) {
455:                       PORTA &= ~0xFF; /* Turn on all of the LEDs if a 0 is passed in              */
456:                       return;
457:                   }
458:               
459:                   if ((led >= 1) && (led <= 8)) {
460:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
461:                       PORTA &= ~(1 << led); /* Turn on the chosen LED                                   */
462:                   }
463:               #endif
464:                   LATBbits.LATB8 = 0;
002AD4  A902CD     BCLR 0x2CD, #0
465:               }
002AD6  060000     RETURN
466:               
467:               /*
468:                *********************************************************************************************************
469:                *                                             LED TOGGLE
470:                *
471:                * Description : This function is used to toggle any or all the LEDs on the board.
472:                *
473:                * Arguments   : led    is the number of the LED to control
474:                *                      0    indicates that you want to toggle ALL the LEDs
475:                *                      1    toggles LED1
476:                *                      2    toggles LED2
477:                *                      .
478:                *                      8    toggles LED8
479:                *
480:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
481:                *********************************************************************************************************
482:                */
483:               
484:               void LED_Toggle(CPU_INT08U led) {
485:               #if defined(__dsPIC33E__)
486:                   if (led == 0) {
487:                       PORTCbits.RC0 = 1;
488:                       PORTCbits.RC1 = 1; /* Turn on all of the LEDs if a 0 is passed in              */
489:                       PORTBbits.RB4 = 1;
490:                       PORTAbits.RA8 = 1;
491:                       PORTEbits.RE12 = 1;
492:                       PORTEbits.RE13 = 1;
493:                       PORTEbits.RE14 = 1;
494:                       PORTCbits.RC8 = 1;
495:                       return;
496:                   }
497:               
498:                   if ((led >= 1) && (led <= 8)) {
499:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
500:                       /* Turn on the chosen LED                                   */
501:                       if (led == 0) {
502:                           PORTCbits.RC0 ^= 1;
503:                       } else if (led == 1) {
504:                           PORTCbits.RC1 ^= 1;
505:                       } else if (led == 2) {
506:                           PORTBbits.RB4 ^= 1;
507:                       } else if (led == 3) {
508:                           PORTAbits.RA8 ^= 1;
509:                       } else if (led == 4) {
510:                           PORTEbits.RE12 ^= 1;
511:                       } else if (led == 5) {
512:                           PORTEbits.RE13 ^= 1;
513:                       } else if (led == 6) {
514:                           PORTEbits.RE14 ^= 1;
515:                       } else {
516:                           PORTCbits.RC8 ^= 1;
517:                       }
518:                   }
519:               #elif defined(__dsPIC33F__) || defined(__PIC24F__) || defined(__PIC24E__)
520:                   if (led == 0) {
521:                       PORTA ^= 0xFF; /* Turn on all of the LEDs if a 0 is passed in              */
522:                       return;
523:                   }
524:               
525:                   if ((led >= 1) && (led <= 8)) {
526:                       led--; /* Convert the LED number to a pin number by subtracting 1	*/
527:                       PORTA ^= (1 << led); /* Turn on the chosen LED                                   */
528:                   }
529:               #endif
530:                   LATBbits.LATB8 ^= 1;
002AE4  801661     MOV LATB, W1
002AE6  DE08C8     LSR W1, #8, W1
002AE8  EA8081     COM W1, W1
002AEA  6080E1     AND W1, #0x1, W1
002AEC  DD08C8     SL W1, #8, W1
002AEE  801660     MOV LATB, W0
002AF0  A18000     BCLR W0, #8
002AF2  708000     IOR W1, W0, W0
002AF4  881660     MOV W0, LATB
531:               }
002AF6  060000     RETURN
532:               
533:               /*
534:                *********************************************************************************************************
535:                *                                   OSProbe_TmrInit()
536:                *
537:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
538:                *               free running timer that is used to make time measurements.
539:                *
540:                * Arguments   : none
541:                *
542:                * Returns     : none
543:                *
544:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
545:                *                  from Tmr_TickInit().
546:                *********************************************************************************************************
547:                */
548:               
549:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
550:               
551:               void OSProbe_TmrInit(void) {
552:               #if OS_PROBE_TIMER_SEL == 3
553:                   T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
554:                   TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
555:                   PR3 = 0xFFFF; /* Set the period register to its maximum value             */
556:                   T3CON |= TON; /* Start the timer                                          */
557:               #endif
558:               
559:               #if OS_PROBE_TIMER_SEL == 5
560:                   T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
561:                   TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
562:                   PR5 = 0xFFFF; /* Set the period register to its maximum value             */
563:                   T5CON |= TON; /* Start the timer                                          */
564:               #endif
565:               }
566:               #endif
567:               
568:               /*
569:                *********************************************************************************************************
570:                *                                   OSProbe_TmrRd()
571:                *
572:                * Description : This function is called to read the current counts of a 16 bit free running timer.
573:                *
574:                * Arguments   : none
575:                *
576:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
577:                *********************************************************************************************************
578:                */
579:               
580:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
581:               
582:               CPU_INT32U OSProbe_TmrRd(void) {
583:               #if OS_PROBE_TIMER_SEL == 3
584:                   return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
585:               #endif
586:               
587:               #if OS_PROBE_TIMER_SEL == 5
588:                   return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
589:               #endif
590:               }
591:               #endif
592:               
593:               /*
594:                *********************************************************************************************************
595:                *                                       TICKER INITIALIZATION
596:                *
597:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
598:                *               interrupts every 1 to 100 mS).
599:                *
600:                * Arguments   : none
601:                *
602:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
603:                *               2) The timer resets to 0 after period register match interrupt is generated
604:                *********************************************************************************************************
605:                */
606:               
607:               static void Tmr_TickInit(void) {
608:                   CPU_INT32U tmr_frq;
609:                   CPU_INT16U cnts;
610:               
611:               
612:                   tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
002AA8  060000     RETURN
613:                   cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
002AAC  203E82     MOV #0x3E8, W2
002AAE  200003     MOV #0x0, W3
002AB0  0203E2     CALL 0x3E2
002AB2  000000     NOP
002AB4  E90080     DEC W0, W1
614:               
615:               #if BSP_OS_TMR_SEL == 2
616:                   T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
002AB6  EF2110     CLR T2CON
617:                   TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
002AB8  EF2106     CLR TMR2
618:                   PR2 = cnts; /* Set the period register                                  */
002ABA  880861     MOV W1, PR2
619:                   IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
002ABC  28FFF0     MOV #0x8FFF, W0
002ABE  B620A6     AND IPC1
620:                   IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
002AC0  270000     MOV #0x7000, W0
002AC2  B720A6     IOR IPC1
621:                   IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
002AC4  A9E084     BCLR IFS0, #7
622:                   IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
002AC6  A8E094     BSET IEC0, #7
623:                   T2CON |= TON; /* Start the timer                                          */
002AC8  280000     MOV #0x8000, W0
002ACA  B72110     IOR T2CON
624:               #endif
625:               
626:               #if BSP_OS_TMR_SEL == 4
627:                   T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
628:                   TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
629:                   PR4 = cnts; /* Set the period register                                  */
630:                   IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
631:                   IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
632:                   IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
633:                   IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
634:                   T4CON |= TON; /* Start the timer                                          */
635:               #endif
636:               }
002ACC  060000     RETURN
637:               
638:               /*
639:                *********************************************************************************************************
640:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
641:                *
642:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
643:                *********************************************************************************************************
644:                */
645:               
646:               //void OS_Tick_ISR_Handler(void) {
647:               
648:               void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
002AF8  FEA000     PUSH.S
002AFA  F80036     PUSH RCOUNT
002AFC  BE9F84     MOV.D W4, [W15++]
002AFE  BE9F86     MOV.D W6, [W15++]
002B00  F80034     PUSH PSVPAG
002B02  200004     MOV #0x0, W4
002B04  8801A4     MOV W4, PSVPAG
649:               #if  BSP_OS_TMR_SEL == 2
650:                   IFS0 &= ~T2IF;
002B06  A9E084     BCLR IFS0, #7
651:               #endif
652:               
653:               #if  BSP_OS_TMR_SEL == 4
654:                   IFS1 &= ~T41F;
655:               #endif
656:               
657:                   OSTimeTick();
002B08  021C4E     CALL OSTimeTick
002B0A  000000     NOP
658:               }
002B0C  F90034     POP PSVPAG
659:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/TIM.c  ---------------------------
1:                 #include"type.h"
2:                 #include"user.h"
3:                 #include"time.h"
4:                 #include"string.h"
5:                 
6:                 vu16 gT3Count = 0;
7:                 vu16 gT1Count = 0; // =1
8:                 
9:                 /*************************************
10:                Function: TIM1_Configuration 
11:                Description: 16 
12:                Input:  
13:                Output: 
14:                 *************************************/
15:                void TIM1_Configuration(void) {
16:                    T1CONbits.TON = 1;
002950  A8E105     BSET 0x105, #7
17:                    T1CONbits.TSIDL = 0; //0 = 
002952  A9A105     BCLR 0x105, #5
18:                    T1CONbits.TCKPS = 0; //64us2()*500K/2=250k=2us 2us*256=512us=0.512ms
002954  2FFCF0     MOV #0xFFCF, W0
002956  B62104     AND T1CON
19:                    T1CONbits.TCS = 1; //=1 T1ECS
002958  A82104     BSET T1CON, #1
20:                    T1CONbits.T1ECS = 0x00; //=0 SOSC
00295A  2FCFF0     MOV #0xFCFF, W0
00295C  B62104     AND T1CON
21:                    T1CONbits.TGATE = 0;
00295E  A9C104     BCLR T1CON, #6
22:                    //    T1CONbits.TSYNC = 0;
23:                    PR1 = 0x8000; //1s  
002960  280000     MOV #0x8000, W0
002962  880810     MOV W0, PR1
24:                    IPC0bits.T1IP = 6; //Setup Timer3 interrupt for desired priority level
002964  28FFF1     MOV #0x8FFF, W1
002966  800520     MOV IPC0, W0
002968  608080     AND W1, W0, W1
00296A  260000     MOV #0x6000, W0
00296C  700001     IOR W0, W1, W0
00296E  880520     MOV W0, IPC0
25:                    //(this example assigns level 1 priority)
26:                    IFS0bits.T1IF = 0; //Clear the Timer3 interrupt status flag
002970  A96084     BCLR IFS0, #3
27:                    IEC0bits.T1IE = 1; //Enable Timer3 interrupts
002972  A86094     BSET IEC0, #3
28:                    TMR1 = 0;
002974  EF2100     CLR TMR1
29:                    T1CONbits.TON = 0; //=0!!!!!!
002976  A9E105     BCLR 0x105, #7
30:                }
002978  060000     RETURN
31:                
32:                /*************************************
33:                Function: TIM4_Configuration 
34:                Description: 16 
35:                Input:  
36:                Output: 
37:                 *************************************/
38:                void TIM2_Configuration(void) {
39:                    T2CONbits.TON = 1;
00297A  A8E111     BSET 0x111, #7
40:                    T2CONbits.TSIDL = 0;
00297C  A9A111     BCLR 0x111, #5
41:                    T2CONbits.TCKPS = 2; //1=1:8  2.56s 10(2)=1:64  11(3)=1:256
00297E  2FFCF0     MOV #0xFFCF, W0
002980  B60110     AND T2CON, WREG
002982  A05000     BSET W0, #5
002984  880880     MOV W0, T2CON
42:                    T2CONbits.TCS = 0; //=1 /2
002986  A92110     BCLR T2CON, #1
43:                    T2CONbits.TGATE = 0;
002988  A9C110     BCLR T2CON, #6
44:                    T2CONbits.T32 = 0; //16
00298A  A96110     BCLR T2CON, #3
45:                    PR2 = 6250; //100ms   1/4/256*1000000*?=1500/1000ms 100ms?=6250
00298C  2186A0     MOV #0x186A, W0
00298E  880860     MOV W0, PR2
46:                    IPC1bits.T2IP = 2; //Setup Timer3 interrupt for desired priority level
002990  28FFF0     MOV #0x8FFF, W0
002992  B600A6     AND IPC1, WREG
002994  A0D000     BSET W0, #13
002996  880530     MOV W0, IPC1
47:                    //(this example assigns level 1 priority)
48:                    IFS0bits.T2IF = 0; //Clear the Timer3 interrupt status flag
002998  A9E084     BCLR IFS0, #7
49:                    IEC0bits.T2IE = 1; //Enable Timer3 interrupts
00299A  A8E094     BSET IEC0, #7
50:                    TMR2 = 0;
00299C  EF2106     CLR TMR2
51:                    T2CONbits.TON = 0; //=0!!!!!!
00299E  A9E111     BCLR 0x111, #7
52:                }
0029A0  060000     RETURN
53:                
54:                /*************************************
55:                Function: TIM4_Configuration 
56:                Description: 16 
57:                Input:  
58:                Output: 
59:                 *************************************/
60:                void TIM3_Configuration(void) {
61:                    T3CONbits.TON = 1;
0029A2  A8E113     BSET 0x113, #7
62:                    T3CONbits.TSIDL = 1;
0029A4  A8A113     BSET 0x113, #5
63:                    T3CONbits.TCKPS = 0; //1:1
0029A6  2FFCF0     MOV #0xFFCF, W0
0029A8  B62112     AND T3CON
64:                    T3CONbits.TCS = 0; //=1 /2
0029AA  A92112     BCLR T3CON, #1
65:                    T3CONbits.TGATE = 0;
0029AC  A9C112     BCLR T3CON, #6
66:                    //    T3CONbits.T32 = 0; //16
67:                    PR3 = 40000; //4000 1ms    
0029AE  29C400     MOV #0x9C40, W0
0029B0  880870     MOV W0, PR3
68:                    IPC2bits.T3IP = 1; //Setup Timer3 interrupt for desired priority level
0029B2  2FFF80     MOV #0xFFF8, W0
0029B4  B600A8     AND IPC2, WREG
0029B6  A00000     BSET W0, #0
0029B8  880540     MOV W0, IPC2
69:                    //(this example assigns level 1 priority)
70:                    IFS0bits.T3IF = 0; //Clear the Timer3 interrupt status flag
0029BA  A90085     BCLR 0x85, #0
71:                    IEC0bits.T3IE = 1; //Enable Timer3 interrupts
0029BC  A80095     BSET 0x95, #0
72:                    TMR3 = 0;
0029BE  EF210A     CLR TMR3
73:                    T3CONbits.TON = 0; //=0!!!!!!
0029C0  A9E113     BCLR 0x113, #7
74:                }
0029C2  060000     RETURN
75:                
76:                /*************************************
77:                Function: TIM4_Configuration 
78:                Description: 16 
79:                Input:  
80:                Output: 
81:                 *************************************/
82:                void TIM4_Configuration(void) {
83:                    T4CONbits.TON = 1;
0029C4  A8E11F     BSET 0x11F, #7
84:                    T4CONbits.TSIDL = 1;
0029C6  A8A11F     BSET 0x11F, #5
85:                    T4CONbits.TCKPS = 0; //1:1
0029C8  2FFCF0     MOV #0xFFCF, W0
0029CA  B6211E     AND T4CON
86:                    T4CONbits.TCS = 0; //=1 /2
0029CC  A9211E     BCLR T4CON, #1
87:                    T4CONbits.TGATE = 0;
0029CE  A9C11E     BCLR T4CON, #6
88:                    T4CONbits.T32 = 0; //16
0029D0  A9611E     BCLR T4CON, #3
89:                    PR4 = 125; //4000 1ms    
0029D2  2007D0     MOV #0x7D, W0
0029D4  8808D0     MOV W0, PR4
90:                    IPC6bits.T4IP = 3; //Setup Timer3 interrupt for desired priority level
0029D6  28FFF1     MOV #0x8FFF, W1
0029D8  800580     MOV IPC6, W0
0029DA  608080     AND W1, W0, W1
0029DC  230000     MOV #0x3000, W0
0029DE  700001     IOR W0, W1, W0
0029E0  880580     MOV W0, IPC6
91:                    //(this example assigns level 1 priority)
92:                    IFS1bits.T4IF = 0; //Clear the Timer3 interrupt status flag
0029E2  A96087     BCLR 0x87, #3
93:                    IEC1bits.T4IE = 1; //Enable Timer3 interrupts
0029E4  A86097     BSET 0x97, #3
94:                    TMR4 = 0;
0029E6  EF2114     CLR TMR4
95:                    T4CONbits.TON = 0; //=0!!!!!!
0029E8  A9E11F     BCLR 0x11F, #7
96:                }
0029EA  060000     RETURN
97:                
98:                void StartTime3(void) {
99:                    gT3Count = 0;
0029EC  EF2C78     CLR gT3Count
100:                   IEC0bits.T3IE = 1; //Enable Timer3 interrupts
0029EE  A80095     BSET 0x95, #0
101:                   T3CONbits.TON = 1; // 
0029F0  A8E113     BSET 0x113, #7
102:               }
0029F2  060000     RETURN
103:               
104:               void CloseTime3(void) {
105:                   IEC0bits.T3IE = 0; //Enable Timer3 interrupts
0029F4  A90095     BCLR 0x95, #0
106:                   T3CONbits.TON = 0; //
0029F6  A9E113     BCLR 0x113, #7
107:                   gT3Count = 0; //
0029F8  EF2C78     CLR gT3Count
108:                   TMR3 = 0x0000;
0029FA  EF210A     CLR TMR3
109:               }
0029FC  060000     RETURN
110:               
111:               bool T3IsOver(const u16 deadline) {// Tcount
0029FE  780080     MOV W0, W1
112:                   //    ClrWdt();
113:                   return (gT3Count > deadline) ? 1 : 0;
002A00  B3C010     MOV.B #0x1, W0
002A02  8063C2     MOV gT3Count, W2
002A04  510F81     SUB W2, W1, [W15]
002A06  3E0001     BRA GTU, 0x2A0A
002A08  EB4000     CLR.B W0
114:               }
002A0A  060000     RETURN
115:               
116:               void GetUnixTime_Char(u8* timeptr, u8* output) {
002A0C  4787F8     ADD W15, #0x18, W15
002A0E  BE9F88     MOV.D W8, [W15++]
002A10  781F8E     MOV W14, [W15++]
002A12  780481     MOV W1, W9
117:                   u8 cnt;
118:                   time_t times_l;
119:                   struct tm gmt;
120:                   void * ptr;
121:               //
122:               //    gmt.tm_year = HCD(*(timeptr + 1)) + 100; //1900 (u16) (HCD(*timeptr))*100; //2000-1900
123:               //    gmt.tm_mon = HCD(*(timeptr + 2)) - 1; //
124:               //    gmt.tm_mday = HCD(*(timeptr + 3));
125:               //    gmt.tm_hour = HCD(*(timeptr + 4));
126:               //    gmt.tm_min = HCD(*(timeptr + 5));
127:               //    gmt.tm_sec = HCD(*(timeptr + 6));
128:                   gmt.tm_isdst = 0;
002A14  EB0000     CLR W0
002A16  9FBFC0     MOV W0, [W15-8]
129:                   gmt.tm_wday = 0;
002A18  9FBFA0     MOV W0, [W15-12]
130:                   gmt.tm_yday = 0;
002A1A  9FBFB0     MOV W0, [W15-10]
131:               
132:                   times_l = mktime(&gmt); // - 28800; //28000s
002A1C  578478     SUB W15, #0x18, W8
002A1E  780008     MOV W8, W0
002A20  02040E     CALL 0x40E
002A22  000000     NOP
002A24  9FB7A0     MOV W0, [W15-28]
002A26  9FB7B1     MOV W1, [W15-26]
002A28  57877C     SUB W15, #0x1C, W14
133:                   ptr = &times_l;
134:               
135:                   for (cnt = 0; cnt < 4; cnt++)// {
002A2C  570F88     SUB W14, W8, [W15]
002A2E  3AFFFD     BRA NZ, 0x2A2A
136:                       *(output + cnt) = *((u8*) ptr + cnt);
002A2A  785CBE     MOV.B [W14++], [W9++]
137:               }
002A30  78074F     MOV [--W15], W14
002A32  BE044F     MOV.D [--W15], W8
002A34  B1018F     SUB #0x18, W15
002A36  060000     RETURN
138:               
139:               /*************************************
140:               Function: delay_nop 
141:               Description: SPI
142:               Input: 
143:               Output: 
144:                *************************************/
145:               void Delay_Nop(int count) {
146:                   while (count--)
002A38  370002     BRA 0x2A3E
002A3E  E00000     CP0 W0
002A40  3AFFFC     BRA NZ, 0x2A3A
147:                       Nop();
002A3A  000000     NOP
002A3C  E90000     DEC W0, W0
148:               }
002A42  060000     RETURN
149:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/SPI.c  ---------------------------
1:                 //#include <p24FV32KA301.h>
2:                 //#include "type.h"
3:                 #include "SPI.h"
4:                 #include "user.h"
5:                 
6:                 u8 gOffsetAdd = 0; //16
7:                 
8:                 static void SPI_Nop(void) {
00284C  B3C240     MOV.B #0x24, W0
9:                     u8 i; //, j;
10:                    for (i = 0; i < 36; i++)
002852  3AFFFD     BRA NZ, 0x284E
11:                        //        for (j = 0; j < 10; j++)
12:                        Nop();
00284E  000000     NOP
002850  E94000     DEC.B W0, W0
13:                    //    Nop();
14:                }
002854  060000     RETURN
15:                
16:                void SPI2_Configuration(void) {
17:                    SCK2_TRIS = 1;
002856  A8A2C8     BSET TRISB, #5
18:                    SDO2_TRIS = 0; //BF 1(bit7)01(bit5)1 1111
002858  A9C2C8     BCLR TRISB, #6
19:                    SDI2_TRIS = 0;
00285A  A9E2C0     BCLR TRISA, #7
20:                    //    ANSAbits.
21:                    SS2_TRIS = 0;
00285C  A982C9     BCLR 0x2C9, #4
22:                    SS2 = 1;
00285E  A882CD     BSET 0x2CD, #4
23:                    //    ANSBbits.ANSB12 = 1;
24:                    ////        ANSAbits.
25:                    IFS2bits.SPI2IF = 0;
002860  A92088     BCLR IFS2, #1
26:                    //    IEC2bits.SPI2IE = 0;
27:                    //    IPC8bits.SPI2IP = 2;
28:                    //    // SPI Frequency = 1,000,000 Hz; PPRE 1:1; SMP Sample at Middle; MSTEN enabled; MODE16 disabled; DISSCK disabled; SPRE 4:1; CKE Active to Idle; DISSDO disabled; CKP Idle:Low, Active:High; 
29:                    //    SPI2CON1 = 0x0133;
30:                    //    // SPIFPOL disabled; SPIBEN enabled; SPIFE disabled; 
31:                    //    SPI2CON2 = 0x0001;
32:                    //    // SISEL SPI_INT_SPIRBF; SPIEN enabled; SPISIDL disabled; SPIROV disabled; 
33:                    //    SPI2STAT = 0x8004; //800C
34:                    // SPI Frequency = 1,000,000 Hz; PPRE 4:1; SMP Sample at Middle; MSTEN enabled; MODE16 disabled; DISSCK disabled; SPRE 1:1; CKE Active to Idle; DISSDO disabled; CKP Idle:Low, Active:High; 
35:                    SPI2CON1 = 0x013E; //0x0133;
002862  2013E0     MOV #0x13E, W0
002864  881310     MOV W0, SPI2CON1
36:                    // SPIFPOL disabled; SPIBEN enabled; SPIFE disabled; 
37:                    SPI2CON2 = 0x0001; //0001
002866  200010     MOV #0x1, W0
002868  881320     MOV W0, SPI2CON2
38:                    // SISEL SPI_INT_SPIRBF; SPIEN enabled; SPISIDL disabled; SPIROV disabled; 
39:                    SPI2STAT = 0x800C;
00286A  2800C0     MOV #0x800C, W0
00286C  881300     MOV W0, SPI2STAT
40:                }
00286E  060000     RETURN
41:                
42:                void SPI_Write(u8 dat, u8*dat1) {
43:                    //    while (SPI2STATbits.SPITBF == true);
44:                    //    SPI2BUF = *((u8*) dat);
45:                    SPI2BUF = dat;
002870  FB8000     ZE W0, W0
002872  881340     MOV W0, SPI2BUF
46:                    while (SPI2STATbits.SR1MPT);
002874  ABA260     BTST SPI2STAT, #5
002876  3AFFFE     BRA NZ, 0x2874
47:                    //    while (SPI2STATbits.SPIRBF == false);
48:                    *((u8*) dat1) = SPI2BUF;
002878  801340     MOV SPI2BUF, W0
00287A  784880     MOV.B W0, [W1]
49:                }
00287C  060000     RETURN
50:                
51:                void SPI_Read(u8* dat) {
52:                    //    while (SPI2STATbits.SPIRBF == true);
53:                    //    SPI2BUF = 0;
54:                    //    while (SPI2STATbits.SR1MPT == false);
55:                    *(u8*) dat = SPI2BUF;
00287E  801341     MOV SPI2BUF, W1
002880  784801     MOV.B W1, [W0]
56:                    Nop();
002882  000000     NOP
57:                }
002884  060000     RETURN
58:                
59:                /*************************************
60:                Function: FM25L64B_Write 
61:                Description: FM25L64B
62:                Input: 9bit8
63:                Output: 
64:                 *************************************/
65:                void FM25L64B_Write(u16 add, u8* dat, u8 bytes) {
002886  BE9F88     MOV.D W8, [W15++]
002888  780480     MOV W0, W9
00288A  780401     MOV W1, W8
66:                    u8 count = 0;
67:                    u8 addL = (u8) (add & 0x00FF);
68:                    u8 addH = (u8) ((add >> 8) & 0x00FF);
69:                
70:                    SS2 = 0; //CS
00288C  A982CD     BCLR 0x2CD, #4
71:                    SPI_Write(WREN, dat); //0x06
00288E  780088     MOV W8, W1
002890  B3C060     MOV.B #0x6, W0
002892  07FFEE     RCALL SPI_Write
72:                    SS2 = 1; //CS
002894  A882CD     BSET 0x2CD, #4
73:                    SS2 = 0; //CS
002896  A982CD     BCLR 0x2CD, #4
74:                    SPI_Write(READ, dat + 1); //0x02
002898  E80088     INC W8, W1
00289A  B3C030     MOV.B #0x3, W0
00289C  07FFE9     RCALL SPI_Write
75:                    SPI_Write(addH, dat + 2); //0x1F 0x1FF0
00289E  E88088     INC2 W8, W1
0028A0  DE4848     LSR W9, #8, W0
0028A2  07FFE6     RCALL SPI_Write
76:                    SPI_Write(addL, dat + 3); //0xF0
0028A4  4400E3     ADD W8, #0x3, W1
0028A6  784009     MOV.B W9, W0
0028A8  07FFE3     RCALL SPI_Write
77:                    SS2 = 1; //CS
0028AA  A882CD     BSET 0x2CD, #4
78:                    //    SPI_Write(1, dat); //0x06
79:                    //    SPI_Write(2, dat + 1); //0x02
80:                    //    SPI_Write(3, dat + 2); //0x1F 0x1FF0
81:                    //    SPI_Write(4, dat + 3); //0xF0
82:                    //    //    Delay_Nop(1);
83:                    //    //    Delay_Nop(1);//9.22
84:                    //    //    while (count < bytes) {
85:                    //    //        SPI_Write(*(dat + count));
86:                    //    //        //        Delay_Nop(1);
87:                    //    //        count++;
88:                    //    //    }
89:                    //    //    while (SPI2STATbits.SPITBF == true);
90:                    //    SPI_Nop();
91:                    //    SS2 = 1;
92:                    //    Delay_Nop(1);
93:                    //    SS1 = 0;
94:                    //    Delay_Nop(1);
95:                    //    SPI_Write(WRDI);
96:                    //    Delay_Nop(1);
97:                    //    SS1 = 1;
98:                    //    Delay_Nop(1);
99:                }
0028AC  BE044F     MOV.D [--W15], W8
0028AE  060000     RETURN
100:               
101:               /*************************************
102:               Function: FM25L64B_Read 
103:               Description: FM25L64B
104:               Input: 1,
105:               Output: 
106:                *************************************/
107:               //static void FM25L64B_Read(u16 add, u8 *dat, u8 bytes) { 
108:               
109:               void FM25L64B_Read(u16 add, u8 *dat, u8 bytes) {
0028B0  BE9F88     MOV.D W8, [W15++]
0028B2  BE9F8A     MOV.D W10, [W15++]
0028B4  781F8C     MOV W12, [W15++]
0028B6  780600     MOV W0, W12
0028B8  780401     MOV W1, W8
110:                   u8 count = 0;
111:                   u8 addL = (u8) (add & 0x00FF);
112:                   u8 addH = (u8) ((add >> 8) & 0x00FF);
0028CC  DE6048     LSR W12, #8, W0
113:               
114:                   SS2 = 0; //CS
0028BA  A982CD     BCLR 0x2CD, #4
115:               
116:                   SPI_Write(WREN, dat); //0x06
0028BC  780088     MOV W8, W1
0028BE  B3C060     MOV.B #0x6, W0
0028C0  07FFD7     RCALL SPI_Write
117:                   SPI_Write(READ, dat + 1); //0x02
0028C2  E80588     INC W8, W11
0028C4  78008B     MOV W11, W1
0028C6  B3C030     MOV.B #0x3, W0
0028C8  07FFD3     RCALL SPI_Write
118:                   SPI_Write(addH, dat + 2); //0x1F 0x1FF0
0028CA  E88508     INC2 W8, W10
0028CE  78008A     MOV W10, W1
0028D0  07FFCF     RCALL SPI_Write
119:                   SPI_Write(addL, dat + 3); //0xF0
0028D2  4404E3     ADD W8, #0x3, W9
0028D4  780089     MOV W9, W1
0028D6  78400C     MOV.B W12, W0
0028D8  07FFCB     RCALL SPI_Write
120:                   //    SPI_Nop();
121:                   SPI_Write(0, dat); //0x06
0028DA  780088     MOV W8, W1
0028DC  EB4000     CLR.B W0
0028DE  07FFC8     RCALL SPI_Write
122:                   SPI_Write(0, dat + 1); //0x02
0028E0  78008B     MOV W11, W1
0028E2  EB4000     CLR.B W0
0028E4  07FFC5     RCALL SPI_Write
123:                   SPI_Write(0, dat + 2); //0x1F 0x1FF0
0028E6  78008A     MOV W10, W1
0028E8  EB4000     CLR.B W0
0028EA  07FFC2     RCALL SPI_Write
124:                   SPI_Write(0, dat + 3); //0xF0
0028EC  780089     MOV W9, W1
0028EE  EB4000     CLR.B W0
125:                   //    if (IFS2bits.SPI2IF) {
126:                   //        *((u8*) dat) = SPI2BUF;
127:                   //        *((u8*) dat+1) = SPI2BUF;
128:                   //        *((u8*) dat+2) = SPI2BUF;
129:                   //        *((u8*) dat+3) = SPI2BUF;
130:                   //        IFS2bits.SPI2IF = 0;
131:                   //        Nop();
132:                   //    }
133:                   SPI_Nop();
0028F0  07FFBF     RCALL SPI_Write
0028F2  07FFAC     RCALL _SPI_Nop
134:                   //        Delay_Nop(1);
135:                   SS2 = 1;
0028F4  A882CD     BSET 0x2CD, #4
136:               }
0028F6  78064F     MOV [--W15], W12
0028F8  BE054F     MOV.D [--W15], W10
0028FA  BE044F     MOV.D [--W15], W8
0028FC  060000     RETURN
137:               
138:               /*************************************
139:               Function:  FROM_WriteDPNum
140:               Description: 
141:               Input: 
142:               Output: 
143:                *************************************/
144:               void FROM_WriteDPNum(void) {
145:                   //    u8 tmp[2];
146:                   //    tmp[0] = (gOffsetAdd >> 8)&0x00ff;
147:                   //    tmp[1] = gOffsetAdd & 0x00ff;
148:                   FM25L64B_Write(DataPacket_ID, &gOffsetAdd, 1); //
0028FE  B3C012     MOV.B #0x1, W2
002900  20C7C1     MOV #0xC7C, W1
002902  21FFF0     MOV #0x1FFF, W0
002904  07FFC0     RCALL FM25L64B_Write
149:                   gOffsetAdd += 1; //+1  
002906  EC4C7C     INC.B gOffsetAdd, WREG
150:                   gOffsetAdd = gOffsetAdd % DataPacketNum; //252 12*21
002908  FB8000     ZE W0, W0
00290A  200902     MOV #0x90, W2
00290C  090011     REPEAT #0x11
00290E  D88002     DIV.UW W0, W2
002910  20C7C0     MOV #0xC7C, W0
002912  784801     MOV.B W1, [W0]
151:               }
002914  060000     RETURN
152:               
153:               /*************************************
154:               Function:  FROM_EN
155:               Description: 
156:               Input: 
157:               Output: 
158:                *************************************/
159:               void FROM_EN(void) {
002916  FA0002     LNK #0x2
160:                   u8 tmp;
161:                   SPI_Write(WREN, &tmp);
002918  E9808F     DEC2 W15, W1
00291A  B3C060     MOV.B #0x6, W0
00291C  07FFA9     RCALL SPI_Write
162:               }
00291E  FA8000     ULNK
002920  060000     RETURN
163:               
164:               /*************************************
165:               Function:  FROM_WRSR
166:               Description: 
167:               Input: 
168:               Output: 
169:                *************************************/
170:               void FROM_WRSR(void) {
002922  FA0002     LNK #0x2
171:                   u8 tmp;
172:                   SS2 = 0;
002924  A982CD     BCLR 0x2CD, #4
173:                   Delay_Nop(1);
002926  200010     MOV #0x1, W0
002928  022A38     CALL Delay_Nop
00292A  000000     NOP
174:                   SPI_Write(WRSR, &tmp);
00292C  E9808F     DEC2 W15, W1
00292E  B3C010     MOV.B #0x1, W0
002930  07FF9F     RCALL SPI_Write
175:                   Delay_Nop(1);
002932  200010     MOV #0x1, W0
002934  022A38     CALL Delay_Nop
002936  000000     NOP
176:                   SPI_Write(0x00, &tmp);
002938  E9808F     DEC2 W15, W1
00293A  EB4000     CLR.B W0
00293C  07FF99     RCALL SPI_Write
177:                   Delay_Nop(1);
00293E  200010     MOV #0x1, W0
002940  022A38     CALL Delay_Nop
002942  000000     NOP
178:                   SS2 = 1;
002944  A882CD     BSET 0x2CD, #4
179:                   Delay_Nop(1);
002946  200010     MOV #0x1, W0
002948  022A38     CALL Delay_Nop
00294A  000000     NOP
180:               }
00294C  FA8000     ULNK
181:               
182:               //void FROM_Arg_Setting(void) {
183:               //    u8 tmp[4] = {4, 3, 2, 1};
184:               //    FM25L64B_Write(BOR_Pulse, tmp, 4);
185:               //    gPulseCount = ((u32) tmp[0] << 24)+((u32) tmp[1] << 16)+((u16) tmp[2] << 8) + tmp[3];
186:               //    //    FM25L64B_Write(BOR_Vm,&,4);
187:               //}
188:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/RTCC.c  --------------------------
1:                 //#include<p24FV32KA301.h>
2:                 #include"UART.h"
3:                 #include "user.h"
4:                 #include "Common.h"
5:                 
6:                 u16 gRTCCDate[4]; //
7:                 
8:                 /*************************************
9:                 Function: RTC_Configuration 
10:                Description: 
11:                Input: 
12:                Output: 
13:                 *************************************/
14:                void RTC_Configuration(void) {
15:                    //    RTCPWCbits.RTCCLK=1;            //RTCC :RTCC 
16:                    //    RCFGCALbits.RTCOE=0;            // RTCC 
17:                    //    RCFGCALbits.RTCSYNC=0;          //RTCC   
18:                    //    RCFGCALbits.CAL=0;              //RTC 
19:                    u8 rtcc_tmp[7] = {0, 0, 0, 0, 0, 0, 0};
20:                //    Register2Read(rtcc_tmp, Register2Read[mi_year], 7);
21:                    asm volatile ("push w7"); // RTCWREN  1
002B18  781F87     MOV W7, [W15++]
22:                    asm volatile ("push w8");
002B1A  781F88     MOV W8, [W15++]
23:                    asm volatile ("disi #5");
002B1C  FC0005     DISI #0x5
24:                    asm volatile ("mov #0x55, w7");
002B1E  200557     MOV #0x55, W7
25:                    asm volatile ("mov w7, _NVMKEY");
002B20  883B37     MOV W7, NVMKEY
26:                    asm volatile ("mov #0xAA, w8");
002B22  200AA8     MOV #0xAA, W8
27:                    asm volatile ("mov w8, _NVMKEY");
002B24  883B38     MOV W8, NVMKEY
28:                    asm volatile ("bset _RCFGCAL, #13"); //set the RTCWREN bit
002B26  A8A627     BSET 0x627, #5
29:                    asm volatile ("pop w8");
002B28  78044F     MOV [--W15], W8
30:                    asm volatile ("pop w7");
002B2A  7803CF     MOV [--W15], W7
31:                
32:                    RCFGCALbits.RTCPTR = 3; //RTCC 
002B2C  203000     MOV #0x300, W0
002B2E  B72626     IOR RCFGCAL
33:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
002B30  EF2624     CLR RTCVAL
34:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
002B32  EF2624     CLR RTCVAL
35:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
002B34  EF2624     CLR RTCVAL
36:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //  
002B36  EF2624     CLR RTCVAL
37:                
38:                    ALCFGRPTbits.AMASK = 0b0011; //1s// 0010:10s// 0x11
002B38  2C3FF2     MOV #0xC3FF, W2
002B3A  803111     MOV ALCFGRPT, W1
002B3C  610101     AND W2, W1, W2
002B3E  20C001     MOV #0xC00, W1
002B40  708082     IOR W1, W2, W1
002B42  883111     MOV W1, ALCFGRPT
39:                    ALCFGRPTbits.CHIME = 1; //1 =  ARPT<7:0>  00h  FFh
002B44  A8C623     BSET 0x623, #6
40:                    ALCFGRPTbits.ALRMPTR = 3; //
002B46  B72622     IOR ALCFGRPT
41:                    ALRMVAL = 0x0000; //none       
002B48  EF2620     CLR ALRMVAL
42:                    ALRMVAL = 0x0000; //month day 0001
002B4A  EF2620     CLR ALRMVAL
43:                    ALRMVAL = 0x0000; //week hour
002B4C  EF2620     CLR ALRMVAL
44:                    ALRMVAL = 0x0000; //minute second  0000
002B4E  EF2620     CLR ALRMVAL
45:                    //    ALCFGRPTbits.ARPT=0;
46:                    ALCFGRPTbits.ALRMEN = 1; //  ARPT<7:0> = 00  CHIME = 0     
002B50  A8E623     BSET 0x623, #7
47:                
48:                    RTCPWCbits.RTCCLK = 0; //SOSC 1; //RTCC :RTCC 
002B52  2F3FF0     MOV #0xF3FF, W0
002B54  B62628     AND RTCPWC
49:                    RCFGCALbits.RTCOE = 0; // RTCC 
002B56  A94627     BCLR 0x627, #2
50:                    RCFGCALbits.RTCSYNC = 0; //RTCC   
002B58  A98627     BCLR 0x627, #4
51:                    RCFGCALbits.CAL = 0; //RTC 
002B5A  EF6626     CLR.B RCFGCAL
52:                    IPC15bits.RTCIP = 4;
002B5C  2F8FF0     MOV #0xF8FF, W0
002B5E  B600C2     AND IPC15, WREG
002B60  A0A000     BSET W0, #10
002B62  880610     MOV W0, IPC15
53:                    IFS3bits.RTCIF = 0; //
002B64  A9C08B     BCLR 0x8B, #6
54:                    IEC3bits.RTCIE = 1; // =1
002B66  A8C09B     BSET 0x9B, #6
55:                
56:                    RCFGCALbits.RTCEN = 1; // RTCC 
002B68  A8E627     BSET 0x627, #7
57:                }
002B6A  060000     RETURN
58:                
59:                /*************************************
60:                Function: RTC_ReadTime 
61:                Description: 
62:                Input: 4u16 
63:                Output: 
64:                 *************************************/
65:                void RTCReadTime(u8* dat) {
002B6C  780300     MOV W0, W6
66:                    u16 tmp[4];
67:                
68:                    while (1) {
69:                        if (RCFGCALbits.RTCSYNC)//
002B6E  AB8627     BTST 0x627, #4
002B70  3AFFFE     BRA NZ, 0x2B6E
70:                            continue;
71:                //        __builtin_write_RTCWEN(); //
72:                        RCFGCALbits.RTCPTR = 3; //RTCC 
002B72  203000     MOV #0x300, W0
002B74  B72626     IOR RCFGCAL
73:                        tmp[0] = RTCVAL; // 17 or 23   [17] 0000 0000 0001 0001
002B76  803124     MOV RTCVAL, W4
74:                        RCFGCALbits.RTCPTR = 2;
002B78  2FCFF1     MOV #0xFCFF, W1
002B7A  803130     MOV RCFGCAL, W0
002B7C  608100     AND W1, W0, W2
002B7E  A09002     BSET W2, #9
002B80  883132     MOV W2, RCFGCAL
75:                        tmp[1] = RTCVAL; //[20a]
002B82  803123     MOV RTCVAL, W3
76:                        RCFGCALbits.RTCPTR = 1;
002B84  803130     MOV RCFGCAL, W0
002B86  608100     AND W1, W0, W2
002B88  A08002     BSET W2, #8
002B8A  883132     MOV W2, RCFGCAL
77:                        tmp[2] = RTCVAL; //[1]
002B8C  803122     MOV RTCVAL, W2
78:                        RCFGCALbits.RTCPTR = 0;
002B8E  206260     MOV #0x626, W0
002B90  608810     AND W1, [W0], [W0]
79:                        tmp[3] = RTCVAL; // [1D03]
002B92  803121     MOV RTCVAL, W1
80:                //        RCFGCALbits.RTCWREN = 0; //
81:                        *(dat) = 0x20;
002B94  B3C205     MOV.B #0x20, W5
002B96  784B05     MOV.B W5, [W6]
82:                        *(dat + 1) = (u8) (tmp[0] & 0X00FF); //   8    2016.6.1. 3 13:10:10
002B98  984314     MOV.B W4, [W6+1]
83:                        *(dat + 2) = (u8) (tmp[1] >> 8);
002B9A  DE1A48     LSR W3, #8, W4
002B9C  984324     MOV.B W4, [W6+2]
84:                        *(dat + 3) = (u8) (tmp[1] & 0X00FF); // 
002B9E  984333     MOV.B W3, [W6+3]
85:                        *(dat + 4) = (u8) (tmp[2] & 0x00FF); //     
002BA0  984342     MOV.B W2, [W6+4]
86:                        *(dat + 5) = (u8) (tmp[3] >> 8);
002BA2  DE0948     LSR W1, #8, W2
002BA4  984352     MOV.B W2, [W6+5]
87:                        *(dat + 6) = (u8) (tmp[3] & 0x00FF); //  
002BA6  984361     MOV.B W1, [W6+6]
88:                        break;
89:                    }
90:                }
002BA8  060000     RETURN
91:                
92:                /*************************************
93:                Function: Check_RTCC 
94:                Description:  RTCC
95:                Input: 6u8
96:                Output: 
97:                 *************************************/
98:                void CheckRTCC(void) {
99:                    //    IEC3bits.RTCIE = 0; // 
100:                   //    RCFGCALbits.RTCEN = 0; // RTCC 
101:               
102:                   u8 rtcc_tmp[7] = {0, 0, 0, 0, 0, 0, 0};
103:               //    Register2Read(rtcc_tmp, mi_arg_add[mi_year], 7); //0x14 0x11
104:                   //    rtcc_tmp[0] = DCH(rtcc_tmp[0]); //20->0x20
105:                   //    rtcc_tmp[1] = DCH(rtcc_tmp[1]);
106:                   //    rtcc_tmp[2] = DCH(rtcc_tmp[2]);
107:                   //    rtcc_tmp[3] = DCH(rtcc_tmp[3]);
108:                   //    rtcc_tmp[4] = DCH(rtcc_tmp[4]);
109:                   //    rtcc_tmp[5] = DCH(rtcc_tmp[5]);
110:                   //    rtcc_tmp[6] = DCH(rtcc_tmp[6]);
111:                   //    Nop();
112:                   asm volatile ("push w7"); // RTCWREN  1
002BAA  781F87     MOV W7, [W15++]
113:                   asm volatile ("push w8");
002BAC  781F88     MOV W8, [W15++]
114:                   asm volatile ("disi #5");
002BAE  FC0005     DISI #0x5
115:                   asm volatile ("mov #0x55, w7");
002BB0  200557     MOV #0x55, W7
116:                   asm volatile ("mov w7, _NVMKEY");
002BB2  883B37     MOV W7, NVMKEY
117:                   asm volatile ("mov #0xAA, w8");
002BB4  200AA8     MOV #0xAA, W8
118:                   asm volatile ("mov w8, _NVMKEY");
002BB6  883B38     MOV W8, NVMKEY
119:                   asm volatile ("bset _RCFGCAL, #13"); //set the RTCWREN bit
002BB8  A8A627     BSET 0x627, #5
120:                   asm volatile ("pop w8");
002BBA  78044F     MOV [--W15], W8
121:                   asm volatile ("pop w7");
002BBC  7803CF     MOV [--W15], W7
122:               
123:                   RCFGCALbits.RTCPTR = 3; //RTCC 
002BBE  203000     MOV #0x300, W0
002BC0  B72626     IOR RCFGCAL
124:                   RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
002BC2  EF2624     CLR RTCVAL
125:                   RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
002BC4  EF2624     CLR RTCVAL
126:                   RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
002BC6  EF2624     CLR RTCVAL
127:                   RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //  
002BC8  EF2624     CLR RTCVAL
128:               //    RCFGCALbits.RTCWREN = 0;//
129:                   //    Nop();
130:                   //    IEC3bits.RTCIE = 1; //
131:                   //    RCFGCALbits.RTCEN = 1; //RTCC
132:                   //    Nop();
133:               }
002BCA  060000     RETURN
134:               
135:               /*************************************
136:               Function: StartRTCC 
137:               Description: 
138:               Input: 
139:               Output: 
140:                *************************************/
141:               void StartRTCC(void) {
142:               
143:                   IEC3bits.RTCIE = 1; //
002BCC  A8C09B     BSET 0x9B, #6
144:                   ALCFGRPTbits.ALRMEN = 1;
002BCE  A8E623     BSET 0x623, #7
145:                   RCFGCALbits.RTCEN = 1; //RTCC
002BD0  A8E627     BSET 0x627, #7
146:               }
002BD2  060000     RETURN
147:               
148:               /*************************************
149:               Function: StopRTCC 
150:               Description: 
151:               Input: 
152:               Output: 
153:                *************************************/
154:               void StopRTCC(void) {
155:                   IEC3bits.RTCIE = 0; // 
002BD4  A9C09B     BCLR 0x9B, #6
156:                   ALCFGRPTbits.ALRMEN = 0;
002BD6  A9E623     BCLR 0x623, #7
157:                   RCFGCALbits.RTCEN = 0; // RTCC 
002BD8  A9E627     BCLR 0x627, #7
158:               }
002BDA  060000     RETURN
159:               
160:               /*************************************
161:               Function: OutputData 
162:               Description: 24*u16
163:               Input: 4u16 
164:               Output: 
165:                *************************************/
166:               //void OutputData(u16* dat)
167:               //{
168:               //    u8 count=0;
169:               //    *dat|=0x2000;        
170:               //    while(count<4)
171:               //    {
172:               //        UART2Send(RTC_NumProcess(dat+count,12));
173:               //        UART2Send(RTC_NumProcess(dat+count,8));
174:               //        UART2Send(RTC_NumProcess(dat+count,4));
175:               //        UART2Send(RTC_NumProcess(dat+count,0));
176:               //        UART2Send(' ');
177:               //        count++;
178:               //    }
179:               //    UART2Send('\n');
180:               //}
181:               /*************************************
182:               Function: RTC_NumProcess 
183:               Description: ASC
184:               Input: 4u16 
185:               Output: ASCII
186:                *************************************/
187:               //static u8 RTCNumProcess(u16*d,u8 s)
188:               //{
189:               //    return (u8)(((*d>>s)&0x000f)+0x30);
190:               //}
191:               
192:               
193:               
194:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/RS485.c  -------------------------
1:                 //#include"p24FV32KA301.h"
2:                 #include"UART.h"
3:                 //#include"user.h"
4:                 #include"25L64B.h"
5:                 
6:                 /*************************************
7:                 Function: RS485_Init 
8:                 Description: 485
9:                 Input:  
10:                Output: 
11:                 *************************************/
12:                void RS485_Init(void) {
13:                    MC_CON_OUT; //
002CF6  A962C8     BCLR TRISB, #3
14:                    RS485_TX_OUT;
002CF8  A9E2C8     BCLR TRISB, #7
15:                    RS485_RX_IN;
002CFA  A842C8     BSET TRISB, #2
16:                
17:                    ANSBbits.ANSB2 = 0; //
002CFC  A944E2     BCLR ANSB, #2
18:                
19:                    U1MODEbits.BRGH = 0;
002CFE  A96220     BCLR U1MODE, #3
20:                    U1BRG = BRGVAL;
002D00  200190     MOV #0x19, W0
002D02  881140     MOV W0, U1BRG
21:                
22:                    U1MODEbits.USIDL = 1;
002D04  A8A221     BSET 0x221, #5
23:                    U1MODEbits.UEN = 0;
002D06  2FCFF0     MOV #0xFCFF, W0
002D08  B62220     AND U1MODE
24:                    U1MODEbits.UARTEN = 1;
002D0A  A8E221     BSET 0x221, #7
25:                    IFS0bits.U1RXIF = 0; // Clear the Recieve Interrupt Flag
002D0C  A96085     BCLR 0x85, #3
26:                    U1STAbits.UTXEN = 1;
002D0E  A84223     BSET 0x223, #2
27:                
28:                    IPC2bits.U1RXIP = 6;
002D10  28FFF1     MOV #0x8FFF, W1
002D12  800540     MOV IPC2, W0
002D14  608080     AND W1, W0, W1
002D16  260000     MOV #0x6000, W0
002D18  700001     IOR W0, W1, W0
002D1A  880540     MOV W0, IPC2
29:                    IPC16bits.U1ERIP=7;
002D1C  200700     MOV #0x70, W0
002D1E  B720C4     IOR IPC16
30:                    U1STAbits.URXISEL = 0;
002D20  2FF3F0     MOV #0xFF3F, W0
002D22  B62222     AND U1STA
31:                    IEC0bits.U1RXIE = 1; //
002D24  A86095     BSET 0x95, #3
32:                }
002D26  060000     RETURN
33:                
34:                //void OpenAwake485(void) {//CN6
35:                //    RS485_RX_IN;
36:                //    CNEN1bits.CN6IE = 1; //RX1
37:                //}
38:                
39:                //void CloseAwake485(void) {
40:                //    CNEN1bits.CN6IE = 0;
41:                //}
42:                
43:                /*************************************
44:                Function: RS485_Send  
45:                Description: 485
46:                Input:  
47:                Output: 1:
48:                 *************************************/
49:                void RS485Send(const u8 dat) {
50:                    RS485_CON = 1; //
002D28  A862CC     BSET LATB, #3
51:                    U1TXREG = dat;
002D2A  FB8000     ZE W0, W0
002D2C  881120     MOV W0, U1TXREG
52:                    while (!U1STAbits.TRMT);
002D2E  AB0223     BTST 0x223, #0
002D30  32FFFE     BRA Z, 0x2D2E
53:                    Delay_Nop(20);
002D32  200140     MOV #0x14, W0
002D34  022A38     CALL Delay_Nop
002D36  000000     NOP
54:                    RS485_CON = 0; //
002D38  A962CC     BCLR LATB, #3
55:                    Delay_Nop(20);
002D3A  200140     MOV #0x14, W0
002D3C  042A38     GOTO Delay_Nop
002D3E  000000     NOP
56:                }
57:                
58:                /*************************************
59:                Function: RS485_SendString 
60:                Description: 485
61:                Input:   
62:                Output: 
63:                 *************************************/
64:                void RS485SendString(const u8* dat, u8 bytes) {
65:                    u8 count = 0;
66:                
67:                    RS485_CON = 1; //
002D40  A862CC     BSET LATB, #3
68:                    while (count < bytes) {
002D42  780100     MOV W0, W2
002D44  370004     BRA 0x2D4E
002D4E  514180     SUB.B W2, W0, W3
002D50  51CF81     SUB.B W3, W1, [W15]
002D52  39FFF9     BRA NC, 0x2D46
69:                        U1TXREG = *(dat + count);
002D46  FB81B2     ZE [W2++], W3
002D48  881123     MOV W3, U1TXREG
70:                        while (U1STAbits.UTXBF);
002D4A  AB2223     BTST 0x223, #1
002D4C  3AFFFE     BRA NZ, 0x2D4A
71:                        //        if(count==bytes-1)
72:                        //            Delay100ms(1);                 //
73:                        count++;
74:                    }
75:                    count = 0;
76:                    //    if(count>30)
77:                    while (!U1STAbits.TRMT);
002D54  AB0223     BTST 0x223, #0
002D56  32FFFE     BRA Z, 0x2D54
78:                    RS485_CON = 0; //
002D58  A962CC     BCLR LATB, #3
79:                    Delay_Nop(20);
002D5A  200140     MOV #0x14, W0
002D5C  042A38     GOTO Delay_Nop
002D5E  000000     NOP
80:                }
81:                
82:                //void OpenRS485(void) {
83:                //    IEC0bits.U1RXIE = 1;
84:                //    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled ??????????
85:                //}
86:                
87:                //void CloseRS485(void) {
88:                //    IEC0bits.U1RXIE = 0;
89:                //    U1STAbits.UTXEN = 0; //UARTx transmitter is enabled ??????????
90:                //}
91:                /*************************************
92:                Function: RS485_test 
93:                Description: 485
94:                Input:  
95:                Output: 
96:                 *************************************/
97:                //void RS485test(void)
98:                //{
99:                //    u8 dat='6';
100:               
101:               //RS485Send('T');
102:               //    if(!RS485Receive(&dat))
103:               //    {
104:               //        RS485Send(dat);
105:               //        RS485Send('T');
106:               //    }
107:               //}
108:               
109:               /*************************************
110:               Function: RS485_Receive  
111:               Description: 485
112:               Input:  
113:               Output: 1
114:                ************************************
115:               bool RS485Receive(u8* dat) {
116:               
117:                   bool b = true;
118:               //    u8 timeCount;
119:                   
120:               //    RS485_CON = 0; //
121:               
122:                   if (U1STAbits.OERR)
123:                       U1STAbits.OERR = 0;
124:                   
125:               //    gT23Count=0;
126:               //    T2CONbits.TON = 1;// 
127:                  
128:                   while (!U1STAbits.URXDA) //
129:                   {
130:               //        timeCount = gT23Count;
131:               //        if( T100msIsOver(timeCount,10) ) {//1s
132:               //            b = false;
133:               //            break;
134:               //        }
135:                   }
136:               //    T2CONbits.TON = 0;//
137:               //    gT23Count=0;           //
138:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
139:               //    TMR2 = 0x0000;
140:                   
141:               //    if(b)
142:               //        *dat = U1RXREG;
143:               
144:                   return b;
145:               }*/
146:               
147:               
148:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/NVIC.c  --------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 201666, 8:48
6:                  */
7:                 #include "user.h"
8:                 #include "UART.h"
9:                 #include "SerialBuffer.h"
10:                #include "RS485.h"
11:                #include "25L64B.h"
12:                
13:                struct FLag_Arg FLagArgbits;
14:                struct TimeCount gTimeCount;
15:                extern u8 gAlarmZeroLock; //
16:                //u8 gLastPulseSta = 0; //
17:                //u32 gLastTCount = 0; //T1
18:                u8 gGPRS_Fail_Count = 0; //GPRS
19:                //u8 gTM2CNT = 0;
20:                
21:                /*************************************
22:                Function:  
23:                Description: 
24:                Input:  
25:                Output: 
26:                 *************************************/
27:                void __attribute__((__interrupt__, __auto_psv__)) _RTCCInterrupt(void) {
0002DC  F80034     PUSH PSVPAG
0002DE  781F88     MOV W8, [W15++]
0002E0  200008     MOV #0x0, W8
0002E2  8801A8     MOV W8, PSVPAG
0002E4  78044F     MOV [--W15], W8
28:                    //    gTimeCount.timeAlarm++; //
29:                //    gTimeCount.timeGprs++;
30:                //    gTimeCount.timeMp++;
31:                //    //    gTimeCount.timeCheckTime++;
32:                //
33:                //    //    u8 tmp[6] = {0, 0, 0, 0, 0, 0};
34:                //    //    Register2Read(tmp, mi_arg_add[mi_tmp], 6);
35:                //    /*
36:                //    if (gTimeCount.timeMp >= ((tmp[0] << 8) + tmp[1]) - 1) {//1
37:                //        FLagArgbits.T1CountFlag = 1;
38:                //        T1CONbits.TON = 1;
39:                //    }
40:                //     */
41:                //    if (gTimeCount.timeMp >= 5) {// ((tmp[0] << 8) + tmp[1])) {//FRAM
42:                //        gTimeCount.timeMp = 0;
43:                //        //        FLagArgbits.T1CountFlag = 0;
44:                //        //        T1CONbits.TON = 0; //1
45:                //        IFS1bits.T4IF = 1; //T4CONbits.TON = 1;
46:                //    }
47:                //
48:                //    if (gTimeCount.timeGprs >= 5) {// ((tmp[2] << 8) + tmp[3])) {//GPRS
49:                //        gTimeCount.timeGprs = 0; //5
50:                //        FLagArgbits.tgprsFlag = 1;
51:                //    }
52:                //    /*
53:                //        //    FLagArgbits.LowPowerFlag = !BAT_DEC; //
54:                //        if (gTimeCount.timeAlarm >= ((tmp[4] << 8) + tmp[5])) {
55:                //            gTimeCount.timeAlarm = 0;
56:                //            if (!BAT_DEC && !FLagArgbits.tgprsFlag) {//3.0V
57:                //                FLagArgbits.talarmFlag = 1; //1
58:                //            }
59:                //        }*/
60:                //    //    if (gTimeCount.timeCheckTime >= 86400) {
61:                //    //        gTimeCount.timeCheckTime = 0;
62:                //    //        FLagArgbits.CheckRTCCFlag = 1;
63:                //    //}
64:                //    //    if (gGPRS_Fail_Count > 0) {
65:                //    //        FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
66:                //    //        RTCReadTime(tmp); //
67:                //    //        FM25L64B_Write(RST_Time, tmp, 7);
68:                //    //        Reset();
69:                //    //    }
70:                //    if (FLagArgbits.tgprsFlag || FLagArgbits.talarmFlag)// || FLagArgbits.CheckRTCCFlag)
71:                //        FLagArgbits.SleepExitFlag = 1;
72:                //    else
73:                //        FLagArgbits.SleepExitFlag = 0;
74:                    IFS3bits.RTCIF = 0; //clear RTC      
0002E6  A9C08B     BCLR 0x8B, #6
75:                }
0002E8  F90034     POP PSVPAG
0002EA  064000     RETFIE
76:                
77:                /*************************************
78:                Function:  
79:                Description: 
80:                Input:  
81:                Output: 
82:                 *************************************/
83:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
0002EC  F80034     PUSH PSVPAG
0002EE  781F88     MOV W8, [W15++]
0002F0  200008     MOV #0x0, W8
0002F2  8801A8     MOV W8, PSVPAG
0002F4  78044F     MOV [--W15], W8
84:                
85:                //    gT3Count++;
86:                    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
0002F6  A90085     BCLR 0x85, #0
87:                }
0002F8  F90034     POP PSVPAG
0002FA  064000     RETFIE
88:                
89:                /*************************************
90:                Function:  
91:                Description: 
92:                Input:  
93:                Output: 
94:                 *************************************/
95:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
96:                //    //    gTM2CNT++;
97:                //
98:                ////    while (!U1STAbits.RIDLE);
99:                ////    PC_Cop();
100:               ////    T2CONbits.TON = 0;
101:               ////    TMR2 = 0;
102:               ////    FLagArgbits.TestFlag = 0; //
103:               ////    //    FLagArgbits.SleepExitFlag = 0;//
104:               //    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
105:               //}
106:               
107:               /*************************************
108:               Function:  
109:               Description: 
110:               Input:  
111:               Output: 
112:                *************************************/
113:               void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
0002FC  F80034     PUSH PSVPAG
0002FE  781F88     MOV W8, [W15++]
000300  200008     MOV #0x0, W8
000302  8801A8     MOV W8, PSVPAG
000304  78044F     MOV [--W15], W8
114:               
115:               //    gT1Count++;
116:                   IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
000306  A96084     BCLR IFS0, #3
117:               }
000308  F90034     POP PSVPAG
00030A  064000     RETFIE
118:               
119:               /*************************************
120:               Function: t4 
121:               Description: 
122:               Input:  
123:               Output: 
124:                *************************************/
125:               void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
00030C  F80034     PUSH PSVPAG
00030E  781F88     MOV W8, [W15++]
000310  200008     MOV #0x0, W8
000312  8801A8     MOV W8, PSVPAG
000314  78044F     MOV [--W15], W8
126:               //    if (FLagArgbits.AlarmDataFlag) {
127:               //        FLagArgbits.AlarmDataFlag = 0;
128:               //        GetAlarmValue(); //
129:               //    } else
130:               //        GetValueTask(); //
131:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
132:               
133:                   IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
000316  A96087     BCLR 0x87, #3
134:               }
000318  F90034     POP PSVPAG
00031A  064000     RETFIE
135:               
136:               /*************************************
137:               Function:  
138:               Description: 
139:               Input:  
140:               Output: 
141:                *************************************/
142:               void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //
00031C  F80034     PUSH PSVPAG
00031E  781F88     MOV W8, [W15++]
000320  200008     MOV #0x0, W8
000322  8801A8     MOV W8, PSVPAG
000324  78044F     MOV [--W15], W8
143:               //    if (S1) {
144:               //        gPulseTOffset += TMR1;
145:               //        TMR1 = 0;
146:               //        T1CONbits.TON = 1; //1,+1
147:               //        while (TMR1 < 13107); //400ms13107/2^15*1000msS1       
148:               //        if (S1) {
149:               //            gPulseCount++;
150:               //            T1CONbits.TON = FLagArgbits.T1CountFlag; //
151:               //            if (FLagArgbits.T1CountLastFlag) {//T1
152:               //                gNowCapture = gT1Count * 1000 + (((u32) TMR1 + gPulseTOffset) * 1000 >> 15); //ms
153:               //
154:               //                if (gNowCapture < 2000)//2s
155:               //                    gNowCapture = 0;
156:               //            }
157:               //            TMR1 = 0;
158:               //            gPulseTOffset = 0;
159:               //            gT1Count = 0;
160:               //            FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag;
161:               //        }
162:               //    }
163:                   IFS1bits.CNIF = 0;
000326  A96086     BCLR IFS1, #3
164:               }
000328  F90034     POP PSVPAG
00032A  064000     RETFIE
165:               
166:               /*************************************
167:               Function: UART1
168:               Description: 
169:               Input:  
170:               Output: 
171:                *************************************/
172:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
00032C  F80034     PUSH PSVPAG
00032E  781F88     MOV W8, [W15++]
000330  200008     MOV #0x0, W8
000332  8801A8     MOV W8, PSVPAG
000334  78044F     MOV [--W15], W8
173:               //    u8 cnt = 0;
174:               //    for (cnt = 0; cnt < 4; cnt++)
175:               //        if (U1STAbits.URXDA == 1) //
176:               //        {
177:               //
178:               //            BufferWrite_UART1();
179:               //        }
180:               //    FLagArgbits.TestFlag = 1;
181:               //    //    FLagArgbits.SleepExitFlag = 1;
182:               //    T2CONbits.TON = 1; //2
183:                   //    IEC0bits.T2IE = 1;T2CONbits.TON = 1;
184:                   IFS0bits.U1RXIF = 0;
000336  A96085     BCLR 0x85, #3
185:               }
000338  F90034     POP PSVPAG
00033A  064000     RETFIE
186:               
187:               /*************************************
188:               Function: UART2
189:               Description: 
190:               Input:  
191:               Output: 
192:                *************************************/
193:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
00033C  F80034     PUSH PSVPAG
00033E  781F88     MOV W8, [W15++]
000340  200008     MOV #0x0, W8
000342  8801A8     MOV W8, PSVPAG
000344  78044F     MOV [--W15], W8
194:               //    u8 cnt = 0;
195:               //    for (cnt = 0; cnt < 4; cnt++)
196:               //        if (U2STAbits.URXDA == 1) //
197:               //        {
198:               //            BufferWrite_UART2();
199:               //        }
200:                   IFS1bits.U2RXIF = 0;
000346  A9C087     BCLR 0x87, #6
201:               }
000348  F90034     POP PSVPAG
00034A  064000     RETFIE
202:               
203:               void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
204:               //    u8 cnt = 0;
205:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
206:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //
207:               //
208:               //        while (!U2STAbits.TRMT);
209:               //        cnt++;
210:               //    }
211:                   IFS1bits.U2TXIF = 0;
00034C  A9E087     BCLR 0x87, #7
212:               }
00034E  064000     RETFIE
213:               
214:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
215:                   if (U1STAbits.OERR == 1) {
000350  AB2222     BTST U1STA, #1
000352  320001     BRA Z, 0x356
216:               
217:                       U1STAbits.OERR = 0;
000354  A92222     BCLR U1STA, #1
218:                   }
219:                   IFS4bits.U1ERIF = 0;
000356  A9208C     BCLR IFS4, #1
220:               }
000358  064000     RETFIE
221:               
222:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
223:                   if (U2STAbits.OERR == 1) {
00035A  AB2232     BTST U2STA, #1
00035C  320001     BRA Z, 0x360
224:               
225:                       U2STAbits.OERR = 0;
00035E  A92232     BCLR U2STA, #1
226:                   }
227:                   IFS4bits.U2ERIF = 0;
000360  A9408C     BCLR IFS4, #2
228:               }
000362  064000     RETFIE
229:               
230:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
231:                   u8 tmp[7] = {0, 0, 0, 0, 0, 0, 0};
232:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
233:               //    //    Register2Read(tmp, mi_arg_add[4], 6);
234:               //    RTCReadTime(tmp); //
235:               //    FM25L64B_Write(RST_Data, (u8*) & RCON, 2); //
236:               //    FM25L64B_Write(RST_Data + 2, (u8*) & IFS0, 2); //
237:               //    FM25L64B_Write(RST_Data + 4, (u8*) & IFS1, 2); //
238:               //    FM25L64B_Write(RST_Data + 6, (u8*) & IFS2, 2); //
239:               //    FM25L64B_Write(RST_Data + 8, (u8*) & IFS3, 2); //
240:               //    FM25L64B_Write(RST_Data + 10, (u8*) & IFS4, 2); //
241:               //    FM25L64B_Write(RST_Data + 12, (u8*) & IFS5, 2); //
242:               //    FM25L64B_Write(RST_Data + 14, (u8*) & IPC0, 2); //
243:               //    FM25L64B_Write(RST_Data + 16, (u8*) & IPC1, 2); //
244:               //    FM25L64B_Write(RST_Data + 18, (u8*) & IPC2, 2); //
245:               //    FM25L64B_Write(RST_Data + 20, (u8*) & IPC3, 2); //
246:               //    FM25L64B_Write(RST_Data + 22, (u8*) & IPC4, 2); //
247:               //    FM25L64B_Write(RST_Data + 24, (u8*) & IPC5, 2); //
248:               //    FM25L64B_Write(RST_Data + 26, (u8*) & IPC6, 2); //
249:               //    FM25L64B_Write(RST_Data + 28, (u8*) & IPC7, 2); //
250:               //    FM25L64B_Write(RST_Data + 30, (u8*) & IPC8, 2); //
251:               //    FM25L64B_Write(RST_Data + 32, (u8*) & IPC9, 2); //
252:               //    FM25L64B_Write(RST_Data + 34, (u8*) & IPC12, 2); //
253:               //    FM25L64B_Write(RST_Data + 36, (u8*) & IPC15, 2); //
254:               //    FM25L64B_Write(RST_Data + 38, (u8*) & IPC16, 2); //
255:               //    FM25L64B_Write(RST_Data + 40, (u8*) & IEC0, 2); //
256:               //    FM25L64B_Write(RST_Data + 42, (u8*) & IEC1, 2); //
257:               //    FM25L64B_Write(RST_Data + 44, (u8*) & IEC2, 2); //
258:               //    FM25L64B_Write(RST_Data + 46, (u8*) & IEC3, 2); //
259:               //    FM25L64B_Write(RST_Data + 48, (u8*) & IEC4, 2); //
260:               //    FM25L64B_Write(RST_Data + 50, (u8*) & IEC5, 2); //
261:                   //    FM25L64B_Write(RST_Data+14, tmp, 2); //
262:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
000364  AB4080     BTST INTCON1, #2
000366  320001     BRA Z, 0x36A
000368  A94080     BCLR INTCON1, #2
263:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
00036A  AB6080     BTST INTCON1, #3
00036C  320001     BRA Z, 0x370
00036E  A96080     BCLR INTCON1, #3
264:               
265:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
000370  AB8080     BTST INTCON1, #4
000372  320001     BRA Z, 0x376
000374  A98080     BCLR INTCON1, #4
266:                   Reset();
000376  FE0000     RESET
267:               }
000378  064000     RETFIE
268:               
269:               void __attribute__((interrupt, no_auto_psv)) _INT1Interrupt(void) {
270:               //    u8 tmp[7] = {0, 0, 0, 0, 0, 0, 0};
271:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
272:               //    //    Register2Read(tmp, mi_arg_add[4], 6);
273:               //    RTCReadTime(tmp); //
274:               //    FM25L64B_Write(RST_Time, tmp, 7); //
275:                   //    Statusbits.staBat = 1; // Vdd=1 Vbat=1  Vdd=0 Vbat=0 
276:                   //***User Area End->code: INT1 - External Interrupt 1***
277:                   IFS1bits.INT1IF = 0;
00037A  A98086     BCLR IFS1, #4
278:               }
00037C  064000     RETFIE
279:               //
280:               //void __attribute__((interrupt, no_auto_psv)) _StackError(void) {
281:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
282:               //    INTCON1bits.STKERR = 0;
283:               //}
284:               //
285:               //void __attribute__((interrupt, no_auto_psv)) _MathError(void) {
286:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
287:               //    INTCON1bits.MATHERR = 0;
288:               //}
289:               ////
290:               //
291:               //void __attribute__((interrupt, no_auto_psv)) _AddressError(void) {
292:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
293:               //    INTCON1bits.ADDRERR = 0; //
294:               //}
295:               
296:               
297:               
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/INT.c  ---------------------------
1:                 /* 
2:                  * File:   INT.c
3:                  * Author: ASUS
4:                  *
5:                  * Created on 20161223, 3:18
6:                  */
7:                 //#include "user.h"
8:                 #include "xc.h"
9:                 
10:                void INT_Configuration(void) {
11:                    ANSBbits.ANSB14 = 0; //
002E18  A9C4E3     BCLR 0x4E3, #6
12:                    TRISBbits.TRISB14 = 1; //
002E1A  A8C2C9     BSET 0x2C9, #6
13:                    IFS1bits.INT1IF = 0;
002E1C  A98086     BCLR IFS1, #4
14:                    IFS0bits.INT0IF = 0;
002E1E  A90084     BCLR IFS0, #0
15:                    INTCON2bits.INT1EP = 1; //
002E20  A82082     BSET INTCON2, #1
16:                    IPC5bits.INT1IP = 6;
002E22  2FFF80     MOV #0xFFF8, W0
002E24  B600AE     AND IPC5, WREG
002E26  B30060     IOR #0x6, W0
002E28  880570     MOV W0, IPC5
17:                    IEC1bits.INT1IE = 1; //
002E2A  A88096     BSET IEC1, #4
18:                }
002E2C  060000     RETURN
19:                
20:                
21:                
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/ICN.c  ---------------------------
1:                 //#include <p24FV32KA301.h>
2:                 //#include "user.h"
3:                 #include "xc.h"
4:                 
5:                 void ICN_Configuration(void) {
6:                     //    INPUT_PULSE_IN;
7:                     TRISBbits.TRISB9 = 1;
002E02  A822C9     BSET 0x2C9, #1
8:                     //    CNPU2bits.CN22PUE = 1; //S2
9:                     //    CNPD2bits.CN22PDE = 1; //S2
10:                    IPC4bits.CNIP = 5;
002E04  28FFF1     MOV #0x8FFF, W1
002E06  800560     MOV IPC4, W0
002E08  608080     AND W1, W0, W1
002E0A  250000     MOV #0x5000, W0
002E0C  700001     IOR W0, W1, W0
002E0E  880560     MOV W0, IPC4
11:                    IFS1bits.CNIF = 0;
002E10  A96086     BCLR IFS1, #3
12:                    IEC1bits.CNIE = 1; //    
002E12  A86096     BSET IEC1, #3
13:                    CNEN2bits.CN21IE = 1; //S1
002E14  A8A064     BSET CNEN2, #5
14:                    //    CNEN2bits.CN22IE = 1; //S2
15:                    //    CNEN1bits.CN6IE=1;//RX1
16:                }
002E16  060000     RETURN
17:                
18:                
19:                
20:                
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/IC.c  ----------------------------
1:                 #include "XC.h"
2:                 //#include "type.h"
3:                 //#include "user.h"
4:                 
5:                 //vu32 gPulseCount = 0;
6:                 
7:                 void IC_Configuration(void) {
8:                     //    IC2CON1bits.ICBNE = 0;
9:                     IC2CON2bits.SYNCSEL = 0b00000; //10100 =  2 
002DAE  2FFE00     MOV #0xFFE0, W0
002DB0  B6214A     AND IC2CON2
10:                    IC2CON1bits.ICSIDL = 0; //0 =  CPU 
002DB2  A9A149     BCLR 0x149, #5
11:                    IC2CON1bits.IC2TSEL = 0b100; //100 = TIMER1    9.26 111
002DB4  2E3FF0     MOV #0xE3FF, W0
002DB6  B60148     AND IC2CON1, WREG
002DB8  A0C000     BSET W0, #12
002DBA  880A40     MOV W0, IC2CON1
12:                    IC2CON1bits.ICI = 0; //
002DBC  2FF9F0     MOV #0xFF9F, W0
002DBE  B62148     AND IC2CON1
13:                    IC2CON2bits.ICTRIG = 0; // ICx  SYNCSELx 
002DC0  A9E14A     BCLR IC2CON2, #7
14:                    IC2CON2bits.TRIGSTAT = 1; //
002DC2  A8C14A     BSET IC2CON2, #6
15:                    IC2BUF = 0;
002DC4  EF214C     CLR IC2BUF
16:                    IC2TMR = 0;
002DC6  EF214E     CLR IC2TMR
17:                    IC2CON1bits.ICM = 0b111; //  
002DC8  200070     MOV #0x7, W0
002DCA  B72148     IOR IC2CON1
18:                    IPC1bits.IC2IP = 6; // Setup Input Capture 1 interrupt for desired priority
002DCC  2FF8F0     MOV #0xFF8F, W0
002DCE  B600A6     AND IPC1, WREG
002DD0  B30600     IOR #0x60, W0
002DD2  880530     MOV W0, IPC1
19:                    // level (this example assigns level 1 priority)
20:                    IFS0bits.IC2IF = 0; // Clear the IC1 interrupt status flag
002DD4  A9A084     BCLR IFS0, #5
21:                    IEC0bits.IC2IE = 1; // Enable IC1 interrupts
002DD6  A8A094     BSET IEC0, #5
22:                    //    S1_IN;
23:                    TRISBbits.TRISB9 = 1;
002DD8  A822C9     BSET 0x2C9, #1
24:                    //    IC2CON1bits.ICBNE = 1;
25:                    //ICI<1:0> 
26:                    //    IC1CON2 = 0x00A4; // Turn on Input Capture 1 Module 
27:                    //    T1CONbits.TON=1;
28:                }
002DDA  060000     RETURN
29:                
30:                
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/bsp/ADC.c  ---------------------------
1:                 //#include "p24F32KA302.h"
2:                 //#include "user.h"
3:                 #include "xc.h"
4:                 
5:                 void ADC_Init(void) {    
6:                 //    ADC0_IN;
7:                     TRISAbits.TRISA2 = 1;
002DDC  A842C0     BSET TRISA, #2
8:                     ANSAbits.ANSA2 = 0;
002DDE  A944E0     BCLR ANSA, #2
9:                     //
10:                    AD1CON2bits.PVCFG=0;//AVdd
002DE0  23FFF0     MOV #0x3FFF, W0
002DE2  B62342     AND AD1CON2
11:                    AD1CON2bits.NVCFG=0;//AVss
002DE4  A9A343     BCLR 0x343, #5
12:                    AD1CON3bits.ADCS=0b00001111;//16Tcy
002DE6  B3C0F0     MOV.B #0xF, W0
002DE8  B7E344     MOV.B WREG, AD1CON3
13:                    AD1CON1bits.SSRC=0;
002DEA  2FF0F0     MOV #0xFF0F, W0
002DEC  B62340     AND AD1CON1
14:                    AD1CON3bits.SAMC=0b01111;//15Tcy
002DEE  2E0FF1     MOV #0xE0FF, W1
002DF0  801A20     MOV AD1CON3, W0
002DF2  608080     AND W1, W0, W1
002DF4  20F000     MOV #0xF00, W0
002DF6  700001     IOR W0, W1, W0
002DF8  881A20     MOV W0, AD1CON3
15:                    AD1CON1bits.FORM=0;//
002DFA  2FCFF0     MOV #0xFCFF, W0
002DFC  B62340     AND AD1CON1
16:                }
002DFE  060000     RETURN
17:                
18:                float Get_Voltage(void) {
19:                
20:                }
002E00  060000     RETURN
21:                
22:                
---  C:/Users/Administrator/Desktop/code/GPRS/UCOS-TestENGPRS1.0.X/App/app.c  ---------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                               uC/OS-II
4:                  *                                         The Real-Time Kernel
5:                  *
6:                  *                               (c) Copyright 2006, Micrium, Weston, FL
7:                  *                                          All Rights Reserved
8:                  *
9:                  *
10:                 *                                      Microchip Application Code
11:                 *
12:                 * File : APP.C
13:                 * By   : Eric Shufo
14:                 *********************************************************************************************************
15:                 */
16:                
17:                #include <includes.h>
18:                //#include <xc.h>
19:                //#include <Configuration Bit.h>
20:                int FBS __attribute__((space(prog), address(0xF80000))) = 0xF;
21:                //_FBS(
22:                //    BWRP_OFF &           // Boot Segment Write Protect (Disabled)
23:                //    BSS_OFF              // Boot segment Protect (No boot program flash segment)
24:                //);
25:                int FGS __attribute__((space(prog), address(0xF80004))) = 0x3;
26:                //_FGS(
27:                //    GWRP_OFF &           // General Segment Write Protect (General segment may be written)
28:                //    GSS0_OFF             // General Segment Code Protect (No Protection)
29:                //);
30:                int FOSCSEL __attribute__((space(prog), address(0xF80006))) = 0xF0; //0x5E;//0xBC ;
31:                //_FOSCSEL(
32:                //    FNOSC_LPFRC &        // Oscillator Select (500kHz Low-Power FRC oscillator with Postscaler(LPFRCDIV))
33:                //    SOSCSRC_DIG &        // SOSC Source Type (Digital Mode for use with external source)
34:                //    LPRCSEL_HP &         // LPRC Oscillator Power and Accuracy (High Power, High Accuracy Mode)
35:                //    IESO_OFF             // Internal External Switch Over bit (Internal External Switchover mode disabled (Two-speed Start-up disabled))
36:                //);
37:                int FOSC __attribute__((space(prog), address(0xF80008))) = 0x33; //;0x70     3B
38:                //_FOSC(
39:                //    POSCMOD_NONE &       // Primary Oscillator Configuration bits (Primary oscillator disabled)
40:                //    OSCIOFNC_OFF &       // CLKO Enable Configuration bit (CLKO output disabled)
41:                //    POSCFREQ_HS &        // Primary Oscillator Frequency Range Configuration bits (Primary oscillator/external clock input frequency greater than 8MHz)
42:                //    SOSCSEL_SOSCHP &     // SOSC Power Selection Configuration bits (Secondary Oscillator configured for high-power operation)
43:                //    FCKSM_CSDCME         // Clock Switching and Monitor Selection (Both Clock Switching and Fail-safe Clock Monitor are enabled)
44:                //);
45:                int FWDT __attribute__((space(prog), address(0xF8000A))) = 0x5F; //DF
46:                //_FWDT(
47:                //    WDTPS_PS32768 &      // Watchdog Timer Postscale Select bits (1:32768)
48:                //    FWPSA_PR128 &        // WDT Prescaler bit (WDT prescaler ratio of 1:128)
49:                //    FWDTEN_SWON &        // Watchdog Timer Enable bits (WDT controlled with the SWDTEN bit setting)
50:                //    WINDIS_OFF           // Windowed Watchdog Timer Disable bit (Standard WDT selected(windowed WDT disabled))
51:                //);
52:                
53:                int FPOR __attribute__((space(prog), address(0xF8000C))) = 0xFC; //0xBB ;//0xFF//0xFC
54:                //_FPOR(
55:                //    BOREN_BOR3 &         // Brown-out Reset Enable bits (Brown-out Reset enabled in hardware, SBOREN bit disabled)
56:                //    LVRCFG_ON &          // Low Voltage Regulator Configuration bit (Low Voltage regulator is available and controlled by LVREN bit)
57:                //    PWRTEN_ON &          // Power-up Timer Enable bit (PWRT enabled)
58:                //    I2C1SEL_PRI &        // Alternate I2C1 Pin Mapping bit (Use Default SCL1/SDA1 Pins For I2C1)
59:                //    BORV_V30 &           // Brown-out Reset Voltage bits (Brown-out Reset set to Highest Voltage (3.0V))
60:                //    MCLRE_ON             // MCLR Pin Enable bit (RA5 input pin disabled,MCLR pin enabled)
61:                //);
62:                int FICD __attribute__((space(prog), address(0xF8000E))) = 0x82;
63:                //_FICD(
64:                //    ICS_PGx2             // ICD Pin Placement Select bits (EMUC/EMUD share PGC2/PGD2)
65:                //);
66:                
67:                int FDS __attribute__((space(prog), address(0xF80010))) = 0x1F; //0x1F ;
68:                //_FDS(
69:                //    DSWDTPS_DSWDTPSF &   // Deep Sleep Watchdog Timer Postscale Select bits (1:2,147,483,648 (25.7 Days))
70:                //    DSWDTOSC_LPRC &      // DSWDT Reference Clock Select bit (DSWDT uses Low Power RC Oscillator (LPRC))
71:                //    DSBOREN_ON &         // Deep Sleep Zero-Power BOR Enable bit (Deep Sleep BOR enabled in Deep Sleep)
72:                //    DSWDTEN_OFF          // Deep Sleep Watchdog Timer Enable bit (DSWDT disabled)
73:                //);    
74:                /*
75:                 *********************************************************************************************************
76:                 *                                                CONSTANTS
77:                 *********************************************************************************************************
78:                 */
79:                
80:                
81:                /*
82:                 *********************************************************************************************************
83:                 *                                                VARIABLES
84:                 *********************************************************************************************************
85:                 */
86:                
87:                OS_STK AppStartTaskStk[128];
88:                //OS_STK  AppLCDTaskStk[128];
89:                
90:                
91:                /*
92:                 *********************************************************************************************************
93:                 *                                            FUNCTION PROTOTYPES
94:                 *********************************************************************************************************
95:                 */
96:                
97:                static void AppStartTask(void *p_arg);
98:                //static  void  AppLCDTask(void *p_arg);
99:                static void AppTaskCreate(void);
100:               
101:               #if (uC_PROBE_OS_PLUGIN > 0) || (uC_PROBE_COM_MODULE > 0)
102:               extern void AppProbeInit(void);
103:               #endif
104:               
105:               /*
106:                *********************************************************************************************************
107:                *                                                main()
108:                *
109:                * Description : This is the standard entry point for C code.
110:                * Arguments   : none
111:                *********************************************************************************************************
112:                */
113:               
114:               CPU_INT16S main(void) {
115:                   CPU_INT08U err;
116:               
117:               
118:                   BSP_IntDisAll(); /* Disable all interrupts until we are ready to accept them */
002D82  022ACE     CALL BSP_IntDisAll
002D84  000000     NOP
119:               
120:                   OSInit(); /* Initialize "uC/OS-II, The Real-Time Kernel"              */
002D86  021D06     CALL OSInit
002D88  000000     NOP
121:               
122:                   OSTaskCreateExt(AppStartTask,
002D8A  200030     MOV #0x3, W0
002D8C  781F80     MOV W0, [W15++]
002D8E  EB1F80     CLR [W15++]
002D90  200806     MOV #0x80, W6
002D92  200007     MOV #0x0, W7
002D94  20C5A5     MOV #0xC5A, W5
002D96  200024     MOV #0x2, W4
002D98  784184     MOV.B W4, W3
002D9A  20B5C2     MOV #0xB5C, W2
002D9C  EB0080     CLR W1
002D9E  22D600     MOV #0x2D60, W0
002DA0  0222DA     CALL OSTaskCreateExt
002DA2  000000     NOP
123:                           (void *) 0,
124:                           (OS_STK *) & AppStartTaskStk[0],
125:                           2,
126:                           2,
127:                           (OS_STK *) & AppStartTaskStk[127],
128:                           128,
129:                           (void *) 0,
130:                           OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
131:               
132:               #if OS_TASK_NAME_SIZE > 11
133:                   OSTaskNameSet(APP_TASK_START_PRIO, (CPU_INT08U *) "Start Task", &err);
134:               #endif
135:               
136:                   OSStart(); /* Start multitasking (i.e. give control to uC/OS-II)       */
002DA4  021BF8     CALL OSStart
002DA6  000000     NOP
002DA8  5787E4     SUB W15, #0x4, W15
137:               
138:                   return (-1); /* Return an error - This line of code is unreachable       */
139:               }
002DAA  EB8000     SETM W0
140:               
141:               /*
142:                *********************************************************************************************************
143:                *                                          STARTUP TASK
144:                *
145:                * Description : This is an example of a startup task.  As mentioned in the book's text, you MUST
146:                *               initialize the ticker only once multitasking has started.
147:                *
148:                * Arguments   : p_arg   is the argument passed to 'AppStartTask()' by 'OSTaskCreate()'.
149:                *
150:                * Notes       : 1) The first line of code is used to prevent a compiler warning because 'p_arg' is not
151:                *                  used.  The compiler should not generate any code for this statement.
152:                *               2) Interrupts are enabled once the task start because the I-bit of the CCR register was
153:                *                  set to 0 by 'OSTaskCreate()'.
154:                *********************************************************************************************************
155:                */
156:               
157:               static void AppStartTask(void *p_arg) {
158:               //    CPU_INT08U i;
159:               //    CPU_INT08U j;
160:               
161:               
162:                   (void) p_arg;
163:               
164:                   BSP_Init(); /* Initialize BSP functions                                 */
002D60  022ADE     CALL BSP_Init
002D62  000000     NOP
165:               
166:               #if OS_TASK_STAT_EN > 0
167:                   OSStatInit(); /* Determine CPU capacity                                   */
002D64  021C14     CALL OSStatInit
002D66  000000     NOP
168:               #endif
169:               
170:               #if (uC_PROBE_OS_PLUGIN > 0) || (uC_PROBE_COM_MODULE > 0)
171:                   AppProbeInit(); /* Initialize uC/Probe modules                              */
172:               #endif
173:               
174:                   //    AppTaskCreate();                                                    /* Create additional user tasks                             */
175:               
176:                   LED_On(1); /* Turn OFF all the LEDs                                    */
002D68  B3C010     MOV.B #0x1, W0
002D6A  022AD0     CALL LED_On
002D6C  000000     NOP
177:               
178:                   while (1) { /* Task body, always written as an infinite loop.           */
179:               //        for (j = 1; j <= 8; j++) {/* Scroll the LEDs to the right	                            */
180:                           LED_Toggle(1);
002D6E  B3C010     MOV.B #0x1, W0
002D70  022AE4     CALL LED_Toggle
002D72  000000     NOP
181:                           OSTimeDlyHMSM(0, 0, 0, 500); /* Delay 25ms                                               */
002D74  201F43     MOV #0x1F4, W3
002D76  EB4100     CLR.B W2
002D78  784082     MOV.B W2, W1
002D7A  784002     MOV.B W2, W0
002D7C  022762     CALL OSTimeDlyHMSM
002D7E  000000     NOP
002D80  37FFF6     BRA 0x2D6E
182:               //            LED_Off(1);
183:               //        }
184:                   }
185:               }
186:               
187:               
188:               /*
189:                *********************************************************************************************************
190:                *                                          LCD TASK
191:                *
192:                * Description : This example task writes messages to the Explorer16 LCD screen.
193:                *
194:                * Arguments   : p_arg   is the argument passed to 'AppStartTask()' by 'OSTaskCreate()'.
195:                *
196:                * Notes       : 1) The first line of code is used to prevent a compiler warning because 'p_arg' is not
197:                *                  used.  The compiler should not generate any code for this statement.
198:                *               2) Interrupts are enabled once the task start because the I-bit of the CCR register was
199:                *                  set to 0 by 'OSTaskCreate()'.
200:                *********************************************************************************************************
201:                */
202:               
203:               //static  void  AppLCDTask (void *p_arg)
204:               //{
205:               //       CPU_INT08S  i;
206:               //       CPU_INT08U  buf[17];
207:               //       CPU_INT32U  value;
208:               //                                                                /* Power On Welcome Message. 3 msg's, 2 rows each.      */
209:               //const  CPU_INT08U  welcome_str[12][17] = {"Welcome to the  ",
210:               //                                          "Explorer 16 EVB.",
211:               //                                          "This demo is    ",
212:               //                                          "running uC/OS-II",
213:               //                                          "and uC/Probe on ",
214:               //                                          "the Microchip   ",
215:               //                                          "PIC CPU.    ",
216:               //                                          "Please visit:   ",
217:               //                                          "www.micrium.com ",
218:               //                                          "to download     ",
219:               //                                          "uC/Probe for use",
220:               //                                          "with this demo. "};
221:               //
222:               //
223:               //   (void)p_arg;
224:               //
225:               //    DispInit(2, 16);                                            /* Initialize uC/LCD for a 2 row by 16 column display.  */
226:               //
227:               //
228:               //    DispClrScr();                                               /* Clear the screen.                                    */
229:               //
230:               //    for (i = 0; i < 12; i+=2) {										
231:               //        DispStr(0, 0, (CPU_INT08U *)welcome_str[i]);            /* Display row 0 of Welcome Message i.                  */
232:               //        DispStr(1, 0, (CPU_INT08U *)welcome_str[i+1]);          /* Display row 1 of Welcome Message i.                  */
233:               //        OSTimeDlyHMSM(0, 0, 2, 0);                              /* Delay between updating the message.                  */
234:               //    }
235:               //
236:               //    Str_Copy(buf, (CPU_INT08U *)"uC/OS-II: Vx.yy ");
237:               //    value    = (CPU_INT32U)OSVersion();
238:               //    buf[11]  = (value / 100) + '0';
239:               //    buf[13]  = (value % 100) / 10 + '0';
240:               //    buf[14]  = (value %  10) + '0';
241:               //    DispStr(0, 0, buf);
242:               //
243:               //    Str_Copy(buf, (CPU_INT08U *)"CPU Speed: xxMHz");
244:               //    value    = (CPU_INT32U)BSP_CPU_ClkFrq() / 1000000L;
245:               //    buf[11]  = (value / 10) + '0';
246:               //    buf[12]  = (value % 10) + '0';
247:               //    DispStr(1, 0, buf);
248:               //
249:               //    OSTimeDlyHMSM(0, 0, 2, 0);
250:               //
251:               //    while (1) {                                          /* All tasks bodies include an infinite loop.           */
252:               //        Str_Copy(buf, (CPU_INT08U *)"CPU Usage: xxx %");
253:               //        value    = (CPU_INT32U)OSCPUUsage;
254:               //        buf[11]  = (value / 100)      + '0';
255:               //        buf[12]  = (value % 100) / 10 + '0';
256:               //        buf[13]  = (value      ) % 10 + '0';
257:               //        DispStr(0, 0, buf);
258:               //
259:               //        Str_Copy(buf, (CPU_INT08U *)"OSCtxSw: ");
260:               //        value    = (CPU_INT32U)OSCtxSwCtr;
261:               //        sprintf((char *)&buf[9], "%ld", value);
262:               //        DispClrLine(1);
263:               //        DispStr(1, 0, buf);
264:               //
265:               //        OSTimeDlyHMSM(0, 0, 0, 100);
266:               //     }
267:               //}
268:               
269:               
270:               /*
271:                *********************************************************************************************************
272:                *                              CREATE ADDITIONAL APPLICATION TASKS
273:                *********************************************************************************************************
274:                */
275:               
276:               //static  void  AppTaskCreate (void)
277:               //{
278:               //    CPU_INT08U  err;
279:               //
280:               //
281:               //    OSTaskCreateExt(AppLCDTask,
282:               //                    (void *)0,
283:               //                    (OS_STK *)&AppLCDTaskStk[0],
284:               //                    3,
285:               //                    3,
286:               //                    (OS_STK *)&AppLCDTaskStk[127],
287:               //                    128,
288:               //                    (void *)0,
289:               //                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);
290:               //
291:               //#if OS_TASK_NAME_SIZE > 11
292:               //    OSTaskNameSet(APP_TASK_LCD_PRIO, (CPU_INT08U *)"LCD Task", &err);
293:               //#endif
294:               //}
295:               
296:               
