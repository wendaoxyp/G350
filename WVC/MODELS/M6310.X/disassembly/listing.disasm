Disassembly Listing for M6310
Generated From:
C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/dist/default/debug/UART1.X.debug.elf
Dec 23, 2017 3:14:18 PM

---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/mcc_generated_files/uart1.c  ----------------
1:                 /**
2:                   UART1 Generated Driver File 
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     uart1.c
9:                 
10:                  @Summary
11:                    This is the generated source file for the UART1 driver using Foundation Services Library
12:                
13:                  @Description
14:                    This source file provides APIs for driver for UART1. 
15:                    Generation Information : 
16:                        Product Revision  :  Foundation Services Library - pic24-dspic-pic32mm : v1.26
17:                        Device            :  PIC24FJ64GA702
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 1.30
20:                        MPLAB 	          :  MPLAB X 3.45
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                
49:                #include "uart1.h"
50:                
51:                /**
52:                  Section: Data Type Definitions
53:                */
54:                
55:                /** UART Driver Queue Status
56:                
57:                  @Summary
58:                    Defines the object required for the status of the queue.
59:                */
60:                
61:                typedef union
62:                {
63:                    struct
64:                    {
65:                            uint8_t full:1;
66:                            uint8_t empty:1;
67:                            uint8_t reserved:6;
68:                    }s;
69:                    uint8_t status;
70:                }
71:                
72:                UART_BYTEQ_STATUS;
73:                
74:                /** UART Driver Hardware Instance Object
75:                
76:                  @Summary
77:                    Defines the object required for the maintenance of the hardware instance.
78:                
79:                */
80:                typedef struct
81:                {
82:                    /* RX Byte Q */
83:                    uint8_t                                      *rxTail ;
84:                
85:                    uint8_t                                      *rxHead ;
86:                
87:                    /* TX Byte Q */
88:                    uint8_t                                      *txTail ;
89:                
90:                    uint8_t                                      *txHead ;
91:                
92:                    UART_BYTEQ_STATUS                        rxStatus ;
93:                
94:                    UART_BYTEQ_STATUS                        txStatus ;
95:                
96:                } UART_OBJECT ;
97:                
98:                static UART_OBJECT uart1_obj ;
99:                
100:               /** UART Driver Queue Length
101:               
102:                 @Summary
103:                   Defines the length of the Transmit and Receive Buffers
104:               
105:               */
106:               
107:               #define UART1_CONFIG_TX_BYTEQ_LENGTH 64
108:               #define UART1_CONFIG_RX_BYTEQ_LENGTH 64
109:               
110:               
111:               /** UART Driver Queue
112:               
113:                 @Summary
114:                   Defines the Transmit and Receive Buffers
115:               
116:               */
117:               
118:               static uint8_t uart1_txByteQ[UART1_CONFIG_TX_BYTEQ_LENGTH] ;
119:               static uint8_t uart1_rxByteQ[UART1_CONFIG_RX_BYTEQ_LENGTH] ;
120:               
121:               void (*UART1_TxDefaultInterruptHandler)(void);
122:               void (*UART1_RxDefaultInterruptHandler)(void);
123:               
124:               /**
125:                 Section: Driver Interface
126:               */
127:               
128:               
129:               void UART1_Initialize (void)
130:               {
00069A  FA0000     LNK #0x0
131:                  // STSEL 1; IREN disabled; PDSEL 8N; UARTEN enabled; RTSMD disabled; USIDL disabled; WAKE disabled; ABAUD disabled; LPBACK disabled; BRGH enabled; URXINV disabled; UEN TX_RX; 
132:                  U1MODE = (0x8008 & ~(1<<15));  // disabling UARTEN bit   
00069C  200080     MOV #0x8, W0
00069E  881CC0     MOV W0, U1MODE
133:                  // UTXISEL0 TX_ONE_CHAR; UTXINV disabled; URXEN disabled; OERR NO_ERROR_cleared; URXISEL RX_3_4_BUF_FULL; UTXBRK COMPLETED; UTXEN disabled; ADDEN disabled; 
134:                  U1STA = 0x0080;
0006A0  200800     MOV #0x80, W0
0006A2  881CD0     MOV W0, U1STA
135:                  // BaudRate = 19200; Frequency = 4000000 Hz; U1BRG 51; 
136:                  U1BRG = 0x0033;
0006A4  200330     MOV #0x33, W0
0006A6  881D00     MOV W0, U1BRG
137:                  // ADMADDR 0; ADMMASK 0; 
138:                  U1ADMD = 0x0000;
0006A8  EF23A2     CLR U1ADMD
139:                   
140:                  IEC0bits.U1RXIE = 1;
0006AA  A86099     BSET 0x99, #3
141:                  UART1_SetRxInterruptHandler(UART1_Receive_ISR);
0006AC  2078A0     MOV #0x78A, W0
0006AE  070058     RCALL UART1_SetRxInterruptHandler
142:                  UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
0006B0  2070E0     MOV #0x70E, W0
0006B2  070018     RCALL UART1_SetTxInterruptHandler
143:               
144:                   //Make sure to set LAT bit corresponding to TxPin as high before UART initialization
145:                  U1MODEbits.UARTEN = 1;  // enabling UART ON bit
0006B4  A8E399     BSET 0x399, #7
146:                  U1STAbits.UTXEN = 1;
0006B6  A8439B     BSET 0x39B, #2
147:                  
148:                  
149:               
150:                  uart1_obj.txHead = uart1_txByteQ;
0006B8  209260     MOV #0x926, W0
0006BA  884910     MOV W0, 0x922
151:                  uart1_obj.txTail = uart1_txByteQ;
0006BC  209260     MOV #0x926, W0
0006BE  884900     MOV W0, 0x920
152:                  uart1_obj.rxHead = uart1_rxByteQ;
0006C0  209660     MOV #0x966, W0
0006C2  8848F0     MOV W0, 0x91E
153:                  uart1_obj.rxTail = uart1_rxByteQ;
0006C4  209660     MOV #0x966, W0
0006C6  8848E0     MOV W0, uart1_obj
154:                  uart1_obj.rxStatus.s.empty = true;
0006C8  804920     MOV 0x924, W0
0006CA  A01000     BSET W0, #1
0006CC  884920     MOV W0, 0x924
155:                  uart1_obj.txStatus.s.empty = true;
0006CE  804920     MOV 0x924, W0
0006D0  A09000     BSET W0, #9
0006D2  884920     MOV W0, 0x924
156:                  uart1_obj.txStatus.s.full = false;
0006D4  804920     MOV 0x924, W0
0006D6  A18000     BCLR W0, #8
0006D8  884920     MOV W0, 0x924
157:                  uart1_obj.rxStatus.s.full = false;
0006DA  804920     MOV 0x924, W0
0006DC  A10000     BCLR W0, #0
0006DE  884920     MOV W0, 0x924
158:               }
0006E0  FA8000     ULNK
0006E2  060000     RETURN
159:               
160:               
161:               
162:               
163:               /**
164:                   Maintains the driver's transmitter state machine and implements its ISR
165:               */
166:               void UART1_SetTxInterruptHandler(void* handler){
0006E4  FA0002     LNK #0x2
0006E6  780F00     MOV W0, [W14]
167:                   UART1_TxDefaultInterruptHandler = handler;
0006E8  78001E     MOV [W14], W0
0006EA  8842B0     MOV W0, UART1_TxDefaultInterruptHandler
168:               }
0006EC  FA8000     ULNK
0006EE  060000     RETURN
169:               
170:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U1TXInterrupt ( void )
171:               {
0006F0  F80036     PUSH RCOUNT
0006F2  BE9F80     MOV.D W0, [W15++]
0006F4  BE9F82     MOV.D W2, [W15++]
0006F6  BE9F84     MOV.D W4, [W15++]
0006F8  BE9F86     MOV.D W6, [W15++]
0006FA  FA0000     LNK #0x0
172:                   (*UART1_TxDefaultInterruptHandler)();
0006FC  8042B0     MOV UART1_TxDefaultInterruptHandler, W0
0006FE  010000     CALL W0
173:               }
000700  FA8000     ULNK
000702  BE034F     MOV.D [--W15], W6
000704  BE024F     MOV.D [--W15], W4
000706  BE014F     MOV.D [--W15], W2
000708  BE004F     MOV.D [--W15], W0
00070A  F90036     POP RCOUNT
00070C  064000     RETFIE
174:               
175:               void UART1_Transmit_ISR(void)
176:               { 
00070E  FA0000     LNK #0x0
177:                   if(uart1_obj.txStatus.s.empty)
000710  804921     MOV 0x924, W1
000712  202000     MOV #0x200, W0
000714  608000     AND W1, W0, W0
000716  E00000     CP0 W0
000718  320002     BRA Z, 0x71E
178:                   {
179:                       IEC0bits.U1TXIE = false;
00071A  A98099     BCLR 0x99, #4
180:                       return;
00071C  37001F     BRA 0x75C
181:                   }
182:               
183:                   IFS0bits.U1TXIF = false;
00071E  A98089     BCLR 0x89, #4
184:               
185:                   while(!(U1STAbits.UTXBF == 1))
000720  370018     BRA 0x752
000752  801CD1     MOV U1STA, W1
000754  202000     MOV #0x200, W0
000756  608000     AND W1, W0, W0
000758  E00000     CP0 W0
00075A  32FFE3     BRA Z, 0x722
186:                   {
187:               
188:                       U1TXREG = *uart1_obj.txHead;
000722  804910     MOV 0x922, W0
000724  784010     MOV.B [W0], W0
000726  FB8000     ZE W0, W0
000728  881CE0     MOV W0, U1TXREG
189:               
190:                       uart1_obj.txHead++;
00072A  804910     MOV 0x922, W0
00072C  E80000     INC W0, W0
00072E  884910     MOV W0, 0x922
191:               
192:                       if(uart1_obj.txHead == (uart1_txByteQ + UART1_CONFIG_TX_BYTEQ_LENGTH))
000730  804911     MOV 0x922, W1
000732  209660     MOV #0x966, W0
000734  508F80     SUB W1, W0, [W15]
000736  3A0002     BRA NZ, 0x73C
193:                       {
194:                           uart1_obj.txHead = uart1_txByteQ;
000738  209260     MOV #0x926, W0
00073A  884910     MOV W0, 0x922
195:                       }
196:               
197:                       uart1_obj.txStatus.s.full = false;
00073C  804920     MOV 0x924, W0
00073E  A18000     BCLR W0, #8
000740  884920     MOV W0, 0x924
198:               
199:                       if(uart1_obj.txHead == uart1_obj.txTail)
000742  804911     MOV 0x922, W1
000744  804900     MOV 0x920, W0
000746  508F80     SUB W1, W0, [W15]
000748  3A0004     BRA NZ, 0x752
200:                       {
201:                           uart1_obj.txStatus.s.empty = true;
00074A  804920     MOV 0x924, W0
00074C  A09000     BSET W0, #9
00074E  884920     MOV W0, 0x924
202:                           break;
000750  370005     BRA 0x75C
203:                       }
204:                   }
205:               }
00075C  FA8000     ULNK
00075E  060000     RETURN
206:               
207:               void UART1_SetRxInterruptHandler(void* handler){
000760  FA0002     LNK #0x2
000762  780F00     MOV W0, [W14]
208:                   UART1_RxDefaultInterruptHandler = handler;
000764  78001E     MOV [W14], W0
000766  8842C0     MOV W0, UART1_RxDefaultInterruptHandler
209:               }
000768  FA8000     ULNK
00076A  060000     RETURN
210:               
211:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U1RXInterrupt( void )
212:               {
00076C  F80036     PUSH RCOUNT
00076E  BE9F80     MOV.D W0, [W15++]
000770  BE9F82     MOV.D W2, [W15++]
000772  BE9F84     MOV.D W4, [W15++]
000774  BE9F86     MOV.D W6, [W15++]
000776  FA0000     LNK #0x0
213:                   (*UART1_RxDefaultInterruptHandler)();
000778  8042C0     MOV UART1_RxDefaultInterruptHandler, W0
00077A  010000     CALL W0
214:               }
00077C  FA8000     ULNK
00077E  BE034F     MOV.D [--W15], W6
000780  BE024F     MOV.D [--W15], W4
000782  BE014F     MOV.D [--W15], W2
000784  BE004F     MOV.D [--W15], W0
000786  F90036     POP RCOUNT
000788  064000     RETFIE
215:               
216:               void UART1_Receive_ISR(void)
217:               {
00078A  FA0000     LNK #0x0
218:               
219:               
220:                   while((U1STAbits.URXDA == 1))
00078C  370018     BRA 0x7BE
0007BE  801CD0     MOV U1STA, W0
0007C0  600061     AND W0, #0x1, W0
0007C2  E00000     CP0 W0
0007C4  3AFFE4     BRA NZ, 0x78E
221:                   {
222:               
223:                       *uart1_obj.rxTail = U1RXREG;
00078E  8048E0     MOV uart1_obj, W0
000790  801CF1     MOV U1RXREG, W1
000792  784081     MOV.B W1, W1
000794  784801     MOV.B W1, [W0]
224:               
225:                       uart1_obj.rxTail++;
000796  8048E0     MOV uart1_obj, W0
000798  E80000     INC W0, W0
00079A  8848E0     MOV W0, uart1_obj
226:               
227:                       if(uart1_obj.rxTail == (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
00079C  8048E1     MOV uart1_obj, W1
00079E  209A60     MOV #0x9A6, W0
0007A0  508F80     SUB W1, W0, [W15]
0007A2  3A0002     BRA NZ, 0x7A8
228:                       {
229:                           uart1_obj.rxTail = uart1_rxByteQ;
0007A4  209660     MOV #0x966, W0
0007A6  8848E0     MOV W0, uart1_obj
230:                       }
231:               
232:                       uart1_obj.rxStatus.s.empty = false;
0007A8  804920     MOV 0x924, W0
0007AA  A11000     BCLR W0, #1
0007AC  884920     MOV W0, 0x924
233:                       
234:                       if(uart1_obj.rxTail == uart1_obj.rxHead)
0007AE  8048E1     MOV uart1_obj, W1
0007B0  8048F0     MOV 0x91E, W0
0007B2  508F80     SUB W1, W0, [W15]
0007B4  3A0004     BRA NZ, 0x7BE
235:                       {
236:                           //Sets the flag RX full
237:                           uart1_obj.rxStatus.s.full = true;
0007B6  804920     MOV 0x924, W0
0007B8  A00000     BSET W0, #0
0007BA  884920     MOV W0, 0x924
238:                           break;
0007BC  370004     BRA 0x7C6
239:                       }
240:                       
241:                   }
242:               
243:                   IFS0bits.U1RXIF = false;
0007C6  A96089     BCLR 0x89, #3
244:                  
245:               }
0007C8  FA8000     ULNK
0007CA  060000     RETURN
246:               
247:               
248:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U1ErrInterrupt ( void )
249:               {
0007CC  781F80     MOV W0, [W15++]
0007CE  FA0000     LNK #0x0
250:                   if ((U1STAbits.OERR == 1))
0007D0  801CD0     MOV U1STA, W0
0007D2  600062     AND W0, #0x2, W0
0007D4  E00000     CP0 W0
0007D6  320001     BRA Z, 0x7DA
251:                   {
252:                       U1STAbits.OERR = 0;
0007D8  A9239A     BCLR U1STA, #1
253:                   }
254:               
255:                   IFS4bits.U1ERIF = false;
0007DA  A92090     BCLR IFS4, #1
256:               }
0007DC  FA8000     ULNK
0007DE  78004F     MOV [--W15], W0
0007E0  064000     RETFIE
257:               
258:               /**
259:                 Section: UART Driver Client Routines
260:               */
261:               
262:               uint8_t UART1_Read( void)
263:               {
0007E2  FA0002     LNK #0x2
264:                   uint8_t data = 0;
0007E4  EB4000     CLR.B W0
0007E6  784F00     MOV.B W0, [W14]
265:               
266:                   data = *uart1_obj.rxHead;
0007E8  8048F0     MOV 0x91E, W0
0007EA  784F10     MOV.B [W0], [W14]
267:               
268:                   uart1_obj.rxHead++;
0007EC  8048F0     MOV 0x91E, W0
0007EE  E80000     INC W0, W0
0007F0  8848F0     MOV W0, 0x91E
269:               
270:                   if (uart1_obj.rxHead == (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
0007F2  8048F1     MOV 0x91E, W1
0007F4  209A60     MOV #0x9A6, W0
0007F6  508F80     SUB W1, W0, [W15]
0007F8  3A0002     BRA NZ, 0x7FE
271:                   {
272:                       uart1_obj.rxHead = uart1_rxByteQ;
0007FA  209660     MOV #0x966, W0
0007FC  8848F0     MOV W0, 0x91E
273:                   }
274:               
275:                   if (uart1_obj.rxHead == uart1_obj.rxTail)
0007FE  8048F1     MOV 0x91E, W1
000800  8048E0     MOV uart1_obj, W0
000802  508F80     SUB W1, W0, [W15]
000804  3A0003     BRA NZ, 0x80C
276:                   {
277:                       uart1_obj.rxStatus.s.empty = true;
000806  804920     MOV 0x924, W0
000808  A01000     BSET W0, #1
00080A  884920     MOV W0, 0x924
278:                   }
279:               
280:                   uart1_obj.rxStatus.s.full = false;
00080C  804920     MOV 0x924, W0
00080E  A10000     BCLR W0, #0
000810  884920     MOV W0, 0x924
281:               
282:                   return data;
000812  78401E     MOV.B [W14], W0
283:               }
000814  FA8000     ULNK
000816  060000     RETURN
284:               
285:               
286:               unsigned int UART1_ReadBuffer( uint8_t *buffer, unsigned int bufLen)
287:               {
000818  FA0006     LNK #0x6
00081A  781F88     MOV W8, [W15++]
00081C  980710     MOV W0, [W14+2]
00081E  980721     MOV W1, [W14+4]
288:                   unsigned int numBytesRead = 0 ;
000820  EB0000     CLR W0
000822  780F00     MOV W0, [W14]
289:                   while ( numBytesRead < ( bufLen ))
000824  370009     BRA 0x838
000838  90002E     MOV [W14+4], W0
00083A  78009E     MOV [W14], W1
00083C  508F80     SUB W1, W0, [W15]
00083E  39FFF3     BRA NC, 0x826
000840  370001     BRA 0x844
290:                   {
291:                       if( uart1_obj.rxStatus.s.empty)
000826  804920     MOV 0x924, W0
000828  600062     AND W0, #0x2, W0
00082A  E00000     CP0 W0
00082C  3A000A     BRA NZ, 0x842
292:                       {
293:                           break;
000842  000000     NOP
294:                       }
295:                       else
296:                       {
297:                           buffer[numBytesRead++] = UART1_Read () ;
00082E  90001E     MOV [W14+2], W0
000830  40041E     ADD W0, [W14], W8
000832  07FFD7     RCALL UART1_Read
000834  784C00     MOV.B W0, [W8]
000836  E80F1E     INC [W14], [W14]
298:                       }
299:                   }
300:               
301:                   return numBytesRead ;
000844  78001E     MOV [W14], W0
302:               }
000846  78044F     MOV [--W15], W8
000848  FA8000     ULNK
00084A  060000     RETURN
303:               
304:               
305:               
306:               void UART1_Write( uint8_t byte)
307:               {
00084C  FA0002     LNK #0x2
00084E  784F00     MOV.B W0, [W14]
308:                   IEC0bits.U1TXIE = false;
000850  A98099     BCLR 0x99, #4
309:                   
310:                   *uart1_obj.txTail = byte;
000852  804900     MOV 0x920, W0
000854  78481E     MOV.B [W14], [W0]
311:               
312:                   uart1_obj.txTail++;
000856  804900     MOV 0x920, W0
000858  E80000     INC W0, W0
00085A  884900     MOV W0, 0x920
313:                   
314:                   if (uart1_obj.txTail == (uart1_txByteQ + UART1_CONFIG_TX_BYTEQ_LENGTH))
00085C  804901     MOV 0x920, W1
00085E  209660     MOV #0x966, W0
000860  508F80     SUB W1, W0, [W15]
000862  3A0002     BRA NZ, 0x868
315:                   {
316:                       uart1_obj.txTail = uart1_txByteQ;
000864  209260     MOV #0x926, W0
000866  884900     MOV W0, 0x920
317:                   }
318:               
319:                   uart1_obj.txStatus.s.empty = false;
000868  804920     MOV 0x924, W0
00086A  A19000     BCLR W0, #9
00086C  884920     MOV W0, 0x924
320:               
321:                   if (uart1_obj.txHead == uart1_obj.txTail)
00086E  804911     MOV 0x922, W1
000870  804900     MOV 0x920, W0
000872  508F80     SUB W1, W0, [W15]
000874  3A0003     BRA NZ, 0x87C
322:                   {
323:                       uart1_obj.txStatus.s.full = true;
000876  804920     MOV 0x924, W0
000878  A08000     BSET W0, #8
00087A  884920     MOV W0, 0x924
324:                   }
325:               
326:                   IEC0bits.U1TXIE = true ;
00087C  A88099     BSET 0x99, #4
327:               	
328:               }
00087E  FA8000     ULNK
000880  060000     RETURN
329:               
330:               
331:               unsigned int UART1_WriteBuffer( uint8_t *buffer , unsigned int bufLen )
332:               {
000882  FA0006     LNK #0x6
000884  980710     MOV W0, [W14+2]
000886  980721     MOV W1, [W14+4]
333:                   unsigned int numBytesWritten = 0 ;
000888  EB0000     CLR W0
00088A  780F00     MOV W0, [W14]
334:               
335:                   while ( numBytesWritten < ( bufLen ))
00088C  37000A     BRA 0x8A2
0008A2  90002E     MOV [W14+4], W0
0008A4  78009E     MOV [W14], W1
0008A6  508F80     SUB W1, W0, [W15]
0008A8  39FFF2     BRA NC, 0x88E
0008AA  370001     BRA 0x8AE
336:                   {
337:                       if((uart1_obj.txStatus.s.full))
00088E  804921     MOV 0x924, W1
000890  201000     MOV #0x100, W0
000892  608000     AND W1, W0, W0
000894  E00000     CP0 W0
000896  3A000A     BRA NZ, 0x8AC
338:                       {
339:                           break;
0008AC  000000     NOP
340:                       }
341:                       else
342:                       {
343:                           UART1_Write (buffer[numBytesWritten++] ) ;
000898  90001E     MOV [W14+2], W0
00089A  40001E     ADD W0, [W14], W0
00089C  784010     MOV.B [W0], W0
00089E  E80F1E     INC [W14], [W14]
0008A0  07FFD5     RCALL UART1_Write
344:                       }
345:                   }
346:               
347:                   return numBytesWritten ;
0008AE  78001E     MOV [W14], W0
348:               
349:               }
0008B0  FA8000     ULNK
0008B2  060000     RETURN
350:               
351:               
352:               UART1_TRANSFER_STATUS UART1_TransferStatusGet (void )
353:               {
0008B4  FA0002     LNK #0x2
354:                   UART1_TRANSFER_STATUS status = 0;
0008B6  EB0000     CLR W0
0008B8  780F00     MOV W0, [W14]
355:               
356:                   if(uart1_obj.txStatus.s.full)
0008BA  804921     MOV 0x924, W1
0008BC  201000     MOV #0x100, W0
0008BE  608000     AND W1, W0, W0
0008C0  E00000     CP0 W0
0008C2  320001     BRA Z, 0x8C6
357:                   {
358:                       status |= UART1_TRANSFER_STATUS_TX_FULL;
0008C4  A0301E     BSET [W14], #3
359:                   }
360:               
361:                   if(uart1_obj.txStatus.s.empty)
0008C6  804921     MOV 0x924, W1
0008C8  202000     MOV #0x200, W0
0008CA  608000     AND W1, W0, W0
0008CC  E00000     CP0 W0
0008CE  320001     BRA Z, 0x8D2
362:                   {
363:                       status |= UART1_TRANSFER_STATUS_TX_EMPTY;
0008D0  A0401E     BSET [W14], #4
364:                   }
365:               
366:                   if(uart1_obj.rxStatus.s.full)
0008D2  804920     MOV 0x924, W0
0008D4  600061     AND W0, #0x1, W0
0008D6  E00000     CP0 W0
0008D8  320001     BRA Z, 0x8DC
367:                   {
368:                       status |= UART1_TRANSFER_STATUS_RX_FULL;
0008DA  A0001E     BSET [W14], #0
369:                   }
370:               
371:                   if(uart1_obj.rxStatus.s.empty)
0008DC  804920     MOV 0x924, W0
0008DE  600062     AND W0, #0x2, W0
0008E0  E00000     CP0 W0
0008E2  320002     BRA Z, 0x8E8
372:                   {
373:                       status |= UART1_TRANSFER_STATUS_RX_EMPTY;
0008E4  A0201E     BSET [W14], #2
0008E6  370001     BRA 0x8EA
374:                   }
375:                   else
376:                   {
377:                       status |= UART1_TRANSFER_STATUS_RX_DATA_PRESENT;
0008E8  A0101E     BSET [W14], #1
378:                   }
379:                   return status;
0008EA  78001E     MOV [W14], W0
380:               }
0008EC  FA8000     ULNK
0008EE  060000     RETURN
381:               
382:               
383:               uint8_t UART1_Peek(uint16_t offset)
384:               {
0008F0  FA0002     LNK #0x2
0008F2  780F00     MOV W0, [W14]
385:                   if( (uart1_obj.rxHead + offset) > (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
0008F4  8048F0     MOV 0x91E, W0
0008F6  40009E     ADD W0, [W14], W1
0008F8  209A60     MOV #0x9A6, W0
0008FA  508F80     SUB W1, W0, [W15]
0008FC  360008     BRA LEU, 0x90E
386:                   {
387:                     return uart1_rxByteQ[offset - (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH - uart1_obj.rxHead)];
0008FE  8048F0     MOV 0x91E, W0
000900  40009E     ADD W0, [W14], W1
000902  209A60     MOV #0x9A6, W0
000904  EA0000     NEG W0, W0
000906  408000     ADD W1, W0, W0
000908  209661     MOV #0x966, W1
00090A  784061     MOV.B [W1+W0], W0
00090C  370003     BRA 0x914
388:                   }
389:                   else
390:                   {
391:                     return *(uart1_obj.rxHead + offset);
00090E  8048F0     MOV 0x91E, W0
000910  40001E     ADD W0, [W14], W0
000912  784010     MOV.B [W0], W0
392:                   }
393:               }
000914  FA8000     ULNK
000916  060000     RETURN
394:               
395:               
396:               uint8_t UART1_is_rx_ready(void)
397:               {
000918  FA0000     LNK #0x0
398:                   if(!uart1_obj.rxStatus.s.full)
00091A  804920     MOV 0x924, W0
00091C  600061     AND W0, #0x1, W0
00091E  E00000     CP0 W0
000920  3A0011     BRA NZ, 0x944
399:                   {
400:                       if(uart1_obj.rxHead > uart1_obj.rxTail)
000922  8048F1     MOV 0x91E, W1
000924  8048E0     MOV uart1_obj, W0
000926  508F80     SUB W1, W0, [W15]
000928  360006     BRA LEU, 0x936
401:                       {
402:                           return(uart1_obj.rxHead - uart1_obj.rxTail);
00092A  8048F0     MOV 0x91E, W0
00092C  784080     MOV.B W0, W1
00092E  8048E0     MOV uart1_obj, W0
000930  784000     MOV.B W0, W0
000932  50C000     SUB.B W1, W0, W0
000934  370008     BRA 0x946
403:                       }
404:                       else
405:                       {
406:                           return(UART1_CONFIG_RX_BYTEQ_LENGTH - (uart1_obj.rxTail - uart1_obj.rxHead));
000936  8048F0     MOV 0x91E, W0
000938  784080     MOV.B W0, W1
00093A  8048E0     MOV uart1_obj, W0
00093C  784000     MOV.B W0, W0
00093E  50C000     SUB.B W1, W0, W0
000940  B04400     ADD.B #0x40, W0
000942  370001     BRA 0x946
407:                       } 
408:                   }
409:                   return 0;
000944  EB4000     CLR.B W0
410:               }
000946  FA8000     ULNK
000948  060000     RETURN
411:               
412:               
413:               uint8_t UART1_is_tx_ready(void)
414:               {
00094A  FA0000     LNK #0x0
415:                   if(!uart1_obj.txStatus.s.full)
00094C  804921     MOV 0x924, W1
00094E  201000     MOV #0x100, W0
000950  608000     AND W1, W0, W0
000952  E00000     CP0 W0
000954  3A0011     BRA NZ, 0x978
416:                   { 
417:                       if(uart1_obj.txHead > uart1_obj.txTail)
000956  804911     MOV 0x922, W1
000958  804900     MOV 0x920, W0
00095A  508F80     SUB W1, W0, [W15]
00095C  360006     BRA LEU, 0x96A
418:                       {
419:                           return(uart1_obj.txHead - uart1_obj.txTail);
00095E  804910     MOV 0x922, W0
000960  784080     MOV.B W0, W1
000962  804900     MOV 0x920, W0
000964  784000     MOV.B W0, W0
000966  50C000     SUB.B W1, W0, W0
000968  370008     BRA 0x97A
420:                       }
421:                       else
422:                       {
423:                           return(UART1_CONFIG_TX_BYTEQ_LENGTH - (uart1_obj.txTail - uart1_obj.txHead));
00096A  804910     MOV 0x922, W0
00096C  784080     MOV.B W0, W1
00096E  804900     MOV 0x920, W0
000970  784000     MOV.B W0, W0
000972  50C000     SUB.B W1, W0, W0
000974  B04400     ADD.B #0x40, W0
000976  370001     BRA 0x97A
424:                       }
425:                   }
426:                   return 0;
000978  EB4000     CLR.B W0
427:               }
00097A  FA8000     ULNK
00097C  060000     RETURN
428:               
429:               
430:               bool UART1_ReceiveBufferIsEmpty (void)
431:               {
00097E  FA0000     LNK #0x0
432:                   return(uart1_obj.rxStatus.s.empty);
000980  804920     MOV 0x924, W0
000982  D10000     LSR W0, W0
000984  604061     AND.B W0, #0x1, W0
000986  FB8000     ZE W0, W0
000988  A7F000     BTSC W0, #15
00098A  EA0000     NEG W0, W0
00098C  EA0000     NEG W0, W0
00098E  DE004F     LSR W0, #15, W0
000990  784000     MOV.B W0, W0
433:               }
000992  FA8000     ULNK
000994  060000     RETURN
434:               
435:               
436:               bool UART1_TransmitBufferIsFull(void)
437:               {
000996  FA0000     LNK #0x0
438:                   return(uart1_obj.txStatus.s.full);
000998  804920     MOV 0x924, W0
00099A  DE0048     LSR W0, #8, W0
00099C  604061     AND.B W0, #0x1, W0
00099E  FB8000     ZE W0, W0
0009A0  A7F000     BTSC W0, #15
0009A2  EA0000     NEG W0, W0
0009A4  EA0000     NEG W0, W0
0009A6  DE004F     LSR W0, #15, W0
0009A8  784000     MOV.B W0, W0
439:               }
0009AA  FA8000     ULNK
0009AC  060000     RETURN
440:               
441:               
442:               UART1_STATUS UART1_StatusGet (void)
443:               {
0009AE  FA0000     LNK #0x0
444:                   return U1STA;
0009B0  801CD0     MOV U1STA, W0
445:               }
0009B2  FA8000     ULNK
0009B4  060000     RETURN
446:               
447:               bool UART1_is_tx_done(void)
448:               {
0009B6  FA0000     LNK #0x0
449:                   return U1STAbits.TRMT;
0009B8  801CD0     MOV U1STA, W0
0009BA  DE0048     LSR W0, #8, W0
0009BC  604061     AND.B W0, #0x1, W0
0009BE  FB8000     ZE W0, W0
0009C0  A7F000     BTSC W0, #15
0009C2  EA0000     NEG W0, W0
0009C4  EA0000     NEG W0, W0
0009C6  DE004F     LSR W0, #15, W0
0009C8  784000     MOV.B W0, W0
450:               }
0009CA  FA8000     ULNK
0009CC  060000     RETURN
451:               
452:               
453:               /**
454:                 End of File
455:               */
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/mcc_generated_files/tmr1.c  -----------------
1:                 
2:                 /**
3:                   TMR1 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr1.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR1. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ64GA702
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB 	          :  MPLAB X 3.61
22:                 */
23:                
24:                /*
25:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                 */
45:                
46:                /**
47:                  Section: Included Files
48:                 */
49:                
50:                #include <xc.h>
51:                #include "tmr1.h"
52:                extern  void UART1_SendString(uint8_t*,uint8_t);
53:                extern uint8_t AT[];// = "AT\r\n";
54:                /**
55:                  Section: Data Type Definitions
56:                 */
57:                
58:                /** TMR Driver Hardware Instance Object
59:                
60:                  @Summary
61:                    Defines the object required for the maintainence of the hardware instance.
62:                
63:                  @Description
64:                    This defines the object required for the maintainence of the hardware
65:                    instance. This object exists once per hardware instance of the peripheral.
66:                
67:                  Remarks:
68:                    None.
69:                 */
70:                
71:                typedef struct _TMR_OBJ_STRUCT {
72:                    /* Timer Elapsed */
73:                    bool timerElapsed;
74:                    /*Software Counter value*/
75:                    uint8_t count;
76:                
77:                } TMR_OBJ;
78:                
79:                static TMR_OBJ tmr1_obj;
80:                
81:                /**
82:                  Section: Driver Interface
83:                 */
84:                
85:                
86:                void TMR1_Initialize(void) {
000DDC  FA0000     LNK #0x0
87:                    //TMR1 0; 
88:                    TMR1 = 0x0000;
000DDE  EF2190     CLR TMR1
89:                    //Period = 0.5 s; Frequency = 31000 Hz; PR1 15500; 
90:                    PR1 = 0x3C8C;
000DE0  23C8C0     MOV #0x3C8C, W0
000DE2  880C90     MOV W0, PR1
91:                    //TCKPS 1:1; TON enabled; TSIDL disabled; TCS External; TECS LPRC; TSYNC disabled; TGATE disabled; 
92:                    T1CON = 0x8202;
000DE4  282020     MOV #0x8202, W0
000DE6  880CA0     MOV W0, T1CON
93:                
94:                
95:                    IFS0bits.T1IF = false;
000DE8  A96088     BCLR IFS0, #3
96:                    IEC0bits.T1IE = true;
000DEA  A86098     BSET IEC0, #3
97:                
98:                    tmr1_obj.timerElapsed = false;
000DEC  209D00     MOV #0x9D0, W0
000DEE  EB4080     CLR.B W1
000DF0  784801     MOV.B W1, [W0]
99:                
100:               }
000DF2  FA8000     ULNK
000DF4  060000     RETURN
101:               
102:               void __attribute__((interrupt, no_auto_psv)) _T1Interrupt() {
000DF6  F80036     PUSH RCOUNT
000DF8  BE9F80     MOV.D W0, [W15++]
000DFA  BE9F82     MOV.D W2, [W15++]
000DFC  BE9F84     MOV.D W4, [W15++]
000DFE  BE9F86     MOV.D W6, [W15++]
000E00  FA0000     LNK #0x0
103:                   /* Check if the Timer Interrupt/Status is set */
104:               
105:                   //***User Area Begin
106:                   static volatile unsigned int CountCallBack = 0;
107:               
108:                   // callback function - called every 4th pass
109:                   if (++CountCallBack >= TMR1_INTERRUPT_TICKER_FACTOR) {
000E02  804140     MOV CountCallBack, W0
000E04  E80000     INC W0, W0
000E06  884140     MOV W0, CountCallBack
000E08  804140     MOV CountCallBack, W0
000E0A  500FE2     SUB W0, #0x2, [W15]
000E0C  360002     BRA LEU, 0xE12
110:                       // ticker function call
111:                       TMR1_CallBack();
000E0E  07002B     RCALL TMR1_CallBack
112:               
113:                       // reset ticker counter
114:                       CountCallBack = 0;
000E10  EF2828     CLR CountCallBack
115:                   }
116:               
117:                   //***User Area End
118:               
119:                   tmr1_obj.count++;
000E12  209D10     MOV #0x9D1, W0
000E14  784010     MOV.B [W0], W0
000E16  E84080     INC.B W0, W1
000E18  209D10     MOV #0x9D1, W0
000E1A  784801     MOV.B W1, [W0]
120:                   tmr1_obj.timerElapsed = true;
000E1C  209D00     MOV #0x9D0, W0
000E1E  B3C011     MOV.B #0x1, W1
000E20  784801     MOV.B W1, [W0]
121:                   IFS0bits.T1IF = false;
000E22  A96088     BCLR IFS0, #3
122:               }
000E24  FA8000     ULNK
000E26  BE034F     MOV.D [--W15], W6
000E28  BE024F     MOV.D [--W15], W4
000E2A  BE014F     MOV.D [--W15], W2
000E2C  BE004F     MOV.D [--W15], W0
000E2E  F90036     POP RCOUNT
000E30  064000     RETFIE
123:               
124:               void TMR1_Period16BitSet(uint16_t value) {
000E32  FA0002     LNK #0x2
000E34  780F00     MOV W0, [W14]
125:                   /* Update the counter values */
126:                   PR1 = value;
000E36  78009E     MOV [W14], W1
000E38  880C91     MOV W1, PR1
127:                   /* Reset the status information */
128:                   tmr1_obj.timerElapsed = false;
000E3A  209D00     MOV #0x9D0, W0
000E3C  EB4080     CLR.B W1
000E3E  784801     MOV.B W1, [W0]
129:               }
000E40  FA8000     ULNK
000E42  060000     RETURN
130:               
131:               uint16_t TMR1_Period16BitGet(void) {
000E44  FA0000     LNK #0x0
132:                   return ( PR1);
000E46  800C90     MOV PR1, W0
133:               }
000E48  FA8000     ULNK
000E4A  060000     RETURN
134:               
135:               void TMR1_Counter16BitSet(uint16_t value) {
000E4C  FA0002     LNK #0x2
000E4E  780F00     MOV W0, [W14]
136:                   /* Update the counter values */
137:                   TMR1 = value;
000E50  78009E     MOV [W14], W1
000E52  880C81     MOV W1, TMR1
138:                   /* Reset the status information */
139:                   tmr1_obj.timerElapsed = false;
000E54  209D00     MOV #0x9D0, W0
000E56  EB4080     CLR.B W1
000E58  784801     MOV.B W1, [W0]
140:               }
000E5A  FA8000     ULNK
000E5C  060000     RETURN
141:               
142:               uint16_t TMR1_Counter16BitGet(void) {
000E5E  FA0000     LNK #0x0
143:                   return ( TMR1);
000E60  800C80     MOV TMR1, W0
144:               }
000E62  FA8000     ULNK
000E64  060000     RETURN
145:               
146:               void __attribute__((weak)) TMR1_CallBack(void) {
000E66  FA0000     LNK #0x0
147:                   FLAG_T1 = 1; // Add your custom callback code here
000E68  B3C010     MOV.B #0x1, W0
000E6A  B7E85A     MOV.B WREG, FLAG_T1
148:                   UART1_SendString(AT, 3);
000E6C  B3C031     MOV.B #0x3, W1
000E6E  282220     MOV #0x8222, W0
000E70  07004B     RCALL UART1_SendString
149:               }
000E72  FA8000     ULNK
000E74  060000     RETURN
150:               
151:               void TMR1_Start(void) {
000E76  FA0000     LNK #0x0
152:                   /* Reset the status information */
153:                   tmr1_obj.timerElapsed = false;
000E78  209D00     MOV #0x9D0, W0
000E7A  EB4080     CLR.B W1
000E7C  784801     MOV.B W1, [W0]
154:               
155:                   /*Enable the interrupt*/
156:                   IEC0bits.T1IE = true;
000E7E  A86098     BSET IEC0, #3
157:               
158:                   /* Start the Timer */
159:                   T1CONbits.TON = 1;
000E80  A8E195     BSET 0x195, #7
160:               }
000E82  FA8000     ULNK
000E84  060000     RETURN
161:               
162:               void TMR1_Stop(void) {
000E86  FA0000     LNK #0x0
163:                   /* Stop the Timer */
164:                   T1CONbits.TON = false;
000E88  A9E195     BCLR 0x195, #7
165:               
166:                   /*Disable the interrupt*/
167:                   IEC0bits.T1IE = false;
000E8A  A96098     BCLR IEC0, #3
168:               }
000E8C  FA8000     ULNK
000E8E  060000     RETURN
169:               
170:               bool TMR1_GetElapsedThenClear(void) {
000E90  FA0002     LNK #0x2
171:                   bool status;
172:               
173:                   status = tmr1_obj.timerElapsed;
000E92  209D00     MOV #0x9D0, W0
000E94  784F10     MOV.B [W0], [W14]
174:               
175:                   if (status == true) {
000E96  78401E     MOV.B [W14], W0
000E98  E00400     CP0.B W0
000E9A  320003     BRA Z, 0xEA2
176:                       tmr1_obj.timerElapsed = false;
000E9C  209D00     MOV #0x9D0, W0
000E9E  EB4080     CLR.B W1
000EA0  784801     MOV.B W1, [W0]
177:                   }
178:                   return status;
000EA2  78401E     MOV.B [W14], W0
179:               }
000EA4  FA8000     ULNK
000EA6  060000     RETURN
180:               
181:               int TMR1_SoftwareCounterGet(void) {
000EA8  FA0000     LNK #0x0
182:                   return tmr1_obj.count;
000EAA  209D10     MOV #0x9D1, W0
000EAC  784010     MOV.B [W0], W0
000EAE  FB8000     ZE W0, W0
183:               }
000EB0  FA8000     ULNK
000EB2  060000     RETURN
184:               
185:               void TMR1_SoftwareCounterClear(void) {
000EB4  FA0000     LNK #0x0
186:                   tmr1_obj.count = 0;
000EB6  209D10     MOV #0x9D1, W0
000EB8  EB4080     CLR.B W1
000EBA  784801     MOV.B W1, [W0]
187:               }
000EBC  FA8000     ULNK
000EBE  060000     RETURN
188:               
189:               /**
190:                End of File
191:                */
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/mcc_generated_files/pin_manager.c  ----------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the MPLAB(c) Code Configurator device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for MPLAB(c) Code Configurator interrupts.
17:                    Generation Information : 
18:                        Product Revision  :  MPLAB(c) Code Configurator - 4.35
19:                        Device            :  PIC24FJ64GA702
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 1.32
22:                        MPLAB             :  MPLAB X 3.61
23:                
24:                    Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
25:                
26:                    Microchip licenses to you the right to use, modify, copy and distribute
27:                    Software only when embedded on a Microchip microcontroller or digital signal
28:                    controller that is integrated into your product or third party product
29:                    (pursuant to the sublicense terms in the accompanying license agreement).
30:                
31:                    You should refer to the license agreement accompanying this Software for
32:                    additional information regarding your rights and obligations.
33:                
34:                    SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                #include <xc.h>
52:                #include "pin_manager.h"
53:                
54:                /**
55:                    void PIN_MANAGER_Initialize(void)
56:                */
57:                void PIN_MANAGER_Initialize(void)
58:                {
000F4E  FA0000     LNK #0x0
59:                    /****************************************************************************
60:                     * Setting the Output Latch SFR(s)
61:                     ***************************************************************************/
62:                    LATA = 0x0000;
000F50  EF2666     CLR LATA
63:                    LATB = 0x0000;
000F52  EF267A     CLR LATB
64:                
65:                    /****************************************************************************
66:                     * Setting the GPIO Direction SFR(s)
67:                     ***************************************************************************/
68:                    TRISA = 0x001F;
000F54  2001F0     MOV #0x1F, W0
000F56  883310     MOV W0, TRISA
69:                    TRISB = 0xC5FF;
000F58  2C5FF0     MOV #0xC5FF, W0
000F5A  8833B0     MOV W0, TRISB
70:                
71:                    /****************************************************************************
72:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
73:                     ***************************************************************************/
74:                    IOCPDA = 0x0000;
000F5C  EF2674     CLR IOCPDA
75:                    IOCPDB = 0x0000;
000F5E  EF2688     CLR IOCPDB
76:                    IOCPUA = 0x0000;
000F60  EF2672     CLR IOCPUA
77:                    IOCPUB = 0x0000;
000F62  EF2686     CLR IOCPUB
78:                
79:                    /****************************************************************************
80:                     * Setting the Open Drain SFR(s)
81:                     ***************************************************************************/
82:                    ODCA = 0x0000;
000F64  EF2668     CLR ODCA
83:                    ODCB = 0x0000;
000F66  EF267C     CLR ODCB
84:                
85:                    /****************************************************************************
86:                     * Setting the Analog/Digital Configuration SFR(s)
87:                     ***************************************************************************/
88:                    ANSA = 0x000F;
000F68  2000F0     MOV #0xF, W0
000F6A  883350     MOV W0, ANSA
89:                    ANSB = 0xF20C;
000F6C  2F20C0     MOV #0xF20C, W0
000F6E  8833F0     MOV W0, ANSB
90:                
91:                
92:                    /****************************************************************************
93:                     * Set the PPS
94:                     ***************************************************************************/
95:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
000F70  800801     MOV OSCCON, W1
000F72  200BF0     MOV #0xBF, W0
000F74  608100     AND W1, W0, W2
000F76  200460     MOV #0x46, W0
000F78  200571     MOV #0x57, W1
000F7A  201003     MOV #0x100, W3
000F7C  784980     MOV.B W0, [W3]
000F7E  784981     MOV.B W1, [W3]
000F80  784982     MOV.B W2, [W3]
96:                
97:                    RPOR5bits.RP11R = 0x0003;   //RB11->UART1:U1TX;
000F82  803EF1     MOV RPOR5, W1
000F84  280FF0     MOV #0x80FF, W0
000F86  608080     AND W1, W0, W1
000F88  203000     MOV #0x300, W0
000F8A  700001     IOR W0, W1, W0
000F8C  883EF0     MOV W0, RPOR5
98:                    RPINR18bits.U1RXR = 0x000A;   //RB10->UART1:U1RX;
000F8E  803DA1     MOV RPINR18, W1
000F90  2FFC00     MOV #0xFFC0, W0
000F92  608000     AND W1, W0, W0
000F94  B300A0     IOR #0xA, W0
000F96  883DA0     MOV W0, RPINR18
99:                
100:                   __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
000F98  800800     MOV OSCCON, W0
000F9A  780100     MOV W0, W2
000F9C  A06002     BSET W2, #6
000F9E  200460     MOV #0x46, W0
000FA0  200571     MOV #0x57, W1
000FA2  201003     MOV #0x100, W3
000FA4  784980     MOV.B W0, [W3]
000FA6  784981     MOV.B W1, [W3]
000FA8  784982     MOV.B W2, [W3]
101:               
102:               }
000FAA  FA8000     ULNK
000FAC  060000     RETURN
103:               
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/mcc_generated_files/mcc.c  ------------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     mcc.c
9:                 
10:                  @Summary:
11:                    This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
17:                        Device            :  PIC24FJ64GA702
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 1.32
20:                        MPLAB             :  MPLAB X 3.61
21:                */
22:                
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    // Boot Segment Write-Protect bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    // Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSEN = OFF    // Boot Segment Control bit->No Boot Segment
51:                #pragma config GWRP = OFF    // General Segment Write-Protect bit->General Segment may be written
52:                #pragma config GSS = DISABLED    // General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    // Configuration Segment Write-Protect bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    // Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = OFF    // Alternate Interrupt Vector Table bit->Disabled AIVT
56:                
57:                // FOSCSEL
58:                #pragma config FNOSC = FRC    // Oscillator Source Selection->Internal Fast RC (FRC)
59:                #pragma config PLLMODE = DISABLED    // PLL Mode Selection->No PLL used; PLLEN bit is not available
60:                #pragma config IESO = ON    // Two-speed Oscillator Start-up Enable bit->Start up device with FRC, then switch to user-selected oscillator source
61:                
62:                // FOSC
63:                #pragma config POSCMD = NONE    // Primary Oscillator Mode Select bits->Primary Oscillator disabled
64:                #pragma config OSCIOFCN = ON    // OSC2 Pin Function bit->OSC2 is general purpose digital I/O pin
65:                #pragma config SOSCSEL = OFF    // SOSC Power Selection Configuration bits->Digital (SCLKI) mode
66:                #pragma config PLLSS = PLL_PRI    // PLL Secondary Selection Configuration bit->PLL is fed by the Primary oscillator
67:                #pragma config IOL1WAY = ON    // Peripheral pin select configuration bit->Allow only one reconfiguration
68:                #pragma config FCKSM = CSDCMD    // Clock Switching Mode bits->Both Clock switching and Fail-safe Clock Monitor are disabled
69:                
70:                // FWDT
71:                #pragma config WDTPS = PS32768    // Watchdog Timer Postscaler bits->1:32768
72:                #pragma config FWPSA = PR128    // Watchdog Timer Prescaler bit->1:128
73:                #pragma config FWDTEN = OFF    // Watchdog Timer Enable bits->WDT and SWDTEN disabled
74:                #pragma config WINDIS = OFF    // Watchdog Timer Window Enable bit->Watchdog Timer in Non-Window mode
75:                #pragma config WDTWIN = WIN25    // Watchdog Timer Window Select bits->WDT Window is 25% of WDT period
76:                #pragma config WDTCMX = WDTCLK    // WDT MUX Source Select bits->WDT clock source is determined by the WDTCLK Configuration bits
77:                #pragma config WDTCLK = LPRC    // WDT Clock Source Select bits->WDT uses LPRC
78:                
79:                // FPOR
80:                #pragma config BOREN = ON    // Brown Out Enable bit->Brown Out Enable Bit
81:                #pragma config LPCFG = OFF    // Low power regulator control->No Retention Sleep
82:                #pragma config DNVPEN = ENABLE    // Downside Voltage Protection Enable bit->Downside protection enabled using ZPBOR when BOR is inactive
83:                
84:                // FICD
85:                #pragma config ICS = PGD1    // ICD Communication Channel Select bits->Communicate on PGEC1 and PGED1
86:                #pragma config JTAGEN = OFF    // JTAG Enable bit->JTAG is disabled
87:                
88:                // FDEVOPT1
89:                #pragma config ALTCMPI = DISABLE    // Alternate Comparator Input Enable bit->C1INC, C2INC, and C3INC are on their standard pin locations
90:                #pragma config TMPRPIN = OFF    // Tamper Pin Enable bit->TMPRN pin function is disabled
91:                #pragma config SOSCHP = ON    // SOSC High Power Enable bit (valid only when SOSCSEL = 1->Enable SOSC high power mode (default)
92:                #pragma config ALTI2C1 = ALTI2CEN    // Alternate I2C pin Location->SDA1 and SCL1 on RB9 and RB8
93:                
94:                #include "mcc.h"
95:                
96:                void SYSTEM_Initialize(void)
97:                {
000FFC  FA0000     LNK #0x0
98:                    PIN_MANAGER_Initialize();
000FFE  07FFA7     RCALL PIN_MANAGER_Initialize
99:                    INTERRUPT_Initialize();
001000  07001A     RCALL INTERRUPT_Initialize
100:                   OSCILLATOR_Initialize();
001002  070004     RCALL OSCILLATOR_Initialize
101:                   TMR1_Initialize();
001004  07FEEB     RCALL TMR1_Initialize
102:                   UART1_Initialize();
001006  07FB49     RCALL UART1_Initialize
103:               }
001008  FA8000     ULNK
00100A  060000     RETURN
104:               
105:               void OSCILLATOR_Initialize(void)
106:               {
00100C  FA0000     LNK #0x0
107:                   // CF no clock failure; NOSC FRC; SOSCEN disabled; POSCEN disabled; CLKLOCK unlocked; OSWEN Switch is Complete; IOLOCK not-active; 
108:                   __builtin_write_OSCCONL((uint8_t) (0x0000 & 0x00FF));
00100E  EB0100     CLR W2
001010  200460     MOV #0x46, W0
001012  200571     MOV #0x57, W1
001014  201003     MOV #0x100, W3
001016  784980     MOV.B W0, [W3]
001018  784981     MOV.B W1, [W3]
00101A  784982     MOV.B W2, [W3]
109:                   // CPDIV 1:1; PLLEN disabled; DOZE 1:8; RCDIV FRC; DOZEN disabled; ROI disabled; 
110:                   CLKDIV = 0x3000;
00101C  230000     MOV #0x3000, W0
00101E  880810     MOV W0, CLKDIV
111:                   // STOR disabled; STORPOL Interrupt when STOR is 1; STSIDL disabled; STLPOL Interrupt when STLOCK is 1; STLOCK disabled; STSRC SOSC; STEN disabled; TUN Center frequency; 
112:                   OSCTUN = 0x0000;
001020  EF2106     CLR OSCTUN
113:                   // ROEN disabled; ROSEL FOSC; ROSIDL disabled; ROSWEN disabled; ROOUT disabled; ROSLP disabled; 
114:                   REFOCONL = 0x0000;
001022  EF2168     CLR REFOCONL
115:                   // RODIV 0; 
116:                   REFOCONH = 0x0000;
001024  EF216A     CLR REFOCONH
117:                   // ROTRIM 0; 
118:                   REFOTRIML = 0x0000;
001026  EF216C     CLR REFOTRIML
119:                   // DCOTUN 0; 
120:                   DCOTUN = 0x0000;
001028  EF2108     CLR DCOTUN
121:                   // DCOFSEL 8; DCOEN disabled; 
122:                   DCOCON = 0x0700;
00102A  207000     MOV #0x700, W0
00102C  880850     MOV W0, DCOCON
123:                   // DIV 0; 
124:                   OSCDIV = 0x0000;
00102E  EF210C     CLR OSCDIV
125:                   // TRIM 0; 
126:                   OSCFDIV = 0x0000;
001030  EF210E     CLR OSCFDIV
127:               }
001032  FA8000     ULNK
001034  060000     RETURN
128:               
129:               /**
130:                End of File
131:               */
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/mcc_generated_files/interrupt_manager.c  ----
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.45
18:                        Device            :  PIC24FJ64GA702
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.32
21:                        MPLAB             :  MPLAB X 3.61
22:                */
23:                /*
24:                    (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
001036  FA0000     LNK #0x0
55:                    //    TI: T1 - Timer1
56:                    //    Priority: 7
57:                        IPC0bits.T1IP = 1;
001038  800541     MOV IPC0, W1
00103A  28FFF0     MOV #0x8FFF, W0
00103C  608000     AND W1, W0, W0
00103E  A0C000     BSET W0, #12
001040  880540     MOV W0, IPC0
58:                    //    UERI: U1E - UART1 Error
59:                    //    Priority: 6
60:                        IPC16bits.U1ERIP = 6;
001042  800641     MOV IPC16, W1
001044  2FF8F0     MOV #0xFF8F, W0
001046  608080     AND W1, W0, W1
001048  200600     MOV #0x60, W0
00104A  700001     IOR W0, W1, W0
00104C  880640     MOV W0, IPC16
61:                    //    UTXI: U1TX - UART1 Transmitter
62:                    //    Priority: 1
63:                        IPC3bits.U1TXIP = 6;
00104E  800571     MOV IPC3, W1
001050  2FFF80     MOV #0xFFF8, W0
001052  608000     AND W1, W0, W0
001054  B30060     IOR #0x6, W0
001056  880570     MOV W0, IPC3
64:                    //    URXI: U1RX - UART1 Receiver
65:                    //    Priority: 5
66:                        IPC2bits.U1RXIP = 5;
001058  800561     MOV IPC2, W1
00105A  28FFF0     MOV #0x8FFF, W0
00105C  608080     AND W1, W0, W1
00105E  250000     MOV #0x5000, W0
001060  700001     IOR W0, W1, W0
001062  880560     MOV W0, IPC2
67:                
68:                }
001064  FA8000     ULNK
001066  060000     RETURN
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/main.c  -------------------------------------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 20171221, 12:54
6:                  */
7:                 
8:                 #include <xc.h>
9:                 #include <stdint.h>
10:                #include <stdio.h>
11:                #include <stdlib.h>
12:                #include "SerialBuffer.h"
13:                #include "mcc_generated_files/mcc.h"
14:                #include "M6310.h"
15:                
16:                #define LED_G LATBbits.LATB12
17:                void LED_Twinkle(void);
18:                void OpenM6310(void);
19:                void UART1_SendString(uint8_t* tmp);
20:                
21:                uint8_t FLAG_T1;
22:                //uint8_t AT[] = "AT\n";
23:                
24:                /*
25:                 * 
26:                 */
27:                int main(void) {
000EC0  FA0000     LNK #0x0
28:                    //    uint8_t bytes = 0;
29:                    SYSTEM_Initialize();
000EC2  07009C     RCALL SYSTEM_Initialize
30:                    //    TRISBbits.TRISB12 = 0;
31:                    //    return (EXIT_SUCCESS);
32:                    UART1_SetRxInterruptHandler(LED_Twinkle);
000EC4  20EF40     MOV #0xEF4, W0
000EC6  07FC4C     RCALL UART1_SetRxInterruptHandler
33:                    IEC0bits.U1TXIE = false;
000EC8  A98099     BCLR 0x99, #4
34:                    //    UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
35:                    //    TMR1_Stop();
36:                    OpenM6310();
000ECA  070019     RCALL OpenM6310
37:                    TMR1_Start();
000ECC  07FFD4     RCALL TMR1_Start
38:                    while (1) {
39:                        //        if (PORTBbits.RB12)
40:                        //            LED_G = 0;
41:                //        M6310_DialingIsERR();
42:                                //        bytes = UART1_WriteBuffer(AT, 4);
43:                                //        UART1_Write(bytes);
44:                                //        LED_G ^= 1;
45:                                //        UART1_SendString(AT, 4);
46:                        while (!FLAG_T1);
000ECE  000000     NOP
000ED0  BFC85A     MOV.B FLAG_T1, WREG
000ED2  E00400     CP0.B W0
000ED4  32FFFD     BRA Z, 0xED0
000EF2  37FFEE     BRA 0xED0
47:                        //        while(FLAG)
48:                        FLAG_T1 = 0;
000ED6  EF685A     CLR.B FLAG_T1
49:                        //        TMR1 = 0;
50:                        LED_G ^= 1;
000ED8  8033D0     MOV LATB, W0
000EDA  DE004C     LSR W0, #12, W0
000EDC  604061     AND.B W0, #0x1, W0
000EDE  A20400     BTG.B W0, #0
000EE0  604061     AND.B W0, #0x1, W0
000EE2  FB8000     ZE W0, W0
000EE4  600061     AND W0, #0x1, W0
000EE6  DD004C     SL W0, #12, W0
000EE8  8033D1     MOV LATB, W1
000EEA  A1C001     BCLR W1, #12
000EEC  700001     IOR W0, W1, W0
000EEE  8833D0     MOV W0, LATB
51:                    }
000EF0  000000     NOP
000EF2  37FFEE     BRA 0xED0
52:                }
53:                
54:                /*
55:                void Timer0_Init(void)
56:                {
57:                    T1CONbits.TON=0;//1
58:                    T1CONbits.TECS=0b10;//LPRC 
59:                    TMR1=0;
60:                    PR1=0x7918;//1s
61:                    IFS0bits.T1IF=0;
62:                //    IECbits.
63:                //    IPCbits.
64:                }
65:                 */
66:                void LED_Twinkle(void) {
000EF4  FA0000     LNK #0x0
67:                    //    uint8_t tmp[20], bytes;
68:                    LED_G = 1;
000EF6  A8867B     BSET 0x67B, #4
69:                    BufferWrite_UART1();
000EF8  07FD6A     RCALL BufferWrite_UART1
70:                    //    UART1_Receive_ISR();
71:                    //    bytes = UART1_ReadBuffer(tmp, 10);
72:                    //    UART1_Read();
73:                    //    IFS0bits.U1RXIF = 0;
74:                }
000EFA  FA8000     ULNK
000EFC  060000     RETURN
75:                
76:                void OpenM6310(void) {//UART1
000EFE  FA0000     LNK #0x0
77:                    GPRS_EN_SetHigh(); //
000F00  A8267B     BSET 0x67B, #1
78:                    /********************/
79:                    PWRKEY_SetHigh(); //
000F02  A8A67B     BSET 0x67B, #5
80:                
81:                    //    TMR1_Start();
82:                    //    while (!IFS0bits.T1IF); //3s
83:                    //    IFS0bits.T1IF = 0;
84:                    //    while (!IFS0bits.T1IF);
85:                    //    IFS0bits.T1IF = 0;
86:                    //    while (!IFS0bits.T1IF);
87:                    //    IFS0bits.T1IF = 0;
88:                    //    while (!FLAG_T1);
89:                    //    FLAG_T1 = 0;
90:                    //    while (!FLAG_T1);
91:                    //    FLAG_T1 = 0;
92:                    //    while (!FLAG_T1);
93:                    //    FLAG_T1 = 0;
94:                    //    TMR1_Stop();
95:                
96:                    //    PWRKEY_SetLow(); //
97:                }
000F04  FA8000     ULNK
000F06  060000     RETURN
98:                
99:                void UART1_SendString(uint8_t* tmp) {
000F08  FA0002     LNK #0x2
000F0A  780F00     MOV W0, [W14]
100:                   //    uint8_t byte = 0;
101:                   while (*tmp != '\0') {
000F0C  37000B     BRA 0xF24
000F24  78001E     MOV [W14], W0
000F26  784010     MOV.B [W0], W0
000F28  E00400     CP0.B W0
000F2A  3AFFF1     BRA NZ, 0xF0E
102:                       U1TXREG = *tmp;
000F0E  78001E     MOV [W14], W0
000F10  784010     MOV.B [W0], W0
000F12  FB8000     ZE W0, W0
000F14  881CE0     MOV W0, U1TXREG
103:                       while (!U1STAbits.TRMT); //
000F16  000000     NOP
000F18  801CD1     MOV U1STA, W1
000F1A  201000     MOV #0x100, W0
000F1C  608000     AND W1, W0, W0
000F1E  E00000     CP0 W0
000F20  32FFFB     BRA Z, 0xF18
104:                       tmp += 1;
000F22  E80F1E     INC [W14], [W14]
105:                   }
106:               }
000F2C  FA8000     ULNK
000F2E  060000     RETURN
107:               
108:               void U1Rx4Byte(void) {//4
000F30  FA0002     LNK #0x2
109:                   uint8_t cnt;
110:                   for (cnt = 0; cnt < 4; cnt++)//
000F32  EB4000     CLR.B W0
000F34  784F00     MOV.B W0, [W14]
000F36  370006     BRA 0xF44
000F42  E84F1E     INC.B [W14], [W14]
000F44  78401E     MOV.B [W14], W0
000F46  504FE3     SUB.B W0, #0x3, [W15]
000F48  36FFF7     BRA LEU, 0xF38
111:                       if (U1STAbits.URXDA) //
000F38  801CD0     MOV U1STA, W0
000F3A  600061     AND W0, #0x1, W0
000F3C  E00000     CP0 W0
000F3E  320001     BRA Z, 0xF42
112:                           BufferWrite_UART1();
000F40  07FD46     RCALL BufferWrite_UART1
113:               }
000F4A  FA8000     ULNK
000F4C  060000     RETURN
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**************************************************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 
25:                Input: 12 
26:                Output: 
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
0009CE  FA0002     LNK #0x2
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {// 
0009D0  BFC850     MOV.B bufferWptr_uart1, WREG
0009D2  FB8080     ZE W0, W1
0009D4  BFC851     MOV.B bufferRptr_uart1, WREG
0009D6  FB8000     ZE W0, W0
0009D8  E90000     DEC W0, W0
0009DA  508F80     SUB W1, W0, [W15]
0009DC  3A0003     BRA NZ, 0x9E4
31:                        tmp = U1RXREG; //
0009DE  801CF0     MOV U1RXREG, W0
0009E0  784F00     MOV.B W0, [W14]
32:                        return;
0009E2  37000C     BRA 0x9FC
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
0009E4  BFC850     MOV.B bufferWptr_uart1, WREG
0009E6  FB8000     ZE W0, W0
0009E8  801CF1     MOV U1RXREG, W1
0009EA  784101     MOV.B W1, W2
0009EC  2085C1     MOV #0x85C, W1
0009EE  787082     MOV.B W2, [W1+W0]
35:                    bufferWptr_uart1++;
0009F0  BFC850     MOV.B bufferWptr_uart1, WREG
0009F2  E84000     INC.B W0, W0
0009F4  B7E850     MOV.B WREG, bufferWptr_uart1
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
0009F6  BFC850     MOV.B bufferWptr_uart1, WREG
0009F8  B243F0     AND.B #0x3F, W0
0009FA  B7E850     MOV.B WREG, bufferWptr_uart1
37:                }
0009FC  FA8000     ULNK
0009FE  060000     RETURN
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 
42:                Input: 12 
43:                Output: 
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
000A00  FA0002     LNK #0x2
46:                    uint8_t tmp = 0;
000A02  EB4000     CLR.B W0
000A04  784F00     MOV.B W0, [W14]
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {// 
000A06  BFC852     MOV.B bufferWptr_uart2, WREG
000A08  FB8080     ZE W0, W1
000A0A  BFC853     MOV.B bufferRptr_uart2, WREG
000A0C  FB8000     ZE W0, W0
000A0E  E90000     DEC W0, W0
000A10  508F80     SUB W1, W0, [W15]
000A12  3A0003     BRA NZ, 0xA1A
48:                        tmp = U2RXREG; //
000A14  801DA0     MOV U2RXREG, W0
000A16  784F00     MOV.B W0, [W14]
49:                        return;
000A18  37000C     BRA 0xA32
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
000A1A  BFC852     MOV.B bufferWptr_uart2, WREG
000A1C  FB8000     ZE W0, W0
000A1E  801DA1     MOV U2RXREG, W1
000A20  784101     MOV.B W1, W2
000A22  2089C1     MOV #0x89C, W1
000A24  787082     MOV.B W2, [W1+W0]
52:                    bufferWptr_uart2++;
000A26  BFC852     MOV.B bufferWptr_uart2, WREG
000A28  E84000     INC.B W0, W0
000A2A  B7E852     MOV.B WREG, bufferWptr_uart2
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
000A2C  BFC852     MOV.B bufferWptr_uart2, WREG
000A2E  B243F0     AND.B #0x3F, W0
000A30  B7E852     MOV.B WREG, bufferWptr_uart2
54:                }
000A32  FA8000     ULNK
000A34  060000     RETURN
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 
59:                Input: 12 
60:                Output: 
61:                 *************************************/
62:                //void BufferWrite_UART3(void) {
63:                //    uint8_t tmp = 0;
64:                //    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {// 
65:                //        tmp = U3RXREG; //
66:                //        return;
67:                //    }
68:                //    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
69:                //    bufferWptr_uart3++;
70:                //    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
71:                //}
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 
76:                Input:  
77:                Output: 10
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
000A36  FA0002     LNK #0x2
000A38  780F00     MOV W0, [W14]
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
000A3A  208511     MOV #0x851, W1
000A3C  784091     MOV.B [W1], W1
000A3E  BFC850     MOV.B bufferWptr_uart1, WREG
000A40  50CF80     SUB.B W1, W0, [W15]
000A42  3A0002     BRA NZ, 0xA48
81:                        return 0;
000A44  EB4000     CLR.B W0
000A46  37000D     BRA 0xA62
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
000A48  BFC851     MOV.B bufferRptr_uart1, WREG
000A4A  FB8000     ZE W0, W0
000A4C  2085C1     MOV #0x85C, W1
000A4E  7840E1     MOV.B [W1+W0], W1
000A50  78001E     MOV [W14], W0
000A52  784801     MOV.B W1, [W0]
84:                    bufferRptr_uart1++;
000A54  BFC851     MOV.B bufferRptr_uart1, WREG
000A56  E84000     INC.B W0, W0
000A58  B7E851     MOV.B WREG, bufferRptr_uart1
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
000A5A  BFC851     MOV.B bufferRptr_uart1, WREG
000A5C  B243F0     AND.B #0x3F, W0
000A5E  B7E851     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
000A60  B3C010     MOV.B #0x1, W0
87:                }
000A62  FA8000     ULNK
000A64  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 
92:                Input:  
93:                Output: 10
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
000A66  FA0002     LNK #0x2
000A68  780F00     MOV W0, [W14]
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
000A6A  208531     MOV #0x853, W1
000A6C  784091     MOV.B [W1], W1
000A6E  BFC852     MOV.B bufferWptr_uart2, WREG
000A70  50CF80     SUB.B W1, W0, [W15]
000A72  3A0007     BRA NZ, 0xA82
97:                        if (U2STAbits.OERR)
000A74  801D80     MOV U2STA, W0
000A76  600062     AND W0, #0x2, W0
000A78  E00000     CP0 W0
000A7A  320001     BRA Z, 0xA7E
98:                            U2STAbits.OERR = 0; //FIFO
000A7C  A923B0     BCLR U2STA, #1
99:                        return 0;
000A7E  EB4000     CLR.B W0
000A80  37000D     BRA 0xA9C
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
000A82  BFC853     MOV.B bufferRptr_uart2, WREG
000A84  FB8000     ZE W0, W0
000A86  2089C1     MOV #0x89C, W1
000A88  7840E1     MOV.B [W1+W0], W1
000A8A  78001E     MOV [W14], W0
000A8C  784801     MOV.B W1, [W0]
102:                   bufferRptr_uart2++;
000A8E  BFC853     MOV.B bufferRptr_uart2, WREG
000A90  E84000     INC.B W0, W0
000A92  B7E853     MOV.B WREG, bufferRptr_uart2
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
000A94  BFC853     MOV.B bufferRptr_uart2, WREG
000A96  B243F0     AND.B #0x3F, W0
000A98  B7E853     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
000A9A  B3C010     MOV.B #0x1, W0
106:               }
000A9C  FA8000     ULNK
000A9E  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 
111:               Input:  
112:               Output: 10
113:                *************************************/
114:               //bool BufferRead_UART3(uint8_t *data) {
115:               //    if (bufferRptr_uart3 == bufferWptr_uart3) {
116:               //        if (U3STAbits.OERR)
117:               //            U3STAbits.OERR = 0; //FIFO
118:               //        return 0;
119:               //    }
120:               //    *data = Buffer_uart3[bufferRptr_uart3];
121:               //    bufferRptr_uart3++;
122:               //    bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
123:               //    //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:               //    return 1;
125:               //}
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 
130:               Input: 
131:               Output: 
132:               Notice256    
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//
000AA0  FA0008     LNK #0x8
000AA2  980730     MOV W0, [W14+6]
135:                   bool IsFind = false; //
000AA4  EB4000     CLR.B W0
000AA6  784F00     MOV.B W0, [W14]
136:                   uint8_t cnt = 0/**/, cnt1 = 0/**/, cnt2/**/, /*offset,*/ byte = 0;
000AA8  EB4000     CLR.B W0
000AAA  984710     MOV.B W0, [W14+1]
000AAC  EB4000     CLR.B W0
000AAE  984720     MOV.B W0, [W14+2]
000AB0  EB4000     CLR.B W0
000AB2  984740     MOV.B W0, [W14+4]
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//0
000AB4  90003E     MOV [W14+6], W0
000AB6  904060     MOV.B [W0+6], W0
000AB8  E00400     CP0.B W0
000ABA  320004     BRA Z, 0xAC4
000ABC  90003E     MOV [W14+6], W0
000ABE  904020     MOV.B [W0+2], W0
000AC0  E00400     CP0.B W0
000AC2  3A0036     BRA NZ, 0xB30
139:                       return false; //
000AC4  EB4000     CLR.B W0
000AC6  3700AD     BRA 0xC22
140:               
141:                   while (cnt < strcmp->Source_len) {
000B30  000000     NOP
000B32  90003E     MOV [W14+6], W0
000B34  9040A0     MOV.B [W0+2], W1
000B36  90401E     MOV.B [W14+1], W0
000B38  50CF80     SUB.B W1, W0, [W15]
000B3A  3EFFC6     BRA GTU, 0xAC8
000B3C  370001     BRA 0xB40
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//==head           
000AC8  90003E     MOV [W14+6], W0
000ACA  780090     MOV [W0], W1
000ACC  90401E     MOV.B [W14+1], W0
000ACE  FB8000     ZE W0, W0
000AD0  408000     ADD W1, W0, W0
000AD2  784090     MOV.B [W0], W1
000AD4  90003E     MOV [W14+6], W0
000AD6  900020     MOV [W0+4], W0
000AD8  784010     MOV.B [W0], W0
000ADA  50CF80     SUB.B W1, W0, [W15]
000ADC  3A0022     BRA NZ, 0xB22
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//               
000ADE  B3C010     MOV.B #0x1, W0
000AE0  984720     MOV.B W0, [W14+2]
000AE2  37001A     BRA 0xB18
000B0A  90402E     MOV.B [W14+2], W0
000B0C  E84000     INC.B W0, W0
000B0E  984720     MOV.B W0, [W14+2]
000B10  370003     BRA 0xB18
000B18  90003E     MOV [W14+6], W0
000B1A  9040E0     MOV.B [W0+6], W1
000B1C  90402E     MOV.B [W14+2], W0
000B1E  50CF80     SUB.B W1, W0, [W15]
000B20  3EFFE1     BRA GTU, 0xAE4
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//
000AE4  90003E     MOV [W14+6], W0
000AE6  780090     MOV [W0], W1
000AE8  90401E     MOV.B [W14+1], W0
000AEA  FB8100     ZE W0, W2
000AEC  90402E     MOV.B [W14+2], W0
000AEE  FB8000     ZE W0, W0
000AF0  410000     ADD W2, W0, W0
000AF2  408000     ADD W1, W0, W0
000AF4  784090     MOV.B [W0], W1
000AF6  90003E     MOV [W14+6], W0
000AF8  900120     MOV [W0+4], W2
000AFA  90402E     MOV.B [W14+2], W0
000AFC  FB8000     ZE W0, W0
000AFE  410000     ADD W2, W0, W0
000B00  784010     MOV.B [W0], W0
000B02  50CF80     SUB.B W1, W0, [W15]
000B04  3A0006     BRA NZ, 0xB12
145:                                   IsFind = true;
000B06  B3C010     MOV.B #0x1, W0
000B08  784F00     MOV.B W0, [W14]
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
000B12  EB4000     CLR.B W0
000B14  784F00     MOV.B W0, [W14]
149:                                   break;
000B16  370005     BRA 0xB22
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //
000B22  78401E     MOV.B [W14], W0
000B24  E00400     CP0.B W0
000B26  3A000B     BRA NZ, 0xB3E
000B3E  000000     NOP
154:                       cnt++; //1
000B28  90401E     MOV.B [W14+1], W0
000B2A  E84000     INC.B W0, W0
000B2C  984710     MOV.B W0, [W14+1]
000B2E  370001     BRA 0xB32
155:                   }
156:               
157:                   if (IsFind) {//
000B40  78401E     MOV.B [W14], W0
000B42  E00400     CP0.B W0
000B44  32006A     BRA Z, 0xC1A
158:                       if (strcmp->Get_len < strcmp->Check_len) {
000B46  90003E     MOV [W14+6], W0
000B48  9048A0     MOV.B [W0+10], W1
000B4A  90003E     MOV [W14+6], W0
000B4C  904060     MOV.B [W0+6], W0
000B4E  50CF80     SUB.B W1, W0, [W15]
000B50  31001A     BRA C, 0xB86
159:                           byte = strcmp->Get_len; //,
000B52  90003E     MOV [W14+6], W0
000B54  9048A0     MOV.B [W0+10], W1
000B56  984741     MOV.B W1, [W14+4]
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //
000B58  EB4000     CLR.B W0
000B5A  984730     MOV.B W0, [W14+3]
000B5C  37000F     BRA 0xB7C
000B76  90403E     MOV.B [W14+3], W0
000B78  E84000     INC.B W0, W0
000B7A  984730     MOV.B W0, [W14+3]
000B7C  9040BE     MOV.B [W14+3], W1
000B7E  90404E     MOV.B [W14+4], W0
000B80  50CF80     SUB.B W1, W0, [W15]
000B82  39FFED     BRA NC, 0xB5E
000B84  370045     BRA 0xC10
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
000B5E  90003E     MOV [W14+6], W0
000B60  9000C0     MOV [W0+8], W1
000B62  90403E     MOV.B [W14+3], W0
000B64  FB8000     ZE W0, W0
000B66  408000     ADD W1, W0, W0
000B68  9000BE     MOV [W14+6], W1
000B6A  900121     MOV [W1+4], W2
000B6C  9040BE     MOV.B [W14+3], W1
000B6E  FB8081     ZE W1, W1
000B70  410081     ADD W2, W1, W1
000B72  784091     MOV.B [W1], W1
000B74  784801     MOV.B W1, [W0]
162:                       } else {//
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//
000B86  90003E     MOV [W14+6], W0
000B88  904020     MOV.B [W0+2], W0
000B8A  FB8080     ZE W0, W1
000B8C  90401E     MOV.B [W14+1], W0
000B8E  FB8000     ZE W0, W0
000B90  508080     SUB W1, W0, W1
000B92  90003E     MOV [W14+6], W0
000B94  904820     MOV.B [W0+10], W0
000B96  FB8000     ZE W0, W0
000B98  508F80     SUB W1, W0, [W15]
000B9A  3D0020     BRA GE, 0xBDC
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //
000B9C  EB4000     CLR.B W0
000B9E  984730     MOV.B W0, [W14+3]
000BA0  370012     BRA 0xBC6
000BC0  90403E     MOV.B [W14+3], W0
000BC2  E84000     INC.B W0, W0
000BC4  984730     MOV.B W0, [W14+3]
000BC6  90403E     MOV.B [W14+3], W0
000BC8  FB8080     ZE W0, W1
000BCA  90003E     MOV [W14+6], W0
000BCC  904020     MOV.B [W0+2], W0
000BCE  FB8100     ZE W0, W2
000BD0  90401E     MOV.B [W14+1], W0
000BD2  FB8000     ZE W0, W0
000BD4  510000     SUB W2, W0, W0
000BD6  508F80     SUB W1, W0, [W15]
000BD8  35FFE4     BRA LT, 0xBA2
000BDA  37001A     BRA 0xC10
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
000BA2  90003E     MOV [W14+6], W0
000BA4  9000C0     MOV [W0+8], W1
000BA6  90403E     MOV.B [W14+3], W0
000BA8  FB8000     ZE W0, W0
000BAA  408000     ADD W1, W0, W0
000BAC  9000BE     MOV [W14+6], W1
000BAE  780111     MOV [W1], W2
000BB0  90409E     MOV.B [W14+1], W1
000BB2  FB8181     ZE W1, W3
000BB4  9040BE     MOV.B [W14+3], W1
000BB6  FB8081     ZE W1, W1
000BB8  418081     ADD W3, W1, W1
000BBA  410081     ADD W2, W1, W1
000BBC  784091     MOV.B [W1], W1
000BBE  784801     MOV.B W1, [W0]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //
000BDC  EB4000     CLR.B W0
000BDE  984730     MOV.B W0, [W14+3]
000BE0  370012     BRA 0xC06
000C00  90403E     MOV.B [W14+3], W0
000C02  E84000     INC.B W0, W0
000C04  984730     MOV.B W0, [W14+3]
000C06  90003E     MOV [W14+6], W0
000C08  9048A0     MOV.B [W0+10], W1
000C0A  90403E     MOV.B [W14+3], W0
000C0C  50CF80     SUB.B W1, W0, [W15]
000C0E  31FFE9     BRA C, 0xBE2
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
000BE2  90003E     MOV [W14+6], W0
000BE4  9000C0     MOV [W0+8], W1
000BE6  90403E     MOV.B [W14+3], W0
000BE8  FB8000     ZE W0, W0
000BEA  408000     ADD W1, W0, W0
000BEC  9000BE     MOV [W14+6], W1
000BEE  780111     MOV [W1], W2
000BF0  90409E     MOV.B [W14+1], W1
000BF2  FB8181     ZE W1, W3
000BF4  9040BE     MOV.B [W14+3], W1
000BF6  FB8081     ZE W1, W1
000BF8  418081     ADD W3, W1, W1
000BFA  410081     ADD W2, W1, W1
000BFC  784091     MOV.B [W1], W1
000BFE  784801     MOV.B W1, [W0]
169:                       }
170:                       strcmp->Real_len = cnt2; //
000C10  90003E     MOV [W14+6], W0
000C12  9040BE     MOV.B [W14+3], W1
000C14  984831     MOV.B W1, [W0+11]
171:                       return true;
000C16  B3C010     MOV.B #0x1, W0
000C18  370004     BRA 0xC22
172:                   }
173:                   strcmp->Real_len = 0;
000C1A  90003E     MOV [W14+6], W0
000C1C  EB4080     CLR.B W1
000C1E  984831     MOV.B W1, [W0+11]
174:                   return false;
000C20  EB4000     CLR.B W0
175:               }
000C22  FA8000     ULNK
000C24  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 
180:               Input: UARTn
181:               Output: 
182:               Notice256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data, uint8_t bytes) {//, const uint8_t get_size) {//'\0'
000C26  FA0008     LNK #0x8
000C28  980710     MOV W0, [W14+2]
000C2A  980721     MOV W1, [W14+4]
000C2C  984762     MOV.B W2, [W14+6]
185:                   uint8_t byte = 0;
000C2E  EB4000     CLR.B W0
000C30  784F00     MOV.B W0, [W14]
186:                   while (bytes > byte) {
000C32  370008     BRA 0xC44
000C44  90406E     MOV.B [W14+6], W0
000C46  504F9E     SUB.B W0, [W14], [W15]
000C48  3EFFF5     BRA GTU, 0xC34
000C4A  370001     BRA 0xC4E
187:                       if (f_uart(Get_Data + byte))
000C34  FB801E     ZE [W14], W0
000C36  9000AE     MOV [W14+4], W1
000C38  408000     ADD W1, W0, W0
000C3A  90009E     MOV [W14+2], W1
000C3C  010001     CALL W1
000C3E  E00400     CP0.B W0
000C40  320005     BRA Z, 0xC4C
188:                           byte++;
000C42  E84F1E     INC.B [W14], [W14]
189:                       else
190:                           break;
000C4C  000000     NOP
191:                   }
192:                   return byte;
000C4E  78401E     MOV.B [W14], W0
193:               }
000C50  FA8000     ULNK
000C52  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 
198:               Input: 
199:               Output: 
200:               Notice
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
000C54  FA0004     LNK #0x4
000C56  980710     MOV W0, [W14+2]
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
000C58  000000     NOP
000C5A  90009E     MOV [W14+2], W1
000C5C  78000E     MOV W14, W0
000C5E  010001     CALL W1
000C60  E00400     CP0.B W0
000C62  3AFFFB     BRA NZ, 0xC5A
205:               }
000C64  FA8000     ULNK
000C66  060000     RETURN
206:               //UARTGetData
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//505050
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/M6310.c  ------------------------------------
1:                 #include "M6310.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 #include <stdlib.h>
5:                 #include  <libq.h>
6:                 //#include "WGC.h"
7:                 #include "mcc_generated_files/mcc.h"
8:                 #include "Common.h"
9:                 //#include "includes.h"
10:                //#include <stdbool.h>
11:                //#include "cJSON.h"
12:                extern void UART1_SendString(uint8_t* tmp);
13:                extern void U1Rx4Byte(void);
14:                //extern OS_EVENT* sem1, *sem2; //
15:                
16:                //struct ATCommand {
17:                //const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
18:                const uint8_t D0[] = {"AT&D0\r\n"}; //{"AT&K3\r\n"};
19:                const uint8_t AT[] = {"AT\r\n"};
20:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
21:                const uint8_t OK[] = {"OK"};
22:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
23:                const uint8_t READY[] = {"+CPIN: READY"};
24:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
25:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
26:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
27:                const uint8_t CGATT[] = {"AT+CGATT?\r\n"};
28:                const uint8_t _5[] = {",5"};
29:                const uint8_t _1[] = {",1"};
30:                //const uint8_t CSCA[] = {"AT+CSCA\r\n"};
31:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
32:                const uint8_t QICSGP[] = {"AT+QICSGP=1,\"CMNET\"\r\n"};
33:                const uint8_t QIMODE[] = {"AT+QIMODE=1\r\n"};
34:                const uint8_t QITCFG[] = {"AT+QITCFG=3,2,512,1\r\n"};
35:                //uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.140.140\",11811\r\n\n"};
36:                uint8_t KTCPCFG1[] = {"AT+QIOPEN=\"TCP\",\"183.246.74.68\",\"5070\"\r\n"};
37:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
38:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//ONENET
39:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
40:                const uint8_t CONNECT[] = {"CONNECT"};
41:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
42:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
43:                
44:                
45:                //static bool M6310SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
46:                
47:                void M6310_Init(void) {
000C68  FA0000     LNK #0x0
48:                    //
49:                    //    PWRON_TRIS = 0; //PWN_ON 6528
50:                    //    PWR_TRIS = 0; //6528
51:                    //    DSR_TRIS = 0; //    
52:                    //    DTR_TRIS = 0; //
53:                    //    RTS_TRIS = 0; //
54:                    //    CTS_TRIS = 0; //  
55:                    //    PWR = 0;
56:                    //    PWRON = 0;
57:                    //    CTS = 0;
58:                    //    RTS = 0;
59:                    //    DSR = 0;
60:                    //    DTR = 0;
61:                    //    UART2_Init();
62:                    //    GPRS_EN_SetHigh(); //
63:                    //    /********************/
64:                    //    PWRKEY_SetHigh();
65:                }
000C6A  FA8000     ULNK
000C6C  060000     RETURN
66:                
67:                /*ss**/
68:                static bool M6310SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
000C6E  FA0048     LNK #0x48
000C70  982700     MOV W0, [W14+64]
000C72  982711     MOV W1, [W14+66]
000C74  982722     MOV W2, [W14+68]
000C76  98C763     MOV.B W3, [W14+70]
000C78  98C774     MOV.B W4, [W14+71]
69:                    uint8_t cnt_tmp = 0;
000C7A  EB4000     CLR.B W0
000C7C  784F00     MOV.B W0, [W14]
70:                    bool b_sta = false;
000C7E  EB4000     CLR.B W0
000C80  984710     MOV.B W0, [W14+1]
71:                    StrCmp stcp;
72:                    uint8_t tmp[50];
73:                    do {
74:                        cnt_tmp += 1;
000C82  E84F1E     INC.B [W14], [W14]
75:                        UART1_SendString((uint8_t*) ss); //AT                               
000C84  90200E     MOV [W14+64], W0
000C86  070140     RCALL UART1_SendString
76:                        Delay1s(3); //(0, 0, 3, 0); //1s
000C88  B3C030     MOV.B #0x3, W0
000C8A  07FC4B     RCALL Delay1s
77:                        U1Rx4Byte();
000C8C  070151     RCALL U1Rx4Byte
78:                        stcp.SourceData = tmp;
000C8E  47006E     ADD W14, #0xE, W0
000C90  980710     MOV W0, [W14+2]
79:                        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 50); //mark
000C92  90001E     MOV [W14+2], W0
000C94  B3C322     MOV.B #0x32, W2
000C96  780080     MOV W0, W1
000C98  20A660     MOV #0xA66, W0
000C9A  07FFC5     RCALL UARTGetData
000C9C  984740     MOV.B W0, [W14+4]
80:                        stcp.CheckData = (uint8_t*) cs;
000C9E  90209E     MOV [W14+66], W1
000CA0  980731     MOV W1, [W14+6]
81:                        stcp.Check_len = csl;
000CA2  90C0EE     MOV.B [W14+70], W1
000CA4  984F01     MOV.B W1, [W14+8]
82:                        stcp.GetData = NULL;
000CA6  EB0000     CLR W0
000CA8  980750     MOV W0, [W14+10]
83:                        stcp.Get_len = 0;
000CAA  EB4000     CLR.B W0
000CAC  984F40     MOV.B W0, [W14+12]
84:                        stcp.Real_len = 0;
000CAE  EB4000     CLR.B W0
000CB0  984F50     MOV.B W0, [W14+13]
85:                
86:                        if (UARTDataIsRight(&stcp)) {
000CB2  E8800E     INC2 W14, W0
000CB4  07FEF5     RCALL UARTDataIsRight
000CB6  E00400     CP0.B W0
000CB8  320003     BRA Z, 0xCC0
87:                            b_sta = true;
000CBA  B3C010     MOV.B #0x1, W0
000CBC  984710     MOV.B W0, [W14+1]
88:                            break;
000CBE  37000F     BRA 0xCDE
89:                        }
90:                
91:                        if (cs1 != NULL) {//NULL
000CC0  90202E     MOV [W14+68], W0
000CC2  E00000     CP0 W0
000CC4  320009     BRA Z, 0xCD8
92:                            stcp.CheckData = (uint8_t*) cs1;
000CC6  9020AE     MOV [W14+68], W1
000CC8  980731     MOV W1, [W14+6]
93:                            if (UARTDataIsRight(&stcp)) {
000CCA  E8800E     INC2 W14, W0
000CCC  07FEE9     RCALL UARTDataIsRight
000CCE  E00400     CP0.B W0
000CD0  320003     BRA Z, 0xCD8
94:                                b_sta = true;
000CD2  B3C010     MOV.B #0x1, W0
000CD4  984710     MOV.B W0, [W14+1]
95:                                break;
000CD6  370003     BRA 0xCDE
96:                            }
97:                        }
98:                
99:                    } while (cnt > cnt_tmp);
000CD8  90C07E     MOV.B [W14+71], W0
000CDA  504F9E     SUB.B W0, [W14], [W15]
000CDC  3EFFD2     BRA GTU, 0xC82
100:                   ClearBuffer(BufferRead_UART2);
000CDE  20A660     MOV #0xA66, W0
000CE0  07FFB9     RCALL ClearBuffer
101:                   return b_sta;
000CE2  90401E     MOV.B [W14+1], W0
102:               }
000CE4  FA8000     ULNK
000CE6  060000     RETURN
103:               
104:               uint8_t M6310_DialingIsERR(void) {
000CE8  FA0002     LNK #0x2
105:                   uint8_t sta;
106:                   //    uint8_t ip_port[25] = {'\0'};
107:               
108:                   //    M6310_GetIP_Port();
109:                   //    PWR = 1;
110:                   //    PWRON = 1;
111:                   //    CTS = 0;
112:                   //    RTS = 0;
113:                   //    DSR = 0;
114:                   //    DTR = 0;
115:                   GPRS_EN_SetHigh(); //
000CEA  A8267B     BSET 0x67B, #1
116:                   /********************/
117:                   PWRKEY_SetHigh();
000CEC  A8A67B     BSET 0x67B, #5
118:                   Delay1s(2);
000CEE  B3C020     MOV.B #0x2, W0
000CF0  07FC18     RCALL Delay1s
119:                   if (M6310SendCmd(D0, OK, NULL, 2, 2)) {
000CF2  B3C024     MOV.B #0x2, W4
000CF4  B3C023     MOV.B #0x2, W3
000CF6  EB0100     CLR W2
000CF8  282331     MOV #0x8233, W1
000CFA  2821A0     MOV #0x821A, W0
000CFC  07FFB8     RCALL _M6310SendCmd
000CFE  E00400     CP0.B W0
000D00  32003A     BRA Z, 0xD76
120:                       if (M6310SendCmd(CPIN, READY, NULL, 8, 2)) {
000D02  B3C024     MOV.B #0x2, W4
000D04  B3C083     MOV.B #0x8, W3
000D06  EB0100     CLR W2
000D08  282411     MOV #0x8241, W1
000D0A  282360     MOV #0x8236, W0
000D0C  07FFB0     RCALL _M6310SendCmd
000D0E  E00400     CP0.B W0
000D10  32002F     BRA Z, 0xD70
121:                           if (M6310SendCmd(CREG, _5, _1, 2, 10)) {//
000D12  B3C0A4     MOV.B #0xA, W4
000D14  B3C023     MOV.B #0x2, W3
000D16  2827E2     MOV #0x827E, W2
000D18  2827B1     MOV #0x827B, W1
000D1A  282580     MOV #0x8258, W0
000D1C  07FFA8     RCALL _M6310SendCmd
000D1E  E00400     CP0.B W0
000D20  320024     BRA Z, 0xD6A
122:                               if (M6310SendCmd(CGATT, OK, NULL, 2, 3)) {
000D22  B3C034     MOV.B #0x3, W4
000D24  B3C023     MOV.B #0x2, W3
000D26  EB0100     CLR W2
000D28  282331     MOV #0x8233, W1
000D2A  2826F0     MOV #0x826F, W0
000D2C  07FFA0     RCALL _M6310SendCmd
000D2E  E00400     CP0.B W0
000D30  320019     BRA Z, 0xD64
123:                                   //M6310_GetIP_Port(); //IP
124:                                   if (M6310SendCmd(QICSGP, OK, NULL, 2, 3)) {
000D32  B3C034     MOV.B #0x3, W4
000D34  B3C023     MOV.B #0x2, W3
000D36  EB0100     CLR W2
000D38  282331     MOV #0x8233, W1
000D3A  282810     MOV #0x8281, W0
000D3C  07FF98     RCALL _M6310SendCmd
000D3E  E00400     CP0.B W0
000D40  32000E     BRA Z, 0xD5E
125:                                       if (M6310SendCmd(KTCPSTART, CONNECT, NULL, 5, 5)) {
000D42  B3C054     MOV.B #0x5, W4
000D44  B3C053     MOV.B #0x5, W3
000D46  EB0100     CLR W2
000D48  282CC1     MOV #0x82CC, W1
000D4A  282BB0     MOV #0x82BB, W0
000D4C  07FF90     RCALL _M6310SendCmd
000D4E  E00400     CP0.B W0
000D50  320003     BRA Z, 0xD58
126:                                           sta = 0;
000D52  EB4000     CLR.B W0
000D54  784F00     MOV.B W0, [W14]
000D56  370011     BRA 0xD7A
127:                                       } else
128:                                           sta = 6; //TCP
000D58  B3C060     MOV.B #0x6, W0
000D5A  784F00     MOV.B W0, [W14]
000D5C  37000E     BRA 0xD7A
129:                                   } else
130:                                       sta = 5; //TCP
000D5E  B3C050     MOV.B #0x5, W0
000D60  784F00     MOV.B W0, [W14]
000D62  37000B     BRA 0xD7A
131:                               } else
132:                                   sta = 4; //APN
000D64  B3C040     MOV.B #0x4, W0
000D66  784F00     MOV.B W0, [W14]
000D68  370008     BRA 0xD7A
133:                           } else
134:                               sta = 3; // 
000D6A  B3C030     MOV.B #0x3, W0
000D6C  784F00     MOV.B W0, [W14]
000D6E  370005     BRA 0xD7A
135:                       } else
136:                           sta = 2; //
000D70  B3C020     MOV.B #0x2, W0
000D72  784F00     MOV.B W0, [W14]
000D74  370002     BRA 0xD7A
137:                   } else
138:                       sta = 1; //
000D76  B3C010     MOV.B #0x1, W0
000D78  784F00     MOV.B W0, [W14]
139:                   return sta;
000D7A  78401E     MOV.B [W14], W0
140:               }
000D7C  FA8000     ULNK
000D7E  060000     RETURN
141:               
142:               void M6310_Close(void) {
000D80  FA0020     LNK #0x20
143:                   uint8_t tmp[20];
144:                   StrCmp stcp;
145:                   ClearBuffer(BufferRead_UART2);
000D82  20A660     MOV #0xA66, W0
000D84  07FF67     RCALL ClearBuffer
146:                   do {
147:                       //        DSR = 1; //AT mark
148:                       //        DTR = 1;
149:                       Delay1s(1); //(0, 0, 1, 0); //1s
000D86  B3C010     MOV.B #0x1, W0
000D88  07FBCC     RCALL Delay1s
150:                       //        DSR = 0; //
151:                       //        DTR = 0;
152:                       Delay1s(1); //(0, 0, 1, 0); //1s
000D8A  B3C010     MOV.B #0x1, W0
000D8C  07FBCA     RCALL Delay1s
153:                       stcp.SourceData = tmp;
000D8E  980F2E     MOV W14, [W14+20]
154:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 20); //mark
000D90  90082E     MOV [W14+20], W0
000D92  B3C142     MOV.B #0x14, W2
000D94  780080     MOV W0, W1
000D96  20A660     MOV #0xA66, W0
000D98  07FF46     RCALL UARTGetData
000D9A  985760     MOV.B W0, [W14+22]
155:                       stcp.CheckData = (uint8_t*) OK;
000D9C  282330     MOV #0x8233, W0
000D9E  980F40     MOV W0, [W14+24]
156:                       stcp.Check_len = 2;
000DA0  B3C020     MOV.B #0x2, W0
000DA2  985F20     MOV.B W0, [W14+26]
157:                       stcp.GetData = NULL;
000DA4  EB0000     CLR W0
000DA6  980F60     MOV W0, [W14+28]
158:                       stcp.Get_len = 0;
000DA8  EB4000     CLR.B W0
000DAA  985F60     MOV.B W0, [W14+30]
159:                       stcp.Real_len = 0;
000DAC  EB4000     CLR.B W0
000DAE  985F70     MOV.B W0, [W14+31]
160:                   } while (UARTDataIsRight(&stcp)); //OK
000DB0  470074     ADD W14, #0x14, W0
000DB2  07FE76     RCALL UARTDataIsRight
000DB4  E00400     CP0.B W0
000DB6  3AFFE7     BRA NZ, 0xD86
161:                   if (M6310SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//TCPID
000DB8  B3C024     MOV.B #0x2, W4
000DBA  B3C023     MOV.B #0x2, W3
000DBC  EB0100     CLR W2
000DBE  282331     MOV #0x8233, W1
000DC0  282D40     MOV #0x82D4, W0
000DC2  07FF55     RCALL _M6310SendCmd
000DC4  E00400     CP0.B W0
000DC6  320006     BRA Z, 0xDD4
162:                       M6310SendCmd(KTCPDEL, OK, NULL, 2, 2);
000DC8  B3C024     MOV.B #0x2, W4
000DCA  B3C023     MOV.B #0x2, W3
000DCC  EB0100     CLR W2
000DCE  282331     MOV #0x8233, W1
000DD0  282E70     MOV #0x82E7, W0
000DD2  07FF4D     RCALL _M6310SendCmd
163:                   Delay1s(1); // (0, 0, 1, 0); //1s    
000DD4  B3C010     MOV.B #0x1, W0
000DD6  07FBA5     RCALL Delay1s
164:                   //    PWR = 0; //
165:                   //    PWRON = 0; //
166:                   //    CTS = 0; //
167:                   //    RTS = 0; //
168:                   //    DSR = 0; //
169:                   //    DTR = 0; //
170:                   //    UART2_Close();
171:               }
000DD8  FA8000     ULNK
000DDA  060000     RETURN
172:               
173:               
174:               
175:               //static void M6310_IOStart(void) {
176:               //    PWR = 1;
177:               //    PWRON = 1;
178:               //    CTS = 0;
179:               //    RTS = 0;
180:               //    DSR = 0;
181:               //    DTR = 0;
182:               //}
183:               //
184:               //static void M6310_IOClose(void) {
185:               //    PWRON = 0;
186:               //    PWR = 0;
187:               //    CTS = 1;
188:               //    RTS = 1;
189:               //    DSR = 1;
190:               //    DTR = 1;
191:               //}
192:               
193:               //void M6310_GetIP_Port(void) {
194:               //    uint8_t net_addr[25] = {'\0'};
195:               //    uint8_t str_tmp[4] = {1, 2, 3, 4};
196:               //    uint8_t cnt;
197:               //    uint8_t all_bytes = 0;
198:               //
199:               //    //
200:               //    all_bytes = my_itoa(WGCIPbits.IP3, net_addr);
201:               //    net_addr[all_bytes] = '.';
202:               //    net_addr[all_bytes + 1] = '\0';
203:               //    all_bytes = all_bytes + 1;
204:               //
205:               //    all_bytes += my_itoa(WGCIPbits.IP2, str_tmp);
206:               //    strcat(net_addr, str_tmp);
207:               //    net_addr[all_bytes ] = '.';
208:               //    net_addr[ all_bytes + 1] = '\0';
209:               //    all_bytes = all_bytes + 1;
210:               //
211:               //    all_bytes += my_itoa(WGCIPbits.IP1, str_tmp);
212:               //    strcat(net_addr, str_tmp);
213:               //    net_addr[all_bytes ] = '.';
214:               //    net_addr[ all_bytes + 1] = '\0';
215:               //    all_bytes = all_bytes + 1;
216:               //
217:               //    all_bytes += my_itoa(WGCIPbits.IP0, str_tmp);
218:               //    strcat(net_addr, str_tmp);
219:               //    net_addr[ all_bytes ] = '"';
220:               //    net_addr[all_bytes + 1 ] = ',';
221:               //    net_addr[ all_bytes + 2] = '\0';
222:               //    all_bytes = all_bytes + 2;
223:               //
224:               //    all_bytes += my_itoa(WGCPORT, str_tmp);
225:               //    strcat(net_addr, str_tmp);
226:               //    net_addr[ all_bytes ] = '\r';
227:               //    net_addr[ all_bytes + 1] = '\n';
228:               //    net_addr[ all_bytes + 2] = '\0';
229:               //    all_bytes = all_bytes + 2;
230:               //    //   uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
231:               //    for (cnt = 0; cnt < all_bytes; cnt++)
232:               //        *(KTCPCFG1 + 16 + cnt) = *(net_addr + cnt);
233:               //    //    return all_bytes;
234:               //}
235:               
236:               
237:               
238:               
239:               
---  C:/Users/Administrator/Desktop/code/WVC/MODELS/UART1.X/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: char
6:                 Input:  4  8  
7:                 Output: 
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
0002F6  FA0008     LNK #0x8
0002F8  980720     MOV W0, [W14+4]
0002FA  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
0002FC  9000AE     MOV [W14+4], W1
0002FE  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
000300  EB4000     CLR.B W0
000302  784F00     MOV.B W0, [W14]
000304  37000A     BRA 0x31A
000318  E84F1E     INC.B [W14], [W14]
00031A  78401E     MOV.B [W14], W0
00031C  504FE3     SUB.B W0, #0x3, [W15]
00031E  36FFF3     BRA LEU, 0x306
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
000306  FB801E     ZE [W14], W0
000308  9000BE     MOV [W14+6], W1
00030A  408000     ADD W1, W0, W0
00030C  90011E     MOV [W14+2], W2
00030E  FB809E     ZE [W14], W1
000310  1080E3     SUBR W1, #0x3, W1
000312  410081     ADD W2, W1, W1
000314  784091     MOV.B [W1], W1
000316  784801     MOV.B W1, [W0]
16:                    }
17:                }
000320  FA8000     ULNK
000322  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char 
22:                Input:     4  8  
23:                Output: 
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
000324  FA0008     LNK #0x8
000326  980720     MOV W0, [W14+4]
000328  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
00032A  9000AE     MOV [W14+4], W1
00032C  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
00032E  EB4000     CLR.B W0
000330  784F00     MOV.B W0, [W14]
000332  37000A     BRA 0x348
000346  E84F1E     INC.B [W14], [W14]
000348  78401E     MOV.B [W14], W0
00034A  504FE3     SUB.B W0, #0x3, [W15]
00034C  36FFF3     BRA LEU, 0x334
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
000334  90009E     MOV [W14+2], W1
000336  FB801E     ZE [W14], W0
000338  408000     ADD W1, W0, W0
00033A  FB809E     ZE [W14], W1
00033C  1080E3     SUBR W1, #0x3, W1
00033E  90013E     MOV [W14+6], W2
000340  410081     ADD W2, W1, W1
000342  784091     MOV.B [W1], W1
000344  784801     MOV.B W1, [W0]
32:                    }
33:                }
00034E  FA8000     ULNK
000350  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: char
38:                Input:  4  8  
39:                Output: 
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
000352  FA0008     LNK #0x8
000354  980720     MOV W0, [W14+4]
000356  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
000358  9000AE     MOV [W14+4], W1
00035A  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
00035C  EB4000     CLR.B W0
00035E  784F00     MOV.B W0, [W14]
000360  37000A     BRA 0x376
000374  E84F1E     INC.B [W14], [W14]
000376  78401E     MOV.B [W14], W0
000378  504FE7     SUB.B W0, #0x7, [W15]
00037A  36FFF3     BRA LEU, 0x362
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
000362  FB801E     ZE [W14], W0
000364  9000BE     MOV [W14+6], W1
000366  408000     ADD W1, W0, W0
000368  90011E     MOV [W14+2], W2
00036A  FB809E     ZE [W14], W1
00036C  1080E7     SUBR W1, #0x7, W1
00036E  410081     ADD W2, W1, W1
000370  784091     MOV.B [W1], W1
000372  784801     MOV.B W1, [W0]
48:                    }
49:                }
00037C  FA8000     ULNK
00037E  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 1610
54:                Input: 
55:                Output: 
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
000380  FA0002     LNK #0x2
000382  781F88     MOV W8, [W15++]
000384  784F00     MOV.B W0, [W14]
58:                    return (dat >> 4)*10 + GetMod(dat, 4);
000386  FB801E     ZE [W14], W0
000388  DE0044     LSR W0, #4, W0
00038A  784000     MOV.B W0, W0
00038C  B9006A     MUL.SU W0, #10, W0
00038E  780000     MOV W0, W0
000390  784400     MOV.B W0, W8
000392  FB801E     ZE [W14], W0
000394  B3C041     MOV.B #0x4, W1
000396  070126     RCALL GetMod
000398  444000     ADD.B W8, W0, W0
59:                }
00039A  78044F     MOV [--W15], W8
00039C  FA8000     ULNK
00039E  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 1016
64:                Input: 
65:                Output: 
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
0003A0  FA0004     LNK #0x4
0003A2  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
0003A4  FB809E     ZE [W14], W1
0003A6  2000A0     MOV #0xA, W0
0003A8  780100     MOV W0, W2
0003AA  090011     REPEAT #0x11
0003AC  D88082     DIV.UW W1, W2
0003AE  784000     MOV.B W0, W0
0003B0  FB8000     ZE W0, W0
0003B2  DD0044     SL W0, #4, W0
0003B4  784000     MOV.B W0, W0
0003B6  984720     MOV.B W0, [W14+2]
0003B8  FB811E     ZE [W14], W2
0003BA  2000A0     MOV #0xA, W0
0003BC  780180     MOV W0, W3
0003BE  090011     REPEAT #0x11
0003C0  D88103     DIV.UW W2, W3
0003C2  FD0080     EXCH W0, W1
0003C4  784000     MOV.B W0, W0
0003C6  60406F     AND.B W0, #0xF, W0
0003C8  9040AE     MOV.B [W14+2], W1
0003CA  70C000     IOR.B W1, W0, W0
69:                }
0003CC  FA8000     ULNK
0003CE  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x1117-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 
79:                Input: 
80:                Output: 
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
0003D0  FA0006     LNK #0x6
0003D2  780F00     MOV W0, [W14]
0003D4  980711     MOV W1, [W14+2]
0003D6  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
0003D8  90001E     MOV [W14+2], W0
0003DA  78009E     MOV [W14], W1
0003DC  508F80     SUB W1, W0, [W15]
0003DE  360002     BRA LEU, 0x3E4
0003E0  EB4000     CLR.B W0
0003E2  370007     BRA 0x3F2
84:                    else if (dat < min) return false;
0003E4  90002E     MOV [W14+4], W0
0003E6  78009E     MOV [W14], W1
0003E8  508F80     SUB W1, W0, [W15]
0003EA  310002     BRA C, 0x3F0
0003EC  EB4000     CLR.B W0
0003EE  370001     BRA 0x3F2
85:                    return true;
0003F0  B3C010     MOV.B #0x1, W0
86:                }
0003F2  FA8000     ULNK
0003F4  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 
91:                Input: 
92:                Output: 
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
0003F6  FA000A     LNK #0xA
0003F8  980710     MOV W0, [W14+2]
0003FA  980722     MOV W2, [W14+4]
0003FC  980733     MOV W3, [W14+6]
0003FE  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
000400  90001E     MOV [W14+2], W0
000402  780010     MOV [W0], W0
000404  DD00C8     SL W0, #8, W1
000406  90001E     MOV [W14+2], W0
000408  E88000     INC2 W0, W0
00040A  780010     MOV [W0], W0
00040C  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
00040E  78001E     MOV [W14], W0
000410  B80161     MUL.UU W0, #1, W2
000412  90002E     MOV [W14+4], W0
000414  9000BE     MOV [W14+6], W1
000416  510F80     SUB W2, W0, [W15]
000418  598F81     SUBB W3, W1, [W15]
00041A  360004     BRA LEU, 0x424
98:                        *dat = max;
00041C  9000AE     MOV [W14+4], W1
00041E  90001E     MOV [W14+2], W0
000420  780801     MOV W1, [W0]
000422  370007     BRA 0x432
99:                    } else if (tmp < min) {
000424  90004E     MOV [W14+8], W0
000426  78009E     MOV [W14], W1
000428  508F80     SUB W1, W0, [W15]
00042A  310003     BRA C, 0x432
100:                       *dat = min;
00042C  90001E     MOV [W14+2], W0
00042E  9000CE     MOV [W14+8], W1
000430  780801     MOV W1, [W0]
101:                   }
102:               }
000432  FA8000     ULNK
000434  060000     RETURN
103:               //
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
000436  FA0006     LNK #0x6
000438  980710     MOV W0, [W14+2]
00043A  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
00043C  EB4000     CLR.B W0
00043E  784F00     MOV.B W0, [W14]
000440  37001B     BRA 0x478
000476  E84F1E     INC.B [W14], [W14]
000478  90404E     MOV.B [W14+4], W0
00047A  FB8000     ZE W0, W0
00047C  D10000     LSR W0, W0
00047E  784000     MOV.B W0, W0
000480  504F9E     SUB.B W0, [W14], [W15]
000482  3EFFDF     BRA GTU, 0x442
109:                       tmp = dat[cnt];
000442  FB801E     ZE [W14], W0
000444  90009E     MOV [W14+2], W1
000446  408000     ADD W1, W0, W0
000448  784090     MOV.B [W0], W1
00044A  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
00044C  FB801E     ZE [W14], W0
00044E  90009E     MOV [W14+2], W1
000450  408000     ADD W1, W0, W0
000452  9040CE     MOV.B [W14+4], W1
000454  FB8081     ZE W1, W1
000456  E90101     DEC W1, W2
000458  FB809E     ZE [W14], W1
00045A  510081     SUB W2, W1, W1
00045C  90011E     MOV [W14+2], W2
00045E  410081     ADD W2, W1, W1
000460  784091     MOV.B [W1], W1
000462  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
000464  90404E     MOV.B [W14+4], W0
000466  FB8000     ZE W0, W0
000468  E90080     DEC W0, W1
00046A  FB801E     ZE [W14], W0
00046C  508000     SUB W1, W0, W0
00046E  90009E     MOV [W14+2], W1
000470  408000     ADD W1, W0, W0
000472  90409E     MOV.B [W14+1], W1
000474  784801     MOV.B W1, [W0]
112:                   }
113:               }
000484  FA8000     ULNK
000486  060000     RETURN
114:               
115:               //void Delayms(uint16_t time) {//1000,
116:               //    TMR2 = 0; //2
117:               //    PR2 = 625 * time / 10; //
118:               //    IFS0bits.T2IF = 0;
119:               //    T2CONbits.TON = 1; //    
120:               //    while (!IFS0bits.T2IF); //
121:               //    T2CONbits.TON = 0; //
122:               //    IFS0bits.T2IF = 0; //
123:               //}
124:               //8MHz-4Mhz 
125:               //0x0271 10ms
126:               
127:               //32Mhz
128:               
129:               void Delay1ms(char time) {
000488  FA0004     LNK #0x4
00048A  984720     MOV.B W0, [W14+2]
130:                   uint16_t i;
131:                   while (time-- > 0)
00048C  370009     BRA 0x4A0
0004A0  B3C010     MOV.B #0x1, W0
0004A2  9040AE     MOV.B [W14+2], W1
0004A4  E00401     CP0.B W1
0004A6  3C0001     BRA GT, 0x4AA
0004A8  EB4000     CLR.B W0
0004AA  9040AE     MOV.B [W14+2], W1
0004AC  E94081     DEC.B W1, W1
0004AE  984721     MOV.B W1, [W14+2]
0004B0  E00400     CP0.B W0
0004B2  3AFFED     BRA NZ, 0x48E
132:                       for (i = 0; i < 144; i++)
00048E  EB0000     CLR W0
000490  780F00     MOV W0, [W14]
000492  370002     BRA 0x498
000496  E80F1E     INC [W14], [W14]
000498  2008F0     MOV #0x8F, W0
00049A  78009E     MOV [W14], W1
00049C  508F80     SUB W1, W0, [W15]
00049E  36FFFA     BRA LEU, 0x494
133:                           Nop();
000494  000000     NOP
134:               }
0004B4  FA8000     ULNK
0004B6  060000     RETURN
135:               
136:               void Delay10ms(char time) {
0004B8  FA0004     LNK #0x4
0004BA  984720     MOV.B W0, [W14+2]
137:                   uint16_t i;
138:                   while (time-- > 0)
0004BC  370009     BRA 0x4D0
0004D0  B3C010     MOV.B #0x1, W0
0004D2  9040AE     MOV.B [W14+2], W1
0004D4  E00401     CP0.B W1
0004D6  3C0001     BRA GT, 0x4DA
0004D8  EB4000     CLR.B W0
0004DA  9040AE     MOV.B [W14+2], W1
0004DC  E94081     DEC.B W1, W1
0004DE  984721     MOV.B W1, [W14+2]
0004E0  E00400     CP0.B W0
0004E2  3AFFED     BRA NZ, 0x4BE
139:                       for (i = 0; i < 1440; i++)
0004BE  EB0000     CLR W0
0004C0  780F00     MOV W0, [W14]
0004C2  370002     BRA 0x4C8
0004C6  E80F1E     INC [W14], [W14]
0004C8  2059F0     MOV #0x59F, W0
0004CA  78009E     MOV [W14], W1
0004CC  508F80     SUB W1, W0, [W15]
0004CE  36FFFA     BRA LEU, 0x4C4
140:                           Nop();
0004C4  000000     NOP
141:               }
0004E4  FA8000     ULNK
0004E6  060000     RETURN
142:               
143:               void Delay100ms(char time) {
0004E8  FA0006     LNK #0x6
0004EA  984740     MOV.B W0, [W14+4]
144:                   uint32_t i;
145:                   while (time-- > 0)
0004EC  37000E     BRA 0x50A
00050A  B3C010     MOV.B #0x1, W0
00050C  9040CE     MOV.B [W14+4], W1
00050E  E00401     CP0.B W1
000510  3C0001     BRA GT, 0x514
000512  EB4000     CLR.B W0
000514  9040CE     MOV.B [W14+4], W1
000516  E94081     DEC.B W1, W1
000518  984741     MOV.B W1, [W14+4]
00051A  E00400     CP0.B W0
00051C  3AFFE8     BRA NZ, 0x4EE
146:                       for (i = 0; i < 14400; i++)
0004EE  B80060     MUL.UU W0, #0, W0
0004F0  BE8F00     MOV.D W0, [W14]
0004F2  370005     BRA 0x4FE
0004F6  200012     MOV #0x1, W2
0004F8  200003     MOV #0x0, W3
0004FA  410F1E     ADD W2, [W14], [W14]
0004FC  49975E     ADDC W3, [++W14], [W14--]
0004FE  2383F0     MOV #0x383F, W0
000500  200001     MOV #0x0, W1
000502  BE011E     MOV.D [W14], W2
000504  510F80     SUB W2, W0, [W15]
000506  598F81     SUBB W3, W1, [W15]
000508  36FFF5     BRA LEU, 0x4F4
147:                           Nop();
0004F4  000000     NOP
148:               }
00051E  FA8000     ULNK
000520  060000     RETURN
149:               
150:               void Delay1s(char time) {
000522  FA0006     LNK #0x6
000524  984740     MOV.B W0, [W14+4]
151:                   uint32_t i; //,j;
152:                   while (time-- > 0)
000526  37000E     BRA 0x544
000544  B3C010     MOV.B #0x1, W0
000546  9040CE     MOV.B [W14+4], W1
000548  E00401     CP0.B W1
00054A  3C0001     BRA GT, 0x54E
00054C  EB4000     CLR.B W0
00054E  9040CE     MOV.B [W14+4], W1
000550  E94081     DEC.B W1, W1
000552  984741     MOV.B W1, [W14+4]
000554  E00400     CP0.B W0
000556  3AFFE8     BRA NZ, 0x528
153:                       for (i = 0; i < 144000; i++)
000528  B80060     MUL.UU W0, #0, W0
00052A  BE8F00     MOV.D W0, [W14]
00052C  370005     BRA 0x538
000530  200012     MOV #0x1, W2
000532  200003     MOV #0x0, W3
000534  410F1E     ADD W2, [W14], [W14]
000536  49975E     ADDC W3, [++W14], [W14--]
000538  2327F0     MOV #0x327F, W0
00053A  200021     MOV #0x2, W1
00053C  BE011E     MOV.D [W14], W2
00053E  510F80     SUB W2, W0, [W15]
000540  598F81     SUBB W3, W1, [W15]
000542  36FFF5     BRA LEU, 0x52E
154:                           Nop();
00052E  000000     NOP
155:               }
000558  FA8000     ULNK
00055A  060000     RETURN
156:               
157:               //void Delays(char time) {
158:               //    uint8_t cnt;
159:               //    for (cnt = 0; cnt < time; cnt++)
160:               //        Delayms(1000);
161:               //}
162:               
163:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
00055C  FA0008     LNK #0x8
00055E  980710     MOV W0, [W14+2]
000560  980721     MOV W1, [W14+4]
000562  984762     MOV.B W2, [W14+6]
164:                   uint8_t num;
165:                   for (num = 0; num < bytes; num++)
000564  EB4000     CLR.B W0
000566  784F00     MOV.B W0, [W14]
000568  370009     BRA 0x57C
00057A  E84F1E     INC.B [W14], [W14]
00057C  90406E     MOV.B [W14+6], W0
00057E  78409E     MOV.B [W14], W1
000580  50CF80     SUB.B W1, W0, [W15]
000582  39FFF3     BRA NC, 0x56A
166:                       *(output + num) = *(input + num);
00056A  FB801E     ZE [W14], W0
00056C  90009E     MOV [W14+2], W1
00056E  408000     ADD W1, W0, W0
000570  FB809E     ZE [W14], W1
000572  90012E     MOV [W14+4], W2
000574  410081     ADD W2, W1, W1
000576  784091     MOV.B [W1], W1
000578  784801     MOV.B W1, [W0]
167:               }
000584  FA8000     ULNK
000586  060000     RETURN
168:               
169:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
000588  FA0006     LNK #0x6
00058A  980710     MOV W0, [W14+2]
00058C  984741     MOV.B W1, [W14+4]
00058E  984752     MOV.B W2, [W14+5]
170:                   uint8_t num;
171:                   for (num = 0; num < bytes; num++)
000590  EB4000     CLR.B W0
000592  784F00     MOV.B W0, [W14]
000594  370006     BRA 0x5A2
0005A0  E84F1E     INC.B [W14], [W14]
0005A2  90405E     MOV.B [W14+5], W0
0005A4  78409E     MOV.B [W14], W1
0005A6  50CF80     SUB.B W1, W0, [W15]
0005A8  39FFF6     BRA NC, 0x596
172:                       *(output + num) = dat;
000596  FB801E     ZE [W14], W0
000598  90009E     MOV [W14+2], W1
00059A  408000     ADD W1, W0, W0
00059C  9040CE     MOV.B [W14+4], W1
00059E  784801     MOV.B W1, [W0]
173:               }
0005AA  FA8000     ULNK
0005AC  060000     RETURN
174:               
175:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
0005AE  FA0008     LNK #0x8
0005B0  980710     MOV W0, [W14+2]
0005B2  980721     MOV W1, [W14+4]
0005B4  984762     MOV.B W2, [W14+6]
176:                   uint8_t cnt;
177:                   for (cnt = 0; cnt < bytes; cnt++)
0005B6  EB4000     CLR.B W0
0005B8  784F00     MOV.B W0, [W14]
0005BA  37000D     BRA 0x5D6
0005D4  E84F1E     INC.B [W14], [W14]
0005D6  90406E     MOV.B [W14+6], W0
0005D8  78409E     MOV.B [W14], W1
0005DA  50CF80     SUB.B W1, W0, [W15]
0005DC  39FFEF     BRA NC, 0x5BC
178:                       if (*(str1 + cnt) != *(str2 + cnt))
0005BC  FB801E     ZE [W14], W0
0005BE  90009E     MOV [W14+2], W1
0005C0  408000     ADD W1, W0, W0
0005C2  784090     MOV.B [W0], W1
0005C4  FB801E     ZE [W14], W0
0005C6  90012E     MOV [W14+4], W2
0005C8  410000     ADD W2, W0, W0
0005CA  784010     MOV.B [W0], W0
0005CC  50CF80     SUB.B W1, W0, [W15]
0005CE  320002     BRA Z, 0x5D4
179:                           return false;
0005D0  EB4000     CLR.B W0
0005D2  370006     BRA 0x5E0
180:                   return true;
0005DE  B3C010     MOV.B #0x1, W0
181:               }
0005E0  FA8000     ULNK
0005E2  060000     RETURN
182:               
183:               //
184:               
185:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
0005E4  FA0004     LNK #0x4
0005E6  780F00     MOV W0, [W14]
0005E8  984721     MOV.B W1, [W14+2]
186:                   return num - ((num >> mod_num) << mod_num);
0005EA  78001E     MOV [W14], W0
0005EC  784080     MOV.B W0, W1
0005EE  90402E     MOV.B [W14+2], W0
0005F0  FB8000     ZE W0, W0
0005F2  78011E     MOV [W14], W2
0005F4  DE1100     LSR W2, W0, W2
0005F6  90402E     MOV.B [W14+2], W0
0005F8  FB8000     ZE W0, W0
0005FA  DD1000     SL W2, W0, W0
0005FC  784000     MOV.B W0, W0
0005FE  50C000     SUB.B W1, W0, W0
187:               }
000600  FA8000     ULNK
000602  060000     RETURN
188:               
189:               //16
190:               
191:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
000604  FA0010     LNK #0x10
000606  980750     MOV W0, [W14+10]
000608  980761     MOV W1, [W14+12]
192:                   uint8_t buf[6];
193:                   uint8_t cnt = 0, len;
00060A  EB4000     CLR.B W0
00060C  784F00     MOV.B W0, [W14]
194:                   uint16_t tmp = i;
00060E  90005E     MOV [W14+10], W0
000610  980710     MOV W0, [W14+2]
195:                   if (!tmp) {
000612  90001E     MOV [W14+2], W0
000614  E00000     CP0 W0
000616  3A001E     BRA NZ, 0x654
196:                       *str = '0';
000618  90006E     MOV [W14+12], W0
00061A  B3C301     MOV.B #0x30, W1
00061C  784801     MOV.B W1, [W0]
197:                       *(str + 1) = '\0';
00061E  90006E     MOV [W14+12], W0
000620  E80000     INC W0, W0
000622  EB4080     CLR.B W1
000624  784801     MOV.B W1, [W0]
198:                       len = 1;
000626  B3C010     MOV.B #0x1, W0
000628  984710     MOV.B W0, [W14+1]
00062A  370034     BRA 0x694
199:                   } else {
200:                       while (tmp) {
000654  90001E     MOV [W14+2], W0
000656  E00000     CP0 W0
000658  3AFFE9     BRA NZ, 0x62C
201:                           *(buf + cnt++) = tmp % 10 + 0x30;
00062C  FB801E     ZE [W14], W0
00062E  4700E4     ADD W14, #0x4, W1
000630  408080     ADD W1, W0, W1
000632  980771     MOV W1, [W14+14]
000634  90011E     MOV [W14+2], W2
000636  2000A1     MOV #0xA, W1
000638  780181     MOV W1, W3
00063A  090011     REPEAT #0x11
00063C  D88103     DIV.UW W2, W3
00063E  784081     MOV.B W1, W1
000640  B04301     ADD.B #0x30, W1
000642  90007E     MOV [W14+14], W0
000644  784801     MOV.B W1, [W0]
000646  E84F1E     INC.B [W14], [W14]
202:                           tmp /= 10;
000648  90009E     MOV [W14+2], W1
00064A  2000A0     MOV #0xA, W0
00064C  780100     MOV W0, W2
00064E  090011     REPEAT #0x11
000650  D88082     DIV.UW W1, W2
000652  980710     MOV W0, [W14+2]
203:                       }
204:                       len = cnt;
00065A  78419E     MOV.B [W14], W3
00065C  984713     MOV.B W3, [W14+1]
205:                       cnt += 1;
00065E  E84F1E     INC.B [W14], [W14]
206:                       while (cnt--) {
000660  37000C     BRA 0x67A
00067A  FB801E     ZE [W14], W0
00067C  EA0000     NEG W0, W0
00067E  DE004F     LSR W0, #15, W0
000680  784000     MOV.B W0, W0
000682  E94F1E     DEC.B [W14], [W14]
000684  E00400     CP0.B W0
000686  3AFFED     BRA NZ, 0x662
207:                           *(str + cnt - 1) = *(buf + len - cnt);
000662  FB801E     ZE [W14], W0
000664  E90000     DEC W0, W0
000666  9000EE     MOV [W14+12], W1
000668  408000     ADD W1, W0, W0
00066A  90409E     MOV.B [W14+1], W1
00066C  FB8101     ZE W1, W2
00066E  FB809E     ZE [W14], W1
000670  510081     SUB W2, W1, W1
000672  470164     ADD W14, #0x4, W2
000674  410081     ADD W2, W1, W1
000676  784091     MOV.B [W1], W1
000678  784801     MOV.B W1, [W0]
208:                       }
209:                       *(str + len) = '\0';
000688  90401E     MOV.B [W14+1], W0
00068A  FB8000     ZE W0, W0
00068C  9000EE     MOV [W14+12], W1
00068E  408000     ADD W1, W0, W0
000690  EB4080     CLR.B W1
000692  784801     MOV.B W1, [W0]
210:                   }
211:                   return len;
000694  90401E     MOV.B [W14+1], W0
212:               }
000696  FA8000     ULNK
000698  060000     RETURN
213:               
214:               
