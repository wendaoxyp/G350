Disassembly Listing for V3_2_forDaZong.X
Generated From:
C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/dist/default/production/V3_2_forDaZong.X.X.production.elf
2016-12-1 16:52:54

---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/task.c  ----------------------------
1:                 #include "user.h"
2:                 #include "Mp.h"
3:                 #include "GPRS.h"
4:                 #include "P-Miot1601.h"
5:                 #include "Miot1601.h"
6:                 
7:                 struct Run_Arg runingArg;
8:                 //u8 gSampleCount = 0; //采集次数记录
9:                 //u8 gCurrentSampleCount=0;//保存采集次数以便重新发送
10:                u8 gAlarmZeroLock = 0;
11:                
12:                void Task_TimeUp(void)//进入先读取 发送一次数据
13:                {
003A9A  FA0000     LNK #0x0
14:                    if (FLagArgbits.tgprsFlag) { //GPRS通讯时间
003A9C  BFCC40     MOV.B FLagArgbits, WREG
003A9E  604061     AND.B W0, #0x1, W0
003AA0  E00400     CP0.B W0
003AA2  320005     BRA Z, 0x3AAE
15:                        Open_UART2();
003AA4  07FFBA     RCALL Open_UART2
16:                        CopUDPTask(DataSamples); //GPRS上线通讯数据     
003AA6  EB4000     CLR.B W0
003AA8  07F25B     RCALL CopUDPTask
17:                        Close_UART2();
003AAA  07FFBC     RCALL Close_UART2
18:                        FLagArgbits.tgprsFlag = 0;
003AAC  A90C40     BCLR FLagArgbits, #0
19:                    }
20:                    if (Statusbits.staBat && !gAlarmZeroLock) { //GPRS报警时间
003AAE  BFCC38     MOV.B Statusbits, WREG
003AB0  604070     AND.B W0, #0x10, W0
003AB2  E00400     CP0.B W0
003AB4  320011     BRA Z, 0x3AD8
003AB6  BFCC3E     MOV.B 0xC3E, WREG
003AB8  E00400     CP0.B W0
003ABA  3A000E     BRA NZ, 0x3AD8
21:                        if (runingArg.gTAlarm) {
003ABC  805DF0     MOV 0xBBE, W0
003ABE  E00000     CP0 W0
003AC0  320006     BRA Z, 0x3ACE
22:                            if (FLagArgbits.talarmFlag) {
003AC2  BFCC40     MOV.B FLagArgbits, WREG
003AC4  604062     AND.B W0, #0x2, W0
003AC6  E00400     CP0.B W0
003AC8  320004     BRA Z, 0x3AD2
23:                                FLagArgbits.talarmFlag = 0;
003ACA  A92C40     BCLR FLagArgbits, #1
003ACC  370002     BRA 0x3AD2
24:                            }
25:                        } else {
26:                            gAlarmZeroLock = 1;
003ACE  B3C010     MOV.B #0x1, W0
003AD0  B7EC3E     MOV.B WREG, 0xC3E
27:                        }
28:                        Open_UART2();
003AD2  07FFA3     RCALL Open_UART2
29:                        UDPAlarmTask(); //GPRS上线报警
003AD4  07F3D7     RCALL UDPAlarmTask
30:                        Close_UART2();
003AD6  07FFA6     RCALL Close_UART2
31:                    }
32:                    if (FLagArgbits.CheckRTCCFlag) {
003AD8  BFCC40     MOV.B FLagArgbits, WREG
003ADA  604070     AND.B W0, #0x10, W0
003ADC  E00400     CP0.B W0
003ADE  32000E     BRA Z, 0x3AFC
33:                        Open_UART2();
003AE0  07FF9C     RCALL Open_UART2
34:                        if (GetUTCTask()) {
003AE2  07F30B     RCALL GetUTCTask
003AE4  E00400     CP0.B W0
003AE6  320003     BRA Z, 0x3AEE
35:                            StartRTCC();
003AE8  07FDC2     RCALL StartRTCC
36:                            Statusbits.staCheckRTCC = 0;
003AEA  A90C38     BCLR Statusbits, #0
003AEC  370001     BRA 0x3AF0
37:                        } else {
38:                            Statusbits.staCheckRTCC = 1;
003AEE  A80C38     BSET Statusbits, #0
39:                        }
40:                        Close_UART2();
003AF0  07FF99     RCALL Close_UART2
41:                        
42:                        FLagArgbits.CheckRTCCFlag = 0;
003AF2  A98C40     BCLR FLagArgbits, #4
43:                        Open_UART2();
003AF4  07FF92     RCALL Open_UART2
44:                        ChangeGPRSArg(GPRS_Arg2);
003AF6  28B920     MOV #0x8B92, W0
003AF8  07F423     RCALL ChangeGPRSArg
45:                        Close_UART2();
003AFA  07FF94     RCALL Close_UART2
46:                    }
47:                }
003AFC  FA8000     ULNK
003AFE  060000     RETURN
48:                
49:                
50:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/main.c  ----------------------------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年6月6日, 下午3:04
6:                  * note ：Fosc=8MHz  Fcy=2MHz
7:                  */
8:                 #include "AllInclude.h"
9:                 /*************************函数申明*****************************/
10:                void NVIC_Configuration(void);
11:                void OSC_Configuration(void);
12:                
13:                /*************************主函数*****************************/
14:                int main(void) {
003A2E  FA0000     LNK #0x0
15:                    OSC_Configuration();
003A30  070020     RCALL OSC_Configuration
16:                    NVIC_Configuration();
003A32  07001B     RCALL NVIC_Configuration
17:                    TIM1_Configuration();
003A34  07FAE0     RCALL TIM1_Configuration
18:                    TIM2_Configuration();
003A36  07FAFE     RCALL TIM2_Configuration
19:                    TIM3_Configuration();
003A38  07FB18     RCALL TIM3_Configuration
20:                    TIM4_Configuration();
003A3A  07FB30     RCALL TIM4_Configuration
21:                    UART2_Configuration();
003A3C  07FFBE     RCALL UART2_Configuration
22:                    FM25L64B_Init();
003A3E  07FBF3     RCALL FM25L64B_Init
23:                    GPRS_Init();
003A40  07F1D9     RCALL GPRS_Init
24:                    RS485_Init();
003A42  07FF2E     RCALL RS485_Init
25:                    ICN_Configuration();
003A44  07009C     RCALL ICN_Configuration
26:                    CopPCTask(); //上线10s    
003A46  07FF7D     RCALL CopPCTask
27:                    RefreshAllArg(); //刷新数据并写入实时时钟
003A48  07F8F7     RCALL RefreshAllArg
28:                    Open_UART2();
003A4A  07FFE7     RCALL Open_UART2
29:                    GetUTCTask();
003A4C  07F356     RCALL GetUTCTask
30:                    ChangeGPRSArg(GPRS_Arg2);
003A4E  28B920     MOV #0x8B92, W0
003A50  07F477     RCALL ChangeGPRSArg
31:                    Close_UART2();
003A52  07FFE8     RCALL Close_UART2
32:                    RTC_Configuration();
003A54  07FD71     RCALL RTC_Configuration
33:                
34:                    while (1) {
35:                        FLagArgbits.SleepExitFlag = 0;
003A56  A96C40     BCLR FLagArgbits, #3
36:                        while (!FLagArgbits.SleepExitFlag) {
003A58  370002     BRA 0x3A5E
003A5E  BFCC40     MOV.B FLagArgbits, WREG
003A60  604068     AND.B W0, #0x8, W0
003A62  E00400     CP0.B W0
003A64  32FFFA     BRA Z, 0x3A5A
37:                            ClrWdt();
003A5A  FE6000     CLRWDT
38:                            Sleep();
003A5C  FE4000     PWRSAV #0
39:                        }
40:                        Task_TimeUp();
003A66  070019     RCALL Task_TimeUp
41:                    }
003A68  37FFF6     BRA 0x3A56
42:                }
43:                
44:                /*************************************
45:                Function: NVIC_Configuration 
46:                Description: 中断配置
47:                Input: 无 
48:                Output: 无
49:                 *************************************/
50:                void NVIC_Configuration(void) {
003A6A  FA0000     LNK #0x0
51:                    INTCON1bits.NSTDIS = 0; //允许嵌套中断
003A6C  A9E081     BCLR 0x81, #7
52:                    //    IEC1bits.U2RXIE = 1;
53:                    //    IEC1bits.CNIE=1;//CNI使能中断
54:                    //    IEC0bits.T1IE = 1; //Enable Timer1 interrupts
55:                
56:                }
003A6E  FA8000     ULNK
003A70  060000     RETURN
57:                
58:                /*************************************
59:                 * Function: NVIC_Configuration 
60:                 * Description: 中断配置
61:                 * Input: 无 
62:                 * Output: 无
63:                 *************************************/
64:                void OSC_Configuration(void) {
003A72  FA0000     LNK #0x0
65:                    __builtin_write_OSCCONH(0x00);
003A74  EB0100     CLR W2
003A76  200781     MOV #0x78, W1
003A78  2009A0     MOV #0x9A, W0
003A7A  207433     MOV #0x743, W3
003A7C  784981     MOV.B W1, [W3]
003A7E  784980     MOV.B W0, [W3]
003A80  784982     MOV.B W2, [W3]
66:                    __builtin_write_OSCCONL(OSCCON | 0x06);
003A82  803A10     MOV OSCCON, W0
003A84  780100     MOV W0, W2
003A86  B30062     IOR #0x6, W2
003A88  200461     MOV #0x46, W1
003A8A  200570     MOV #0x57, W0
003A8C  207423     MOV #0x742, W3
003A8E  784981     MOV.B W1, [W3]
003A90  784980     MOV.B W0, [W3]
003A92  784982     MOV.B W2, [W3]
67:                    OSCCONbits.OSWEN = 1;
003A94  A80742     BSET OSCCON, #0
68:                    //    OSCCONbits.SOSCDRV = 1;//辅助振荡器驱动强度位
69:                    //    OSCCONbits.SOSCEN = 1;//32 kHz 辅助振荡器 （ SOSC）使能位   
70:                    //    CLKDIVbits.RCDIV = 0b011; //1 MHz （ 8 分频）
71:                }
003A96  FA8000     ULNK
003A98  060000     RETURN
72:                
73:                
74:                
75:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/UART.c  ----------------------------
1:                 //#include<p24Fxxxx.h>
2:                 #include "user.h"
3:                 //#include "p24FV32KA301.h"
4:                 
5:                 /*************************************
6:                 Function: UART2_Configuration 
7:                 Description: 串口2初始化
8:                 Input: 无 
9:                 Output: 无
10:                 *************************************/
11:                void UART2_Configuration(void) {
0039BA  FA0000     LNK #0x0
12:                    RX2_IN;
0039BC  A822C8     BSET TRISB, #1
13:                    TX2_OUT;
0039BE  A902C8     BCLR TRISB, #0
14:                    ANSBbits.ANSB1 = 0; //数字输入             
0039C0  A924E2     BCLR ANSB, #1
15:                    U2MODEbits.BRGH = 1; //High Baudrate
0039C2  A86230     BSET U2MODE, #3
16:                    U2BRG = 51; //19200 0.15%BRGVAL ((FP/BAUDRATE)/4) - 1
0039C4  200330     MOV #0x33, W0
0039C6  8811C0     MOV W0, U2BRG
17:                    U2MODEbits.USIDL = 0; //1 = 当器件进入空闲模式时，模块停止工作
0039C8  A9A231     BCLR 0x231, #5
18:                    U2MODEbits.UARTEN = 1;
0039CA  A8E231     BSET 0x231, #7
19:                    IFS1bits.U2RXIF = 0; // Clear the Recieve Interrupt Flag
0039CC  A9C087     BCLR 0x87, #6
20:                
21:                    U2STAbits.UTXEN = 0; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
0039CE  A94233     BCLR 0x233, #2
22:                
23:                    IPC7bits.U2RXIP = 7;
0039D0  BFC0B3     MOV.B 0xB3, WREG
0039D2  B34070     IOR.B #0x7, W0
0039D4  B7E0B3     MOV.B WREG, 0xB3
24:                    IEC1bits.U2RXIE = 0; //开启中断??????????????
0039D6  A9C097     BCLR 0x97, #6
25:                    U2STAbits.URXISEL = 0;
0039D8  BFC232     MOV.B U2STA, WREG
0039DA  B243F0     AND.B #0x3F, W0
0039DC  B7E232     MOV.B WREG, U2STA
26:                    //    U2TXREG=0x00;//先填充一次
27:                }
0039DE  FA8000     ULNK
0039E0  060000     RETURN
28:                
29:                /*************************************
30:                Function: UART2Send 
31:                Description: 串口2发送单个数据
32:                Input: u8类型数据 
33:                Output: 1 发送成功
34:                 *************************************/
35:                void UART2Send(const u8 dat) {
0039E2  FA0002     LNK #0x2
0039E4  784F00     MOV.B W0, [W14]
36:                    U2TXREG = dat;
0039E6  FB801E     ZE [W14], W0
0039E8  8811A0     MOV W0, U2TXREG
37:                    while (!U2STAbits.TRMT);
0039EA  BFC233     MOV.B 0x233, WREG
0039EC  604061     AND.B W0, #0x1, W0
0039EE  E00400     CP0.B W0
0039F0  32FFFC     BRA Z, 0x39EA
38:                }
0039F2  FA8000     ULNK
0039F4  060000     RETURN
39:                
40:                /*************************************
41:                Function: UART2SendString 
42:                Description: 串口2发送字符串
43:                Input: 指向u8类型的数据
44:                Output: 无
45:                 *************************************/
46:                void UART2SendString(const u8* ch, u8 bytes) {
0039F6  FA0006     LNK #0x6
0039F8  980710     MOV W0, [W14+2]
0039FA  984741     MOV.B W1, [W14+4]
47:                    u8 count = 0;
0039FC  EB4000     CLR.B W0
0039FE  784F00     MOV.B W0, [W14]
48:                    while (count < bytes) {
003A00  370007     BRA 0x3A10
003A10  90404E     MOV.B [W14+4], W0
003A12  104F9E     SUBR.B W0, [W14], [W15]
003A14  39FFF6     BRA NC, 0x3A02
49:                        UART2Send(*(ch + count));
003A02  FB801E     ZE [W14], W0
003A04  780080     MOV W0, W1
003A06  90001E     MOV [W14+2], W0
003A08  408000     ADD W1, W0, W0
003A0A  784010     MOV.B [W0], W0
003A0C  07FFEA     RCALL UART2Send
50:                        count++;
003A0E  E84F1E     INC.B [W14], [W14]
51:                    }
52:                }
003A16  FA8000     ULNK
003A18  060000     RETURN
53:                
54:                
55:                ///*************************************
56:                //Function: UART2_Receive 
57:                //Description: 获取实时时钟的时间
58:                //Input: 4个u16类型数据 
59:                //Output: 1接收成功
60:                //*************************************/
61:                // bool UART2Receive(u8* dat)
62:                //{   
63:                ////    if(U2STAbits.OERR)
64:                ////        U2STAbits.OERR = 0;
65:                //
66:                //    if(U2STAbits.URXDA)//    while(!U2STAbits.URXDA)
67:                //    {
68:                //        *dat = U2RXREG;
69:                //        return true;
70:                //    }
71:                //    else
72:                //        return false;
73:                //}
74:                
75:                void Open_UART2(void) {
003A1A  FA0000     LNK #0x0
76:                    U2STAbits.UTXEN = 1; //关闭串口以免设备一串口供电
003A1C  A84233     BSET 0x233, #2
77:                    IEC1bits.U2RXIE = 1; //开启中断
003A1E  A8C097     BSET 0x97, #6
78:                }
003A20  FA8000     ULNK
003A22  060000     RETURN
79:                
80:                void Close_UART2(void) {
003A24  FA0000     LNK #0x0
81:                    U2STAbits.UTXEN = 0; //关闭串口以免设备一串口供电
003A26  A94233     BCLR 0x233, #2
82:                    IEC1bits.U2RXIE = 0; //开启中断
003A28  A9C097     BCLR 0x97, #6
83:                }
003A2A  FA8000     ULNK
003A2C  060000     RETURN
84:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/TIM.c  -----------------------------
1:                 //#include<p24FV32KA301.h>
2:                 #include"type.h"
3:                 #include"user.h"
4:                 #include"time.h"
5:                 #include"string.h"
6:                 
7:                 //u16 StackValue;
8:                 vu16 gT2Count = 0; //记录定时器的数值
9:                 vu16 gT3Count = 0;
10:                vu32 gT1Count = 0; //记录溢出的次数 =1避免上线定时器在中断开启的时间短
11:                
12:                ///*************************************
13:                //Function: TIM23_Configuration 
14:                //Description: 32位定时器初始化 
15:                //Input: 无 
16:                //Output: 无
17:                // *************************************/
18:                //void TIM23_Configuration(void)//定时100ms基时
19:                //{
20:                //    T2CONbits.T32 = 1; //Enable 32-bit Timer operation
21:                //    T2CONbits.TCKPS = 0; //Stops any 16/32-bit Timer2 operation
22:                //    //    T3CONT3CON = 0x00;    //Stops any 16-bit Timer3 operation
23:                //    T2CONbits.TGATE = 0;
24:                //    T2CONbits.TCS = 0;
25:                //    T2CONbits.TSIDL = 0; //1 = 当器件进入空闲模式时，模块停止工作
26:                //    T3CONbits.TSIDL = 1;
27:                //    TMR3 = 0x0000; //Clear contents of the timer3 register
28:                //    TMR2 = 0x0000; //Clear contents of the timer2 register
29:                //    PR3 = 0x0006; //Load the Period register3 with the value 0xFFFF  100ms
30:                //    PR2 = 0x1A80; //Load the Period register2 with the value 0xFFFF  100ms 500K
31:                //    IPC2bits.T3IP = 0x4; //Setup Timer3 interrupt for desired priority level
32:                //    //(this example assigns level 1 priority)
33:                //    IFS0bits.T3IF = 0; //Clear the Timer3 interrupt status flag
34:                //    IEC0bits.T3IE = 1; //Enable Timer3 interrupts
35:                //
36:                //    T2CONbits.TON = 0;
37:                //    //    T2CONbits.TON = 1; //Start 32-bit timer with prescaler
38:                //    //settings at 1:1 and clock source set to
39:                //    //the internal instruction cycle
40:                //}
41:                
42:                /*************************************
43:                Function: TIM1_Configuration 
44:                Description: 16位定时器初始化 
45:                Input: 无 
46:                Output: 无
47:                 *************************************/
48:                void TIM1_Configuration(void) {
002FF6  FA0000     LNK #0x0
49:                    T1CONbits.TON = 1;
002FF8  A8E105     BSET 0x105, #7
50:                    T1CONbits.TSIDL = 1; //0 = 模块在空闲模式下继续工作
002FFA  A8A105     BSET 0x105, #5
51:                    T1CONbits.TCKPS = 0; //64us一个脉冲2(自动倍频)*500K/2=250k=2us 2us*256=512us=0.512ms
002FFC  201041     MOV #0x104, W1
002FFE  784091     MOV.B [W1], W1
003000  B3CCF0     MOV.B #0xCF, W0
003002  60C000     AND.B W1, W0, W0
003004  B7E104     MOV.B WREG, T1CON
52:                    T1CONbits.TCS = 1; //=1 T1ECS决定
003006  A82104     BSET T1CON, #1
53:                    T1CONbits.T1ECS = 0x00; //=0 SOSC
003008  201051     MOV #0x105, W1
00300A  784091     MOV.B [W1], W1
00300C  B3CFC0     MOV.B #0xFC, W0
00300E  60C000     AND.B W1, W0, W0
003010  B7E105     MOV.B WREG, 0x105
54:                    T1CONbits.TGATE = 0;
003012  A9C104     BCLR T1CON, #6
55:                    //    T1CONbits.TSYNC = 0;
56:                    PR1 = 4095; //125ms  32768Hz/8=
003014  20FFF0     MOV #0xFFF, W0
003016  880810     MOV W0, PR1
57:                    IPC0bits.T1IP = 6; //Setup Timer3 interrupt for desired priority level
003018  200A51     MOV #0xA5, W1
00301A  784091     MOV.B [W1], W1
00301C  B3C8F0     MOV.B #0x8F, W0
00301E  60C000     AND.B W1, W0, W0
003020  B3C601     MOV.B #0x60, W1
003022  704001     IOR.B W0, W1, W0
003024  B7E0A5     MOV.B WREG, 0xA5
58:                    //(this example assigns level 1 priority)
59:                    IFS0bits.T1IF = 0; //Clear the Timer3 interrupt status flag
003026  A96084     BCLR IFS0, #3
60:                    IEC0bits.T1IE = 1; //Enable Timer3 interrupts
003028  A86094     BSET IEC0, #3
61:                    TMR1 = 0;
00302A  EB0000     CLR W0
00302C  880800     MOV W0, TMR1
62:                    T1CONbits.TON = 0; //=0!!!!!!
00302E  A9E105     BCLR 0x105, #7
63:                }
003030  FA8000     ULNK
003032  060000     RETURN
64:                
65:                /*************************************
66:                Function: TIM4_Configuration 
67:                Description: 16位定时器初始化 
68:                Input: 无 
69:                Output: 无
70:                 *************************************/
71:                void TIM2_Configuration(void) {
003034  FA0000     LNK #0x0
72:                    T2CONbits.TON = 1;
003036  A8E111     BSET 0x111, #7
73:                    T2CONbits.TSIDL = 1;
003038  A8A111     BSET 0x111, #5
74:                    T2CONbits.TCKPS = 0; //1:1
00303A  201101     MOV #0x110, W1
00303C  784091     MOV.B [W1], W1
00303E  B3CCF0     MOV.B #0xCF, W0
003040  60C000     AND.B W1, W0, W0
003042  B7E110     MOV.B WREG, T2CON
75:                    T2CONbits.TCS = 0; //=1 内部时钟/2
003044  A92110     BCLR T2CON, #1
76:                    T2CONbits.TGATE = 0;
003046  A9C110     BCLR T2CON, #6
77:                    T2CONbits.T32 = 0; //16位独立
003048  A96110     BCLR T2CON, #3
78:                    PR2 = 40000; //4000 1ms    
00304A  29C400     MOV #0x9C40, W0
00304C  880860     MOV W0, PR2
79:                    IPC1bits.T2IP = 4; //Setup Timer3 interrupt for desired priority level
00304E  200A71     MOV #0xA7, W1
003050  784091     MOV.B [W1], W1
003052  B3C8F0     MOV.B #0x8F, W0
003054  60C000     AND.B W1, W0, W0
003056  B3C401     MOV.B #0x40, W1
003058  704001     IOR.B W0, W1, W0
00305A  B7E0A7     MOV.B WREG, 0xA7
80:                    //(this example assigns level 1 priority)
81:                    IFS0bits.T2IF = 0; //Clear the Timer3 interrupt status flag
00305C  A9E084     BCLR IFS0, #7
82:                    IEC0bits.T2IE = 1; //Enable Timer3 interrupts
00305E  A8E094     BSET IEC0, #7
83:                    TMR2 = 0;
003060  EB0000     CLR W0
003062  880830     MOV W0, TMR2
84:                    T2CONbits.TON = 0; //=0!!!!!!
003064  A9E111     BCLR 0x111, #7
85:                }
003066  FA8000     ULNK
003068  060000     RETURN
86:                
87:                /*************************************
88:                Function: TIM4_Configuration 
89:                Description: 16位定时器初始化 
90:                Input: 无 
91:                Output: 无
92:                 *************************************/
93:                void TIM3_Configuration(void) {
00306A  FA0000     LNK #0x0
94:                    T3CONbits.TON = 1;
00306C  A8E113     BSET 0x113, #7
95:                    T3CONbits.TSIDL = 1;
00306E  A8A113     BSET 0x113, #5
96:                    T3CONbits.TCKPS = 0; //1:1
003070  201121     MOV #0x112, W1
003072  784091     MOV.B [W1], W1
003074  B3CCF0     MOV.B #0xCF, W0
003076  60C000     AND.B W1, W0, W0
003078  B7E112     MOV.B WREG, T3CON
97:                    T3CONbits.TCS = 0; //=1 内部时钟/2
00307A  A92112     BCLR T3CON, #1
98:                    T3CONbits.TGATE = 0;
00307C  A9C112     BCLR T3CON, #6
99:                    //    T3CONbits.T32 = 0; //16位独立
100:                   PR3 = 40000; //4000 1ms    
00307E  29C400     MOV #0x9C40, W0
003080  880870     MOV W0, PR3
101:                   IPC2bits.T3IP = 4; //Setup Timer3 interrupt for desired priority level
003082  200A81     MOV #0xA8, W1
003084  784091     MOV.B [W1], W1
003086  B3CF80     MOV.B #0xF8, W0
003088  60C000     AND.B W1, W0, W0
00308A  A02400     BSET.B W0, #2
00308C  B7E0A8     MOV.B WREG, IPC2
102:                   //(this example assigns level 1 priority)
103:                   IFS0bits.T3IF = 0; //Clear the Timer3 interrupt status flag
00308E  A90085     BCLR 0x85, #0
104:                   IEC0bits.T3IE = 0; //Enable Timer3 interrupts
003090  A90095     BCLR 0x95, #0
105:                   TMR3 = 0;
003092  EB0000     CLR W0
003094  880850     MOV W0, TMR3
106:                   T3CONbits.TON = 0; //=0!!!!!!
003096  A9E113     BCLR 0x113, #7
107:               }
003098  FA8000     ULNK
00309A  060000     RETURN
108:               
109:               /*************************************
110:               Function: TIM4_Configuration 
111:               Description: 16位定时器初始化 
112:               Input: 无 
113:               Output: 无
114:                *************************************/
115:               void TIM4_Configuration(void) {
00309C  FA0000     LNK #0x0
116:                   T4CONbits.TON = 1;
00309E  A8E11F     BSET 0x11F, #7
117:                   T4CONbits.TSIDL = 1;
0030A0  A8A11F     BSET 0x11F, #5
118:                   T4CONbits.TCKPS = 0; //1:1
0030A2  2011E1     MOV #0x11E, W1
0030A4  784091     MOV.B [W1], W1
0030A6  B3CCF0     MOV.B #0xCF, W0
0030A8  60C000     AND.B W1, W0, W0
0030AA  B7E11E     MOV.B WREG, T4CON
119:                   T4CONbits.TCS = 0; //=1 内部时钟/2
0030AC  A9211E     BCLR T4CON, #1
120:                   T4CONbits.TGATE = 0;
0030AE  A9C11E     BCLR T4CON, #6
121:                   T4CONbits.T32 = 0; //16位独立
0030B0  A9611E     BCLR T4CON, #3
122:                   PR4 = 4000; //4000 1ms    
0030B2  20FA00     MOV #0xFA0, W0
0030B4  8808D0     MOV W0, PR4
123:                   IPC6bits.T4IP = 1; //Setup Timer3 interrupt for desired priority level
0030B6  200B11     MOV #0xB1, W1
0030B8  784091     MOV.B [W1], W1
0030BA  B3C8F0     MOV.B #0x8F, W0
0030BC  60C000     AND.B W1, W0, W0
0030BE  A04400     BSET.B W0, #4
0030C0  B7E0B1     MOV.B WREG, 0xB1
124:                   //(this example assigns level 1 priority)
125:                   IFS1bits.T4IF = 0; //Clear the Timer3 interrupt status flag
0030C2  A96087     BCLR 0x87, #3
126:                   IEC1bits.T4IE = 1; //Enable Timer3 interrupts
0030C4  A86097     BSET 0x97, #3
127:                   TMR4 = 0;
0030C6  EB0000     CLR W0
0030C8  8808A0     MOV W0, TMR4
128:                   T4CONbits.TON = 0; //=0!!!!!!
0030CA  A9E11F     BCLR 0x11F, #7
129:               }
0030CC  FA8000     ULNK
0030CE  060000     RETURN
130:               
131:               void StartTime2(void) {
0030D0  FA0000     LNK #0x0
132:                   gT2Count = 0;
0030D2  EB0000     CLR W0
0030D4  886100     MOV W0, 0xC20
133:                   T2CONbits.TON = 1; //开定时器 提高通讯稳定性
0030D6  A8E111     BSET 0x111, #7
134:               }
0030D8  FA8000     ULNK
0030DA  060000     RETURN
135:               
136:               void CloseTime2(void) {
0030DC  FA0000     LNK #0x0
137:                   T2CONbits.TON = 0; //关定时器
0030DE  A9E111     BCLR 0x111, #7
138:                   gT2Count = 0; //清除计数
0030E0  EB0000     CLR W0
0030E2  886100     MOV W0, 0xC20
139:                   //    TMR3 = 0x0000; //Clear contents of the timer3 register
140:                   TMR2 = 0x0000;
0030E4  EB0000     CLR W0
0030E6  880830     MOV W0, TMR2
141:               }
0030E8  FA8000     ULNK
0030EA  060000     RETURN
142:               
143:               void StartTime3(void) {
0030EC  FA0000     LNK #0x0
144:                   gT3Count = 0;
0030EE  EB0000     CLR W0
0030F0  886110     MOV W0, 0xC22
145:                   IEC0bits.T3IE = 1; //Enable Timer3 interrupts
0030F2  A80095     BSET 0x95, #0
146:                   T3CONbits.TON = 1; //开定时器 提高通讯稳定性
0030F4  A8E113     BSET 0x113, #7
147:               }
0030F6  FA8000     ULNK
0030F8  060000     RETURN
148:               
149:               void CloseTime3(void) {
0030FA  FA0000     LNK #0x0
150:                   IEC0bits.T3IE = 0; //Enable Timer3 interrupts
0030FC  A90095     BCLR 0x95, #0
151:                   T3CONbits.TON = 0; //关定时器
0030FE  A9E113     BCLR 0x113, #7
152:                   gT3Count = 0; //清除计数
003100  EB0000     CLR W0
003102  886110     MOV W0, 0xC22
153:                   TMR3 = 0x0000;
003104  EB0000     CLR W0
003106  880850     MOV W0, TMR3
154:               }
003108  FA8000     ULNK
00310A  060000     RETURN
155:               
156:               void T2Delay10ms(u16 time) {
00310C  FA0002     LNK #0x2
00310E  780F00     MOV W0, [W14]
157:                   StartTime2();
003110  07FFDF     RCALL StartTime2
158:                   while (time > gT2Count)ClrWdt(); // T2CONbits.TON = 1; //等待时间到 防止T4中断关闭定时器    
003112  370001     BRA 0x3116
003114  FE6000     CLRWDT
003116  806100     MOV 0xC20, W0
003118  100F9E     SUBR W0, [W14], [W15]
00311A  3EFFFC     BRA GTU, 0x3114
159:                   CloseTime2();
00311C  07FFDF     RCALL CloseTime2
160:               }
00311E  FA8000     ULNK
003120  060000     RETURN
161:               
162:               void T3Delay10ms(u16 time) {
003122  FA0002     LNK #0x2
003124  780F00     MOV W0, [W14]
163:                   StartTime3();
003126  07FFE2     RCALL StartTime3
164:               
165:                   while (time > gT3Count)ClrWdt(); // T2CONbits.TON = 1; //等待时间到 防止T4中断关闭定时器
003128  370001     BRA 0x312C
00312A  FE6000     CLRWDT
00312C  806110     MOV 0xC22, W0
00312E  100F9E     SUBR W0, [W14], [W15]
003130  3EFFFC     BRA GTU, 0x312A
166:               
167:                   CloseTime3();
003132  07FFE3     RCALL CloseTime3
168:               }
003134  FA8000     ULNK
003136  060000     RETURN
169:               
170:               bool T2IsOver(const u16 deadline) {
003138  FA0004     LNK #0x4
00313A  780F00     MOV W0, [W14]
171:                   ClrWdt();
00313C  FE6000     CLRWDT
172:                   return (gT2Count > deadline) ? 1 : 0;
00313E  806100     MOV 0xC20, W0
003140  EB0080     CLR W1
003142  980711     MOV W1, [W14+2]
003144  500F9E     SUB W0, [W14], [W15]
003146  360002     BRA LEU, 0x314C
003148  200010     MOV #0x1, W0
00314A  980710     MOV W0, [W14+2]
00314C  90001E     MOV [W14+2], W0
173:               }
00314E  FA8000     ULNK
003150  060000     RETURN
174:               
175:               bool T3IsOver(const u16 deadline) {//放在循环中判断是否是个死循环 使用之前需要清除Tcount
003152  FA0004     LNK #0x4
003154  780F00     MOV W0, [W14]
176:                   //    ClrWdt();
177:                   return (gT3Count > deadline) ? 1 : 0;
003156  806110     MOV 0xC22, W0
003158  EB0080     CLR W1
00315A  980711     MOV W1, [W14+2]
00315C  500F9E     SUB W0, [W14], [W15]
00315E  360002     BRA LEU, 0x3164
003160  200010     MOV #0x1, W0
003162  980710     MOV W0, [W14+2]
003164  90001E     MOV [W14+2], W0
178:               }
003166  FA8000     ULNK
003168  060000     RETURN
179:               //input 2016.1.1.0.0.0 output //1451577600
180:               
181:               void GetUnixTime_Char(u8* timeptr, u8* output) {
00316A  FA001E     LNK #0x1E
00316C  980F50     MOV W0, [W14+26]
00316E  980F61     MOV W1, [W14+28]
182:                   u8 cnt;
183:                   u32 times_l;
184:                   struct tm times;
185:                   void * ptr;
186:               
187:                   //    times.tm_year = (u16) *timeptr * 100 + *(timeptr + 1) - 1900;
188:                   times.tm_year = (u16)*(timeptr + 1) + 100; //2000-1900
003170  90085E     MOV [W14+26], W0
003172  E80000     INC W0, W0
003174  784010     MOV.B [W0], W0
003176  FB8000     ZE W0, W0
003178  B00640     ADD #0x64, W0
00317A  780080     MOV W0, W1
00317C  470068     ADD W14, #0x8, W0
00317E  980051     MOV W1, [W0+10]
189:                   times.tm_mon = *(timeptr + 2) - 1;
003180  90085E     MOV [W14+26], W0
003182  E88000     INC2 W0, W0
003184  784010     MOV.B [W0], W0
003186  FB8000     ZE W0, W0
003188  E90080     DEC W0, W1
00318A  470068     ADD W14, #0x8, W0
00318C  980041     MOV W1, [W0+8]
190:                   times.tm_mday = *(timeptr + 3);
00318E  90085E     MOV [W14+26], W0
003190  400063     ADD W0, #0x3, W0
003192  784010     MOV.B [W0], W0
003194  FB8080     ZE W0, W1
003196  470068     ADD W14, #0x8, W0
003198  980031     MOV W1, [W0+6]
191:                   times.tm_hour = *(timeptr + 4);
00319A  90085E     MOV [W14+26], W0
00319C  400064     ADD W0, #0x4, W0
00319E  784010     MOV.B [W0], W0
0031A0  FB8080     ZE W0, W1
0031A2  470068     ADD W14, #0x8, W0
0031A4  980021     MOV W1, [W0+4]
192:                   times.tm_min = *(timeptr + 5);
0031A6  90085E     MOV [W14+26], W0
0031A8  400065     ADD W0, #0x5, W0
0031AA  784010     MOV.B [W0], W0
0031AC  FB8080     ZE W0, W1
0031AE  470068     ADD W14, #0x8, W0
0031B0  980011     MOV W1, [W0+2]
193:                   times.tm_sec = *(timeptr + 6);
0031B2  90085E     MOV [W14+26], W0
0031B4  400066     ADD W0, #0x6, W0
0031B6  784010     MOV.B [W0], W0
0031B8  FB8080     ZE W0, W1
0031BA  470068     ADD W14, #0x8, W0
0031BC  780801     MOV W1, [W0]
194:                   times.tm_isdst = 0;
0031BE  4700E8     ADD W14, #0x8, W1
0031C0  EB0000     CLR W0
0031C2  980880     MOV W0, [W1+16]
195:                   times.tm_wday = 0;
0031C4  4700E8     ADD W14, #0x8, W1
0031C6  EB0000     CLR W0
0031C8  9800E0     MOV W0, [W1+12]
196:                   times.tm_yday = 0;
0031CA  4700E8     ADD W14, #0x8, W1
0031CC  EB0000     CLR W0
0031CE  9800F0     MOV W0, [W1+14]
197:               
198:                   times_l = mktime(&times) - 28800; //相差28000s
0031D0  470068     ADD W14, #0x8, W0
0031D2  07EC3E     RCALL _mktime
0031D4  BE0100     MOV.D W0, W2
0031D6  28F800     MOV #0x8F80, W0
0031D8  2FFFF1     MOV #0xFFFF, W1
0031DA  400002     ADD W0, W2, W0
0031DC  488083     ADDC W1, W3, W1
0031DE  980720     MOV W0, [W14+4]
0031E0  980731     MOV W1, [W14+6]
199:                   ptr = &times_l;
0031E2  470F64     ADD W14, #0x4, [W14]
200:               
201:                   for (cnt = 0; cnt < 4; cnt++)// {
0031E4  EB4000     CLR.B W0
0031E6  984720     MOV.B W0, [W14+2]
0031E8  37000F     BRA 0x3208
003202  90402E     MOV.B [W14+2], W0
003204  E84000     INC.B W0, W0
003206  984720     MOV.B W0, [W14+2]
003208  90402E     MOV.B [W14+2], W0
00320A  504FE3     SUB.B W0, #0x3, [W15]
00320C  36FFEE     BRA LEU, 0x31EA
202:                       *(output + cnt) = *((u8*) ptr + cnt);
0031EA  90402E     MOV.B [W14+2], W0
0031EC  FB8000     ZE W0, W0
0031EE  780080     MOV W0, W1
0031F0  90086E     MOV [W14+28], W0
0031F2  408100     ADD W1, W0, W2
0031F4  90402E     MOV.B [W14+2], W0
0031F6  FB8000     ZE W0, W0
0031F8  780080     MOV W0, W1
0031FA  78001E     MOV [W14], W0
0031FC  408000     ADD W1, W0, W0
0031FE  784010     MOV.B [W0], W0
003200  784900     MOV.B W0, [W2]
203:                   //        tmp = *(output + cnt);
204:                   //}
205:               }
00320E  FA8000     ULNK
003210  060000     RETURN
206:               
207:               /*************************************
208:               Function: delay_nop 
209:               Description: 用于调整SPI通讯的延时
210:               Input: 延时数量
211:               Output: 无
212:                *************************************/
213:               void Delay_Nop(u16 count) {
003212  FA0002     LNK #0x2
003214  780F00     MOV W0, [W14]
214:                   while (count--)
003216  370001     BRA 0x321A
00321A  E90F1E     DEC [W14], [W14]
00321C  EB8000     SETM W0
00321E  100F9E     SUBR W0, [W14], [W15]
003220  3AFFFB     BRA NZ, 0x3218
215:                       Nop();
003218  000000     NOP
216:               }
003222  FA8000     ULNK
003224  060000     RETURN
217:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/SerialBuffer.c  --------------------
1:                 #include "user.h"
2:                 //#include "p24FV32KA301.h"
3:                 
4:                 /**********************************定义****************************************/
5:                 #define BUFFERMAX 256
6:                 static u8 Buffer_uart1[BUFFERMAX];
7:                 static u8 bufferWptr_uart1 = 0;
8:                 static u8 bufferRptr_uart1 = 0;
9:                 
10:                static u8 Buffer_uart2[BUFFERMAX];
11:                static u8 bufferWptr_uart2 = 0;
12:                static u8 bufferRptr_uart2 = 0;
13:                
14:                /*************************************
15:                Function: BufferWrite 
16:                Description: 写数据到环形缓冲区
17:                Input: 串口号，1和2 
18:                Output: 无
19:                 *************************************/
20:                void BufferWrite_UART1(void) {
002404  FA0000     LNK #0x0
21:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1))//如果缓冲区已满 写的速度比读的速度块
002406  BFC800     MOV.B bufferWptr_uart1, WREG
002408  FB8080     ZE W0, W1
00240A  BFC801     MOV.B bufferRptr_uart1, WREG
00240C  FB8000     ZE W0, W0
00240E  E90000     DEC W0, W0
002410  508F80     SUB W1, W0, [W15]
002412  320012     BRA Z, 0x2438
22:                        return;
23:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
002414  BFC800     MOV.B bufferWptr_uart1, WREG
002416  FB8100     ZE W0, W2
002418  801130     MOV U1RXREG, W0
00241A  784080     MOV.B W0, W1
00241C  208040     MOV #0x804, W0
00241E  410000     ADD W2, W0, W0
002420  784801     MOV.B W1, [W0]
24:                    bufferWptr_uart1++;
002422  BFC800     MOV.B bufferWptr_uart1, WREG
002424  E84000     INC.B W0, W0
002426  B7E800     MOV.B WREG, bufferWptr_uart1
25:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 8) << 8);
002428  BFC800     MOV.B bufferWptr_uart1, WREG
00242A  784080     MOV.B W0, W1
00242C  BFC800     MOV.B bufferWptr_uart1, WREG
00242E  FB8000     ZE W0, W0
002430  DE8048     ASR W0, #8, W0
002432  DD0048     SL W0, #8, W0
002434  50C000     SUB.B W1, W0, W0
002436  B7E800     MOV.B WREG, bufferWptr_uart1
26:                    //bufferWptr_uart1 % BUFFERMAX; //bufferWptr_uart1 - (bufferWptr_uart1 >> 8) << 8; //// X - (X >> n) << n 取余数
27:                }
002438  FA8000     ULNK
00243A  060000     RETURN
28:                
29:                /*************************************
30:                Function: BufferWrite 
31:                Description: 写数据到环形缓冲区
32:                Input: 串口号，1和2 
33:                Output: 无
34:                 *************************************/
35:                void BufferWrite_UART2(void) {
00243C  FA0000     LNK #0x0
36:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1))//如果缓冲区已满 写的速度比读的速度块
00243E  BFC802     MOV.B bufferWptr_uart2, WREG
002440  FB8080     ZE W0, W1
002442  BFC803     MOV.B bufferRptr_uart2, WREG
002444  FB8000     ZE W0, W0
002446  E90000     DEC W0, W0
002448  508F80     SUB W1, W0, [W15]
00244A  320012     BRA Z, 0x2470
37:                        return;
38:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
00244C  BFC802     MOV.B bufferWptr_uart2, WREG
00244E  FB8100     ZE W0, W2
002450  8011B0     MOV U2RXREG, W0
002452  784080     MOV.B W0, W1
002454  209040     MOV #0x904, W0
002456  410000     ADD W2, W0, W0
002458  784801     MOV.B W1, [W0]
39:                    bufferWptr_uart2++;
00245A  BFC802     MOV.B bufferWptr_uart2, WREG
00245C  E84000     INC.B W0, W0
00245E  B7E802     MOV.B WREG, bufferWptr_uart2
40:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 8) << 8); //bufferWptr_uart2%BUFFERMAX
002460  BFC802     MOV.B bufferWptr_uart2, WREG
002462  784080     MOV.B W0, W1
002464  BFC802     MOV.B bufferWptr_uart2, WREG
002466  FB8000     ZE W0, W0
002468  DE8048     ASR W0, #8, W0
00246A  DD0048     SL W0, #8, W0
00246C  50C000     SUB.B W1, W0, W0
00246E  B7E802     MOV.B WREG, bufferWptr_uart2
41:                    //X - (X >> n) << n 取余数bufferWptr_uart2 - (bufferWptr_uart2 >> 8) << 8; 
42:                }
002470  FA8000     ULNK
002472  060000     RETURN
43:                
44:                /*************************************
45:                Function:  BufferRead
46:                Description: 读环形缓冲区
47:                Input: 数据地址 
48:                Output: 1：读取成功，0：读取失败
49:                 *************************************/
50:                bool BufferRead_UART1(u8 *data) {
002474  FA0004     LNK #0x4
002476  780F00     MOV W0, [W14]
51:                    if (bufferRptr_uart1 == bufferWptr_uart1)
002478  208011     MOV #0x801, W1
00247A  784091     MOV.B [W1], W1
00247C  BFC800     MOV.B bufferWptr_uart1, WREG
00247E  50CF80     SUB.B W1, W0, [W15]
002480  3A0003     BRA NZ, 0x2488
52:                        return 0;
002482  EB0000     CLR W0
002484  980710     MOV W0, [W14+2]
002486  370014     BRA 0x24B0
53:                    *data = Buffer_uart1[bufferRptr_uart1];
002488  BFC801     MOV.B bufferRptr_uart1, WREG
00248A  FB8080     ZE W0, W1
00248C  208040     MOV #0x804, W0
00248E  408000     ADD W1, W0, W0
002490  784090     MOV.B [W0], W1
002492  78001E     MOV [W14], W0
002494  784801     MOV.B W1, [W0]
54:                    bufferRptr_uart1++;
002496  BFC801     MOV.B bufferRptr_uart1, WREG
002498  E84000     INC.B W0, W0
00249A  B7E801     MOV.B WREG, bufferRptr_uart1
55:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 8) << 8); //bufferRptr_uart1 % BUFFERMAX; 
00249C  BFC801     MOV.B bufferRptr_uart1, WREG
00249E  784080     MOV.B W0, W1
0024A0  BFC801     MOV.B bufferRptr_uart1, WREG
0024A2  FB8000     ZE W0, W0
0024A4  DE8048     ASR W0, #8, W0
0024A6  DD0048     SL W0, #8, W0
0024A8  50C000     SUB.B W1, W0, W0
0024AA  B7E801     MOV.B WREG, bufferRptr_uart1
56:                    //bufferRptr_uart1 - (bufferRptr_uart1 >> 8) << 8; // // X - (X >> n) << n 取余数
57:                    return 1;
0024AC  200010     MOV #0x1, W0
0024AE  980710     MOV W0, [W14+2]
0024B0  90001E     MOV [W14+2], W0
58:                }
0024B2  FA8000     ULNK
0024B4  060000     RETURN
59:                
60:                /*************************************
61:                Function:  BufferRead
62:                Description: 读环形缓冲区
63:                Input: 数据地址 
64:                Output: 1：读取成功，0：读取失败
65:                 *************************************/
66:                bool BufferRead_UART2(u8 *data) {
0024B6  FA0004     LNK #0x4
0024B8  780F00     MOV W0, [W14]
67:                    if (bufferRptr_uart2 == bufferWptr_uart2)
0024BA  208031     MOV #0x803, W1
0024BC  784091     MOV.B [W1], W1
0024BE  BFC802     MOV.B bufferWptr_uart2, WREG
0024C0  50CF80     SUB.B W1, W0, [W15]
0024C2  3A0003     BRA NZ, 0x24CA
68:                        return 0;
0024C4  EB0000     CLR W0
0024C6  980710     MOV W0, [W14+2]
0024C8  370014     BRA 0x24F2
69:                    *data = Buffer_uart2[bufferRptr_uart2];
0024CA  BFC803     MOV.B bufferRptr_uart2, WREG
0024CC  FB8080     ZE W0, W1
0024CE  209040     MOV #0x904, W0
0024D0  408000     ADD W1, W0, W0
0024D2  784090     MOV.B [W0], W1
0024D4  78001E     MOV [W14], W0
0024D6  784801     MOV.B W1, [W0]
70:                    bufferRptr_uart2++;
0024D8  BFC803     MOV.B bufferRptr_uart2, WREG
0024DA  E84000     INC.B W0, W0
0024DC  B7E803     MOV.B WREG, bufferRptr_uart2
71:                    bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 8) << 8);
0024DE  BFC803     MOV.B bufferRptr_uart2, WREG
0024E0  784080     MOV.B W0, W1
0024E2  BFC803     MOV.B bufferRptr_uart2, WREG
0024E4  FB8000     ZE W0, W0
0024E6  DE8048     ASR W0, #8, W0
0024E8  DD0048     SL W0, #8, W0
0024EA  50C000     SUB.B W1, W0, W0
0024EC  B7E803     MOV.B WREG, bufferRptr_uart2
72:                    //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
73:                    return 1;
0024EE  200010     MOV #0x1, W0
0024F0  980710     MOV W0, [W14+2]
0024F2  90001E     MOV [W14+2], W0
74:                }
0024F4  FA8000     ULNK
0024F6  060000     RETURN
75:                
76:                /*************************************
77:                Function: UART2DataIsGet  
78:                Description: deadline时间内，从串口缓冲区取bytes个字节数据，判断帧头head 
79:                 * 校验方式 帧头+CRC16
80:                Input: 
81:                Output: 返回字节数
82:                Notice：字节数不能大于256 取数据的时间可能短   
83:                 *************************************/
84:                u8 UART2DataIsGet(u8 *dat, const u8 *head, u8 num,const u16 dealline) {
0024F8  FA0018     LNK #0x18
0024FA  980720     MOV W0, [W14+4]
0024FC  980731     MOV W1, [W14+6]
0024FE  984F02     MOV.B W2, [W14+8]
002500  980753     MOV W3, [W14+10]
85:                    u8 byte = 0; //记录字节数
002502  EB4000     CLR.B W0
002504  984720     MOV.B W0, [W14+2]
86:                    //    u8 now = 0, last = 0; //保存数据
87:                    u16 timeCount = 0;
002506  EB0000     CLR W0
002508  780F00     MOV W0, [W14]
88:                    *dat = 0;
00250A  9000AE     MOV [W14+4], W1
00250C  EB4000     CLR.B W0
00250E  784880     MOV.B W0, [W1]
89:                
90:                    StartTime3(); //开启定时器 
002510  0705ED     RCALL StartTime3
91:                    while (1) //在中断中接收数据，并在数据中寻找有效数据
92:                    {
93:                        ClrWdt(); //清除看门狗 
002512  FE6000     CLRWDT
94:                        if (BufferRead_UART2(dat + byte)) //接收数据
002514  90402E     MOV.B [W14+2], W0
002516  FB8000     ZE W0, W0
002518  780080     MOV W0, W1
00251A  90002E     MOV [W14+4], W0
00251C  408000     ADD W1, W0, W0
00251E  07FFCB     RCALL BufferRead_UART2
002520  E00400     CP0.B W0
002522  3200DC     BRA Z, 0x26DC
95:                        {
96:                            timeCount = gT3Count;
002524  806110     MOV 0xC22, W0
002526  780F00     MOV W0, [W14]
97:                            switch (byte) //没寻找帧头
002528  90402E     MOV.B [W14+2], W0
00252A  FB8000     ZE W0, W0
00252C  980F30     MOV W0, [W14+22]
00252E  90083E     MOV [W14+22], W0
002530  500FE3     SUB W0, #0x3, [W15]
002532  32005D     BRA Z, 0x25EE
002534  90083E     MOV [W14+22], W0
002536  500FE3     SUB W0, #0x3, [W15]
002538  3C000A     BRA GT, 0x254E
00253A  90083E     MOV [W14+22], W0
00253C  500FE1     SUB W0, #0x1, [W15]
00253E  320029     BRA Z, 0x2592
002540  90083E     MOV [W14+22], W0
002542  500FE1     SUB W0, #0x1, [W15]
002544  3C003D     BRA GT, 0x25C0
002546  90083E     MOV [W14+22], W0
002548  E00000     CP0 W0
00254A  32000E     BRA Z, 0x2568
00254C  3700C3     BRA 0x26D4
00254E  90083E     MOV [W14+22], W0
002550  500FE5     SUB W0, #0x5, [W15]
002552  32007B     BRA Z, 0x264A
002554  90083E     MOV [W14+22], W0
002556  500FE5     SUB W0, #0x5, [W15]
002558  350061     BRA LT, 0x261C
00255A  90083E     MOV [W14+22], W0
00255C  500FE6     SUB W0, #0x6, [W15]
00255E  32008C     BRA Z, 0x2678
002560  90083E     MOV [W14+22], W0
002562  500FE7     SUB W0, #0x7, [W15]
002564  3200A0     BRA Z, 0x26A6
002566  3700B6     BRA 0x26D4
98:                            {
99:                                case 0:
100:                               {
101:                                   byte = (*(dat) == *head) ? 1 : 0;
002568  90002E     MOV [W14+4], W0
00256A  784110     MOV.B [W0], W2
00256C  90003E     MOV [W14+6], W0
00256E  784090     MOV.B [W0], W1
002570  EB4000     CLR.B W0
002572  984720     MOV.B W0, [W14+2]
002574  514F81     SUB.B W2, W1, [W15]
002576  3A0002     BRA NZ, 0x257C
002578  B3C010     MOV.B #0x1, W0
00257A  984720     MOV.B W0, [W14+2]
102:                                   if (!byte) {
00257C  90402E     MOV.B [W14+2], W0
00257E  E00400     CP0.B W0
002580  3A00BA     BRA NZ, 0x26F6
103:                                       *gUARTtmp = *(gUARTtmp + 1);
002582  20C430     MOV #0xC43, W0
002584  784010     MOV.B [W0], W0
002586  B7EC42     MOV.B WREG, gUARTtmp
104:                                       *(gUARTtmp + 1) = *dat;
002588  20C431     MOV #0xC43, W1
00258A  90002E     MOV [W14+4], W0
00258C  784010     MOV.B [W0], W0
00258E  784880     MOV.B W0, [W1]
105:                                   }
106:                                   break;
002590  3700B2     BRA 0x26F6
107:                               }
108:                               case 1:
109:                               {
110:                                   if (num > 1)
002592  90480E     MOV.B [W14+8], W0
002594  504FE1     SUB.B W0, #0x1, [W15]
002596  360010     BRA LEU, 0x25B8
111:                                       byte = (*(dat + 1) == *(head + 1)) ? 2 : 0;
002598  90002E     MOV [W14+4], W0
00259A  E80000     INC W0, W0
00259C  784090     MOV.B [W0], W1
00259E  90003E     MOV [W14+6], W0
0025A0  E80000     INC W0, W0
0025A2  784010     MOV.B [W0], W0
0025A4  50CF80     SUB.B W1, W0, [W15]
0025A6  3A0003     BRA NZ, 0x25AE
0025A8  B3C020     MOV.B #0x2, W0
0025AA  985740     MOV.B W0, [W14+20]
0025AC  370002     BRA 0x25B2
0025AE  EB4000     CLR.B W0
0025B0  985740     MOV.B W0, [W14+20]
0025B2  90504E     MOV.B [W14+20], W0
0025B4  984720     MOV.B W0, [W14+2]
0025B6  37009F     BRA 0x26F6
112:                                   else
113:                                       byte += 1;
0025B8  90402E     MOV.B [W14+2], W0
0025BA  E84000     INC.B W0, W0
0025BC  984720     MOV.B W0, [W14+2]
114:                                   break;
0025BE  37009B     BRA 0x26F6
115:                               }
116:                               case 2:
117:                               {
118:                                   if (num > 2)
0025C0  90480E     MOV.B [W14+8], W0
0025C2  504FE2     SUB.B W0, #0x2, [W15]
0025C4  360010     BRA LEU, 0x25E6
119:                                       byte = (*(dat + 2) == *(head + 2)) ? 3 : 0;
0025C6  90002E     MOV [W14+4], W0
0025C8  E88000     INC2 W0, W0
0025CA  784090     MOV.B [W0], W1
0025CC  90003E     MOV [W14+6], W0
0025CE  E88000     INC2 W0, W0
0025D0  784010     MOV.B [W0], W0
0025D2  50CF80     SUB.B W1, W0, [W15]
0025D4  3A0003     BRA NZ, 0x25DC
0025D6  B3C030     MOV.B #0x3, W0
0025D8  985730     MOV.B W0, [W14+19]
0025DA  370002     BRA 0x25E0
0025DC  EB4000     CLR.B W0
0025DE  985730     MOV.B W0, [W14+19]
0025E0  90503E     MOV.B [W14+19], W0
0025E2  984720     MOV.B W0, [W14+2]
0025E4  370088     BRA 0x26F6
120:                                   else
121:                                       byte += 1;
0025E6  90402E     MOV.B [W14+2], W0
0025E8  E84000     INC.B W0, W0
0025EA  984720     MOV.B W0, [W14+2]
122:                                   break;
0025EC  370084     BRA 0x26F6
123:                               }
124:                               case 3:
125:                               {
126:                                   if (num > 3)
0025EE  90480E     MOV.B [W14+8], W0
0025F0  504FE3     SUB.B W0, #0x3, [W15]
0025F2  360010     BRA LEU, 0x2614
127:                                       byte = (*(dat + 3) == *(head + 3)) ? 4 : 0;
0025F4  90002E     MOV [W14+4], W0
0025F6  400063     ADD W0, #0x3, W0
0025F8  784090     MOV.B [W0], W1
0025FA  90003E     MOV [W14+6], W0
0025FC  400063     ADD W0, #0x3, W0
0025FE  784010     MOV.B [W0], W0
002600  50CF80     SUB.B W1, W0, [W15]
002602  3A0003     BRA NZ, 0x260A
002604  B3C040     MOV.B #0x4, W0
002606  985720     MOV.B W0, [W14+18]
002608  370002     BRA 0x260E
00260A  EB4000     CLR.B W0
00260C  985720     MOV.B W0, [W14+18]
00260E  90502E     MOV.B [W14+18], W0
002610  984720     MOV.B W0, [W14+2]
002612  370071     BRA 0x26F6
128:                                   else
129:                                       byte += 1;
002614  90402E     MOV.B [W14+2], W0
002616  E84000     INC.B W0, W0
002618  984720     MOV.B W0, [W14+2]
130:                                   break;
00261A  37006D     BRA 0x26F6
131:                               }
132:                               case 4:
133:                               {
134:                                   if (num > 4)
00261C  90480E     MOV.B [W14+8], W0
00261E  504FE4     SUB.B W0, #0x4, [W15]
002620  360010     BRA LEU, 0x2642
135:                                       byte = (*(dat + 4) == *(head + 4)) ? 5 : 0;
002622  90002E     MOV [W14+4], W0
002624  400064     ADD W0, #0x4, W0
002626  784090     MOV.B [W0], W1
002628  90003E     MOV [W14+6], W0
00262A  400064     ADD W0, #0x4, W0
00262C  784010     MOV.B [W0], W0
00262E  50CF80     SUB.B W1, W0, [W15]
002630  3A0003     BRA NZ, 0x2638
002632  B3C050     MOV.B #0x5, W0
002634  985710     MOV.B W0, [W14+17]
002636  370002     BRA 0x263C
002638  EB4000     CLR.B W0
00263A  985710     MOV.B W0, [W14+17]
00263C  90501E     MOV.B [W14+17], W0
00263E  984720     MOV.B W0, [W14+2]
002640  37005A     BRA 0x26F6
136:                                   else
137:                                       byte += 1;
002642  90402E     MOV.B [W14+2], W0
002644  E84000     INC.B W0, W0
002646  984720     MOV.B W0, [W14+2]
138:                                   break;
002648  370056     BRA 0x26F6
139:                               }
140:                               case 5:
141:                               {
142:                                   if (num > 5)
00264A  90480E     MOV.B [W14+8], W0
00264C  504FE5     SUB.B W0, #0x5, [W15]
00264E  360010     BRA LEU, 0x2670
143:                                       byte = (*(dat + 5) == *(head + 5)) ? 6 : 0;
002650  90002E     MOV [W14+4], W0
002652  400065     ADD W0, #0x5, W0
002654  784090     MOV.B [W0], W1
002656  90003E     MOV [W14+6], W0
002658  400065     ADD W0, #0x5, W0
00265A  784010     MOV.B [W0], W0
00265C  50CF80     SUB.B W1, W0, [W15]
00265E  3A0003     BRA NZ, 0x2666
002660  B3C060     MOV.B #0x6, W0
002662  985700     MOV.B W0, [W14+16]
002664  370002     BRA 0x266A
002666  EB4000     CLR.B W0
002668  985700     MOV.B W0, [W14+16]
00266A  90500E     MOV.B [W14+16], W0
00266C  984720     MOV.B W0, [W14+2]
00266E  370043     BRA 0x26F6
144:                                   else
145:                                       byte += 1;
002670  90402E     MOV.B [W14+2], W0
002672  E84000     INC.B W0, W0
002674  984720     MOV.B W0, [W14+2]
146:                                   break;
002676  37003F     BRA 0x26F6
147:                               }
148:                               case 6:
149:                               {
150:                                   if (num > 6)
002678  90480E     MOV.B [W14+8], W0
00267A  504FE6     SUB.B W0, #0x6, [W15]
00267C  360010     BRA LEU, 0x269E
151:                                       byte = (*(dat + 6) == *(head + 6)) ? 7 : 0;
00267E  90002E     MOV [W14+4], W0
002680  400066     ADD W0, #0x6, W0
002682  784090     MOV.B [W0], W1
002684  90003E     MOV [W14+6], W0
002686  400066     ADD W0, #0x6, W0
002688  784010     MOV.B [W0], W0
00268A  50CF80     SUB.B W1, W0, [W15]
00268C  3A0003     BRA NZ, 0x2694
00268E  B3C070     MOV.B #0x7, W0
002690  984F70     MOV.B W0, [W14+15]
002692  370002     BRA 0x2698
002694  EB4000     CLR.B W0
002696  984F70     MOV.B W0, [W14+15]
002698  90487E     MOV.B [W14+15], W0
00269A  984720     MOV.B W0, [W14+2]
00269C  37002C     BRA 0x26F6
152:                                   else
153:                                       byte += 1;
00269E  90402E     MOV.B [W14+2], W0
0026A0  E84000     INC.B W0, W0
0026A2  984720     MOV.B W0, [W14+2]
154:                                   break;
0026A4  370028     BRA 0x26F6
155:                               }
156:                               case 7:
157:                               {
158:                                   if (num > 7)
0026A6  90480E     MOV.B [W14+8], W0
0026A8  504FE7     SUB.B W0, #0x7, [W15]
0026AA  360010     BRA LEU, 0x26CC
159:                                       byte = (*(dat + 7) == *(head + 7)) ? 8 : 0;
0026AC  90002E     MOV [W14+4], W0
0026AE  400067     ADD W0, #0x7, W0
0026B0  784090     MOV.B [W0], W1
0026B2  90003E     MOV [W14+6], W0
0026B4  400067     ADD W0, #0x7, W0
0026B6  784010     MOV.B [W0], W0
0026B8  50CF80     SUB.B W1, W0, [W15]
0026BA  3A0003     BRA NZ, 0x26C2
0026BC  B3C080     MOV.B #0x8, W0
0026BE  984F60     MOV.B W0, [W14+14]
0026C0  370002     BRA 0x26C6
0026C2  EB4000     CLR.B W0
0026C4  984F60     MOV.B W0, [W14+14]
0026C6  90486E     MOV.B [W14+14], W0
0026C8  984720     MOV.B W0, [W14+2]
0026CA  370015     BRA 0x26F6
160:                                   else
161:                                       byte += 1;
0026CC  90402E     MOV.B [W14+2], W0
0026CE  E84000     INC.B W0, W0
0026D0  984720     MOV.B W0, [W14+2]
162:                                   break;
0026D2  370011     BRA 0x26F6
163:                               }
164:                               default:
165:                               {
166:                                   byte++;
0026D4  90402E     MOV.B [W14+2], W0
0026D6  E84000     INC.B W0, W0
0026D8  984720     MOV.B W0, [W14+2]
0026DA  37000D     BRA 0x26F6
167:                                   break;
168:                               }
169:                           } //记录字节数 用于校验;                   
170:                       } else {//如果获取到数据且100ms内没有收到数据，退出并放回字节数
171:                           if (byte && (gT3Count > timeCount + 10)) {
0026DC  90402E     MOV.B [W14+2], W0
0026DE  E00400     CP0.B W0
0026E0  32000A     BRA Z, 0x26F6
0026E2  78001E     MOV [W14], W0
0026E4  4000EA     ADD W0, #0xA, W1
0026E6  806110     MOV 0xC22, W0
0026E8  508F80     SUB W1, W0, [W15]
0026EA  310005     BRA C, 0x26F6
172:                               CloseTime3();
0026EC  070506     RCALL CloseTime3
173:                               return byte;
0026EE  90402E     MOV.B [W14+2], W0
0026F0  FB8000     ZE W0, W0
0026F2  980760     MOV W0, [W14+12]
0026F4  370007     BRA 0x2704
174:                           }
175:                       }
176:               
177:                       if (T3IsOver(dealline)) //10s内没有接收数据
0026F6  90005E     MOV [W14+10], W0
0026F8  07052C     RCALL T3IsOver
0026FA  E00000     CP0 W0
0026FC  32FF0A     BRA Z, 0x2512
178:                       {
179:                           CloseTime3();
0026FE  0704FD     RCALL CloseTime3
180:                           return 0;
002700  EB0000     CLR W0
002702  980760     MOV W0, [W14+12]
181:                       }
182:                   }
002704  90006E     MOV [W14+12], W0
183:               }
002706  FA8000     ULNK
002708  060000     RETURN
184:               
185:               /*************************************
186:               Function: UART1DataIsGet  
187:               Description: deadline时间内，从串口缓冲区取bytes个字节数据，判断帧头head 
188:                * 校验方式 帧头+CRC16
189:               Input: 
190:               Output: 返回字节数
191:               Notice：字节数不能大于256 取数据的时间可能短   
192:                *************************************/
193:               u8 UART1IsGet(u8 *dat, u8* head, u8 num) {
00270A  FA0016     LNK #0x16
00270C  980720     MOV W0, [W14+4]
00270E  980731     MOV W1, [W14+6]
002710  984F02     MOV.B W2, [W14+8]
194:                   u8 byte = 0; //记录字节数
002712  EB4000     CLR.B W0
002714  984720     MOV.B W0, [W14+2]
195:                   u16 timeCount = 0;
002716  EB0000     CLR W0
002718  780F00     MOV W0, [W14]
196:                   *dat = 0;
00271A  9000AE     MOV [W14+4], W1
00271C  EB4000     CLR.B W0
00271E  784880     MOV.B W0, [W1]
197:               
198:                   StartTime2();
002720  0704D7     RCALL StartTime2
199:               
200:                   while (1) //在中断中接收数据，并在数据中寻找有效数据
201:                   {
202:                       ClrWdt(); //清除看门狗  
002722  FE6000     CLRWDT
203:                       if (BufferRead_UART1(dat + byte)) //接收数据
002724  90402E     MOV.B [W14+2], W0
002726  FB8000     ZE W0, W0
002728  780080     MOV W0, W1
00272A  90002E     MOV [W14+4], W0
00272C  408000     ADD W1, W0, W0
00272E  07FEA2     RCALL BufferRead_UART1
002730  E00400     CP0.B W0
002732  3200D2     BRA Z, 0x28D8
204:                       {
205:                           timeCount = gT2Count;
002734  806100     MOV 0xC20, W0
002736  780F00     MOV W0, [W14]
206:                           switch (byte) //没寻找帧头
002738  90402E     MOV.B [W14+2], W0
00273A  FB8000     ZE W0, W0
00273C  980F20     MOV W0, [W14+20]
00273E  9008AE     MOV [W14+20], W1
002740  508FE3     SUB W1, #0x3, [W15]
002742  320053     BRA Z, 0x27EA
002744  90082E     MOV [W14+20], W0
002746  500FE3     SUB W0, #0x3, [W15]
002748  3C000A     BRA GT, 0x275E
00274A  9008AE     MOV [W14+20], W1
00274C  508FE1     SUB W1, #0x1, [W15]
00274E  32001F     BRA Z, 0x278E
002750  90082E     MOV [W14+20], W0
002752  500FE1     SUB W0, #0x1, [W15]
002754  3C0033     BRA GT, 0x27BC
002756  9008AE     MOV [W14+20], W1
002758  E00001     CP0 W1
00275A  32000E     BRA Z, 0x2778
00275C  3700B9     BRA 0x28D0
00275E  90082E     MOV [W14+20], W0
002760  500FE5     SUB W0, #0x5, [W15]
002762  320071     BRA Z, 0x2846
002764  9008AE     MOV [W14+20], W1
002766  508FE5     SUB W1, #0x5, [W15]
002768  350057     BRA LT, 0x2818
00276A  90082E     MOV [W14+20], W0
00276C  500FE6     SUB W0, #0x6, [W15]
00276E  320082     BRA Z, 0x2874
002770  9008AE     MOV [W14+20], W1
002772  508FE7     SUB W1, #0x7, [W15]
002774  320096     BRA Z, 0x28A2
002776  3700AC     BRA 0x28D0
207:                           {
208:                               case 0:
209:                               {
210:                                   byte = (*(dat) == *head) ? 1 : 0;
002778  90002E     MOV [W14+4], W0
00277A  784110     MOV.B [W0], W2
00277C  90003E     MOV [W14+6], W0
00277E  784090     MOV.B [W0], W1
002780  EB4000     CLR.B W0
002782  984720     MOV.B W0, [W14+2]
002784  514F81     SUB.B W2, W1, [W15]
002786  3A00B5     BRA NZ, 0x28F2
002788  B3C010     MOV.B #0x1, W0
00278A  984720     MOV.B W0, [W14+2]
211:                                   break;
00278C  3700B2     BRA 0x28F2
212:                               }
213:                               case 1:
214:                               {
215:                                   if (num > 1)
00278E  90480E     MOV.B [W14+8], W0
002790  504FE1     SUB.B W0, #0x1, [W15]
002792  360010     BRA LEU, 0x27B4
216:                                       byte = (*(dat + 1) == *(head + 1)) ? 2 : 0;
002794  90002E     MOV [W14+4], W0
002796  E80000     INC W0, W0
002798  784090     MOV.B [W0], W1
00279A  90003E     MOV [W14+6], W0
00279C  E80000     INC W0, W0
00279E  784010     MOV.B [W0], W0
0027A0  50CF80     SUB.B W1, W0, [W15]
0027A2  3A0003     BRA NZ, 0x27AA
0027A4  B3C020     MOV.B #0x2, W0
0027A6  985720     MOV.B W0, [W14+18]
0027A8  370002     BRA 0x27AE
0027AA  EB4080     CLR.B W1
0027AC  985721     MOV.B W1, [W14+18]
0027AE  90502E     MOV.B [W14+18], W0
0027B0  984720     MOV.B W0, [W14+2]
0027B2  37009F     BRA 0x28F2
217:                                   else
218:                                       byte += 1;
0027B4  90402E     MOV.B [W14+2], W0
0027B6  E84000     INC.B W0, W0
0027B8  984720     MOV.B W0, [W14+2]
219:                                   break;
0027BA  37009B     BRA 0x28F2
220:                               }
221:                               case 2:
222:                               {
223:                                   if (num > 2)
0027BC  90480E     MOV.B [W14+8], W0
0027BE  504FE2     SUB.B W0, #0x2, [W15]
0027C0  360010     BRA LEU, 0x27E2
224:                                       byte = (*(dat + 2) == *(head + 2)) ? 3 : 0;
0027C2  90002E     MOV [W14+4], W0
0027C4  E88000     INC2 W0, W0
0027C6  784090     MOV.B [W0], W1
0027C8  90003E     MOV [W14+6], W0
0027CA  E88000     INC2 W0, W0
0027CC  784010     MOV.B [W0], W0
0027CE  50CF80     SUB.B W1, W0, [W15]
0027D0  3A0003     BRA NZ, 0x27D8
0027D2  B3C031     MOV.B #0x3, W1
0027D4  985711     MOV.B W1, [W14+17]
0027D6  370002     BRA 0x27DC
0027D8  EB4000     CLR.B W0
0027DA  985710     MOV.B W0, [W14+17]
0027DC  90509E     MOV.B [W14+17], W1
0027DE  984721     MOV.B W1, [W14+2]
0027E0  370088     BRA 0x28F2
225:                                   else
226:                                       byte += 1;
0027E2  90402E     MOV.B [W14+2], W0
0027E4  E84000     INC.B W0, W0
0027E6  984720     MOV.B W0, [W14+2]
227:                                   break;
0027E8  370084     BRA 0x28F2
228:                               }
229:                               case 3:
230:                               {
231:                                   if (num > 3)
0027EA  90480E     MOV.B [W14+8], W0
0027EC  504FE3     SUB.B W0, #0x3, [W15]
0027EE  360010     BRA LEU, 0x2810
232:                                       byte = (*(dat + 3) == *(head + 3)) ? 4 : 0;
0027F0  90002E     MOV [W14+4], W0
0027F2  400063     ADD W0, #0x3, W0
0027F4  784090     MOV.B [W0], W1
0027F6  90003E     MOV [W14+6], W0
0027F8  400063     ADD W0, #0x3, W0
0027FA  784010     MOV.B [W0], W0
0027FC  50CF80     SUB.B W1, W0, [W15]
0027FE  3A0003     BRA NZ, 0x2806
002800  B3C040     MOV.B #0x4, W0
002802  985700     MOV.B W0, [W14+16]
002804  370002     BRA 0x280A
002806  EB4080     CLR.B W1
002808  985701     MOV.B W1, [W14+16]
00280A  90500E     MOV.B [W14+16], W0
00280C  984720     MOV.B W0, [W14+2]
00280E  370071     BRA 0x28F2
233:                                   else
234:                                       byte += 1;
002810  90402E     MOV.B [W14+2], W0
002812  E84000     INC.B W0, W0
002814  984720     MOV.B W0, [W14+2]
235:                                   break;
002816  37006D     BRA 0x28F2
236:                               }
237:                               case 4:
238:                               {
239:                                   if (num > 4)
002818  90480E     MOV.B [W14+8], W0
00281A  504FE4     SUB.B W0, #0x4, [W15]
00281C  360010     BRA LEU, 0x283E
240:                                       byte = (*(dat + 4) == *(head + 4)) ? 5 : 0;
00281E  90002E     MOV [W14+4], W0
002820  400064     ADD W0, #0x4, W0
002822  784090     MOV.B [W0], W1
002824  90003E     MOV [W14+6], W0
002826  400064     ADD W0, #0x4, W0
002828  784010     MOV.B [W0], W0
00282A  50CF80     SUB.B W1, W0, [W15]
00282C  3A0003     BRA NZ, 0x2834
00282E  B3C051     MOV.B #0x5, W1
002830  984F71     MOV.B W1, [W14+15]
002832  370002     BRA 0x2838
002834  EB4000     CLR.B W0
002836  984F70     MOV.B W0, [W14+15]
002838  9048FE     MOV.B [W14+15], W1
00283A  984721     MOV.B W1, [W14+2]
00283C  37005A     BRA 0x28F2
241:                                   else
242:                                       byte += 1;
00283E  90402E     MOV.B [W14+2], W0
002840  E84000     INC.B W0, W0
002842  984720     MOV.B W0, [W14+2]
243:                                   break;
002844  370056     BRA 0x28F2
244:                               }
245:                               case 5:
246:                               {
247:                                   if (num > 5)
002846  90480E     MOV.B [W14+8], W0
002848  504FE5     SUB.B W0, #0x5, [W15]
00284A  360010     BRA LEU, 0x286C
248:                                       byte = (*(dat + 5) == *(head + 5)) ? 6 : 0;
00284C  90002E     MOV [W14+4], W0
00284E  400065     ADD W0, #0x5, W0
002850  784090     MOV.B [W0], W1
002852  90003E     MOV [W14+6], W0
002854  400065     ADD W0, #0x5, W0
002856  784010     MOV.B [W0], W0
002858  50CF80     SUB.B W1, W0, [W15]
00285A  3A0003     BRA NZ, 0x2862
00285C  B3C060     MOV.B #0x6, W0
00285E  984F60     MOV.B W0, [W14+14]
002860  370002     BRA 0x2866
002862  EB4080     CLR.B W1
002864  984F61     MOV.B W1, [W14+14]
002866  90486E     MOV.B [W14+14], W0
002868  984720     MOV.B W0, [W14+2]
00286A  370043     BRA 0x28F2
249:                                   else
250:                                       byte += 1;
00286C  90402E     MOV.B [W14+2], W0
00286E  E84000     INC.B W0, W0
002870  984720     MOV.B W0, [W14+2]
251:                                   break;
002872  37003F     BRA 0x28F2
252:                               }
253:                               case 6:
254:                               {
255:                                   if (num > 6)
002874  90480E     MOV.B [W14+8], W0
002876  504FE6     SUB.B W0, #0x6, [W15]
002878  360010     BRA LEU, 0x289A
256:                                       byte = (*(dat + 6) == *(head + 6)) ? 7 : 0;
00287A  90002E     MOV [W14+4], W0
00287C  400066     ADD W0, #0x6, W0
00287E  784090     MOV.B [W0], W1
002880  90003E     MOV [W14+6], W0
002882  400066     ADD W0, #0x6, W0
002884  784010     MOV.B [W0], W0
002886  50CF80     SUB.B W1, W0, [W15]
002888  3A0003     BRA NZ, 0x2890
00288A  B3C071     MOV.B #0x7, W1
00288C  984F51     MOV.B W1, [W14+13]
00288E  370002     BRA 0x2894
002890  EB4000     CLR.B W0
002892  984F50     MOV.B W0, [W14+13]
002894  9048DE     MOV.B [W14+13], W1
002896  984721     MOV.B W1, [W14+2]
002898  37002C     BRA 0x28F2
257:                                   else
258:                                       byte += 1;
00289A  90402E     MOV.B [W14+2], W0
00289C  E84000     INC.B W0, W0
00289E  984720     MOV.B W0, [W14+2]
259:                                   break;
0028A0  370028     BRA 0x28F2
260:                               }
261:                               case 7:
262:                               {
263:                                   if (num > 7)
0028A2  90480E     MOV.B [W14+8], W0
0028A4  504FE7     SUB.B W0, #0x7, [W15]
0028A6  360010     BRA LEU, 0x28C8
264:                                       byte = (*(dat + 7) == *(head + 7)) ? 8 : 0;
0028A8  90002E     MOV [W14+4], W0
0028AA  400067     ADD W0, #0x7, W0
0028AC  784090     MOV.B [W0], W1
0028AE  90003E     MOV [W14+6], W0
0028B0  400067     ADD W0, #0x7, W0
0028B2  784010     MOV.B [W0], W0
0028B4  50CF80     SUB.B W1, W0, [W15]
0028B6  3A0003     BRA NZ, 0x28BE
0028B8  B3C080     MOV.B #0x8, W0
0028BA  984F40     MOV.B W0, [W14+12]
0028BC  370002     BRA 0x28C2
0028BE  EB4080     CLR.B W1
0028C0  984F41     MOV.B W1, [W14+12]
0028C2  90484E     MOV.B [W14+12], W0
0028C4  984720     MOV.B W0, [W14+2]
0028C6  370015     BRA 0x28F2
265:                                   else
266:                                       byte += 1;
0028C8  90402E     MOV.B [W14+2], W0
0028CA  E84000     INC.B W0, W0
0028CC  984720     MOV.B W0, [W14+2]
267:                                   break;
0028CE  370011     BRA 0x28F2
268:                               }
269:                               default:
270:                               {
271:                                   byte++;
0028D0  90402E     MOV.B [W14+2], W0
0028D2  E84000     INC.B W0, W0
0028D4  984720     MOV.B W0, [W14+2]
0028D6  37000D     BRA 0x28F2
272:                                   break;
273:                               }
274:                           } //记录字节数 用于校验;                   
275:                       } else {//如果获取到数据且100ms内没有收到数据，退出并放回字节数
276:                           if (byte && T2IsOver(timeCount + 10)) {
0028D8  90402E     MOV.B [W14+2], W0
0028DA  E00400     CP0.B W0
0028DC  32000A     BRA Z, 0x28F2
0028DE  78009E     MOV [W14], W1
0028E0  40806A     ADD W1, #0xA, W0
0028E2  07042A     RCALL T2IsOver
0028E4  E00000     CP0 W0
0028E6  320005     BRA Z, 0x28F2
277:                               CloseTime2();
0028E8  0703F9     RCALL CloseTime2
278:                               return byte;
0028EA  90402E     MOV.B [W14+2], W0
0028EC  FB8000     ZE W0, W0
0028EE  980750     MOV W0, [W14+10]
0028F0  370007     BRA 0x2900
279:                           }
280:                       }
281:               
282:                       if (T2IsOver(TIME_UART_GET2)) //10s内没有接收数据
0028F2  203E80     MOV #0x3E8, W0
0028F4  070421     RCALL T2IsOver
0028F6  E00000     CP0 W0
0028F8  32FF14     BRA Z, 0x2722
283:                       {
284:                           CloseTime2();
0028FA  0703F0     RCALL CloseTime2
285:                           return 0;
0028FC  EB0000     CLR W0
0028FE  980750     MOV W0, [W14+10]
286:                       }
287:                   }
002900  90005E     MOV [W14+10], W0
288:               }
002902  FA8000     ULNK
002904  060000     RETURN
289:               
290:               
291:               
292:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/SPI.c  -----------------------------
1:                 //#include <p24FV32KA301.h>
2:                 #include "type.h"
3:                 #include "user.h"
4:                 
5:                 //void SPI1_Configuration(void)
6:                 //{
7:                 //    //fcy=Fosc/2/pp/sp See P1712
8:                 //    //定义IO口的方向
9:                 ////    ANSBbits.ANSB15=0;
10:                //    ANSBbits.ANSB14=0;
11:                ////    ANSBbits.ANSB13=0;
12:                ////    ANSBbits.ANSB12=0;
13:                //    SDO1_TRIS=0;
14:                //    SDI1_TRIS=1;
15:                //    SCK1_TRIS=0;
16:                //    SS1_TRIS=0;
17:                //    SS1=1;//CS disable
18:                //    IFS0bits.SPI1IF=0;
19:                //    IEC0bits.SPI1IE=0;
20:                ////    IPC2bits.SPI1IP=7;
21:                ////    ANSbits.
22:                //    SPI1CON1bits.PPRE=2;//主预分频比位1/2 fspi=4Mhz/2
23:                //    SPI1CON1bits.SPRE=7;//辅助预分频比为 4:1 
24:                //
25:                //    SPI1CON1bits.CKE=1;//串行输出数据在时钟由有效状态变为空闲状态 （见 bit 6）时改变
26:                //    SPI1CON1bits.CKP=0;//时钟信号空闲状态为高电平；有效状态为低电平
27:                //    
28:                //    SPI1CON1bits.SSEN=0;// 模块使用不SSx 引脚；引脚由端口功能控制
29:                //    SPI1CON1bits.SMP=1;// 在数据输出时间的中间采样输入数据
30:                //    SPI1CON1bits.DISSCK=0;//使能内部 SPIx 时钟
31:                //    SPI1CON1bits.DISSDO=0;//SDOx 引脚受模块控制
32:                //    SPI1CON1bits.MODE16=0;// 通信为字节宽 （ 8 位）    
33:                //    SPI1CON1bits.MSTEN=1;//主模式使能位 SPI mode=1 上升沿检测
34:                //    
35:                //    //SPI1CON2 don't need to operation
36:                //    
37:                ////    SPI2CON2bits.FRMEN=1;
38:                ////    SPI2CON2bits.SPIFSD=0;   
39:                ////    SPI2CON2bits.SPIFPOL=0;
40:                ////    SPI2CON2bits.SPIFE=0;//帧同步脉冲与第一个位时钟同步
41:                //    
42:                //    SPI1STATbits.SPIRBF = 0; //接收标志
43:                //    SPI1STATbits.SPITBF = 0 ;
44:                //    SPI1STATbits.SPIROV=0;//清除溢出
45:                //    
46:                //    SPI2CON2bits.SPIBEN=1;   
47:                //    
48:                //    SPI1STATbits.SPIEN=1;//使能SPI通讯
49:                //}
50:                //
51:                //u8 SPI1_Read(void)
52:                //{
53:                //    u8 dat;
54:                //    SPI1STATbits.SPIROV = 0;
55:                ////    IFS0bits.SPI1IF=0;
56:                //    SPI1BUF = 0x00;
57:                //   
58:                ////    while(!SPI1STATbits.SPIRBF); //SPIRBF位置1，即接收缓冲器满，就可以读SPIBUF。   
59:                //    while(SPI1STATbits.SR1MPT);
60:                ////    SPI1STATbits.SPIROV = 0;
61:                //    dat = SPI1BUF;// & 0xFF;
62:                ////    SPI1RXB
63:                ////    dat =0x36;
64:                //    return dat;
65:                //}
66:                //
67:                //
68:                //void SPI1_Write(u8 dat)
69:                //{   
70:                //    SPI1BUF=dat; 
71:                //    while(SPI1STATbits.SPITBF);  
72:                ////    while(!SPI1STATbits.SPITBF); 
73:                ////    SPI1BUF=0xFF;
74:                ////    SPI1BUF=0xAA;
75:                ////    SPI1STATbits.SPITBF=0;
76:                ////    while(!(IFS0bits.SPI1IF));
77:                ////    IFS0bits.SPI1IF=0;
78:                //}
79:                
80:                void delay_nop(u8 count)
81:                {
003B9C  FA0002     LNK #0x2
003B9E  784F00     MOV.B W0, [W14]
82:                    while(count--)
003BA0  370001     BRA 0x3BA4
003BA4  E94F1E     DEC.B [W14], [W14]
003BA6  EBC000     SETM.B W0
003BA8  104F9E     SUBR.B W0, [W14], [W15]
003BAA  3AFFFB     BRA NZ, 0x3BA2
83:                        Nop();
003BA2  000000     NOP
84:                }
003BAC  FA8000     ULNK
003BAE  060000     RETURN
85:                
86:                
87:                
88:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/RTCC.c  ----------------------------
1:                 //#include<p24FV32KA301.h>
2:                 #include"UART.h"
3:                 #include "user.h"
4:                 #include "Common.h"
5:                 
6:                 //vu16 gAlarmCheckFlag = 0;
7:                 struct TimeOffset timeOffset;
8:                 vu32 gAlarmCount = 0;
9:                 //vu32 gCheckUTCount= 0;
10:                u16 gRTCCDate[4]; //用于存放日期参数
11:                
12:                /*************************************
13:                Function: RTC_Configuration 
14:                Description: 实时时钟和闹钟初始化
15:                Input: 无
16:                Output: 无
17:                 *************************************/
18:                void RTC_Configuration(void) {
003538  FA0000     LNK #0x0
19:                    //    RTCPWCbits.RTCCLK=1;            //RTCC 时钟选择位:RTCC 时钟选择位
20:                    //    RCFGCALbits.RTCOE=0;            //禁止 RTCC 输出
21:                    //    RCFGCALbits.RTCSYNC=0;          //RTCC 值寄存器读同步位  
22:                    //    RCFGCALbits.CAL=0;              //RTC 漂移校准位
23:                
24:                    asm volatile ("push w7"); //将 RTCWREN 位置 1
00353A  781F87     MOV W7, [W15++]
25:                    asm volatile ("push w8");
00353C  781F88     MOV W8, [W15++]
26:                    asm volatile ("disi #5");
00353E  FC0005     DISI #0x5
27:                    asm volatile ("mov #0x55, w7");
003540  200557     MOV #0x55, W7
28:                    asm volatile ("mov w7, _NVMKEY");
003542  883B37     MOV W7, NVMKEY
29:                    asm volatile ("mov #0xAA, w8");
003544  200AA8     MOV #0xAA, W8
30:                    asm volatile ("mov w8, _NVMKEY");
003546  883B38     MOV W8, NVMKEY
31:                    asm volatile ("bset _RCFGCAL, #13"); //set the RTCWREN bit
003548  A8A627     BSET 0x627, #5
32:                    asm volatile ("pop w8");
00354A  78044F     MOV [--W15], W8
33:                    asm volatile ("pop w7");
00354C  7803CF     MOV [--W15], W7
34:                
35:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
00354E  BFC627     MOV.B 0x627, WREG
003550  B34030     IOR.B #0x3, W0
003552  B7E627     MOV.B WREG, 0x627
36:                    RTCVAL = runingArg.gYear[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
003554  BFCBB3     MOV.B 0xBB3, WREG
003556  FB8000     ZE W0, W0
003558  883120     MOV W0, RTCVAL
37:                    RTCVAL = (runingArg.gMonth << 8) + runingArg.gDay; //0x1022; //月份 日期
00355A  BFCBB4     MOV.B 0xBB4, WREG
00355C  FB8000     ZE W0, W0
00355E  DD00C8     SL W0, #8, W1
003560  BFCBB5     MOV.B 0xBB5, WREG
003562  FB8000     ZE W0, W0
003564  408000     ADD W1, W0, W0
003566  883120     MOV W0, RTCVAL
38:                    RTCVAL = runingArg.gHour & 0x00FF; //0x0008; //星期  小时
003568  BFCBB6     MOV.B 0xBB6, WREG
00356A  FB8000     ZE W0, W0
00356C  883120     MOV W0, RTCVAL
39:                    RTCVAL = (runingArg.gMin << 8) + runingArg.gSec; //0x3050; //分钟 秒 
00356E  BFCBB7     MOV.B 0xBB7, WREG
003570  FB8000     ZE W0, W0
003572  DD00C8     SL W0, #8, W1
003574  BFCBB8     MOV.B 0xBB8, WREG
003576  FB8000     ZE W0, W0
003578  408000     ADD W1, W0, W0
00357A  883120     MOV W0, RTCVAL
40:                
41:                    ALCFGRPTbits.AMASK = 0b0001; //闹钟掩码设置 每秒闹钟中断一次
00357C  206231     MOV #0x623, W1
00357E  784091     MOV.B [W1], W1
003580  B3CC30     MOV.B #0xC3, W0
003582  60C000     AND.B W1, W0, W0
003584  A02400     BSET.B W0, #2
003586  B7E623     MOV.B WREG, 0x623
42:                    ALCFGRPTbits.CHIME = 1; //1 = 使能响铃； ARPT<7:0> 允许从 00h 进位到 FFh
003588  A8C623     BSET 0x623, #6
43:                    ALCFGRPTbits.ALRMPTR = 3; //闹钟值寄存器窗口指针位
00358A  BFC623     MOV.B 0x623, WREG
00358C  B34030     IOR.B #0x3, W0
00358E  B7E623     MOV.B WREG, 0x623
44:                    ALRMVAL = 0x0000; //none       
003590  EB0000     CLR W0
003592  883100     MOV W0, ALRMVAL
45:                    ALRMVAL = 0x0000; //month day 0001
003594  EB0000     CLR W0
003596  883100     MOV W0, ALRMVAL
46:                    ALRMVAL = 0x0000; //week hour
003598  EB0000     CLR W0
00359A  883100     MOV W0, ALRMVAL
47:                    ALRMVAL = 0x0000; //minute second  0000
00359C  EB0000     CLR W0
00359E  883100     MOV W0, ALRMVAL
48:                    //    ALCFGRPTbits.ARPT=0;
49:                    ALCFGRPTbits.ALRMEN = 1; //闹钟已使能 （每当 ARPT<7:0> = 00 和 CHIME = 0 时，发生闹钟事件后都自动清零）    
0035A0  A8E623     BSET 0x623, #7
50:                
51:                    RTCPWCbits.RTCCLK = 0; //SOSC 1; //RTCC 时钟选择位:RTCC 时钟选择位
0035A2  206291     MOV #0x629, W1
0035A4  784091     MOV.B [W1], W1
0035A6  B3CF30     MOV.B #0xF3, W0
0035A8  60C000     AND.B W1, W0, W0
0035AA  B7E629     MOV.B WREG, 0x629
52:                    RCFGCALbits.RTCOE = 0; //禁止 RTCC 输出
0035AC  A94627     BCLR 0x627, #2
53:                    RCFGCALbits.RTCSYNC = 0; //RTCC 值寄存器读同步位  
0035AE  A98627     BCLR 0x627, #4
54:                    RCFGCALbits.CAL = 0; //RTC 漂移校准位
0035B0  EB4000     CLR.B W0
0035B2  B7E626     MOV.B WREG, RCFGCAL
55:                    //    IPC0bits. = 2
56:                    IFS3bits.RTCIF = 0; //外设相关的中断标志状态位清零
0035B4  A9C08B     BCLR 0x8B, #6
57:                    IEC3bits.RTCIE = 1; //开中断 =1
0035B6  A8C09B     BSET head, #6
58:                
59:                    RCFGCALbits.RTCEN = 1; //使能 RTCC 模块
0035B8  A8E627     BSET 0x627, #7
60:                }
0035BA  FA8000     ULNK
0035BC  060000     RETURN
61:                
62:                /*************************************
63:                Function: RTC_ReadTime 
64:                Description: 获取实时时钟的时间
65:                Input: 4个u16类型数据 
66:                Output: 无
67:                 *************************************/
68:                void RTCReadTime(u8* dat) {
0035BE  FA0004     LNK #0x4
0035C0  781F88     MOV W8, [W15++]
0035C2  980710     MOV W0, [W14+2]
69:                    u16 tmp;
70:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
0035C4  BFC627     MOV.B 0x627, WREG
0035C6  B34030     IOR.B #0x3, W0
0035C8  B7E627     MOV.B WREG, 0x627
71:                    tmp = RTCVAL; //获取年份    
0035CA  803120     MOV RTCVAL, W0
0035CC  780F00     MOV W0, [W14]
72:                    *(dat) = 20;
0035CE  90009E     MOV [W14+2], W1
0035D0  B3C140     MOV.B #0x14, W0
0035D2  784880     MOV.B W0, [W1]
73:                    *(dat + 1) = HCD((u8) (tmp & 0X00FF)); //年份   屏蔽高8位    2016.6.1. 3 13:10:10
0035D4  90001E     MOV [W14+2], W0
0035D6  E80400     INC W0, W8
0035D8  78001E     MOV [W14], W0
0035DA  07FF56     RCALL HCD
0035DC  784C00     MOV.B W0, [W8]
74:                
75:                    tmp = RTCVAL; //获取月日
0035DE  803120     MOV RTCVAL, W0
0035E0  780F00     MOV W0, [W14]
76:                    *(dat + 2) = HCD((u8) (tmp >> 8));
0035E2  90001E     MOV [W14+2], W0
0035E4  E88400     INC2 W0, W8
0035E6  78001E     MOV [W14], W0
0035E8  DE0048     LSR W0, #8, W0
0035EA  07FF4E     RCALL HCD
0035EC  784C00     MOV.B W0, [W8]
77:                    *(dat + 3) = HCD((u8) (tmp & 0X00FF)); //月份 日期
0035EE  90001E     MOV [W14+2], W0
0035F0  400463     ADD W0, #0x3, W8
0035F2  78001E     MOV [W14], W0
0035F4  07FF49     RCALL HCD
0035F6  784C00     MOV.B W0, [W8]
78:                    tmp = RTCVAL; //获取小时
0035F8  803120     MOV RTCVAL, W0
0035FA  780F00     MOV W0, [W14]
79:                    *(dat + 4) = HCD((u8) (tmp & 0x00FF)); //星期  小时
0035FC  90001E     MOV [W14+2], W0
0035FE  400464     ADD W0, #0x4, W8
003600  78001E     MOV [W14], W0
003602  07FF42     RCALL HCD
003604  784C00     MOV.B W0, [W8]
80:                    tmp = RTCVAL; //获取分钟 秒
003606  803120     MOV RTCVAL, W0
003608  780F00     MOV W0, [W14]
81:                    *(dat + 5) = HCD((u8) (tmp >> 8));
00360A  90001E     MOV [W14+2], W0
00360C  400465     ADD W0, #0x5, W8
00360E  78001E     MOV [W14], W0
003610  DE0048     LSR W0, #8, W0
003612  07FF3A     RCALL HCD
003614  784C00     MOV.B W0, [W8]
82:                    *(dat + 6) = HCD((u8) (tmp & 0x00FF)); //分钟 秒 
003616  90001E     MOV [W14+2], W0
003618  400466     ADD W0, #0x6, W8
00361A  78001E     MOV [W14], W0
00361C  07FF35     RCALL HCD
00361E  784C00     MOV.B W0, [W8]
83:                }
003620  78044F     MOV [--W15], W8
003622  FA8000     ULNK
003624  060000     RETURN
84:                
85:                /*************************************
86:                Function: Check_RTCC 
87:                Description: 从仪表获取时间 赋值给RTCC
88:                Input: 6个u8类型数据
89:                Output: 无
90:                 *************************************/
91:                void CheckRTCC(void) {
003626  FA0000     LNK #0x0
92:                    //    IEC3bits.RTCIE = 0; //关闭中断 
93:                    //    RCFGCALbits.RTCEN = 0; //关闭 RTCC 模块
94:                    asm volatile ("push w7"); //将 RTCWREN 位置 1
003628  781F87     MOV W7, [W15++]
95:                    asm volatile ("push w8");
00362A  781F88     MOV W8, [W15++]
96:                    asm volatile ("disi #5");
00362C  FC0005     DISI #0x5
97:                    asm volatile ("mov #0x55, w7");
00362E  200557     MOV #0x55, W7
98:                    asm volatile ("mov w7, _NVMKEY");
003630  883B37     MOV W7, NVMKEY
99:                    asm volatile ("mov #0xAA, w8");
003632  200AA8     MOV #0xAA, W8
100:                   asm volatile ("mov w8, _NVMKEY");
003634  883B38     MOV W8, NVMKEY
101:                   asm volatile ("bset _RCFGCAL, #13"); //set the RTCWREN bit
003636  A8A627     BSET 0x627, #5
102:                   asm volatile ("pop w8");
003638  78044F     MOV [--W15], W8
103:                   asm volatile ("pop w7");
00363A  7803CF     MOV [--W15], W7
104:               
105:                   RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
00363C  BFC627     MOV.B 0x627, WREG
00363E  B34030     IOR.B #0x3, W0
003640  B7E627     MOV.B WREG, 0x627
106:                   RTCVAL = runingArg.gYear[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
003642  BFCBB3     MOV.B 0xBB3, WREG
003644  FB8000     ZE W0, W0
003646  883120     MOV W0, RTCVAL
107:                   RTCVAL = (runingArg.gMonth << 8) + runingArg.gDay; //0x1022; //月份 日期
003648  BFCBB4     MOV.B 0xBB4, WREG
00364A  FB8000     ZE W0, W0
00364C  DD00C8     SL W0, #8, W1
00364E  BFCBB5     MOV.B 0xBB5, WREG
003650  FB8000     ZE W0, W0
003652  408000     ADD W1, W0, W0
003654  883120     MOV W0, RTCVAL
108:                   RTCVAL = runingArg.gHour & 0x00FF; //0x0008; //星期  小时
003656  BFCBB6     MOV.B 0xBB6, WREG
003658  FB8000     ZE W0, W0
00365A  883120     MOV W0, RTCVAL
109:                   RTCVAL = (runingArg.gMin << 8) + runingArg.gSec; //0x3050; //分钟 秒 
00365C  BFCBB7     MOV.B 0xBB7, WREG
00365E  FB8000     ZE W0, W0
003660  DD00C8     SL W0, #8, W1
003662  BFCBB8     MOV.B 0xBB8, WREG
003664  FB8000     ZE W0, W0
003666  408000     ADD W1, W0, W0
003668  883120     MOV W0, RTCVAL
110:               
111:                   //    IEC3bits.RTCIE = 1; //开启中断
112:                   //    RCFGCALbits.RTCEN = 1; //开启RTCC
113:               }
00366A  FA8000     ULNK
00366C  060000     RETURN
114:               
115:               /*************************************
116:               Function: StartRTCC 
117:               Description: 
118:               Input: 
119:               Output: 
120:                *************************************/
121:               void StartRTCC(void) {
00366E  FA0000     LNK #0x0
122:                   IEC3bits.RTCIE = 1; //开启中断
003670  A8C09B     BSET head, #6
123:                   RCFGCALbits.RTCEN = 1; //开启RTCC
003672  A8E627     BSET 0x627, #7
124:               }
003674  FA8000     ULNK
003676  060000     RETURN
125:               
126:               /*************************************
127:               Function: StopRTCC 
128:               Description: 
129:               Input: 
130:               Output: 
131:                *************************************/
132:               void StopRTCC(void) {
003678  FA0000     LNK #0x0
133:                   IEC3bits.RTCIE = 0; //关闭中断 
00367A  A9C09B     BCLR head, #6
134:                   RCFGCALbits.RTCEN = 0; //关闭 RTCC 模块
00367C  A9E627     BCLR 0x627, #7
135:               }
00367E  FA8000     ULNK
003680  060000     RETURN
136:               
137:               /*************************************
138:               Function: OutputData 
139:               Description: 通过串口2打印4*u16类型的数据
140:               Input: 4个u16类型数据 
141:               Output: 无
142:                *************************************/
143:               //void OutputData(u16* dat)
144:               //{
145:               //    u8 count=0;
146:               //    *dat|=0x2000;        
147:               //    while(count<4)
148:               //    {
149:               //        UART2Send(RTC_NumProcess(dat+count,12));
150:               //        UART2Send(RTC_NumProcess(dat+count,8));
151:               //        UART2Send(RTC_NumProcess(dat+count,4));
152:               //        UART2Send(RTC_NumProcess(dat+count,0));
153:               //        UART2Send(' ');
154:               //        count++;
155:               //    }
156:               //    UART2Send('\n');
157:               //}
158:               /*************************************
159:               Function: RTC_NumProcess 
160:               Description: 输入数据和右移数，获得对应ASC数值
161:               Input: 4个u16类型数据 ，位移数
162:               Output: 输出ASCII
163:                *************************************/
164:               //static u8 RTCNumProcess(u16*d,u8 s)
165:               //{
166:               //    return (u8)(((*d>>s)&0x000f)+0x30);
167:               //}
168:               
169:               
170:               
171:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/RS485.c  ---------------------------
1:                 //#include"p24FV32KA301.h"
2:                 #include"UART.h"
3:                 #include"user.h"
4:                 #include"25L64B.h"
5:                 
6:                 /*************************************
7:                 Function: RS485_Init 
8:                 Description: 485通讯初始化
9:                 Input: 无 
10:                Output: 无
11:                 *************************************/
12:                void RS485_Init(void) {
0038A0  FA0000     LNK #0x0
13:                    MC_CON_OUT; //控制口设置位输出
0038A2  A962C8     BCLR TRISB, #3
14:                    RS485_TX_OUT;
0038A4  A9E2C8     BCLR TRISB, #7
15:                    RS485_RX_IN;
0038A6  A842C8     BSET TRISB, #2
16:                
17:                    ANSBbits.ANSB2 = 0; //数字输入
0038A8  A944E2     BCLR ANSB, #2
18:                
19:                    U1MODEbits.BRGH = 0;
0038AA  A96220     BCLR U1MODE, #3
20:                    U1BRG = BRGVAL;
0038AC  200190     MOV #0x19, W0
0038AE  881140     MOV W0, U1BRG
21:                
22:                    U1MODEbits.USIDL = 1;
0038B0  A8A221     BSET 0x221, #5
23:                    U1MODEbits.UEN = 0;
0038B2  202211     MOV #0x221, W1
0038B4  784091     MOV.B [W1], W1
0038B6  B3CFC0     MOV.B #0xFC, W0
0038B8  60C000     AND.B W1, W0, W0
0038BA  B7E221     MOV.B WREG, 0x221
24:                    U1MODEbits.UARTEN = 1;
0038BC  A8E221     BSET 0x221, #7
25:                    IFS0bits.U1RXIF = 0; // Clear the Recieve Interrupt Flag
0038BE  A96085     BCLR 0x85, #3
26:                    U1STAbits.UTXEN = 1;
0038C0  A84223     BSET 0x223, #2
27:                
28:                    IPC2bits.U1RXIP = 5;
0038C2  200A91     MOV #0xA9, W1
0038C4  784091     MOV.B [W1], W1
0038C6  B3C8F0     MOV.B #0x8F, W0
0038C8  60C000     AND.B W1, W0, W0
0038CA  B3C501     MOV.B #0x50, W1
0038CC  704001     IOR.B W0, W1, W0
0038CE  B7E0A9     MOV.B WREG, 0xA9
29:                    U1STAbits.URXISEL = 0;
0038D0  BFC222     MOV.B U1STA, WREG
0038D2  B243F0     AND.B #0x3F, W0
0038D4  B7E222     MOV.B WREG, U1STA
30:                    IEC0bits.U1RXIE = 1; //优先开启中断，用于设置参数
0038D6  A86095     BSET 0x95, #3
31:                }
0038D8  FA8000     ULNK
0038DA  060000     RETURN
32:                
33:                /*************************************
34:                Function: RS485_Send 待修改 
35:                Description: 485发送数据指令
36:                Input: 发送的数据 
37:                Output: 1:发送成功
38:                 *************************************/
39:                void RS485Send(const u8 dat) {
0038DC  FA0002     LNK #0x2
0038DE  784F00     MOV.B W0, [W14]
40:                    RS485_CON = 1; //发送
0038E0  A862CC     BSET LATB, #3
41:                    U1TXREG = dat;
0038E2  FB801E     ZE [W14], W0
0038E4  881120     MOV W0, U1TXREG
42:                    while (!U1STAbits.TRMT);
0038E6  BFC223     MOV.B 0x223, WREG
0038E8  604061     AND.B W0, #0x1, W0
0038EA  E00400     CP0.B W0
0038EC  32FFFC     BRA Z, 0x38E6
43:                    Delay_Nop(20);
0038EE  200140     MOV #0x14, W0
0038F0  07FC90     RCALL Delay_Nop
44:                    RS485_CON = 0; //接收
0038F2  A962CC     BCLR LATB, #3
45:                }
0038F4  FA8000     ULNK
0038F6  060000     RETURN
46:                
47:                /*************************************
48:                Function: RS485_SendString 
49:                Description: 485发送字符串
50:                Input: 字符串 字符串长度 
51:                Output: 无
52:                 *************************************/
53:                void RS485SendString(const u8* dat, u8 bytes) {
0038F8  FA0006     LNK #0x6
0038FA  980710     MOV W0, [W14+2]
0038FC  984741     MOV.B W1, [W14+4]
54:                    u8 count = 0;
0038FE  EB4000     CLR.B W0
003900  784F00     MOV.B W0, [W14]
55:                
56:                    RS485_CON = 1; //发送
003902  A862CC     BSET LATB, #3
57:                    //    Delay100ms(1);
58:                    while (count < bytes) {
003904  37000C     BRA 0x391E
00391E  90404E     MOV.B [W14+4], W0
003920  104F9E     SUBR.B W0, [W14], [W15]
003922  39FFF1     BRA NC, 0x3906
59:                        U1TXREG = *(dat + count);
003906  FB801E     ZE [W14], W0
003908  780080     MOV W0, W1
00390A  90001E     MOV [W14+2], W0
00390C  408000     ADD W1, W0, W0
00390E  784010     MOV.B [W0], W0
003910  FB8000     ZE W0, W0
003912  881120     MOV W0, U1TXREG
60:                        while (!U1STAbits.TRMT);
003914  BFC223     MOV.B 0x223, WREG
003916  604061     AND.B W0, #0x1, W0
003918  E00400     CP0.B W0
00391A  32FFFC     BRA Z, 0x3914
61:                        //        if(count==bytes-1)
62:                        //            Delay100ms(1);                 //可以更短时间
63:                        count++;
00391C  E84F1E     INC.B [W14], [W14]
64:                    }
65:                    //    Delay100ms(1);//没有发送完全
66:                    Delay_Nop(750); //20
003924  202EE0     MOV #0x2EE, W0
003926  07FC75     RCALL Delay_Nop
67:                    RS485_CON = 0; //接收
003928  A962CC     BCLR LATB, #3
68:                }
00392A  FA8000     ULNK
00392C  060000     RETURN
69:                
70:                void OpenRS485(void) {
00392E  FA0000     LNK #0x0
71:                    IEC0bits.U1RXIE = 1;
003930  A86095     BSET 0x95, #3
72:                    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
003932  A84223     BSET 0x223, #2
73:                }
003934  FA8000     ULNK
003936  060000     RETURN
74:                
75:                void CloseRS485(void) {
003938  FA0000     LNK #0x0
76:                    IEC0bits.U1RXIE = 0;
00393A  A96095     BCLR 0x95, #3
77:                    U1STAbits.UTXEN = 0; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
00393C  A94223     BCLR 0x223, #2
78:                }
00393E  FA8000     ULNK
003940  060000     RETURN
79:                /*************************************
80:                Function: RS485_test 
81:                Description: 485通讯测试
82:                Input: 无 
83:                Output: 无
84:                 *************************************/
85:                //void RS485test(void)
86:                //{
87:                //    u8 dat='6';
88:                
89:                //RS485Send('T');
90:                //    if(!RS485Receive(&dat))
91:                //    {
92:                //        RS485Send(dat);
93:                //        RS485Send('T');
94:                //    }
95:                //}
96:                
97:                /*************************************
98:                Function: RS485_Receive  待修改
99:                Description: 485接收数据指令
100:               Input: 接收数据的指针 
101:               Output: 1：接收到数据
102:                ************************************
103:               bool RS485Receive(u8* dat) {
104:               
105:                   bool b = true;
106:               //    u8 timeCount;
107:                   
108:               //    RS485_CON = 0; //接收
109:               
110:                   if (U1STAbits.OERR)
111:                       U1STAbits.OERR = 0;
112:                   
113:               //    gT23Count=0;
114:               //    T2CONbits.TON = 1;//开定时器 提高通讯稳定性
115:                  
116:                   while (!U1STAbits.URXDA) //没有接收到
117:                   {
118:               //        timeCount = gT23Count;
119:               //        if( T100msIsOver(timeCount,10) ) {//1s没有接收到数据
120:               //            b = false;
121:               //            break;
122:               //        }
123:                   }
124:               //    T2CONbits.TON = 0;//关定时器
125:               //    gT23Count=0;           //清除计数
126:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
127:               //    TMR2 = 0x0000;
128:                   
129:               //    if(b)
130:               //        *dat = U1RXREG;
131:               
132:                   return b;
133:               }*/
134:               
135:               
136:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/PC.c  ------------------------------
1:                 #include "user.h"
2:                 #include "task.h"
3:                 #include "CheckData.h"
4:                 #include "SerialBuffer.h"
5:                 #include "P-Miot1601.h"
6:                 #include "Miot1601.h"
7:                 
8:                 /*************************************
9:                 Function: CopPCorTCPTask 
10:                Description: 开机启动10s用于PC与模块通讯
11:                Input: 无
12:                Output: 无
13:                 *************************************/
14:                void CopPCTask(void) {
003942  FA009C     LNK #0x9C
15:                    //如果数据接收到或是PC通讯任务挂起标志为1，则进行功能选择，反之10s后退出通讯
16:                    u8 sendData[152]; //临时发送数据
17:                    u8 flag = 0, cnt = 0; //hook
003944  EB4000     CLR.B W0
003946  984720     MOV.B W0, [W14+2]
003948  EB4000     CLR.B W0
00394A  984710     MOV.B W0, [W14+1]
18:                    u8 bytes, head;
19:                
20:                    OpenRS485();
00394C  07FFF0     RCALL OpenRS485
21:                    T3Delay10ms(10);
00394E  2000A0     MOV #0xA, W0
003950  07FBE8     RCALL T3Delay10ms
22:                    RS485SendString("SSSSSSSSSS", 10); //人机交互
003952  2000A1     MOV #0xA, W1
003954  28E600     MOV #0x8E60, W0
003956  07FFD0     RCALL RS485SendString
23:                    do {//10s判断是否进入参数设置
24:                        Register2Read(&head, mi_arg_add[mi_add], 1); //获取帧头
003958  846F81     MOV 0x8DF0, W1
00395A  2009B0     MOV #0x9B, W0
00395C  40000E     ADD W0, W14, W0
00395E  B3C012     MOV.B #0x1, W2
003960  07F84C     RCALL Register2Read
25:                        bytes = UART1IsGet(sendData, &head, 1);
003962  2009B1     MOV #0x9B, W1
003964  40808E     ADD W1, W14, W1
003966  470063     ADD W14, #0x3, W0
003968  B3C012     MOV.B #0x1, W2
00396A  07F6CF     RCALL UART1IsGet
00396C  784F00     MOV.B W0, [W14]
26:                        if (bytes) {
00396E  E0041E     CP0.B [W14]
003970  320014     BRA Z, 0x399A
27:                            if (CheckIsRight(CRC16_Check, sendData, bytes - 2)) {
003972  78401E     MOV.B [W14], W0
003974  E9C000     DEC2.B W0, W0
003976  784100     MOV.B W0, W2
003978  4700E3     ADD W14, #0x3, W1
00397A  236820     MOV #0x3682, W0
00397C  07FEDD     RCALL CheckIsRight
00397E  E00400     CP0.B W0
003980  320009     BRA Z, 0x3994
28:                                flag = CopFun(sendData, bytes, PC); //如果是退出设置，gChangeParameterFlag=0；
003982  470063     ADD W14, #0x3, W0
003984  EB4100     CLR.B W2
003986  78409E     MOV.B [W14], W1
003988  07EF01     RCALL CopFun
00398A  984720     MOV.B W0, [W14+2]
29:                                if (flag == 'b') //如果gChangeParameterFlag为0，立马退出
00398C  9040AE     MOV.B [W14+2], W1
00398E  B3C620     MOV.B #0x62, W0
003990  50CF80     SUB.B W1, W0, [W15]
003992  32000D     BRA Z, 0x39AE
30:                                    break;
31:                
32:                            } //else//校验失败 发送未执行
33:                            // TCP_Error_Relay(sendData + 1, Do_Err, PC);
34:                            cnt = 0;
003994  EB4000     CLR.B W0
003996  984710     MOV.B W0, [W14+1]
003998  370003     BRA 0x39A0
35:                        } else
36:                            cnt++;
00399A  90401E     MOV.B [W14+1], W0
00399C  E84000     INC.B W0, W0
00399E  984710     MOV.B W0, [W14+1]
37:                        if (cnt > 2)
0039A0  90401E     MOV.B [W14+1], W0
0039A2  504FE2     SUB.B W0, #0x2, [W15]
0039A4  3E0004     BRA GTU, 0x39AE
38:                            break;
39:                        ClrWdt();
0039A6  FE6000     CLRWDT
40:                    } while (flag);
0039A8  90402E     MOV.B [W14+2], W0
0039AA  E00400     CP0.B W0
0039AC  3AFFD5     BRA NZ, 0x3958
41:                    RS485SendString("EEEEEEEEEE", 10); //人机交互
0039AE  2000A1     MOV #0xA, W1
0039B0  28E6B0     MOV #0x8E6B, W0
0039B2  07FFA2     RCALL RS485SendString
42:                    CloseRS485();
0039B4  07FFC1     RCALL CloseRS485
43:                }
0039B6  FA8000     ULNK
0039B8  060000     RETURN
44:                
45:                
46:                
47:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/P-Miot1601.c  ----------------------
1:                 /* 
2:                  * File:   Miot1601.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年8月17日, 下午4:48
6:                  */
7:                 #include "user.h"
8:                 #include "P-Miot1601.h"
9:                 #include "GPRS.h"
10:                #include "CheckData.h"
11:                #include "TIM.h"
12:                #include "SerialBuffer.h"
13:                #include "Miot1601.h"
14:                #include "math.h"
15:                #include "Common.h"
16:                
17:                extern const u8 mi_dat_add[REG_DATA_ARG_NUM + 1];
18:                extern const u16 mi_arg_add[REG_ARG_NUM + 1];
19:                extern enum mi_arg_add_enum enum_mi_arg_add;
20:                extern enum mi_dat_add_enum enum_mi_dat_add;
21:                struct Alarm_Arg AlarmArgbits;
22:                struct Status Statusbits;
23:                
24:                //static bool DUPDataChange(u8 *source_dat);
25:                static void TCP_03_Reply(u16 reg_add, u8 arg_num, u8 source);
26:                static void TCP_04_Reply(u16 reg_add, u8 arg_num, u8 source);
27:                static void TCP_10_Reply(u16 reg_add, u8 arg_num, u8 source);
28:                static void TCP_11_Reply(u8* dat);
29:                static u8 TCP_43_DataReIsOK(u8*dat);
30:                void TCP_Error_Relay(u8 code, u8 err, u8 source);
31:                
32:                /*************************************
33:                Function: CopFun 
34:                Description: 选择通讯功能
35:                Input: 数据 发送给
36:                Output: 
37:                 *************************************/
38:                u8 CopFun(u8*dat, u8 bytes, u8 source) {
00178C  FA000C     LNK #0xC
00178E  980720     MOV W0, [W14+4]
001790  984761     MOV.B W1, [W14+6]
001792  984772     MOV.B W2, [W14+7]
39:                
40:                    u16 reg_add = 0; //获取参数寄存器地址   
001794  EB0000     CLR W0
001796  980710     MOV W0, [W14+2]
41:                    u8 arg_num = 0; //BCD 参数数量  
001798  EB4000     CLR.B W0
00179A  984710     MOV.B W0, [W14+1]
42:                    u8 tmp;
43:                    //判断功能码
44:                    switch (*(dat + 1)) {//读取数据包
00179C  90002E     MOV [W14+4], W0
00179E  E80000     INC W0, W0
0017A0  784010     MOV.B [W0], W0
0017A2  FB8000     ZE W0, W0
0017A4  980750     MOV W0, [W14+10]
0017A6  90005E     MOV [W14+10], W0
0017A8  500FF0     SUB W0, #0x10, [W15]
0017AA  320072     BRA Z, 0x1890
0017AC  9000DE     MOV [W14+10], W1
0017AE  508FF0     SUB W1, #0x10, [W15]
0017B0  3C0007     BRA GT, 0x17C0
0017B2  90005E     MOV [W14+10], W0
0017B4  500FE3     SUB W0, #0x3, [W15]
0017B6  32000C     BRA Z, 0x17D0
0017B8  9000DE     MOV [W14+10], W1
0017BA  508FE4     SUB W1, #0x4, [W15]
0017BC  320031     BRA Z, 0x1820
0017BE  3700B7     BRA 0x192E
0017C0  90005E     MOV [W14+10], W0
0017C2  500FF1     SUB W0, #0x11, [W15]
0017C4  32009F     BRA Z, 0x1904
0017C6  200600     MOV #0x60, W0
0017C8  9000DE     MOV [W14+10], W1
0017CA  508F80     SUB W1, W0, [W15]
0017CC  3200AD     BRA Z, 0x1928
0017CE  3700AF     BRA 0x192E
45:                        case 0x03:
46:                        {
47:                            if (bytes == 6) //接受到数据字节数核对
0017D0  90406E     MOV.B [W14+6], W0
0017D2  504FE6     SUB.B W0, #0x6, [W15]
0017D4  3A00B0     BRA NZ, 0x1936
48:                            {
49:                                reg_add = *(dat + 2); //获取数据包寄存器地址   
0017D6  90002E     MOV [W14+4], W0
0017D8  E88000     INC2 W0, W0
0017DA  784010     MOV.B [W0], W0
0017DC  FB8000     ZE W0, W0
0017DE  980710     MOV W0, [W14+2]
50:                                arg_num = *(dat + 3); //BCD 参数数量 
0017E0  90002E     MOV [W14+4], W0
0017E2  400063     ADD W0, #0x3, W0
0017E4  784090     MOV.B [W0], W1
0017E6  984711     MOV.B W1, [W14+1]
51:                                //如果数据地址范围不在0-503(其中每隔41个有一个预留空间),发送非法数据地址
52:                                if (!DataIsVaild(reg_add, 144, 0)) //判断数据有效性
0017E8  EB0100     CLR W2
0017EA  200901     MOV #0x90, W1
0017EC  90001E     MOV [W14+2], W0
0017EE  070E5A     RCALL DataIsVaild
0017F0  E00400     CP0.B W0
0017F2  3A0005     BRA NZ, 0x17FE
53:                                {
54:                                    TCP_Error_Relay(0x03, Dat_Add_Err, source);
0017F4  90417E     MOV.B [W14+7], W2
0017F6  B3C021     MOV.B #0x2, W1
0017F8  B3C030     MOV.B #0x3, W0
0017FA  070190     RCALL TCP_Error_Relay
55:                                    break;
0017FC  37009C     BRA 0x1936
56:                                }
57:                                //如果数据值不在1-5之间，发送非法数据值
58:                                if (!DataIsVaild(arg_num, 5, 1)) //
0017FE  90401E     MOV.B [W14+1], W0
001800  FB8000     ZE W0, W0
001802  200012     MOV #0x1, W2
001804  200051     MOV #0x5, W1
001806  070E4E     RCALL DataIsVaild
001808  E00400     CP0.B W0
00180A  3A0005     BRA NZ, 0x1816
59:                                {
60:                                    TCP_Error_Relay(0x03, Dat_Val_Err, source);
00180C  90417E     MOV.B [W14+7], W2
00180E  B3C031     MOV.B #0x3, W1
001810  B3C030     MOV.B #0x3, W0
001812  070184     RCALL TCP_Error_Relay
61:                                    break;
001814  370090     BRA 0x1936
62:                                }
63:                                TCP_03_Reply(reg_add, arg_num, source);
001816  90417E     MOV.B [W14+7], W2
001818  90409E     MOV.B [W14+1], W1
00181A  90001E     MOV [W14+2], W0
00181C  070091     RCALL _TCP_03_Reply
64:                            }
65:                            break;
00181E  37008B     BRA 0x1936
66:                        }
67:                        case 0x04://读取参数
68:                        {
69:                            if (bytes == 7) {
001820  90406E     MOV.B [W14+6], W0
001822  504FE7     SUB.B W0, #0x7, [W15]
001824  3A0088     BRA NZ, 0x1936
70:                                reg_add = (*(dat + 2) << 8) + *(dat + 3); //获取参数寄存器地址   
001826  90002E     MOV [W14+4], W0
001828  E88000     INC2 W0, W0
00182A  784010     MOV.B [W0], W0
00182C  FB8000     ZE W0, W0
00182E  DD00C8     SL W0, #8, W1
001830  90002E     MOV [W14+4], W0
001832  400063     ADD W0, #0x3, W0
001834  784010     MOV.B [W0], W0
001836  FB8000     ZE W0, W0
001838  408000     ADD W1, W0, W0
00183A  980710     MOV W0, [W14+2]
71:                                arg_num = (*(dat + 4) >> 4)*10 + (*(dat + 4) & 0x0F); //BCD 参数数量                 
00183C  90002E     MOV [W14+4], W0
00183E  400064     ADD W0, #0x4, W0
001840  784010     MOV.B [W0], W0
001842  FB8000     ZE W0, W0
001844  DE0044     LSR W0, #4, W0
001846  FB8000     ZE W0, W0
001848  B9006A     MUL.SU W0, #10, W0
00184A  784080     MOV.B W0, W1
00184C  90002E     MOV [W14+4], W0
00184E  400064     ADD W0, #0x4, W0
001850  784010     MOV.B [W0], W0
001852  60406F     AND.B W0, #0xF, W0
001854  40C000     ADD.B W1, W0, W0
001856  984710     MOV.B W0, [W14+1]
72:                                //如果参数地址不在0x200-0x212，则发送非法数据地址
73:                                if (!DataIsVaild(reg_add, mi_arg_add[REG_ARG_NUM - 1], mi_arg_add[0])) //
001858  846F82     MOV 0x8DF0, W2
00185A  8470E1     MOV 0x8E1C, W1
00185C  90001E     MOV [W14+2], W0
00185E  070E22     RCALL DataIsVaild
001860  E00400     CP0.B W0
001862  3A0005     BRA NZ, 0x186E
74:                                {
75:                                    TCP_Error_Relay(0x04, Dat_Add_Err, source);
001864  90417E     MOV.B [W14+7], W2
001866  B3C021     MOV.B #0x2, W1
001868  B3C040     MOV.B #0x4, W0
00186A  070158     RCALL TCP_Error_Relay
76:                                    break;
00186C  370064     BRA 0x1936
77:                                }
78:                                //如果参数数量不在1-18，则发送非法数据值
79:                                if (!DataIsVaild(arg_num, REG_ARG_NUM, 1)) //????????????超出个数
00186E  90401E     MOV.B [W14+1], W0
001870  FB8000     ZE W0, W0
001872  200012     MOV #0x1, W2
001874  200171     MOV #0x17, W1
001876  070E16     RCALL DataIsVaild
001878  E00400     CP0.B W0
00187A  3A0005     BRA NZ, 0x1886
80:                                {
81:                                    TCP_Error_Relay(0x04, Dat_Val_Err, source);
00187C  90417E     MOV.B [W14+7], W2
00187E  B3C031     MOV.B #0x3, W1
001880  B3C040     MOV.B #0x4, W0
001882  07014C     RCALL TCP_Error_Relay
82:                                    break;
001884  370058     BRA 0x1936
83:                                }
84:                                TCP_04_Reply(reg_add, arg_num, source);
001886  90417E     MOV.B [W14+7], W2
001888  90409E     MOV.B [W14+1], W1
00188A  90001E     MOV [W14+2], W0
00188C  070098     RCALL _TCP_04_Reply
85:                            }
86:                            break;
00188E  370053     BRA 0x1936
87:                        }
88:                            //设置Miot1601参数
89:                        case 0x10:
90:                        {
91:                            reg_add = (*(dat + 2) << 8)+*(dat + 3); //获取参数寄存器地址   
001890  90002E     MOV [W14+4], W0
001892  E88000     INC2 W0, W0
001894  784010     MOV.B [W0], W0
001896  FB8000     ZE W0, W0
001898  DD00C8     SL W0, #8, W1
00189A  90002E     MOV [W14+4], W0
00189C  400063     ADD W0, #0x3, W0
00189E  784010     MOV.B [W0], W0
0018A0  FB8000     ZE W0, W0
0018A2  408000     ADD W1, W0, W0
0018A4  980710     MOV W0, [W14+2]
92:                            arg_num = (*(dat + 4) >> 4)*10 + (*(dat + 4)&0x0F); //BCD 参数数量 
0018A6  90002E     MOV [W14+4], W0
0018A8  400064     ADD W0, #0x4, W0
0018AA  784010     MOV.B [W0], W0
0018AC  FB8000     ZE W0, W0
0018AE  DE0044     LSR W0, #4, W0
0018B0  FB8000     ZE W0, W0
0018B2  B9006A     MUL.SU W0, #10, W0
0018B4  784080     MOV.B W0, W1
0018B6  90002E     MOV [W14+4], W0
0018B8  400064     ADD W0, #0x4, W0
0018BA  784010     MOV.B [W0], W0
0018BC  60406F     AND.B W0, #0xF, W0
0018BE  40C000     ADD.B W1, W0, W0
0018C0  984710     MOV.B W0, [W14+1]
93:                            //如果参数地址不在0x200-0x212，则发送数据地址错误
94:                            if (!DataIsVaild(reg_add, mi_arg_add[REG_ARG_NUM - 1], mi_arg_add[0])) //
0018C2  846F82     MOV 0x8DF0, W2
0018C4  8470E1     MOV 0x8E1C, W1
0018C6  90001E     MOV [W14+2], W0
0018C8  070DED     RCALL DataIsVaild
0018CA  E00400     CP0.B W0
0018CC  3A0005     BRA NZ, 0x18D8
95:                            {
96:                                TCP_Error_Relay(0x10, Dat_Add_Err, source);
0018CE  90417E     MOV.B [W14+7], W2
0018D0  B3C021     MOV.B #0x2, W1
0018D2  B3C100     MOV.B #0x10, W0
0018D4  070123     RCALL TCP_Error_Relay
97:                                break;
0018D6  37002F     BRA 0x1936
98:                            }
99:                            //如果参数数量不在1-18，则发送非法数据值
100:                           if (!DataIsVaild(arg_num, REG_ARG_NUM, 1)) //
0018D8  90401E     MOV.B [W14+1], W0
0018DA  FB8000     ZE W0, W0
0018DC  200012     MOV #0x1, W2
0018DE  200171     MOV #0x17, W1
0018E0  070DE1     RCALL DataIsVaild
0018E2  E00400     CP0.B W0
0018E4  3A0005     BRA NZ, 0x18F0
101:                           {
102:                               TCP_Error_Relay(0x10, Dat_Val_Err, source);
0018E6  90417E     MOV.B [W14+7], W2
0018E8  B3C031     MOV.B #0x3, W1
0018EA  B3C100     MOV.B #0x10, W0
0018EC  070117     RCALL TCP_Error_Relay
103:                               break;
0018EE  370023     BRA 0x1936
104:                           }
105:               
106:                           //写入寄存器2的地址
107:                           Register2Write(dat + 5, reg_add, arg_num);
0018F0  90002E     MOV [W14+4], W0
0018F2  400065     ADD W0, #0x5, W0
0018F4  90411E     MOV.B [W14+1], W2
0018F6  90009E     MOV [W14+2], W1
0018F8  07085C     RCALL Register2Write
108:                           TCP_10_Reply(reg_add, arg_num, source);
0018FA  90417E     MOV.B [W14+7], W2
0018FC  90409E     MOV.B [W14+1], W1
0018FE  90001E     MOV [W14+2], W0
001900  07009A     RCALL _TCP_10_Reply
109:                           break;
001902  370019     BRA 0x1936
110:                       }
111:                           //设置GPRS参数
112:                       case 0x11:
113:                       {//错误判断放在上位机上面 仅支持TRG1601            
114:                           if (source == GPRS) {//GPRS上线发送数据
001904  90407E     MOV.B [W14+7], W0
001906  504FE1     SUB.B W0, #0x1, [W15]
001908  3A0005     BRA NZ, 0x1914
115:                               TCP_Error_Relay(0x11, Fun_Err, GPRS);
00190A  B3C012     MOV.B #0x1, W2
00190C  B3C011     MOV.B #0x1, W1
00190E  B3C110     MOV.B #0x11, W0
001910  070105     RCALL TCP_Error_Relay
116:                               break;
001912  370011     BRA 0x1936
117:                           }
118:                           TCP_11_Reply(dat);
001914  90002E     MOV [W14+4], W0
001916  0700CD     RCALL _TCP_11_Reply
119:                           //获取GPRS工作模式
120:                           tmp = *(dat + 15) - 0x30;
001918  90002E     MOV [W14+4], W0
00191A  40006F     ADD W0, #0xF, W0
00191C  784010     MOV.B [W0], W0
00191E  784080     MOV.B W0, W1
001920  B3CD00     MOV.B #0xD0, W0
001922  40C000     ADD.B W1, W0, W0
001924  784F00     MOV.B W0, [W14]
121:                           //            Register2Write(&tmp, mi_arg_add[mi_gprs_mode], 1);
122:                           break;
001926  370007     BRA 0x1936
123:                       }
124:                           //主动报当天数据
125:                           //        case 0x43:
126:                           //        {
127:                           //            return TCP_43_DataReIsOK(dat);
128:                           //        }
129:                           //退出通讯
130:                       case 0x60:
131:                       {
132:                           return 'b';
001928  200620     MOV #0x62, W0
00192A  980740     MOV W0, [W14+8]
00192C  370006     BRA 0x193A
133:                       }
134:                       default:
135:                       {
136:                           TCP_Error_Relay(0, Fun_Err, source);
00192E  90417E     MOV.B [W14+7], W2
001930  B3C011     MOV.B #0x1, W1
001932  EB4000     CLR.B W0
001934  0700F3     RCALL TCP_Error_Relay
137:                           break;
138:                       }
139:                   }
140:                   return 1;
001936  200011     MOV #0x1, W1
001938  980741     MOV W1, [W14+8]
00193A  90004E     MOV [W14+8], W0
141:               }
00193C  FA8000     ULNK
00193E  060000     RETURN
142:               
143:               static void TCP_03_Reply(u16 reg_add, u8 arg_num, u8 source) {
001940  FA003A     LNK #0x3A
001942  981F30     MOV W0, [W14+54]
001944  987F01     MOV.B W1, [W14+56]
001946  987F12     MOV.B W2, [W14+57]
144:                   //    u16 vaildBytes = 0; //有效字节数
145:                   u8 sendBuffer[REG_DATA_SZIE + 10]; //声明发送缓冲区，计数
146:                   u16 CRC_Result = 0; //CRC校验结果
001948  EB0000     CLR W0
00194A  780F00     MOV W0, [W14]
147:               
148:                   Register2Read(sendBuffer, mi_arg_add[mi_add], 1); //赋值Miot1601地址
00194C  846F81     MOV 0x8DF0, W1
00194E  E8800E     INC2 W14, W0
001950  B3C012     MOV.B #0x1, W2
001952  070853     RCALL Register2Read
149:                   sendBuffer[1] = 0X03; //赋值功能码        
001954  E8808E     INC2 W14, W1
001956  B3C030     MOV.B #0x3, W0
001958  984090     MOV.B W0, [W1+1]
150:                   sendBuffer[2] = arg_num; //获取字节数
00195A  E8800E     INC2 W14, W0
00195C  90788E     MOV.B [W14+56], W1
00195E  984021     MOV.B W1, [W0+2]
151:               
152:                   if (reg_add == 0x90)
001960  9018BE     MOV [W14+54], W1
001962  200900     MOV #0x90, W0
001964  508F80     SUB W1, W0, [W15]
001966  3A0010     BRA NZ, 0x1988
153:                       FM25L64B_Read((gOffsetAdd + 143) % 144 * REG_DATA_SECTION, sendBuffer + 3, REG_DATA_SECTION);
001968  E8800E     INC2 W14, W0
00196A  4001E3     ADD W0, #0x3, W3
00196C  BFCC32     MOV.B 0xC32, WREG
00196E  FB8000     ZE W0, W0
001970  B008F0     ADD #0x8F, W0
001972  200902     MOV #0x90, W2
001974  090011     REPEAT #0x11
001976  D80002     DIV.SW W0, W2
001978  FD0080     EXCH W0, W1
00197A  780080     MOV W0, W1
00197C  2002A0     MOV #0x2A, W0
00197E  B98800     MUL.SS W1, W0, W0
001980  2002A2     MOV #0x2A, W2
001982  780083     MOV W3, W1
001984  070CD2     RCALL FM25L64B_Read
001986  370008     BRA 0x1998
154:                   else
155:                       FM25L64B_Read(reg_add * REG_DATA_SECTION, sendBuffer + 3, REG_DATA_SECTION);
001988  E8800E     INC2 W14, W0
00198A  4001E3     ADD W0, #0x3, W3
00198C  9018BE     MOV [W14+54], W1
00198E  2002A0     MOV #0x2A, W0
001990  B98800     MUL.SS W1, W0, W0
001992  2002A2     MOV #0x2A, W2
001994  780083     MOV W3, W1
001996  070CC9     RCALL FM25L64B_Read
156:                   //CRC校验
157:                   CRC_Result = CRC16_Check(sendBuffer, 44); //计算CRC结果
001998  E8800E     INC2 W14, W0
00199A  2002C1     MOV #0x2C, W1
00199C  070E72     RCALL CRC16_Check
00199E  780F00     MOV W0, [W14]
158:                   sendBuffer[44] = (u8) (CRC_Result & 0x00ff); //赋值CRC低8位
0019A0  78001E     MOV [W14], W0
0019A2  784080     MOV.B W0, W1
0019A4  E8800E     INC2 W14, W0
0019A6  986841     MOV.B W1, [W0+44]
159:                   sendBuffer[45] = (u8) ((CRC_Result >> 8)&0x00ff); //赋值CRC高8位
0019A8  78001E     MOV [W14], W0
0019AA  DE0048     LSR W0, #8, W0
0019AC  784080     MOV.B W0, W1
0019AE  E8800E     INC2 W14, W0
0019B0  986851     MOV.B W1, [W0+45]
160:                   //    vaildBytes += 2;
161:                   //发送数据到对应串口
162:                   TCP_SendData(source, sendBuffer, 46);
0019B2  E8808E     INC2 W14, W1
0019B4  B3C2E2     MOV.B #0x2E, W2
0019B6  90781E     MOV.B [W14+57], W0
0019B8  0700D5     RCALL TCP_SendData
163:               }
0019BA  FA8000     ULNK
0019BC  060000     RETURN
164:               
165:               static void TCP_04_Reply(u16 reg_add, u8 arg_num, u8 source) {
0019BE  FA0048     LNK #0x48
0019C0  982720     MOV W0, [W14+68]
0019C2  98C761     MOV.B W1, [W14+70]
0019C4  98C772     MOV.B W2, [W14+71]
166:                   u16 vaildBytes = 0; //有效字节数
0019C6  EB0000     CLR W0
0019C8  980710     MOV W0, [W14+2]
167:                   u8 sendBuffer[REG_ARG_SIZE + 10]; //声明发送缓冲区，计数
168:                   u16 CRC_Result = 0; //CRC校验结果
0019CA  EB0000     CLR W0
0019CC  780F00     MOV W0, [W14]
169:               
170:                   Register2Read(sendBuffer, mi_arg_add[mi_add], 1); //赋值Miot1601地址
0019CE  846F81     MOV 0x8DF0, W1
0019D0  470064     ADD W14, #0x4, W0
0019D2  B3C012     MOV.B #0x1, W2
0019D4  070812     RCALL Register2Read
171:                   sendBuffer[1] = 0X04; //赋值功能码                   
0019D6  4700E4     ADD W14, #0x4, W1
0019D8  B3C040     MOV.B #0x4, W0
0019DA  984090     MOV.B W0, [W1+1]
172:                   sendBuffer[2] = GetSize(reg_add, arg_num); //赋值字节数
0019DC  90C0EE     MOV.B [W14+70], W1
0019DE  90202E     MOV [W14+68], W0
0019E0  070792     RCALL GetSize
0019E2  784080     MOV.B W0, W1
0019E4  470064     ADD W14, #0x4, W0
0019E6  984021     MOV.B W1, [W0+2]
173:                   vaildBytes = sendBuffer[2] + 3;
0019E8  470064     ADD W14, #0x4, W0
0019EA  904020     MOV.B [W0+2], W0
0019EC  FB8000     ZE W0, W0
0019EE  400063     ADD W0, #0x3, W0
0019F0  980710     MOV W0, [W14+2]
174:                   //对应赋值寄存器值
175:                   Register2Read(&sendBuffer[3], reg_add, sendBuffer[2]);
0019F2  470064     ADD W14, #0x4, W0
0019F4  904120     MOV.B [W0+2], W2
0019F6  470064     ADD W14, #0x4, W0
0019F8  400063     ADD W0, #0x3, W0
0019FA  9020AE     MOV [W14+68], W1
0019FC  0707FE     RCALL Register2Read
176:               
177:                   CRC_Result = CRC16_Check(sendBuffer, vaildBytes); //计算CRC结果
0019FE  470064     ADD W14, #0x4, W0
001A00  90009E     MOV [W14+2], W1
001A02  070E3F     RCALL CRC16_Check
001A04  780F00     MOV W0, [W14]
178:                   sendBuffer[vaildBytes] = (u8) (CRC_Result & 0x00ff); //赋值CRC低8位
001A06  90011E     MOV [W14+2], W2
001A08  78001E     MOV [W14], W0
001A0A  784080     MOV.B W0, W1
001A0C  470064     ADD W14, #0x4, W0
001A0E  410000     ADD W2, W0, W0
001A10  784801     MOV.B W1, [W0]
179:                   sendBuffer[vaildBytes + 1] = (u8) ((CRC_Result >> 8)&0x00ff); //赋值CRC高8位
001A12  90001E     MOV [W14+2], W0
001A14  E80100     INC W0, W2
001A16  78001E     MOV [W14], W0
001A18  DE0048     LSR W0, #8, W0
001A1A  784080     MOV.B W0, W1
001A1C  470064     ADD W14, #0x4, W0
001A1E  410000     ADD W2, W0, W0
001A20  784801     MOV.B W1, [W0]
180:                   vaildBytes += 2;
001A22  90001E     MOV [W14+2], W0
001A24  E88000     INC2 W0, W0
001A26  980710     MOV W0, [W14+2]
181:                   //发送数据到对应串口
182:                   TCP_SendData(source, sendBuffer, vaildBytes);
001A28  90001E     MOV [W14+2], W0
001A2A  784100     MOV.B W0, W2
001A2C  4700E4     ADD W14, #0x4, W1
001A2E  90C07E     MOV.B [W14+71], W0
001A30  070099     RCALL TCP_SendData
183:               }
001A32  FA8000     ULNK
001A34  060000     RETURN
184:               
185:               //200,14,PC
186:               //修改miot参数
187:               
188:               static void TCP_10_Reply(u16 reg_add, u8 arg_num, u8 source) {
001A36  FA000E     LNK #0xE
001A38  980750     MOV W0, [W14+10]
001A3A  984F41     MOV.B W1, [W14+12]
001A3C  984F52     MOV.B W2, [W14+13]
189:                   u8 sendBuffer[7];
190:                   u16 CRC_Result = 0; //CRC校验结果
001A3E  EB0000     CLR W0
001A40  780F00     MOV W0, [W14]
191:               
192:                   Register2Read(sendBuffer, mi_arg_add[mi_add], 1); //赋值Miot1601地址
001A42  846F81     MOV 0x8DF0, W1
001A44  E8800E     INC2 W14, W0
001A46  B3C012     MOV.B #0x1, W2
001A48  0707D8     RCALL Register2Read
193:                   sendBuffer[1] = 0x10;
001A4A  E8808E     INC2 W14, W1
001A4C  B3C100     MOV.B #0x10, W0
001A4E  984090     MOV.B W0, [W1+1]
194:                   sendBuffer[2] = (u8) ((reg_add >> 8)&0x00ff);
001A50  90005E     MOV [W14+10], W0
001A52  DE0048     LSR W0, #8, W0
001A54  784080     MOV.B W0, W1
001A56  E8800E     INC2 W14, W0
001A58  984021     MOV.B W1, [W0+2]
195:                   sendBuffer[3] = (u8) (reg_add & 0x00ff);
001A5A  90005E     MOV [W14+10], W0
001A5C  784080     MOV.B W0, W1
001A5E  E8800E     INC2 W14, W0
001A60  984031     MOV.B W1, [W0+3]
196:                   sendBuffer[4] = arg_num / 10 * 16 + arg_num % 10;
001A62  90484E     MOV.B [W14+12], W0
001A64  FB8000     ZE W0, W0
001A66  2000A2     MOV #0xA, W2
001A68  090011     REPEAT #0x11
001A6A  D88002     DIV.UW W0, W2
001A6C  FB8000     ZE W0, W0
001A6E  DD0044     SL W0, #4, W0
001A70  784080     MOV.B W0, W1
001A72  90484E     MOV.B [W14+12], W0
001A74  FB8000     ZE W0, W0
001A76  2000A2     MOV #0xA, W2
001A78  781F81     MOV W1, [W15++]
001A7A  090011     REPEAT #0x11
001A7C  D88002     DIV.UW W0, W2
001A7E  780100     MOV W0, W2
001A80  780001     MOV W1, W0
001A82  7800CF     MOV [--W15], W1
001A84  40C000     ADD.B W1, W0, W0
001A86  784080     MOV.B W0, W1
001A88  E8800E     INC2 W14, W0
001A8A  984041     MOV.B W1, [W0+4]
197:                   CRC_Result = CRC16_Check(sendBuffer, 5); //计算CRC结果    
001A8C  E8800E     INC2 W14, W0
001A8E  200051     MOV #0x5, W1
001A90  070DF8     RCALL CRC16_Check
001A92  780F00     MOV W0, [W14]
198:                   sendBuffer[5] = (u8) (CRC_Result & 0x00ff);
001A94  78001E     MOV [W14], W0
001A96  784080     MOV.B W0, W1
001A98  E8800E     INC2 W14, W0
001A9A  984051     MOV.B W1, [W0+5]
199:                   sendBuffer[6] = (u8) ((CRC_Result >> 8)&0x00ff);
001A9C  78001E     MOV [W14], W0
001A9E  DE0048     LSR W0, #8, W0
001AA0  784080     MOV.B W0, W1
001AA2  E8800E     INC2 W14, W0
001AA4  984061     MOV.B W1, [W0+6]
200:               
201:                   TCP_SendData(source, sendBuffer, 7);
001AA6  E8808E     INC2 W14, W1
001AA8  B3C072     MOV.B #0x7, W2
001AAA  90485E     MOV.B [W14+13], W0
001AAC  07005B     RCALL TCP_SendData
202:               }
001AAE  FA8000     ULNK
001AB0  060000     RETURN
203:               //返回
204:               //修改GPRS参数
205:               
206:               static void TCP_11_Reply(u8* dat) {
001AB2  FA0096     LNK #0x96
001AB4  988F20     MOV W0, [W14+148]
207:                   u8 receiveBuffer[145];
208:                   u16 CRC_Result = 0; //CRC校验结果
001AB6  EB0000     CLR W0
001AB8  780F00     MOV W0, [W14]
209:                   u8 tmp = 0x2B;
001ABA  B3C2B0     MOV.B #0x2B, W0
001ABC  995730     MOV.B W0, [W14+147]
210:                   //    GPRS_OFF;
211:                   GPRS_ON;
001ABE  A862C4     BSET LATA, #3
212:                   //    Delay100ms(2);
213:                   //发送GPRS参数值  
214:                   UART2SendString(dat + 2, 144);
001AC0  90882E     MOV [W14+148], W0
001AC2  E88000     INC2 W0, W0
001AC4  200901     MOV #0x90, W1
001AC6  070F97     RCALL UART2SendString
215:                   //等待100ms 接收数据 中断
216:                   T3Delay10ms(10);
001AC8  2000A0     MOV #0xA, W0
001ACA  070B2B     RCALL T3Delay10ms
217:                   //1s内从串口2接收数据 放在reciveBuffer+2中 反之发送没有指令的命令
218:                   if (UART1IsGet(receiveBuffer + 2, &tmp, 1)) {
001ACC  E8800E     INC2 W14, W0
001ACE  E88000     INC2 W0, W0
001AD0  200931     MOV #0x93, W1
001AD2  40808E     ADD W1, W14, W1
001AD4  B3C012     MOV.B #0x1, W2
001AD6  070619     RCALL UART1IsGet
001AD8  E00400     CP0.B W0
001ADA  320019     BRA Z, 0x1B0E
219:                       Register2Read(receiveBuffer, 0x200, 1); //赋值Miot1601地址
001ADC  E8800E     INC2 W14, W0
001ADE  B3C012     MOV.B #0x1, W2
001AE0  202001     MOV #0x200, W1
001AE2  07078B     RCALL Register2Read
220:                       receiveBuffer[1] = 0x11;
001AE4  E8808E     INC2 W14, W1
001AE6  B3C110     MOV.B #0x11, W0
001AE8  984090     MOV.B W0, [W1+1]
221:                       CRC_Result = CRC16_Check(receiveBuffer, 136); //计算CRC结果    
001AEA  E8800E     INC2 W14, W0
001AEC  200881     MOV #0x88, W1
001AEE  070DC9     RCALL CRC16_Check
001AF0  780F00     MOV W0, [W14]
222:                       receiveBuffer[136] = (u8) (CRC_Result & 0x00ff);
001AF2  78001E     MOV [W14], W0
001AF4  784080     MOV.B W0, W1
001AF6  E8800E     INC2 W14, W0
001AF8  994801     MOV.B W1, [W0+136]
223:                       receiveBuffer[137] = (u8) ((CRC_Result >> 8)&0x00ff);
001AFA  78001E     MOV [W14], W0
001AFC  DE0048     LSR W0, #8, W0
001AFE  784080     MOV.B W0, W1
001B00  E8800E     INC2 W14, W0
001B02  994811     MOV.B W1, [W0+137]
224:                       TCP_SendData(PC, receiveBuffer, 138);
001B04  E8808E     INC2 W14, W1
001B06  B3C8A2     MOV.B #0x8A, W2
001B08  EB4000     CLR.B W0
001B0A  07002C     RCALL TCP_SendData
001B0C  370004     BRA 0x1B16
225:                   } else
226:                       TCP_Error_Relay(0x11, Do_Err, PC);
001B0E  EB4100     CLR.B W2
001B10  B3C041     MOV.B #0x4, W1
001B12  B3C110     MOV.B #0x11, W0
001B14  070003     RCALL TCP_Error_Relay
227:                   GPRS_OFF;
001B16  A962C4     BCLR LATA, #3
228:               }
001B18  FA8000     ULNK
001B1A  060000     RETURN
229:               
230:               //void TCP_43_Send(/*u8 datacont,*/u8 source) {
231:               //    //    u8 tmp;//=(datacont)?datacont:1;                  //选择数据包的次数
232:               //    //    u16 tmp=10+REG_DATA_SZIE*12;                        //计算发送数据的总数                            
233:               //    u8 sendBuffer[502]; //创建发送数据的缓冲区
234:               //    u8 count = 0;
235:               //    u16 CRC_Result;
236:               //
237:               //    Register2Read(sendBuffer, 0x200, 1); //赋值Miot1601地址
238:               //    sendBuffer[1] = 0x43; //功能码
239:               //
240:               //    //    FROM_ReadN(&sendBuffer[2]); //从FROM中获取数据 
241:               //
242:               //    for (count = 0; count < 6; count++) //仪表ID
243:               //        Register2Read(&sendBuffer[494 + count], 0x201, 1);
244:               //    CRC_Result = CRC16_Check(sendBuffer, 500); //计算CRC结果
245:               //    sendBuffer[500] = (u8) (CRC_Result & 0x00ff);
246:               //    sendBuffer[501] = (u8) ((CRC_Result >> 8)&0x00ff);
247:               //
248:               //    TCP_SendData(GPRS, sendBuffer, 255); //分开发送数据
249:               //    //    TCP_SendData(GPRS, sendBuffer + 255, 10 + REG_DATA_SZIE * 12 - 255);
250:               //}
251:               //
252:               //static u8 TCP_43_DataReIsOK(u8* dat) {
253:               //    if (*(dat + 15) == 0xAA) //如果检测中心接收成功 退出
254:               //        return 'b';
255:               //    else {
256:               //        TCP_Error_Relay(0x43, Do_Err, PC); //反之，返回未执行错误
257:               //        return 0;
258:               //    }
259:               //}
260:               
261:               //input:0x30,01,PC
262:               
263:               void TCP_Error_Relay(u8 code, u8 err, u8 source) {
001B1C  FA000C     LNK #0xC
001B1E  984F00     MOV.B W0, [W14+8]
001B20  984F11     MOV.B W1, [W14+9]
001B22  984F22     MOV.B W2, [W14+10]
264:                   u8 sendBuffer[5]; //声明发送缓冲区
265:                   u16 CRC_Result; //声明CRC结果
266:               
267:                   Register2Read(sendBuffer, 0x200, 1); //赋值Miot1601地址
001B24  E8800E     INC2 W14, W0
001B26  B3C012     MOV.B #0x1, W2
001B28  202001     MOV #0x200, W1
001B2A  070767     RCALL Register2Read
268:                   sendBuffer[1] = 0x80 + code;
001B2C  90488E     MOV.B [W14+8], W1
001B2E  B3C800     MOV.B #0x80, W0
001B30  40C000     ADD.B W1, W0, W0
001B32  784080     MOV.B W0, W1
001B34  E8800E     INC2 W14, W0
001B36  984011     MOV.B W1, [W0+1]
269:                   sendBuffer[2] = err;
001B38  E8800E     INC2 W14, W0
001B3A  90489E     MOV.B [W14+9], W1
001B3C  984021     MOV.B W1, [W0+2]
270:               
271:                   CRC_Result = CRC16_Check(sendBuffer, 3); //计算CRC结果
001B3E  E8800E     INC2 W14, W0
001B40  200031     MOV #0x3, W1
001B42  070D9F     RCALL CRC16_Check
001B44  780F00     MOV W0, [W14]
272:                   sendBuffer[3] = (u8) (CRC_Result & 0x00ff);
001B46  78001E     MOV [W14], W0
001B48  784080     MOV.B W0, W1
001B4A  E8800E     INC2 W14, W0
001B4C  984031     MOV.B W1, [W0+3]
273:               
274:                   sendBuffer[4] = (u8) ((CRC_Result >> 8)&0x00ff);
001B4E  78001E     MOV [W14], W0
001B50  DE0048     LSR W0, #8, W0
001B52  784080     MOV.B W0, W1
001B54  E8800E     INC2 W14, W0
001B56  984041     MOV.B W1, [W0+4]
275:                   TCP_SendData(source, sendBuffer, 5); //发送数据
001B58  E8808E     INC2 W14, W1
001B5A  B3C052     MOV.B #0x5, W2
001B5C  90482E     MOV.B [W14+10], W0
001B5E  070002     RCALL TCP_SendData
276:               }
001B60  FA8000     ULNK
001B62  060000     RETURN
277:               
278:               //input arg,01,7
279:               
280:               void TCP_SendData(u8 source, u8 *dat, u8 bytes) {
001B64  FA0006     LNK #0x6
001B66  784F00     MOV.B W0, [W14]
001B68  980711     MOV W1, [W14+2]
001B6A  984742     MOV.B W2, [W14+4]
281:                   if (source)
001B6C  E0041E     CP0.B [W14]
001B6E  320005     BRA Z, 0x1B7A
282:                       UART2SendString(dat, bytes); //向GPRS发送数据
001B70  90404E     MOV.B [W14+4], W0
001B72  FB8080     ZE W0, W1
001B74  90001E     MOV [W14+2], W0
001B76  070F3F     RCALL UART2SendString
001B78  370004     BRA 0x1B82
283:                   else
284:                       RS485SendString(dat, bytes); //向电脑发送数据
001B7A  90404E     MOV.B [W14+4], W0
001B7C  FB8080     ZE W0, W1
001B7E  90001E     MOV [W14+2], W0
001B80  070EBB     RCALL RS485SendString
285:               }
001B82  FA8000     ULNK
001B84  060000     RETURN
286:               
287:               //for DAZONG
288:               
289:               void UDPSendData(u8 packetType) {//, u8 OffSet, const u8 SampleCnt) {
001B86  FA004E     LNK #0x4E
001B88  98CF40     MOV.B W0, [W14+76]
290:                   u8 sendBuffer[19]; //A2[2]+EID[8]+LEN[2]+T[1]+N[1]
291:                   u8 sendBuffer2[UDP_A2_LENGTH + 7];
292:                   u8 cnt/*, channel, number*/, sumCheck = 0, start_cnt = 0;
001B8A  EB4000     CLR.B W0
001B8C  98CF20     MOV.B W0, [W14+74]
001B8E  EB4000     CLR.B W0
001B90  984740     MOV.B W0, [W14+4]
293:                   u16 length;
294:                   u8 sampCnt = gCnt_Reg1;
001B92  BFCBDA     MOV.B 0xBDA, WREG
001B94  784F00     MOV.B W0, [W14]
295:               
296:                   if (sampCnt) {//如果数据包类型是Data Samples,反之就是报警数据
001B96  E0041E     CP0.B [W14]
001B98  32007C     BRA Z, 0x1C92
297:                       if (!packetType) {
001B9A  90C84E     MOV.B [W14+76], W0
001B9C  E00400     CP0.B W0
001B9E  3A000D     BRA NZ, 0x1BBA
298:                           //判断数据包数量是否正确
299:                           if (sampCnt > REG1_MAX_CNT) {
001BA0  B3C100     MOV.B #0x10, W0
001BA2  104F9E     SUBR.B W0, [W14], [W15]
001BA4  36000C     BRA LEU, 0x1BBE
300:                               start_cnt = sampCnt - ((sampCnt >> 4) << 4); //1
001BA6  78409E     MOV.B [W14], W1
001BA8  FB801E     ZE [W14], W0
001BAA  DE0044     LSR W0, #4, W0
001BAC  FB8000     ZE W0, W0
001BAE  DD0044     SL W0, #4, W0
001BB0  50C000     SUB.B W1, W0, W0
001BB2  984740     MOV.B W0, [W14+4]
301:                               sampCnt = REG1_MAX_CNT;
001BB4  B3C100     MOV.B #0x10, W0
001BB6  784F00     MOV.B W0, [W14]
001BB8  370002     BRA 0x1BBE
302:                           }
303:                       } else
304:                           sampCnt = 1;
001BBA  B3C010     MOV.B #0x1, W0
001BBC  784F00     MOV.B W0, [W14]
305:                       //A2帧头
306:                       sendBuffer[0] = 'A';
001BBE  4700E6     ADD W14, #0x6, W1
001BC0  B3C410     MOV.B #0x41, W0
001BC2  784880     MOV.B W0, [W1]
307:                       sendBuffer[1] = '2';
001BC4  4700E6     ADD W14, #0x6, W1
001BC6  B3C320     MOV.B #0x32, W0
001BC8  984090     MOV.B W0, [W1+1]
308:                       //EID
309:                       for (cnt = 0; cnt < 8; cnt++)
001BCA  EB4000     CLR.B W0
001BCC  984750     MOV.B W0, [W14+5]
001BCE  370010     BRA 0x1BF0
001BEA  90405E     MOV.B [W14+5], W0
001BEC  E84000     INC.B W0, W0
001BEE  984750     MOV.B W0, [W14+5]
001BF0  90405E     MOV.B [W14+5], W0
001BF2  504FE7     SUB.B W0, #0x7, [W15]
001BF4  36FFED     BRA LEU, 0x1BD0
310:                           *(sendBuffer + cnt + 2) = runingArg.gMp_id[cnt];
001BD0  90405E     MOV.B [W14+5], W0
001BD2  FB8000     ZE W0, W0
001BD4  780080     MOV W0, W1
001BD6  470066     ADD W14, #0x6, W0
001BD8  400001     ADD W0, W1, W0
001BDA  E88100     INC2 W0, W2
001BDC  90405E     MOV.B [W14+5], W0
001BDE  FB8000     ZE W0, W0
001BE0  4000E8     ADD W0, #0x8, W1
001BE2  20BA20     MOV #0xBA2, W0
001BE4  408000     ADD W1, W0, W0
001BE6  784010     MOV.B [W0], W0
001BE8  784900     MOV.B W0, [W2]
311:                       //        Register2Read(sendBuffer + 2, mi_arg_add[mp_id], 8);
312:                       //数据总长
313:                       length = 15 + (UDP_A2_LENGTH + 4) * sampCnt; //2+8+2+1+1+(UDP_A2_LENGTH+4)*number+1;
001BF6  FB809E     ZE [W14], W1
001BF8  2002E0     MOV #0x2E, W0
001BFA  B98800     MUL.SS W1, W0, W0
001BFC  40006F     ADD W0, #0xF, W0
001BFE  980710     MOV W0, [W14+2]
314:                       sendBuffer[10] = (u8) (length >> 8);
001C00  90001E     MOV [W14+2], W0
001C02  DE0048     LSR W0, #8, W0
001C04  784080     MOV.B W0, W1
001C06  470066     ADD W14, #0x6, W0
001C08  984821     MOV.B W1, [W0+10]
315:                       sendBuffer[11] = (u8) (length & 0x00FF); //数据类型
001C0A  90001E     MOV [W14+2], W0
001C0C  784080     MOV.B W0, W1
001C0E  470066     ADD W14, #0x6, W0
001C10  984831     MOV.B W1, [W0+11]
316:                       sendBuffer[12] = packetType; //赋值数据包个数
001C12  470066     ADD W14, #0x6, W0
001C14  90C8CE     MOV.B [W14+76], W1
001C16  984841     MOV.B W1, [W0+12]
317:                       sendBuffer[13] = sampCnt; //分开发送数据
001C18  470066     ADD W14, #0x6, W0
001C1A  78409E     MOV.B [W14], W1
001C1C  984851     MOV.B W1, [W0+13]
318:                       TCP_SendData(GPRS, sendBuffer, 14); //获取校验和
001C1E  4700E6     ADD W14, #0x6, W1
001C20  B3C0E2     MOV.B #0xE, W2
001C22  B3C010     MOV.B #0x1, W0
001C24  07FF9F     RCALL TCP_SendData
319:                       sumCheck = Sum_Check256(sendBuffer, 14); //赋值数据包的数据  
001C26  470066     ADD W14, #0x6, W0
001C28  2000E1     MOV #0xE, W1
001C2A  070D6F     RCALL Sum_Check256
001C2C  98CF20     MOV.B W0, [W14+74]
320:               
321:                       for (cnt = 0; cnt < sampCnt; cnt++) {
001C2E  EB4000     CLR.B W0
001C30  984750     MOV.B W0, [W14+5]
001C32  370027     BRA 0x1C82
001C7C  90405E     MOV.B [W14+5], W0
001C7E  E84000     INC.B W0, W0
001C80  984750     MOV.B W0, [W14+5]
001C82  90405E     MOV.B [W14+5], W0
001C84  504F9E     SUB.B W0, [W14], [W15]
001C86  39FFD6     BRA NC, 0x1C34
322:                           T3Delay10ms(50);
001C34  200320     MOV #0x32, W0
001C36  070A75     RCALL T3Delay10ms
323:                           //获取数据
324:                           GetRegister1(sendBuffer, (start_cnt + cnt - (((start_cnt + cnt) >> 4) << 4)));
001C38  9040CE     MOV.B [W14+4], W1
001C3A  90405E     MOV.B [W14+5], W0
001C3C  40C000     ADD.B W1, W0, W0
001C3E  784100     MOV.B W0, W2
001C40  90404E     MOV.B [W14+4], W0
001C42  FB8080     ZE W0, W1
001C44  90405E     MOV.B [W14+5], W0
001C46  FB8000     ZE W0, W0
001C48  408000     ADD W1, W0, W0
001C4A  DE8044     ASR W0, #4, W0
001C4C  DD0044     SL W0, #4, W0
001C4E  514000     SUB.B W2, W0, W0
001C50  784080     MOV.B W0, W1
001C52  470066     ADD W14, #0x6, W0
001C54  070868     RCALL GetRegister1
325:                           //获取时间戳 08 16 1 1 0 0 0 时间容易溢出
326:                           GetUnixTime_Char(sendBuffer + 12, sendBuffer2);
001C56  470066     ADD W14, #0x6, W0
001C58  40006C     ADD W0, #0xC, W0
001C5A  4700F9     ADD W14, #0x19, W1
001C5C  070A86     RCALL GetUnixTime_Char
327:                           //获取协议 赋值给数据包  A2参数+时间戳
328:                           PacketData2A2(sendBuffer2 + 4, sendBuffer);
001C5E  470079     ADD W14, #0x19, W0
001C60  400064     ADD W0, #0x4, W0
001C62  4700E6     ADD W14, #0x6, W1
001C64  07FCCC     RCALL PacketData2A2
329:                           //发送数据
330:                           TCP_SendData(GPRS, sendBuffer2, UDP_A2_LENGTH + 4);
001C66  4700F9     ADD W14, #0x19, W1
001C68  B3C2E2     MOV.B #0x2E, W2
001C6A  B3C010     MOV.B #0x1, W0
001C6C  07FF7B     RCALL TCP_SendData
331:                           //获取和校验
332:                           sumCheck += Sum_Check256(sendBuffer2, UDP_A2_LENGTH + 4);
001C6E  470079     ADD W14, #0x19, W0
001C70  2002E1     MOV #0x2E, W1
001C72  070D4B     RCALL Sum_Check256
001C74  784080     MOV.B W0, W1
001C76  90C82E     MOV.B [W14+74], W0
001C78  40C000     ADD.B W1, W0, W0
001C7A  98CF20     MOV.B W0, [W14+74]
333:                       }
334:                       //发送校验码  
335:                       TCP_SendData(GPRS, &sumCheck, 1);
001C88  2004A1     MOV #0x4A, W1
001C8A  40808E     ADD W1, W14, W1
001C8C  B3C012     MOV.B #0x1, W2
001C8E  B3C010     MOV.B #0x1, W0
001C90  07FF69     RCALL TCP_SendData
336:                   }
337:               }
001C92  FA8000     ULNK
001C94  060000     RETURN
338:               
339:               bool UDPReceiveData(u8 *dat, u8 *head, u8 num) {
001C96  FA000A     LNK #0xA
001C98  781F88     MOV W8, [W15++]
001C9A  980710     MOV W0, [W14+2]
001C9C  980721     MOV W1, [W14+4]
001C9E  984762     MOV.B W2, [W14+6]
340:                   //00 00 78 01 01 2C 02 00 78 03 42 C8 00 00 04 41 20 00 00 05 42 48 00 00 06 40 A0 00 00
341:                   u8 bytes = 0;
001CA0  EB4000     CLR.B W0
001CA2  784F00     MOV.B W0, [W14]
342:                   //    T3Delay10ms(100);//延时1s获取数据
343:                   bytes = UART2DataIsGet(dat, head, num, 10); //获取数据并校验数据  
001CA4  2000A3     MOV #0xA, W3
001CA6  90416E     MOV.B [W14+6], W2
001CA8  9000AE     MOV [W14+4], W1
001CAA  90001E     MOV [W14+2], W0
001CAC  070425     RCALL UART2DataIsGet
001CAE  784F00     MOV.B W0, [W14]
344:                   if (bytes) {//如果有接收到数据 
001CB0  E0041E     CP0.B [W14]
001CB2  320011     BRA Z, 0x1CD6
345:                       if (dat[bytes - 1] == Sum_Check256(dat, bytes - 1)) { //判断校验和是否正确        
001CB4  FB801E     ZE [W14], W0
001CB6  780080     MOV W0, W1
001CB8  90001E     MOV [W14+2], W0
001CBA  408000     ADD W1, W0, W0
001CBC  E90000     DEC W0, W0
001CBE  784410     MOV.B [W0], W8
001CC0  FB801E     ZE [W14], W0
001CC2  E90000     DEC W0, W0
001CC4  780080     MOV W0, W1
001CC6  90001E     MOV [W14+2], W0
001CC8  070D20     RCALL Sum_Check256
001CCA  544F80     SUB.B W8, W0, [W15]
001CCC  3A0004     BRA NZ, 0x1CD6
346:                           GPRS_OFF; //如果数据正确，模块下线 
001CCE  A962C4     BCLR LATA, #3
347:                           return true;
001CD0  200010     MOV #0x1, W0
001CD2  980740     MOV W0, [W14+8]
001CD4  370003     BRA 0x1CDC
348:                       }
349:                   }
350:                   GPRS_OFF; //没有接收到数据
001CD6  A962C4     BCLR LATA, #3
351:                   return false;
001CD8  EB0000     CLR W0
001CDA  980740     MOV W0, [W14+8]
001CDC  90004E     MOV [W14+8], W0
352:               }
001CDE  78044F     MOV [--W15], W8
001CE0  FA8000     ULNK
001CE2  060000     RETURN
353:               
354:               bool DUPDataChange(u8 * source_dat) {
001CE4  FA0008     LNK #0x8
001CE6  980710     MOV W0, [W14+2]
355:                   u8 Data_Type = *(source_dat + 14); //获取第一个数据的序号
001CE8  90001E     MOV [W14+2], W0
001CEA  40006E     ADD W0, #0xE, W0
001CEC  784090     MOV.B [W0], W1
001CEE  984711     MOV.B W1, [W14+1]
356:                   char bytes = *(source_dat + 13); //获取数据的长度
001CF0  90001E     MOV [W14+2], W0
001CF2  40006D     ADD W0, #0xD, W0
001CF4  784010     MOV.B [W0], W0
001CF6  784F00     MOV.B W0, [W14]
357:                   // u16 time_tmp;//获取时间 
358:                   //41 32 7F F9 02 01 00 00 00 01
359:                   //00 06 00 1D 00 00 78 01 02 58 
360:                   //02 00 3C 03 42 C8 00 00 04 42 
361:                   //C8 00 00 05 41 20 00 00 06 41 
362:                   //20 00 00 0B 
363:                   if (!DataIsVaild((u16) Data_Type, 6, 0)) //判断数据类型是否超出范围
001CF8  90401E     MOV.B [W14+1], W0
001CFA  FB8000     ZE W0, W0
001CFC  EB0100     CLR W2
001CFE  200061     MOV #0x6, W1
001D00  070BD1     RCALL DataIsVaild
001D02  E00400     CP0.B W0
001D04  3A0003     BRA NZ, 0x1D0C
364:                       return false;
001D06  EB0000     CLR W0
001D08  980730     MOV W0, [W14+6]
001D0A  370071     BRA 0x1DEE
365:               
366:                   if (!DataIsVaild((u16) bytes, 29, 3)) //判断字节数是否超出范围
001D0C  FB001E     SE [W14], W0
001D0E  200032     MOV #0x3, W2
001D10  2001D1     MOV #0x1D, W1
001D12  070BC8     RCALL DataIsVaild
001D14  E00400     CP0.B W0
001D16  3A0003     BRA NZ, 0x1D1E
367:                       return false;
001D18  EB0080     CLR W1
001D1A  980731     MOV W1, [W14+6]
001D1C  370068     BRA 0x1DEE
368:               
369:                   if (!(*(source_dat + 12))) {//如果数据类型是ACK
001D1E  90001E     MOV [W14+2], W0
001D20  40006C     ADD W0, #0xC, W0
001D22  784010     MOV.B [W0], W0
001D24  E00400     CP0.B W0
001D26  3A0061     BRA NZ, 0x1DEA
370:                       while (bytes > 0) {
001D28  37005A     BRA 0x1DDE
001DDE  E0041E     CP0.B [W14]
001DE0  3CFFA4     BRA GT, 0x1D2A
371:                           switch (Data_Type) {
001D2A  90401E     MOV.B [W14+1], W0
001D2C  FB8000     ZE W0, W0
001D2E  980720     MOV W0, [W14+4]
001D30  90002E     MOV [W14+4], W0
001D32  500FE1     SUB W0, #0x1, [W15]
001D34  320019     BRA Z, 0x1D68
001D36  9000AE     MOV [W14+4], W1
001D38  508FE2     SUB W1, #0x2, [W15]
001D3A  320028     BRA Z, 0x1D8C
001D3C  90002E     MOV [W14+4], W0
001D3E  E00000     CP0 W0
001D40  320001     BRA Z, 0x1D44
001D42  37004B     BRA 0x1DDA
372:                               case 0x00:
373:                               {// Save Period (seconds) 时间的表示方式不对                    
374:                                   SetVaildData((source_dat + 15), TIME_MP_MAX, TIME_MP_MIN); //检查数据
001D44  90001E     MOV [W14+2], W0
001D46  40006F     ADD W0, #0xF, W0
001D48  20E101     MOV #0xE10, W1
001D4A  251802     MOV #0x5180, W2
001D4C  200013     MOV #0x1, W3
001D4E  070BBF     RCALL SetVaildData
375:               
376:                                   Register2Write((source_dat + 15), mi_arg_add[mi_tmp], 1);
001D50  847021     MOV 0x8E04, W1
001D52  90001E     MOV [W14+2], W0
001D54  40006F     ADD W0, #0xF, W0
001D56  B3C012     MOV.B #0x1, W2
001D58  07062C     RCALL Register2Write
377:                                   bytes -= 3;
001D5A  78409E     MOV.B [W14], W1
001D5C  50CF63     SUB.B W1, #0x3, [W14]
378:                                   Data_Type = *(source_dat + 17);
001D5E  90001E     MOV [W14+2], W0
001D60  400071     ADD W0, #0x11, W0
001D62  784090     MOV.B [W0], W1
001D64  984711     MOV.B W1, [W14+1]
379:                                   break;
001D66  37003B     BRA 0x1DDE
380:                               }
381:                               case 0x01:
382:                               {// Send Period (seconds)                   
383:                                   SetVaildData((source_dat + 18), TIME_GPRS_MAX, TIME_GPRS_MIN); //获取GPRS上线时间并检查
001D68  90001E     MOV [W14+2], W0
001D6A  400072     ADD W0, #0x12, W0
001D6C  20E101     MOV #0xE10, W1
001D6E  251802     MOV #0x5180, W2
001D70  200013     MOV #0x1, W3
001D72  070BAD     RCALL SetVaildData
384:               
385:                                   Register2Write((source_dat + 18), mi_arg_add[mi_tgprs], 1);
001D74  847031     MOV 0x8E06, W1
001D76  90001E     MOV [W14+2], W0
001D78  400072     ADD W0, #0x12, W0
001D7A  B3C012     MOV.B #0x1, W2
001D7C  07061A     RCALL Register2Write
386:                                   bytes -= 3;
001D7E  78401E     MOV.B [W14], W0
001D80  504F63     SUB.B W0, #0x3, [W14]
387:                                   Data_Type = *(source_dat + 20);
001D82  90001E     MOV [W14+2], W0
001D84  400074     ADD W0, #0x14, W0
001D86  784090     MOV.B [W0], W1
001D88  984711     MOV.B W1, [W14+1]
388:                                   break;
001D8A  370029     BRA 0x1DDE
389:                               }
390:                               case 0x02:
391:                               {// Alarm Period (seconds)
392:                                   if (!(*(source_dat + 22)+(*(source_dat + 21) << 8))) {
001D8C  90001E     MOV [W14+2], W0
001D8E  400076     ADD W0, #0x16, W0
001D90  784010     MOV.B [W0], W0
001D92  FB8080     ZE W0, W1
001D94  90001E     MOV [W14+2], W0
001D96  400075     ADD W0, #0x15, W0
001D98  784010     MOV.B [W0], W0
001D9A  FB8000     ZE W0, W0
001D9C  DD0048     SL W0, #8, W0
001D9E  408000     ADD W1, W0, W0
001DA0  E00000     CP0 W0
001DA2  3A0007     BRA NZ, 0x1DB2
393:                                       SetVaildData((source_dat + 21), TIME_ALARM_MAX, TIME_ALARM_MIN); //获取GPRS上线时间并检查
001DA4  90001E     MOV [W14+2], W0
001DA6  400075     ADD W0, #0x15, W0
001DA8  2005A1     MOV #0x5A, W1
001DAA  251802     MOV #0x5180, W2
001DAC  200013     MOV #0x1, W3
001DAE  070B8F     RCALL SetVaildData
001DB0  370008     BRA 0x1DC2
394:                                   } else {
395:                                       *(source_dat + 21) = 0;
001DB2  90001E     MOV [W14+2], W0
001DB4  4000F5     ADD W0, #0x15, W1
001DB6  EB4000     CLR.B W0
001DB8  784880     MOV.B W0, [W1]
396:                                       *(source_dat + 22) = 0;
001DBA  90001E     MOV [W14+2], W0
001DBC  4000F6     ADD W0, #0x16, W1
001DBE  EB4000     CLR.B W0
001DC0  784880     MOV.B W0, [W1]
397:                                   }
398:                                   Register2Write((source_dat + 21), mi_arg_add[mi_talarm], 1);
001DC2  847041     MOV 0x8E08, W1
001DC4  90001E     MOV [W14+2], W0
001DC6  400075     ADD W0, #0x15, W0
001DC8  B3C012     MOV.B #0x1, W2
001DCA  0705F3     RCALL Register2Write
399:                                   bytes -= 3;
001DCC  78401E     MOV.B [W14], W0
001DCE  504F63     SUB.B W0, #0x3, [W14]
400:                                   Data_Type = *(source_dat + 23);
001DD0  90001E     MOV [W14+2], W0
001DD2  400077     ADD W0, #0x17, W0
001DD4  784090     MOV.B [W0], W1
001DD6  984711     MOV.B W1, [W14+1]
401:                                   break;
001DD8  370002     BRA 0x1DDE
402:                               }
403:                                   //                case 0x03:
404:                                   //                {// High Pressure Alarm 需要加判断
405:                                   //                    Register2Write((source_dat + 24), mi_arg_add[mi_hp_alarm], 1);
406:                                   //                    bytes -= 5;
407:                                   //                    Data_Type = *(source_dat + 28);
408:                                   //                    break;
409:                                   //                }
410:                                   //                case 0x04:
411:                                   //                {// Low Pressure Alarm 需要加判断
412:                                   //                    Register2Write((source_dat + 29), mi_arg_add[mi_lp_alarm], 1);
413:                                   //                    bytes -= 5;
414:                                   //                    Data_Type = *(source_dat + 33);
415:                                   //                    break;
416:                                   //                }
417:                                   //                case 0x05:
418:                                   //                {// High Temperature Alarm 需要加判断
419:                                   //                    Register2Write((source_dat + 34), mi_arg_add[mi_ht_alarm], 1);
420:                                   //                    bytes -= 5;
421:                                   //                    Data_Type = *(source_dat + 38);
422:                                   //                    break;
423:                                   //                }
424:                                   //                case 0x06:
425:                                   //                {// Low Temperature Alarm 需要加判断
426:                                   //                    Register2Write((source_dat + 39), mi_arg_add[mi_lt_alarm], 1);
427:                                   //                    bytes -= 5;
428:                                   //                    //                    Data_Type = *(source_dat + 24);
429:                                   //                    break;
430:                                   //                }
431:                               default:
432:                               {
433:                                   bytes = 0;
001DDA  EB4000     CLR.B W0
001DDC  784F00     MOV.B W0, [W14]
434:                                   break;
435:                               }
436:                           }
437:                       }
438:                       RefreshDaZong(); //刷新数据
001DE2  070717     RCALL RefreshDaZong
439:                       //        gAlarmCount = 0; //刷新计数  2016//11//23 删除数据
440:                       //        FLagArgbits.talarmFlag = 0; //清除标志位
441:                       //        FLagArgbits.tgprsFlag = 0;
442:                       //        gRefreshFlag = 0; //刷新位 置0
443:                       return true;
001DE4  200010     MOV #0x1, W0
001DE6  980730     MOV W0, [W14+6]
001DE8  370002     BRA 0x1DEE
444:                   }
445:                   return false;
001DEA  EB0080     CLR W1
001DEC  980731     MOV W1, [W14+6]
001DEE  90003E     MOV [W14+6], W0
446:               }
001DF0  FA8000     ULNK
001DF2  060000     RETURN
447:               
448:               
449:               
450:               
451:               
452:               
453:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/NVIC.c  ----------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年6月6日, 上午8:48
6:                  */
7:                 
8:                 #include "user.h"
9:                 #include "UART.h"
10:                #include "SerialBuffer.h"
11:                #include "RS485.h"
12:                #include "25L64B.h"
13:                
14:                struct FLag_Arg FLagArgbits;
15:                extern u8 gAlarmZeroLock; //
16:                //static u8 gOnce = 1;
17:                
18:                /*************************************
19:                Function: 闹钟中断 
20:                Description: 无
21:                Input: 无 
22:                Output: 无
23:                 *************************************/
24:                void __attribute__((__interrupt__, __auto_psv__)) _RTCCInterrupt(void) {
002D94  F80036     PUSH RCOUNT
002D96  BE9F80     MOV.D W0, [W15++]
002D98  BE9F82     MOV.D W2, [W15++]
002D9A  BE9F84     MOV.D W4, [W15++]
002D9C  BE9F86     MOV.D W6, [W15++]
002D9E  F80034     PUSH PSVPAG
002DA0  200000     MOV #0x0, W0
002DA2  8801A0     MOV W0, PSVPAG
002DA4  FA0000     LNK #0x0
25:                    //    gAlarmCheckFlag++; //时间校验标志位=1
26:                    gAlarmCount++; //时间计数 
002DA6  8061D0     MOV 0xC3A, W0
002DA8  8061E1     MOV 0xC3C, W1
002DAA  400061     ADD W0, #0x1, W0
002DAC  4880E0     ADDC W1, #0x0, W1
002DAE  8861D0     MOV W0, 0xC3A
002DB0  8861E1     MOV W1, 0xC3C
27:                    FLagArgbits.SleepExitFlag = 1; //退出睡眠模式
002DB2  A86C40     BSET FLagArgbits, #3
28:                
29:                    if (!((gAlarmCount + timeOffset.timeGprs) % runingArg.gTGprs))
002DB4  8060A0     MOV 0xC14, W0
002DB6  B80161     MUL.UU W0, #1, W2
002DB8  8061D0     MOV 0xC3A, W0
002DBA  8061E1     MOV 0xC3C, W1
002DBC  400202     ADD W0, W2, W4
002DBE  488283     ADDC W1, W3, W5
002DC0  805DE0     MOV 0xBBC, W0
002DC2  B80161     MUL.UU W0, #1, W2
002DC4  BE0004     MOV.D W4, W0
002DC6  07ECA0     RCALL ___umodsi3
002DC8  500FE0     SUB W0, #0x0, [W15]
002DCA  588FE0     SUBB W1, #0x0, [W15]
002DCC  3A0001     BRA NZ, 0x2DD0
30:                        FLagArgbits.tgprsFlag = 1;
002DCE  A80C40     BSET FLagArgbits, #0
31:                    if (runingArg.gTAlarm) {//如果报警时间不为0
002DD0  805DF0     MOV 0xBBE, W0
002DD2  E00000     CP0 W0
002DD4  320010     BRA Z, 0x2DF6
32:                        if (!((gAlarmCount + timeOffset.timeAlarm) % runingArg.gTAlarm)) {
002DD6  8060B0     MOV 0xC16, W0
002DD8  B80161     MUL.UU W0, #1, W2
002DDA  8061D0     MOV 0xC3A, W0
002DDC  8061E1     MOV 0xC3C, W1
002DDE  400202     ADD W0, W2, W4
002DE0  488283     ADDC W1, W3, W5
002DE2  805DF0     MOV 0xBBE, W0
002DE4  B80161     MUL.UU W0, #1, W2
002DE6  BE0004     MOV.D W4, W0
002DE8  07EC8F     RCALL ___umodsi3
002DEA  500FE0     SUB W0, #0x0, [W15]
002DEC  588FE0     SUBB W1, #0x0, [W15]
002DEE  3A0003     BRA NZ, 0x2DF6
33:                            FLagArgbits.talarmFlag = 1;
002DF0  A82C40     BSET FLagArgbits, #1
34:                            gAlarmZeroLock = 0; //解锁时间
002DF2  EB4000     CLR.B W0
002DF4  B7EC3E     MOV.B WREG, 0xC3E
35:                        }
36:                    }
37:                    if (!((gAlarmCount + timeOffset.timeMp) % runingArg.gTMp)) {//采集数据，并写入FRAM
002DF6  806090     MOV timeOffset, W0
002DF8  B80161     MUL.UU W0, #1, W2
002DFA  8061D0     MOV 0xC3A, W0
002DFC  8061E1     MOV 0xC3C, W1
002DFE  400202     ADD W0, W2, W4
002E00  488283     ADDC W1, W3, W5
002E02  805DD0     MOV 0xBBA, W0
002E04  B80161     MUL.UU W0, #1, W2
002E06  BE0004     MOV.D W4, W0
002E08  07EC7F     RCALL ___umodsi3
002E0A  500FE0     SUB W0, #0x0, [W15]
002E0C  588FE0     SUBB W1, #0x0, [W15]
002E0E  3A0003     BRA NZ, 0x2E16
38:                        FLagArgbits.tmpFlag = 1;
002E10  A84C40     BSET FLagArgbits, #2
39:                        T4CONbits.TON = 1;
002E12  A8E11F     BSET 0x11F, #7
40:                        IEC1bits.T4IE = 1;
002E14  A86097     BSET 0x97, #3
41:                    }
42:                    if (/*TST && */!(gAlarmCount - ((gAlarmCount >> 3) << 3)))
002E16  8061D0     MOV 0xC3A, W0
002E18  8061E1     MOV 0xC3C, W1
002E1A  DD094D     SL W1, #13, W2
002E1C  DE0043     LSR W0, #3, W0
002E1E  710000     IOR W2, W0, W0
002E20  DE08C3     LSR W1, #3, W1
002E22  DD0943     SL W1, #3, W2
002E24  DE01CD     LSR W0, #13, W3
002E26  710183     IOR W2, W3, W3
002E28  DD0143     SL W0, #3, W2
002E2A  8061D0     MOV 0xC3A, W0
002E2C  8061E1     MOV 0xC3C, W1
002E2E  510F80     SUB W2, W0, [W15]
002E30  598F81     SUBB W3, W1, [W15]
002E32  3A0001     BRA NZ, 0x2E36
43:                        GetArgForTest();
002E34  07FF1B     RCALL GetArgForTest
44:                    if (gAlarmCount > 86400) {//记录时间差值 
002E36  8061D2     MOV 0xC3A, W2
002E38  8061E3     MOV 0xC3C, W3
002E3A  251800     MOV #0x5180, W0
002E3C  200011     MOV #0x1, W1
002E3E  510F80     SUB W2, W0, [W15]
002E40  598F81     SUBB W3, W1, [W15]
002E42  36001C     BRA LEU, 0x2E7C
45:                        timeOffset.timeMp = gAlarmCount % runingArg.gTMp - 1;
002E44  8061D4     MOV 0xC3A, W4
002E46  8061E5     MOV 0xC3C, W5
002E48  805DD0     MOV 0xBBA, W0
002E4A  B80161     MUL.UU W0, #1, W2
002E4C  BE0004     MOV.D W4, W0
002E4E  07EC5C     RCALL ___umodsi3
002E50  E90000     DEC W0, W0
002E52  886090     MOV W0, timeOffset
46:                        timeOffset.timeGprs = gAlarmCount % runingArg.gTGprs - 1;
002E54  8061D4     MOV 0xC3A, W4
002E56  8061E5     MOV 0xC3C, W5
002E58  805DE0     MOV 0xBBC, W0
002E5A  B80161     MUL.UU W0, #1, W2
002E5C  BE0004     MOV.D W4, W0
002E5E  07EC54     RCALL ___umodsi3
002E60  E90000     DEC W0, W0
002E62  8860A0     MOV W0, 0xC14
47:                        timeOffset.timeAlarm = gAlarmCount % runingArg.gTAlarm - 1;
002E64  8061D4     MOV 0xC3A, W4
002E66  8061E5     MOV 0xC3C, W5
002E68  805DF0     MOV 0xBBE, W0
002E6A  B80161     MUL.UU W0, #1, W2
002E6C  BE0004     MOV.D W4, W0
002E6E  07EC4C     RCALL ___umodsi3
002E70  E90000     DEC W0, W0
002E72  8860B0     MOV W0, 0xC16
48:                        gAlarmCount = 0;
002E74  B80060     MUL.UU W0, #0, W0
002E76  8861D0     MOV W0, 0xC3A
002E78  8861E1     MOV W1, 0xC3C
49:                        FLagArgbits.CheckRTCCFlag = 1;
002E7A  A88C40     BSET FLagArgbits, #4
50:                    }
51:                    IFS3bits.RTCIF = 0; //clear RTC标志位      
002E7C  A9C08B     BCLR 0x8B, #6
52:                }
002E7E  FA8000     ULNK
002E80  F90034     POP PSVPAG
002E82  BE034F     MOV.D [--W15], W6
002E84  BE024F     MOV.D [--W15], W4
002E86  BE014F     MOV.D [--W15], W2
002E88  BE004F     MOV.D [--W15], W0
002E8A  F90036     POP RCOUNT
002E8C  064000     RETFIE
53:                
54:                /*************************************
55:                Function: 定时器中断 
56:                Description: 无
57:                Input: 无 
58:                Output: 无
59:                 *************************************/
60:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
002E8E  FEA000     PUSH.S
002E90  F80034     PUSH PSVPAG
002E92  781F88     MOV W8, [W15++]
002E94  200008     MOV #0x0, W8
002E96  8801A8     MOV W8, PSVPAG
002E98  78044F     MOV [--W15], W8
002E9A  FA0000     LNK #0x0
61:                    gT3Count++;
002E9C  806110     MOV 0xC22, W0
002E9E  E80000     INC W0, W0
002EA0  886110     MOV W0, 0xC22
62:                    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
002EA2  A90085     BCLR 0x85, #0
63:                }
002EA4  FA8000     ULNK
002EA6  F90034     POP PSVPAG
002EA8  FE8000     POP.S
002EAA  064000     RETFIE
64:                
65:                /*************************************
66:                Function: 定时器中断 
67:                Description: 无
68:                Input: 无 
69:                Output: 无
70:                 *************************************/
71:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
002EAC  FEA000     PUSH.S
002EAE  F80034     PUSH PSVPAG
002EB0  781F88     MOV W8, [W15++]
002EB2  200008     MOV #0x0, W8
002EB4  8801A8     MOV W8, PSVPAG
002EB6  78044F     MOV [--W15], W8
002EB8  FA0000     LNK #0x0
72:                    gT2Count++;
002EBA  806100     MOV 0xC20, W0
002EBC  E80000     INC W0, W0
002EBE  886100     MOV W0, 0xC20
73:                    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
002EC0  A9E084     BCLR IFS0, #7
74:                }
002EC2  FA8000     ULNK
002EC4  F90034     POP PSVPAG
002EC6  FE8000     POP.S
002EC8  064000     RETFIE
75:                
76:                /*************************************
77:                Function: 定时器中断 
78:                Description: 无
79:                Input: 无 
80:                Output: 无
81:                 *************************************/
82:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
002ECA  FEA000     PUSH.S
002ECC  F80034     PUSH PSVPAG
002ECE  781F88     MOV W8, [W15++]
002ED0  200008     MOV #0x0, W8
002ED2  8801A8     MOV W8, PSVPAG
002ED4  78044F     MOV [--W15], W8
002ED6  FA0000     LNK #0x0
83:                    gT1Count++;
002ED8  806120     MOV 0xC24, W0
002EDA  806131     MOV 0xC26, W1
002EDC  400061     ADD W0, #0x1, W0
002EDE  4880E0     ADDC W1, #0x0, W1
002EE0  886120     MOV W0, 0xC24
002EE2  886131     MOV W1, 0xC26
84:                    IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
002EE4  A96084     BCLR IFS0, #3
85:                }
002EE6  FA8000     ULNK
002EE8  F90034     POP PSVPAG
002EEA  FE8000     POP.S
002EEC  064000     RETFIE
86:                
87:                /*************************************
88:                Function: 定时器t4中断 
89:                Description: 无
90:                Input: 无 
91:                Output: 无
92:                 *************************************/
93:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
002EEE  FEA000     PUSH.S
002EF0  F80036     PUSH RCOUNT
002EF2  BE9F84     MOV.D W4, [W15++]
002EF4  BE9F86     MOV.D W6, [W15++]
002EF6  F80034     PUSH PSVPAG
002EF8  200004     MOV #0x0, W4
002EFA  8801A4     MOV W4, PSVPAG
002EFC  FA0000     LNK #0x0
94:                    if (FLagArgbits.tmpFlag) {
002EFE  BFCC40     MOV.B FLagArgbits, WREG
002F00  604064     AND.B W0, #0x4, W0
002F02  E00400     CP0.B W0
002F04  320002     BRA Z, 0x2F0A
95:                        FLagArgbits.tmpFlag = 0;
002F06  A94C40     BCLR FLagArgbits, #2
96:                        GetValueTask(); //获取仪表的通讯数据
002F08  07F2B7     RCALL GetValueTask
97:                    }
98:                    //    ClrWdt();
99:                    T4CONbits.TON = 0;
002F0A  A9E11F     BCLR 0x11F, #7
100:                   IEC1bits.T4IE = 0;
002F0C  A96097     BCLR 0x97, #3
101:                   IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
002F0E  A96087     BCLR 0x87, #3
102:               
103:                   //    //for test
104:                   //    FM25L64B_Read((gOffsetAdd + 143) % 144 * REG_DATA_SECTION, tmp, REG_DATA_SECTION);
105:                   //    GPRS_OFF;
106:               }
002F10  FA8000     ULNK
002F12  F90034     POP PSVPAG
002F14  BE034F     MOV.D [--W15], W6
002F16  BE024F     MOV.D [--W15], W4
002F18  F90036     POP RCOUNT
002F1A  FE8000     POP.S
002F1C  064000     RETFIE
107:               
108:               /*************************************
109:               Function: 电平变化中断 
110:               Description: 无
111:               Input: 无 
112:               Output: 无
113:                *************************************/
114:               void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //提醒更换电池
002F1E  BE9F80     MOV.D W0, [W15++]
002F20  BE9F82     MOV.D W2, [W15++]
002F22  F80034     PUSH PSVPAG
002F24  200000     MOV #0x0, W0
002F26  8801A0     MOV W0, PSVPAG
002F28  FA0000     LNK #0x0
115:                   if (INPUT_PULSE) {
002F2A  BFC2CB     MOV.B 0x2CB, WREG
002F2C  604062     AND.B W0, #0x2, W0
002F2E  E00400     CP0.B W0
002F30  32001A     BRA Z, 0x2F66
116:                       if (!T1CONbits.TON)
002F32  BFC105     MOV.B 0x105, WREG
002F34  B3C801     MOV.B #0x80, W1
002F36  604001     AND.B W0, W1, W0
002F38  E00400     CP0.B W0
002F3A  3A0001     BRA NZ, 0x2F3E
117:                           T1CONbits.TON = 1;
002F3C  A8E105     BSET 0x105, #7
118:                       gPulseCount++;
002F3E  805CE0     MOV 0xB9C, W0
002F40  805CF1     MOV 0xB9E, W1
002F42  400061     ADD W0, #0x1, W0
002F44  4880E0     ADDC W1, #0x0, W1
002F46  885CE0     MOV W0, 0xB9C
002F48  885CF1     MOV W1, 0xB9E
119:                       if (gT1Count > 20) {//125ms*20=2.5s
002F4A  806122     MOV 0xC24, W2
002F4C  806133     MOV 0xC26, W3
002F4E  200140     MOV #0x14, W0
002F50  200001     MOV #0x0, W1
002F52  510F80     SUB W2, W0, [W15]
002F54  598F81     SUBB W3, W1, [W15]
002F56  360007     BRA LEU, 0x2F66
120:                           gNowCapture = gT1Count;
002F58  806120     MOV 0xC24, W0
002F5A  806131     MOV 0xC26, W1
002F5C  885CC0     MOV W0, 0xB98
002F5E  885CD1     MOV W1, 0xB9A
121:                           gT1Count = 0;
002F60  B80060     MUL.UU W0, #0, W0
002F62  886120     MOV W0, 0xC24
002F64  886131     MOV W1, 0xC26
122:                       }
123:                   }
124:                   IFS1bits.CNIF = 0;
002F66  A96086     BCLR IFS1, #3
125:               }
002F68  FA8000     ULNK
002F6A  F90034     POP PSVPAG
002F6C  BE014F     MOV.D [--W15], W2
002F6E  BE004F     MOV.D [--W15], W0
002F70  064000     RETFIE
126:               
127:               /*************************************
128:               Function: UART1接收中断
129:               Description: 无
130:               Input: 无 
131:               Output: 无
132:                *************************************/
133:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
002F72  F80036     PUSH RCOUNT
002F74  BE9F80     MOV.D W0, [W15++]
002F76  BE9F82     MOV.D W2, [W15++]
002F78  BE9F84     MOV.D W4, [W15++]
002F7A  BE9F86     MOV.D W6, [W15++]
002F7C  F80034     PUSH PSVPAG
002F7E  200000     MOV #0x0, W0
002F80  8801A0     MOV W0, PSVPAG
002F82  FA0000     LNK #0x0
134:                   if (U1STAbits.OERR)//溢出处理
002F84  BFC222     MOV.B U1STA, WREG
002F86  604062     AND.B W0, #0x2, W0
002F88  E00400     CP0.B W0
002F8A  320001     BRA Z, 0x2F8E
135:                       U1STAbits.OERR = 0;
002F8C  A92222     BCLR U1STA, #1
136:               
137:                   if (U1STAbits.URXDA) //没有接收到
002F8E  BFC222     MOV.B U1STA, WREG
002F90  604061     AND.B W0, #0x1, W0
002F92  E00400     CP0.B W0
002F94  320001     BRA Z, 0x2F98
138:                   {
139:                       BufferWrite_UART1();
002F96  07FA36     RCALL BufferWrite_UART1
140:                   }
141:                   IFS0bits.U1RXIF = 0;
002F98  A96085     BCLR 0x85, #3
142:               }
002F9A  FA8000     ULNK
002F9C  F90034     POP PSVPAG
002F9E  BE034F     MOV.D [--W15], W6
002FA0  BE024F     MOV.D [--W15], W4
002FA2  BE014F     MOV.D [--W15], W2
002FA4  BE004F     MOV.D [--W15], W0
002FA6  F90036     POP RCOUNT
002FA8  064000     RETFIE
143:               
144:               /*************************************
145:               Function: UART2接收中断
146:               Description: 无
147:               Input: 无 
148:               Output: 无
149:                *************************************/
150:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
002FAA  F80036     PUSH RCOUNT
002FAC  BE9F80     MOV.D W0, [W15++]
002FAE  BE9F82     MOV.D W2, [W15++]
002FB0  BE9F84     MOV.D W4, [W15++]
002FB2  BE9F86     MOV.D W6, [W15++]
002FB4  F80034     PUSH PSVPAG
002FB6  200000     MOV #0x0, W0
002FB8  8801A0     MOV W0, PSVPAG
002FBA  FA0000     LNK #0x0
151:                   if (U2STAbits.OERR)//溢出处理
002FBC  BFC232     MOV.B U2STA, WREG
002FBE  604062     AND.B W0, #0x2, W0
002FC0  E00400     CP0.B W0
002FC2  320001     BRA Z, 0x2FC6
152:                       U2STAbits.OERR = 0;
002FC4  A92232     BCLR U2STA, #1
153:                   if (U2STAbits.FERR)
002FC6  BFC232     MOV.B U2STA, WREG
002FC8  604064     AND.B W0, #0x4, W0
002FCA  E00400     CP0.B W0
002FCC  320001     BRA Z, 0x2FD0
154:                       U2STAbits.FERR = 0;
002FCE  A94232     BCLR U2STA, #2
155:                   if (U2STAbits.PERR)
002FD0  BFC232     MOV.B U2STA, WREG
002FD2  604068     AND.B W0, #0x8, W0
002FD4  E00400     CP0.B W0
002FD6  320001     BRA Z, 0x2FDA
156:                       U2STAbits.PERR = 0;
002FD8  A96232     BCLR U2STA, #3
157:                   if (U2STAbits.URXDA) //没有接收到
002FDA  BFC232     MOV.B U2STA, WREG
002FDC  604061     AND.B W0, #0x1, W0
002FDE  E00400     CP0.B W0
002FE0  320001     BRA Z, 0x2FE4
158:                   {
159:                       BufferWrite_UART2();
002FE2  07FA2C     RCALL BufferWrite_UART2
160:                   }
161:                   IFS1bits.U2RXIF = 0;
002FE4  A9C087     BCLR 0x87, #6
162:               }
002FE6  FA8000     ULNK
002FE8  F90034     POP PSVPAG
002FEA  BE034F     MOV.D [--W15], W6
002FEC  BE024F     MOV.D [--W15], W4
002FEE  BE014F     MOV.D [--W15], W2
002FF0  BE004F     MOV.D [--W15], W0
002FF2  F90036     POP RCOUNT
002FF4  064000     RETFIE
163:               
164:               ///*************************************
165:               //Function: 脉冲数计算 
166:               //Description: 无
167:               //Input:   无 
168:               //Output: 无
169:               // *************************************/
170:               //void __attribute__((__interrupt__, __auto_psv__)) _IC2Interrupt(void) {
171:               //    //如果大于2s    
172:               //    gPulseCount++;
173:               //    //    if (gMcuFristFlag) {
174:               //    if (gT1Count > 200) {
175:               //        gNowCapture = gT1Count;
176:               //        gT1Count = 0;
177:               //    } else {
178:               //        T1CONbits.TON = 1;
179:               //    }
180:               //    IFS0bits.IC2IF = 0; // Reset respective interrupt flag
181:               //}
182:               
183:               
184:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/Miot1601.c  ------------------------
1:                 #include "user.h"
2:                 #include "25L64B.h"
3:                 #include "Miot1601.h"
4:                 #include "RS485.h"
5:                 
6:                 
7:                 //通径参数
8:                 const u8 Mi_Arg1[7] = {32, 40, 50, 80, 100, 150, 200};
9:                 const u8 Mi_Arg2[3] = {1, 10, 100};
10:                //static u8 Mi_Sp[5]={};
11:                static u8 Register1[REG1_MAX_CNT][19]; //用于存储时间7和工况量12
12:                u8 gCnt_Reg1 = 0;
13:                //模块参数初始化
14:                static u8 Register2[REG_ARG_SIZE] = {
15:                    0x08, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x02, 0x7F, 0xF9,
16:                    0x02, 0x01, 0x00, 0x00, 0x00, 0x04, 0x20, 0x16, 0x01, 0x01,
17:                    0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x01,
18:                    0x04, 0x01, 0x01, 0x03, 0x42, 0xF0, 0x00, 0x00, 0x42, 0xB4,
19:                    0x00, 0x00, 0x42, 0x48, 0x00, 0x00, 0x40, 0xA0, 0x00, 0x00,
20:                    0x00, 0x00, 0x00, 0x00
21:                };
22:                
23:                //寄存器地址
24:                const u16 mi_arg_add[REG_ARG_NUM + 1] = {
25:                    0x200, 0x201, 0x207, 0x208, 0x210, 0x212, 0x213, 0x214, 0x215,
26:                    0x216, 0x217, 0x219, 0x21B, 0x21D, 0x21E, 0x21F, 0x220, 0x221,
27:                    0x222, 0x226, 0x22A, 0x22E, 0x232, 0x236
28:                };
29:                
30:                //数据包地址
31:                const u8 mi_dat_add[REG_DATA_ARG_NUM + 1] = {
32:                    0x00, 0x07, 0x0B, 0x13, 0x17, 0x1B, 0x1F, 0x27, 0x28, 0x29
33:                };
34:                
35:                /*************************************
36:                Function: GetSize 
37:                Description: 获取数据长度
38:                Input: 寄存器地址 寄存器数量
39:                Output: 数据长度
40:                 *************************************/
41:                u8 GetSize(u16 reg_add, u8 arg_num) {
002906  FA0008     LNK #0x8
002908  980720     MOV W0, [W14+4]
00290A  984761     MOV.B W1, [W14+6]
42:                    u8 arg_Now = 0;
00290C  EB4000     CLR.B W0
00290E  984720     MOV.B W0, [W14+2]
43:                    u8 bytes = 0, count = 0;
002910  EB4000     CLR.B W0
002912  984710     MOV.B W0, [W14+1]
002914  EB4000     CLR.B W0
002916  784F00     MOV.B W0, [W14]
44:                
45:                    if (reg_add < mi_arg_add[REG_ARG_NUM] || reg_add >= mi_arg_add[0]) //获取Miot1601的参数字节数
002918  8470F1     MOV 0x8E1E, W1
00291A  90002E     MOV [W14+4], W0
00291C  508F80     SUB W1, W0, [W15]
00291E  3E0004     BRA GTU, 0x2928
002920  846F81     MOV 0x8DF0, W1
002922  90002E     MOV [W14+4], W0
002924  508F80     SUB W1, W0, [W15]
002926  3E0024     BRA GTU, 0x2970
00296E  37001D     BRA 0x29AA
46:                    {
47:                        for (count = 0; count < REG_ARG_NUM; count++) //判断当前参数是哪个
002928  EB4000     CLR.B W0
00292A  784F00     MOV.B W0, [W14]
00292C  370009     BRA 0x2940
00293E  E84F1E     INC.B [W14], [W14]
002940  B3C160     MOV.B #0x16, W0
002942  104F9E     SUBR.B W0, [W14], [W15]
002944  36FFF4     BRA LEU, 0x292E
48:                        {
49:                            if (reg_add == mi_arg_add[count])
00292E  FB801E     ZE [W14], W0
002930  400080     ADD W0, W0, W1
002932  28DF00     MOV #0x8DF0, W0
002934  408000     ADD W1, W0, W0
002936  780090     MOV [W0], W1
002938  90002E     MOV [W14+4], W0
00293A  508F80     SUB W1, W0, [W15]
00293C  320004     BRA Z, 0x2946
50:                                break;
51:                        }
52:                
53:                        arg_Now = count; //记录当前参数
002946  78401E     MOV.B [W14], W0
002948  984720     MOV.B W0, [W14+2]
54:                
55:                        bytes = (mi_arg_add[arg_Now + arg_num] - mi_arg_add[arg_Now]);
00294A  90402E     MOV.B [W14+2], W0
00294C  FB8080     ZE W0, W1
00294E  90406E     MOV.B [W14+6], W0
002950  FB8000     ZE W0, W0
002952  408000     ADD W1, W0, W0
002954  400080     ADD W0, W0, W1
002956  28DF00     MOV #0x8DF0, W0
002958  408000     ADD W1, W0, W0
00295A  780010     MOV [W0], W0
00295C  784100     MOV.B W0, W2
00295E  90402E     MOV.B [W14+2], W0
002960  FB8000     ZE W0, W0
002962  400080     ADD W0, W0, W1
002964  28DF00     MOV #0x8DF0, W0
002966  408000     ADD W1, W0, W0
002968  780010     MOV [W0], W0
00296A  514000     SUB.B W2, W0, W0
00296C  984710     MOV.B W0, [W14+1]
56:                    } else //获取数据中参数的字节数//读高地址有问题
57:                    {
58:                        for (count = 0; count < REG_DATA_ARG_NUM; count++) //判断当前参数是哪个
002970  EB4000     CLR.B W0
002972  784F00     MOV.B W0, [W14]
002974  370008     BRA 0x2986
002984  E84F1E     INC.B [W14], [W14]
002986  B3C080     MOV.B #0x8, W0
002988  104F9E     SUBR.B W0, [W14], [W15]
00298A  36FFF5     BRA LEU, 0x2976
59:                        {
60:                            if (reg_add == mi_dat_add[count])
002976  FB809E     ZE [W14], W1
002978  28E200     MOV #0x8E20, W0
00297A  784061     MOV.B [W1+W0], W0
00297C  FB8080     ZE W0, W1
00297E  90002E     MOV [W14+4], W0
002980  508F80     SUB W1, W0, [W15]
002982  320004     BRA Z, 0x298C
61:                                break;
62:                        }
63:                
64:                        arg_Now = count; //记录当前参数
00298C  78401E     MOV.B [W14], W0
00298E  984720     MOV.B W0, [W14+2]
65:                
66:                        bytes = (mi_dat_add[arg_Now + arg_num ] - mi_dat_add[arg_Now]);
002990  90402E     MOV.B [W14+2], W0
002992  FB8080     ZE W0, W1
002994  90406E     MOV.B [W14+6], W0
002996  FB8000     ZE W0, W0
002998  408080     ADD W1, W0, W1
00299A  28E200     MOV #0x8E20, W0
00299C  784161     MOV.B [W1+W0], W2
00299E  90402E     MOV.B [W14+2], W0
0029A0  FB8080     ZE W0, W1
0029A2  28E200     MOV #0x8E20, W0
0029A4  784061     MOV.B [W1+W0], W0
0029A6  514000     SUB.B W2, W0, W0
0029A8  984710     MOV.B W0, [W14+1]
67:                    }
68:                    return bytes;
0029AA  90401E     MOV.B [W14+1], W0
0029AC  FB8000     ZE W0, W0
69:                }
0029AE  FA8000     ULNK
0029B0  060000     RETURN
70:                
71:                /*************************************
72:                Function: Register2_Write 
73:                Description: 写寄存器2参数
74:                Input: 源数据指针dat 寄存器地址 寄存器数量
75:                Output: 无
76:                 *************************************/
77:                void Register2Write(u8 * dat, u16 reg_add, u8 arg_num) {
0029B2  FA000C     LNK #0xC
0029B4  980730     MOV W0, [W14+6]
0029B6  980741     MOV W1, [W14+8]
0029B8  984F22     MOV.B W2, [W14+10]
78:                    u8 count = 0; //声明计数变量      
0029BA  EB4000     CLR.B W0
0029BC  984740     MOV.B W0, [W14+4]
79:                    u16 add_base = reg_add - mi_arg_add[0]; //获取地址偏移量
0029BE  846F81     MOV 0x8DF0, W1
0029C0  90004E     MOV [W14+8], W0
0029C2  500001     SUB W0, W1, W0
0029C4  980710     MOV W0, [W14+2]
80:                    u8 bytes = GetSize(reg_add, arg_num);
0029C6  9048AE     MOV.B [W14+10], W1
0029C8  90004E     MOV [W14+8], W0
0029CA  07FF9D     RCALL GetSize
0029CC  784F00     MOV.B W0, [W14]
81:                
82:                    while (count < bytes) {
0029CE  370010     BRA 0x29F0
0029F0  90404E     MOV.B [W14+4], W0
0029F2  504F9E     SUB.B W0, [W14], [W15]
0029F4  39FFED     BRA NC, 0x29D0
83:                        Register2[add_base + count] = *(dat + count); //寄存器导入参数
0029D0  90404E     MOV.B [W14+4], W0
0029D2  FB8080     ZE W0, W1
0029D4  90001E     MOV [W14+2], W0
0029D6  408100     ADD W1, W0, W2
0029D8  90404E     MOV.B [W14+4], W0
0029DA  FB8000     ZE W0, W0
0029DC  780080     MOV W0, W1
0029DE  90003E     MOV [W14+6], W0
0029E0  408000     ADD W1, W0, W0
0029E2  784090     MOV.B [W0], W1
0029E4  20BDB0     MOV #0xBDB, W0
0029E6  410000     ADD W2, W0, W0
0029E8  784801     MOV.B W1, [W0]
84:                        count++;
0029EA  90404E     MOV.B [W14+4], W0
0029EC  E84000     INC.B W0, W0
0029EE  984740     MOV.B W0, [W14+4]
85:                    }
86:                
87:                    //！！！！！！！！！！！添加限制
88:                    //    Register2[mi_arg_add[mi_gprs_mode]] = 1; //UDP
89:                    //    Register2[Cmi_arg_add[mi_mp_po]] = 3; //A3
90:                    //    if (Register2[mi_arg_add[mi_tmp]]*12 > Register2[mi_arg_add[mi_tgprs]])//如果时间之比大于12
91:                    //        Register2[mi_arg_add[mi_tmp]] = Register2[mi_arg_add[mi_tgprs]] / 12;
92:                    //??????????????????? 结束
93:                }
0029F6  FA8000     ULNK
0029F8  060000     RETURN
94:                
95:                /*************************************
96:                Function: Register2_Read 
97:                Description: 读取寄存器2
98:                Input: 数据源指针dat 寄存器地址reg_add  字节数bytes 
99:                Output: 无
100:                *************************************/
101:               void Register2Read(u8* dat, u16 reg_add, u8 bytes) {
0029FA  FA000A     LNK #0xA
0029FC  980720     MOV W0, [W14+4]
0029FE  980731     MOV W1, [W14+6]
002A00  984F02     MOV.B W2, [W14+8]
102:                   u8 count = 0;
002A02  EB4000     CLR.B W0
002A04  984720     MOV.B W0, [W14+2]
103:                   u16 add_base = reg_add - mi_arg_add[0];
002A06  846F81     MOV 0x8DF0, W1
002A08  90003E     MOV [W14+6], W0
002A0A  500F01     SUB W0, W1, [W14]
104:               
105:                   for (count = 0; count < bytes; count++)
002A0C  EB4000     CLR.B W0
002A0E  984720     MOV.B W0, [W14+2]
002A10  37000F     BRA 0x2A30
002A2A  90402E     MOV.B [W14+2], W0
002A2C  E84000     INC.B W0, W0
002A2E  984720     MOV.B W0, [W14+2]
002A30  9040AE     MOV.B [W14+2], W1
002A32  90480E     MOV.B [W14+8], W0
002A34  50CF80     SUB.B W1, W0, [W15]
002A36  39FFED     BRA NC, 0x2A12
106:                       *(dat + count) = Register2[count + add_base];
002A12  90402E     MOV.B [W14+2], W0
002A14  FB8000     ZE W0, W0
002A16  780080     MOV W0, W1
002A18  90002E     MOV [W14+4], W0
002A1A  408100     ADD W1, W0, W2
002A1C  90402E     MOV.B [W14+2], W0
002A1E  FB8000     ZE W0, W0
002A20  40009E     ADD W0, [W14], W1
002A22  20BDB0     MOV #0xBDB, W0
002A24  408000     ADD W1, W0, W0
002A26  784010     MOV.B [W0], W0
002A28  784900     MOV.B W0, [W2]
107:               }
002A38  FA8000     ULNK
002A3A  060000     RETURN
108:               
109:               /*************************************
110:               Function: Get_Mi_Add
111:               Description: 获取miot地址
112:               Input: 
113:               Output: 
114:                *************************************/
115:               static void Get_Mi_Add(void) {
002A3C  FA0000     LNK #0x0
116:                   Register2Read(&runingArg.gMi_add, mi_arg_add[mi_add], 1);
002A3E  846F81     MOV 0x8DF0, W1
002A40  B3C012     MOV.B #0x1, W2
002A42  20BA20     MOV #0xBA2, W0
002A44  07FFDA     RCALL Register2Read
117:               }
002A46  FA8000     ULNK
002A48  060000     RETURN
118:               
119:               /*************************************
120:               Function: Get_Mi_ID
121:               Description: 获取mi的Id号
122:               Input: 
123:               Output: 
124:                *************************************/
125:               static void Get_Mi_Id(void) {
002A4A  FA0000     LNK #0x0
126:                   Register2Read(runingArg.gMi_id, mi_arg_add[mi_id], 6);
002A4C  846F91     MOV 0x8DF2, W1
002A4E  B3C062     MOV.B #0x6, W2
002A50  20BA30     MOV #0xBA3, W0
002A52  07FFD3     RCALL Register2Read
127:               }
002A54  FA8000     ULNK
002A56  060000     RETURN
128:               
129:               /*************************************
130:               Function: Get_Mp_Add
131:               Description: 获取mp的地址
132:               Input: 
133:               Output: 
134:                *************************************/
135:               static void Get_Mp_Add(void) {
002A58  FA0000     LNK #0x0
136:                   Register2Read(&runingArg.gMp_add, mi_arg_add[mp_add], 1);
002A5A  846FA1     MOV 0x8DF4, W1
002A5C  B3C012     MOV.B #0x1, W2
002A5E  20BA90     MOV #0xBA9, W0
002A60  07FFCC     RCALL Register2Read
137:               }
002A62  FA8000     ULNK
002A64  060000     RETURN
138:               
139:               /*************************************
140:               Function: Get_Mp_Id
141:               Description: 获取mp的ID号
142:               Input: 
143:               Output: 
144:                *************************************/
145:               static void Get_Mp_Id(void) {
002A66  FA0000     LNK #0x0
146:                   Register2Read(runingArg.gMp_id, mi_arg_add[mp_id], 8);
002A68  846FB1     MOV 0x8DF6, W1
002A6A  B3C082     MOV.B #0x8, W2
002A6C  20BAA0     MOV #0xBAA, W0
002A6E  07FFC5     RCALL Register2Read
147:               }
002A70  FA8000     ULNK
002A72  060000     RETURN
148:               
149:               /*************************************
150:               Function: Get_Mi_Month
151:               Description: 获取mi的年
152:               Input: 
153:               Output: 
154:                *************************************/
155:               static void Get_Mi_Year(void) {
002A74  FA0000     LNK #0x0
156:                   Register2Read(runingArg.gYear, mi_arg_add[mi_year], 2);
002A76  846FC1     MOV 0x8DF8, W1
002A78  B3C022     MOV.B #0x2, W2
002A7A  20BB20     MOV #0xBB2, W0
002A7C  07FFBE     RCALL Register2Read
157:               }
002A7E  FA8000     ULNK
002A80  060000     RETURN
158:               
159:               /*************************************
160:               Function: Get_Mi_Month
161:               Description: 获取mi的月
162:               Input: 
163:               Output: 
164:                *************************************/
165:               static void Get_Mi_Month(void) {
002A82  FA0000     LNK #0x0
166:                   Register2Read(&runingArg.gMonth, mi_arg_add[mi_month], 1);
002A84  846FD1     MOV 0x8DFA, W1
002A86  B3C012     MOV.B #0x1, W2
002A88  20BB40     MOV #0xBB4, W0
002A8A  07FFB7     RCALL Register2Read
167:               }
002A8C  FA8000     ULNK
002A8E  060000     RETURN
168:               
169:               /*************************************
170:               Function: Get_Mi_Day
171:               Description: 获取mi的天
172:               Input: 
173:               Output: 
174:                *************************************/
175:               static void Get_Mi_Day(void) {
002A90  FA0000     LNK #0x0
176:                   Register2Read(&runingArg.gDay, mi_arg_add[mi_day], 1);
002A92  846FE1     MOV 0x8DFC, W1
002A94  B3C012     MOV.B #0x1, W2
002A96  20BB50     MOV #0xBB5, W0
002A98  07FFB0     RCALL Register2Read
177:               }
002A9A  FA8000     ULNK
002A9C  060000     RETURN
178:               
179:               /*************************************
180:               Function: Get_Mi_Hour
181:               Description: 获取mi的小时
182:               Input: 
183:               Output: 
184:                *************************************/
185:               static void Get_Mi_Hour(void) {
002A9E  FA0000     LNK #0x0
186:                   Register2Read(&runingArg.gHour, mi_arg_add[mi_hour], 1);
002AA0  846FF1     MOV 0x8DFE, W1
002AA2  B3C012     MOV.B #0x1, W2
002AA4  20BB60     MOV #0xBB6, W0
002AA6  07FFA9     RCALL Register2Read
187:               }
002AA8  FA8000     ULNK
002AAA  060000     RETURN
188:               
189:               /*************************************
190:               Function: Get_Mi_Min
191:               Description: 获取mi的分钟
192:               Input: 
193:               Output: 
194:                *************************************/
195:               static void Get_Mi_Min(void) {
002AAC  FA0000     LNK #0x0
196:                   Register2Read(&runingArg.gMin, mi_arg_add[mi_min], 1);
002AAE  847001     MOV 0x8E00, W1
002AB0  B3C012     MOV.B #0x1, W2
002AB2  20BB70     MOV #0xBB7, W0
002AB4  07FFA2     RCALL Register2Read
197:               }
002AB6  FA8000     ULNK
002AB8  060000     RETURN
198:               
199:               /*************************************
200:               Function: Get_Mi_Sec
201:               Description: 获取mi的秒
202:               Input: 
203:               Output: 
204:                *************************************/
205:               static void Get_Mi_Sec(void) {
002ABA  FA0000     LNK #0x0
206:                   Register2Read(&runingArg.gSec, mi_arg_add[mi_sec], 1);
002ABC  847011     MOV 0x8E02, W1
002ABE  B3C012     MOV.B #0x1, W2
002AC0  20BB80     MOV #0xBB8, W0
002AC2  07FF9B     RCALL Register2Read
207:               }
002AC4  FA8000     ULNK
002AC6  060000     RETURN
208:               
209:               /*************************************
210:               Function: Get_Mi_Tgprs
211:               Description: 获取gprs上传时间
212:               Input: 
213:               Output: 
214:                *************************************/
215:               static void Get_Mi_Tgprs(void) {//获取GPRS上线时间
002AC8  FA0002     LNK #0x2
216:                   u8 time_tmp[2];
217:                   Register2Read(time_tmp, mi_arg_add[mi_tgprs], 2);
002ACA  847031     MOV 0x8E06, W1
002ACC  B3C022     MOV.B #0x2, W2
002ACE  78000E     MOV W14, W0
002AD0  07FF94     RCALL Register2Read
218:                   runingArg.gTGprs = (time_tmp[0] << 8) + time_tmp[1];
002AD2  78401E     MOV.B [W14], W0
002AD4  FB8000     ZE W0, W0
002AD6  DD00C8     SL W0, #8, W1
002AD8  90401E     MOV.B [W14+1], W0
002ADA  FB8000     ZE W0, W0
002ADC  408000     ADD W1, W0, W0
002ADE  885DE0     MOV W0, 0xBBC
219:               }
002AE0  FA8000     ULNK
002AE2  060000     RETURN
220:               
221:               /*************************************
222:               Function: Get_Mi_Tmp
223:               Description: 获取采集时间
224:               Input: 
225:               Output: 
226:                *************************************/
227:               static void Get_Mi_Tmp(void) { //获取采集mP时间
002AE4  FA0002     LNK #0x2
228:                   u8 time_tmp[2];
229:                   Register2Read(time_tmp, mi_arg_add[mi_tmp], 2);
002AE6  847021     MOV 0x8E04, W1
002AE8  B3C022     MOV.B #0x2, W2
002AEA  78000E     MOV W14, W0
002AEC  07FF86     RCALL Register2Read
230:                   runingArg.gTMp = (time_tmp[0] << 8) + time_tmp[1];
002AEE  78401E     MOV.B [W14], W0
002AF0  FB8000     ZE W0, W0
002AF2  DD00C8     SL W0, #8, W1
002AF4  90401E     MOV.B [W14+1], W0
002AF6  FB8000     ZE W0, W0
002AF8  408000     ADD W1, W0, W0
002AFA  885DD0     MOV W0, 0xBBA
231:               }
002AFC  FA8000     ULNK
002AFE  060000     RETURN
232:               
233:               /*************************************
234:               Function: Get_Mi_Talarm
235:               Description: 获取报警时间
236:               Input: 
237:               Output: 
238:                *************************************/
239:               static void Get_Mi_Talarm(void) {//获取报警时间并检查 
002B00  FA0002     LNK #0x2
240:                   u8 time_tmp[2];
241:                   Register2Read(time_tmp, mi_arg_add[mi_talarm], 2);
002B02  847041     MOV 0x8E08, W1
002B04  B3C022     MOV.B #0x2, W2
002B06  78000E     MOV W14, W0
002B08  07FF78     RCALL Register2Read
242:                   runingArg.gTAlarm = (time_tmp[0] << 8) + time_tmp[1];
002B0A  78401E     MOV.B [W14], W0
002B0C  FB8000     ZE W0, W0
002B0E  DD00C8     SL W0, #8, W1
002B10  90401E     MOV.B [W14+1], W0
002B12  FB8000     ZE W0, W0
002B14  408000     ADD W1, W0, W0
002B16  885DF0     MOV W0, 0xBBE
243:               }
002B18  FA8000     ULNK
002B1A  060000     RETURN
244:               
245:               /*************************************
246:               Function: Get_Mi_Sp
247:               Description: 获取MP通径
248:               Input: 
249:               Output: 
250:                *************************************/
251:               static void Get_Mi_Sp(void) {//获取报警时间并检查 
002B1C  FA0000     LNK #0x0
252:                   Register2Read(&runingArg.gSp, mi_arg_add[mi_sp], 1);
002B1E  847051     MOV 0x8E0A, W1
002B20  B3C012     MOV.B #0x1, W2
002B22  20BC00     MOV #0xBC0, W0
002B24  07FF6A     RCALL Register2Read
253:               }
002B26  FA8000     ULNK
002B28  060000     RETURN
254:               
255:               /*************************************
256:               Function: Get_Mi_Arg1
257:               Description: 获取MP通径
258:               Input: 
259:               Output: 
260:                *************************************/
261:               static void Get_Mi_Arg1(void) {
002B2A  FA0002     LNK #0x2
262:                   u8 tmp;
263:                   Register2Read(&tmp, mi_arg_add[mi_arg1], 1);
002B2C  847061     MOV 0x8E0C, W1
002B2E  B3C012     MOV.B #0x1, W2
002B30  78000E     MOV W14, W0
002B32  07FF63     RCALL Register2Read
264:                   //    if (runingArg.gArg1 < 7)
265:                   runingArg.gArg1 = Mi_Arg1[runingArg.gArg1];
002B34  BFCBC1     MOV.B 0xBC1, WREG
002B36  FB8080     ZE W0, W1
002B38  28DE60     MOV #0x8DE6, W0
002B3A  784061     MOV.B [W1+W0], W0
002B3C  B7EBC1     MOV.B WREG, 0xBC1
266:               }
002B3E  FA8000     ULNK
002B40  060000     RETURN
267:               
268:               /*************************************
269:               Function: Get_Mi_Arg2
270:               Description: 获取MP SSP
271:               Input: 
272:               Output: 
273:                *************************************/
274:               static void Get_Mi_Arg2(void) {
002B42  FA0002     LNK #0x2
275:                   u8 tmp;
276:                   Register2Read(&tmp, mi_arg_add[mi_arg2], 1);
002B44  847071     MOV 0x8E0E, W1
002B46  B3C012     MOV.B #0x1, W2
002B48  78000E     MOV W14, W0
002B4A  07FF57     RCALL Register2Read
277:                   //    if (runingArg.gArg2 < 3)
278:                   runingArg.gArg2 = Mi_Arg2[runingArg.gArg2];
002B4C  BFCBC2     MOV.B 0xBC2, WREG
002B4E  FB8080     ZE W0, W1
002B50  28DED0     MOV #0x8DED, W0
002B52  784061     MOV.B [W1+W0], W0
002B54  B7EBC2     MOV.B WREG, 0xBC2
279:               }
002B56  FA8000     ULNK
002B58  060000     RETURN
280:               
281:               /*************************************
282:               Function: Get_Mi_Mode
283:               Description: 获取Mi主从模式
284:               Input: 
285:               Output: 
286:                *************************************/
287:               static void Get_Mi_Mode(void) {
002B5A  FA0000     LNK #0x0
288:                   Register2Read(&runingArg.gMode, mi_arg_add[mi_mode], 1);
002B5C  847081     MOV 0x8E10, W1
002B5E  B3C012     MOV.B #0x1, W2
002B60  20BC30     MOV #0xBC3, W0
002B62  07FF4B     RCALL Register2Read
289:               }
002B64  FA8000     ULNK
002B66  060000     RETURN
290:               
291:               ///*************************************
292:               //Function: Get_Mi_Gprs_Mode
293:               //Description: 获取GPRS工作模式
294:               //Input: 
295:               //Output: 
296:               // *************************************/
297:               //static void Get_Mi_Gprs_Mode(void) {
298:               //    Register2Read(&runingArg.gGprs_Mode, mi_arg_add[mi_gprs_mode], 1);
299:               //}
300:               
301:               /*************************************
302:               Function: Get_Mi_Mp_Po
303:               Description: 获取MP协议
304:               Input: 
305:               Output: 
306:                *************************************/
307:               static void Get_Mi_Mp_Po(void) {
002B68  FA0000     LNK #0x0
308:                   Register2Read(&runingArg.gMp_po, mi_arg_add[mi_mp_po], 1);
002B6A  847091     MOV 0x8E12, W1
002B6C  B3C012     MOV.B #0x1, W2
002B6E  20BC40     MOV #0xBC4, W0
002B70  07FF44     RCALL Register2Read
309:               }
002B72  FA8000     ULNK
002B74  060000     RETURN
310:               
311:               /*************************************
312:               Function: Get_Mi_Hp
313:               Description: 获取高压报警
314:               Input: 
315:               Output: 
316:                *************************************/
317:               static void Get_Mi_Hp(void) {
002B76  FA0004     LNK #0x4
318:                   u8 tmp_alarm[4];
319:                   Register2Read(tmp_alarm, mi_arg_add[mi_hp_alarm], 4);
002B78  8470A1     MOV 0x8E14, W1
002B7A  B3C042     MOV.B #0x4, W2
002B7C  78000E     MOV W14, W0
002B7E  07FF3D     RCALL Register2Read
320:                   CharToFloat(&runingArg.gHP, tmp_alarm);
002B80  78008E     MOV W14, W1
002B82  20BC60     MOV #0xBC6, W0
002B84  07044A     RCALL CharToFloat
321:               }
002B86  FA8000     ULNK
002B88  060000     RETURN
322:               
323:               /*************************************
324:               Function: Get_Mi_Lp
325:               Description: 获取低压报警
326:               Input: 
327:               Output: 
328:                *************************************/
329:               static void Get_Mi_Lp(void) {
002B8A  FA0004     LNK #0x4
330:                   u8 tmp_alarm[4];
331:                   Register2Read(tmp_alarm, mi_arg_add[mi_lp_alarm], 4);
002B8C  8470B1     MOV 0x8E16, W1
002B8E  B3C042     MOV.B #0x4, W2
002B90  78000E     MOV W14, W0
002B92  07FF33     RCALL Register2Read
332:                   CharToFloat(&runingArg.gLP, tmp_alarm);
002B94  78008E     MOV W14, W1
002B96  20BCA0     MOV #0xBCA, W0
002B98  070440     RCALL CharToFloat
333:               }
002B9A  FA8000     ULNK
002B9C  060000     RETURN
334:               
335:               /*************************************
336:               Function: Get_Mi_Ht
337:               Description: 获取高温报警
338:               Input: 
339:               Output: 
340:                *************************************/
341:               static void Get_Mi_Ht(void) {
002B9E  FA0004     LNK #0x4
342:                   u8 tmp_alarm[4];
343:                   Register2Read(tmp_alarm, mi_arg_add[mi_ht_alarm], 4);
002BA0  8470C1     MOV 0x8E18, W1
002BA2  B3C042     MOV.B #0x4, W2
002BA4  78000E     MOV W14, W0
002BA6  07FF29     RCALL Register2Read
344:                   CharToFloat(&runingArg.gHT, tmp_alarm);
002BA8  78008E     MOV W14, W1
002BAA  20BCE0     MOV #0xBCE, W0
002BAC  070436     RCALL CharToFloat
345:               }
002BAE  FA8000     ULNK
002BB0  060000     RETURN
346:               
347:               /*************************************
348:               Function: Get_Mi_Lt
349:               Description: 获取低温参数
350:               Input: 
351:               Output: 
352:                *************************************/
353:               static void Get_Mi_Lt(void) {
002BB2  FA0004     LNK #0x4
354:                   u8 tmp_alarm[4];
355:                   Register2Read(tmp_alarm, mi_arg_add[mi_lt_alarm], 4);
002BB4  8470D1     MOV 0x8E1A, W1
002BB6  B3C042     MOV.B #0x4, W2
002BB8  78000E     MOV W14, W0
002BBA  07FF1F     RCALL Register2Read
356:                   CharToFloat(&runingArg.gLT, tmp_alarm);
002BBC  78008E     MOV W14, W1
002BBE  20BD20     MOV #0xBD2, W0
002BC0  07042C     RCALL CharToFloat
357:               }
002BC2  FA8000     ULNK
002BC4  060000     RETURN
358:               
359:               static void Get_Mi_Ofst(void) {
002BC6  FA0004     LNK #0x4
360:                   u8 tmp_ofst[4]; // cnt = 0;
361:                   Register2Read(tmp_ofst, mi_arg_add[mi_ofst], 4);
002BC8  8470E1     MOV 0x8E1C, W1
002BCA  B3C042     MOV.B #0x4, W2
002BCC  78000E     MOV W14, W0
002BCE  07FF15     RCALL Register2Read
362:                   //    for(cnt=0;cnt<4;cnt++)
363:                   runingArg.gOfst = tmp_ofst[3]+((u16) tmp_ofst[2] << 8)+((u32) tmp_ofst[1] << 16)+((u32) tmp_ofst[0] << 24);
002BD0  90403E     MOV.B [W14+3], W0
002BD2  FB8080     ZE W0, W1
002BD4  90402E     MOV.B [W14+2], W0
002BD6  FB8000     ZE W0, W0
002BD8  DD0048     SL W0, #8, W0
002BDA  408000     ADD W1, W0, W0
002BDC  B80161     MUL.UU W0, #1, W2
002BDE  90401E     MOV.B [W14+1], W0
002BE0  FB8000     ZE W0, W0
002BE2  200001     MOV #0x0, W1
002BE4  DD00C0     SL W0, #0, W1
002BE6  200000     MOV #0x0, W0
002BE8  400102     ADD W0, W2, W2
002BEA  488183     ADDC W1, W3, W3
002BEC  78401E     MOV.B [W14], W0
002BEE  FB8000     ZE W0, W0
002BF0  200001     MOV #0x0, W1
002BF2  DD00C8     SL W0, #8, W1
002BF4  200000     MOV #0x0, W0
002BF6  400002     ADD W0, W2, W0
002BF8  488083     ADDC W1, W3, W1
002BFA  885EB0     MOV W0, 0xBD6
002BFC  885EC1     MOV W1, 0xBD8
364:                   gPulseCount += runingArg.gOfst;
002BFE  805EB2     MOV 0xBD6, W2
002C00  805EC3     MOV 0xBD8, W3
002C02  805CE0     MOV 0xB9C, W0
002C04  805CF1     MOV 0xB9E, W1
002C06  400002     ADD W0, W2, W0
002C08  488083     ADDC W1, W3, W1
002C0A  885CE0     MOV W0, 0xB9C
002C0C  885CF1     MOV W1, 0xB9E
365:               }
002C0E  FA8000     ULNK
002C10  060000     RETURN
366:               
367:               /*************************************
368:               Function: RefreshDaZong
369:               Description: 大众协议返回参数刷新参数
370:               Input: 
371:               Output: 
372:                *************************************/
373:               void RefreshDaZong(void) {
002C12  FA0000     LNK #0x0
374:                   Get_Mi_Tmp();
002C14  07FF67     RCALL _Get_Mi_Tmp
375:                   Get_Mi_Tgprs();
002C16  07FF58     RCALL _Get_Mi_Tgprs
376:                   Get_Mi_Talarm();
002C18  07FF73     RCALL _Get_Mi_Talarm
377:                   Get_Mi_Hp();
002C1A  07FFAD     RCALL _Get_Mi_Hp
378:                   Get_Mi_Lp();
002C1C  07FFB6     RCALL _Get_Mi_Lp
379:                   Get_Mi_Ht();
002C1E  07FFBF     RCALL _Get_Mi_Ht
380:                   Get_Mi_Lt();
002C20  07FFC8     RCALL _Get_Mi_Lt
381:               }
002C22  FA8000     ULNK
002C24  060000     RETURN
382:               
383:               /*************************************
384:               Function: RefreshTime
385:               Description: 刷新内部时间
386:               Input: 
387:               Output: 
388:                *************************************/
389:               void RefreshTime(void) {
002C26  FA0000     LNK #0x0
390:                   Get_Mi_Year();
002C28  07FF25     RCALL _Get_Mi_Year
391:                   Get_Mi_Month();
002C2A  07FF2B     RCALL _Get_Mi_Month
392:                   Get_Mi_Day();
002C2C  07FF31     RCALL _Get_Mi_Day
393:                   Get_Mi_Hour();
002C2E  07FF37     RCALL _Get_Mi_Hour
394:                   Get_Mi_Min();
002C30  07FF3D     RCALL _Get_Mi_Min
395:                   Get_Mi_Sec();
002C32  07FF43     RCALL _Get_Mi_Sec
396:               }
002C34  FA8000     ULNK
002C36  060000     RETURN
397:               
398:               /*************************************
399:               Function: RefreshAllArg
400:               Description: 刷新s所有参数
401:               Input: 
402:               Output: 
403:                *************************************/
404:               void RefreshAllArg(void) {
002C38  FA0000     LNK #0x0
405:                   Get_Mi_Add();
002C3A  07FF00     RCALL _Get_Mi_Add
406:                   Get_Mi_Id();
002C3C  07FF06     RCALL _Get_Mi_Id
407:                   Get_Mp_Add();
002C3E  07FF0C     RCALL _Get_Mp_Add
408:                   Get_Mp_Id();
002C40  07FF12     RCALL _Get_Mp_Id
409:                   Get_Mi_Year();
002C42  07FF18     RCALL _Get_Mi_Year
410:                   Get_Mi_Month();
002C44  07FF1E     RCALL _Get_Mi_Month
411:                   Get_Mi_Day();
002C46  07FF24     RCALL _Get_Mi_Day
412:                   Get_Mi_Hour();
002C48  07FF2A     RCALL _Get_Mi_Hour
413:                   Get_Mi_Min();
002C4A  07FF30     RCALL _Get_Mi_Min
414:                   Get_Mi_Sec();
002C4C  07FF36     RCALL _Get_Mi_Sec
415:                   Get_Mi_Tmp();
002C4E  07FF4A     RCALL _Get_Mi_Tmp
416:                   Get_Mi_Tgprs();
002C50  07FF3B     RCALL _Get_Mi_Tgprs
417:                   Get_Mi_Talarm();
002C52  07FF56     RCALL _Get_Mi_Talarm
418:                   Get_Mi_Sp();
002C54  07FF63     RCALL _Get_Mi_Sp
419:                   Get_Mi_Arg1();
002C56  07FF69     RCALL _Get_Mi_Arg1
420:                   Get_Mi_Arg2();
002C58  07FF74     RCALL _Get_Mi_Arg2
421:                   Get_Mi_Mode();
002C5A  07FF7F     RCALL _Get_Mi_Mode
422:                   /*Get_Mi_Gprs_Mode();*/Get_Mi_Mp_Po();
002C5C  07FF85     RCALL _Get_Mi_Mp_Po
423:                   Get_Mi_Hp();
002C5E  07FF8B     RCALL _Get_Mi_Hp
424:                   Get_Mi_Lp();
002C60  07FF94     RCALL _Get_Mi_Lp
425:                   Get_Mi_Ht();
002C62  07FF9D     RCALL _Get_Mi_Ht
426:                   Get_Mi_Lt();
002C64  07FFA6     RCALL _Get_Mi_Lt
427:                   Get_Mi_Ofst();
002C66  07FFAF     RCALL _Get_Mi_Ofst
428:               }
002C68  FA8000     ULNK
002C6A  060000     RETURN
429:               
430:               void GetArgForTest(void) {
002C6C  FA0036     LNK #0x36
431:                   u8 *ptr = Register2;
002C6E  20BDB0     MOV #0xBDB, W0
002C70  980710     MOV W0, [W14+2]
432:                   u8 ReceiveBuffer[50];
433:                   u8 *tempValue = (u8*) (&gAlarmCount);
002C72  20C3A0     MOV #0xC3A, W0
002C74  780F00     MOV W0, [W14]
434:                   OpenRS485();
002C76  07065B     RCALL OpenRS485
435:                   RS485Send(runingArg.gMi_add);
002C78  BFCBA2     MOV.B runingArg, WREG
002C7A  070630     RCALL RS485Send
436:                   RS485Send(0x04);
002C7C  B3C040     MOV.B #0x4, W0
002C7E  07062E     RCALL RS485Send
437:                   RS485Send(0x32);
002C80  B3C320     MOV.B #0x32, W0
002C82  07062C     RCALL RS485Send
438:                   RS485SendString(ptr, 50);
002C84  B3C321     MOV.B #0x32, W1
002C86  90001E     MOV [W14+2], W0
002C88  070637     RCALL RS485SendString
439:                   RS485Send(runingArg.gMi_add);
002C8A  BFCBA2     MOV.B runingArg, WREG
002C8C  070627     RCALL RS485Send
440:                   RS485Send(0x03);
002C8E  B3C030     MOV.B #0x3, W0
002C90  070625     RCALL RS485Send
441:                   RS485Send(0x01);
002C92  B3C010     MOV.B #0x1, W0
002C94  070623     RCALL RS485Send
442:                   FM25L64B_Read((gOffsetAdd + 143) % 144 * REG_DATA_SECTION, ReceiveBuffer, REG_DATA_SECTION); //0-41
002C96  BFCC32     MOV.B 0xC32, WREG
002C98  FB8000     ZE W0, W0
002C9A  B008F0     ADD #0x8F, W0
002C9C  200902     MOV #0x90, W2
002C9E  090011     REPEAT #0x11
002CA0  D80002     DIV.SW W0, W2
002CA2  FD0080     EXCH W0, W1
002CA4  780080     MOV W0, W1
002CA6  2002A0     MOV #0x2A, W0
002CA8  B98800     MUL.SS W1, W0, W0
002CAA  4700E4     ADD W14, #0x4, W1
002CAC  B3C2A2     MOV.B #0x2A, W2
002CAE  07033D     RCALL FM25L64B_Read
443:                   ReceiveBuffer[42] = *(tempValue + 3);
002CB0  78009E     MOV [W14], W1
002CB2  408063     ADD W1, #0x3, W0
002CB4  784090     MOV.B [W0], W1
002CB6  470064     ADD W14, #0x4, W0
002CB8  986821     MOV.B W1, [W0+42]
444:                   ReceiveBuffer[43] = *(tempValue + 2);
002CBA  E8801E     INC2 [W14], W0
002CBC  784090     MOV.B [W0], W1
002CBE  470064     ADD W14, #0x4, W0
002CC0  986831     MOV.B W1, [W0+43]
445:                   ReceiveBuffer[44] = *(tempValue + 1);
002CC2  E8001E     INC [W14], W0
002CC4  784090     MOV.B [W0], W1
002CC6  470064     ADD W14, #0x4, W0
002CC8  986841     MOV.B W1, [W0+44]
446:                   ReceiveBuffer[45] = *tempValue;
002CCA  78001E     MOV [W14], W0
002CCC  784090     MOV.B [W0], W1
002CCE  470064     ADD W14, #0x4, W0
002CD0  986851     MOV.B W1, [W0+45]
447:                   RS485SendString(ReceiveBuffer, REG_DATA_SECTION + 4);
002CD2  470064     ADD W14, #0x4, W0
002CD4  B3C2E1     MOV.B #0x2E, W1
002CD6  070610     RCALL RS485SendString
448:                   CloseRS485();
002CD8  07062F     RCALL CloseRS485
449:               }
002CDA  FA8000     ULNK
002CDC  060000     RETURN
450:               
451:               /*关于寄存器1的操作*/
452:               bool EnRegister1(u8 * ptr_dat) {
002CDE  FA0004     LNK #0x4
002CE0  980710     MOV W0, [W14+2]
453:                   u8 cnt_Reg1 = gCnt_Reg1; //把可用的通道记录下来
002CE2  BFCBDA     MOV.B 0xBDA, WREG
002CE4  984710     MOV.B W0, [W14+1]
454:                   u8 cnt_For;
455:               
456:                   for (cnt_For = 0; cnt_For < 19; cnt_For++)
002CE6  EB4000     CLR.B W0
002CE8  784F00     MOV.B W0, [W14]
002CEA  37000E     BRA 0x2D08
002D06  E84F1E     INC.B [W14], [W14]
002D08  B3C120     MOV.B #0x12, W0
002D0A  104F9E     SUBR.B W0, [W14], [W15]
002D0C  36FFEF     BRA LEU, 0x2CEC
457:                       Register1[cnt_Reg1][cnt_For] = *(ptr_dat + cnt_For);
002CEC  90401E     MOV.B [W14+1], W0
002CEE  FB8100     ZE W0, W2
002CF0  FB819E     ZE [W14], W3
002CF2  FB801E     ZE [W14], W0
002CF4  780080     MOV W0, W1
002CF6  90001E     MOV [W14+2], W0
002CF8  408000     ADD W1, W0, W0
002CFA  784210     MOV.B [W0], W4
002CFC  B91073     MUL.SU W2, #19, W0
002CFE  400083     ADD W0, W3, W1
002D00  20A040     MOV #0xA04, W0
002D02  408000     ADD W1, W0, W0
002D04  784804     MOV.B W4, [W0]
458:                   gCnt_Reg1 = cnt_Reg1 - ((cnt_Reg1 >> 4) << 4) + 1; //cnt_Reg1取16的余数+1
002D0E  90409E     MOV.B [W14+1], W1
002D10  90401E     MOV.B [W14+1], W0
002D12  FB8000     ZE W0, W0
002D14  DE0044     LSR W0, #4, W0
002D16  FB8000     ZE W0, W0
002D18  DD0044     SL W0, #4, W0
002D1A  50C000     SUB.B W1, W0, W0
002D1C  E84000     INC.B W0, W0
002D1E  B7EBDA     MOV.B WREG, 0xBDA
459:                   return true;
002D20  200010     MOV #0x1, W0
460:               }
002D22  FA8000     ULNK
002D24  060000     RETURN
461:               
462:               void GetRegister1(u8 *ptr_dat, u8 reg_cnt) {
002D26  FA0006     LNK #0x6
002D28  980710     MOV W0, [W14+2]
002D2A  984741     MOV.B W1, [W14+4]
463:                   u8 cnt_For;
464:                   for (cnt_For = 0; cnt_For < 19; cnt_For++)
002D2C  EB4000     CLR.B W0
002D2E  784F00     MOV.B W0, [W14]
002D30  37000E     BRA 0x2D4E
002D4C  E84F1E     INC.B [W14], [W14]
002D4E  B3C120     MOV.B #0x12, W0
002D50  104F9E     SUBR.B W0, [W14], [W15]
002D52  36FFEF     BRA LEU, 0x2D32
465:                       *(ptr_dat + cnt_For) = Register1[reg_cnt][cnt_For];
002D32  FB801E     ZE [W14], W0
002D34  780080     MOV W0, W1
002D36  90001E     MOV [W14+2], W0
002D38  408180     ADD W1, W0, W3
002D3A  90404E     MOV.B [W14+4], W0
002D3C  FB8000     ZE W0, W0
002D3E  FB811E     ZE [W14], W2
002D40  B90073     MUL.SU W0, #19, W0
002D42  400082     ADD W0, W2, W1
002D44  20A040     MOV #0xA04, W0
002D46  408000     ADD W1, W0, W0
002D48  784010     MOV.B [W0], W0
002D4A  784980     MOV.B W0, [W3]
466:               }
002D54  FA8000     ULNK
002D56  060000     RETURN
467:               
468:               void EmptyRegister1(void) {
002D58  FA0002     LNK #0x2
469:                   u8 cnt_For, cnt_Reg;
470:                   for (cnt_Reg = 0; cnt_Reg < REG1_MAX_CNT; cnt_Reg++)
002D5A  EB4000     CLR.B W0
002D5C  784F00     MOV.B W0, [W14]
002D5E  370013     BRA 0x2D86
002D84  E84F1E     INC.B [W14], [W14]
002D86  B3C0F0     MOV.B #0xF, W0
002D88  104F9E     SUBR.B W0, [W14], [W15]
002D8A  36FFEA     BRA LEU, 0x2D60
471:                       for (cnt_For = 0; cnt_For < 19; cnt_For++)
002D60  EB4000     CLR.B W0
002D62  984710     MOV.B W0, [W14+1]
002D64  37000C     BRA 0x2D7E
002D78  90401E     MOV.B [W14+1], W0
002D7A  E84000     INC.B W0, W0
002D7C  984710     MOV.B W0, [W14+1]
002D7E  90401E     MOV.B [W14+1], W0
002D80  504FF2     SUB.B W0, #0x12, [W15]
002D82  36FFF1     BRA LEU, 0x2D66
472:                           Register1[cnt_Reg][cnt_For] = 0;
002D66  FB809E     ZE [W14], W1
002D68  90401E     MOV.B [W14+1], W0
002D6A  FB8100     ZE W0, W2
002D6C  B90873     MUL.SU W1, #19, W0
002D6E  400082     ADD W0, W2, W1
002D70  20A040     MOV #0xA04, W0
002D72  408080     ADD W1, W0, W1
002D74  EB4000     CLR.B W0
002D76  784880     MOV.B W0, [W1]
473:               
474:                   gCnt_Reg1 = 0; //cnt_Reg1 - ((cnt_Reg1 >> 4) << 4);
002D8C  EB4000     CLR.B W0
002D8E  B7EBDA     MOV.B WREG, 0xBDA
475:               }
002D90  FA8000     ULNK
002D92  060000     RETURN
476:               
477:               
478:               
479:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/MP.c  ------------------------------
1:                 #include "user.h"
2:                 #include "RS485.h"
3:                 #include "UART.h"
4:                 #include "Protocal.h"
5:                 #include "CheckData.h"
6:                 #include "TIM.h"
7:                 #include "Mp.h"
8:                 #include "P-Miot1601.h"
9:                 #include "SerialBuffer.h"
10:                #include "math.h"
11:                #include "Miot1601.h"
12:                #include "Common.h"
13:                #include "Queue.h"
14:                
15:                #define PULSE_MAX 100000000 
16:                extern QUEUE line; //创建队列
17:                /*********************************模块与PC通讯的参数**********************************/
18:                vu32 gNowCapture = 0; //输入捕获数据2
19:                vu32 gPulseCount = 0; //脉冲累加量
20:                u8 gAlarmVoltageAdd;
21:                u8 gOverFlag = 0;
22:                /**********************************模块和设备通讯的参数****************************/
23:                
24:                
25:                
26:                /*********************************函数声明**********************************/
27:                //static bool MpReceiveDataIsRight(FP_CRC fp, u8 Head, u8 t_100ms, u8 bytes);
28:                static void SendMp(u8 protocals);
29:                static void V12ToNum(u8 *dat, u8 Bytes);
30:                static void V12ToChar(u8* dat, u8* ch);
31:                static float V13ToFloat(u8* dat);
32:                static float A1ToFloat(u8 * dat, u8 bytes);
33:                static void BPasteA(u8* A, u8* B, u8 bytes);
34:                
35:                
36:                
37:                //static void Protocal12(void);
38:                //static void Protocal13(void);
39:                //static void ProtocalModbusA1(void);
40:                //static void ProtocalModbusA2(void);
41:                //static void ProtocalModbusA3(void);
42:                
43:                
44:                //bool SerialDataIsGet(u8 *dat,u8 head,u8 time);
45:                
46:                /*************************************
47:                Function: ClrData 
48:                Description: 清除数据
49:                Input: dat：数据地址 bytes：字节数
50:                Output: 无
51:                 *************************************/
52:                void ClrData(u8 *dat, u8 bytes) {
000E76  FA0006     LNK #0x6
000E78  980710     MOV W0, [W14+2]
000E7A  984741     MOV.B W1, [W14+4]
53:                    u8 count = 0;
000E7C  EB4000     CLR.B W0
000E7E  784F00     MOV.B W0, [W14]
54:                
55:                    while (count < bytes) {
000E80  370007     BRA 0xE90
000E90  90404E     MOV.B [W14+4], W0
000E92  104F9E     SUBR.B W0, [W14], [W15]
000E94  39FFF6     BRA NC, 0xE82
56:                        *(dat + count) = 0;
000E82  FB801E     ZE [W14], W0
000E84  780080     MOV W0, W1
000E86  90001E     MOV [W14+2], W0
000E88  408080     ADD W1, W0, W1
000E8A  EB4000     CLR.B W0
000E8C  784880     MOV.B W0, [W1]
57:                        count++;
000E8E  E84F1E     INC.B [W14], [W14]
58:                    }
59:                }
000E96  FA8000     ULNK
000E98  060000     RETURN
60:                
61:                /*************************************
62:                Function: V12ToNum 
63:                Description: -30 并且合并字节
64:                Input: 数据  字节数
65:                Output: 无
66:                 *************************************/
67:                static void V12ToNum(u8 *dat, u8 Bytes)//test OK
68:                { //如i:0x32 35 o:25  
000E9A  FA0006     LNK #0x6
000E9C  980710     MOV W0, [W14+2]
000E9E  984741     MOV.B W1, [W14+4]
69:                    //  35 05 37 07 3B 0B 3B 0B 3D 0D 30 00 30 00 
70:                    u8 count;
71:                    for (count = 0; count < Bytes; count++) {
000EA0  EB4000     CLR.B W0
000EA2  784F00     MOV.B W0, [W14]
000EA4  37000E     BRA 0xEC2
000EC0  E84F1E     INC.B [W14], [W14]
000EC2  90404E     MOV.B [W14+4], W0
000EC4  104F9E     SUBR.B W0, [W14], [W15]
000EC6  39FFEF     BRA NC, 0xEA6
72:                        //        UART2Send(*(dat+count));
73:                        *(dat + count) = TONUM(*(dat + count));
000EA6  FB801E     ZE [W14], W0
000EA8  780080     MOV W0, W1
000EAA  90001E     MOV [W14+2], W0
000EAC  408100     ADD W1, W0, W2
000EAE  FB801E     ZE [W14], W0
000EB0  780080     MOV W0, W1
000EB2  90001E     MOV [W14+2], W0
000EB4  408000     ADD W1, W0, W0
000EB6  784010     MOV.B [W0], W0
000EB8  784080     MOV.B W0, W1
000EBA  B3CD00     MOV.B #0xD0, W0
000EBC  40C000     ADD.B W1, W0, W0
000EBE  784900     MOV.B W0, [W2]
74:                        //        UART2Send(*(dat+count));
75:                    }
76:                }
000EC8  FA8000     ULNK
000ECA  060000     RETURN
77:                
78:                /*************************************
79:                Function: ToChar 
80:                Description: V1.2转化为浮点数
81:                Input: 4个u16类型数据 
82:                Output: 浮点数
83:                 *************************************/
84:                static void V12ToChar(u8* dat, u8* ch) //legnth 6  or 4
85:                {//如 1 2 3 4 5 6 7 8 =12 34 56 78     
000ECC  FA0004     LNK #0x4
000ECE  780F00     MOV W0, [W14]
000ED0  980711     MOV W1, [W14+2]
86:                    //获得处理后的数字
87:                    *ch = (*dat << 4)+*(dat + 1);
000ED2  78001E     MOV [W14], W0
000ED4  784010     MOV.B [W0], W0
000ED6  FB8000     ZE W0, W0
000ED8  DD0044     SL W0, #4, W0
000EDA  784080     MOV.B W0, W1
000EDC  E8001E     INC [W14], W0
000EDE  784010     MOV.B [W0], W0
000EE0  40C000     ADD.B W1, W0, W0
000EE2  784080     MOV.B W0, W1
000EE4  90001E     MOV [W14+2], W0
000EE6  784801     MOV.B W1, [W0]
88:                    *(ch + 1) = (*(dat + 2) << 4)+*(dat + 3);
000EE8  90001E     MOV [W14+2], W0
000EEA  E80100     INC W0, W2
000EEC  E8801E     INC2 [W14], W0
000EEE  784010     MOV.B [W0], W0
000EF0  FB8000     ZE W0, W0
000EF2  DD0044     SL W0, #4, W0
000EF4  784080     MOV.B W0, W1
000EF6  78019E     MOV [W14], W3
000EF8  418063     ADD W3, #0x3, W0
000EFA  784010     MOV.B [W0], W0
000EFC  40C000     ADD.B W1, W0, W0
000EFE  784900     MOV.B W0, [W2]
89:                    *(ch + 2) = (*(dat + 4) << 4)+*(dat + 5);
000F00  90001E     MOV [W14+2], W0
000F02  E88100     INC2 W0, W2
000F04  78009E     MOV [W14], W1
000F06  408064     ADD W1, #0x4, W0
000F08  784010     MOV.B [W0], W0
000F0A  FB8000     ZE W0, W0
000F0C  DD0044     SL W0, #4, W0
000F0E  784080     MOV.B W0, W1
000F10  78019E     MOV [W14], W3
000F12  418065     ADD W3, #0x5, W0
000F14  784010     MOV.B [W0], W0
000F16  40C000     ADD.B W1, W0, W0
000F18  784900     MOV.B W0, [W2]
90:                    *(ch + 3) = (*(dat + 6) << 4)+*(dat + 7);
000F1A  90001E     MOV [W14+2], W0
000F1C  400163     ADD W0, #0x3, W2
000F1E  78009E     MOV [W14], W1
000F20  408066     ADD W1, #0x6, W0
000F22  784010     MOV.B [W0], W0
000F24  FB8000     ZE W0, W0
000F26  DD0044     SL W0, #4, W0
000F28  784080     MOV.B W0, W1
000F2A  78019E     MOV [W14], W3
000F2C  418067     ADD W3, #0x7, W0
000F2E  784010     MOV.B [W0], W0
000F30  40C000     ADD.B W1, W0, W0
000F32  784900     MOV.B W0, [W2]
91:                }
000F34  FA8000     ULNK
000F36  060000     RETURN
92:                
93:                /*************************************
94:                Function: ToFloat 
95:                Description: 天信V1.3数据处理
96:                Input: 4个u16类型数据 
97:                Output: 浮点数
98:                Eg：12 34 56 78--浮点数
99:                 *************************************/
100:               static float V13ToFloat(u8 *dat) {
000F38  FA000E     LNK #0xE
000F3A  781F88     MOV W8, [W15++]
000F3C  980740     MOV W0, [W14+8]
101:                   long temp = (long) (*(dat + 1) *65536 | *(dat + 2) << 8 | *(dat + 3));
000F3E  90004E     MOV [W14+8], W0
000F40  E80000     INC W0, W0
000F42  784010     MOV.B [W0], W0
000F44  FB8000     ZE W0, W0
000F46  200001     MOV #0x0, W1
000F48  DD01C0     SL W0, #0, W3
000F4A  200002     MOV #0x0, W2
000F4C  90004E     MOV [W14+8], W0
000F4E  E88000     INC2 W0, W0
000F50  784010     MOV.B [W0], W0
000F52  FB8000     ZE W0, W0
000F54  DD0048     SL W0, #8, W0
000F56  DE80CF     ASR W0, #15, W1
000F58  710100     IOR W2, W0, W2
000F5A  718181     IOR W3, W1, W3
000F5C  90004E     MOV [W14+8], W0
000F5E  400063     ADD W0, #0x3, W0
000F60  784010     MOV.B [W0], W0
000F62  FB8000     ZE W0, W0
000F64  200001     MOV #0x0, W1
000F66  710000     IOR W2, W0, W0
000F68  718081     IOR W3, W1, W1
000F6A  980720     MOV W0, [W14+4]
000F6C  980731     MOV W1, [W14+6]
102:                   float f;
103:               
104:                   f = 1.0 * temp / 8388608;
000F6E  90002E     MOV [W14+4], W0
000F70  9000BE     MOV [W14+6], W1
000F72  07FA32     RCALL ___floatsisf
000F74  200002     MOV #0x0, W2
000F76  24B003     MOV #0x4B00, W3
000F78  07F9ED     RCALL ___divsf3
000F7A  BE8F00     MOV.D W0, [W14]
105:               
106:                   if (!(*dat & 0X80)) //判断阶数最高位是否为1
000F7C  90004E     MOV [W14+8], W0
000F7E  784010     MOV.B [W0], W0
000F80  E00400     CP0.B W0
000F82  35001A     BRA LT, 0xFB8
107:                       f *= 1.0 * pow(2, *dat);
000F84  90004E     MOV [W14+8], W0
000F86  784410     MOV.B [W0], W8
000F88  FB0008     SE W8, W0
000F8A  DE80CF     ASR W0, #15, W1
000F8C  07FA25     RCALL ___floatsisf
000F8E  980750     MOV W0, [W14+10]
000F90  980761     MOV W1, [W14+12]
000F92  E00408     CP0.B W8
000F94  3D0007     BRA GE, 0xFA4
000F96  200002     MOV #0x0, W2
000F98  243803     MOV #0x4380, W3
000F9A  90005E     MOV [W14+10], W0
000F9C  9000EE     MOV [W14+12], W1
000F9E  07F97D     RCALL ___addsf3
000FA0  980750     MOV W0, [W14+10]
000FA2  980761     MOV W1, [W14+12]
000FA4  90015E     MOV [W14+10], W2
000FA6  9001EE     MOV [W14+12], W3
000FA8  200000     MOV #0x0, W0
000FAA  240001     MOV #0x4000, W1
000FAC  07FABA     RCALL _powf
000FAE  BE0100     MOV.D W0, W2
000FB0  BE001E     MOV.D [W14], W0
000FB2  07FA83     RCALL ___mulsf3
000FB4  BE8F00     MOV.D W0, [W14]
000FB6  370012     BRA 0xFDC
108:                   else
109:                       f *= 1.0 / pow(2, ~(*dat - 1)); //负数表示 1.0/a
000FB8  90004E     MOV [W14+8], W0
000FBA  784010     MOV.B [W0], W0
000FBC  FB8000     ZE W0, W0
000FBE  EA0000     NEG W0, W0
000FC0  DE80CF     ASR W0, #15, W1
000FC2  07FA0A     RCALL ___floatsisf
000FC4  BE0100     MOV.D W0, W2
000FC6  200000     MOV #0x0, W0
000FC8  240001     MOV #0x4000, W1
000FCA  07FAAB     RCALL _powf
000FCC  BE0100     MOV.D W0, W2
000FCE  200000     MOV #0x0, W0
000FD0  23F801     MOV #0x3F80, W1
000FD2  07F9C0     RCALL ___divsf3
000FD4  BE0100     MOV.D W0, W2
000FD6  BE001E     MOV.D [W14], W0
000FD8  07FA70     RCALL ___mulsf3
000FDA  BE8F00     MOV.D W0, [W14]
110:                   return f;
000FDC  BE001E     MOV.D [W14], W0
111:               }
000FDE  78044F     MOV [--W15], W8
000FE0  FA8000     ULNK
000FE2  060000     RETURN
112:               
113:               /*************************************
114:               Function: A1ToFloat 
115:               Description: ModbusA1协议 获取BCD
116:               Input: 无
117:               Output: 无
118:                *************************************/
119:               static float A1ToFloat(u8 * dat, u8 bytes) {
000FE4  FA000C     LNK #0xC
000FE6  BE9F88     MOV.D W8, [W15++]
000FE8  980740     MOV W0, [W14+8]
000FEA  984F21     MOV.B W1, [W14+10]
120:                   float f = 0;
000FEC  B80060     MUL.UU W0, #0, W0
000FEE  980720     MOV W0, [W14+4]
000FF0  980731     MOV W1, [W14+6]
121:                   u8 count = bytes;
000FF2  90482E     MOV.B [W14+10], W0
000FF4  984720     MOV.B W0, [W14+2]
122:                   u8 temp, temp1 = 0;
000FF6  EB4000     CLR.B W0
000FF8  784F00     MOV.B W0, [W14]
123:               
124:                   while (count > 0) {
000FFA  37002F     BRA 0x105A
00105A  90402E     MOV.B [W14+2], W0
00105C  E00400     CP0.B W0
00105E  3AFFCE     BRA NZ, 0xFFC
125:                       temp = *(dat + bytes - count); //BCD处理
000FFC  90482E     MOV.B [W14+10], W0
000FFE  FB8000     ZE W0, W0
001000  780080     MOV W0, W1
001002  90004E     MOV [W14+8], W0
001004  408080     ADD W1, W0, W1
001006  90402E     MOV.B [W14+2], W0
001008  FB8000     ZE W0, W0
00100A  508000     SUB W1, W0, W0
00100C  784090     MOV.B [W0], W1
00100E  984711     MOV.B W1, [W14+1]
126:                       temp1 = temp / 16;
001010  90401E     MOV.B [W14+1], W0
001012  FB8000     ZE W0, W0
001014  DE0044     LSR W0, #4, W0
001016  784F00     MOV.B W0, [W14]
127:                       if (temp1)
001018  E0041E     CP0.B [W14]
00101A  320005     BRA Z, 0x1026
128:                           temp = temp - temp1 * 6;
00101C  90411E     MOV.B [W14+1], W2
00101E  FB801E     ZE [W14], W0
001020  B90066     MUL.SU W0, #6, W0
001022  514000     SUB.B W2, W0, W0
001024  984710     MOV.B W0, [W14+1]
129:               
130:                       f += temp * 1.0 * pow(100, count - 1);
001026  90401E     MOV.B [W14+1], W0
001028  FB8000     ZE W0, W0
00102A  DE80CF     ASR W0, #15, W1
00102C  07F9D5     RCALL ___floatsisf
00102E  BE0400     MOV.D W0, W8
001030  90402E     MOV.B [W14+2], W0
001032  FB8000     ZE W0, W0
001034  E90000     DEC W0, W0
001036  DE80CF     ASR W0, #15, W1
001038  07F9CF     RCALL ___floatsisf
00103A  BE0100     MOV.D W0, W2
00103C  200000     MOV #0x0, W0
00103E  242C81     MOV #0x42C8, W1
001040  07FA70     RCALL _powf
001042  BE0100     MOV.D W0, W2
001044  BE0008     MOV.D W8, W0
001046  07FA39     RCALL ___mulsf3
001048  BE0100     MOV.D W0, W2
00104A  90002E     MOV [W14+4], W0
00104C  9000BE     MOV [W14+6], W1
00104E  07F925     RCALL ___addsf3
001050  980720     MOV W0, [W14+4]
001052  980731     MOV W1, [W14+6]
131:                       count--;
001054  90402E     MOV.B [W14+2], W0
001056  E94000     DEC.B W0, W0
001058  984720     MOV.B W0, [W14+2]
132:                   }
133:               
134:                   f *= 0.01;
001060  90002E     MOV [W14+4], W0
001062  9000BE     MOV [W14+6], W1
001064  2D70A2     MOV #0xD70A, W2
001066  23C233     MOV #0x3C23, W3
001068  07FA28     RCALL ___mulsf3
00106A  980720     MOV W0, [W14+4]
00106C  980731     MOV W1, [W14+6]
135:               
136:                   return f;
00106E  90002E     MOV [W14+4], W0
001070  9000BE     MOV [W14+6], W1
137:               }
001072  BE044F     MOV.D [--W15], W8
001074  FA8000     ULNK
001076  060000     RETURN
138:               
139:               /*************************************
140:               Function: BPasteA
141:               Description: ModbusA2\A3协议 赋值参数
142:               Input: 无
143:               Output: 无
144:                *************************************/
145:               static void BPasteA(u8* A, u8* B, u8 bytes) {
001078  FA0008     LNK #0x8
00107A  980710     MOV W0, [W14+2]
00107C  980721     MOV W1, [W14+4]
00107E  984762     MOV.B W2, [W14+6]
146:                   char count = bytes;
001080  90406E     MOV.B [W14+6], W0
001082  784F00     MOV.B W0, [W14]
147:                   while (count-- >= 0) {
001084  37000A     BRA 0x109A
00109A  EB4000     CLR.B W0
00109C  984770     MOV.B W0, [W14+7]
00109E  E0041E     CP0.B [W14]
0010A0  350002     BRA LT, 0x10A6
0010A2  B3C010     MOV.B #0x1, W0
0010A4  984770     MOV.B W0, [W14+7]
0010A6  E94F1E     DEC.B [W14], [W14]
0010A8  90407E     MOV.B [W14+7], W0
0010AA  E00400     CP0.B W0
0010AC  3AFFEC     BRA NZ, 0x1086
148:                       *(A + count) = *(B + count);
001086  FB001E     SE [W14], W0
001088  780080     MOV W0, W1
00108A  90001E     MOV [W14+2], W0
00108C  408100     ADD W1, W0, W2
00108E  FB001E     SE [W14], W0
001090  780080     MOV W0, W1
001092  90002E     MOV [W14+4], W0
001094  408000     ADD W1, W0, W0
001096  784010     MOV.B [W0], W0
001098  784900     MOV.B W0, [W2]
149:                   }
150:               }
0010AE  FA8000     ULNK
0010B0  060000     RETURN
151:               
152:               /*************************************
153:               Function: PulseIsOver 
154:               Description: 脉冲数是否溢出
155:               Input: 无
156:               Output: 无
157:                *************************************/
158:               static bool PulseIsOver(unsigned long nowPulse) {
0010B2  FA0006     LNK #0x6
0010B4  980710     MOV W0, [W14+2]
0010B6  980721     MOV W1, [W14+4]
159:                   bool b = false;
0010B8  EB4000     CLR.B W0
0010BA  784F00     MOV.B W0, [W14]
160:                   while (nowPulse > PULSE_MAX) {
0010BC  37000A     BRA 0x10D2
0010D2  90011E     MOV [W14+2], W2
0010D4  9001AE     MOV [W14+4], W3
0010D6  2E1000     MOV #0xE100, W0
0010D8  205F51     MOV #0x5F5, W1
0010DA  510F80     SUB W2, W0, [W15]
0010DC  598F81     SUBB W3, W1, [W15]
0010DE  3EFFEF     BRA GTU, 0x10BE
161:                       nowPulse -= PULSE_MAX; //归零
0010BE  90011E     MOV [W14+2], W2
0010C0  9001AE     MOV [W14+4], W3
0010C2  21F000     MOV #0x1F00, W0
0010C4  2FA0A1     MOV #0xFA0A, W1
0010C6  400002     ADD W0, W2, W0
0010C8  488083     ADDC W1, W3, W1
0010CA  980710     MOV W0, [W14+2]
0010CC  980721     MOV W1, [W14+4]
162:                       b = true;
0010CE  B3C010     MOV.B #0x1, W0
0010D0  784F00     MOV.B W0, [W14]
163:                   }
164:                   gPulseCount = nowPulse;
0010E0  90001E     MOV [W14+2], W0
0010E2  9000AE     MOV [W14+4], W1
0010E4  885CE0     MOV W0, 0xB9C
0010E6  885CF1     MOV W1, 0xB9E
165:                   return b;
0010E8  FB801E     ZE [W14], W0
166:               }
0010EA  FA8000     ULNK
0010EC  060000     RETURN
167:               
168:               /*************************************
169:               Function: Get_Q
170:               Description: 获取瞬间量
171:               Input: 无
172:               Output: 无
173:                *************************************/
174:               static float Get_Q(const unsigned long nowPulse) {
0010EE  FA0026     LNK #0x26
0010F0  980710     MOV W0, [W14+2]
0010F2  980721     MOV W1, [W14+4]
175:                   u8 tmp = runingArg.gArg2;
0010F4  BFCBC2     MOV.B 0xBC2, WREG
0010F6  784F00     MOV.B W0, [W14]
176:                   if(!gNowCapture)
0010F8  805CC0     MOV 0xB98, W0
0010FA  805CD1     MOV 0xB9A, W1
0010FC  500FE0     SUB W0, #0x0, [W15]
0010FE  588FE0     SUBB W1, #0x0, [W15]
001100  3A0004     BRA NZ, 0x110A
177:                       return 0;
001102  B80060     MUL.UU W0, #0, W0
001104  981710     MOV W0, [W14+34]
001106  981721     MOV W1, [W14+36]
001108  37007B     BRA 0x1200
178:                   if (nowPulse < 2) {
00110A  90011E     MOV [W14+2], W2
00110C  9001AE     MOV [W14+4], W3
00110E  200010     MOV #0x1, W0
001110  200001     MOV #0x0, W1
001112  510F80     SUB W2, W0, [W15]
001114  598F81     SUBB W3, W1, [W15]
001116  3E0040     BRA GTU, 0x1198
179:                       return (gOverFlag) ? (1.0 * tmp * 2880 / gNowCapture) : 0;
001118  BFCBA0     MOV.B 0xBA0, WREG
00111A  E00400     CP0.B W0
00111C  320035     BRA Z, 0x1188
00111E  FB801E     ZE [W14], W0
001120  DE80CF     ASR W0, #15, W1
001122  07F95A     RCALL ___floatsisf
001124  200002     MOV #0x0, W2
001126  245343     MOV #0x4534, W3
001128  07F9C8     RCALL ___mulsf3
00112A  980F50     MOV W0, [W14+26]
00112C  980F61     MOV W1, [W14+28]
00112E  805CC4     MOV 0xB98, W4
001130  805CD5     MOV 0xB9A, W5
001132  980F34     MOV W4, [W14+22]
001134  980F45     MOV W5, [W14+24]
001136  90083E     MOV [W14+22], W0
001138  9008CE     MOV [W14+24], W1
00113A  500FE0     SUB W0, #0x0, [W15]
00113C  588FE0     SUBB W1, #0x0, [W15]
00113E  350006     BRA LT, 0x114C
001140  90083E     MOV [W14+22], W0
001142  9008CE     MOV [W14+24], W1
001144  07F949     RCALL ___floatsisf
001146  980F10     MOV W0, [W14+18]
001148  980F21     MOV W1, [W14+20]
00114A  370016     BRA 0x1178
00114C  90083E     MOV [W14+22], W0
00114E  600161     AND W0, #0x1, W2
001150  B80060     MUL.UU W0, #0, W0
001152  200003     MOV #0x0, W3
001154  700002     IOR W0, W2, W0
001156  708083     IOR W1, W3, W1
001158  900A3E     MOV [W14+22], W4
00115A  900ACE     MOV [W14+24], W5
00115C  D10185     LSR W5, W3
00115E  D38104     RRC W4, W2
001160  700002     IOR W0, W2, W0
001162  708083     IOR W1, W3, W1
001164  07F939     RCALL ___floatsisf
001166  980F10     MOV W0, [W14+18]
001168  980F21     MOV W1, [W14+20]
00116A  90091E     MOV [W14+18], W2
00116C  9009AE     MOV [W14+20], W3
00116E  90081E     MOV [W14+18], W0
001170  9008AE     MOV [W14+20], W1
001172  07F893     RCALL ___addsf3
001174  980F10     MOV W0, [W14+18]
001176  980F21     MOV W1, [W14+20]
001178  90091E     MOV [W14+18], W2
00117A  9009AE     MOV [W14+20], W3
00117C  90085E     MOV [W14+26], W0
00117E  9008EE     MOV [W14+28], W1
001180  07F8E9     RCALL ___divsf3
001182  980F70     MOV W0, [W14+30]
001184  981701     MOV W1, [W14+32]
001186  370003     BRA 0x118E
001188  B80060     MUL.UU W0, #0, W0
00118A  980F70     MOV W0, [W14+30]
00118C  981701     MOV W1, [W14+32]
00118E  900A7E     MOV [W14+30], W4
001190  90128E     MOV [W14+32], W5
001192  981714     MOV W4, [W14+34]
001194  981725     MOV W5, [W14+36]
001196  370034     BRA 0x1200
180:                   } else {
181:                       return 1.0 * tmp * 2880 / gNowCapture;
001198  FB801E     ZE [W14], W0
00119A  DE80CF     ASR W0, #15, W1
00119C  07F91D     RCALL ___floatsisf
00119E  200002     MOV #0x0, W2
0011A0  245343     MOV #0x4534, W3
0011A2  07F98B     RCALL ___mulsf3
0011A4  980770     MOV W0, [W14+14]
0011A6  980F01     MOV W1, [W14+16]
0011A8  805CC0     MOV 0xB98, W0
0011AA  805CD1     MOV 0xB9A, W1
0011AC  980750     MOV W0, [W14+10]
0011AE  980761     MOV W1, [W14+12]
0011B0  90025E     MOV [W14+10], W4
0011B2  9002EE     MOV [W14+12], W5
0011B4  520FE0     SUB W4, #0x0, [W15]
0011B6  5A8FE0     SUBB W5, #0x0, [W15]
0011B8  350006     BRA LT, 0x11C6
0011BA  90005E     MOV [W14+10], W0
0011BC  9000EE     MOV [W14+12], W1
0011BE  07F90C     RCALL ___floatsisf
0011C0  980730     MOV W0, [W14+6]
0011C2  980741     MOV W1, [W14+8]
0011C4  370016     BRA 0x11F2
0011C6  90005E     MOV [W14+10], W0
0011C8  600161     AND W0, #0x1, W2
0011CA  B80060     MUL.UU W0, #0, W0
0011CC  200003     MOV #0x0, W3
0011CE  700002     IOR W0, W2, W0
0011D0  708083     IOR W1, W3, W1
0011D2  90025E     MOV [W14+10], W4
0011D4  9002EE     MOV [W14+12], W5
0011D6  D10185     LSR W5, W3
0011D8  D38104     RRC W4, W2
0011DA  700002     IOR W0, W2, W0
0011DC  708083     IOR W1, W3, W1
0011DE  07F8FC     RCALL ___floatsisf
0011E0  980730     MOV W0, [W14+6]
0011E2  980741     MOV W1, [W14+8]
0011E4  90013E     MOV [W14+6], W2
0011E6  9001CE     MOV [W14+8], W3
0011E8  90003E     MOV [W14+6], W0
0011EA  9000CE     MOV [W14+8], W1
0011EC  07F856     RCALL ___addsf3
0011EE  980730     MOV W0, [W14+6]
0011F0  980741     MOV W1, [W14+8]
0011F2  90013E     MOV [W14+6], W2
0011F4  9001CE     MOV [W14+8], W3
0011F6  90007E     MOV [W14+14], W0
0011F8  90088E     MOV [W14+16], W1
0011FA  07F8AC     RCALL ___divsf3
0011FC  981710     MOV W0, [W14+34]
0011FE  981721     MOV W1, [W14+36]
001200  90101E     MOV [W14+34], W0
001202  9010AE     MOV [W14+36], W1
182:                   }
183:                   
184:               }
001204  FA8000     ULNK
001206  060000     RETURN
185:               
186:               /*************************************
187:               Function: Get_V 
188:               Description: 获取总量
189:               Input: 无
190:               Output: 无
191:                *************************************/
192:               static void Get_V(const unsigned long nowPulse, float*tmp) {
001208  FA003E     LNK #0x3E
00120A  BE8F00     MOV.D W0, [W14]
00120C  980722     MOV W2, [W14+4]
193:                   //float tmp[2];
194:                   if (nowPulse)
00120E  BE001E     MOV.D [W14], W0
001210  500FE0     SUB W0, #0x0, [W15]
001212  588FE0     SUBB W1, #0x0, [W15]
001214  320128     BRA Z, 0x1466
195:                       switch (runingArg.gArg2) {
001216  BFCBC2     MOV.B 0xBC2, WREG
001218  FB8000     ZE W0, W0
00121A  981F60     MOV W0, [W14+60]
00121C  90186E     MOV [W14+60], W0
00121E  500FEA     SUB W0, #0xA, [W15]
001220  320066     BRA Z, 0x12EE
001222  200640     MOV #0x64, W0
001224  9018EE     MOV [W14+60], W1
001226  508F80     SUB W1, W0, [W15]
001228  3200C0     BRA Z, 0x13AA
00122A  90196E     MOV [W14+60], W2
00122C  510FE1     SUB W2, #0x1, [W15]
00122E  320001     BRA Z, 0x1232
001230  370121     BRA 0x1474
196:                           case 1:
197:                           {
198:                               *tmp = floor(nowPulse / 100000);
001232  BE001E     MOV.D [W14], W0
001234  286A02     MOV #0x86A0, W2
001236  200013     MOV #0x1, W3
001238  07FA57     RCALL ___udivsi3
00123A  981F40     MOV W0, [W14+56]
00123C  981F51     MOV W1, [W14+58]
00123E  901A4E     MOV [W14+56], W4
001240  901ADE     MOV [W14+58], W5
001242  520FE0     SUB W4, #0x0, [W15]
001244  5A8FE0     SUBB W5, #0x0, [W15]
001246  350006     BRA LT, 0x1254
001248  90184E     MOV [W14+56], W0
00124A  9018DE     MOV [W14+58], W1
00124C  07F8C5     RCALL ___floatsisf
00124E  981F20     MOV W0, [W14+52]
001250  981F31     MOV W1, [W14+54]
001252  370016     BRA 0x1280
001254  90184E     MOV [W14+56], W0
001256  600161     AND W0, #0x1, W2
001258  B80060     MUL.UU W0, #0, W0
00125A  200003     MOV #0x0, W3
00125C  700002     IOR W0, W2, W0
00125E  708083     IOR W1, W3, W1
001260  901A4E     MOV [W14+56], W4
001262  901ADE     MOV [W14+58], W5
001264  D10185     LSR W5, W3
001266  D38104     RRC W4, W2
001268  700002     IOR W0, W2, W0
00126A  708083     IOR W1, W3, W1
00126C  07F8B5     RCALL ___floatsisf
00126E  981F20     MOV W0, [W14+52]
001270  981F31     MOV W1, [W14+54]
001272  90192E     MOV [W14+52], W2
001274  9019BE     MOV [W14+54], W3
001276  90182E     MOV [W14+52], W0
001278  9018BE     MOV [W14+54], W1
00127A  07F80F     RCALL ___addsf3
00127C  981F20     MOV W0, [W14+52]
00127E  981F31     MOV W1, [W14+54]
001280  90182E     MOV [W14+52], W0
001282  9018BE     MOV [W14+54], W1
001284  07F8D4     RCALL _floorf
001286  90012E     MOV [W14+4], W2
001288  BE8900     MOV.D W0, [W2]
199:                               *(tmp + 1) = nowPulse % 100000 / 10.0;
00128A  90002E     MOV [W14+4], W0
00128C  400064     ADD W0, #0x4, W0
00128E  981F10     MOV W0, [W14+50]
001290  BE001E     MOV.D [W14], W0
001292  286A02     MOV #0x86A0, W2
001294  200013     MOV #0x1, W3
001296  07FA38     RCALL ___umodsi3
001298  981770     MOV W0, [W14+46]
00129A  981F01     MOV W1, [W14+48]
00129C  90107E     MOV [W14+46], W0
00129E  90188E     MOV [W14+48], W1
0012A0  500FE0     SUB W0, #0x0, [W15]
0012A2  588FE0     SUBB W1, #0x0, [W15]
0012A4  350006     BRA LT, 0x12B2
0012A6  90107E     MOV [W14+46], W0
0012A8  90188E     MOV [W14+48], W1
0012AA  07F896     RCALL ___floatsisf
0012AC  981750     MOV W0, [W14+42]
0012AE  981761     MOV W1, [W14+44]
0012B0  370016     BRA 0x12DE
0012B2  90107E     MOV [W14+46], W0
0012B4  600161     AND W0, #0x1, W2
0012B6  B80060     MUL.UU W0, #0, W0
0012B8  200003     MOV #0x0, W3
0012BA  700002     IOR W0, W2, W0
0012BC  708083     IOR W1, W3, W1
0012BE  90127E     MOV [W14+46], W4
0012C0  901A8E     MOV [W14+48], W5
0012C2  D10185     LSR W5, W3
0012C4  D38104     RRC W4, W2
0012C6  700002     IOR W0, W2, W0
0012C8  708083     IOR W1, W3, W1
0012CA  07F886     RCALL ___floatsisf
0012CC  981750     MOV W0, [W14+42]
0012CE  981761     MOV W1, [W14+44]
0012D0  90115E     MOV [W14+42], W2
0012D2  9011EE     MOV [W14+44], W3
0012D4  90105E     MOV [W14+42], W0
0012D6  9010EE     MOV [W14+44], W1
0012D8  07F7E0     RCALL ___addsf3
0012DA  981750     MOV W0, [W14+42]
0012DC  981761     MOV W1, [W14+44]
0012DE  200002     MOV #0x0, W2
0012E0  241203     MOV #0x4120, W3
0012E2  90105E     MOV [W14+42], W0
0012E4  9010EE     MOV [W14+44], W1
0012E6  07F836     RCALL ___divsf3
0012E8  901A9E     MOV [W14+50], W5
0012EA  BE8A80     MOV.D W0, [W5]
200:                               break;
0012EC  3700C3     BRA 0x1474
201:                           }
202:                           case 10:
203:                           {
204:                               *tmp = floor(nowPulse / 10000);
0012EE  BE001E     MOV.D [W14], W0
0012F0  227102     MOV #0x2710, W2
0012F2  200003     MOV #0x0, W3
0012F4  07F9F9     RCALL ___udivsi3
0012F6  981730     MOV W0, [W14+38]
0012F8  981741     MOV W1, [W14+40]
0012FA  90103E     MOV [W14+38], W0
0012FC  9010CE     MOV [W14+40], W1
0012FE  500FE0     SUB W0, #0x0, [W15]
001300  588FE0     SUBB W1, #0x0, [W15]
001302  350006     BRA LT, 0x1310
001304  90103E     MOV [W14+38], W0
001306  9010CE     MOV [W14+40], W1
001308  07F867     RCALL ___floatsisf
00130A  981710     MOV W0, [W14+34]
00130C  981721     MOV W1, [W14+36]
00130E  370016     BRA 0x133C
001310  90103E     MOV [W14+38], W0
001312  600161     AND W0, #0x1, W2
001314  B80060     MUL.UU W0, #0, W0
001316  200003     MOV #0x0, W3
001318  700002     IOR W0, W2, W0
00131A  708083     IOR W1, W3, W1
00131C  90123E     MOV [W14+38], W4
00131E  9012CE     MOV [W14+40], W5
001320  D10185     LSR W5, W3
001322  D38104     RRC W4, W2
001324  700002     IOR W0, W2, W0
001326  708083     IOR W1, W3, W1
001328  07F857     RCALL ___floatsisf
00132A  981710     MOV W0, [W14+34]
00132C  981721     MOV W1, [W14+36]
00132E  90111E     MOV [W14+34], W2
001330  9011AE     MOV [W14+36], W3
001332  90101E     MOV [W14+34], W0
001334  9010AE     MOV [W14+36], W1
001336  07F7B1     RCALL ___addsf3
001338  981710     MOV W0, [W14+34]
00133A  981721     MOV W1, [W14+36]
00133C  90101E     MOV [W14+34], W0
00133E  9010AE     MOV [W14+36], W1
001340  07F876     RCALL _floorf
001342  90012E     MOV [W14+4], W2
001344  BE8900     MOV.D W0, [W2]
205:                               *(tmp + 1) = nowPulse % 10000 / 10.0;
001346  90002E     MOV [W14+4], W0
001348  400064     ADD W0, #0x4, W0
00134A  981700     MOV W0, [W14+32]
00134C  BE001E     MOV.D [W14], W0
00134E  227102     MOV #0x2710, W2
001350  200003     MOV #0x0, W3
001352  07F9DA     RCALL ___umodsi3
001354  980F60     MOV W0, [W14+28]
001356  980F71     MOV W1, [W14+30]
001358  90086E     MOV [W14+28], W0
00135A  9008FE     MOV [W14+30], W1
00135C  500FE0     SUB W0, #0x0, [W15]
00135E  588FE0     SUBB W1, #0x0, [W15]
001360  350006     BRA LT, 0x136E
001362  90086E     MOV [W14+28], W0
001364  9008FE     MOV [W14+30], W1
001366  07F838     RCALL ___floatsisf
001368  980F40     MOV W0, [W14+24]
00136A  980F51     MOV W1, [W14+26]
00136C  370016     BRA 0x139A
00136E  90086E     MOV [W14+28], W0
001370  600161     AND W0, #0x1, W2
001372  B80060     MUL.UU W0, #0, W0
001374  200003     MOV #0x0, W3
001376  700002     IOR W0, W2, W0
001378  708083     IOR W1, W3, W1
00137A  900A6E     MOV [W14+28], W4
00137C  900AFE     MOV [W14+30], W5
00137E  D10185     LSR W5, W3
001380  D38104     RRC W4, W2
001382  700002     IOR W0, W2, W0
001384  708083     IOR W1, W3, W1
001386  07F828     RCALL ___floatsisf
001388  980F40     MOV W0, [W14+24]
00138A  980F51     MOV W1, [W14+26]
00138C  90094E     MOV [W14+24], W2
00138E  9009DE     MOV [W14+26], W3
001390  90084E     MOV [W14+24], W0
001392  9008DE     MOV [W14+26], W1
001394  07F782     RCALL ___addsf3
001396  980F40     MOV W0, [W14+24]
001398  980F51     MOV W1, [W14+26]
00139A  200002     MOV #0x0, W2
00139C  241203     MOV #0x4120, W3
00139E  90084E     MOV [W14+24], W0
0013A0  9008DE     MOV [W14+26], W1
0013A2  07F7D8     RCALL ___divsf3
0013A4  90128E     MOV [W14+32], W5
0013A6  BE8A80     MOV.D W0, [W5]
206:                               break;
0013A8  370065     BRA 0x1474
207:                           }
208:                           case 100:
209:                           {
210:                               *tmp = floor(nowPulse / 1000);
0013AA  BE001E     MOV.D [W14], W0
0013AC  203E82     MOV #0x3E8, W2
0013AE  200003     MOV #0x0, W3
0013B0  07F99B     RCALL ___udivsi3
0013B2  980F20     MOV W0, [W14+20]
0013B4  980F31     MOV W1, [W14+22]
0013B6  90082E     MOV [W14+20], W0
0013B8  9008BE     MOV [W14+22], W1
0013BA  500FE0     SUB W0, #0x0, [W15]
0013BC  588FE0     SUBB W1, #0x0, [W15]
0013BE  350006     BRA LT, 0x13CC
0013C0  90082E     MOV [W14+20], W0
0013C2  9008BE     MOV [W14+22], W1
0013C4  07F809     RCALL ___floatsisf
0013C6  980F00     MOV W0, [W14+16]
0013C8  980F11     MOV W1, [W14+18]
0013CA  370016     BRA 0x13F8
0013CC  90082E     MOV [W14+20], W0
0013CE  600161     AND W0, #0x1, W2
0013D0  B80060     MUL.UU W0, #0, W0
0013D2  200003     MOV #0x0, W3
0013D4  700002     IOR W0, W2, W0
0013D6  708083     IOR W1, W3, W1
0013D8  900A2E     MOV [W14+20], W4
0013DA  900ABE     MOV [W14+22], W5
0013DC  D10185     LSR W5, W3
0013DE  D38104     RRC W4, W2
0013E0  700002     IOR W0, W2, W0
0013E2  708083     IOR W1, W3, W1
0013E4  07F7F9     RCALL ___floatsisf
0013E6  980F00     MOV W0, [W14+16]
0013E8  980F11     MOV W1, [W14+18]
0013EA  90090E     MOV [W14+16], W2
0013EC  90099E     MOV [W14+18], W3
0013EE  90080E     MOV [W14+16], W0
0013F0  90089E     MOV [W14+18], W1
0013F2  07F753     RCALL ___addsf3
0013F4  980F00     MOV W0, [W14+16]
0013F6  980F11     MOV W1, [W14+18]
0013F8  90080E     MOV [W14+16], W0
0013FA  90089E     MOV [W14+18], W1
0013FC  07F818     RCALL _floorf
0013FE  90012E     MOV [W14+4], W2
001400  BE8900     MOV.D W0, [W2]
211:                               *(tmp + 1) = nowPulse % 1000 / 10.0;
001402  90002E     MOV [W14+4], W0
001404  400064     ADD W0, #0x4, W0
001406  980770     MOV W0, [W14+14]
001408  BE001E     MOV.D [W14], W0
00140A  203E82     MOV #0x3E8, W2
00140C  200003     MOV #0x0, W3
00140E  07F97C     RCALL ___umodsi3
001410  980750     MOV W0, [W14+10]
001412  980761     MOV W1, [W14+12]
001414  90005E     MOV [W14+10], W0
001416  9000EE     MOV [W14+12], W1
001418  500FE0     SUB W0, #0x0, [W15]
00141A  588FE0     SUBB W1, #0x0, [W15]
00141C  350006     BRA LT, 0x142A
00141E  90005E     MOV [W14+10], W0
001420  9000EE     MOV [W14+12], W1
001422  07F7DA     RCALL ___floatsisf
001424  980730     MOV W0, [W14+6]
001426  980741     MOV W1, [W14+8]
001428  370016     BRA 0x1456
00142A  90005E     MOV [W14+10], W0
00142C  600161     AND W0, #0x1, W2
00142E  B80060     MUL.UU W0, #0, W0
001430  200003     MOV #0x0, W3
001432  700002     IOR W0, W2, W0
001434  708083     IOR W1, W3, W1
001436  90025E     MOV [W14+10], W4
001438  9002EE     MOV [W14+12], W5
00143A  D10185     LSR W5, W3
00143C  D38104     RRC W4, W2
00143E  700002     IOR W0, W2, W0
001440  708083     IOR W1, W3, W1
001442  07F7CA     RCALL ___floatsisf
001444  980730     MOV W0, [W14+6]
001446  980741     MOV W1, [W14+8]
001448  90013E     MOV [W14+6], W2
00144A  9001CE     MOV [W14+8], W3
00144C  90003E     MOV [W14+6], W0
00144E  9000CE     MOV [W14+8], W1
001450  07F724     RCALL ___addsf3
001452  980730     MOV W0, [W14+6]
001454  980741     MOV W1, [W14+8]
001456  200002     MOV #0x0, W2
001458  241203     MOV #0x4120, W3
00145A  90003E     MOV [W14+6], W0
00145C  9000CE     MOV [W14+8], W1
00145E  07F77A     RCALL ___divsf3
001460  9002FE     MOV [W14+14], W5
001462  BE8A80     MOV.D W0, [W5]
001464  370007     BRA 0x1474
212:                               break;
213:                           }
214:                       } else {
215:                       *tmp = *(tmp + 1) = 0;
001466  90002E     MOV [W14+4], W0
001468  400164     ADD W0, #0x4, W2
00146A  B80060     MUL.UU W0, #0, W0
00146C  BE8900     MOV.D W0, [W2]
00146E  BE0012     MOV.D [W2], W0
001470  90012E     MOV [W14+4], W2
001472  BE8900     MOV.D W0, [W2]
216:                   }
217:               }
001474  FA8000     ULNK
001476  060000     RETURN
218:               
219:               /*************************************
220:               Function: Protocal12 
221:               Description: 协议1.2
222:               Input: 无
223:               Output: 无
224:                *************************************/
225:               //static void Protocal12(void)
226:               //{  
227:               ////    u16 crctemp;
228:               //    u8 temp[4];
229:               ////    gprsOutput[19] = tmp_dat[2]; //获取设备编号 20个字节地址最后2个字节有效
230:               ////    gprsOutput[18] = tmp_dat[1];
231:               //    mpdat.RSGPAddress=tmp_dat[2]+tmp_dat[1];
232:               //    //标况瞬间流量
233:               //    V12ToNum(tmp_dat + PTL_LOC[V1_2][v1i], 8);
234:               //    V12ToChar(tmp_dat + PTL_LOC[V1_2][v1i],temp);
235:               //    mpdat.Qb= V13ToFloat(temp);//第5个字节开始 处理4个字节（8字节） 获得标况瞬间流量
236:               ////    FloatToChar(&mpdat.Qb, gprsOutput + PTL_LOC[Gprs][v1i]); //从20字节开始存放数据
237:               ////            forTestfloat(1.23);//打印浮点数
238:               //
239:               //    //标况总流量
240:               //    V12ToNum(tmp_dat + PTL_LOC[V1_2][v1a], 4);
241:               //    mpdat.Vb = 2 * Pow1(10, *(tmp_dat + 12) << 12 + *(tmp_dat + 13) << 8 + 
242:               //            *(tmp_dat + 14) << 4 + *(tmp_dat + 15));
243:               //
244:               //    V12ToNum(tmp_dat + 16, 8);
245:               //    V12ToChar(tmp_dat + 16,temp);
246:               //    mpdat.Vb += V13ToFloat(temp); //获得标况总流量
247:               ////    DoubleToChar(&mpdat.Vb, gprsOutput + PTL_LOC[Gprs][v1a]); //从20字节开始存放数据
248:               ////            forTestfloat(gV1Acc);
249:               //    //温度
250:               //    V12ToNum(tmp_dat + PTL_LOC[V1_2][t1], 8);
251:               //    V12ToChar(tmp_dat + PTL_LOC[V1_2][t1],temp);
252:               //    mpdat.T = V13ToFloat(temp);
253:               ////    FloatToChar(&mpdat.gTemperature, gprsOutput + PTL_LOC[Gprs][t1]);
254:               ////            forTestfloat(gTemperature);
255:               //    //压力
256:               //    V12ToNum(tmp_dat + PTL_LOC[V1_2][s1], 8);
257:               //    V12ToChar(tmp_dat + PTL_LOC[V1_2][s1],temp);
258:               //    mpdat.P = V13ToFloat(temp);
259:               ////    FloatToChar(&mpdat.gStress, gprsOutput + PTL_LOC[Gprs][s1]);
260:               ////            forTestfloat(gStress);
261:               //    //工况瞬间流量
262:               //    V12ToNum(tmp_dat + PTL_LOC[V1_2][v2i], 8);
263:               //    V12ToChar(tmp_dat + PTL_LOC[V1_2][v2i],temp);
264:               //    mpdat.Q = V13ToFloat(temp);
265:               ////    FloatToChar(&mpdat.gStress, gprsOutput+PTL_LOC[Gprs][v2i]);
266:               ////            forTestfloat(gV2Ins);
267:               //}
268:               /*
269:                * Sned:7C 0D 31 30 32 30 30 30 30 30 30 30 30 30 30 30 30 30 30 7D
270:                * Receive:
271:                           7C ；                       起始位
272:                           30 32 ；                    仪表子机号
273:                           31 ；                       数据序列
274:                           30 35 37 3B 3B 3D 30 30 ；  瞬时流量，浮点数为 057BBD00，解包后十进制数为30.935  浮点数解包方法见下面所述。
275:                           30 30 30 30 ；              累积总量 BCD 码部分
276:                           30 3E 34 33 3F 38 30 31 ；  累积总量浮点数部分
277:                           30 35 35 30 30 30 30 30 ；  温度
278:                           30 37 36 35 32 3F 38 30 ；  压力
279:                           30 35 37 3B 3E 39 38 30 ；  工况流量
280:                           30 30 ；                    FLAG 标志（未使用）
281:                           30 30 ；                    校验和
282:                           7D ；                       停止位
283:                */
284:               
285:               ///*************************************
286:               //Function: ProtocalTX13 
287:               //Description: 协议1.3
288:               //Input: 无
289:               //Output: 无
290:               // *************************************/
291:               //static void Protocal13(void) {
292:               //    u8 count;
293:               //    float f;
294:               //    long double d;
295:               //
296:               //    //获取时间
297:               //    for (count = 0; count < 6; count++)
298:               //        mpdat.time[count] = tmp_dat[PTL_LOC[V1_3][time1] + count];
299:               //    //标况瞬时流量gV1Ins 
300:               //    f = V13ToFloat(tmp_dat + PTL_LOC[V1_3][v1i]);
301:               //    FloatToChar(&f, mpdat.Qb);
302:               //    //标况累积总量gV1Acc
303:               //    d = (*(tmp_dat + PTL_LOC[V1_3][v1a])*100)+
304:               //            *(tmp_dat + PTL_LOC[V1_3][v1a] + 1) +
305:               //            V13ToFloat(tmp_dat + PTL_LOC[V1_3][v1a] + 2);
306:               //    DoubleToChar(&d, mpdat.Vb);
307:               //    //温度
308:               //    f = V13ToFloat(tmp_dat + PTL_LOC[V1_3][t1]);
309:               //    FloatToChar(&f, mpdat.T);
310:               //    //压力
311:               //    f = V13ToFloat(tmp_dat + PTL_LOC[V1_3][s1]);
312:               //    FloatToChar(&f, mpdat.P);
313:               //    //报警字    
314:               //    mpdat.Alarm = *(tmp_dat + PTL_LOC[V1_3][alarm1]);
315:               //    //状态字
316:               //    mpdat.Status = *(tmp_dat + PTL_LOC[V1_3][status1]);
317:               //}
318:               /*
319:                * Send：CC 02 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FE 00 EE
320:                * 
321:                * Receive:
322:                           CC ；                   起始位
323:                           02 ；                   仪表子机号
324:                           30 ；                   功能码
325:                           1C 00 ；                数据长度
326:                           20 06 06 05 16 16 44 ； 时间
327:                           05 7B 86 80 ；          瞬时标况流量，浮点数结构，浮点数解包方法见下面所述。
328:                           00 00 0E 45 98 01 ；    标况总量（ 8908）
329:                           05 50 00 00 ；          温度
330:                           07 65 03 00 ；          压力
331:                           AA 5E ；                报警字位控说明
332:                           80 ；                   状态字
333:                           79 06 ；                校验和
334:                           EE ；                   结束符
335:                */
336:               
337:               ///*************************************
338:               //Function: ProtocalModBusA1 
339:               //Description: ModbusA1协议 BCD
340:               //Input: 无
341:               //Output: 无
342:               //*************************************/
343:               //static void ProtocalModbusA1(void)
344:               //{
345:               //    gprsOutput[19] = tmp_dat[0]; //地址
346:               //    //标况s瞬间流量gV1Acc
347:               //    mpdat.Qb = A1ToFloat(tmp_dat+PTL_LOC[A1][v1i],4);
348:               ////    FloatToChar(&mpdat.gV1Ins,gprsOutput + PTL_LOC[Gprs][v1i]);
349:               //    
350:               //    //标况累积总量gV1Acc
351:               //    mpdat.Vb = (double)A1ToFloat(tmp_dat+PTL_LOC[A1][v1a],6);
352:               ////    DoubleToChar(&mpdat.gV1Acc,gprsOutput + PTL_LOC[Gprs][v1a]);
353:               //    //温度
354:               //    mpdat.T = A1ToFloat(tmp_dat+PTL_LOC[A1][t1],4);
355:               ////    FloatToChar(&mpdat.gTemperature,gprsOutput + PTL_LOC[Gprs][t1]);
356:               //    //压力
357:               //    mpdat.P = A1ToFloat(tmp_dat+PTL_LOC[A1][s1],4);
358:               ////    FloatToChar(&mpdat.gStress,gprsOutput + PTL_LOC[Gprs][s1]);    
359:               //}
360:               ///*
361:               // * Send:02 03 00 01 00 0B 55 FE
362:               // * Receive:
363:               //            02 03 16 ；             地址、功能码、字节计数
364:               //            12 34 56 39 59 00 ；    标准总量： 1234563959
365:               //            00 00 34 63 ；          标况体积流量34.63
366:               //            00 00 30 97 ；          工况体积流量30.97
367:               //            80 00 10 50 ；          温度值-10.5℃
368:               //            00 01 01 50 ；          压力值101.5
369:               //            2A 69 ； CRC
370:               // */
371:               //
372:               
373:               /*************************************
374:               Function: ProtocalModBusA2 
375:               Description: ModbusA2协议 两个float
376:               Input: 无
377:               Output: 无
378:                *************************************/
379:               //static void ProtocalModbusA2(void) {
380:               //    //    gprsOutput[19] = tmp_dat[0]; //地址
381:               //    //标况瞬间流量gV1Ins    
382:               //    BPasteA(gprsOutput + PTL_LOC[Gprs][v1i], tmp_dat + PTL_LOC[A1][v1i], 4);
383:               //
384:               //    //标况累积总量gV1Acc
385:               //    CharToFloat(&mpdat.gV1Ins, tmp_dat + PTL_LOC[A1][v1a]);
386:               //    CharToFloat(&mpdat.gV2Ins, tmp_dat + PTL_LOC[A1][v1a] + 4);
387:               //    mpdat.gV1Acc = mpdat.gV1Ins * 1000000 + mpdat.gV2Ins;
388:               //    DoubleToChar(&mpdat.gV1Acc, gprsOutput + PTL_LOC[Gprs][v1a]);
389:               //
390:               //    //温度
391:               //    BPasteA(mpdat.g, tmp_dat + PTL_LOC[A1][t1], 4);
392:               //
393:               //    //压力
394:               //    BPasteA(gprsOutput + PTL_LOC[Gprs][s1], tmp_dat + PTL_LOC[A1][s1], 4);
395:               //
396:               //}
397:               ///*
398:               // * Send:02 03 00 01 00 0C 14 3C
399:               // * Receive:
400:               //            02 03 18 ；                 地址、功能码、字节计数
401:               //            41 10 00 00 40 F0 FC 46 ；  标准总量： 9000007.530
402:               //            00 00 00 00 ；              标况体积流量:0
403:               //            00 00 00 00 ；              工况体积流量:0
404:               //            41 A0 00 00 ；              温度值:20.0℃
405:               //            42 CA A6 00 ；              压力值:101.3
406:               //            BA A2 ；                    CRC
407:               // 
408:               // */
409:               //
410:               
411:               /*************************************
412:               Function: ProtocalModBusA3 
413:               Description: ModbusA3协议 一个double
414:               Input: 无
415:               Output: 无
416:                ************************************/
417:               //static void ProtocalModbusA3(void) {
418:               //标况累积总量gV1Acc
419:               //    BPasteA(mpdat.Vb, tmp_dat + PTL_LOC[A1][v1a], 8);
420:               //
421:               //    //标况瞬间流量gV1Ins    
422:               //    BPasteA(mpdat.Qb, tmp_dat + PTL_LOC[A1][v1i], 4);
423:               //
424:               //    //工况瞬间流量gV2Acc
425:               //    BPasteA(mpdat.Q, tmp_dat + PTL_LOC[A1][v1a], 4);
426:               //
427:               //    //温度
428:               //    BPasteA(mpdat.T, tmp_dat + PTL_LOC[A1][t1], 4);
429:               //
430:               //    //压力
431:               //    BPasteA(mpdat.P, tmp_dat + PTL_LOC[A1][s1], 4);
432:               //}
433:               /*
434:                * Send：02 03 00 01 00 0C 14 3C
435:                * Receive：
436:                       02 03 18 ；                 地址、功能码、字节计数
437:                       42 02 A0 5E D9 40 00 00 ；  标准总量： 9999997736
438:                       41 1B 35 F2 ；              标况体积流量9.70
439:                       41 1B 37 C0 ；              工况体积流量9.70
440:                       41 A0 00 00 ；              温度值20.0℃
441:                       42 CA A6 00 ；              压力值101.3
442:                       E3 EE ；                    CRC
443:                */
444:               
445:               /*************************************
446:               Function: CopMPTask 
447:               Description: miot1601与仪表的通讯任务是否完成 
448:               Input: Protovals：选择通讯协议 
449:               Output: 1:数据接收完整 
450:               // *************************************/
451:               //bool CopMPTaskIsFinish(u8 protocals) {
452:               //    bool b = false;
453:               //    u8 tmp = 0; //[8];
454:               //    //    float tmp_f; //临时存放浮点数
455:               //    long double tmp_d; //临时存放双精度浮点数
456:               //    float f1, f2;
457:               //    u8 mpCopData[53];
458:               //
459:               //    MP_ON; //开启仪表通讯 
460:               //    //向Mp发送查询指令
461:               //    //    if (protocals < 2) //V12 V13协议 发送20个字节
462:               //    //        UART2SendString(SEND_PROTOCAL[protocals], 20); //发送数据
463:               //    //    else //A1 A2 A3协议 发送8个字节
464:               //    UART2SendString(SEND_PROTOCAL[protocals], 8); //发送数据 
465:               
466:               //    switch (protocals) {
467:               //        case V1_2:
468:               //        {
469:               //            if(SerialDataIsGet(tmp_dat,0x7C,20,Sum_Check))
470:               //            {
471:               //                MP_OFF;                         //关闭仪表通讯
472:               //                if(tmp_dat[35] == 0xEE)
473:               //                {      
474:               //                    b = true;
475:               //                    if(!mode) Protocal12();
476:               //                }
477:               //            }
478:               //            break;
479:               //        }
480:               //        case 1://V3
481:               //        {
482:               //            if (SerialDataIsGet(BufferRead_UART1, mpCopData, 0xCC, 10)) //t_100ms*10 s内寻找帧头 开始已经取了1个十字街
483:               //            {
484:               //                MP_OFF; //关闭仪表通讯
485:               //                if (CheckIsRight(Sum_Check, mpCopData, 33)) //和校验 
486:               //                {
487:               //                    b = true;
488:               //                    //获取时间
489:               //                    Register1Write(&mpCopData[PTL_LOC[V1_3][time1]], 0x0000, 1);
490:               //                    //标况瞬时流量gV1Ins 
491:               //                    tmp_f = V13ToFloat(mpCopData + PTL_LOC[V1_3][v1i]);
492:               //                    FloatToChar(&tmp_f, tmp);
493:               //                    Register1Write(tmp, 0x0007, 1);
494:               //                    //标况累积总量gV1Acc
495:               //                    tmp_d = (*(mpCopData + PTL_LOC[V1_3][v1a])*100)+
496:               //                            *(mpCopData + PTL_LOC[V1_3][v1a] + 1) +
497:               //                            V13ToFloat(mpCopData + PTL_LOC[V1_3][v1a] + 2);
498:               //                    DoubleToChar(&tmp_d, tmp);
499:               //                    Register1Write(tmp, 0x000B, 1);
500:               //                    //温度
501:               //                    tmp_f = V13ToFloat(mpCopData + PTL_LOC[V1_3][t1]);
502:               //                    FloatToChar(&tmp_f, tmp);
503:               //                    Register1Write(tmp, 0x0013, 1);
504:               //                    //压力
505:               //                    tmp_f = V13ToFloat(mpCopData + PTL_LOC[V1_3][s1]);
506:               //                    FloatToChar(&tmp_f, tmp);
507:               //                    Register1Write(tmp, 0x0017, 1);
508:               //                    //报警字    
509:               //                    Register1Write((mpCopData + PTL_LOC[V1_3][alarm1]), 0x0027, 1);
510:               //                    //状态字
511:               //                    Register1Write((mpCopData + PTL_LOC[V1_3][status1]), 0x0028, 1);
512:               //                    //写入FROM
513:               //                    RegisterToFrom();
514:               //                }
515:               //
516:               //                break;
517:               //            }
518:               //        case A1:
519:               //        {
520:               //           if(MpReceiveDataIsRight(CRC16_Check,m1601arg.MP_Add,20,25))
521:               //            {
522:               //                    b = true;
523:               //                     ProtocalModbusA1();
524:               //        }
525:               //                break;
526:               //        }
527:               //        case 3://A2
528:               //        {
529:               //    Register2Read(tmp, mi_arg_add[mp_add], 1); //读取仪表地址  
530:               //
531:               //    if (SerialDataIsGet(BufferRead_UART1, mpCopData, *tmp, CopUDPA2Sample)) //t_100ms*10 s内寻找帧头 开始已经取了1个十字街
532:               //    {
533:               //        MP_OFF; //关闭仪表通讯
534:               //        if (CheckIsRight(CRC16_Check, mpCopData, 27)) //CRC校验 
535:               //        {
536:               //            b = true;
537:               //            //            Register2Write(mpCopData, 0x207, 1);
538:               //            //标况瞬间流量gV1Ins    
539:               //            //Register1Write(mpCopData + PTL_LOC[A2][v1i], 0x0007, 1);
540:               //
541:               //            //标况累积总量gV1Acc
542:               //            CharToFloat(&f1, mpCopData + PTL_LOC[A2][v1a]);
543:               //            CharToFloat(&f2, mpCopData + PTL_LOC[A2][v1a] + 4);
544:               //            //            tmp_d = f1 * (long double) 1000000 + f2;
545:               //            //            DoubleToChar(&tmp_d, tmp);
546:               //            //                    Register1Write(tmp, 0x000B, 1);
547:               //            //温度
548:               //            //                        BPasteA(Register1 + PTL_LOC[Gprs][t1], mpCopData + PTL_LOC[A2][t1], 4);
549:               //            //                    Register1Write(mpCopData + PTL_LOC[A2][t1], 0x0013, 1);
550:               //
551:               //            //压力
552:               //            //                        BPasteA(Register1 + PTL_LOC[Gprs][s1], mpCopData + PTL_LOC[A2][s1], 4);
553:               //            //                    Register1Write(mpCopData + PTL_LOC[A2][s1], 0x0017, 1);
554:               //
555:               //            //赋值数据
556:               //            for (tmp[0] = 0; tmp[0] < 29; tmp[0]++)
557:               //                *(tmp[0] + mpCopDataForUDP) = *(tmp[0] + mpCopData);
558:               //            //写入FROM
559:               //            RegisterToFrom();
560:               //        }
561:               //        //    }
562:               //        //            break;
563:               //        //            default:
564:               //        //            {
565:               //        //                break;
566:               //        //            }
567:               //        //}
568:               //        //                        case A3:
569:               //        //                        {
570:               //        //                            //                if (MpReceiveDataIsRight(CRC16_Check, m1601arg.MP_Add, 10, 27)) {
571:               //        //                            //                    b = true;
572:               //        //                            //                    ProtocalModbusA3();
573:               //        //                            //                }
574:               //        //                            break;
575:               //        //                        }
576:               //        //                        default:
577:               //        //                            break;
578:               //        //        }
579:               //    }
580:               //    MP_OFF; //无论通讯结果如何，关闭仪表通讯  
581:               //    //    ClrData(mpCopData, 30); //清除帧尾数据,避免数据不刷新
582:               //    return b;
583:               //}
584:               
585:               /*************************************
586:               Function: GetValueTask
587:               Description: 获取MP中工况瞬间量和工况总量
588:               Input: 无
589:               Output: 无
590:                *************************************/
591:               void GetValueTask(void) {
001478  FA0022     LNK #0x22
592:                   u8 tmp_ch[19]; //临时4为浮点数IEE745的字符
593:                   float Qm_f; //瞬间量
594:                   float Vm_f[2]; //总量的高8位和低8位
595:                   //    u8 rtcTime[7] = {20, 00, 00, 00, 00, 00, 00};
596:                   u16 OffsetAdd1 = gOffsetAdd * REG_DATA_SECTION; //同意使用偏移量
00147A  BFCC32     MOV.B 0xC32, WREG
00147C  FB8080     ZE W0, W1
00147E  2002A0     MOV #0x2A, W0
001480  B98800     MUL.SS W1, W0, W0
001482  780F00     MOV W0, [W14]
597:               
598:                   //计算工况数据
599:                   if (PulseIsOver(gPulseCount) && !gOverFlag)
001484  805CE0     MOV 0xB9C, W0
001486  805CF1     MOV 0xB9E, W1
001488  07FE14     RCALL _PulseIsOver
00148A  FB8000     ZE W0, W0
00148C  E00000     CP0 W0
00148E  320005     BRA Z, 0x149A
001490  BFCBA0     MOV.B 0xBA0, WREG
001492  E00400     CP0.B W0
001494  3A0002     BRA NZ, 0x149A
600:                       gOverFlag = 1;
001496  B3C010     MOV.B #0x1, W0
001498  B7EBA0     MOV.B WREG, 0xBA0
601:                   Qm_f = Get_Q(gPulseCount);
00149A  805CE0     MOV 0xB9C, W0
00149C  805CF1     MOV 0xB9E, W1
00149E  07FE27     RCALL _Get_Q
0014A0  980F30     MOV W0, [W14+22]
0014A2  980F41     MOV W1, [W14+24]
602:                   Get_V(gPulseCount, Vm_f);
0014A4  805CE0     MOV 0xB9C, W0
0014A6  805CF1     MOV 0xB9E, W1
0014A8  47017A     ADD W14, #0x1A, W2
0014AA  07FEAE     RCALL _Get_V
603:                   gNowCapture = 0; //清除定时器数值，避免没有脉冲是显示脉冲工况瞬间量
0014AC  B80060     MUL.UU W0, #0, W0
0014AE  885CC0     MOV W0, 0xB98
0014B0  885CD1     MOV W1, 0xB9A
604:                   //将数据写入队列中
605:                   FloatToChar(&Qm_f, tmp_ch); //工况瞬间量
0014B2  E8808E     INC2 W14, W1
0014B4  470076     ADD W14, #0x16, W0
0014B6  070F96     RCALL FloatToChar
606:                   FloatToChar(Vm_f, tmp_ch + 4); //工况总量1
0014B8  E8800E     INC2 W14, W0
0014BA  4000E4     ADD W0, #0x4, W1
0014BC  47007A     ADD W14, #0x1A, W0
0014BE  070F92     RCALL FloatToChar
607:                   FloatToChar(Vm_f + 1, tmp_ch + 8); //工况总量2
0014C0  E8800E     INC2 W14, W0
0014C2  4000E8     ADD W0, #0x8, W1
0014C4  47007A     ADD W14, #0x1A, W0
0014C6  400064     ADD W0, #0x4, W0
0014C8  070F8D     RCALL FloatToChar
608:                   RTCReadTime(tmp_ch + 12);
0014CA  E8800E     INC2 W14, W0
0014CC  40006C     ADD W0, #0xC, W0
0014CE  071077     RCALL RTCReadTime
609:                   //    EnQueue(tmp_ch, &line);
610:                   EnRegister1(tmp_ch);
0014D0  E8800E     INC2 W14, W0
0014D2  070C05     RCALL EnRegister1
611:               
612:                   //写标况瞬间量  change
613:                   FM25L64B_Write((mi_dat_add[mp_Qm] + OffsetAdd1), tmp_ch, 4);
0014D4  28E250     MOV #0x8E25, W0
0014D6  784010     MOV.B [W0], W0
0014D8  FB8000     ZE W0, W0
0014DA  40001E     ADD W0, [W14], W0
0014DC  E8808E     INC2 W14, W1
0014DE  200042     MOV #0x4, W2
0014E0  070EF5     RCALL FM25L64B_Write
614:                   //获取工况总量转换字符串，并写入FRAM  
615:                   FM25L64B_Write((mi_dat_add[mp_Vm] + OffsetAdd1), tmp_ch + 4, 4);
0014E2  E8800E     INC2 W14, W0
0014E4  4000E4     ADD W0, #0x4, W1
0014E6  28E260     MOV #0x8E26, W0
0014E8  784010     MOV.B [W0], W0
0014EA  FB8000     ZE W0, W0
0014EC  40001E     ADD W0, [W14], W0
0014EE  200042     MOV #0x4, W2
0014F0  070EED     RCALL FM25L64B_Write
616:                   FM25L64B_Write((mi_dat_add[mp_Vm] + OffsetAdd1 + 4), tmp_ch + 8, 4);
0014F2  E8800E     INC2 W14, W0
0014F4  4000E8     ADD W0, #0x8, W1
0014F6  28E260     MOV #0x8E26, W0
0014F8  784010     MOV.B [W0], W0
0014FA  FB8000     ZE W0, W0
0014FC  40001E     ADD W0, [W14], W0
0014FE  400064     ADD W0, #0x4, W0
001500  200042     MOV #0x4, W2
001502  070EE4     RCALL FM25L64B_Write
617:                   //获取时间，并写入FRAM
618:                   FM25L64B_Write((mi_dat_add[mp_time] + OffsetAdd1), tmp_ch + 12, 7);
001504  E8800E     INC2 W14, W0
001506  4000EC     ADD W0, #0xC, W1
001508  28E200     MOV #0x8E20, W0
00150A  784010     MOV.B [W0], W0
00150C  FB8000     ZE W0, W0
00150E  40001E     ADD W0, [W14], W0
001510  200072     MOV #0x7, W2
001512  070EDC     RCALL FM25L64B_Write
619:                   //赋值其他值
620:                   tmp_ch[0] = tmp_ch[1] = tmp_ch[2] = tmp_ch[3] = 0;
001514  E8808E     INC2 W14, W1
001516  EB4000     CLR.B W0
001518  9840B0     MOV.B W0, [W1+3]
00151A  E8800E     INC2 W14, W0
00151C  9040B0     MOV.B [W0+3], W1
00151E  E8800E     INC2 W14, W0
001520  984021     MOV.B W1, [W0+2]
001522  E8800E     INC2 W14, W0
001524  9040A0     MOV.B [W0+2], W1
001526  E8800E     INC2 W14, W0
001528  984011     MOV.B W1, [W0+1]
00152A  E8800E     INC2 W14, W0
00152C  904090     MOV.B [W0+1], W1
00152E  E8800E     INC2 W14, W0
001530  784801     MOV.B W1, [W0]
621:                   FM25L64B_Write(mi_dat_add[mp_T] + OffsetAdd1, tmp_ch, 4);
001532  28E230     MOV #0x8E23, W0
001534  784010     MOV.B [W0], W0
001536  FB8000     ZE W0, W0
001538  40001E     ADD W0, [W14], W0
00153A  E8808E     INC2 W14, W1
00153C  200042     MOV #0x4, W2
00153E  070EC6     RCALL FM25L64B_Write
622:                   FM25L64B_Write((mi_dat_add[mp_P] + OffsetAdd1), tmp_ch, 4);
001540  28E240     MOV #0x8E24, W0
001542  784010     MOV.B [W0], W0
001544  FB8000     ZE W0, W0
001546  40001E     ADD W0, [W14], W0
001548  E8808E     INC2 W14, W1
00154A  200042     MOV #0x4, W2
00154C  070EBF     RCALL FM25L64B_Write
623:                   FM25L64B_Write((mi_dat_add[mp_Qb] + OffsetAdd1), tmp_ch, 4);
00154E  28E210     MOV #0x8E21, W0
001550  784010     MOV.B [W0], W0
001552  FB8000     ZE W0, W0
001554  40001E     ADD W0, [W14], W0
001556  E8808E     INC2 W14, W1
001558  200042     MOV #0x4, W2
00155A  070EB8     RCALL FM25L64B_Write
624:                   FM25L64B_Write((mi_dat_add[mp_Vb] + OffsetAdd1), tmp_ch, 4);
00155C  28E220     MOV #0x8E22, W0
00155E  784010     MOV.B [W0], W0
001560  FB8000     ZE W0, W0
001562  40001E     ADD W0, [W14], W0
001564  E8808E     INC2 W14, W1
001566  200042     MOV #0x4, W2
001568  070EB1     RCALL FM25L64B_Write
625:                   FM25L64B_Write((mi_dat_add[mp_Vb] + OffsetAdd1 + 4), tmp_ch, 4);
00156A  28E220     MOV #0x8E22, W0
00156C  784010     MOV.B [W0], W0
00156E  FB8000     ZE W0, W0
001570  40001E     ADD W0, [W14], W0
001572  400064     ADD W0, #0x4, W0
001574  E8808E     INC2 W14, W1
001576  200042     MOV #0x4, W2
001578  070EA9     RCALL FM25L64B_Write
626:               
627:                   Statusbits.staSample = 1;
00157A  A82C38     BSET Statusbits, #1
628:                   //获取电池信息，并写入FRAM 
629:                   Statusbits.staBat = (BAT_DEC) ? 0 : 1; // Vdd=1 Vbat=1  ；Vdd=0 Vbat=0
00157C  BFC2CB     MOV.B 0x2CB, WREG
00157E  FB8000     ZE W0, W0
001580  DE0046     LSR W0, #6, W0
001582  A20400     BTG.B W0, #0
001584  604061     AND.B W0, #0x1, W0
001586  604061     AND.B W0, #0x1, W0
001588  604061     AND.B W0, #0x1, W0
00158A  604061     AND.B W0, #0x1, W0
00158C  DD0144     SL W0, #4, W2
00158E  20C381     MOV #0xC38, W1
001590  784091     MOV.B [W1], W1
001592  B3CEF0     MOV.B #0xEF, W0
001594  60C000     AND.B W1, W0, W0
001596  704002     IOR.B W0, W2, W0
001598  B7EC38     MOV.B WREG, Statusbits
630:                   if (Statusbits.staBat)
00159A  BFCC38     MOV.B Statusbits, WREG
00159C  604070     AND.B W0, #0x10, W0
00159E  E00400     CP0.B W0
0015A0  320002     BRA Z, 0x15A6
631:                       gAlarmVoltageAdd = gOffsetAdd;
0015A2  BFCC32     MOV.B 0xC32, WREG
0015A4  B7EC44     MOV.B WREG, gAlarmVoltageAdd
632:                   tmp_ch[0] = (Statusbits.staBat << 4) | (Statusbits.staAlarm << 3)
0015A6  BFCC38     MOV.B Statusbits, WREG
0015A8  FB8000     ZE W0, W0
0015AA  DE0044     LSR W0, #4, W0
0015AC  604061     AND.B W0, #0x1, W0
0015AE  FB8000     ZE W0, W0
0015B0  DD0044     SL W0, #4, W0
0015B2  784080     MOV.B W0, W1
0015B4  BFCC38     MOV.B Statusbits, WREG
0015B6  FB8000     ZE W0, W0
0015B8  DE0043     LSR W0, #3, W0
0015BA  604061     AND.B W0, #0x1, W0
0015BC  FB8000     ZE W0, W0
0015BE  DD0043     SL W0, #3, W0
0015C0  70C080     IOR.B W1, W0, W1
0015C2  BFCC38     MOV.B Statusbits, WREG
0015C4  FB8000     ZE W0, W0
0015C6  DE0042     LSR W0, #2, W0
0015C8  604061     AND.B W0, #0x1, W0
0015CA  FB8000     ZE W0, W0
0015CC  DD0042     SL W0, #2, W0
0015CE  70C080     IOR.B W1, W0, W1
0015D0  BFCC38     MOV.B Statusbits, WREG
0015D2  FB8000     ZE W0, W0
0015D4  D10000     LSR W0, W0
0015D6  604061     AND.B W0, #0x1, W0
0015D8  FB8000     ZE W0, W0
0015DA  400000     ADD W0, W0, W0
0015DC  70C080     IOR.B W1, W0, W1
0015DE  BFCC38     MOV.B Statusbits, WREG
0015E0  604061     AND.B W0, #0x1, W0
0015E2  70C000     IOR.B W1, W0, W0
0015E4  784080     MOV.B W0, W1
0015E6  E8800E     INC2 W14, W0
0015E8  784801     MOV.B W1, [W0]
633:                           | (Statusbits.staGPRS << 2) | (Statusbits.staSample << 1)
634:                           | Statusbits.staCheckRTCC;
635:                   FM25L64B_Write((mi_dat_add[mp_status] + OffsetAdd1), tmp_ch, 1);
0015EA  28E280     MOV #0x8E28, W0
0015EC  784010     MOV.B [W0], W0
0015EE  FB8000     ZE W0, W0
0015F0  40001E     ADD W0, [W14], W0
0015F2  E8808E     INC2 W14, W1
0015F4  200012     MOV #0x1, W2
0015F6  070E6A     RCALL FM25L64B_Write
636:                   //    //for test
637:                   //    FM25L64B_Read(OffsetAdd1, tmp, REG_DATA_SECTION);
638:                   //    更新数据包数据
639:                   FROM_WriteDPNum(); //更新数据包数据
0015F8  070EC6     RCALL FROM_WriteDPNum
640:               }
0015FA  FA8000     ULNK
0015FC  060000     RETURN
641:               
642:               /*************************************
643:               Function: PacketData2A2
644:               Description: 选择指定的通道打包成A2
645:               Input: 指定铁电通道（0-12）
646:               Output: A2的字符长度
647:                *************************************/
648:               // 02 03 18 41 10 00 00 40 F0 FC 46 00 00 00 00 00 00 00 00 41 A0 00 00 42 CA A6 00 BA A2
649:               
650:               void PacketData2A2(u8 *dat, u8*dat1) {
0015FE  FA0008     LNK #0x8
001600  980720     MOV W0, [W14+4]
001602  980731     MOV W1, [W14+6]
651:                   u8 cnt;
652:                   u16 CRCtmp;
653:                   //设备地址
654:                   Register2Read(dat, mi_arg_add[mi_add], 1);
001604  846F81     MOV 0x8DF0, W1
001606  B3C012     MOV.B #0x1, W2
001608  90002E     MOV [W14+4], W0
00160A  0709F7     RCALL Register2Read
655:                   //功能码
656:                   *(dat + 1) = 0x03;
00160C  90002E     MOV [W14+4], W0
00160E  E80080     INC W0, W1
001610  B3C030     MOV.B #0x3, W0
001612  784880     MOV.B W0, [W1]
657:                   //字节数 减去功能码 地址 CRC校验2位- 自身1位
658:                   *(dat + 2) = UDP_A2_LENGTH - 5;
001614  90002E     MOV [W14+4], W0
001616  E88080     INC2 W0, W1
001618  B3C250     MOV.B #0x25, W0
00161A  784880     MOV.B W0, [W1]
659:                   //标况总量
660:                   for (cnt = 0; cnt < 8; cnt++)
00161C  EB4000     CLR.B W0
00161E  984720     MOV.B W0, [W14+2]
001620  37000B     BRA 0x1638
001632  90402E     MOV.B [W14+2], W0
001634  E84000     INC.B W0, W0
001636  984720     MOV.B W0, [W14+2]
001638  90402E     MOV.B [W14+2], W0
00163A  504FE7     SUB.B W0, #0x7, [W15]
00163C  36FFF2     BRA LEU, 0x1622
661:                       *(dat + 3 + cnt) = 0;
001622  90402E     MOV.B [W14+2], W0
001624  FB8000     ZE W0, W0
001626  780080     MOV W0, W1
001628  90002E     MOV [W14+4], W0
00162A  408000     ADD W1, W0, W0
00162C  4000E3     ADD W0, #0x3, W1
00162E  EB4000     CLR.B W0
001630  784880     MOV.B W0, [W1]
662:                   //标况瞬间量
663:                   for (cnt = 0; cnt < 4; cnt++)
00163E  EB4000     CLR.B W0
001640  984720     MOV.B W0, [W14+2]
001642  37000B     BRA 0x165A
001654  90402E     MOV.B [W14+2], W0
001656  E84000     INC.B W0, W0
001658  984720     MOV.B W0, [W14+2]
00165A  90402E     MOV.B [W14+2], W0
00165C  504FE3     SUB.B W0, #0x3, [W15]
00165E  36FFF2     BRA LEU, 0x1644
664:                       *(dat + 11 + cnt) = 0;
001644  90402E     MOV.B [W14+2], W0
001646  FB8000     ZE W0, W0
001648  780080     MOV W0, W1
00164A  90002E     MOV [W14+4], W0
00164C  408000     ADD W1, W0, W0
00164E  4000EB     ADD W0, #0xB, W1
001650  EB4000     CLR.B W0
001652  784880     MOV.B W0, [W1]
665:                   //工况总量
666:                   for (cnt = 0; cnt < 8; cnt++)
001660  EB4000     CLR.B W0
001662  984720     MOV.B W0, [W14+2]
001664  370011     BRA 0x1688
001682  90402E     MOV.B [W14+2], W0
001684  E84000     INC.B W0, W0
001686  984720     MOV.B W0, [W14+2]
001688  90402E     MOV.B [W14+2], W0
00168A  504FE7     SUB.B W0, #0x7, [W15]
00168C  36FFEC     BRA LEU, 0x1666
667:                       *(dat + 15 + cnt) = *(dat1 + cnt + 4);
001666  90402E     MOV.B [W14+2], W0
001668  FB8000     ZE W0, W0
00166A  780080     MOV W0, W1
00166C  90002E     MOV [W14+4], W0
00166E  408000     ADD W1, W0, W0
001670  40016F     ADD W0, #0xF, W2
001672  90402E     MOV.B [W14+2], W0
001674  FB8000     ZE W0, W0
001676  780080     MOV W0, W1
001678  90003E     MOV [W14+6], W0
00167A  408000     ADD W1, W0, W0
00167C  400064     ADD W0, #0x4, W0
00167E  784010     MOV.B [W0], W0
001680  784900     MOV.B W0, [W2]
668:                   //工况瞬间量
669:                   for (cnt = 0; cnt < 4; cnt++)
00168E  EB4000     CLR.B W0
001690  984720     MOV.B W0, [W14+2]
001692  370010     BRA 0x16B4
0016AE  90402E     MOV.B [W14+2], W0
0016B0  E84000     INC.B W0, W0
0016B2  984720     MOV.B W0, [W14+2]
0016B4  90402E     MOV.B [W14+2], W0
0016B6  504FE3     SUB.B W0, #0x3, [W15]
0016B8  36FFED     BRA LEU, 0x1694
670:                       *(dat + 23 + cnt) = *(dat1 + cnt);
001694  90402E     MOV.B [W14+2], W0
001696  FB8000     ZE W0, W0
001698  780080     MOV W0, W1
00169A  90002E     MOV [W14+4], W0
00169C  408000     ADD W1, W0, W0
00169E  400177     ADD W0, #0x17, W2
0016A0  90402E     MOV.B [W14+2], W0
0016A2  FB8000     ZE W0, W0
0016A4  780080     MOV W0, W1
0016A6  90003E     MOV [W14+6], W0
0016A8  408000     ADD W1, W0, W0
0016AA  784010     MOV.B [W0], W0
0016AC  784900     MOV.B W0, [W2]
671:               
672:                   //温度
673:                   //    FM25L64B_Read(mi_dat_add[mp_T] + REG_DATA_SECTION * channel, tmp, 4);
674:                   for (cnt = 0; cnt < 4; cnt++)
0016BA  EB4000     CLR.B W0
0016BC  984720     MOV.B W0, [W14+2]
0016BE  37000B     BRA 0x16D6
0016D0  90402E     MOV.B [W14+2], W0
0016D2  E84000     INC.B W0, W0
0016D4  984720     MOV.B W0, [W14+2]
0016D6  90402E     MOV.B [W14+2], W0
0016D8  504FE3     SUB.B W0, #0x3, [W15]
0016DA  36FFF2     BRA LEU, 0x16C0
675:                       *(dat + 27 + cnt) = 0;
0016C0  90402E     MOV.B [W14+2], W0
0016C2  FB8000     ZE W0, W0
0016C4  780080     MOV W0, W1
0016C6  90002E     MOV [W14+4], W0
0016C8  408000     ADD W1, W0, W0
0016CA  4000FB     ADD W0, #0x1B, W1
0016CC  EB4000     CLR.B W0
0016CE  784880     MOV.B W0, [W1]
676:                   //压力
677:                   //    FM25L64B_Read(mi_dat_add[mp_P] + REG_DATA_SECTION * channel, tmp, 4);
678:                   for (cnt = 0; cnt < 4; cnt++)
0016DC  EB4000     CLR.B W0
0016DE  984720     MOV.B W0, [W14+2]
0016E0  37000B     BRA 0x16F8
0016F2  90402E     MOV.B [W14+2], W0
0016F4  E84000     INC.B W0, W0
0016F6  984720     MOV.B W0, [W14+2]
0016F8  90402E     MOV.B [W14+2], W0
0016FA  504FE3     SUB.B W0, #0x3, [W15]
0016FC  36FFF2     BRA LEU, 0x16E2
679:                       *(dat + 31 + cnt) = 0;
0016E2  90402E     MOV.B [W14+2], W0
0016E4  FB8000     ZE W0, W0
0016E6  780080     MOV W0, W1
0016E8  90002E     MOV [W14+4], W0
0016EA  408000     ADD W1, W0, W0
0016EC  4000FF     ADD W0, #0x1F, W1
0016EE  EB4000     CLR.B W0
0016F0  784880     MOV.B W0, [W1]
680:                   //设备状态
681:                   //    FM25L64B_Read(mi_dat_add[mp_status] + REG_DATA_SECTION * channel, tmp, 1);
682:                   *(dat + 35) = Statusbits.staBat << 4;
0016FE  90002E     MOV [W14+4], W0
001700  200231     MOV #0x23, W1
001702  408080     ADD W1, W0, W1
001704  BFCC38     MOV.B Statusbits, WREG
001706  FB8000     ZE W0, W0
001708  DE0044     LSR W0, #4, W0
00170A  604061     AND.B W0, #0x1, W0
00170C  DD0044     SL W0, #4, W0
00170E  784880     MOV.B W0, [W1]
683:                   if (Statusbits.staBat) {//高压的话输出3.0V       
001710  BFCC38     MOV.B Statusbits, WREG
001712  604070     AND.B W0, #0x10, W0
001714  E00400     CP0.B W0
001716  320015     BRA Z, 0x1742
684:                       *(dat + 36) = 0x40;
001718  90002E     MOV [W14+4], W0
00171A  200241     MOV #0x24, W1
00171C  408080     ADD W1, W0, W1
00171E  B3C400     MOV.B #0x40, W0
001720  784880     MOV.B W0, [W1]
685:                       *(dat + 37) = 0x40;
001722  90002E     MOV [W14+4], W0
001724  200251     MOV #0x25, W1
001726  408080     ADD W1, W0, W1
001728  B3C400     MOV.B #0x40, W0
00172A  784880     MOV.B W0, [W1]
686:                       *(dat + 38) = 0x00;
00172C  90002E     MOV [W14+4], W0
00172E  200261     MOV #0x26, W1
001730  408080     ADD W1, W0, W1
001732  EB4000     CLR.B W0
001734  784880     MOV.B W0, [W1]
687:                       *(dat + 39) = 0x00;
001736  90002E     MOV [W14+4], W0
001738  200271     MOV #0x27, W1
00173A  408080     ADD W1, W0, W1
00173C  EB4000     CLR.B W0
00173E  784880     MOV.B W0, [W1]
001740  370014     BRA 0x176A
688:                   } else {//低压的话输出3.6V        
689:                       *(dat + 36) = 0x40;
001742  90002E     MOV [W14+4], W0
001744  200241     MOV #0x24, W1
001746  408080     ADD W1, W0, W1
001748  B3C400     MOV.B #0x40, W0
00174A  784880     MOV.B W0, [W1]
690:                       *(dat + 37) = 0x66;
00174C  90002E     MOV [W14+4], W0
00174E  200251     MOV #0x25, W1
001750  408080     ADD W1, W0, W1
001752  B3C660     MOV.B #0x66, W0
001754  784880     MOV.B W0, [W1]
691:                       *(dat + 38) = 0x66;
001756  90002E     MOV [W14+4], W0
001758  200261     MOV #0x26, W1
00175A  408080     ADD W1, W0, W1
00175C  B3C660     MOV.B #0x66, W0
00175E  784880     MOV.B W0, [W1]
692:                       *(dat + 39) = 0x66;
001760  90002E     MOV [W14+4], W0
001762  200271     MOV #0x27, W1
001764  408080     ADD W1, W0, W1
001766  B3C660     MOV.B #0x66, W0
001768  784880     MOV.B W0, [W1]
693:                   }
694:                   //CRC校验
695:                   CRCtmp = CRC16_Check(dat, UDP_A2_LENGTH - 2);
00176A  200281     MOV #0x28, W1
00176C  90002E     MOV [W14+4], W0
00176E  070F89     RCALL CRC16_Check
001770  780F00     MOV W0, [W14]
696:                   *(dat + 40) = (u8) (CRCtmp & 0x00FF);
001772  90002E     MOV [W14+4], W0
001774  200281     MOV #0x28, W1
001776  408080     ADD W1, W0, W1
001778  78001E     MOV [W14], W0
00177A  784880     MOV.B W0, [W1]
697:                   *(dat + 41) = (u8) (CRCtmp >> 8);
00177C  90002E     MOV [W14+4], W0
00177E  200291     MOV #0x29, W1
001780  408080     ADD W1, W0, W1
001782  78001E     MOV [W14], W0
001784  DE0048     LSR W0, #8, W0
001786  784880     MOV.B W0, [W1]
698:               }
001788  FA8000     ULNK
00178A  060000     RETURN
699:               
700:               
701:               //void PacketData2A2(u8 channel, u8 *dat) {
702:               //    u8 cnt, tmp[8];
703:               //    u16 CRCtmp;
704:               //    //设备地址
705:               //    Register2Read(dat, mi_arg_add[mi_add], 1);
706:               //    //功能吗
707:               //    *(dat + 1) = 0x03;
708:               //    //字节数 减去功能码 地址 CRC校验2位- 自身1位
709:               //    *(dat + 2) = UDP_A2_LENGTH - 5;//38-4
710:               //    //标况总量
711:               //    for (cnt = 0; cnt < 8; cnt++)
712:               //        *(dat + 3 + cnt) = 0;
713:               //    //标况瞬间量
714:               //    for (cnt = 0; cnt < 4; cnt++)
715:               //        *(dat + 11 + cnt) = 0;
716:               //    //工况总量
717:               //    FM25L64B_Read(mi_dat_add[mp_Vm] + REG_DATA_SECTION * channel, tmp, 8);
718:               //    for (cnt = 0; cnt < 8; cnt++)
719:               //        *(dat + 15 + cnt) = tmp[cnt];
720:               //    //工况瞬间量
721:               //    FM25L64B_Read(mi_dat_add[mp_Qm] + REG_DATA_SECTION * channel, tmp, 4);
722:               //    for (cnt = 0; cnt < 4; cnt++)
723:               //        *(dat + 23 + cnt) = tmp[cnt];
724:               //    //温度
725:               //    FM25L64B_Read(mi_dat_add[mp_T] + REG_DATA_SECTION * channel, tmp, 4);
726:               //    for (cnt = 0; cnt < 4; cnt++)
727:               //        *(dat + 27 + cnt) = tmp[cnt];
728:               //    //压力
729:               //    FM25L64B_Read(mi_dat_add[mp_P] + REG_DATA_SECTION * channel, tmp, 4);
730:               //    for (cnt = 0; cnt < 4; cnt++)
731:               //        *(dat + 31 + cnt) = tmp[cnt];
732:               //    //设备状态
733:               //    FM25L64B_Read(mi_dat_add[mp_status] + REG_DATA_SECTION * channel, tmp, 1);
734:               //    *(dat + 35) = *tmp;
735:               //    //CRC校验
736:               //    CRCtmp = CRC16_Check(dat, UDP_A2_LENGTH - 2);
737:               //    *(dat + 36) = (u8) (CRCtmp & 0x00FF);
738:               //    *(dat + 37) = (u8) (CRCtmp >> 8);
739:               //}
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/ICN.c  -----------------------------
1:                 //#include <p24FV32KA301.h>
2:                 #include "user.h"
3:                 
4:                 void ICN_Configuration(void) {
003B7E  FA0000     LNK #0x0
5:                     BAT_DEC_IN;
003B80  A8C2C9     BSET 0x2C9, #6
6:                     INPUT_PULSE_IN;
003B82  A822C9     BSET 0x2C9, #1
7:                     //    CNPU2bits.CN21PUE=1;//使能弱上拉
8:                     IPC4bits.CNIP = 6;
003B84  200AD1     MOV #0xAD, W1
003B86  784091     MOV.B [W1], W1
003B88  B3C8F0     MOV.B #0x8F, W0
003B8A  60C000     AND.B W1, W0, W0
003B8C  B3C601     MOV.B #0x60, W1
003B8E  704001     IOR.B W0, W1, W0
003B90  B7E0AD     MOV.B WREG, 0xAD
9:                     IFS1bits.CNIF = 0;
003B92  A96086     BCLR IFS1, #3
10:                    //    CNEN1bits.CN0IE=1;//使能输入电平变化通知
11:                    IEC1bits.CNIE = 1; //使能中断    
003B94  A86096     BSET IEC1, #3
12:                    CNEN2bits.CN21IE = 1;//开启脉冲输入中断
003B96  A8A064     BSET CNEN2, #5
13:                //    CNEN1bits.CN12IE = 1; //开启电平检测
14:                    //    IEC1bits.CNIE=1
15:                }
003B98  FA8000     ULNK
003B9A  060000     RETURN
16:                
17:                //void ICN21_Configuration(void)
18:                //{
19:                //    ////    TRISBbits.TRISB9=1;//RB9 input CN21
20:                //    //    INPUT_PULSE_IN;
21:                //    //    CNPU2bits.CN21PUE=1;//使能弱上拉
22:                //    //    IPC4bits.CNIP=1;
23:                //    IFS1bits.CNIF = 0;
24:                //    //    CNEN1bits.CN0IE=1;//使能输入电平变化通知
25:                //    IEC1bits.CNIE = 1; //使能中断    
26:                //    CNEN1bits.CN12IE = 1; //开启电平检测
27:                //    //    IEC1bits.CNIE=1
28:                //}
29:                
30:                
31:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/GPRS.c  ----------------------------
1:                 #include "user.h"
2:                 #include "UART.h"
3:                 #include "GPRS.h" 
4:                 #include "25L64B.h"
5:                 #include "TIM.h"
6:                 #include "SerialBuffer.h"
7:                 #include "Miot1601.h"
8:                 #include "CheckData.h"
9:                 #include "string.h"
10:                //#include "ctype.h"
11:                const u8 GPRS_Arg1[144] = {//UTC
12:                    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
13:                    0x53, 0x54, 0x57, 0x30, 0x80, 0x8A, 0x8D, 0xAC, 0x0D, 0x00,
14:                    0x30, 0x30, 0x30, 0x0B, 0x15, 0x13, 0x87, 0x57, 0x96, 0x1F,
15:                    0x0B, 0x13, 0x46, 0x10, 0x79, 0x92, 0x5F, 0x30, 0x30, 0x32,
16:                    0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x77, 0x77,
17:                    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
18:                    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
19:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
20:                    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
21:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
22:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
23:                    0xFF, 0x30, 0x0B, 0x13, 0x71, 0x11, 0x11, 0x11, 0x1F, 0xFF,
24:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
25:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
26:                    0xFF, 0xFF, 0xCC, 0xC2
27:                };
28:                const u8 GPRS_Arg2[144] = {//miot1601
29:                    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
30:                    0x53, 0x54, 0x57, 0x30, 0xCA, 0x94, 0xEA, 0x20, 0x7A, 0x17,
31:                    0x30, 0x31, 0x30, 0x0B, 0x18, 0x25, 0x77, 0x00, 0x27, 0x1F,
32:                    0x0B, 0x13, 0x80, 0x05, 0x77, 0x50, 0x0F, 0x30, 0x30, 0x32,
33:                    0x3C, 0x00, 0xB4, 0x00, 0x58, 0x02, 0x30, 0x0D, 0x77, 0x77,
34:                    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
35:                    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
36:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
37:                    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
38:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
39:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
40:                    0xFF, 0x30, 0x0B, 0x18, 0x35, 0x77, 0x68, 0x90, 0x7F, 0xFF,
41:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
42:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
43:                    0xFF, 0xFF, 0x7B, 0xF5
44:                };
45:                
46:                const u8 GPRS_Arg3[144] = {//FOR TEST
47:                    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
48:                    0x53, 0x54, 0x57, 0x30, 0xB7, 0xF6, 0x4A, 0x44, 0xCF, 0x13,
49:                    0x30, 0x31, 0x30, 0x0B, 0x13, 0x73, 0x69, 0x53, 0x37, 0x2F,
50:                    0x0B, 0x13, 0x80, 0x05, 0x77, 0x50, 0x0F, 0x30, 0x30, 0x32,
51:                    0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x77, 0x77,
52:                    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
53:                    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
54:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
55:                    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
56:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
57:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
58:                    0xFF, 0x30, 0x0B, 0x13, 0x71, 0x11, 0x11, 0x11, 0x1F, 0xFF,
59:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
60:                    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
61:                    0xFF, 0xFF, 0x43, 0x7A
62:                };
63:                
64:                const u16 GPRS_ON_TIME = 7000; //50s 5000*0.01
65:                const u16 GPRS_ON_CHECK = 9000; //100s
66:                
67:                
68:                //u8 SendUTC[12] = "+TURONG GPOT";
69:                const u8 Ready[5] = "READY";
70:                const u8 SendON[12] = "+TURONG GPON";
71:                const u8 SendOFF[13] = "+TURONG GPOFF";
72:                const u8 ReceiveOK[6] = "+RECW0";
73:                const u8 UTCHead = 0x2D;
74:                //const u8 SendCH[12] = "+TURONG GPCH";
75:                //u8 Head2[4] = "FAIL";
76:                u8 gUARTtmp[2]; //用于存放临时变量
77:                extern u8 gAlarmVoltageAdd;
78:                //extern u8 gCurrentSampleCount;
79:                
80:                /*************************************
81:                Function: GPRS_Init 
82:                Description: GPRS模块初始化
83:                Input: 无
84:                Output: 无
85:                 *************************************/
86:                void GPRS_Init(void) {
001DF4  FA0002     LNK #0x2
87:                    u8 dat;
88:                    GP_CON_OUT;
001DF6  A962C0     BCLR TRISA, #3
89:                    GPRS_OFF;
001DF8  A962C4     BCLR LATA, #3
90:                
91:                    LK_IN;
001DFA  A8A2C9     BSET 0x2C9, #5
92:                    ANSBbits.ANSB13 = 0; //数字输入
001DFC  A9A4E3     BCLR 0x4E3, #5
93:                    //    CNPD2bits.CN22PDE = 1; //设置下拉
94:                    dat = LK;
001DFE  BFC2CB     MOV.B 0x2CB, WREG
001E00  FB8000     ZE W0, W0
001E02  DE0045     LSR W0, #5, W0
001E04  604061     AND.B W0, #0x1, W0
001E06  784F00     MOV.B W0, [W14]
95:                }
001E08  FA8000     ULNK
001E0A  060000     RETURN
96:                
97:                static bool RTCCDataIsOK(u8* input, u8 *output) {//UTC时间
001E0C  FA0006     LNK #0x6
001E0E  980710     MOV W0, [W14+2]
001E10  980721     MOV W1, [W14+4]
98:                    bool b = false;
001E12  EB4000     CLR.B W0
001E14  784F00     MOV.B W0, [W14]
99:                    if ((*(input + 2) == 0x2D)&&(*(input + 5) == 0x2D)) {
001E16  90001E     MOV [W14+2], W0
001E18  E88000     INC2 W0, W0
001E1A  784090     MOV.B [W0], W1
001E1C  B3C2D0     MOV.B #0x2D, W0
001E1E  50CF80     SUB.B W1, W0, [W15]
001E20  3A0079     BRA NZ, 0x1F14
001E22  90001E     MOV [W14+2], W0
001E24  400065     ADD W0, #0x5, W0
001E26  784090     MOV.B [W0], W1
001E28  B3C2D0     MOV.B #0x2D, W0
001E2A  50CF80     SUB.B W1, W0, [W15]
001E2C  3A0073     BRA NZ, 0x1F14
100:                       *output = ((*input - 0x30) << 4) + (*(input + 1) - 0x30);
001E2E  90001E     MOV [W14+2], W0
001E30  784010     MOV.B [W0], W0
001E32  FB8080     ZE W0, W1
001E34  2FFD00     MOV #0xFFD0, W0
001E36  408000     ADD W1, W0, W0
001E38  DD0044     SL W0, #4, W0
001E3A  784080     MOV.B W0, W1
001E3C  90001E     MOV [W14+2], W0
001E3E  E80000     INC W0, W0
001E40  784010     MOV.B [W0], W0
001E42  40C080     ADD.B W1, W0, W1
001E44  B3CD00     MOV.B #0xD0, W0
001E46  40C000     ADD.B W1, W0, W0
001E48  784080     MOV.B W0, W1
001E4A  90002E     MOV [W14+4], W0
001E4C  784801     MOV.B W1, [W0]
101:                       *(output + 1) = ((*(input + 3) - 0x30) << 4) + (*(input + 4) - 0x30);
001E4E  90002E     MOV [W14+4], W0
001E50  E80100     INC W0, W2
001E52  90001E     MOV [W14+2], W0
001E54  400063     ADD W0, #0x3, W0
001E56  784010     MOV.B [W0], W0
001E58  FB8080     ZE W0, W1
001E5A  2FFD00     MOV #0xFFD0, W0
001E5C  408000     ADD W1, W0, W0
001E5E  DD0044     SL W0, #4, W0
001E60  784080     MOV.B W0, W1
001E62  90001E     MOV [W14+2], W0
001E64  400064     ADD W0, #0x4, W0
001E66  784010     MOV.B [W0], W0
001E68  40C080     ADD.B W1, W0, W1
001E6A  B3CD00     MOV.B #0xD0, W0
001E6C  40C000     ADD.B W1, W0, W0
001E6E  784900     MOV.B W0, [W2]
102:                       *(output + 2) = ((*(input + 6) - 0x30) << 4) + (*(input + 7) - 0x30);
001E70  90002E     MOV [W14+4], W0
001E72  E88100     INC2 W0, W2
001E74  90001E     MOV [W14+2], W0
001E76  400066     ADD W0, #0x6, W0
001E78  784010     MOV.B [W0], W0
001E7A  FB8080     ZE W0, W1
001E7C  2FFD00     MOV #0xFFD0, W0
001E7E  408000     ADD W1, W0, W0
001E80  DD0044     SL W0, #4, W0
001E82  784080     MOV.B W0, W1
001E84  90001E     MOV [W14+2], W0
001E86  400067     ADD W0, #0x7, W0
001E88  784010     MOV.B [W0], W0
001E8A  40C080     ADD.B W1, W0, W1
001E8C  B3CD00     MOV.B #0xD0, W0
001E8E  40C000     ADD.B W1, W0, W0
001E90  784900     MOV.B W0, [W2]
103:                       if ((*(input + 11) == 0x3A)&&(*(input + 14) == 0x3A)) {
001E92  90001E     MOV [W14+2], W0
001E94  40006B     ADD W0, #0xB, W0
001E96  784090     MOV.B [W0], W1
001E98  B3C3A0     MOV.B #0x3A, W0
001E9A  50CF80     SUB.B W1, W0, [W15]
001E9C  3A003B     BRA NZ, 0x1F14
001E9E  90001E     MOV [W14+2], W0
001EA0  40006E     ADD W0, #0xE, W0
001EA2  784090     MOV.B [W0], W1
001EA4  B3C3A0     MOV.B #0x3A, W0
001EA6  50CF80     SUB.B W1, W0, [W15]
001EA8  3A0035     BRA NZ, 0x1F14
104:                           *(output + 3) = ((*(input + 9) - 0x30) << 4) + (*(input + 10) - 0x30);
001EAA  90002E     MOV [W14+4], W0
001EAC  400163     ADD W0, #0x3, W2
001EAE  90001E     MOV [W14+2], W0
001EB0  400069     ADD W0, #0x9, W0
001EB2  784010     MOV.B [W0], W0
001EB4  FB8080     ZE W0, W1
001EB6  2FFD00     MOV #0xFFD0, W0
001EB8  408000     ADD W1, W0, W0
001EBA  DD0044     SL W0, #4, W0
001EBC  784080     MOV.B W0, W1
001EBE  90001E     MOV [W14+2], W0
001EC0  40006A     ADD W0, #0xA, W0
001EC2  784010     MOV.B [W0], W0
001EC4  40C080     ADD.B W1, W0, W1
001EC6  B3CD00     MOV.B #0xD0, W0
001EC8  40C000     ADD.B W1, W0, W0
001ECA  784900     MOV.B W0, [W2]
105:                           *(output + 4) = ((*(input + 12) - 0x30) << 4) + (*(input + 13) - 0x30);
001ECC  90002E     MOV [W14+4], W0
001ECE  400164     ADD W0, #0x4, W2
001ED0  90001E     MOV [W14+2], W0
001ED2  40006C     ADD W0, #0xC, W0
001ED4  784010     MOV.B [W0], W0
001ED6  FB8080     ZE W0, W1
001ED8  2FFD00     MOV #0xFFD0, W0
001EDA  408000     ADD W1, W0, W0
001EDC  DD0044     SL W0, #4, W0
001EDE  784080     MOV.B W0, W1
001EE0  90001E     MOV [W14+2], W0
001EE2  40006D     ADD W0, #0xD, W0
001EE4  784010     MOV.B [W0], W0
001EE6  40C080     ADD.B W1, W0, W1
001EE8  B3CD00     MOV.B #0xD0, W0
001EEA  40C000     ADD.B W1, W0, W0
001EEC  784900     MOV.B W0, [W2]
106:                           *(output + 5) = ((*(input + 15) - 0x30) << 4) + (*(input + 16) - 0x30);
001EEE  90002E     MOV [W14+4], W0
001EF0  400165     ADD W0, #0x5, W2
001EF2  90001E     MOV [W14+2], W0
001EF4  40006F     ADD W0, #0xF, W0
001EF6  784010     MOV.B [W0], W0
001EF8  FB8080     ZE W0, W1
001EFA  2FFD00     MOV #0xFFD0, W0
001EFC  408000     ADD W1, W0, W0
001EFE  DD0044     SL W0, #4, W0
001F00  784080     MOV.B W0, W1
001F02  90001E     MOV [W14+2], W0
001F04  400070     ADD W0, #0x10, W0
001F06  784010     MOV.B [W0], W0
001F08  40C080     ADD.B W1, W0, W1
001F0A  B3CD00     MOV.B #0xD0, W0
001F0C  40C000     ADD.B W1, W0, W0
001F0E  784900     MOV.B W0, [W2]
107:                           b = true;
001F10  B3C010     MOV.B #0x1, W0
001F12  784F00     MOV.B W0, [W14]
108:                       }
109:                   }
110:                   return b;
001F14  FB801E     ZE [W14], W0
111:               }
001F16  FA8000     ULNK
001F18  060000     RETURN
112:               
113:               /*************************************
114:               Function: LKIsHigh 
115:               Description: 判断是否上线
116:               Input: 无
117:               Output: 1：发送成功
118:                *************************************/
119:               bool LKIsHigh(u16 deadline) {
001F1A  FA0006     LNK #0x6
001F1C  980720     MOV W0, [W14+4]
120:                   bool b = false;
001F1E  EB4000     CLR.B W0
001F20  984720     MOV.B W0, [W14+2]
121:                   u16 TCnt = 0;
001F22  EB0000     CLR W0
001F24  780F00     MOV W0, [W14]
122:                   StartTime3();
001F26  0708E2     RCALL StartTime3
123:               
124:                   while (gT3Count < deadline) {//50s内上线  
001F28  370012     BRA 0x1F4E
001F4E  806111     MOV 0xC22, W1
001F50  90002E     MOV [W14+4], W0
001F52  508F80     SUB W1, W0, [W15]
001F54  39FFEA     BRA NC, 0x1F2A
125:                       ClrWdt();
001F2A  FE6000     CLRWDT
126:                       if (LK) {
001F2C  BFC2CB     MOV.B 0x2CB, WREG
001F2E  B24200     AND.B #0x20, W0
001F30  E00400     CP0.B W0
001F32  32000D     BRA Z, 0x1F4E
127:                           TCnt = gT3Count;
001F34  806110     MOV 0xC22, W0
001F36  780F00     MOV W0, [W14]
128:                           while ((gT3Count - TCnt) < 10);
001F38  806110     MOV 0xC22, W0
001F3A  50001E     SUB W0, [W14], W0
001F3C  500FE9     SUB W0, #0x9, [W15]
001F3E  36FFFC     BRA LEU, 0x1F38
129:                           if (LK) {
001F40  BFC2CB     MOV.B 0x2CB, WREG
001F42  B24200     AND.B #0x20, W0
001F44  E00400     CP0.B W0
001F46  320003     BRA Z, 0x1F4E
130:                               b = true;
001F48  B3C010     MOV.B #0x1, W0
001F4A  984720     MOV.B W0, [W14+2]
131:                               break;
001F4C  370004     BRA 0x1F56
132:                           }
133:                       }
134:                   }
135:                   CloseTime3();
001F56  0708D1     RCALL CloseTime3
136:                   return b;
001F58  90402E     MOV.B [W14+2], W0
001F5A  FB8000     ZE W0, W0
137:               }
001F5C  FA8000     ULNK
001F5E  060000     RETURN
138:               
139:               /*************************************
140:               Function: CopUDPTask 
141:               Description: UDP发送采集数据任务通讯任务
142:               Input: 无
143:               Output: 无
144:                *************************************/
145:               bool CopUDPTask(u8 dat) {
001F60  FA004A     LNK #0x4A
001F62  781F88     MOV W8, [W15++]
001F64  98C720     MOV.B W0, [W14+66]
146:                   u8 receiveBuffer[60] = {0, 0, 0, 0}; //29+15=44
001F66  470064     ADD W14, #0x4, W0
001F68  28CDB1     MOV #0x8CDB, W1
001F6A  09003B     REPEAT #0x3B
001F6C  785831     MOV.B [W1++], [W0++]
001F6E  B103C0     SUB #0x3C, W0
147:                   u8 UDPHead[2] = {0x41, 0x32}; // cnt = 0;
001F70  200401     MOV #0x40, W1
001F72  40808E     ADD W1, W14, W1
001F74  B3C410     MOV.B #0x41, W0
001F76  784880     MOV.B W0, [W1]
001F78  200401     MOV #0x40, W1
001F7A  40808E     ADD W1, W14, W1
001F7C  B3C320     MOV.B #0x32, W0
001F7E  984090     MOV.B W0, [W1+1]
148:                   u8 bytes = 0, cnt;
001F80  EB4000     CLR.B W0
001F82  984730     MOV.B W0, [W14+3]
149:                   u8 FailCount = 0, sendCnt = 0; //, cnt = 0;
001F84  EB4000     CLR.B W0
001F86  984710     MOV.B W0, [W14+1]
001F88  EB4000     CLR.B W0
001F8A  784F00     MOV.B W0, [W14]
150:               //    u8 samplecnt = 0, offsetAdd = 0;
151:               
152:                   Statusbits.staGPRS = 1;
001F8C  A84C38     BSET Statusbits, #2
153:                   while (FailCount++ < 3) {
001F8E  3700A2     BRA 0x20D4
0020D4  EB4000     CLR.B W0
0020D6  98C730     MOV.B W0, [W14+67]
0020D8  90401E     MOV.B [W14+1], W0
0020DA  504FE2     SUB.B W0, #0x2, [W15]
0020DC  3E0002     BRA GTU, 0x20E2
0020DE  B3C011     MOV.B #0x1, W1
0020E0  98C731     MOV.B W1, [W14+67]
0020E2  90401E     MOV.B [W14+1], W0
0020E4  E84000     INC.B W0, W0
0020E6  984710     MOV.B W0, [W14+1]
0020E8  90C03E     MOV.B [W14+67], W0
0020EA  E00400     CP0.B W0
0020EC  3AFF51     BRA NZ, 0x1F90
154:                       cnt = 0; //刷新数据
001F90  EB4000     CLR.B W0
001F92  984720     MOV.B W0, [W14+2]
155:                       GPRS_ON; //T3Delay10ms(100);打开GPRS模块  
001F94  A862C4     BSET LATA, #3
156:                       T3Delay10ms(10); //延时100ms
001F96  2000A0     MOV #0xA, W0
001F98  0708C4     RCALL T3Delay10ms
157:                       while (!UART2DataIsGet(receiveBuffer, Ready, 5, 300)) {//是不是接收到READY
001F9A  37001B     BRA 0x1FD2
001FD2  470064     ADD W14, #0x4, W0
001FD4  2012C3     MOV #0x12C, W3
001FD6  B3C052     MOV.B #0x5, W2
001FD8  28CB61     MOV #0x8CB6, W1
001FDA  07028E     RCALL UART2DataIsGet
001FDC  E00400     CP0.B W0
001FDE  32FFDE     BRA Z, 0x1F9C
158:                           GPRS_OFF;
001F9C  A962C4     BCLR LATA, #3
159:                           T3Delay10ms(600);
001F9E  202580     MOV #0x258, W0
001FA0  0708C0     RCALL T3Delay10ms
160:                           GPRS_ON;
001FA2  A862C4     BSET LATA, #3
161:                           while (U2STAbits.URXDA)
001FA4  370001     BRA 0x1FA8
001FA8  BFC232     MOV.B U2STA, WREG
001FAA  604061     AND.B W0, #0x1, W0
001FAC  E00400     CP0.B W0
001FAE  3AFFFB     BRA NZ, 0x1FA6
162:                               IFS1bits.U2RXIF = 1; //读取完数据 
001FA6  A8C087     BSET 0x87, #6
163:                           if (cnt++ > 4) {//上线6次
001FB0  EB4000     CLR.B W0
001FB2  98CF00     MOV.B W0, [W14+72]
001FB4  90402E     MOV.B [W14+2], W0
001FB6  504FE4     SUB.B W0, #0x4, [W15]
001FB8  360002     BRA LEU, 0x1FBE
001FBA  B3C011     MOV.B #0x1, W1
001FBC  98CF01     MOV.B W1, [W14+72]
001FBE  90402E     MOV.B [W14+2], W0
001FC0  E84000     INC.B W0, W0
001FC2  984720     MOV.B W0, [W14+2]
001FC4  90C80E     MOV.B [W14+72], W0
001FC6  E00400     CP0.B W0
001FC8  320004     BRA Z, 0x1FD2
164:                               GPRS_OFF;
001FCA  A962C4     BCLR LATA, #3
165:                               return false;
001FCC  EB0080     CLR W1
001FCE  982731     MOV W1, [W14+70]
001FD0  370090     BRA 0x20F2
166:                           }
167:                       }
168:                       cnt = 0;
001FE0  EB4000     CLR.B W0
001FE2  984720     MOV.B W0, [W14+2]
169:                       T3Delay10ms(100); //延时1s  
001FE4  200640     MOV #0x64, W0
001FE6  07089D     RCALL T3Delay10ms
170:                       while (U2STAbits.URXDA)//避免错过中断接收数据
001FE8  370001     BRA 0x1FEC
001FEC  BFC232     MOV.B U2STA, WREG
001FEE  604061     AND.B W0, #0x1, W0
001FF0  E00400     CP0.B W0
001FF2  3AFFFB     BRA NZ, 0x1FEA
171:                           IFS1bits.U2RXIF = 1;
001FEA  A8C087     BSET 0x87, #6
172:                       T3Delay10ms(10); //延时1s
001FF4  2000A0     MOV #0xA, W0
001FF6  070895     RCALL T3Delay10ms
173:                       while (cnt++ < 3) {//避免发送一次单片机没有响应
001FF8  370005     BRA 0x2004
002004  EB4000     CLR.B W0
002006  98C750     MOV.B W0, [W14+69]
002008  90402E     MOV.B [W14+2], W0
00200A  504FE2     SUB.B W0, #0x2, [W15]
00200C  3E0002     BRA GTU, 0x2012
00200E  B3C011     MOV.B #0x1, W1
002010  98C751     MOV.B W1, [W14+69]
002012  90402E     MOV.B [W14+2], W0
002014  E84000     INC.B W0, W0
002016  984720     MOV.B W0, [W14+2]
002018  90C05E     MOV.B [W14+69], W0
00201A  E00400     CP0.B W0
00201C  3AFFEE     BRA NZ, 0x1FFA
174:                           UART2SendString(SendON, 12);
001FFA  B3C0C1     MOV.B #0xC, W1
001FFC  28CBB0     MOV #0x8CBB, W0
001FFE  070CFB     RCALL UART2SendString
175:                           T3Delay10ms(100); //延时1s 
002000  200640     MOV #0x64, W0
002002  07088F     RCALL T3Delay10ms
176:                       }
177:                       cnt = 0;
00201E  EB4000     CLR.B W0
002020  984720     MOV.B W0, [W14+2]
178:                       sendCnt = 0;
002022  EB4000     CLR.B W0
002024  784F00     MOV.B W0, [W14]
179:                       if (LKIsHigh(GPRS_ON_TIME))//判断LK在60s内是否上线
002026  846590     MOV 0x8CB2, W0
002028  07FF78     RCALL LKIsHigh
00202A  E00400     CP0.B W0
00202C  320045     BRA Z, 0x20B8
180:                       {
181:                           while (sendCnt++ < 3) {
00202E  370039     BRA 0x20A2
0020A2  EB4000     CLR.B W0
0020A4  98C740     MOV.B W0, [W14+68]
0020A6  B3C021     MOV.B #0x2, W1
0020A8  10CF9E     SUBR.B W1, [W14], [W15]
0020AA  3E0002     BRA GTU, 0x20B0
0020AC  B3C010     MOV.B #0x1, W0
0020AE  98C740     MOV.B W0, [W14+68]
0020B0  E84F1E     INC.B [W14], [W14]
0020B2  90C0CE     MOV.B [W14+68], W1
0020B4  E00401     CP0.B W1
0020B6  3AFFBC     BRA NZ, 0x2030
182:                               T3Delay10ms(10); //延时100ms避免GPRS准备好发送数据
002030  2000A0     MOV #0xA, W0
002032  070877     RCALL T3Delay10ms
183:                               //？？？？？？？？？？？重发机制？？？
184:                               UDPSendData(dat);//, offsetAdd);
002034  90C02E     MOV.B [W14+66], W0
002036  FB8000     ZE W0, W0
002038  07FDA6     RCALL UDPSendData
185:                               T3Delay10ms(300);
00203A  2012C0     MOV #0x12C, W0
00203C  070872     RCALL T3Delay10ms
186:                               //7F F9 02 01 00 00 00 01 00 1D 00 00 78 01 02 58 02 00 3C 03 42 C8 00 00 04 42 C8 00 00 05 41 20 00 00 06 41 20 00 00 92
187:                               bytes = UART2DataIsGet(receiveBuffer, UDPHead, 2, 100); //获取数据并校验数据          
00203E  200401     MOV #0x40, W1
002040  40808E     ADD W1, W14, W1
002042  470064     ADD W14, #0x4, W0
002044  200643     MOV #0x64, W3
002046  B3C022     MOV.B #0x2, W2
002048  070257     RCALL UART2DataIsGet
00204A  984730     MOV.B W0, [W14+3]
188:                               if (bytes > 10) {//如果有接收到数据 
00204C  90403E     MOV.B [W14+3], W0
00204E  504FEA     SUB.B W0, #0xA, [W15]
002050  360028     BRA LEU, 0x20A2
189:                                   if (receiveBuffer[bytes - 1] == Sum_Check256(receiveBuffer, bytes - 1)) { //判断校验和是否正确                        
002052  90403E     MOV.B [W14+3], W0
002054  FB8000     ZE W0, W0
002056  E90080     DEC W0, W1
002058  470064     ADD W14, #0x4, W0
00205A  408000     ADD W1, W0, W0
00205C  784410     MOV.B [W0], W8
00205E  90403E     MOV.B [W14+3], W0
002060  FB8000     ZE W0, W0
002062  E90000     DEC W0, W0
002064  780080     MOV W0, W1
002066  470064     ADD W14, #0x4, W0
002068  070B50     RCALL Sum_Check256
00206A  544F80     SUB.B W8, W0, [W15]
00206C  3A001A     BRA NZ, 0x20A2
190:                                       if (CheckSrting(receiveBuffer + 2, runingArg.gMp_id, 8)) {
00206E  470064     ADD W14, #0x4, W0
002070  E88000     INC2 W0, W0
002072  B3C082     MOV.B #0x8, W2
002074  20BAA1     MOV #0xBAA, W1
002076  070B84     RCALL CheckSrting
002078  E00400     CP0.B W0
00207A  320013     BRA Z, 0x20A2
191:                                           DUPDataChange(receiveBuffer);
00207C  470064     ADD W14, #0x4, W0
00207E  07FE32     RCALL DUPDataChange
192:                                           Statusbits.staGPRS = 0;
002080  A94C38     BCLR Statusbits, #2
193:                                           UART2SendString(SendOFF, 13);
002082  B3C0D1     MOV.B #0xD, W1
002084  28CC70     MOV #0x8CC7, W0
002086  070CB7     RCALL UART2SendString
194:                                           T3Delay10ms(200); //延时2s
002088  200C80     MOV #0xC8, W0
00208A  07084B     RCALL T3Delay10ms
195:                                           while (U2STAbits.URXDA)
00208C  370001     BRA 0x2090
002090  BFC232     MOV.B U2STA, WREG
002092  604061     AND.B W0, #0x1, W0
002094  E00400     CP0.B W0
002096  3AFFFB     BRA NZ, 0x208E
196:                                               IFS1bits.U2RXIF = 1; //读取完数据   
00208E  A8C087     BSET 0x87, #6
197:                                           GPRS_OFF; //关闭GPRS模块  
002098  A962C4     BCLR LATA, #3
198:                                           EmptyRegister1();//清除缓冲数据
00209A  07065E     RCALL EmptyRegister1
199:                                           return true;
00209C  200011     MOV #0x1, W1
00209E  982731     MOV W1, [W14+70]
0020A0  370028     BRA 0x20F2
200:                                       }
201:                                   }
202:                               }
203:                           }
204:                       }
205:                       UART2SendString(SendOFF, 13);
0020B8  B3C0D1     MOV.B #0xD, W1
0020BA  28CC70     MOV #0x8CC7, W0
0020BC  070C9C     RCALL UART2SendString
206:                       T3Delay10ms(600); //延时2s
0020BE  202580     MOV #0x258, W0
0020C0  070830     RCALL T3Delay10ms
207:                       while (U2STAbits.URXDA)
0020C2  370001     BRA 0x20C6
0020C6  BFC232     MOV.B U2STA, WREG
0020C8  604061     AND.B W0, #0x1, W0
0020CA  E00400     CP0.B W0
0020CC  3AFFFB     BRA NZ, 0x20C4
208:                           IFS1bits.U2RXIF = 1; //读取完数据   
0020C4  A8C087     BSET 0x87, #6
209:                       GPRS_OFF; //关闭GPRS模块      
0020CE  A962C4     BCLR LATA, #3
210:                       T3Delay10ms(500); //延时1s
0020D0  201F40     MOV #0x1F4, W0
0020D2  070827     RCALL T3Delay10ms
211:                   }
212:                   return false;
0020EE  EB0080     CLR W1
0020F0  982731     MOV W1, [W14+70]
0020F2  90203E     MOV [W14+70], W0
213:               }
0020F4  78044F     MOV [--W15], W8
0020F6  FA8000     ULNK
0020F8  060000     RETURN
214:               
215:               /*************************************
216:               Function: GetUTCTask 
217:               Description: 获取UTC任务
218:               Input: 无
219:               Output: 无
220:                *************************************/
221:               bool GetUTCTask(void) {
0020FA  FA00A6     LNK #0xA6
222:                   u8 RTCCtime[7] = {0x20, 0, 0, 0, 0, 0, 0}; //16-10-28 00:31:37
0020FC  470063     ADD W14, #0x3, W0
0020FE  28D171     MOV #0x8D17, W1
002100  090006     REPEAT #0x6
002102  785831     MOV.B [W1++], [W0++]
002104  B10070     SUB #0x7, W0
223:                   u8 receiveBuffer[150];
224:                   u8 bytes;
225:                   u8 cnt = 0, FailCount = 0;
002106  EB4000     CLR.B W0
002108  984710     MOV.B W0, [W14+1]
00210A  EB4000     CLR.B W0
00210C  784F00     MOV.B W0, [W14]
226:               
227:                   while (LK)//保护机制 GPRS 为插上
00210E  370001     BRA 0x2112
002112  BFC2CB     MOV.B 0x2CB, WREG
002114  B24200     AND.B #0x20, W0
002116  E00400     CP0.B W0
002118  3AFFFB     BRA NZ, 0x2110
228:                       GPRS_OFF;
002110  A962C4     BCLR LATA, #3
229:                   //写入参数
230:                   if (!ChangeGPRSArg(GPRS_Arg1))
00211A  28B020     MOV #0x8B02, W0
00211C  070111     RCALL ChangeGPRSArg
00211E  E00400     CP0.B W0
002120  3A0004     BRA NZ, 0x212A
231:                       return false;
002122  EB0000     CLR W0
002124  989720     MOV W0, [W14+164]
002126  3700AB     BRA 0x227E
232:               
233:                   while (U2STAbits.URXDA)
00212A  BFC232     MOV.B U2STA, WREG
00212C  604061     AND.B W0, #0x1, W0
00212E  E00400     CP0.B W0
002130  3AFFFB     BRA NZ, 0x2128
234:                       IFS1bits.U2RXIF = 1; //读取完数据   
002128  A8C087     BSET 0x87, #6
235:                   while (FailCount++ < 3) {
002132  37008B     BRA 0x224A
00224A  EB4080     CLR.B W1
00224C  996701     MOV.B W1, [W14+160]
00224E  B3C020     MOV.B #0x2, W0
002250  104F9E     SUBR.B W0, [W14], [W15]
002252  3E0002     BRA GTU, 0x2258
002254  B3C011     MOV.B #0x1, W1
002256  996701     MOV.B W1, [W14+160]
002258  E84F1E     INC.B [W14], [W14]
00225A  91600E     MOV.B [W14+160], W0
00225C  E00400     CP0.B W0
00225E  3AFF6A     BRA NZ, 0x2134
236:                       cnt = 0; //刷新数据
002134  EB4000     CLR.B W0
002136  984710     MOV.B W0, [W14+1]
237:                       GPRS_ON; //T3Delay10ms(100);打开GPRS模块  
002138  A862C4     BSET LATA, #3
238:                       T3Delay10ms(10); //延时100ms
00213A  2000A0     MOV #0xA, W0
00213C  0707F2     RCALL T3Delay10ms
239:                       while (!UART2DataIsGet(receiveBuffer, Ready, 5, 300)) {//是不是接收到READY
00213E  37001B     BRA 0x2176
002176  47006A     ADD W14, #0xA, W0
002178  2012C3     MOV #0x12C, W3
00217A  B3C052     MOV.B #0x5, W2
00217C  28CB61     MOV #0x8CB6, W1
00217E  0701BC     RCALL UART2DataIsGet
002180  E00400     CP0.B W0
002182  32FFDE     BRA Z, 0x2140
240:                           GPRS_OFF;
002140  A962C4     BCLR LATA, #3
241:                           T3Delay10ms(600);
002142  202580     MOV #0x258, W0
002144  0707EE     RCALL T3Delay10ms
242:                           GPRS_ON;
002146  A862C4     BSET LATA, #3
243:                           while (U2STAbits.URXDA)
002148  370001     BRA 0x214C
00214C  BFC232     MOV.B U2STA, WREG
00214E  604061     AND.B W0, #0x1, W0
002150  E00400     CP0.B W0
002152  3AFFFB     BRA NZ, 0x214A
244:                               IFS1bits.U2RXIF = 1; //读取完数据 
00214A  A8C087     BSET 0x87, #6
245:                           if (cnt++ > 1) {
002154  EB4080     CLR.B W1
002156  996721     MOV.B W1, [W14+162]
002158  90401E     MOV.B [W14+1], W0
00215A  504FE1     SUB.B W0, #0x1, [W15]
00215C  360002     BRA LEU, 0x2162
00215E  B3C010     MOV.B #0x1, W0
002160  996720     MOV.B W0, [W14+162]
002162  90401E     MOV.B [W14+1], W0
002164  E84000     INC.B W0, W0
002166  984710     MOV.B W0, [W14+1]
002168  9160AE     MOV.B [W14+162], W1
00216A  E00401     CP0.B W1
00216C  320004     BRA Z, 0x2176
246:                               GPRS_OFF;
00216E  A962C4     BCLR LATA, #3
247:                               return false;
002170  EB0000     CLR W0
002172  989720     MOV W0, [W14+164]
002174  370084     BRA 0x227E
248:                           }
249:                       }
250:                       cnt = 0;
002184  EB4000     CLR.B W0
002186  984710     MOV.B W0, [W14+1]
251:                       T3Delay10ms(100); //延时1s  
002188  200640     MOV #0x64, W0
00218A  0707CB     RCALL T3Delay10ms
252:                       while (U2STAbits.URXDA)
00218C  370001     BRA 0x2190
002190  BFC232     MOV.B U2STA, WREG
002192  604061     AND.B W0, #0x1, W0
002194  E00400     CP0.B W0
002196  3AFFFB     BRA NZ, 0x218E
253:                           IFS1bits.U2RXIF = 1; //读取完数据 
00218E  A8C087     BSET 0x87, #6
254:                       while (cnt++ < 3) {//避免发送一次单片机没有响应
002198  370005     BRA 0x21A4
0021A4  EB4080     CLR.B W1
0021A6  996711     MOV.B W1, [W14+161]
0021A8  90401E     MOV.B [W14+1], W0
0021AA  504FE2     SUB.B W0, #0x2, [W15]
0021AC  3E0002     BRA GTU, 0x21B2
0021AE  B3C010     MOV.B #0x1, W0
0021B0  996710     MOV.B W0, [W14+161]
0021B2  90401E     MOV.B [W14+1], W0
0021B4  E84000     INC.B W0, W0
0021B6  984710     MOV.B W0, [W14+1]
0021B8  91609E     MOV.B [W14+161], W1
0021BA  E00401     CP0.B W1
0021BC  3AFFEE     BRA NZ, 0x219A
255:                           UART2SendString(SendON, 12);
00219A  B3C0C1     MOV.B #0xC, W1
00219C  28CBB0     MOV #0x8CBB, W0
00219E  070C2B     RCALL UART2SendString
256:                           T3Delay10ms(100); //延时1s 
0021A0  200640     MOV #0x64, W0
0021A2  0707BF     RCALL T3Delay10ms
257:                       }
258:                       cnt = 0;
0021BE  EB4000     CLR.B W0
0021C0  984710     MOV.B W0, [W14+1]
259:                       //        StartTime3();
260:                       if (LKIsHigh(GPRS_ON_TIME)) {
0021C2  846590     MOV 0x8CB2, W0
0021C4  07FEAA     RCALL LKIsHigh
0021C6  E00400     CP0.B W0
0021C8  320031     BRA Z, 0x222C
261:                           T3Delay10ms(100); //延时5s  等待收到数据//11.27 300
0021CA  200640     MOV #0x64, W0
0021CC  0707AA     RCALL T3Delay10ms
262:                           bytes = UART2DataIsGet(receiveBuffer + 2, &UTCHead, 1, 100);
0021CE  47006A     ADD W14, #0xA, W0
0021D0  E88000     INC2 W0, W0
0021D2  200643     MOV #0x64, W3
0021D4  B3C012     MOV.B #0x1, W2
0021D6  28CDA1     MOV #0x8CDA, W1
0021D8  07018F     RCALL UART2DataIsGet
0021DA  984720     MOV.B W0, [W14+2]
263:                           if (bytes > 20) {
0021DC  90402E     MOV.B [W14+2], W0
0021DE  504FF4     SUB.B W0, #0x14, [W15]
0021E0  360025     BRA LEU, 0x222C
264:                               receiveBuffer[0] = *gUARTtmp; //2000年
0021E2  20C421     MOV #0xC42, W1
0021E4  784091     MOV.B [W1], W1
0021E6  47006A     ADD W14, #0xA, W0
0021E8  784801     MOV.B W1, [W0]
265:                               receiveBuffer[1] = *(gUARTtmp + 1); //2000年
0021EA  20C430     MOV #0xC43, W0
0021EC  784090     MOV.B [W0], W1
0021EE  47006A     ADD W14, #0xA, W0
0021F0  984011     MOV.B W1, [W0+1]
266:                               if (RTCCDataIsOK(receiveBuffer, RTCCtime + 1)) {
0021F2  470063     ADD W14, #0x3, W0
0021F4  E80080     INC W0, W1
0021F6  47006A     ADD W14, #0xA, W0
0021F8  07FE09     RCALL _RTCCDataIsOK
0021FA  E00400     CP0.B W0
0021FC  320017     BRA Z, 0x222C
267:                                   Register2Write(RTCCtime, mi_arg_add[mi_year], 6);
0021FE  846FC1     MOV 0x8DF8, W1
002200  470063     ADD W14, #0x3, W0
002202  B3C062     MOV.B #0x6, W2
002204  0703D6     RCALL Register2Write
268:                                   RefreshTime();
002206  07050F     RCALL RefreshTime
269:                                   StopRTCC();
002208  070A37     RCALL StopRTCC
270:                                   CheckRTCC();
00220A  070A0D     RCALL CheckRTCC
271:                                   Statusbits.staCheckRTCC = 0;
00220C  A90C38     BCLR Statusbits, #0
272:               //                    T3Delay10ms(100); //延时1s//11.27 100
273:                                   UART2SendString(SendOFF, 13);
00220E  B3C0D1     MOV.B #0xD, W1
002210  28CC70     MOV #0x8CC7, W0
002212  070BF1     RCALL UART2SendString
274:                                   T3Delay10ms(200); //延时2s
002214  200C80     MOV #0xC8, W0
002216  070785     RCALL T3Delay10ms
275:                                   while (U2STAbits.URXDA)
002218  370001     BRA 0x221C
00221C  BFC232     MOV.B U2STA, WREG
00221E  604061     AND.B W0, #0x1, W0
002220  E00400     CP0.B W0
002222  3AFFFB     BRA NZ, 0x221A
276:                                       IFS1bits.U2RXIF = 1; //读取完数据                 
00221A  A8C087     BSET 0x87, #6
277:                                   GPRS_OFF; //关闭GPRS模块  避免绿灯亮过久 
002224  A962C4     BCLR LATA, #3
278:                                   return true;
002226  200010     MOV #0x1, W0
002228  989720     MOV W0, [W14+164]
00222A  370029     BRA 0x227E
279:                               }
280:                           }
281:                       }
282:                       ClrWdt();
00222C  FE6000     CLRWDT
283:                       UART2SendString(SendOFF, 13);
00222E  B3C0D1     MOV.B #0xD, W1
002230  28CC70     MOV #0x8CC7, W0
002232  070BE1     RCALL UART2SendString
284:                       T3Delay10ms(200); //延时2s
002234  200C80     MOV #0xC8, W0
002236  070775     RCALL T3Delay10ms
285:                       while (U2STAbits.URXDA)
002238  370001     BRA 0x223C
00223C  BFC232     MOV.B U2STA, WREG
00223E  604061     AND.B W0, #0x1, W0
002240  E00400     CP0.B W0
002242  3AFFFB     BRA NZ, 0x223A
286:                           IFS1bits.U2RXIF = 1; //读取完数据                 
00223A  A8C087     BSET 0x87, #6
287:                       GPRS_OFF; //关闭GPRS模块  避免绿灯亮过久    
002244  A962C4     BCLR LATA, #3
288:                       T3Delay10ms(200); //延时2s
002246  200C80     MOV #0xC8, W0
002248  07076C     RCALL T3Delay10ms
289:                   }
290:                   ClrWdt();
002260  FE6000     CLRWDT
291:                   UART2SendString(SendOFF, 13);
002262  B3C0D1     MOV.B #0xD, W1
002264  28CC70     MOV #0x8CC7, W0
002266  070BC7     RCALL UART2SendString
292:                   T3Delay10ms(600); //延时1s
002268  202580     MOV #0x258, W0
00226A  07075B     RCALL T3Delay10ms
293:                   while (U2STAbits.URXDA)
00226C  370001     BRA 0x2270
002270  BFC232     MOV.B U2STA, WREG
002272  604061     AND.B W0, #0x1, W0
002274  E00400     CP0.B W0
002276  3AFFFB     BRA NZ, 0x226E
294:                       IFS1bits.U2RXIF = 1; //读取完数据        
00226E  A8C087     BSET 0x87, #6
295:                   GPRS_OFF;
002278  A962C4     BCLR LATA, #3
296:                   return false;
00227A  EB0080     CLR W1
00227C  989721     MOV W1, [W14+164]
00227E  90902E     MOV [W14+164], W0
297:               }
002280  FA8000     ULNK
002282  060000     RETURN
298:               
299:               /*************************************
300:               Function: UDPAlarmTask
301:               Description: 报警任务
302:               Input: 
303:               Output: 
304:                *************************************/
305:               bool UDPAlarmTask(void) {
002284  FA003A     LNK #0x3A
306:                   u8 receiveBuffer[50] = {0, 0, 0, 0, 0};
002286  E8800E     INC2 W14, W0
002288  28D1E1     MOV #0x8D1E, W1
00228A  090031     REPEAT #0x31
00228C  785831     MOV.B [W1++], [W0++]
00228E  B10320     SUB #0x32, W0
307:                   //    u8 headudp[2] = {0x41, 0x32};
308:                   bool b = false;
002290  EB4000     CLR.B W0
002292  984710     MOV.B W0, [W14+1]
309:                   u8 cnt = 0;
002294  EB4000     CLR.B W0
002296  784F00     MOV.B W0, [W14]
310:                   //如果有报警的参数
311:                   GPRS_ON; //打开GPRS模块  
002298  A862C4     BSET LATA, #3
312:                   T3Delay10ms(100); //延时1s 
00229A  200640     MOV #0x64, W0
00229C  070742     RCALL T3Delay10ms
313:                   while (!UART2DataIsGet(receiveBuffer, Ready, 5, 300)) {//是不是接收到READY
00229E  370019     BRA 0x22D2
0022D2  E8800E     INC2 W14, W0
0022D4  2012C3     MOV #0x12C, W3
0022D6  B3C052     MOV.B #0x5, W2
0022D8  28CB61     MOV #0x8CB6, W1
0022DA  07010E     RCALL UART2DataIsGet
0022DC  E00400     CP0.B W0
0022DE  32FFE0     BRA Z, 0x22A0
314:                       GPRS_OFF;
0022A0  A962C4     BCLR LATA, #3
315:                       T3Delay10ms(600);
0022A2  202580     MOV #0x258, W0
0022A4  07073E     RCALL T3Delay10ms
316:                       GPRS_ON;
0022A6  A862C4     BSET LATA, #3
317:                       while (U2STAbits.URXDA)
0022A8  370001     BRA 0x22AC
0022AC  BFC232     MOV.B U2STA, WREG
0022AE  604061     AND.B W0, #0x1, W0
0022B0  E00400     CP0.B W0
0022B2  3AFFFB     BRA NZ, 0x22AA
318:                           IFS1bits.U2RXIF = 1; //读取完数据 
0022AA  A8C087     BSET 0x87, #6
319:                       if (cnt++ > 1) {
0022B4  EB4000     CLR.B W0
0022B6  987F00     MOV.B W0, [W14+56]
0022B8  B3C011     MOV.B #0x1, W1
0022BA  10CF9E     SUBR.B W1, [W14], [W15]
0022BC  360002     BRA LEU, 0x22C2
0022BE  B3C010     MOV.B #0x1, W0
0022C0  987F00     MOV.B W0, [W14+56]
0022C2  E84F1E     INC.B [W14], [W14]
0022C4  90788E     MOV.B [W14+56], W1
0022C6  E00401     CP0.B W1
0022C8  320004     BRA Z, 0x22D2
320:                           GPRS_OFF;
0022CA  A962C4     BCLR LATA, #3
321:                           return false;
0022CC  EB0000     CLR W0
0022CE  981F30     MOV W0, [W14+54]
0022D0  370034     BRA 0x233A
322:                       }
323:                   }
324:                   while (cnt++ < 3) {//避免发送一次单片机没有响应
0022E0  370005     BRA 0x22EC
0022EC  EB4080     CLR.B W1
0022EE  987741     MOV.B W1, [W14+52]
0022F0  B3C020     MOV.B #0x2, W0
0022F2  104F9E     SUBR.B W0, [W14], [W15]
0022F4  3E0002     BRA GTU, 0x22FA
0022F6  B3C011     MOV.B #0x1, W1
0022F8  987741     MOV.B W1, [W14+52]
0022FA  E84F1E     INC.B [W14], [W14]
0022FC  90704E     MOV.B [W14+52], W0
0022FE  E00400     CP0.B W0
002300  3AFFF0     BRA NZ, 0x22E2
325:                       UART2SendString(SendON, 12);
0022E2  B3C0C1     MOV.B #0xC, W1
0022E4  28CBB0     MOV #0x8CBB, W0
0022E6  070B87     RCALL UART2SendString
326:                       T3Delay10ms(100); //延时1s 
0022E8  200640     MOV #0x64, W0
0022EA  07071B     RCALL T3Delay10ms
327:                   }
328:                   if (LKIsHigh(GPRS_ON_TIME))//判断LK在60s内是否上线
002302  846590     MOV 0x8CB2, W0
002304  07FE0A     RCALL LKIsHigh
002306  E00400     CP0.B W0
002308  32000B     BRA Z, 0x2320
329:                   {
330:                       b = true;
00230A  B3C010     MOV.B #0x1, W0
00230C  984710     MOV.B W0, [W14+1]
331:                       T3Delay10ms(100); //延时1s
00230E  200640     MOV #0x64, W0
002310  070708     RCALL T3Delay10ms
332:                       UDPSendData(1, gAlarmVoltageAdd, 1);
002312  BFCC44     MOV.B gAlarmVoltageAdd, WREG
002314  FB8080     ZE W0, W1
002316  200012     MOV #0x1, W2
002318  200010     MOV #0x1, W0
00231A  07FC35     RCALL UDPSendData
333:                       //        if (UDPReceiveData(headudp, 2, receiveBuffer)) {
334:                       //            if (CheckSrting(receiveBuffer + 2, runingArg.gMp_id, 8)) {
335:                       //                DUPDataChange(receiveBuffer);}
336:                       Statusbits.staAlarm = 1;
00231C  A86C38     BSET Statusbits, #3
00231E  370001     BRA 0x2322
337:                   } else
338:                       Statusbits.staAlarm = 0;
002320  A96C38     BCLR Statusbits, #3
339:                   ClrWdt();
002322  FE6000     CLRWDT
340:                   T3Delay10ms(100); //延时2s 保证数据发送成功  
002324  200640     MOV #0x64, W0
002326  0706FD     RCALL T3Delay10ms
341:                   UART2SendString(SendOFF, 13);
002328  B3C0D1     MOV.B #0xD, W1
00232A  28CC70     MOV #0x8CC7, W0
00232C  070B64     RCALL UART2SendString
342:                   T3Delay10ms(200); //延时2s 保证数据发送成功   
00232E  200C80     MOV #0xC8, W0
002330  0706F8     RCALL T3Delay10ms
343:                   GPRS_OFF; //关闭GPRS模块
002332  A962C4     BCLR LATA, #3
344:                   return b;
002334  90401E     MOV.B [W14+1], W0
002336  FB8000     ZE W0, W0
002338  981F30     MOV W0, [W14+54]
00233A  90183E     MOV [W14+54], W0
345:               }
00233C  FA8000     ULNK
00233E  060000     RETURN
346:               ///*************************************
347:               //Function: CopTCPTask 
348:               //Description: 
349:               //Input: 无
350:               //Output: 无
351:               // *************************************/
352:               //bool CopTCPTask(void) {
353:               //    bool b = false;
354:               //    u8 sendData[152];
355:               //    u8 flag = 0; //hook
356:               //    u8 bytes, mode;
357:               //
358:               //    GPRS_ON; //打开GPRS模块  
359:               //
360:               //    if (LKIsHigh())//判断LK在60s内是否上线
361:               //    {
362:               //        //        ClrWdt(); //清除看门狗
363:               //        b = true;
364:               //        Delay100ms(1); //延时100ms 
365:               //
366:               //        //选择模式
367:               //        Register2Read(&mode, mi_arg_add[mi_mode], 1); //参数表中获取模式
368:               //        if (!mode)//主模式 
369:               //            TCP_43_Send();        
370:               //        do {
371:               ////            Register2Read(&tmp, 0x207, 1); //获取参数表中的仪表地址
372:               //            bytes = SerialDataIsGet(BufferRead_UART2, sendData, &runingArg.gMp_add, 1, CopTCPDeadline);
373:               //            if (bytes) {
374:               //                if (CheckIsRight(CRC16_Check, sendData, bytes - 2)) {
375:               //                    flag = CopFun(sendData, bytes, GPRS); //如果是退出设置，gChangeParameterFlag=0；
376:               //                    if (flag == 'b') //如果gChangeParameterFlag为0，立马退出
377:               //                        break;
378:               //                }
379:               //            } else
380:               //                break;
381:               //        } while (!flag);
382:               //    } else
383:               //        ClrWdt(); //清除看门狗
384:               //    Delay100ms(1); //延时500ms 保证数据发送成功
385:               //    GPRS_OFF; //关闭GPRS模块
386:               //    return b;
387:               //}
388:               
389:               bool ChangeGPRSArg(const u8 * dat) {
002340  FA009E     LNK #0x9E
002342  988F40     MOV W0, [W14+152]
390:                   u8 receiveBuffer[150] = {0, 0, 0};
002344  E8000E     INC W14, W0
002346  28D501     MOV #0x8D50, W1
002348  090095     REPEAT #0x95
00234A  785831     MOV.B [W1++], [W0++]
00234C  B10960     SUB #0x96, W0
391:                   u8 cnt = 0;
00234E  EB4000     CLR.B W0
002350  784F00     MOV.B W0, [W14]
392:               
393:                   while (LK)
002352  370001     BRA 0x2356
002356  BFC2CB     MOV.B 0x2CB, WREG
002358  B24200     AND.B #0x20, W0
00235A  E00400     CP0.B W0
00235C  3AFFFB     BRA NZ, 0x2354
394:                       GPRS_OFF;
002354  A962C4     BCLR LATA, #3
395:                   T3Delay10ms(100); //1s
00235E  200640     MOV #0x64, W0
002360  0706E0     RCALL T3Delay10ms
396:                   GPRS_ON; //打开GPRS模块 
002362  A862C4     BSET LATA, #3
397:                   while (U2STAbits.URXDA)
002364  370001     BRA 0x2368
002368  BFC232     MOV.B U2STA, WREG
00236A  604061     AND.B W0, #0x1, W0
00236C  E00400     CP0.B W0
00236E  3AFFFB     BRA NZ, 0x2366
398:                       IFS1bits.U2RXIF = 1; //读取完数据 
002366  A8C087     BSET 0x87, #6
399:                   while (!UART2DataIsGet(receiveBuffer, Ready, 5, 200)) { //如果返回READY
002370  370019     BRA 0x23A4
0023A4  E8000E     INC W14, W0
0023A6  200C83     MOV #0xC8, W3
0023A8  B3C052     MOV.B #0x5, W2
0023AA  28CB61     MOV #0x8CB6, W1
0023AC  0700A5     RCALL UART2DataIsGet
0023AE  E00400     CP0.B W0
0023B0  32FFE0     BRA Z, 0x2372
400:                       GPRS_OFF; //关闭GPRS模块 
002372  A962C4     BCLR LATA, #3
401:                       T3Delay10ms(600); //10s
002374  202580     MOV #0x258, W0
002376  0706D5     RCALL T3Delay10ms
402:                       GPRS_ON; //打开GPRS模块 
002378  A862C4     BSET LATA, #3
403:                       while (U2STAbits.URXDA)
00237A  370001     BRA 0x237E
00237E  BFC232     MOV.B U2STA, WREG
002380  604061     AND.B W0, #0x1, W0
002382  E00400     CP0.B W0
002384  3AFFFB     BRA NZ, 0x237C
404:                           IFS1bits.U2RXIF = 1; //读取完数据 
00237C  A8C087     BSET 0x87, #6
405:                       if (cnt++ > 2) {//如果3次都没有收到数据，说明GPRS的波特率有问题，GPRS没有插上
002386  EB4000     CLR.B W0
002388  995F40     MOV.B W0, [W14+156]
00238A  B3C021     MOV.B #0x2, W1
00238C  10CF9E     SUBR.B W1, [W14], [W15]
00238E  360002     BRA LEU, 0x2394
002390  B3C010     MOV.B #0x1, W0
002392  995F40     MOV.B W0, [W14+156]
002394  E84F1E     INC.B [W14], [W14]
002396  9158CE     MOV.B [W14+156], W1
002398  E00401     CP0.B W1
00239A  320004     BRA Z, 0x23A4
406:                           GPRS_OFF;
00239C  A962C4     BCLR LATA, #3
407:                           return false;
00239E  EB0000     CLR W0
0023A0  988F50     MOV W0, [W14+154]
0023A2  37002D     BRA 0x23FE
408:                       }
409:                   }
410:                   T3Delay10ms(100); //延时1s
0023B2  200640     MOV #0x64, W0
0023B4  0706B6     RCALL T3Delay10ms
411:                   UART2SendString(dat, 144); //发送修改参数值指令
0023B6  B3C901     MOV.B #0x90, W1
0023B8  90884E     MOV [W14+152], W0
0023BA  070B1D     RCALL UART2SendString
412:                   while (U2STAbits.URXDA)
0023BC  370001     BRA 0x23C0
0023C0  BFC232     MOV.B U2STA, WREG
0023C2  604061     AND.B W0, #0x1, W0
0023C4  E00400     CP0.B W0
0023C6  3AFFFB     BRA NZ, 0x23BE
413:                       IFS1bits.U2RXIF = 1; //读取完数据 
0023BE  A8C087     BSET 0x87, #6
414:                   while (!UART2DataIsGet(receiveBuffer, ReceiveOK, 6, 200))//如果修改成功
0023C8  370010     BRA 0x23EA
0023EA  E8000E     INC W14, W0
0023EC  200C83     MOV #0xC8, W3
0023EE  B3C062     MOV.B #0x6, W2
0023F0  28CD41     MOV #0x8CD4, W1
0023F2  070082     RCALL UART2DataIsGet
0023F4  E00400     CP0.B W0
0023F6  32FFEA     BRA Z, 0x23CC
415:                   {
416:                       while (U2STAbits.URXDA)
0023CC  BFC232     MOV.B U2STA, WREG
0023CE  604061     AND.B W0, #0x1, W0
0023D0  E00400     CP0.B W0
0023D2  3AFFFB     BRA NZ, 0x23CA
417:                           IFS1bits.U2RXIF = 1; //读取完数据    
0023CA  A8C087     BSET 0x87, #6
418:                       UART2SendString(dat, 144);
0023D4  B3C901     MOV.B #0x90, W1
0023D6  90884E     MOV [W14+152], W0
0023D8  070B0E     RCALL UART2SendString
419:                       T3Delay10ms(100);
0023DA  200640     MOV #0x64, W0
0023DC  0706A2     RCALL T3Delay10ms
420:                       while (U2STAbits.URXDA)
0023DE  370001     BRA 0x23E2
0023E2  BFC232     MOV.B U2STA, WREG
0023E4  604061     AND.B W0, #0x1, W0
0023E6  E00400     CP0.B W0
0023E8  3AFFFB     BRA NZ, 0x23E0
421:                           IFS1bits.U2RXIF = 1; //读取完数据 
0023E0  A8C087     BSET 0x87, #6
422:                   }
423:                   GPRS_OFF;
0023F8  A962C4     BCLR LATA, #3
424:                   return true;
0023FA  200011     MOV #0x1, W1
0023FC  988F51     MOV W1, [W14+154]
0023FE  90885E     MOV [W14+154], W0
425:               }
002400  FA8000     ULNK
002402  060000     RETURN
426:               
427:               
428:               ///*************************************
429:               //Function: UDPAlarmTask
430:               //Description: 报警任务
431:               //Input: 
432:               //Output: 
433:               // *************************************/
434:               //void UDPAlarmTask(void) {
435:               //    u8 receiveBuffer[50] = {0, 0, 0, 0, 0};
436:               //    u8 headudp[2] = {0x41, 0x32};
437:               //    //如果有报警的参数
438:               //    do{
439:               //        
440:               //    }while(FLagArgbits.talarmFlag);
441:               //            
442:               //    if (AlarmArgbits.ATF || AlarmArgbits.APF) {
443:               //        GPRS_ON; //打开GPRS模块  
444:               //        if (LKIsHigh(GPRS_ON_TIME))//判断LK在60s内是否上线
445:               //        {
446:               //            U2STAbits.UTXEN = 1; //关闭串口以免设备一串口供电
447:               //            IEC1bits.U2RXIE = 1; //开启中断
448:               //            if (AlarmArgbits.ATF) {
449:               //                UDPSendData(AlarmArgbits.ATF, AlarmArgbits.ATC);
450:               //                if (UDPReceiveData(headudp, 2, receiveBuffer)) {
451:               //                    if (CheckSrting(receiveBuffer + 2, runingArg.gMp_id, 8)) {
452:               //                        DUPDataChange(receiveBuffer);
453:               //                        Statusbits.staAlarm = 0;
454:               //                    }
455:               //                } else
456:               //                    Statusbits.staAlarm = 1;
457:               //            }
458:               //            if (AlarmArgbits.APF) {
459:               //                UDPSendData(AlarmArgbits.APF, AlarmArgbits.APC);
460:               //                if (UDPReceiveData(headudp, 2, receiveBuffer)) {
461:               //                    if (CheckSrting(receiveBuffer + 2, runingArg.gMp_id, 8)) {
462:               //                        Statusbits.staAlarm = 0;
463:               //                        DUPDataChange(receiveBuffer);
464:               //                    } else
465:               //                        Statusbits.staAlarm = 1;
466:               //                }
467:               //            }
468:               //            IEC1bits.U2RXIE = 0; //关闭中断
469:               //            U2STAbits.UTXEN = 0; //关闭串口以免设备一串口供电
470:               //        } else
471:               //            Statusbits.staAlarm = 0;
472:               //        T3Delay10ms(1); //延时500ms 保证数据发送成功        
473:               //        AlarmArgbits.ATF = 0;
474:               //        AlarmArgbits.APF = 0;
475:               //        ClrWdt();
476:               //        GPRS_OFF; //关闭GPRS模块
477:               //    }
478:               //}
479:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/DeepSleep.c  -----------------------
1:                 /* 
2:                  * File:   DeepSleep.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年7月2日, 下午2:00
6:                  */
7:                 
8:                 #include "user.h"
9:                 //#include "p24FV32KA301.h"
10:                
11:                
12:                void Start_Sleep(void)
13:                {
003B00  FA0000     LNK #0x0
14:                //    DSCONbits.DSEN=1;
15:                //    Sleep();//#define Sleep() {__asm__ volatile ("pwrsav #0");}
16:                    
17:                    asm("bset DSCON, #15");
003B02  A8E759     BSET 0x759, #7
18:                    asm("nop");
003B04  000000     NOP
19:                    asm("nop");
003B06  000000     NOP
20:                    asm("nop");
003B08  000000     NOP
21:                    asm("pwrsav #0");
003B0A  FE4000     PWRSAV #0
22:                    
23:                //    asm("disi #4");
24:                //    asm("bset DSCON, #15");
25:                //    asm("nop");
26:                //    asm("nop");
27:                //    asm("btss INTTREG, #15");
28:                //    asm("pwrsav #0");
29:                
30:                }
003B0C  FA8000     ULNK
003B0E  060000     RETURN
31:                
32:                void Start_nod(void)//进入打盹模式
33:                {
003B10  FA0000     LNK #0x0
34:                    CLKDIVbits.DOZEN=1;
003B12  A86745     BSET 0x745, #3
35:                //    CLKDIVbits.DOZE//1:1 是默认设置
36:                    //关闭部分时钟源
37:                    PMD1bits.T2MD=1;
003B14  A88771     BSET 0x771, #4
38:                    PMD1bits.T3MD=1;
003B16  A8A771     BSET 0x771, #5
39:                    PMD1bits.SPI1MD=1;
003B18  A86770     BSET PMD1, #3
40:                //    PMD1bits.U1MD=1;
41:                    PMD1bits.U2MD=1;
003B1A  A8C770     BSET PMD1, #6
42:                //    PMD2bits.IC2MD=0;
43:                    
44:                }
003B1C  FA8000     ULNK
003B1E  060000     RETURN
45:                
46:                void  Start_idle(void)
47:                {
003B20  FA0000     LNK #0x0
48:                    Idle();
003B22  FE4001     PWRSAV #1
49:                    //关闭部分时钟源
50:                //    PMD1bits.T2MD=1;
51:                //    PMD1bits.T3MD=1;
52:                    PMD1bits.SPI1MD=1;
003B24  A86770     BSET PMD1, #3
53:                    PMD1bits.ADC1MD=1;
003B26  A80770     BSET PMD1, #0
54:                    PMD1bits.I2C1MD=1;
003B28  A8E770     BSET PMD1, #7
55:                    PMD1bits.SPI2MD=1;
003B2A  A88770     BSET PMD1, #4
56:                    PMD1bits.T4MD=1;
003B2C  A8C771     BSET 0x771, #6
57:                    PMD1bits.T5MD=1;
003B2E  A8E771     BSET 0x771, #7
58:                //    PMD1bits.T1MD=1;//?
59:                    PMD1bits.U1MD=1;//?
003B30  A8A770     BSET PMD1, #5
60:                //    PMD2bits.IC2MD=1;//?    
61:                //    PMD3bits.RTCCMD=1; 
62:                //    PMD1bits.U2MD=1;
63:                    PMD2bits.IC1MD=1;
003B32  A80773     BSET 0x773, #0
64:                    PMD2bits.IC3MD=1;
003B34  A84773     BSET 0x773, #2
65:                    PMD2bits.OC1MD=1;
003B36  A80772     BSET PMD2, #0
66:                    PMD2bits.OC2MD=1;
003B38  A82772     BSET PMD2, #1
67:                    PMD2bits.OC3MD=1;
003B3A  A84772     BSET PMD2, #2
68:                    PMD3bits.CRCPMD=1;
003B3C  A8E774     BSET PMD3, #7
69:                    PMD3bits.I2C2MD=1;
003B3E  A82774     BSET PMD3, #1
70:                    PMD3bits.CMPMD=1;   
003B40  A84775     BSET 0x775, #2
71:                }
003B42  FA8000     ULNK
003B44  060000     RETURN
72:                
73:                
74:                
75:                
76:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/Common.c  --------------------------
1:                 #include "user.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: 浮点数转化为char数组
6:                 Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
7:                 Output: 输出数值
8:                  *************************************/
9:                 void FloatToChar(float *f, u8 *ch) {
0033E4  FA0008     LNK #0x8
0033E6  980720     MOV W0, [W14+4]
0033E8  980731     MOV W1, [W14+6]
10:                    u8 count;
11:                    void * pf;
12:                    pf = f;
0033EA  90002E     MOV [W14+4], W0
0033EC  780F00     MOV W0, [W14]
13:                
14:                    for (count = 0; count < 4; count++) {
0033EE  EB4000     CLR.B W0
0033F0  984720     MOV.B W0, [W14+2]
0033F2  37000E     BRA 0x3410
00340A  90402E     MOV.B [W14+2], W0
00340C  E84000     INC.B W0, W0
00340E  984720     MOV.B W0, [W14+2]
003410  90402E     MOV.B [W14+2], W0
003412  504FE3     SUB.B W0, #0x3, [W15]
003414  36FFEF     BRA LEU, 0x33F4
15:                        *(ch + count) = *((u8 *) pf + 3 - count);
0033F4  90402E     MOV.B [W14+2], W0
0033F6  FB8000     ZE W0, W0
0033F8  780080     MOV W0, W1
0033FA  90003E     MOV [W14+6], W0
0033FC  408080     ADD W1, W0, W1
0033FE  90402E     MOV.B [W14+2], W0
003400  FB8000     ZE W0, W0
003402  10001E     SUBR W0, [W14], W0
003404  400063     ADD W0, #0x3, W0
003406  784010     MOV.B [W0], W0
003408  784880     MOV.B W0, [W1]
16:                    }
17:                }
003416  FA8000     ULNK
003418  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char数组转化为浮点数 
22:                Input: 输出数值    模式：4 单精度浮点数 8 双精度浮点数 
23:                Output: 输入浮点数
24:                 *************************************/
25:                void CharToFloat(float *f, u8 *ch) {
00341A  FA0008     LNK #0x8
00341C  980720     MOV W0, [W14+4]
00341E  980731     MOV W1, [W14+6]
26:                    u8 count;
27:                    void *pf;
28:                    pf = f;
003420  90002E     MOV [W14+4], W0
003422  780F00     MOV W0, [W14]
29:                
30:                    for (count = 0; count < 4; count++) {
003424  EB4000     CLR.B W0
003426  984720     MOV.B W0, [W14+2]
003428  37000F     BRA 0x3448
003442  90402E     MOV.B [W14+2], W0
003444  E84000     INC.B W0, W0
003446  984720     MOV.B W0, [W14+2]
003448  90402E     MOV.B [W14+2], W0
00344A  504FE3     SUB.B W0, #0x3, [W15]
00344C  36FFEE     BRA LEU, 0x342A
31:                        *((u8 *) pf + count) = *(ch + 3 - count);
00342A  90402E     MOV.B [W14+2], W0
00342C  FB8000     ZE W0, W0
00342E  780080     MOV W0, W1
003430  78001E     MOV [W14], W0
003432  408100     ADD W1, W0, W2
003434  90402E     MOV.B [W14+2], W0
003436  FB8080     ZE W0, W1
003438  90003E     MOV [W14+6], W0
00343A  500001     SUB W0, W1, W0
00343C  400063     ADD W0, #0x3, W0
00343E  784010     MOV.B [W0], W0
003440  784900     MOV.B W0, [W2]
32:                    }
33:                }
00344E  FA8000     ULNK
003450  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: 浮点数转化为char数组
38:                Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
39:                Output: 输出数值
40:                 *************************************/
41:                void DoubleToChar(long double *d, u8 *ch) {
003452  FA0008     LNK #0x8
003454  980720     MOV W0, [W14+4]
003456  980731     MOV W1, [W14+6]
42:                    u8 count;
43:                    void * pf;
44:                    pf = d;
003458  90002E     MOV [W14+4], W0
00345A  780F00     MOV W0, [W14]
45:                
46:                    for (count = 0; count < 8; count++) {
00345C  EB4000     CLR.B W0
00345E  984720     MOV.B W0, [W14+2]
003460  37000E     BRA 0x347E
003478  90402E     MOV.B [W14+2], W0
00347A  E84000     INC.B W0, W0
00347C  984720     MOV.B W0, [W14+2]
00347E  90402E     MOV.B [W14+2], W0
003480  504FE7     SUB.B W0, #0x7, [W15]
003482  36FFEF     BRA LEU, 0x3462
47:                        *(ch + count) = *((u8 *) pf + 7 - count);
003462  90402E     MOV.B [W14+2], W0
003464  FB8000     ZE W0, W0
003466  780080     MOV W0, W1
003468  90003E     MOV [W14+6], W0
00346A  408080     ADD W1, W0, W1
00346C  90402E     MOV.B [W14+2], W0
00346E  FB8000     ZE W0, W0
003470  10001E     SUBR W0, [W14], W0
003472  400067     ADD W0, #0x7, W0
003474  784010     MOV.B [W0], W0
003476  784880     MOV.B W0, [W1]
48:                    }
49:                }
003484  FA8000     ULNK
003486  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 16进制转化为10进制
54:                Input: 数据，字节数
55:                Output: 输出数值
56:                 *************************************/
57:                u8 HCD(u8 dat) {
003488  FA0002     LNK #0x2
00348A  784F00     MOV.B W0, [W14]
58:                    return ((dat >> 4)&0x0f)*10 + (dat & 0x0f);
00348C  FB801E     ZE [W14], W0
00348E  DE0044     LSR W0, #4, W0
003490  FB8000     ZE W0, W0
003492  60006F     AND W0, #0xF, W0
003494  B9006A     MUL.SU W0, #10, W0
003496  784080     MOV.B W0, W1
003498  78401E     MOV.B [W14], W0
00349A  60406F     AND.B W0, #0xF, W0
00349C  40C000     ADD.B W1, W0, W0
00349E  FB8000     ZE W0, W0
59:                }
0034A0  FA8000     ULNK
0034A2  060000     RETURN
60:                
61:                /*************************************
62:                Function: DataIsVaild 
63:                Description: 判断数据是否有效
64:                Input: 是否
65:                Output: 输出数值
66:                 *************************************/
67:                bool DataIsVaild(u16 dat, u16 max, u16 min) {
0034A4  FA0008     LNK #0x8
0034A6  780F00     MOV W0, [W14]
0034A8  980711     MOV W1, [W14+2]
0034AA  980722     MOV W2, [W14+4]
68:                    if (dat > max) return false;
0034AC  90001E     MOV [W14+2], W0
0034AE  100F9E     SUBR W0, [W14], [W15]
0034B0  360003     BRA LEU, 0x34B8
0034B2  EB0000     CLR W0
0034B4  980730     MOV W0, [W14+6]
0034B6  370008     BRA 0x34C8
69:                    else if (dat < min) return false;
0034B8  90002E     MOV [W14+4], W0
0034BA  100F9E     SUBR W0, [W14], [W15]
0034BC  310003     BRA C, 0x34C4
0034BE  EB0000     CLR W0
0034C0  980730     MOV W0, [W14+6]
0034C2  370002     BRA 0x34C8
70:                    return true;
0034C4  200010     MOV #0x1, W0
0034C6  980730     MOV W0, [W14+6]
0034C8  90003E     MOV [W14+6], W0
71:                }
0034CA  FA8000     ULNK
0034CC  060000     RETURN
72:                
73:                /*************************************
74:                Function: SetVaildData 
75:                Description: 根据阀值设置参数
76:                Input: 是否
77:                Output: 输出数值
78:                 *************************************/
79:                void SetVaildData(u8 * dat, u32 max, u16 min) {
0034CE  FA000A     LNK #0xA
0034D0  980710     MOV W0, [W14+2]
0034D2  980722     MOV W2, [W14+4]
0034D4  980733     MOV W3, [W14+6]
0034D6  980741     MOV W1, [W14+8]
80:                    u16 tmp = (*dat << 8) + *(dat + 1);
0034D8  90001E     MOV [W14+2], W0
0034DA  784010     MOV.B [W0], W0
0034DC  FB8000     ZE W0, W0
0034DE  DD00C8     SL W0, #8, W1
0034E0  90001E     MOV [W14+2], W0
0034E2  E80000     INC W0, W0
0034E4  784010     MOV.B [W0], W0
0034E6  FB8000     ZE W0, W0
0034E8  408000     ADD W1, W0, W0
0034EA  780F00     MOV W0, [W14]
81:                
82:                    if (tmp > max) {
0034EC  78001E     MOV [W14], W0
0034EE  B80161     MUL.UU W0, #1, W2
0034F0  90002E     MOV [W14+4], W0
0034F2  9000BE     MOV [W14+6], W1
0034F4  510F80     SUB W2, W0, [W15]
0034F6  598F81     SUBB W3, W1, [W15]
0034F8  36000E     BRA LEU, 0x3516
83:                        *dat = max >> 8;
0034FA  90002E     MOV [W14+4], W0
0034FC  9000BE     MOV [W14+6], W1
0034FE  DD0948     SL W1, #8, W2
003500  DE0048     LSR W0, #8, W0
003502  710000     IOR W2, W0, W0
003504  DE08C8     LSR W1, #8, W1
003506  784080     MOV.B W0, W1
003508  90001E     MOV [W14+2], W0
00350A  784801     MOV.B W1, [W0]
84:                        *(dat + 1) = max & 0x00ff;
00350C  90001E     MOV [W14+2], W0
00350E  E80080     INC W0, W1
003510  90002E     MOV [W14+4], W0
003512  784880     MOV.B W0, [W1]
003514  37000C     BRA 0x352E
85:                    } else if (tmp < min) {
003516  90004E     MOV [W14+8], W0
003518  100F9E     SUBR W0, [W14], [W15]
00351A  310009     BRA C, 0x352E
86:                        *dat = min >> 8;
00351C  90004E     MOV [W14+8], W0
00351E  DE0048     LSR W0, #8, W0
003520  784080     MOV.B W0, W1
003522  90001E     MOV [W14+2], W0
003524  784801     MOV.B W1, [W0]
87:                        *(dat + 1) = min & 0x00ff;
003526  90001E     MOV [W14+2], W0
003528  E80080     INC W0, W1
00352A  90004E     MOV [W14+8], W0
00352C  784880     MOV.B W0, [W1]
88:                    }
89:                }
00352E  FA8000     ULNK
003530  060000     RETURN
90:                
91:                
92:                //128.138.141.172 13
93:                //??OK??57682 16-10-21 07:16:25 17 0 0 282.4 UTC(NIST) * ???SHUTDOWN??
94:                /*获取UTC时间*/
95:                u32 GetUTCTime(void)
96:                {
003532  FA0000     LNK #0x0
97:                //设置GPRS参数
98:                    
99:                //GPRS上线
100:                   
101:               //接收数据并处理 13 14:47:33 DAT ---> <51> .57682 16-10-21 06:47:36 17 0 0 234.2 UTC(NIST) * .
102:               
103:               //设置GPRS参数
104:               
105:               //GPRS下线    
106:               }
003534  FA8000     ULNK
003536  060000     RETURN
107:               
108:               
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/CheckData.c  -----------------------
1:                 #include "user.h"
2:                 #include "UART.h"
3:                 
4:                 /****************************************************************************
5:                 名称: CRC16()
6:                 说明: CRC16校验程序
7:                 参数: *CRC_Buf:数据地址
8:                       CRC_Leni:数据长度
9:                 返回: CRC校验值
10:                 *****************************************************************************/
11:                u16 CRC16_Check(u8 *CRC_Buf, u16 CRC_Leni) {
003682  FA000A     LNK #0xA
003684  980730     MOV W0, [W14+6]
003686  980741     MOV W1, [W14+8]
12:                    u16 i, j;
13:                    u16 CRC_Sumx;
14:                
15:                    CRC_Sumx = 0xFFFF;
003688  EB8000     SETM W0
00368A  780F00     MOV W0, [W14]
16:                    for (i = 0; i < CRC_Leni; i++) {
00368C  EB0000     CLR W0
00368E  980720     MOV W0, [W14+4]
003690  37001F     BRA 0x36D0
0036CA  90002E     MOV [W14+4], W0
0036CC  E80000     INC W0, W0
0036CE  980720     MOV W0, [W14+4]
0036D0  9000AE     MOV [W14+4], W1
0036D2  90004E     MOV [W14+8], W0
0036D4  508F80     SUB W1, W0, [W15]
0036D6  39FFDD     BRA NC, 0x3692
17:                        CRC_Sumx ^= *(CRC_Buf + i); //异或
003692  9000AE     MOV [W14+4], W1
003694  90003E     MOV [W14+6], W0
003696  408000     ADD W1, W0, W0
003698  784010     MOV.B [W0], W0
00369A  FB8000     ZE W0, W0
00369C  680F1E     XOR W0, [W14], [W14]
18:                        for (j = 0; j < 8; j++) {
00369E  EB0000     CLR W0
0036A0  980710     MOV W0, [W14+2]
0036A2  370010     BRA 0x36C4
0036BE  90001E     MOV [W14+2], W0
0036C0  E80000     INC W0, W0
0036C2  980710     MOV W0, [W14+2]
0036C4  90001E     MOV [W14+2], W0
0036C6  500FE7     SUB W0, #0x7, [W15]
0036C8  36FFED     BRA LEU, 0x36A4
19:                            if (CRC_Sumx & 0x01) {
0036A4  78009E     MOV [W14], W1
0036A6  608061     AND W1, #0x1, W0
0036A8  E00400     CP0.B W0
0036AA  320006     BRA Z, 0x36B8
20:                                CRC_Sumx >>= 1;
0036AC  78001E     MOV [W14], W0
0036AE  D10000     LSR W0, W0
0036B0  780F00     MOV W0, [W14]
21:                                CRC_Sumx ^= 0xA001;
0036B2  2A0010     MOV #0xA001, W0
0036B4  680F1E     XOR W0, [W14], [W14]
0036B6  370003     BRA 0x36BE
22:                            } else {
23:                                CRC_Sumx >>= 1;
0036B8  78001E     MOV [W14], W0
0036BA  D10000     LSR W0, W0
0036BC  780F00     MOV W0, [W14]
24:                            }
25:                        }
26:                    }
27:                    return (CRC_Sumx);
0036D8  78001E     MOV [W14], W0
28:                }
0036DA  FA8000     ULNK
0036DC  060000     RETURN
29:                
30:                /*************************************
31:                Function: Sum_Check 
32:                Description: 计算和校验的数值，
33:                Input: frame：数据，bytes：字节数 
34:                Output: 和校验结果值
35:                 *************************************/
36:                u16 Sum_Check(u8 *frame, u16 bytes) {
0036DE  FA0006     LNK #0x6
0036E0  980710     MOV W0, [W14+2]
0036E2  980721     MOV W1, [W14+4]
37:                    u16 cksum = 0;
0036E4  EB0000     CLR W0
0036E6  780F00     MOV W0, [W14]
38:                
39:                    while (bytes > 0) {
0036E8  37000A     BRA 0x36FE
0036FE  90002E     MOV [W14+4], W0
003700  E00000     CP0 W0
003702  3AFFF3     BRA NZ, 0x36EA
40:                        cksum += *frame++;
0036EA  90001E     MOV [W14+2], W0
0036EC  784010     MOV.B [W0], W0
0036EE  FB8000     ZE W0, W0
0036F0  400F1E     ADD W0, [W14], [W14]
0036F2  90001E     MOV [W14+2], W0
0036F4  E80000     INC W0, W0
0036F6  980710     MOV W0, [W14+2]
41:                        bytes--;
0036F8  90002E     MOV [W14+4], W0
0036FA  E90000     DEC W0, W0
0036FC  980720     MOV W0, [W14+4]
42:                    }
43:                    return cksum;
003704  78001E     MOV [W14], W0
44:                }
003706  FA8000     ULNK
003708  060000     RETURN
45:                
46:                /*************************************
47:                Function: Sum_Check256
48:                Description: 计算和校验的数值，
49:                Input: frame：数据，bytes：字节数 
50:                Output: 和校验结果值
51:                 *************************************/
52:                u8 Sum_Check256(u8 *frame, u16 bytes) {
00370A  FA0006     LNK #0x6
00370C  980710     MOV W0, [W14+2]
00370E  980721     MOV W1, [W14+4]
53:                    u16 ckSum = 0;
003710  EB0000     CLR W0
003712  780F00     MOV W0, [W14]
54:                    //    u8 modDat;
55:                
56:                    while (bytes > 0) {
003714  37000A     BRA 0x372A
00372A  90002E     MOV [W14+4], W0
00372C  E00000     CP0 W0
00372E  3AFFF3     BRA NZ, 0x3716
57:                        ckSum += *frame++;
003716  90001E     MOV [W14+2], W0
003718  784010     MOV.B [W0], W0
00371A  FB8000     ZE W0, W0
00371C  400F1E     ADD W0, [W14], [W14]
00371E  90001E     MOV [W14+2], W0
003720  E80000     INC W0, W0
003722  980710     MOV W0, [W14+2]
58:                        bytes--;
003724  90002E     MOV [W14+4], W0
003726  E90000     DEC W0, W0
003728  980720     MOV W0, [W14+4]
59:                    }
60:                    return (u8) (ckSum -((ckSum>>8)<<8));
003730  78001E     MOV [W14], W0
003732  FB8000     ZE W0, W0
61:                }
003734  FA8000     ULNK
003736  060000     RETURN
62:                
63:                /*************************************
64:                Function: CheckIsRight  
65:                Description: 判断接受dat，根据fp校验，返回数据正确性
66:                Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
67:                Output: 1：校验正确  0：校验错误
68:                 *************************************/
69:                bool CheckIsRight(FP_CRC fp, u8 * dat, u8 bytes) {
003738  FA000A     LNK #0xA
00373A  980710     MOV W0, [W14+2]
00373C  980721     MOV W1, [W14+4]
00373E  984762     MOV.B W2, [W14+6]
70:                    u16 CRCtep = fp(dat, bytes); //CRC校验
003740  90406E     MOV.B [W14+6], W0
003742  FB8080     ZE W0, W1
003744  90011E     MOV [W14+2], W2
003746  90002E     MOV [W14+4], W0
003748  010002     CALL W2
00374A  780F00     MOV W0, [W14]
71:                    return (CRCtep == (*(dat + bytes)+(u16) (*(dat + bytes + 1) << 8))); //校验数据+CRC
00374C  90406E     MOV.B [W14+6], W0
00374E  FB8000     ZE W0, W0
003750  780080     MOV W0, W1
003752  90002E     MOV [W14+4], W0
003754  408000     ADD W1, W0, W0
003756  784010     MOV.B [W0], W0
003758  FB8100     ZE W0, W2
00375A  90406E     MOV.B [W14+6], W0
00375C  FB8000     ZE W0, W0
00375E  780080     MOV W0, W1
003760  90002E     MOV [W14+4], W0
003762  408000     ADD W1, W0, W0
003764  E80000     INC W0, W0
003766  784010     MOV.B [W0], W0
003768  FB8000     ZE W0, W0
00376A  DD0048     SL W0, #8, W0
00376C  410000     ADD W2, W0, W0
00376E  EB0080     CLR W1
003770  980741     MOV W1, [W14+8]
003772  500F9E     SUB W0, [W14], [W15]
003774  3A0002     BRA NZ, 0x377A
003776  200010     MOV #0x1, W0
003778  980740     MOV W0, [W14+8]
00377A  90004E     MOV [W14+8], W0
72:                }
00377C  FA8000     ULNK
00377E  060000     RETURN
73:                
74:                bool CheckSrting(u8*dat1, u8*dat2, u8 num) {
003780  FA000A     LNK #0xA
003782  980710     MOV W0, [W14+2]
003784  980721     MOV W1, [W14+4]
003786  984762     MOV.B W2, [W14+6]
75:                    u8 cnt;
76:                    for (cnt = 0; cnt < num; cnt++) {//判断EID
003788  EB4000     CLR.B W0
00378A  784F00     MOV.B W0, [W14]
00378C  370010     BRA 0x37AE
0037AC  E84F1E     INC.B [W14], [W14]
0037AE  90406E     MOV.B [W14+6], W0
0037B0  104F9E     SUBR.B W0, [W14], [W15]
0037B2  39FFED     BRA NC, 0x378E
77:                        if (*(dat1 + cnt) != *(dat2 + cnt)) {
00378E  FB801E     ZE [W14], W0
003790  780080     MOV W0, W1
003792  90001E     MOV [W14+2], W0
003794  408000     ADD W1, W0, W0
003796  784110     MOV.B [W0], W2
003798  FB801E     ZE [W14], W0
00379A  780080     MOV W0, W1
00379C  90002E     MOV [W14+4], W0
00379E  408000     ADD W1, W0, W0
0037A0  784010     MOV.B [W0], W0
0037A2  514F80     SUB.B W2, W0, [W15]
0037A4  320003     BRA Z, 0x37AC
78:                            return false;
0037A6  EB0000     CLR W0
0037A8  980740     MOV W0, [W14+8]
0037AA  370006     BRA 0x37B8
79:                        }
80:                    }
81:                    return true;
0037B4  200010     MOV #0x1, W0
0037B6  980740     MOV W0, [W14+8]
0037B8  90004E     MOV [W14+8], W0
82:                }
0037BA  FA8000     ULNK
0037BC  060000     RETURN
83:                
84:                ///*************************************
85:                //Function: MD5encrypt  
86:                //Description: 
87:                //Input: 
88:                //Output:
89:                //*************************************/
90:                //void MD5encrypt(u8* input,u8 *output)
91:                //{
92:                //    
93:                //}
94:                
95:                
96:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/ADC.c  -----------------------------
1:                 //#include "p24F32KA302.h"
2:                 #include "user.h"
3:                 
4:                 void ADC_Init(void) {    
003B46  FA0000     LNK #0x0
5:                     ADC0_IN;
003B48  A842C0     BSET TRISA, #2
6:                     ANSAbits.ANSA2 = 0;
003B4A  A944E0     BCLR ANSA, #2
7:                     //带参考
8:                     AD1CON2bits.PVCFG=0;//AVdd
003B4C  BFC343     MOV.B 0x343, WREG
003B4E  B243F0     AND.B #0x3F, W0
003B50  B7E343     MOV.B WREG, 0x343
9:                     AD1CON2bits.NVCFG=0;//AVss
003B52  A9A343     BCLR 0x343, #5
10:                    AD1CON3bits.ADCS=0b00001111;//16Tcy
003B54  B3C0F0     MOV.B #0xF, W0
003B56  B7E344     MOV.B WREG, AD1CON3
11:                    AD1CON1bits.SSRC=0;
003B58  BFC340     MOV.B AD1CON1, WREG
003B5A  60406F     AND.B W0, #0xF, W0
003B5C  B7E340     MOV.B WREG, AD1CON1
12:                    AD1CON3bits.SAMC=0b01111;//15Tcy
003B5E  203451     MOV #0x345, W1
003B60  784091     MOV.B [W1], W1
003B62  B3CE00     MOV.B #0xE0, W0
003B64  60C000     AND.B W1, W0, W0
003B66  B340F0     IOR.B #0xF, W0
003B68  B7E345     MOV.B WREG, 0x345
13:                    AD1CON1bits.FORM=0;//待定。。。
003B6A  203411     MOV #0x341, W1
003B6C  784091     MOV.B [W1], W1
003B6E  B3CFC0     MOV.B #0xFC, W0
003B70  60C000     AND.B W1, W0, W0
003B72  B7E341     MOV.B WREG, 0x341
14:                }
003B74  FA8000     ULNK
003B76  060000     RETURN
15:                
16:                float Get_Voltage(void) {
003B78  FA0000     LNK #0x0
17:                
18:                }
003B7A  FA8000     ULNK
003B7C  060000     RETURN
19:                
20:                
---  C:/Users/TURONG62/Documents/MPLAB/RS485-GPRS/V3_2_forDaZong.X.X/25L64B.c  --------------------------
1:                 #include "SPI.h"
2:                 #include "user.h"
3:                 #include "25L64B.h"
4:                 //#include "p24FV32KA301.h"
5:                 #include "UART.h"
6:                 #include "TIM.h"
7:                 #include "P-Miot1601.h"
8:                 #include "Miot1601.h"
9:                 
10:                u16 bufferWptr_spi = 0;
11:                u16 bufferRptr_spi = 0;
12:                u8 gOffsetAdd = 0; //16位数据包
13:                
14:                
15:                static void SPI_Read(u8 *dat);
16:                static void SPI_Write(u8 dat);
17:                //static void Delay_Nop(u8 count);
18:                
19:                //const u16 DataPacke_Add[DataPacketNum] = {
20:                //    0x0000, 0x002A, 0x0054, 0x007E, 0x00A8, 0x00D2,
21:                //    0x00FC, 0x0126, 0x0150, 0x017A, 0x01A4, 0x01CE,
22:                //    
23:                //};
24:                //static const u16 OverFlag_Add=0x1FE;
25:                //static const u16 DataPacket_ID = 0x1FF;
26:                //static void FROMFindOffsetAdd(void);
27:                
28:                /*************************************
29:                Function: FM25L64B_Init 
30:                Description: FM25L64B初始化
31:                Input: 无
32:                Output: 无
33:                 *************************************/
34:                void FM25L64B_Init(void) {
003226  FA0000     LNK #0x0
35:                //    u8 tmp[2];
36:                    SDO1_TRIS = 0; //单片机输出
003228  A9C2C8     BCLR TRISB, #6
37:                    SDI1_TRIS = 1; //单片机输入
00322A  A8E2C0     BSET TRISA, #7
38:                    SCK1_TRIS = 0;
00322C  A9A2C8     BCLR TRISB, #5
39:                    SS1_TRIS = 0;
00322E  A982C9     BCLR 0x2C9, #4
40:                    ANSBbits.ANSB14 = 0; //数字输入
003230  A9C4E3     BCLR 0x4E3, #6
41:                    CNPD1bits.CN12PDE = 1;
003232  A88057     BSET 0x57, #4
42:                    SS1 = 1; //输出高电平
003234  A882CD     BSET 0x2CD, #4
43:                    SCK1 = 0;
003236  A9A2CC     BCLR LATB, #5
44:                    SDO1 = 0;
003238  A9C2CC     BCLR LATB, #6
45:                
46:                
47:                    //无写保护区
48:                    FROM_WRSR(); //02
00323A  0700C3     RCALL FROM_WRSR
49:                    //获取数据地址偏移量
50:                    FM25L64B_Read(DataPacket_ID, &gOffsetAdd, 1);
00323C  B3C012     MOV.B #0x1, W2
00323E  20C321     MOV #0xC32, W1
003240  21FFF0     MOV #0x1FFF, W0
003242  070073     RCALL FM25L64B_Read
51:                //    gOffsetAdd=(tmp[0]<<8)+tmp[1];
52:                }
003244  FA8000     ULNK
003246  060000     RETURN
53:                
54:                /*************************************
55:                Function: SPI_Write 
56:                Description: 软件SPI写数据指令
57:                Input: SPI通讯数据
58:                Output: 无
59:                 *************************************/
60:                static void SPI_Write(u8 dat) {
003248  FA0004     LNK #0x4
00324A  984720     MOV.B W0, [W14+2]
61:                    char count;
62:                    for (count = 7; count >= 0; count--) {
00324C  B3C070     MOV.B #0x7, W0
00324E  784F00     MOV.B W0, [W14]
003250  370016     BRA 0x327E
00327C  E94F1E     DEC.B [W14], [W14]
00327E  E0041E     CP0.B [W14]
003280  3DFFE8     BRA GE, 0x3252
63:                        SDO1 = (dat >> count)&0x01;
003252  90402E     MOV.B [W14+2], W0
003254  FB8080     ZE W0, W1
003256  FB001E     SE [W14], W0
003258  DE8800     ASR W1, W0, W0
00325A  604061     AND.B W0, #0x1, W0
00325C  604061     AND.B W0, #0x1, W0
00325E  604061     AND.B W0, #0x1, W0
003260  604061     AND.B W0, #0x1, W0
003262  DD0146     SL W0, #6, W2
003264  202CC1     MOV #0x2CC, W1
003266  784091     MOV.B [W1], W1
003268  B3CBF0     MOV.B #0xBF, W0
00326A  60C000     AND.B W1, W0, W0
00326C  704002     IOR.B W0, W2, W0
00326E  B7E2CC     MOV.B WREG, LATB
64:                        Delay_Nop(1);
003270  200010     MOV #0x1, W0
003272  07FFCF     RCALL Delay_Nop
65:                        SCK1 = 1;
003274  A8A2CC     BSET LATB, #5
66:                        Delay_Nop(1); //9.22 3
003276  200010     MOV #0x1, W0
003278  07FFCC     RCALL Delay_Nop
67:                        SCK1 = 0;
00327A  A9A2CC     BCLR LATB, #5
68:                        //        Delay_Nop(1);
69:                    }
70:                    SDO1 = 0;
003282  A9C2CC     BCLR LATB, #6
71:                }
003284  FA8000     ULNK
003286  060000     RETURN
72:                
73:                /*************************************
74:                Function: SPI_Read 
75:                Description: 软件SPI的读取数据指令
76:                Input: 无
77:                Output: 从机发送过来的数据
78:                 *************************************/
79:                static void SPI_Read(u8 *dat) {
003288  FA0004     LNK #0x4
00328A  980710     MOV W0, [W14+2]
80:                    char count = 0;
00328C  EB4000     CLR.B W0
00328E  784F00     MOV.B W0, [W14]
81:                    *dat = 0x00; //清除原始数据
003290  90009E     MOV [W14+2], W1
003292  EB4000     CLR.B W0
003294  784880     MOV.B W0, [W1]
82:                    for (count = 7; count >= 0; count--) {
003296  B3C070     MOV.B #0x7, W0
003298  784F00     MOV.B W0, [W14]
00329A  370014     BRA 0x32C4
0032C2  E94F1E     DEC.B [W14], [W14]
0032C4  E0041E     CP0.B [W14]
0032C6  3DFFEA     BRA GE, 0x329C
83:                        Delay_Nop(1);
00329C  200010     MOV #0x1, W0
00329E  07FFB9     RCALL Delay_Nop
84:                        SCK1 = 1;
0032A0  A8A2CC     BSET LATB, #5
85:                        *dat |= (SDI1 << count);
0032A2  90001E     MOV [W14+2], W0
0032A4  784010     MOV.B [W0], W0
0032A6  784100     MOV.B W0, W2
0032A8  BFC2C2     MOV.B PORTA, WREG
0032AA  FB8000     ZE W0, W0
0032AC  DE0047     LSR W0, #7, W0
0032AE  FB8080     ZE W0, W1
0032B0  FB001E     SE [W14], W0
0032B2  DD0800     SL W1, W0, W0
0032B4  714000     IOR.B W2, W0, W0
0032B6  784080     MOV.B W0, W1
0032B8  90001E     MOV [W14+2], W0
0032BA  784801     MOV.B W1, [W0]
86:                        Delay_Nop(1);
0032BC  200010     MOV #0x1, W0
0032BE  07FFA9     RCALL Delay_Nop
87:                        SCK1 = 0;
0032C0  A9A2CC     BCLR LATB, #5
88:                    }
89:                }
0032C8  FA8000     ULNK
0032CA  060000     RETURN
90:                
91:                /*************************************
92:                Function: FM25L64B_Write 
93:                Description: FM25L64B通讯写数据
94:                Input: 地址，第9位地址bit8，发送的数据
95:                Output: 无
96:                 *************************************/
97:                void FM25L64B_Write(u16 add, u8* dat, u8 bytes) {
0032CC  FA000A     LNK #0xA
0032CE  980720     MOV W0, [W14+4]
0032D0  980731     MOV W1, [W14+6]
0032D2  984F02     MOV.B W2, [W14+8]
98:                    u8 count = 0;
0032D4  EB4000     CLR.B W0
0032D6  984720     MOV.B W0, [W14+2]
99:                    u8 addL = (u8) (add & 0x00FF);
0032D8  90002E     MOV [W14+4], W0
0032DA  984710     MOV.B W0, [W14+1]
100:                   u8 addH = (u8) ((add >> 8) & 0x00FF);
0032DC  90002E     MOV [W14+4], W0
0032DE  DE0048     LSR W0, #8, W0
0032E0  784F00     MOV.B W0, [W14]
101:               
102:                   FROM_EN();
0032E2  070062     RCALL FROM_EN
103:                   SS1 = 0;
0032E4  A982CD     BCLR 0x2CD, #4
104:                   Delay_Nop(1);
0032E6  200010     MOV #0x1, W0
0032E8  07FF94     RCALL Delay_Nop
105:                   SPI_Write(WRITE);
0032EA  B3C020     MOV.B #0x2, W0
0032EC  07FFAD     RCALL _SPI_Write
106:                   Delay_Nop(1);
0032EE  200010     MOV #0x1, W0
0032F0  07FF90     RCALL Delay_Nop
107:                   SPI_Write(addH);
0032F2  78401E     MOV.B [W14], W0
0032F4  07FFA9     RCALL _SPI_Write
108:                   Delay_Nop(1);
0032F6  200010     MOV #0x1, W0
0032F8  07FF8C     RCALL Delay_Nop
109:                   SPI_Write(addL);
0032FA  90401E     MOV.B [W14+1], W0
0032FC  07FFA5     RCALL _SPI_Write
110:                   Delay_Nop(1);
0032FE  200010     MOV #0x1, W0
003300  07FF88     RCALL Delay_Nop
111:                   //    Delay_Nop(1);//9.22
112:                   while (count < bytes) {
003302  37000C     BRA 0x331C
00331C  9040AE     MOV.B [W14+2], W1
00331E  90480E     MOV.B [W14+8], W0
003320  50CF80     SUB.B W1, W0, [W15]
003322  39FFF0     BRA NC, 0x3304
113:                       SPI_Write(*(dat + count));
003304  90402E     MOV.B [W14+2], W0
003306  FB8000     ZE W0, W0
003308  780080     MOV W0, W1
00330A  90003E     MOV [W14+6], W0
00330C  408000     ADD W1, W0, W0
00330E  784010     MOV.B [W0], W0
003310  07FF9B     RCALL _SPI_Write
114:                       Delay_Nop(1);
003312  200010     MOV #0x1, W0
003314  07FF7E     RCALL Delay_Nop
115:                       count++;
003316  90402E     MOV.B [W14+2], W0
003318  E84000     INC.B W0, W0
00331A  984720     MOV.B W0, [W14+2]
116:                   }
117:                   SS1 = 1;
003324  A882CD     BSET 0x2CD, #4
118:                   //    Delay_Nop(1);
119:                   //    SS1 = 0;
120:                   //    Delay_Nop(1);
121:                   //    SPI_Write(WRDI);
122:                   //    Delay_Nop(1);
123:                   //    SS1 = 1;
124:                   //    Delay_Nop(1);
125:               }
003326  FA8000     ULNK
003328  060000     RETURN
126:               
127:               /*************************************
128:               Function: FM25L64B_Read 
129:               Description: FM25L64B通讯读指令
130:               Input: 地址1，接收的数据,字节数
131:               Output: 无
132:                *************************************/
133:               //static void FM25L64B_Read(u16 add, u8 *dat, u8 bytes) { 
134:               
135:               void FM25L64B_Read(u16 add, u8 *dat, u8 bytes) {
00332A  FA000A     LNK #0xA
00332C  980720     MOV W0, [W14+4]
00332E  980731     MOV W1, [W14+6]
003330  984F02     MOV.B W2, [W14+8]
136:                   u8 count = 0;
003332  EB4000     CLR.B W0
003334  984720     MOV.B W0, [W14+2]
137:                   u8 addL = (u8) (add & 0x00FF);
003336  90002E     MOV [W14+4], W0
003338  984710     MOV.B W0, [W14+1]
138:                   u8 addH = (u8) ((add >> 8) & 0x00FF);
00333A  90002E     MOV [W14+4], W0
00333C  DE0048     LSR W0, #8, W0
00333E  784F00     MOV.B W0, [W14]
139:               
140:                   FROM_EN();
003340  070033     RCALL FROM_EN
141:                   SS1 = 0;
003342  A982CD     BCLR 0x2CD, #4
142:                   Delay_Nop(1);
003344  200010     MOV #0x1, W0
003346  07FF65     RCALL Delay_Nop
143:                   SPI_Write(READ);
003348  B3C030     MOV.B #0x3, W0
00334A  07FF7E     RCALL _SPI_Write
144:                   Delay_Nop(1);
00334C  200010     MOV #0x1, W0
00334E  07FF61     RCALL Delay_Nop
145:                   SPI_Write(addH); //0x03
003350  78401E     MOV.B [W14], W0
003352  07FF7A     RCALL _SPI_Write
146:                   Delay_Nop(1);
003354  200010     MOV #0x1, W0
003356  07FF5D     RCALL Delay_Nop
147:                   SPI_Write(addL); //0x07
003358  90401E     MOV.B [W14+1], W0
00335A  07FF76     RCALL _SPI_Write
148:                   Delay_Nop(1);
00335C  200010     MOV #0x1, W0
00335E  07FF59     RCALL Delay_Nop
149:                   while (count < bytes) {//0xa1
003360  37000B     BRA 0x3378
003378  9040AE     MOV.B [W14+2], W1
00337A  90480E     MOV.B [W14+8], W0
00337C  50CF80     SUB.B W1, W0, [W15]
00337E  39FFF1     BRA NC, 0x3362
150:                       SPI_Read(dat + count);
003362  90402E     MOV.B [W14+2], W0
003364  FB8000     ZE W0, W0
003366  780080     MOV W0, W1
003368  90003E     MOV [W14+6], W0
00336A  408000     ADD W1, W0, W0
00336C  07FF8D     RCALL _SPI_Read
151:                       Delay_Nop(1);
00336E  200010     MOV #0x1, W0
003370  07FF50     RCALL Delay_Nop
152:                       count++;
003372  90402E     MOV.B [W14+2], W0
003374  E84000     INC.B W0, W0
003376  984720     MOV.B W0, [W14+2]
153:                   }
154:                   //        Delay_Nop(1);
155:                   SS1 = 1;
003380  A882CD     BSET 0x2CD, #4
156:                   //        Delay_Nop(1);
157:                   //        SS1 = 0;
158:                   //        Delay_Nop(1);
159:                   //        SPI_Write(WRDI);
160:                   //        Delay_Nop(1);
161:                   //    SS1 = 1;
162:                   //    Delay_Nop(1);
163:               }
003382  FA8000     ULNK
003384  060000     RETURN
164:               
165:               ///*************************************
166:               //Function: BufferWrite 
167:               //Description: 写数据到环形缓冲区
168:               //Input: 串口号，1和2 
169:               //Output: 无
170:               // *************************************/
171:               //void BufferWrite_SPI(u8* dat) {
172:               //    if (bufferWptr_spi == (bufferRptr_spi - 1)) //如果缓冲区已满 写的速度比读的速度块
173:               //        return;
174:               //
175:               //    FM25L64B_Write(bufferWptr_spi, dat, REG_DATA_SZIE);
176:               //
177:               //    FROM_WriteDPNum(); //更新数据包序号
178:               //
179:               //    bufferWptr_spi += (REG_DATA_SECTION);
180:               //    bufferWptr_spi = bufferWptr_spi % BUFFERMAX1;
181:               //}
182:               //
183:               ///*************************************
184:               //Function:  BufferRead_SPI
185:               //Description: 读环形缓冲区
186:               //Input: 数据地址 
187:               //Output: 1：读取成功，0：读取失败
188:               // *************************************/
189:               //bool BufferRead_SPI(u8 *data) {
190:               //    //    u8 count = 0;
191:               //    if (bufferRptr_spi == bufferWptr_spi)
192:               //        return 0;
193:               //    //    u8 tmp=0xab;
194:               //    //    FM25L64B_Write(bufferRptr_spi,&tmp,1);
195:               //    FM25L64B_Read(bufferRptr_spi, data, REG_DATA_SZIE);
196:               //    bufferRptr_spi += (REG_DATA_SECTION);
197:               //    bufferRptr_spi = bufferRptr_spi % BUFFERMAX1;
198:               //    return 1;
199:               //}
200:               
201:               ///*************************************
202:               //Function:  FROM_ReadN
203:               //Description: 读取12z组参数 最新数据在最后面
204:               //Input: 读取的数据 
205:               //Output: 无
206:               // *************************************/
207:               //void FROM_ReadN(u8*dat) {
208:               //    //    u8 tmp,
209:               //    u8 count = 0; //tmp 数据的序列号
210:               //    //    FM25L64B_Read(DataPacket_ID, &tmp, 1); //读取到最近数据总序号
211:               //    ClrWdt(); //清除看门狗
212:               //    //读取序列号
213:               //    while (count < 42) {
214:               //        FM25L64B_Read((gOffsetAdd+)*REG_DATA_SZIE, dat + count * REG_DATA_SZIE, REG_DATA_SZIE);
215:               //        count++;
216:               //    }
217:               //}
218:               
219:               /*************************************
220:               Function:  FROM_WriteDPNum
221:               Description: 更新数据包序号
222:               Input: 无
223:               Output: 无
224:                *************************************/
225:               void FROM_WriteDPNum(void) {
003386  FA0000     LNK #0x0
226:               //    u8 tmp[2];
227:               //    tmp[0] = (gOffsetAdd >> 8)&0x00ff;
228:               //    tmp[1] = gOffsetAdd & 0x00ff;
229:                   FM25L64B_Write(DataPacket_ID, &gOffsetAdd, 1); //写入数据包序号
003388  B3C012     MOV.B #0x1, W2
00338A  20C321     MOV #0xC32, W1
00338C  21FFF0     MOV #0x1FFF, W0
00338E  07FF9E     RCALL FM25L64B_Write
230:                   gOffsetAdd += 1; //数据包序号+1  
003390  BFCC32     MOV.B 0xC32, WREG
003392  E84000     INC.B W0, W0
003394  B7EC32     MOV.B WREG, 0xC32
231:                   gOffsetAdd = gOffsetAdd % DataPacketNum; //一个环数据为252 12*21
003396  BFCC32     MOV.B 0xC32, WREG
003398  FB8000     ZE W0, W0
00339A  200902     MOV #0x90, W2
00339C  090011     REPEAT #0x11
00339E  D88002     DIV.UW W0, W2
0033A0  FD0080     EXCH W0, W1
0033A2  B7EC32     MOV.B WREG, 0xC32
232:               }
0033A4  FA8000     ULNK
0033A6  060000     RETURN
233:               
234:               ///*************************************
235:               //Function:  FROM_WriteDPNum
236:               //Description: 更新数据包序号
237:               //Input: 无
238:               //Output: 无
239:               // *************************************/
240:               //void FROM_ReadDPNum(void) {
241:               //    //    UART2Send(tmp);
242:               //    FM25L64B_Write(DataPacket_ID, &gOffsetAdd, 1); //写入数据包序号
243:               ////    gOffsetAdd += 1; //数据包序号+1  
244:               ////    gOffsetAdd = gOffsetAdd % DataPacketNum; //一个环数据为252 12*21
245:               //}
246:               
247:               /*************************************
248:               Function:  FROM_EN
249:               Description: 使能写
250:               Input: 无
251:               Output: 无
252:                *************************************/
253:               void FROM_EN(void) {
0033A8  FA0000     LNK #0x0
254:                   SS1 = 0;
0033AA  A982CD     BCLR 0x2CD, #4
255:                   Delay_Nop(1);
0033AC  200010     MOV #0x1, W0
0033AE  07FF31     RCALL Delay_Nop
256:                   SPI_Write(WREN);
0033B0  B3C060     MOV.B #0x6, W0
0033B2  07FF4A     RCALL _SPI_Write
257:                   Delay_Nop(1);
0033B4  200010     MOV #0x1, W0
0033B6  07FF2D     RCALL Delay_Nop
258:                   SS1 = 1;
0033B8  A882CD     BSET 0x2CD, #4
259:                   Delay_Nop(1);
0033BA  200010     MOV #0x1, W0
0033BC  07FF2A     RCALL Delay_Nop
260:               }
0033BE  FA8000     ULNK
0033C0  060000     RETURN
261:               
262:               /*************************************
263:               Function:  FROM_WRSR
264:               Description: 写保护区
265:               Input: 无
266:               Output: 无
267:                *************************************/
268:               void FROM_WRSR(void) {
0033C2  FA0000     LNK #0x0
269:                   SS1 = 0;
0033C4  A982CD     BCLR 0x2CD, #4
270:                   Delay_Nop(1);
0033C6  200010     MOV #0x1, W0
0033C8  07FF24     RCALL Delay_Nop
271:                   SPI_Write(WRSR);
0033CA  B3C010     MOV.B #0x1, W0
0033CC  07FF3D     RCALL _SPI_Write
272:                   Delay_Nop(1);
0033CE  200010     MOV #0x1, W0
0033D0  07FF20     RCALL Delay_Nop
273:                   SPI_Write(0x00);
0033D2  EB4000     CLR.B W0
0033D4  07FF39     RCALL _SPI_Write
274:                   Delay_Nop(1);
0033D6  200010     MOV #0x1, W0
0033D8  07FF1C     RCALL Delay_Nop
275:                   SS1 = 1;
0033DA  A882CD     BSET 0x2CD, #4
276:                   Delay_Nop(1);
0033DC  200010     MOV #0x1, W0
0033DE  07FF19     RCALL Delay_Nop
277:               }
0033E0  FA8000     ULNK
0033E2  060000     RETURN
278:               
279:               #ifdef DEBUG_From
280:               
281:               void FROM_RDSR(void) {
282:                   u8 tmp;
283:                   SS1 = 0;
284:                   Delay_Nop(1);
285:                   SPI_Write(RDSR);
286:                   //    Delay_Nop(1);
287:                   SPI_Read(&tmp);
288:                   Delay_Nop(1);
289:                   SS1 = 1;
290:                   Delay_Nop(1);
291:               }
292:               
293:               void SPI_Test(void) {
294:                   //    u8 dat_debug = 0xa1;
295:                   //        while (1) {
296:                   //            SPI_Write(0xa1);
297:                   //            Delay100ms(1);
298:                   //        }
299:                   //        while (1) {
300:                   //            FM25L64B_Write(mi_dat_add[mi_id],&dat_debug,1);
301:                   //            Delay100ms(1);
302:                   //        } 
303:                   //    while (1) {
304:                   //    FM25L64B_Read(DataPacket_ID, &dat_debug, 1);
305:                   //        FM25L64B_Read(mi_dat_add[mi_id], &dat_debug, 1);
306:                   //        UART2Send(dat_debug);
307:                   //        Delay100ms(10);
308:                   //    }
309:                   u8 tmp_dat[492];
310:                   u16 cnt;
311:                   //    UART2SendString("\n******************FRAM Dat*****************", 44);
312:                   FROM_ReadN(tmp_dat);
313:                   for (cnt = 0; cnt < 492; cnt++) {
314:                       //        if(!(cnt%42))  UART2Send('\n');
315:                       //        else UART2Send(' ');
316:                       UART2Send(tmp_dat[cnt]);
317:                       //        PrintInterIsFinish(tmp_dat[cnt], 'c', 0);
318:                       //        UART2Send(((tmp_dat[cnt]>>4)&0x0F)+0x30);
319:                       //        UART2Send((tmp_dat[cnt]&0x0F)+0x30);
320:                   }
321:                   //    UART2SendString("\n***********************************\n", 37);
322:               }
323:               #endif
324:               
325:               
