#include "user.h"
#include "UART.h"
#include "GPRS.h" 
#include "25L64B.h"
#include "TIM.h"
#include "SerialBuffer.h"
#include "Miot1601.h"
#include "CheckData.h"
#include "string.h"
#include "time.h"
#include "stdlib.h"
#include "Status.h"
//#include "ctype.h"
//const u8 GPRS_Arg1[144] = {//UTC
//    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
//    0x53, 0x54, 0x57, 0x30, 0x80, 0x8A, 0x8D, 0xAC, 0x0D, 0x00,
//    0x30, 0x30, 0x30, 0x0B, 0x15, 0x13, 0x87, 0x57, 0x96, 0x1F,
//    0x0B, 0x13, 0x46, 0x10, 0x79, 0x92, 0x5F, 0x30, 0x30, 0x32,
//    0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x77, 0x77,
//    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
//    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
//    0x43, 0x4D, 0x4E, 0x45, 0x54,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0x30, 0x0B, 0x13, 0x71, 0x11, 0x11, 0x11, 0x1F, 0xFF,
//    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//    0xFF, 0xFF, 0xCC, 0xC2
//};
/*
const u8 GPRS_Arg1[144] = {//UTC
    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
    0x53, 0x54, 0x57, 0x30, 0xCA, 0x78, 0x02, 0x65, 0x7B, 0x00,
    0x30, 0x31, 0x30, 0x0B, 0x15, 0x13, 0x87, 0x57, 0x96, 0x1F,
    0x0B, 0x13, 0x46, 0x10, 0x79, 0x92, 0x5F, 0x30, 0x30, 0x31/*9600,
    0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x77, 0x77,
    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x30, 0x0B, 0x13, 0x71, 0x11, 0x11, 0x11, 0x1F, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x68, 0x61
};
const u8 GPRS_Arg2[144] = {//miot1601
    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
    0x53, 0x54, 0x57, 0x30, 0xCA, 0x94, 0xEA, 0x20, 0x7A, 0x17,
    0x30, 0x31, 0x30, 0x0B, 0x18, 0x25, 0x77, 0x00, 0x27, 0x1F,
    0x0B, 0x13, 0x80, 0x05, 0x77, 0x50, 0x0F, 0x30, 0x30, 0x31/*9600,
    0x3C, 0x00, 0xB4, 0x00, 0x58, 0x02, 0x30, 0x0D, 0x77, 0x77,
    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x30, 0x0B, 0x18, 0x35, 0x77, 0x68, 0x90, 0x7F, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x89, 0x83
};

const u8 GPRS_Arg3[144] = {//FOR TEST
    0x2B, 0x54, 0x55, 0x52, 0x4F, 0x4E, 0x47, 0x20, 0x54, 0x45,
    0x53, 0x54, 0x57, 0x30, 0xB7, 0xF6, 0x4A, 0x44, 0xCF, 0x13,
    0x30, 0x31, 0x30, 0x0B, 0x13, 0x73, 0x69, 0x53, 0x37, 0x2F,
    0x0B, 0x13, 0x80, 0x05, 0x77, 0x50, 0x0F, 0x30, 0x30, 0x31, /*9600
    0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x77, 0x77,
    0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F,
    0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05,
    0x43, 0x4D, 0x4E, 0x45, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x30, 0x0B, 0x13, 0x71, 0x11, 0x11, 0x11, 0x1F, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x3B, 0x19
};*/

const u16 GPRS_ON_TIME = 7000; //50s 5000*0.01
//const u16 GPRS_ON_CHECK = 9000; //100s
//const u8 NTP_Message[48] = {
//    0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//};

//u8 SendUTC[12] = "+TURONG GPOT";
const u8 Ready[5] = "READY";
const u8 SendON[14] = "+TURONG GPON\r\n";
const u8 SendOFF[13] = "+TURONG GPOFF";
//const u8 SendGPOT[12] = "+TURONG GPOT";
//const u8 ReceiveOK[6] = "+RECW0";
const u8 ReadArg[14] = "+TURONG TESTR0";
const u8 ArgRe[5] = {0x2B, 0x52, 0x45, 0x43, 0x57};
const u8 UDPHead[2] = {0x41, 0x32};
//const u8 GMTHead[3] = {'T', 'R', ':'};
//const u8 GMTHead[4] = {0x24, 0x03, 0x03, 0xE9};

//const u8 SendCH[12] = "+TURONG GPCH";
//u8 Head2[4] = "FAIL";
//u8 gUARTtmp[2]; //用于存放临时变量
u8 gAlarmZeroLock = 0;
//extern u8 gCurrentSampleCount;

/*************************************
Function: GPRS_Init 
Description: GPRS模块初始化
Input: 无
Output: 无
 *************************************/
void GPRS_Init(void) {
    //    u8 dat;
    GP_CON_OUT;
    GPRS_OFF;
    //    ANSAbits.ANSA3 = 0; //GP_CON设置为数字输出
    LK_OUT;
    ANSBbits.ANSB13 = 0; //数字输入
    //    dat = LK;
}

void GPRS_Send(const u8*dat, u8 bytes) {
    u8 cnt = 0;
    while (cnt++ < 3) {
        UART2SendString(dat, bytes);
        Delay100ms(5); //延时1s 
    }
}

bool GPRS_IS_Ready(void) {//如果返回READY，EN为高；反之，EN为低
    u8 fail_Cnt = 0; // loop_Cnt = 0;
    u8 tmp[5] = {0, 0};

    do {
        GPRS_OFF;
        Delay1s(6); //6s
        GPRS_ON;
        Delay1s(1); //6s
        if (fail_Cnt++ > 3) {//上线6次
            GPRS_OFF;
            return false;
        }
    } while (!UARTIsGet(BufferRead_UART2, tmp, 2, Ready, 5)); //{//是不是接收到READY
    return true;
}

bool GPRS_IS_Close(const u8 nS) {
    u8 tmp[5] = {0, 0};
    GPRS_Send(SendOFF, 12);
    Delay1s(nS); //延时delay秒
    return UARTIsGet(BufferRead_UART2, tmp, 2, SendOFF + 10, 3); //{//是不是接收到OFF
}

/*************************************
Function: LKIsHigh 
Description: 判断是否上线
Input: 无
Output: 1：发送成功
 *************************************/
bool LKIsHigh(u16 deadline) {
    bool sta = false;
    StartTime3(); //开启定时器3计时
    ANSBbits.ANSB13 = 0;
    TRISBbits.TRISB13 = 1; //LK口设置为数字输入

    while (gT3Count < deadline) {//50s内上线  
        ClrWdt();
        if (LK) {
            Delay10ms(1);
            if (LK) {
                sta = true;
                break;
            }
        }
    }
    CloseTime3(); //关闭定时器3定时
    ANSBbits.ANSB13 = 1;
    TRISBbits.TRISB13 = 0; //LK口设置为数字输入   
    return sta;
}

/*************************************
Function: CopUDPTask 
Description: UDP发送采集数据任务通讯任务
Input: 无
Output: 无
 *************************************/
bool CopUDPTask(const u8 sendDat, const u8 goLineCount, const u8 sendCount) {
    u8 receiveBuffer[60] = {0, 0, 0, 0}; //29+15=44
    u8 FailCount = 0, sendCnt = 0, cnt = 0, getbytes = 0;
    u8 mi_id_Tmp[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    bool sta = false;

    Register2Read(mi_id_Tmp, REG2_Arg_Postion[mi_id], 8); //获取EID
    Statusbits.staGPRS = GPRS_Initing;
    Open_UART2(); //打开串口2

    while (FailCount++ < goLineCount) {//2次上线
        if (!GPRS_IS_Ready())//等待GPRS在状态
        {
            Statusbits.staGPRS = GPRS_No_Ready; //GPRS没有返回READY
            Close_UART2(); //关闭串口2
            return false;
        }
        Statusbits.staGPRS = GPRS_Ready_OK;
        GPRS_Send(SendON, 14); //发送GPRS_ON
        ClrWdt(); //清除看门狗
        Statusbits.staGPRS = GPRS_Dialing; //GPRS正在拨号
        if (LKIsHigh(GPRS_ON_TIME))//判断LK在60s内是否上线
        {
            Statusbits.staGPRS = GPRS_Send_Data; //GPRS上线成功并发送数据
            //            Statusbits.staGPRS = GPRS_Online_OK; //GPRS上线成功
            sendCnt = 0; //清除发送次数
            while (sendCnt++ < sendCount) {
                UDPSendData(sendDat); //, offsetAdd);
                Delay1s(3); //延时4s 必须要等待3s后数据返回
                //41 32 7F F9 02 01 00 00 00 08 00 1F 00 1D 00 0E 10 01 0E 10 02 00 00 05 41 20 00 00 06 41 20 00 00 03 41 20 00 00 04 41 20 00 00 07  [44bytes]
                for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
                    if (U2STAbits.URXDA == 1) //没有接收到
                        BufferWrite_UART2();
            }
            if (getbytes = UARTIsGet(BufferRead_UART2, receiveBuffer, 55, UDPHead, 2)) { //获取数据并校验数据     //如果有接收到数据 
                if (receiveBuffer[getbytes - 2] == Sum_Check256(receiveBuffer, getbytes - 2)) { //判断校验和是否正确53 42   获取到的字节数减对于1位和校验吗                  
                    if (CheckSrting(receiveBuffer + 2, mi_id_Tmp, 8)) {
                        Statusbits.staGPRS = DUPDataChange(receiveBuffer) ? RData_Change_OK : RData_Change_Fail;
                        if (FLagArgbits.TestOnlieFlag)Delay1s(1); //用于显示上位机数据
                        gTimeCount.timeGprs = gTimeCount.timeMp; //确保每次发送的数据正常
                        if (sendDat == SampleData)//如果是采集数据的话，采集数据通道清除
                            EmptyRegister1(); //清除缓冲数据
                        if (miotArgs.timealarm)
                            gAlarmZeroLock = 0; //如果报警值不为零的话，清除锁存位                            
                        sta = true;
                        break; //退出拨号
                    } else
                        Statusbits.staGPRS = RData_Error_EID; //EID错误
                } else
                    Statusbits.staGPRS = RData_Error_Check_Sum; //校验和错误
            } else
                Statusbits.staGPRS = RData_No_Receive; //没有接受到有效数据
        } else
            Statusbits.staGPRS = GPRS_Dialing_Time_Over; //拨号超时
        //延时1s等待上位机刷新状态
    }
    if (!sta && (FailCount - 1 > goLineCount))//如果上线次数超过了，表示为置1
        Statusbits.staGPRS = GPRS_Dialing_Cnt_Over;
    if (!GPRS_IS_Close(5))
        Statusbits.staGPRS = GPRS_Unline_No_Ready;
    Close_UART2(); //关闭串口2
    GPRS_OFF; //关闭GPRS
    Statusbits.staGPRS = GPRS_Exit;
    return sta;
}





