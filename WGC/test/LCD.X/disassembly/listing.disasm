Disassembly Listing for V1_1_0WCGfor6528
Generated From:
C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/dist/default/debug/V1_1_0WCGfor6528.X.debug.elf
2017-6-20 12:42:56

---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_time.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             TIME MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TIME.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*
31:                *********************************************************************************************************
32:                *                                        DELAY TASK 'n' TICKS
33:                *
34:                * Description: This function is called to delay execution of the currently running task until the
35:                *              specified number of system ticks expires.  This, of course, directly equates to delaying
36:                *              the current task for some time to expire.  No delay will result If the specified delay is
37:                *              0.  If the specified delay is greater than 0 then, a context switch will result.
38:                *
39:                * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
40:                *                        Note that by specifying 0, the task will not be delayed.
41:                *
42:                * Returns    : none
43:                *********************************************************************************************************
44:                */
45:                
46:                void  OSTimeDly (INT32U ticks)
47:                {
006C20  FA0008     LNK #0x8
006C22  980720     MOV W0, [W14+4]
006C24  980731     MOV W1, [W14+6]
48:                    INT8U      y;
49:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
50:                    OS_CPU_SR  cpu_sr = 0u;
006C26  EB0000     CLR W0
006C28  780F00     MOV W0, [W14]
51:                #endif
52:                
53:                
54:                
55:                    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
006C2A  BFC86B     MOV.B OSIntNesting, WREG
006C2C  E00400     CP0.B W0
006C2E  3A0032     BRA NZ, 0x6C94
56:                        return;
006C94  000000     NOP
006C96  370001     BRA 0x6C9A
57:                    }
58:                    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
006C30  BFC86C     MOV.B OSLockNesting, WREG
006C32  E00400     CP0.B W0
006C34  3A0031     BRA NZ, 0x6C98
59:                        return;
006C98  000000     NOP
60:                    }
61:                    if (ticks > 0u) {                            /* 0 means no delay!                                  */
006C36  90002E     MOV [W14+4], W0
006C38  9000BE     MOV [W14+6], W1
006C3A  500FE0     SUB W0, #0x0, [W15]
006C3C  588FE0     SUBB W1, #0x0, [W15]
006C3E  32002D     BRA Z, 0x6C9A
62:                        OS_ENTER_CRITICAL();
006C40  800211     MOV SR, W1
006C42  780F01     MOV W1, [W14]
006C44  800211     MOV SR, W1
006C46  200E00     MOV #0xE0, W0
006C48  700001     IOR W0, W1, W0
006C4A  880210     MOV W0, SR
63:                        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
006C4C  8043B0     MOV OSTCBCur, W0
006C4E  906140     MOV.B [W0+36], W2
006C50  984722     MOV.B W2, [W14+2]
64:                        OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
006C52  90402E     MOV.B [W14+2], W0
006C54  FB8000     ZE W0, W0
006C56  9040AE     MOV.B [W14+2], W1
006C58  FB8081     ZE W1, W1
006C5A  209402     MOV #0x940, W2
006C5C  78C162     MOV.B [W2+W1], W2
006C5E  8043B1     MOV OSTCBCur, W1
006C60  9060D1     MOV.B [W1+37], W1
006C62  EAC081     COM.B W1, W1
006C64  614101     AND.B W2, W1, W2
006C66  209401     MOV #0x940, W1
006C68  787082     MOV.B W2, [W1+W0]
65:                        if (OSRdyTbl[y] == 0u) {
006C6A  90402E     MOV.B [W14+2], W0
006C6C  FB8000     ZE W0, W0
006C6E  209401     MOV #0x940, W1
006C70  784061     MOV.B [W1+W0], W0
006C72  E00400     CP0.B W0
006C74  3A0006     BRA NZ, 0x6C82
66:                            OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
006C76  8043B0     MOV OSTCBCur, W0
006C78  906060     MOV.B [W0+38], W0
006C7A  EAC080     COM.B W0, W1
006C7C  BFC86F     MOV.B OSRdyGrp, WREG
006C7E  60C000     AND.B W1, W0, W0
006C80  B7E86F     MOV.B WREG, OSRdyGrp
67:                        }
68:                        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
006C82  8043B0     MOV OSTCBCur, W0
006C84  90012E     MOV [W14+4], W2
006C86  9001BE     MOV [W14+6], W3
006C88  980862     MOV W2, [W0+28]
006C8A  980873     MOV W3, [W0+30]
69:                        OS_EXIT_CRITICAL();
006C8C  78019E     MOV [W14], W3
006C8E  880213     MOV W3, SR
70:                        OS_Sched();                              /* Find next task to run!                             */
006C90  07D34F     RCALL OS_Sched
006C92  370003     BRA 0x6C9A
71:                    }
72:                }
006C9A  FA8000     ULNK
006C9C  060000     RETURN
73:                /*$PAGE*/
74:                /*
75:                *********************************************************************************************************
76:                *                                    DELAY TASK FOR SPECIFIED TIME
77:                *
78:                * Description: This function is called to delay execution of the currently running task until some time
79:                *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
80:                *              MILLISECONDS instead of ticks.
81:                *
82:                * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
83:                *              minutes   specifies the number of minutes (max. 59)
84:                *              seconds   specifies the number of seconds (max. 59)
85:                *              ms        specifies the number of milliseconds (max. 999)
86:                *
87:                * Returns    : OS_ERR_NONE
88:                *              OS_ERR_TIME_INVALID_MINUTES
89:                *              OS_ERR_TIME_INVALID_SECONDS
90:                *              OS_ERR_TIME_INVALID_MS
91:                *              OS_ERR_TIME_ZERO_DLY
92:                *              OS_ERR_TIME_DLY_ISR
93:                *
94:                * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
95:                *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
96:                *              set to 0.  The actual delay is rounded to the nearest tick.
97:                *********************************************************************************************************
98:                */
99:                
100:               #if OS_TIME_DLY_HMSM_EN > 0u
101:               INT8U  OSTimeDlyHMSM (INT8U   hours,
102:                                     INT8U   minutes,
103:                                     INT8U   seconds,
104:                                     INT16U  ms)
105:               {
006C9E  FA000A     LNK #0xA
006CA0  BE9F88     MOV.D W8, [W15++]
006CA2  984740     MOV.B W0, [W14+4]
006CA4  984751     MOV.B W1, [W14+5]
006CA6  984762     MOV.B W2, [W14+6]
006CA8  980743     MOV W3, [W14+8]
106:                   INT32U ticks;
107:               
108:               
109:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
006CAA  BFC86B     MOV.B OSIntNesting, WREG
006CAC  E00400     CP0.B W0
006CAE  320002     BRA Z, 0x6CB4
110:                       return (OS_ERR_TIME_DLY_ISR);
006CB0  B3C550     MOV.B #0x55, W0
006CB2  370064     BRA 0x6D7C
111:                   }
112:                   if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
006CB4  BFC86C     MOV.B OSLockNesting, WREG
006CB6  E00400     CP0.B W0
006CB8  320002     BRA Z, 0x6CBE
113:                       return (OS_ERR_SCHED_LOCKED);
006CBA  B3C320     MOV.B #0x32, W0
006CBC  37005F     BRA 0x6D7C
114:                   }
115:               #if OS_ARG_CHK_EN > 0u
116:                   if (hours == 0u) {
006CBE  90404E     MOV.B [W14+4], W0
006CC0  E00400     CP0.B W0
006CC2  3A000B     BRA NZ, 0x6CDA
117:                       if (minutes == 0u) {
006CC4  90405E     MOV.B [W14+5], W0
006CC6  E00400     CP0.B W0
006CC8  3A0008     BRA NZ, 0x6CDA
118:                           if (seconds == 0u) {
006CCA  90406E     MOV.B [W14+6], W0
006CCC  E00400     CP0.B W0
006CCE  3A0005     BRA NZ, 0x6CDA
119:                               if (ms == 0u) {
006CD0  90004E     MOV [W14+8], W0
006CD2  E00000     CP0 W0
006CD4  3A0002     BRA NZ, 0x6CDA
120:                                   return (OS_ERR_TIME_ZERO_DLY);
006CD6  B3C540     MOV.B #0x54, W0
006CD8  370051     BRA 0x6D7C
121:                               }
122:                           }
123:                       }
124:                   }
125:                   if (minutes > 59u) {
006CDA  9040DE     MOV.B [W14+5], W1
006CDC  B3C3B0     MOV.B #0x3B, W0
006CDE  50CF80     SUB.B W1, W0, [W15]
006CE0  360002     BRA LEU, 0x6CE6
126:                       return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
006CE2  B3C510     MOV.B #0x51, W0
006CE4  37004B     BRA 0x6D7C
127:                   }
128:                   if (seconds > 59u) {
006CE6  9040EE     MOV.B [W14+6], W1
006CE8  B3C3B0     MOV.B #0x3B, W0
006CEA  50CF80     SUB.B W1, W0, [W15]
006CEC  360002     BRA LEU, 0x6CF2
129:                       return (OS_ERR_TIME_INVALID_SECONDS);
006CEE  B3C520     MOV.B #0x52, W0
006CF0  370045     BRA 0x6D7C
130:                   }
131:                   if (ms > 999u) {
006CF2  9000CE     MOV [W14+8], W1
006CF4  203E70     MOV #0x3E7, W0
006CF6  508F80     SUB W1, W0, [W15]
006CF8  360002     BRA LEU, 0x6CFE
132:                       return (OS_ERR_TIME_INVALID_MS);
006CFA  B3C530     MOV.B #0x53, W0
006CFC  37003F     BRA 0x6D7C
133:                   }
134:               #endif
135:                                                                /* Compute the total number of clock ticks required.. */
136:                                                                /* .. (rounded to the nearest tick)                   */
137:                   ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
006CFE  90404E     MOV.B [W14+4], W0
006D00  FB8000     ZE W0, W0
006D02  EB0080     CLR W1
006D04  20E102     MOV #0xE10, W2
006D06  B98902     MUL.SS W1, W2, W2
006D08  780202     MOV W2, W4
006D0A  B90160     MUL.SU W0, #0, W2
006D0C  780102     MOV W2, W2
006D0E  420202     ADD W4, W2, W4
006D10  20E102     MOV #0xE10, W2
006D12  B80102     MUL.UU W0, W2, W2
006D14  420203     ADD W4, W3, W4
006D16  780184     MOV W4, W3
006D18  90405E     MOV.B [W14+5], W0
006D1A  FB8000     ZE W0, W0
006D1C  EB0080     CLR W1
006D1E  2003C4     MOV #0x3C, W4
006D20  B98A04     MUL.SS W1, W4, W4
006D22  780204     MOV W4, W4
006D24  B90360     MUL.SU W0, #0, W6
006D26  780286     MOV W6, W5
006D28  420205     ADD W4, W5, W4
006D2A  2003C5     MOV #0x3C, W5
006D2C  B80005     MUL.UU W0, W5, W0
006D2E  420201     ADD W4, W1, W4
006D30  780084     MOV W4, W1
006D32  400102     ADD W0, W2, W2
006D34  488183     ADDC W1, W3, W3
006D36  90406E     MOV.B [W14+6], W0
006D38  FB8000     ZE W0, W0
006D3A  EB0080     CLR W1
006D3C  400002     ADD W0, W2, W0
006D3E  488083     ADDC W1, W3, W1
006D40  203E82     MOV #0x3E8, W2
006D42  B98902     MUL.SS W1, W2, W2
006D44  780102     MOV W2, W2
006D46  B90260     MUL.SU W0, #0, W4
006D48  780184     MOV W4, W3
006D4A  410103     ADD W2, W3, W2
006D4C  203E83     MOV #0x3E8, W3
006D4E  B80403     MUL.UU W0, W3, W8
006D50  410109     ADD W2, W9, W2
006D52  780482     MOV W2, W9
006D72  441F00     ADD W8, W0, [W14++]
006D74  4C9701     ADDC W9, W1, [W14--]
138:                         + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
006D54  90004E     MOV [W14+8], W0
006D56  EB0080     CLR W1
006D58  203E82     MOV #0x3E8, W2
006D5A  B98902     MUL.SS W1, W2, W2
006D5C  780102     MOV W2, W2
006D5E  B90260     MUL.SU W0, #0, W4
006D60  780184     MOV W4, W3
006D62  410103     ADD W2, W3, W2
006D64  203E83     MOV #0x3E8, W3
006D66  B80003     MUL.UU W0, W3, W0
006D68  410101     ADD W2, W1, W2
006D6A  780082     MOV W2, W1
006D6C  203E82     MOV #0x3E8, W2
006D6E  200003     MOV #0x0, W3
006D70  07CB57     RCALL 0x420
139:                   OSTimeDly(ticks);
006D76  BE001E     MOV.D [W14], W0
006D78  07FF53     RCALL OSTimeDly
140:                   return (OS_ERR_NONE);
006D7A  EB4000     CLR.B W0
141:               }
006D7C  BE044F     MOV.D [--W15], W8
142:               #endif
143:               /*$PAGE*/
144:               /*
145:               *********************************************************************************************************
146:               *                                        RESUME A DELAYED TASK
147:               *
148:               * Description: This function is used resume a task that has been delayed through a call to either
149:               *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
150:               *              task that is waiting for an event with timeout.  This would make the task look
151:               *              like a timeout occurred.
152:               *
153:               * Arguments  : prio                      specifies the priority of the task to resume
154:               *
155:               * Returns    : OS_ERR_NONE               Task has been resumed
156:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
157:               *                                        (i.e. >= OS_LOWEST_PRIO)
158:               *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
159:               *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
160:               *********************************************************************************************************
161:               */
162:               
163:               #if OS_TIME_DLY_RESUME_EN > 0u
164:               INT8U  OSTimeDlyResume (INT8U prio)
165:               {
166:                   OS_TCB    *ptcb;
167:               #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
168:                   OS_CPU_SR  cpu_sr = 0u;
169:               #endif
170:               
171:               
172:               
173:                   if (prio >= OS_LOWEST_PRIO) {
174:                       return (OS_ERR_PRIO_INVALID);
175:                   }
176:                   OS_ENTER_CRITICAL();
177:                   ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
178:                   if (ptcb == (OS_TCB *)0) {
179:                       OS_EXIT_CRITICAL();
180:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
181:                   }
182:                   if (ptcb == OS_TCB_RESERVED) {
183:                       OS_EXIT_CRITICAL();
184:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
185:                   }
186:                   if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
187:                       OS_EXIT_CRITICAL();
188:                       return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
189:                   }
190:               
191:                   ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
192:                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
193:                       ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
194:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
195:                   } else {
196:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
197:                   }
198:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
199:                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
200:                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
201:                       OS_EXIT_CRITICAL();
202:                       OS_Sched();                                            /* See if this is new highest priority  */
203:                   } else {
204:                       OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
205:                   }
206:                   return (OS_ERR_NONE);
207:               }
208:               #endif
209:               /*$PAGE*/
210:               /*
211:               *********************************************************************************************************
212:               *                                       GET CURRENT SYSTEM TIME
213:               *
214:               * Description: This function is used by your application to obtain the current value of the 32-bit
215:               *              counter which keeps track of the number of clock ticks.
216:               *
217:               * Arguments  : none
218:               *
219:               * Returns    : The current value of OSTime
220:               *********************************************************************************************************
221:               */
222:               
223:               #if OS_TIME_GET_SET_EN > 0u
224:               INT32U  OSTimeGet (void)
225:               {
226:                   INT32U     ticks;
227:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
228:                   OS_CPU_SR  cpu_sr = 0u;
229:               #endif
230:               
231:               
232:               
233:                   OS_ENTER_CRITICAL();
234:                   ticks = OSTime;
235:                   OS_EXIT_CRITICAL();
236:                   return (ticks);
237:               }
238:               #endif
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                          SET SYSTEM CLOCK
243:               *
244:               * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
245:               *
246:               * Arguments  : ticks      specifies the new value that OSTime needs to take.
247:               *
248:               * Returns    : none
249:               *********************************************************************************************************
250:               */
251:               
252:               #if OS_TIME_GET_SET_EN > 0u
253:               void  OSTimeSet (INT32U ticks)
254:               {
255:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
256:                   OS_CPU_SR  cpu_sr = 0u;
257:               #endif
258:               
259:               
260:               
261:                   OS_ENTER_CRITICAL();
262:                   OSTime = ticks;
263:                   OS_EXIT_CRITICAL();
264:               }
265:               #endif
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_task.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                            TASK MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TASK.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*$PAGE*/
31:                /*
32:                *********************************************************************************************************
33:                *                                      CHANGE PRIORITY OF A TASK
34:                *
35:                * Description: This function allows you to change the priority of a task dynamically.  Note that the new
36:                *              priority MUST be available.
37:                *
38:                * Arguments  : oldp     is the old priority
39:                *
40:                *              newp     is the new priority
41:                *
42:                * Returns    : OS_ERR_NONE            is the call was successful
43:                *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
44:                *                                     (i.e. >= OS_LOWEST_PRIO)
45:                *              OS_ERR_PRIO_EXIST      if the new priority already exist.
46:                *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
47:                *                                     not exist.
48:                *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
49:                *********************************************************************************************************
50:                */
51:                
52:                #if OS_TASK_CHANGE_PRIO_EN > 0u
53:                INT8U  OSTaskChangePrio (INT8U  oldprio,
54:                                         INT8U  newprio)
55:                {
002F78  FA0012     LNK #0x12
002F7A  985700     MOV.B W0, [W14+16]
002F7C  985711     MOV.B W1, [W14+17]
56:                #if (OS_EVENT_EN)
57:                    OS_EVENT  *pevent;
58:                #if (OS_EVENT_MULTI_EN > 0u)
59:                    OS_EVENT **pevents;
60:                #endif
61:                #endif
62:                    OS_TCB    *ptcb;
63:                    INT8U      y_new;
64:                    INT8U      x_new;
65:                    INT8U      y_old;
66:                    OS_PRIO    bity_new;
67:                    OS_PRIO    bitx_new;
68:                    OS_PRIO    bity_old;
69:                    OS_PRIO    bitx_old;
70:                #if OS_CRITICAL_METHOD == 3u
71:                    OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
002F7E  EB0000     CLR W0
002F80  980720     MOV W0, [W14+4]
72:                #endif
73:                
74:                
75:                /*$PAGE*/
76:                #if OS_ARG_CHK_EN > 0u
77:                    if (oldprio >= OS_LOWEST_PRIO) {
002F82  90500E     MOV.B [W14+16], W0
002F84  504FEB     SUB.B W0, #0xB, [W15]
002F86  360005     BRA LEU, 0x2F92
78:                        if (oldprio != OS_PRIO_SELF) {
002F88  90500E     MOV.B [W14+16], W0
002F8A  404FE1     ADD.B W0, #0x1, [W15]
002F8C  320002     BRA Z, 0x2F92
79:                            return (OS_ERR_PRIO_INVALID);
002F8E  B3C2A0     MOV.B #0x2A, W0
002F90  370121     BRA 0x31D4
80:                        }
81:                    }
82:                    if (newprio >= OS_LOWEST_PRIO) {
002F92  90501E     MOV.B [W14+17], W0
002F94  504FEB     SUB.B W0, #0xB, [W15]
002F96  360002     BRA LEU, 0x2F9C
83:                        return (OS_ERR_PRIO_INVALID);
002F98  B3C2A0     MOV.B #0x2A, W0
002F9A  37011C     BRA 0x31D4
84:                    }
85:                #endif
86:                    OS_ENTER_CRITICAL();
002F9C  800211     MOV SR, W1
002F9E  980721     MOV W1, [W14+4]
002FA0  800211     MOV SR, W1
002FA2  200E00     MOV #0xE0, W0
002FA4  700001     IOR W0, W1, W0
002FA6  880210     MOV W0, SR
87:                    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
002FA8  90501E     MOV.B [W14+17], W0
002FAA  FB8000     ZE W0, W0
002FAC  400080     ADD W0, W0, W1
002FAE  209C20     MOV #0x9C2, W0
002FB0  408000     ADD W1, W0, W0
002FB2  780010     MOV [W0], W0
002FB4  E00000     CP0 W0
002FB6  320004     BRA Z, 0x2FC0
88:                        OS_EXIT_CRITICAL();
002FB8  9001AE     MOV [W14+4], W3
002FBA  880213     MOV W3, SR
89:                        return (OS_ERR_PRIO_EXIST);
002FBC  B3C280     MOV.B #0x28, W0
002FBE  37010A     BRA 0x31D4
90:                    }
91:                    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
002FC0  90500E     MOV.B [W14+16], W0
002FC2  404FE1     ADD.B W0, #0x1, [W15]
002FC4  3A0003     BRA NZ, 0x2FCC
92:                        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
002FC6  8043B0     MOV OSTCBCur, W0
002FC8  9060A0     MOV.B [W0+34], W1
002FCA  985701     MOV.B W1, [W14+16]
93:                    }
94:                    ptcb = OSTCBPrioTbl[oldprio];
002FCC  90500E     MOV.B [W14+16], W0
002FCE  FB8000     ZE W0, W0
002FD0  400080     ADD W0, W0, W1
002FD2  209C20     MOV #0x9C2, W0
002FD4  408000     ADD W1, W0, W0
002FD6  780190     MOV [W0], W3
002FD8  980733     MOV W3, [W14+6]
95:                    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
002FDA  90003E     MOV [W14+6], W0
002FDC  E00000     CP0 W0
002FDE  3A0004     BRA NZ, 0x2FE8
96:                        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
002FE0  9000AE     MOV [W14+4], W1
002FE2  880211     MOV W1, SR
97:                        return (OS_ERR_PRIO);
002FE4  B3C290     MOV.B #0x29, W0
002FE6  3700F6     BRA 0x31D4
98:                    }
99:                    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
002FE8  90003E     MOV [W14+6], W0
002FEA  500FE1     SUB W0, #0x1, [W15]
002FEC  3A0004     BRA NZ, 0x2FF6
100:                       OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
002FEE  9001AE     MOV [W14+4], W3
002FF0  880213     MOV W3, SR
101:                       return (OS_ERR_TASK_NOT_EXIST);
002FF2  B3C430     MOV.B #0x43, W0
002FF4  3700EF     BRA 0x31D4
102:                   }
103:               #if OS_LOWEST_PRIO <= 63u
104:                   y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
002FF6  90501E     MOV.B [W14+17], W0
002FF8  FB8000     ZE W0, W0
002FFA  DE0043     LSR W0, #3, W0
002FFC  984F00     MOV.B W0, [W14+8]
105:                   x_new                 = (INT8U)(newprio & 0x07u);
002FFE  90501E     MOV.B [W14+17], W0
003000  604067     AND.B W0, #0x7, W0
003002  984F10     MOV.B W0, [W14+9]
106:               #else
107:                   y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
108:                   x_new                 = (INT8U)(newprio & 0x0Fu);
109:               #endif
110:                   bity_new              = (OS_PRIO)(1uL << y_new);
003004  90480E     MOV.B [W14+8], W0
003006  FB8100     ZE W0, W2
003008  200010     MOV #0x1, W0
00300A  200001     MOV #0x0, W1
00300C  780182     MOV W2, W3
00300E  E90183     DEC W3, W3
003010  330003     BRA N, 0x3018
003012  400000     ADD W0, W0, W0
003014  488081     ADDC W1, W1, W1
003016  37FFFB     BRA 0x300E
003018  984F20     MOV.B W0, [W14+10]
111:                   bitx_new              = (OS_PRIO)(1uL << x_new);
00301A  90481E     MOV.B [W14+9], W0
00301C  FB8100     ZE W0, W2
00301E  200010     MOV #0x1, W0
003020  200001     MOV #0x0, W1
003022  780182     MOV W2, W3
003024  E90183     DEC W3, W3
003026  330003     BRA N, 0x302E
003028  400000     ADD W0, W0, W0
00302A  488081     ADDC W1, W1, W1
00302C  37FFFB     BRA 0x3024
00302E  984F30     MOV.B W0, [W14+11]
112:               
113:                   OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
003030  90500E     MOV.B [W14+16], W0
003032  FB8000     ZE W0, W0
003034  400080     ADD W0, W0, W1
003036  209C20     MOV #0x9C2, W0
003038  408000     ADD W1, W0, W0
00303A  EB0080     CLR W1
00303C  780801     MOV W1, [W0]
114:                   OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00303E  90501E     MOV.B [W14+17], W0
003040  FB8000     ZE W0, W0
003042  400080     ADD W0, W0, W1
003044  209C20     MOV #0x9C2, W0
003046  408000     ADD W1, W0, W0
003048  9000BE     MOV [W14+6], W1
00304A  780801     MOV W1, [W0]
115:                   y_old                 =  ptcb->OSTCBY;
00304C  90003E     MOV [W14+6], W0
00304E  9061C0     MOV.B [W0+36], W3
003050  984F43     MOV.B W3, [W14+12]
116:                   bity_old              =  ptcb->OSTCBBitY;
003052  90003E     MOV [W14+6], W0
003054  9060E0     MOV.B [W0+38], W1
003056  984F51     MOV.B W1, [W14+13]
117:                   bitx_old              =  ptcb->OSTCBBitX;
003058  90003E     MOV [W14+6], W0
00305A  9061D0     MOV.B [W0+37], W3
00305C  984F63     MOV.B W3, [W14+14]
118:                   if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00305E  90484E     MOV.B [W14+12], W0
003060  FB8000     ZE W0, W0
003062  209401     MOV #0x940, W1
003064  7840E1     MOV.B [W1+W0], W1
003066  90486E     MOV.B [W14+14], W0
003068  60C000     AND.B W1, W0, W0
00306A  E00400     CP0.B W0
00306C  320025     BRA Z, 0x30B8
119:                        OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
00306E  90484E     MOV.B [W14+12], W0
003070  FB8000     ZE W0, W0
003072  9048CE     MOV.B [W14+12], W1
003074  FB8081     ZE W1, W1
003076  209402     MOV #0x940, W2
003078  78C162     MOV.B [W2+W1], W2
00307A  9048EE     MOV.B [W14+14], W1
00307C  EAC081     COM.B W1, W1
00307E  614101     AND.B W2, W1, W2
003080  209401     MOV #0x940, W1
003082  787082     MOV.B W2, [W1+W0]
120:                        if (OSRdyTbl[y_old] == 0u) {
003084  90484E     MOV.B [W14+12], W0
003086  FB8000     ZE W0, W0
003088  209401     MOV #0x940, W1
00308A  784061     MOV.B [W1+W0], W0
00308C  E00400     CP0.B W0
00308E  3A0005     BRA NZ, 0x309A
121:                            OSRdyGrp &= (OS_PRIO)~bity_old;
003090  90485E     MOV.B [W14+13], W0
003092  EAC080     COM.B W0, W1
003094  BFC86F     MOV.B OSRdyGrp, WREG
003096  60C000     AND.B W1, W0, W0
003098  B7E86F     MOV.B WREG, OSRdyGrp
122:                        }
123:                        OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
00309A  2086F1     MOV #0x86F, W1
00309C  784091     MOV.B [W1], W1
00309E  90482E     MOV.B [W14+10], W0
0030A0  70C000     IOR.B W1, W0, W0
0030A2  B7E86F     MOV.B WREG, OSRdyGrp
124:                        OSRdyTbl[y_new] |= bitx_new;
0030A4  90480E     MOV.B [W14+8], W0
0030A6  FB8000     ZE W0, W0
0030A8  90488E     MOV.B [W14+8], W1
0030AA  FB8081     ZE W1, W1
0030AC  209402     MOV #0x940, W2
0030AE  78C162     MOV.B [W2+W1], W2
0030B0  9048BE     MOV.B [W14+11], W1
0030B2  714101     IOR.B W2, W1, W2
0030B4  209401     MOV #0x940, W1
0030B6  787082     MOV.B W2, [W1+W0]
125:                   }
126:               
127:               #if (OS_EVENT_EN)
128:                   pevent = ptcb->OSTCBEventPtr;
0030B8  90003E     MOV [W14+6], W0
0030BA  900890     MOV [W0+18], W1
0030BC  780F01     MOV W1, [W14]
129:                   if (pevent != (OS_EVENT *)0) {
0030BE  78001E     MOV [W14], W0
0030C0  E00000     CP0 W0
0030C2  320030     BRA Z, 0x3124
130:                       pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
0030C4  90484E     MOV.B [W14+12], W0
0030C6  FB8000     ZE W0, W0
0030C8  9048CE     MOV.B [W14+12], W1
0030CA  FB8081     ZE W1, W1
0030CC  78011E     MOV [W14], W2
0030CE  4080E6     ADD W1, #0x6, W1
0030D0  410081     ADD W2, W1, W1
0030D2  904111     MOV.B [W1+1], W2
0030D4  9048EE     MOV.B [W14+14], W1
0030D6  EAC081     COM.B W1, W1
0030D8  614081     AND.B W2, W1, W1
0030DA  78011E     MOV [W14], W2
0030DC  410000     ADD W2, W0, W0
0030DE  984071     MOV.B W1, [W0+7]
131:                       if (pevent->OSEventTbl[y_old] == 0u) {
0030E0  90484E     MOV.B [W14+12], W0
0030E2  FB8000     ZE W0, W0
0030E4  78009E     MOV [W14], W1
0030E6  400066     ADD W0, #0x6, W0
0030E8  408000     ADD W1, W0, W0
0030EA  904010     MOV.B [W0+1], W0
0030EC  E00400     CP0.B W0
0030EE  3A0007     BRA NZ, 0x30FE
132:                           pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0030F0  78001E     MOV [W14], W0
0030F2  9040E0     MOV.B [W0+6], W1
0030F4  90485E     MOV.B [W14+13], W0
0030F6  EAC000     COM.B W0, W0
0030F8  60C080     AND.B W1, W0, W1
0030FA  78001E     MOV [W14], W0
0030FC  984061     MOV.B W1, [W0+6]
133:                       }
134:                       pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
0030FE  78001E     MOV [W14], W0
003100  9040E0     MOV.B [W0+6], W1
003102  90482E     MOV.B [W14+10], W0
003104  70C080     IOR.B W1, W0, W1
003106  78001E     MOV [W14], W0
003108  984061     MOV.B W1, [W0+6]
135:                       pevent->OSEventTbl[y_new] |= bitx_new;
00310A  90480E     MOV.B [W14+8], W0
00310C  FB8000     ZE W0, W0
00310E  90488E     MOV.B [W14+8], W1
003110  FB8081     ZE W1, W1
003112  78011E     MOV [W14], W2
003114  4080E6     ADD W1, #0x6, W1
003116  410081     ADD W2, W1, W1
003118  904111     MOV.B [W1+1], W2
00311A  9048BE     MOV.B [W14+11], W1
00311C  714081     IOR.B W2, W1, W1
00311E  78011E     MOV [W14], W2
003120  410000     ADD W2, W0, W0
003122  984071     MOV.B W1, [W0+7]
136:                   }
137:               #if (OS_EVENT_MULTI_EN > 0u)
138:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
003124  90003E     MOV [W14+6], W0
003126  900820     MOV [W0+20], W0
003128  E00000     CP0 W0
00312A  32003E     BRA Z, 0x31A8
139:                       pevents =  ptcb->OSTCBEventMultiPtr;
00312C  90003E     MOV [W14+6], W0
00312E  9009A0     MOV [W0+20], W3
003130  980713     MOV W3, [W14+2]
140:                       pevent  = *pevents;
003132  90001E     MOV [W14+2], W0
003134  780F10     MOV [W0], [W14]
141:                       while (pevent != (OS_EVENT *)0) {
003136  370035     BRA 0x31A2
0031A2  78001E     MOV [W14], W0
0031A4  E00000     CP0 W0
0031A6  3AFFC8     BRA NZ, 0x3138
142:                           pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
003138  90484E     MOV.B [W14+12], W0
00313A  FB8000     ZE W0, W0
00313C  9048CE     MOV.B [W14+12], W1
00313E  FB8081     ZE W1, W1
003140  78011E     MOV [W14], W2
003142  4080E6     ADD W1, #0x6, W1
003144  410081     ADD W2, W1, W1
003146  904111     MOV.B [W1+1], W2
003148  9048EE     MOV.B [W14+14], W1
00314A  EAC081     COM.B W1, W1
00314C  614081     AND.B W2, W1, W1
00314E  78011E     MOV [W14], W2
003150  410000     ADD W2, W0, W0
003152  984071     MOV.B W1, [W0+7]
143:                           if (pevent->OSEventTbl[y_old] == 0u) {
003154  90484E     MOV.B [W14+12], W0
003156  FB8000     ZE W0, W0
003158  78009E     MOV [W14], W1
00315A  400066     ADD W0, #0x6, W0
00315C  408000     ADD W1, W0, W0
00315E  904010     MOV.B [W0+1], W0
003160  E00400     CP0.B W0
003162  3A0007     BRA NZ, 0x3172
144:                               pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
003164  78001E     MOV [W14], W0
003166  9040E0     MOV.B [W0+6], W1
003168  90485E     MOV.B [W14+13], W0
00316A  EAC000     COM.B W0, W0
00316C  60C080     AND.B W1, W0, W1
00316E  78001E     MOV [W14], W0
003170  984061     MOV.B W1, [W0+6]
145:                           }
146:                           pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
003172  78001E     MOV [W14], W0
003174  9040E0     MOV.B [W0+6], W1
003176  90482E     MOV.B [W14+10], W0
003178  70C080     IOR.B W1, W0, W1
00317A  78001E     MOV [W14], W0
00317C  984061     MOV.B W1, [W0+6]
147:                           pevent->OSEventTbl[y_new] |= bitx_new;
00317E  90480E     MOV.B [W14+8], W0
003180  FB8000     ZE W0, W0
003182  90488E     MOV.B [W14+8], W1
003184  FB8081     ZE W1, W1
003186  78011E     MOV [W14], W2
003188  4080E6     ADD W1, #0x6, W1
00318A  410081     ADD W2, W1, W1
00318C  904111     MOV.B [W1+1], W2
00318E  9048BE     MOV.B [W14+11], W1
003190  714081     IOR.B W2, W1, W1
003192  78011E     MOV [W14], W2
003194  410000     ADD W2, W0, W0
003196  984071     MOV.B W1, [W0+7]
148:                           pevents++;
003198  90001E     MOV [W14+2], W0
00319A  E88000     INC2 W0, W0
00319C  980710     MOV W0, [W14+2]
149:                           pevent                     = *pevents;
00319E  90001E     MOV [W14+2], W0
0031A0  780F10     MOV [W0], [W14]
150:                       }
151:                   }
152:               #endif
153:               #endif
154:               
155:                   ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
0031A8  90003E     MOV [W14+6], W0
0031AA  90509E     MOV.B [W14+17], W1
0031AC  986021     MOV.B W1, [W0+34]
156:                   ptcb->OSTCBY    = y_new;
0031AE  90003E     MOV [W14+6], W0
0031B0  90498E     MOV.B [W14+8], W3
0031B2  986043     MOV.B W3, [W0+36]
157:                   ptcb->OSTCBX    = x_new;
0031B4  90003E     MOV [W14+6], W0
0031B6  90489E     MOV.B [W14+9], W1
0031B8  986031     MOV.B W1, [W0+35]
158:                   ptcb->OSTCBBitY = bity_new;
0031BA  90003E     MOV [W14+6], W0
0031BC  9049AE     MOV.B [W14+10], W3
0031BE  986063     MOV.B W3, [W0+38]
159:                   ptcb->OSTCBBitX = bitx_new;
0031C0  90003E     MOV [W14+6], W0
0031C2  9048BE     MOV.B [W14+11], W1
0031C4  986051     MOV.B W1, [W0+37]
160:                   OS_EXIT_CRITICAL();
0031C6  9001AE     MOV [W14+4], W3
0031C8  880213     MOV W3, SR
161:                   if (OSRunning == OS_TRUE) {
0031CA  BFC870     MOV.B OSRunning, WREG
0031CC  504FE1     SUB.B W0, #0x1, [W15]
0031CE  3A0001     BRA NZ, 0x31D2
162:                       OS_Sched();                                         /* Find new highest priority task          */
0031D0  07F0AF     RCALL OS_Sched
163:                   }
164:                   return (OS_ERR_NONE);
0031D2  EB4000     CLR.B W0
165:               }
0031D4  FA8000     ULNK
0031D6  060000     RETURN
166:               #endif
167:               /*$PAGE*/
168:               /*
169:               *********************************************************************************************************
170:               *                                            CREATE A TASK
171:               *
172:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
173:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
174:               *              created by an ISR.
175:               *
176:               * Arguments  : task     is a pointer to the task's code
177:               *
178:               *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
179:               *                       the task when the task first executes.  Where the task is concerned it thinks
180:               *                       it was invoked and passed the argument 'p_arg' as follows:
181:               *
182:               *                           void Task (void *p_arg)
183:               *                           {
184:               *                               for (;;) {
185:               *                                   Task code;
186:               *                               }
187:               *                           }
188:               *
189:               *              ptos     is a pointer to the task's top of stack.  If the configuration constant
190:               *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
191:               *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
192:               *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
193:               *                       lowest memory location of the stack and the stack will grow with increasing
194:               *                       memory locations.
195:               *
196:               *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
197:               *                       lower the number, the higher the priority.
198:               *
199:               * Returns    : OS_ERR_NONE                      if the function was successful.
200:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
201:               *                                               (each task MUST have a unique priority).
202:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
203:               *                                               allowed (i.e. >= OS_LOWEST_PRIO)
204:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
205:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
206:               *                                               operation started.
207:               *********************************************************************************************************
208:               */
209:               
210:               #if OS_TASK_CREATE_EN > 0u
211:               INT8U  OSTaskCreate (void   (*task)(void *p_arg),
212:                                    void    *p_arg,
213:                                    OS_STK  *ptos,
214:                                    INT8U    prio)
215:               {
0031D8  FA000E     LNK #0xE
0031DA  980730     MOV W0, [W14+6]
0031DC  980741     MOV W1, [W14+8]
0031DE  980752     MOV W2, [W14+10]
0031E0  984F43     MOV.B W3, [W14+12]
216:                   OS_STK     *psp;
217:                   INT8U       err;
218:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
219:                   OS_CPU_SR   cpu_sr = 0u;
0031E2  EB0000     CLR W0
0031E4  780F00     MOV W0, [W14]
220:               #endif
221:               
222:               
223:               
224:               #ifdef OS_SAFETY_CRITICAL_IEC61508
225:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
226:                       OS_SAFETY_CRITICAL_EXCEPTION();
227:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
228:                   }
229:               #endif
230:               
231:               #if OS_ARG_CHK_EN > 0u
232:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
0031E6  90484E     MOV.B [W14+12], W0
0031E8  504FEC     SUB.B W0, #0xC, [W15]
0031EA  360002     BRA LEU, 0x31F0
233:                       return (OS_ERR_PRIO_INVALID);
0031EC  B3C2A0     MOV.B #0x2A, W0
0031EE  370049     BRA 0x3282
234:                   }
235:               #endif
236:                   OS_ENTER_CRITICAL();
0031F0  800211     MOV SR, W1
0031F2  780F01     MOV W1, [W14]
0031F4  800211     MOV SR, W1
0031F6  200E00     MOV #0xE0, W0
0031F8  700001     IOR W0, W1, W0
0031FA  880210     MOV W0, SR
237:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0031FC  BFC86B     MOV.B OSIntNesting, WREG
0031FE  E00400     CP0.B W0
003200  320004     BRA Z, 0x320A
238:                       OS_EXIT_CRITICAL();
003202  78009E     MOV [W14], W1
003204  880211     MOV W1, SR
239:                       return (OS_ERR_TASK_CREATE_ISR);
003206  B3C3C0     MOV.B #0x3C, W0
003208  37003C     BRA 0x3282
240:                   }
241:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
00320A  90484E     MOV.B [W14+12], W0
00320C  FB8000     ZE W0, W0
00320E  400080     ADD W0, W0, W1
003210  209C20     MOV #0x9C2, W0
003212  408000     ADD W1, W0, W0
003214  780010     MOV [W0], W0
003216  E00000     CP0 W0
003218  3A0031     BRA NZ, 0x327C
242:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00321A  90484E     MOV.B [W14+12], W0
00321C  FB8000     ZE W0, W0
00321E  400080     ADD W0, W0, W1
003220  209C20     MOV #0x9C2, W0
003222  408000     ADD W1, W0, W0
003224  200011     MOV #0x1, W1
003226  780801     MOV W1, [W0]
243:                                                            /* ... the same thing until task is created.              */
244:                       OS_EXIT_CRITICAL();
003228  78009E     MOV [W14], W1
00322A  880211     MOV W1, SR
245:                       psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
00322C  EB0180     CLR W3
00322E  90015E     MOV [W14+10], W2
003230  9000CE     MOV [W14+8], W1
003232  90003E     MOV [W14+6], W0
003234  071C4D     RCALL OSTaskStkInit
003236  980710     MOV W0, [W14+2]
246:                       err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
003238  EB0380     CLR W7
00323A  EB0300     CLR W6
00323C  B82260     MUL.UU W4, #0, W4
00323E  EB0180     CLR W3
003240  EB0100     CLR W2
003242  90009E     MOV [W14+2], W1
003244  90484E     MOV.B [W14+12], W0
003246  07F15A     RCALL OS_TCBInit
003248  984740     MOV.B W0, [W14+4]
247:                       if (err == OS_ERR_NONE) {
00324A  90404E     MOV.B [W14+4], W0
00324C  E00400     CP0.B W0
00324E  3A0005     BRA NZ, 0x325A
248:                           if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
003250  BFC870     MOV.B OSRunning, WREG
003252  504FE1     SUB.B W0, #0x1, [W15]
003254  3A0011     BRA NZ, 0x3278
249:                               OS_Sched();
003256  07F06C     RCALL OS_Sched
003258  37000F     BRA 0x3278
250:                           }
251:                       } else {
252:                           OS_ENTER_CRITICAL();
00325A  800211     MOV SR, W1
00325C  780F01     MOV W1, [W14]
00325E  800211     MOV SR, W1
003260  200E00     MOV #0xE0, W0
003262  700001     IOR W0, W1, W0
003264  880210     MOV W0, SR
253:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
003266  90484E     MOV.B [W14+12], W0
003268  FB8000     ZE W0, W0
00326A  400080     ADD W0, W0, W1
00326C  209C20     MOV #0x9C2, W0
00326E  408000     ADD W1, W0, W0
003270  EB0080     CLR W1
003272  780801     MOV W1, [W0]
254:                           OS_EXIT_CRITICAL();
003274  78009E     MOV [W14], W1
003276  880211     MOV W1, SR
255:                       }
256:                       return (err);
003278  90404E     MOV.B [W14+4], W0
00327A  370003     BRA 0x3282
257:                   }
258:                   OS_EXIT_CRITICAL();
00327C  78009E     MOV [W14], W1
00327E  880211     MOV W1, SR
259:                   return (OS_ERR_PRIO_EXIST);
003280  B3C280     MOV.B #0x28, W0
260:               }
003282  FA8000     ULNK
003284  060000     RETURN
261:               #endif
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                  CREATE A TASK (Extended Version)
266:               *
267:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
268:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
269:               *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
270:               *              additional information about a task to be specified.
271:               *
272:               * Arguments  : task      is a pointer to the task's code
273:               *
274:               *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
275:               *                        the task when the task first executes.  Where the task is concerned it thinks
276:               *                        it was invoked and passed the argument 'p_arg' as follows:
277:               *
278:               *                            void Task (void *p_arg)
279:               *                            {
280:               *                                for (;;) {
281:               *                                    Task code;
282:               *                                }
283:               *                            }
284:               *
285:               *              ptos      is a pointer to the task's top of stack.  If the configuration constant
286:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
287:               *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
288:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
289:               *                        lowest memory location of the stack and the stack will grow with increasing
290:               *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
291:               *
292:               *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
293:               *                        lower the number, the higher the priority.
294:               *
295:               *              id        is the task's ID (0..65535)
296:               *
297:               *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
298:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
299:               *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
300:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
301:               *                        HIGHEST memory location of the stack and the stack will grow with increasing
302:               *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
303:               *
304:               *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
305:               *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
306:               *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
307:               *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
308:               *                        available on the stack.
309:               *
310:               *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
311:               *                        For example, this user memory can hold the contents of floating-point registers
312:               *                        during a context switch, the time each task takes to execute, the number of times
313:               *                        the task has been switched-in, etc.
314:               *
315:               *              opt       contains additional information (or options) about the behavior of the task.  The
316:               *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
317:               *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
318:               *
319:               *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
320:               *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
321:               *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
322:               *                                                 during a context switch.
323:               *
324:               * Returns    : OS_ERR_NONE                      if the function was successful.
325:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
326:               *                                               (each task MUST have a unique priority).
327:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
328:               *                                               allowed (i.e. > OS_LOWEST_PRIO)
329:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
330:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
331:               *                                               operation started.
332:               *********************************************************************************************************
333:               */
334:               /*$PAGE*/
335:               #if OS_TASK_CREATE_EXT_EN > 0u
336:               INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
337:                                       void    *p_arg,
338:                                       OS_STK  *ptos,
339:                                       INT8U    prio,
340:                                       INT16U   id,
341:                                       OS_STK  *pbos,
342:                                       INT32U   stk_size,
343:                                       void    *pext,
344:                                       INT16U   opt)
345:               {
003286  FA0016     LNK #0x16
003288  980730     MOV W0, [W14+6]
00328A  980741     MOV W1, [W14+8]
00328C  980752     MOV W2, [W14+10]
00328E  984F43     MOV.B W3, [W14+12]
003290  980774     MOV W4, [W14+14]
003292  980F05     MOV W5, [W14+16]
003294  980F16     MOV W6, [W14+18]
003296  980F27     MOV W7, [W14+20]
346:                   OS_STK     *psp;
347:                   INT8U       err;
348:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
349:                   OS_CPU_SR   cpu_sr = 0u;
003298  EB0000     CLR W0
00329A  780F00     MOV W0, [W14]
350:               #endif
351:               
352:               
353:               
354:               #ifdef OS_SAFETY_CRITICAL_IEC61508
355:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
356:                       OS_SAFETY_CRITICAL_EXCEPTION();
357:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
358:                   }
359:               #endif
360:               
361:               #if OS_ARG_CHK_EN > 0u
362:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
00329C  90484E     MOV.B [W14+12], W0
00329E  504FEC     SUB.B W0, #0xC, [W15]
0032A0  360002     BRA LEU, 0x32A6
363:                       return (OS_ERR_PRIO_INVALID);
0032A2  B3C2A0     MOV.B #0x2A, W0
0032A4  37004F     BRA 0x3344
364:                   }
365:               #endif
366:                   OS_ENTER_CRITICAL();
0032A6  800211     MOV SR, W1
0032A8  780F01     MOV W1, [W14]
0032AA  800211     MOV SR, W1
0032AC  200E00     MOV #0xE0, W0
0032AE  700001     IOR W0, W1, W0
0032B0  880210     MOV W0, SR
367:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0032B2  BFC86B     MOV.B OSIntNesting, WREG
0032B4  E00400     CP0.B W0
0032B6  320004     BRA Z, 0x32C0
368:                       OS_EXIT_CRITICAL();
0032B8  78009E     MOV [W14], W1
0032BA  880211     MOV W1, SR
369:                       return (OS_ERR_TASK_CREATE_ISR);
0032BC  B3C3C0     MOV.B #0x3C, W0
0032BE  370042     BRA 0x3344
370:                   }
371:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
0032C0  90484E     MOV.B [W14+12], W0
0032C2  FB8000     ZE W0, W0
0032C4  400080     ADD W0, W0, W1
0032C6  209C20     MOV #0x9C2, W0
0032C8  408000     ADD W1, W0, W0
0032CA  780010     MOV [W0], W0
0032CC  E00000     CP0 W0
0032CE  3A0037     BRA NZ, 0x333E
372:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
0032D0  90484E     MOV.B [W14+12], W0
0032D2  FB8000     ZE W0, W0
0032D4  400080     ADD W0, W0, W1
0032D6  209C20     MOV #0x9C2, W0
0032D8  408000     ADD W1, W0, W0
0032DA  200011     MOV #0x1, W1
0032DC  780801     MOV W1, [W0]
373:                                                            /* ... the same thing until task is created.              */
374:                       OS_EXIT_CRITICAL();
0032DE  78009E     MOV [W14], W1
0032E0  880211     MOV W1, SR
375:               
376:               #if (OS_TASK_STAT_STK_CHK_EN > 0u)
377:                       OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
0032E2  97B8BE     MOV [W14-10], W1
0032E4  90091E     MOV [W14+18], W2
0032E6  9009AE     MOV [W14+20], W3
0032E8  90080E     MOV [W14+16], W0
0032EA  0703EE     RCALL OS_TaskStkClr
378:               #endif
379:               
380:                       psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
0032EC  97B9BE     MOV [W14-10], W3
0032EE  90015E     MOV [W14+10], W2
0032F0  9000CE     MOV [W14+8], W1
0032F2  90003E     MOV [W14+6], W0
0032F4  071BED     RCALL OSTaskStkInit
0032F6  980710     MOV W0, [W14+2]
381:                       err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
0032F8  97BBBE     MOV [W14-10], W7
0032FA  97BB4E     MOV [W14-8], W6
0032FC  900A1E     MOV [W14+18], W4
0032FE  900AAE     MOV [W14+20], W5
003300  9001FE     MOV [W14+14], W3
003302  90090E     MOV [W14+16], W2
003304  90009E     MOV [W14+2], W1
003306  90484E     MOV.B [W14+12], W0
003308  07F0F9     RCALL OS_TCBInit
00330A  984740     MOV.B W0, [W14+4]
382:                       if (err == OS_ERR_NONE) {
00330C  90404E     MOV.B [W14+4], W0
00330E  E00400     CP0.B W0
003310  3A0005     BRA NZ, 0x331C
383:                           if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
003312  BFC870     MOV.B OSRunning, WREG
003314  504FE1     SUB.B W0, #0x1, [W15]
003316  3A0011     BRA NZ, 0x333A
384:                               OS_Sched();
003318  07F00B     RCALL OS_Sched
00331A  37000F     BRA 0x333A
385:                           }
386:                       } else {
387:                           OS_ENTER_CRITICAL();
00331C  800211     MOV SR, W1
00331E  780F01     MOV W1, [W14]
003320  800211     MOV SR, W1
003322  200E00     MOV #0xE0, W0
003324  700001     IOR W0, W1, W0
003326  880210     MOV W0, SR
388:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
003328  90484E     MOV.B [W14+12], W0
00332A  FB8000     ZE W0, W0
00332C  400080     ADD W0, W0, W1
00332E  209C20     MOV #0x9C2, W0
003330  408000     ADD W1, W0, W0
003332  EB0080     CLR W1
003334  780801     MOV W1, [W0]
389:                           OS_EXIT_CRITICAL();
003336  78009E     MOV [W14], W1
003338  880211     MOV W1, SR
390:                       }
391:                       return (err);
00333A  90404E     MOV.B [W14+4], W0
00333C  370003     BRA 0x3344
392:                   }
393:                   OS_EXIT_CRITICAL();
00333E  78009E     MOV [W14], W1
003340  880211     MOV W1, SR
394:                   return (OS_ERR_PRIO_EXIST);
003342  B3C280     MOV.B #0x28, W0
395:               }
003344  FA8000     ULNK
003346  060000     RETURN
396:               #endif
397:               /*$PAGE*/
398:               /*
399:               *********************************************************************************************************
400:               *                                            DELETE A TASK
401:               *
402:               * Description: This function allows you to delete a task.  The calling task can delete itself by
403:               *              its own priority number.  The deleted task is returned to the dormant state and can be
404:               *              re-activated by creating the deleted task again.
405:               *
406:               * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
407:               *                      the current task without knowing its priority level by setting 'prio' to
408:               *                      OS_PRIO_SELF.
409:               *
410:               * Returns    : OS_ERR_NONE             if the call is successful
411:               *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
412:               *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
413:               *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
414:               *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
415:               *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
416:               *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
417:               *
418:               * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
419:               *                    a) by making it not ready
420:               *                    b) by removing it from any wait lists
421:               *                    c) by preventing OSTimeTick() from making the task ready to run.
422:               *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
423:               *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
424:               *                 the next instruction following the enable interrupt instruction is ignored.
425:               *              3) An ISR cannot delete a task.
426:               *              4) The lock nesting counter is incremented because, for a brief instant, if the current
427:               *                 task is being deleted, the current task would not be able to be rescheduled because it
428:               *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
429:               *                 from being schedule.  This means that an ISR would return to the current task which is
430:               *                 being deleted.  The rest of the deletion would thus be able to be completed.
431:               *********************************************************************************************************
432:               */
433:               
434:               #if OS_TASK_DEL_EN > 0u
435:               INT8U  OSTaskDel (INT8U prio)
436:               {
003348  FA0008     LNK #0x8
00334A  984760     MOV.B W0, [W14+6]
437:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
438:                   OS_FLAG_NODE *pnode;
439:               #endif
440:                   OS_TCB       *ptcb;
441:               #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
442:                   OS_CPU_SR     cpu_sr = 0u;
00334C  EB0000     CLR W0
00334E  780F00     MOV W0, [W14]
443:               #endif
444:               
445:               
446:               
447:                   if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
003350  BFC86B     MOV.B OSIntNesting, WREG
003352  E00400     CP0.B W0
003354  320002     BRA Z, 0x335A
448:                       return (OS_ERR_TASK_DEL_ISR);
003356  B3C400     MOV.B #0x40, W0
003358  3700B3     BRA 0x34C0
449:                   }
450:                   if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00335A  90406E     MOV.B [W14+6], W0
00335C  504FEC     SUB.B W0, #0xC, [W15]
00335E  3A0002     BRA NZ, 0x3364
451:                       return (OS_ERR_TASK_DEL_IDLE);
003360  B3C3E0     MOV.B #0x3E, W0
003362  3700AE     BRA 0x34C0
452:                   }
453:               #if OS_ARG_CHK_EN > 0u
454:                   if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
003364  90406E     MOV.B [W14+6], W0
003366  504FEB     SUB.B W0, #0xB, [W15]
003368  360005     BRA LEU, 0x3374
455:                       if (prio != OS_PRIO_SELF) {
00336A  90406E     MOV.B [W14+6], W0
00336C  404FE1     ADD.B W0, #0x1, [W15]
00336E  320002     BRA Z, 0x3374
456:                           return (OS_ERR_PRIO_INVALID);
003370  B3C2A0     MOV.B #0x2A, W0
003372  3700A6     BRA 0x34C0
457:                       }
458:                   }
459:               #endif
460:               
461:               /*$PAGE*/
462:                   OS_ENTER_CRITICAL();
003374  800211     MOV SR, W1
003376  780F01     MOV W1, [W14]
003378  800211     MOV SR, W1
00337A  200E00     MOV #0xE0, W0
00337C  700001     IOR W0, W1, W0
00337E  880210     MOV W0, SR
463:                   if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
003380  90406E     MOV.B [W14+6], W0
003382  404FE1     ADD.B W0, #0x1, [W15]
003384  3A0003     BRA NZ, 0x338C
464:                       prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
003386  8043B0     MOV OSTCBCur, W0
003388  9060A0     MOV.B [W0+34], W1
00338A  984761     MOV.B W1, [W14+6]
465:                   }
466:                   ptcb = OSTCBPrioTbl[prio];
00338C  90406E     MOV.B [W14+6], W0
00338E  FB8000     ZE W0, W0
003390  400080     ADD W0, W0, W1
003392  209C20     MOV #0x9C2, W0
003394  408000     ADD W1, W0, W0
003396  780090     MOV [W0], W1
003398  980711     MOV W1, [W14+2]
467:                   if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
00339A  90001E     MOV [W14+2], W0
00339C  E00000     CP0 W0
00339E  3A0004     BRA NZ, 0x33A8
468:                       OS_EXIT_CRITICAL();
0033A0  78009E     MOV [W14], W1
0033A2  880211     MOV W1, SR
469:                       return (OS_ERR_TASK_NOT_EXIST);
0033A4  B3C430     MOV.B #0x43, W0
0033A6  37008C     BRA 0x34C0
470:                   }
471:                   if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
0033A8  90001E     MOV [W14+2], W0
0033AA  500FE1     SUB W0, #0x1, [W15]
0033AC  3A0004     BRA NZ, 0x33B6
472:                       OS_EXIT_CRITICAL();
0033AE  78009E     MOV [W14], W1
0033B0  880211     MOV W1, SR
473:                       return (OS_ERR_TASK_DEL);
0033B2  B3C3D0     MOV.B #0x3D, W0
0033B4  370085     BRA 0x34C0
474:                   }
475:               
476:                   OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
0033B6  90001E     MOV [W14+2], W0
0033B8  906040     MOV.B [W0+36], W0
0033BA  FB8000     ZE W0, W0
0033BC  90009E     MOV [W14+2], W1
0033BE  9060C1     MOV.B [W1+36], W1
0033C0  FB8081     ZE W1, W1
0033C2  209402     MOV #0x940, W2
0033C4  78C162     MOV.B [W2+W1], W2
0033C6  90009E     MOV [W14+2], W1
0033C8  9060D1     MOV.B [W1+37], W1
0033CA  EAC081     COM.B W1, W1
0033CC  614101     AND.B W2, W1, W2
0033CE  209401     MOV #0x940, W1
0033D0  787082     MOV.B W2, [W1+W0]
477:                   if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
0033D2  90001E     MOV [W14+2], W0
0033D4  906040     MOV.B [W0+36], W0
0033D6  FB8000     ZE W0, W0
0033D8  209401     MOV #0x940, W1
0033DA  784061     MOV.B [W1+W0], W0
0033DC  E00400     CP0.B W0
0033DE  3A0006     BRA NZ, 0x33EC
478:                       OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
0033E0  90001E     MOV [W14+2], W0
0033E2  906060     MOV.B [W0+38], W0
0033E4  EAC080     COM.B W0, W1
0033E6  BFC86F     MOV.B OSRdyGrp, WREG
0033E8  60C000     AND.B W1, W0, W0
0033EA  B7E86F     MOV.B WREG, OSRdyGrp
479:                   }
480:               
481:               #if (OS_EVENT_EN)
482:                   if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
0033EC  90001E     MOV [W14+2], W0
0033EE  900810     MOV [W0+18], W0
0033F0  E00000     CP0 W0
0033F2  320005     BRA Z, 0x33FE
483:                       OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
0033F4  90001E     MOV [W14+2], W0
0033F6  900810     MOV [W0+18], W0
0033F8  780080     MOV W0, W1
0033FA  90001E     MOV [W14+2], W0
0033FC  07EE4C     RCALL OS_EventTaskRemove
484:                   }
485:               #if (OS_EVENT_MULTI_EN > 0u)
486:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
0033FE  90001E     MOV [W14+2], W0
003400  900820     MOV [W0+20], W0
003402  E00000     CP0 W0
003404  320005     BRA Z, 0x3410
487:                       OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
003406  90001E     MOV [W14+2], W0
003408  900820     MOV [W0+20], W0
00340A  780080     MOV W0, W1
00340C  90001E     MOV [W14+2], W0
00340E  07EE6A     RCALL OS_EventTaskRemoveMulti
488:                   }
489:               #endif
490:               #endif
491:               
492:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
493:                   pnode = ptcb->OSTCBFlagNode;
003410  90001E     MOV [W14+2], W0
003412  9008C0     MOV [W0+24], W1
003414  980721     MOV W1, [W14+4]
494:                   if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
003416  90002E     MOV [W14+4], W0
003418  E00000     CP0 W0
00341A  320002     BRA Z, 0x3420
495:                       OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00341C  90002E     MOV [W14+4], W0
00341E  070842     RCALL OS_FlagUnlink
496:                   }
497:               #endif
498:               
499:                   ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
003420  90011E     MOV [W14+2], W2
003422  B80060     MUL.UU W0, #0, W0
003424  980960     MOV W0, [W2+28]
003426  980971     MOV W1, [W2+30]
500:                   ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
003428  90001E     MOV [W14+2], W0
00342A  EB4080     CLR.B W1
00342C  986001     MOV.B W1, [W0+32]
501:                   ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00342E  90001E     MOV [W14+2], W0
003430  EB4080     CLR.B W1
003432  986011     MOV.B W1, [W0+33]
502:                   if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
003434  BFC86C     MOV.B OSLockNesting, WREG
003436  404FE1     ADD.B W0, #0x1, [W15]
003438  320003     BRA Z, 0x3440
503:                       OSLockNesting++;
00343A  BFC86C     MOV.B OSLockNesting, WREG
00343C  E84000     INC.B W0, W0
00343E  B7E86C     MOV.B WREG, OSLockNesting
504:                   }
505:                   OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
003440  78009E     MOV [W14], W1
003442  880211     MOV W1, SR
506:                   OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
003444  07ED4F     RCALL OS_Dummy
507:                   OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
003446  800211     MOV SR, W1
003448  780F01     MOV W1, [W14]
00344A  800211     MOV SR, W1
00344C  200E00     MOV #0xE0, W0
00344E  700001     IOR W0, W1, W0
003450  880210     MOV W0, SR
508:                   if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
003452  BFC86C     MOV.B OSLockNesting, WREG
003454  E00400     CP0.B W0
003456  320003     BRA Z, 0x345E
509:                       OSLockNesting--;
003458  BFC86C     MOV.B OSLockNesting, WREG
00345A  E94000     DEC.B W0, W0
00345C  B7E86C     MOV.B WREG, OSLockNesting
510:                   }
511:                   OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
00345E  90001E     MOV [W14+2], W0
003460  071B22     RCALL OSTaskDelHook
512:               
513:               #if OS_TASK_CREATE_EXT_EN > 0u
514:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
515:                   OS_TLS_TaskDel(ptcb);                               /* Call TLS hook                               */
516:               #endif
517:               #endif
518:               
519:                   OSTaskCtr--;                                        /* One less task being managed                 */
003462  BFC871     MOV.B OSTaskCtr, WREG
003464  E94000     DEC.B W0, W0
003466  B7E871     MOV.B WREG, OSTaskCtr
520:                   OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
003468  90406E     MOV.B [W14+6], W0
00346A  FB8000     ZE W0, W0
00346C  400080     ADD W0, W0, W1
00346E  209C20     MOV #0x9C2, W0
003470  408000     ADD W1, W0, W0
003472  EB0080     CLR W1
003474  780801     MOV W1, [W0]
521:                   if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
003476  90001E     MOV [W14+2], W0
003478  900800     MOV [W0+16], W0
00347A  E00000     CP0 W0
00347C  3A0008     BRA NZ, 0x348E
522:                       ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
00347E  90001E     MOV [W14+2], W0
003480  900070     MOV [W0+14], W0
003482  EB0080     CLR W1
003484  980801     MOV W1, [W0+16]
523:                       OSTCBList                  = ptcb->OSTCBNext;
003486  90001E     MOV [W14+2], W0
003488  900070     MOV [W0+14], W0
00348A  8843E0     MOV W0, OSTCBList
00348C  37000A     BRA 0x34A2
524:                   } else {
525:                       ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
00348E  90001E     MOV [W14+2], W0
003490  900800     MOV [W0+16], W0
003492  90009E     MOV [W14+2], W1
003494  9000F1     MOV [W1+14], W1
003496  980071     MOV W1, [W0+14]
526:                       ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
003498  90001E     MOV [W14+2], W0
00349A  900070     MOV [W0+14], W0
00349C  90009E     MOV [W14+2], W1
00349E  900881     MOV [W1+16], W1
0034A0  980801     MOV W1, [W0+16]
527:                   }
528:                   ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
0034A2  8043C1     MOV OSTCBFreeList, W1
0034A4  90001E     MOV [W14+2], W0
0034A6  980071     MOV W1, [W0+14]
529:                   OSTCBFreeList       = ptcb;
0034A8  90009E     MOV [W14+2], W1
0034AA  8843C1     MOV W1, OSTCBFreeList
530:               #if OS_TASK_NAME_EN > 0u
531:                   ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
0034AC  288461     MOV #0x8846, W1
0034AE  90001E     MOV [W14+2], W0
0034B0  981851     MOV W1, [W0+58]
532:               #endif
533:                   OS_EXIT_CRITICAL();
0034B2  78009E     MOV [W14], W1
0034B4  880211     MOV W1, SR
534:                   if (OSRunning == OS_TRUE) {
0034B6  BFC870     MOV.B OSRunning, WREG
0034B8  504FE1     SUB.B W0, #0x1, [W15]
0034BA  3A0001     BRA NZ, 0x34BE
535:                       OS_Sched();                                     /* Find new highest priority task              */
0034BC  07EF39     RCALL OS_Sched
536:                   }
537:                   return (OS_ERR_NONE);
0034BE  EB4000     CLR.B W0
538:               }
0034C0  FA8000     ULNK
0034C2  060000     RETURN
539:               #endif
540:               /*$PAGE*/
541:               /*
542:               *********************************************************************************************************
543:               *                                  REQUEST THAT A TASK DELETE ITSELF
544:               *
545:               * Description: This function is used to:
546:               *                   a) notify a task to delete itself.
547:               *                   b) to see if a task requested that the current task delete itself.
548:               *              This function is a little tricky to understand.  Basically, you have a task that needs
549:               *              to be deleted however, this task has resources that it has allocated (memory buffers,
550:               *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
551:               *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
552:               *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
553:               *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
554:               *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
555:               *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
556:               *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
557:               *              this:
558:               *
559:               *                   void Task(void *p_arg)
560:               *                   {
561:               *                       .
562:               *                       .
563:               *                       while (1) {
564:               *                           OSTimeDly(1);
565:               *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
566:               *                               Release any owned resources;
567:               *                               De-allocate any dynamic memory;
568:               *                               OSTaskDel(OS_PRIO_SELF);
569:               *                           }
570:               *                       }
571:               *                   }
572:               *
573:               * Arguments  : prio    is the priority of the task to request the delete from
574:               *
575:               * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
576:               *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
577:               *                                     the request has been executed.
578:               *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
579:               *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
580:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
581:               *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
582:               *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
583:               *                                     deleted.
584:               *********************************************************************************************************
585:               */
586:               /*$PAGE*/
587:               #if OS_TASK_DEL_EN > 0u
588:               INT8U  OSTaskDelReq (INT8U prio)
589:               {
0034C4  FA0008     LNK #0x8
0034C6  984760     MOV.B W0, [W14+6]
590:                   INT8U      stat;
591:                   OS_TCB    *ptcb;
592:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
593:                   OS_CPU_SR  cpu_sr = 0u;
0034C8  EB0000     CLR W0
0034CA  780F00     MOV W0, [W14]
594:               #endif
595:               
596:               
597:               
598:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
0034CC  90406E     MOV.B [W14+6], W0
0034CE  504FEC     SUB.B W0, #0xC, [W15]
0034D0  3A0002     BRA NZ, 0x34D6
599:                       return (OS_ERR_TASK_DEL_IDLE);
0034D2  B3C3E0     MOV.B #0x3E, W0
0034D4  370039     BRA 0x3548
600:                   }
601:               #if OS_ARG_CHK_EN > 0u
602:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
0034D6  90406E     MOV.B [W14+6], W0
0034D8  504FEB     SUB.B W0, #0xB, [W15]
0034DA  360005     BRA LEU, 0x34E6
603:                       if (prio != OS_PRIO_SELF) {
0034DC  90406E     MOV.B [W14+6], W0
0034DE  404FE1     ADD.B W0, #0x1, [W15]
0034E0  320002     BRA Z, 0x34E6
604:                           return (OS_ERR_PRIO_INVALID);
0034E2  B3C2A0     MOV.B #0x2A, W0
0034E4  370031     BRA 0x3548
605:                       }
606:                   }
607:               #endif
608:                   if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
0034E6  90406E     MOV.B [W14+6], W0
0034E8  404FE1     ADD.B W0, #0x1, [W15]
0034EA  3A000D     BRA NZ, 0x3506
609:                       OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
0034EC  800211     MOV SR, W1
0034EE  780F01     MOV W1, [W14]
0034F0  800211     MOV SR, W1
0034F2  200E00     MOV #0xE0, W0
0034F4  700001     IOR W0, W1, W0
0034F6  880210     MOV W0, SR
610:                       stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
0034F8  8043B0     MOV OSTCBCur, W0
0034FA  9060F0     MOV.B [W0+39], W1
0034FC  984721     MOV.B W1, [W14+2]
611:                       OS_EXIT_CRITICAL();
0034FE  78009E     MOV [W14], W1
003500  880211     MOV W1, SR
612:                       return (stat);
003502  90402E     MOV.B [W14+2], W0
003504  370021     BRA 0x3548
613:                   }
614:                   OS_ENTER_CRITICAL();
003506  800211     MOV SR, W1
003508  780F01     MOV W1, [W14]
00350A  800211     MOV SR, W1
00350C  200E00     MOV #0xE0, W0
00350E  700001     IOR W0, W1, W0
003510  880210     MOV W0, SR
615:                   ptcb = OSTCBPrioTbl[prio];
003512  90406E     MOV.B [W14+6], W0
003514  FB8000     ZE W0, W0
003516  400080     ADD W0, W0, W1
003518  209C20     MOV #0x9C2, W0
00351A  408000     ADD W1, W0, W0
00351C  780090     MOV [W0], W1
00351E  980721     MOV W1, [W14+4]
616:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
003520  90002E     MOV [W14+4], W0
003522  E00000     CP0 W0
003524  3A0004     BRA NZ, 0x352E
617:                       OS_EXIT_CRITICAL();
003526  78009E     MOV [W14], W1
003528  880211     MOV W1, SR
618:                       return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
00352A  B3C430     MOV.B #0x43, W0
00352C  37000D     BRA 0x3548
619:                   }
620:                   if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
00352E  90002E     MOV [W14+4], W0
003530  500FE1     SUB W0, #0x1, [W15]
003532  3A0004     BRA NZ, 0x353C
621:                       OS_EXIT_CRITICAL();
003534  78009E     MOV [W14], W1
003536  880211     MOV W1, SR
622:                       return (OS_ERR_TASK_DEL);
003538  B3C3D0     MOV.B #0x3D, W0
00353A  370006     BRA 0x3548
623:                   }
624:                   ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
00353C  90002E     MOV [W14+4], W0
00353E  B3C3F1     MOV.B #0x3F, W1
003540  986071     MOV.B W1, [W0+39]
625:                   OS_EXIT_CRITICAL();
003542  78009E     MOV [W14], W1
003544  880211     MOV W1, SR
626:                   return (OS_ERR_NONE);
003546  EB4000     CLR.B W0
627:               }
003548  FA8000     ULNK
00354A  060000     RETURN
628:               #endif
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                       GET THE NAME OF A TASK
633:               *
634:               * Description: This function is called to obtain the name of a task.
635:               *
636:               * Arguments  : prio      is the priority of the task that you want to obtain the name from.
637:               *
638:               *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
639:               *
640:               *              perr      is a pointer to an error code that can contain one of the following values:
641:               *
642:               *                        OS_ERR_NONE                if the requested task is resumed
643:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
644:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
645:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
646:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
647:               *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
648:               *
649:               *
650:               * Returns    : The length of the string or 0 if the task does not exist.
651:               *********************************************************************************************************
652:               */
653:               
654:               #if OS_TASK_NAME_EN > 0u
655:               INT8U  OSTaskNameGet (INT8U    prio,
656:                                     INT8U  **pname,
657:                                     INT8U   *perr)
658:               {
00354C  FA000C     LNK #0xC
00354E  984760     MOV.B W0, [W14+6]
003550  980741     MOV W1, [W14+8]
003552  980752     MOV W2, [W14+10]
659:                   OS_TCB    *ptcb;
660:                   INT8U      len;
661:               #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
662:                   OS_CPU_SR  cpu_sr = 0u;
003554  EB0000     CLR W0
003556  780F00     MOV W0, [W14]
663:               #endif
664:               
665:               
666:               
667:               #ifdef OS_SAFETY_CRITICAL
668:                   if (perr == (INT8U *)0) {
669:                       OS_SAFETY_CRITICAL_EXCEPTION();
670:                       return (0u);
671:                   }
672:               #endif
673:               
674:               #if OS_ARG_CHK_EN > 0u
675:                   if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
003558  90406E     MOV.B [W14+6], W0
00355A  504FEC     SUB.B W0, #0xC, [W15]
00355C  360008     BRA LEU, 0x356E
676:                       if (prio != OS_PRIO_SELF) {
00355E  90406E     MOV.B [W14+6], W0
003560  404FE1     ADD.B W0, #0x1, [W15]
003562  320005     BRA Z, 0x356E
677:                           *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
003564  90005E     MOV [W14+10], W0
003566  B3C2A1     MOV.B #0x2A, W1
003568  784801     MOV.B W1, [W0]
678:                           return (0u);
00356A  EB4000     CLR.B W0
00356C  370045     BRA 0x35F8
679:                       }
680:                   }
681:                   if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
00356E  90004E     MOV [W14+8], W0
003570  E00000     CP0 W0
003572  3A0005     BRA NZ, 0x357E
682:                       *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
003574  90005E     MOV [W14+10], W0
003576  B3C0C1     MOV.B #0xC, W1
003578  784801     MOV.B W1, [W0]
683:                       return (0u);
00357A  EB4000     CLR.B W0
00357C  37003D     BRA 0x35F8
684:                   }
685:               #endif
686:                   if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00357E  BFC86B     MOV.B OSIntNesting, WREG
003580  E00400     CP0.B W0
003582  320005     BRA Z, 0x358E
687:                       *perr = OS_ERR_NAME_GET_ISR;
003584  90005E     MOV [W14+10], W0
003586  B3C111     MOV.B #0x11, W1
003588  784801     MOV.B W1, [W0]
688:                       return (0u);
00358A  EB4000     CLR.B W0
00358C  370035     BRA 0x35F8
689:                   }
690:                   OS_ENTER_CRITICAL();
00358E  800211     MOV SR, W1
003590  780F01     MOV W1, [W14]
003592  800211     MOV SR, W1
003594  200E00     MOV #0xE0, W0
003596  700001     IOR W0, W1, W0
003598  880210     MOV W0, SR
691:                   if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
00359A  90406E     MOV.B [W14+6], W0
00359C  404FE1     ADD.B W0, #0x1, [W15]
00359E  3A0003     BRA NZ, 0x35A6
692:                       prio = OSTCBCur->OSTCBPrio;
0035A0  8043B0     MOV OSTCBCur, W0
0035A2  9060A0     MOV.B [W0+34], W1
0035A4  984761     MOV.B W1, [W14+6]
693:                   }
694:                   ptcb = OSTCBPrioTbl[prio];
0035A6  90406E     MOV.B [W14+6], W0
0035A8  FB8000     ZE W0, W0
0035AA  400080     ADD W0, W0, W1
0035AC  209C20     MOV #0x9C2, W0
0035AE  408000     ADD W1, W0, W0
0035B0  780090     MOV [W0], W1
0035B2  980711     MOV W1, [W14+2]
695:                   if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
0035B4  90001E     MOV [W14+2], W0
0035B6  E00000     CP0 W0
0035B8  3A0007     BRA NZ, 0x35C8
696:                       OS_EXIT_CRITICAL();                              /* No                                         */
0035BA  78009E     MOV [W14], W1
0035BC  880211     MOV W1, SR
697:                       *perr = OS_ERR_TASK_NOT_EXIST;
0035BE  90005E     MOV [W14+10], W0
0035C0  B3C431     MOV.B #0x43, W1
0035C2  784801     MOV.B W1, [W0]
698:                       return (0u);
0035C4  EB4000     CLR.B W0
0035C6  370018     BRA 0x35F8
699:                   }
700:                   if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
0035C8  90001E     MOV [W14+2], W0
0035CA  500FE1     SUB W0, #0x1, [W15]
0035CC  3A0007     BRA NZ, 0x35DC
701:                       OS_EXIT_CRITICAL();                              /* Yes                                        */
0035CE  78009E     MOV [W14], W1
0035D0  880211     MOV W1, SR
702:                       *perr = OS_ERR_TASK_NOT_EXIST;
0035D2  90005E     MOV [W14+10], W0
0035D4  B3C431     MOV.B #0x43, W1
0035D6  784801     MOV.B W1, [W0]
703:                       return (0u);
0035D8  EB4000     CLR.B W0
0035DA  37000E     BRA 0x35F8
704:                   }
705:                   *pname = ptcb->OSTCBTaskName;
0035DC  90001E     MOV [W14+2], W0
0035DE  9018D0     MOV [W0+58], W1
0035E0  90004E     MOV [W14+8], W0
0035E2  780801     MOV W1, [W0]
706:                   len    = OS_StrLen(*pname);
0035E4  90004E     MOV [W14+8], W0
0035E6  780010     MOV [W0], W0
0035E8  07EEE3     RCALL OS_StrLen
0035EA  984740     MOV.B W0, [W14+4]
707:                   OS_EXIT_CRITICAL();
0035EC  78009E     MOV [W14], W1
0035EE  880211     MOV W1, SR
708:                   *perr  = OS_ERR_NONE;
0035F0  90005E     MOV [W14+10], W0
0035F2  EB4080     CLR.B W1
0035F4  784801     MOV.B W1, [W0]
709:                   return (len);
0035F6  90404E     MOV.B [W14+4], W0
710:               }
0035F8  FA8000     ULNK
0035FA  060000     RETURN
711:               #endif
712:               
713:               /*$PAGE*/
714:               /*
715:               *********************************************************************************************************
716:               *                                       ASSIGN A NAME TO A TASK
717:               *
718:               * Description: This function is used to set the name of a task.
719:               *
720:               * Arguments  : prio      is the priority of the task that you want the assign a name to.
721:               *
722:               *              pname     is a pointer to an ASCII string that contains the name of the task.
723:               *
724:               *              perr       is a pointer to an error code that can contain one of the following values:
725:               *
726:               *                        OS_ERR_NONE                if the requested task is resumed
727:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
728:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
729:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
730:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
731:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
732:               *
733:               * Returns    : None
734:               *********************************************************************************************************
735:               */
736:               #if OS_TASK_NAME_EN > 0u
737:               void  OSTaskNameSet (INT8U   prio,
738:                                    INT8U  *pname,
739:                                    INT8U  *perr)
740:               {
0035FC  FA000A     LNK #0xA
0035FE  984740     MOV.B W0, [W14+4]
003600  980731     MOV W1, [W14+6]
003602  980742     MOV W2, [W14+8]
741:                   OS_TCB    *ptcb;
742:               #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
743:                   OS_CPU_SR  cpu_sr = 0u;
003604  EB0000     CLR W0
003606  780F00     MOV W0, [W14]
744:               #endif
745:               
746:               
747:               
748:               #ifdef OS_SAFETY_CRITICAL
749:                   if (perr == (INT8U *)0) {
750:                       OS_SAFETY_CRITICAL_EXCEPTION();
751:                       return;
752:                   }
753:               #endif
754:               
755:               #if OS_ARG_CHK_EN > 0u
756:                   if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
003608  90404E     MOV.B [W14+4], W0
00360A  504FEC     SUB.B W0, #0xC, [W15]
00360C  360007     BRA LEU, 0x361C
757:                       if (prio != OS_PRIO_SELF) {
00360E  90404E     MOV.B [W14+4], W0
003610  404FE1     ADD.B W0, #0x1, [W15]
003612  320004     BRA Z, 0x361C
758:                           *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
003614  90004E     MOV [W14+8], W0
003616  B3C2A1     MOV.B #0x2A, W1
003618  784801     MOV.B W1, [W0]
759:                           return;
00361A  37003B     BRA 0x3692
760:                       }
761:                   }
762:                   if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
00361C  90003E     MOV [W14+6], W0
00361E  E00000     CP0 W0
003620  3A0004     BRA NZ, 0x362A
763:                       *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
003622  90004E     MOV [W14+8], W0
003624  B3C0C1     MOV.B #0xC, W1
003626  784801     MOV.B W1, [W0]
764:                       return;
003628  370034     BRA 0x3692
765:                   }
766:               #endif
767:                   if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00362A  BFC86B     MOV.B OSIntNesting, WREG
00362C  E00400     CP0.B W0
00362E  320004     BRA Z, 0x3638
768:                       *perr = OS_ERR_NAME_SET_ISR;
003630  90004E     MOV [W14+8], W0
003632  B3C121     MOV.B #0x12, W1
003634  784801     MOV.B W1, [W0]
769:                       return;
003636  37002D     BRA 0x3692
770:                   }
771:                   OS_ENTER_CRITICAL();
003638  800211     MOV SR, W1
00363A  780F01     MOV W1, [W14]
00363C  800211     MOV SR, W1
00363E  200E00     MOV #0xE0, W0
003640  700001     IOR W0, W1, W0
003642  880210     MOV W0, SR
772:                   if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
003644  90404E     MOV.B [W14+4], W0
003646  404FE1     ADD.B W0, #0x1, [W15]
003648  3A0003     BRA NZ, 0x3650
773:                       prio = OSTCBCur->OSTCBPrio;
00364A  8043B0     MOV OSTCBCur, W0
00364C  9060A0     MOV.B [W0+34], W1
00364E  984741     MOV.B W1, [W14+4]
774:                   }
775:                   ptcb = OSTCBPrioTbl[prio];
003650  90404E     MOV.B [W14+4], W0
003652  FB8000     ZE W0, W0
003654  400080     ADD W0, W0, W1
003656  209C20     MOV #0x9C2, W0
003658  408000     ADD W1, W0, W0
00365A  780090     MOV [W0], W1
00365C  980711     MOV W1, [W14+2]
776:                   if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
00365E  90001E     MOV [W14+2], W0
003660  E00000     CP0 W0
003662  3A0006     BRA NZ, 0x3670
777:                       OS_EXIT_CRITICAL();                          /* No                                             */
003664  78009E     MOV [W14], W1
003666  880211     MOV W1, SR
778:                       *perr = OS_ERR_TASK_NOT_EXIST;
003668  90004E     MOV [W14+8], W0
00366A  B3C431     MOV.B #0x43, W1
00366C  784801     MOV.B W1, [W0]
779:                       return;
00366E  370011     BRA 0x3692
780:                   }
781:                   if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
003670  90001E     MOV [W14+2], W0
003672  500FE1     SUB W0, #0x1, [W15]
003674  3A0006     BRA NZ, 0x3682
782:                       OS_EXIT_CRITICAL();                          /* Yes                                            */
003676  78009E     MOV [W14], W1
003678  880211     MOV W1, SR
783:                       *perr = OS_ERR_TASK_NOT_EXIST;
00367A  90004E     MOV [W14+8], W0
00367C  B3C431     MOV.B #0x43, W1
00367E  784801     MOV.B W1, [W0]
784:                       return;
003680  370008     BRA 0x3692
785:                   }
786:                   ptcb->OSTCBTaskName = pname;
003682  90001E     MOV [W14+2], W0
003684  9000BE     MOV [W14+6], W1
003686  981851     MOV W1, [W0+58]
787:                   OS_EXIT_CRITICAL();
003688  78009E     MOV [W14], W1
00368A  880211     MOV W1, SR
788:                   *perr               = OS_ERR_NONE;
00368C  90004E     MOV [W14+8], W0
00368E  EB4080     CLR.B W1
003690  784801     MOV.B W1, [W0]
789:               }
003692  FA8000     ULNK
003694  060000     RETURN
790:               #endif
791:               
792:               /*$PAGE*/
793:               /*
794:               *********************************************************************************************************
795:               *                                       RESUME A SUSPENDED TASK
796:               *
797:               * Description: This function is called to resume a previously suspended task.  This is the only call that
798:               *              will remove an explicit task suspension.
799:               *
800:               * Arguments  : prio     is the priority of the task to resume.
801:               *
802:               * Returns    : OS_ERR_NONE                if the requested task is resumed
803:               *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
804:               *                                         (i.e. >= OS_LOWEST_PRIO)
805:               *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
806:               *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
807:               *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
808:               *********************************************************************************************************
809:               */
810:               
811:               #if OS_TASK_SUSPEND_EN > 0u
812:               INT8U  OSTaskResume (INT8U prio)
813:               {
003696  FA0006     LNK #0x6
003698  984740     MOV.B W0, [W14+4]
814:                   OS_TCB    *ptcb;
815:               #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
816:                   OS_CPU_SR  cpu_sr = 0u;
00369A  EB0000     CLR W0
00369C  780F00     MOV W0, [W14]
817:               #endif
818:               
819:               
820:               
821:               #if OS_ARG_CHK_EN > 0u
822:                   if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
00369E  90404E     MOV.B [W14+4], W0
0036A0  504FEB     SUB.B W0, #0xB, [W15]
0036A2  360002     BRA LEU, 0x36A8
823:                       return (OS_ERR_PRIO_INVALID);
0036A4  B3C2A0     MOV.B #0x2A, W0
0036A6  370057     BRA 0x3756
824:                   }
825:               #endif
826:                   OS_ENTER_CRITICAL();
0036A8  800211     MOV SR, W1
0036AA  780F01     MOV W1, [W14]
0036AC  800211     MOV SR, W1
0036AE  200E00     MOV #0xE0, W0
0036B0  700001     IOR W0, W1, W0
0036B2  880210     MOV W0, SR
827:                   ptcb = OSTCBPrioTbl[prio];
0036B4  90404E     MOV.B [W14+4], W0
0036B6  FB8000     ZE W0, W0
0036B8  400080     ADD W0, W0, W1
0036BA  209C20     MOV #0x9C2, W0
0036BC  408000     ADD W1, W0, W0
0036BE  780090     MOV [W0], W1
0036C0  980711     MOV W1, [W14+2]
828:                   if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
0036C2  90001E     MOV [W14+2], W0
0036C4  E00000     CP0 W0
0036C6  3A0004     BRA NZ, 0x36D0
829:                       OS_EXIT_CRITICAL();
0036C8  78009E     MOV [W14], W1
0036CA  880211     MOV W1, SR
830:                       return (OS_ERR_TASK_RESUME_PRIO);
0036CC  B3C460     MOV.B #0x46, W0
0036CE  370043     BRA 0x3756
831:                   }
832:                   if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
0036D0  90001E     MOV [W14+2], W0
0036D2  500FE1     SUB W0, #0x1, [W15]
0036D4  3A0004     BRA NZ, 0x36DE
833:                       OS_EXIT_CRITICAL();
0036D6  78009E     MOV [W14], W1
0036D8  880211     MOV W1, SR
834:                       return (OS_ERR_TASK_NOT_EXIST);
0036DA  B3C430     MOV.B #0x43, W0
0036DC  37003C     BRA 0x3756
835:                   }
836:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
0036DE  90001E     MOV [W14+2], W0
0036E0  906000     MOV.B [W0+32], W0
0036E2  FB8000     ZE W0, W0
0036E4  600068     AND W0, #0x8, W0
0036E6  E00000     CP0 W0
0036E8  320033     BRA Z, 0x3750
837:                       ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
0036EA  90001E     MOV [W14+2], W0
0036EC  906000     MOV.B [W0+32], W0
0036EE  784080     MOV.B W0, W1
0036F0  A13401     BCLR.B W1, #3
0036F2  90001E     MOV [W14+2], W0
0036F4  986001     MOV.B W1, [W0+32]
838:                       if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) == OS_STAT_RDY) { /* See if task is now ready         */
0036F6  90001E     MOV [W14+2], W0
0036F8  906000     MOV.B [W0+32], W0
0036FA  FB8080     ZE W0, W1
0036FC  200370     MOV #0x37, W0
0036FE  608000     AND W1, W0, W0
003700  E00000     CP0 W0
003702  3A0022     BRA NZ, 0x3748
839:                           if (ptcb->OSTCBDly == 0u) {
003704  90001E     MOV [W14+2], W0
003706  9008F0     MOV [W0+30], W1
003708  900860     MOV [W0+28], W0
00370A  500FE0     SUB W0, #0x0, [W15]
00370C  588FE0     SUBB W1, #0x0, [W15]
00370E  3A0019     BRA NZ, 0x3742
840:                               OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
003710  90001E     MOV [W14+2], W0
003712  9060E0     MOV.B [W0+38], W1
003714  BFC86F     MOV.B OSRdyGrp, WREG
003716  70C000     IOR.B W1, W0, W0
003718  B7E86F     MOV.B WREG, OSRdyGrp
841:                               OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00371A  90001E     MOV [W14+2], W0
00371C  906040     MOV.B [W0+36], W0
00371E  FB8000     ZE W0, W0
003720  90009E     MOV [W14+2], W1
003722  9060C1     MOV.B [W1+36], W1
003724  FB8081     ZE W1, W1
003726  209402     MOV #0x940, W2
003728  78C162     MOV.B [W2+W1], W2
00372A  90009E     MOV [W14+2], W1
00372C  9060D1     MOV.B [W1+37], W1
00372E  714101     IOR.B W2, W1, W2
003730  209401     MOV #0x940, W1
003732  787082     MOV.B W2, [W1+W0]
842:                               OS_EXIT_CRITICAL();
003734  78009E     MOV [W14], W1
003736  880211     MOV W1, SR
843:                               if (OSRunning == OS_TRUE) {
003738  BFC870     MOV.B OSRunning, WREG
00373A  504FE1     SUB.B W0, #0x1, [W15]
00373C  3A0007     BRA NZ, 0x374C
844:                                   OS_Sched();                               /* Find new highest priority task        */
00373E  07EDF8     RCALL OS_Sched
003740  370005     BRA 0x374C
845:                               }
846:                           } else {
847:                               OS_EXIT_CRITICAL();
003742  78009E     MOV [W14], W1
003744  880211     MOV W1, SR
003746  370002     BRA 0x374C
848:                           }
849:                       } else {                                              /* Must be pending on event              */
850:                           OS_EXIT_CRITICAL();
003748  78009E     MOV [W14], W1
00374A  880211     MOV W1, SR
851:                       }
852:                       return (OS_ERR_NONE);
00374C  EB4000     CLR.B W0
00374E  370003     BRA 0x3756
853:                   }
854:                   OS_EXIT_CRITICAL();
003750  78009E     MOV [W14], W1
003752  880211     MOV W1, SR
855:                   return (OS_ERR_TASK_NOT_SUSPENDED);
003754  B3C440     MOV.B #0x44, W0
856:               }
003756  FA8000     ULNK
003758  060000     RETURN
857:               #endif
858:               /*$PAGE*/
859:               /*
860:               *********************************************************************************************************
861:               *                                           STACK CHECKING
862:               *
863:               * Description: This function is called to check the amount of free memory left on the specified task's
864:               *              stack.
865:               *
866:               * Arguments  : prio          is the task priority
867:               *
868:               *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
869:               *
870:               * Returns    : OS_ERR_NONE            upon success
871:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
872:               *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
873:               *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
874:               *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
875:               *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
876:               *********************************************************************************************************
877:               */
878:               #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
879:               INT8U  OSTaskStkChk (INT8U         prio,
880:                                    OS_STK_DATA  *p_stk_data)
881:               {
00375A  FA0012     LNK #0x12
00375C  984F60     MOV.B W0, [W14+14]
00375E  980F01     MOV W1, [W14+16]
882:                   OS_TCB    *ptcb;
883:                   OS_STK    *pchk;
884:                   INT32U     nfree;
885:                   INT32U     size;
886:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
887:                   OS_CPU_SR  cpu_sr = 0u;
003760  EB0000     CLR W0
003762  980730     MOV W0, [W14+6]
888:               #endif
889:               
890:               
891:               
892:               #if OS_ARG_CHK_EN > 0u
893:                   if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
003764  90486E     MOV.B [W14+14], W0
003766  504FEC     SUB.B W0, #0xC, [W15]
003768  360005     BRA LEU, 0x3774
894:                       if (prio != OS_PRIO_SELF) {
00376A  90486E     MOV.B [W14+14], W0
00376C  404FE1     ADD.B W0, #0x1, [W15]
00376E  320002     BRA Z, 0x3774
895:                           return (OS_ERR_PRIO_INVALID);
003770  B3C2A0     MOV.B #0x2A, W0
003772  370062     BRA 0x3838
896:                       }
897:                   }
898:                   if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
003774  90080E     MOV [W14+16], W0
003776  E00000     CP0 W0
003778  3A0002     BRA NZ, 0x377E
899:                       return (OS_ERR_PDATA_NULL);
00377A  B3C090     MOV.B #0x9, W0
00377C  37005D     BRA 0x3838
900:                   }
901:               #endif
902:                   p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00377E  90090E     MOV [W14+16], W2
003780  B80060     MUL.UU W0, #0, W0
003782  BE8900     MOV.D W0, [W2]
903:                   p_stk_data->OSUsed = 0u;
003784  90090E     MOV [W14+16], W2
003786  B80060     MUL.UU W0, #0, W0
003788  980120     MOV W0, [W2+4]
00378A  980131     MOV W1, [W2+6]
904:                   OS_ENTER_CRITICAL();
00378C  800211     MOV SR, W1
00378E  980731     MOV W1, [W14+6]
003790  800211     MOV SR, W1
003792  200E00     MOV #0xE0, W0
003794  700001     IOR W0, W1, W0
003796  880210     MOV W0, SR
905:                   if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
003798  90486E     MOV.B [W14+14], W0
00379A  404FE1     ADD.B W0, #0x1, [W15]
00379C  3A0003     BRA NZ, 0x37A4
906:                       prio = OSTCBCur->OSTCBPrio;
00379E  8043B0     MOV OSTCBCur, W0
0037A0  906120     MOV.B [W0+34], W2
0037A2  984F62     MOV.B W2, [W14+14]
907:                   }
908:                   ptcb = OSTCBPrioTbl[prio];
0037A4  90486E     MOV.B [W14+14], W0
0037A6  FB8000     ZE W0, W0
0037A8  400080     ADD W0, W0, W1
0037AA  209C20     MOV #0x9C2, W0
0037AC  408000     ADD W1, W0, W0
0037AE  780190     MOV [W0], W3
0037B0  980743     MOV W3, [W14+8]
909:                   if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
0037B2  90004E     MOV [W14+8], W0
0037B4  E00000     CP0 W0
0037B6  3A0004     BRA NZ, 0x37C0
910:                       OS_EXIT_CRITICAL();
0037B8  9000BE     MOV [W14+6], W1
0037BA  880211     MOV W1, SR
911:                       return (OS_ERR_TASK_NOT_EXIST);
0037BC  B3C430     MOV.B #0x43, W0
0037BE  37003C     BRA 0x3838
912:                   }
913:                   if (ptcb == OS_TCB_RESERVED) {
0037C0  90004E     MOV [W14+8], W0
0037C2  500FE1     SUB W0, #0x1, [W15]
0037C4  3A0004     BRA NZ, 0x37CE
914:                       OS_EXIT_CRITICAL();
0037C6  90013E     MOV [W14+6], W2
0037C8  880212     MOV W2, SR
915:                       return (OS_ERR_TASK_NOT_EXIST);
0037CA  B3C430     MOV.B #0x43, W0
0037CC  370035     BRA 0x3838
916:                   }
917:                   if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
0037CE  90004E     MOV [W14+8], W0
0037D0  900050     MOV [W0+10], W0
0037D2  600061     AND W0, #0x1, W0
0037D4  E00000     CP0 W0
0037D6  3A0004     BRA NZ, 0x37E0
918:                       OS_EXIT_CRITICAL();
0037D8  9001BE     MOV [W14+6], W3
0037DA  880213     MOV W3, SR
919:                       return (OS_ERR_TASK_OPT);
0037DC  B3C450     MOV.B #0x45, W0
0037DE  37002C     BRA 0x3838
920:                   }
921:                   nfree = 0u;
0037E0  B80060     MUL.UU W0, #0, W0
0037E2  980710     MOV W0, [W14+2]
0037E4  980721     MOV W1, [W14+4]
922:                   size  = ptcb->OSTCBStkSize;
0037E6  90004E     MOV [W14+8], W0
0037E8  900130     MOV [W0+6], W2
0037EA  9001C0     MOV [W0+8], W3
0037EC  980752     MOV W2, [W14+10]
0037EE  980763     MOV W3, [W14+12]
923:                   pchk  = ptcb->OSTCBStkBottom;
0037F0  90004E     MOV [W14+8], W0
0037F2  9001A0     MOV [W0+4], W3
0037F4  780F03     MOV W3, [W14]
924:                   OS_EXIT_CRITICAL();
0037F6  9000BE     MOV [W14+6], W1
0037F8  880211     MOV W1, SR
925:               #if OS_STK_GROWTH == 1u
926:                   while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
927:                       nfree++;
928:                   }
929:               #else
930:                   while (*pchk-- == (OS_STK)0) {
0037FA  370006     BRA 0x3808
003808  78001E     MOV [W14], W0
00380A  780010     MOV [W0], W0
00380C  A7F000     BTSC W0, #15
00380E  EA0000     NEG W0, W0
003810  E90000     DEC W0, W0
003812  DE004F     LSR W0, #15, W0
003814  784000     MOV.B W0, W0
003816  E98F1E     DEC2 [W14], [W14]
003818  E00400     CP0.B W0
00381A  3AFFF0     BRA NZ, 0x37FC
931:                       nfree++;
0037FC  90001E     MOV [W14+2], W0
0037FE  9000AE     MOV [W14+4], W1
003800  400061     ADD W0, #0x1, W0
003802  4880E0     ADDC W1, #0x0, W1
003804  980710     MOV W0, [W14+2]
003806  980721     MOV W1, [W14+4]
932:                   }
933:               #endif
934:                   p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00381C  90080E     MOV [W14+16], W0
00381E  90011E     MOV [W14+2], W2
003820  9001AE     MOV [W14+4], W3
003822  BE8802     MOV.D W2, [W0]
935:                   p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
003824  90015E     MOV [W14+10], W2
003826  9001EE     MOV [W14+12], W3
003828  90001E     MOV [W14+2], W0
00382A  9000AE     MOV [W14+4], W1
00382C  510000     SUB W2, W0, W0
00382E  598081     SUBB W3, W1, W1
003830  90090E     MOV [W14+16], W2
003832  980120     MOV W0, [W2+4]
003834  980131     MOV W1, [W2+6]
936:                   return (OS_ERR_NONE);
003836  EB4000     CLR.B W0
937:               }
003838  FA8000     ULNK
00383A  060000     RETURN
938:               #endif
939:               /*$PAGE*/
940:               /*
941:               *********************************************************************************************************
942:               *                                           SUSPEND A TASK
943:               *
944:               * Description: This function is called to suspend a task.  The task can be the calling task if the
945:               *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
946:               *
947:               * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
948:               *                       calling task will suspend itself and rescheduling will occur.
949:               *
950:               * Returns    : OS_ERR_NONE               if the requested task is suspended
951:               *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
952:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
953:               *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
954:               *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
955:               *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
956:               *
957:               * Note       : You should use this function with great care.  If you suspend a task that is waiting for
958:               *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
959:               *              running when the event arrives.
960:               *********************************************************************************************************
961:               */
962:               
963:               #if OS_TASK_SUSPEND_EN > 0u
964:               INT8U  OSTaskSuspend (INT8U prio)
965:               {
00383C  FA000A     LNK #0xA
00383E  984F00     MOV.B W0, [W14+8]
966:                   BOOLEAN    self;
967:                   OS_TCB    *ptcb;
968:                   INT8U      y;
969:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
970:                   OS_CPU_SR  cpu_sr = 0u;
003840  EB0000     CLR W0
003842  980710     MOV W0, [W14+2]
971:               #endif
972:               
973:               
974:               
975:               #if OS_ARG_CHK_EN > 0u
976:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
003844  90480E     MOV.B [W14+8], W0
003846  504FEC     SUB.B W0, #0xC, [W15]
003848  3A0002     BRA NZ, 0x384E
977:                       return (OS_ERR_TASK_SUSPEND_IDLE);
00384A  B3C470     MOV.B #0x47, W0
00384C  37005E     BRA 0x390A
978:                   }
979:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
00384E  90480E     MOV.B [W14+8], W0
003850  504FEB     SUB.B W0, #0xB, [W15]
003852  360005     BRA LEU, 0x385E
980:                       if (prio != OS_PRIO_SELF) {
003854  90480E     MOV.B [W14+8], W0
003856  404FE1     ADD.B W0, #0x1, [W15]
003858  320002     BRA Z, 0x385E
981:                           return (OS_ERR_PRIO_INVALID);
00385A  B3C2A0     MOV.B #0x2A, W0
00385C  370056     BRA 0x390A
982:                       }
983:                   }
984:               #endif
985:                   OS_ENTER_CRITICAL();
00385E  800211     MOV SR, W1
003860  980711     MOV W1, [W14+2]
003862  800211     MOV SR, W1
003864  200E00     MOV #0xE0, W0
003866  700001     IOR W0, W1, W0
003868  880210     MOV W0, SR
986:                   if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00386A  90480E     MOV.B [W14+8], W0
00386C  404FE1     ADD.B W0, #0x1, [W15]
00386E  3A0006     BRA NZ, 0x387C
987:                       prio = OSTCBCur->OSTCBPrio;
003870  8043B0     MOV OSTCBCur, W0
003872  9060A0     MOV.B [W0+34], W1
003874  984F01     MOV.B W1, [W14+8]
988:                       self = OS_TRUE;
003876  B3C010     MOV.B #0x1, W0
003878  784F00     MOV.B W0, [W14]
00387A  37000A     BRA 0x3890
989:                   } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00387C  8043B0     MOV OSTCBCur, W0
00387E  9060A0     MOV.B [W0+34], W1
003880  90480E     MOV.B [W14+8], W0
003882  50CF80     SUB.B W1, W0, [W15]
003884  3A0003     BRA NZ, 0x388C
990:                       self = OS_TRUE;
003886  B3C010     MOV.B #0x1, W0
003888  784F00     MOV.B W0, [W14]
00388A  370002     BRA 0x3890
991:                   } else {
992:                       self = OS_FALSE;                                        /* No suspending another task          */
00388C  EB4000     CLR.B W0
00388E  784F00     MOV.B W0, [W14]
993:                   }
994:                   ptcb = OSTCBPrioTbl[prio];
003890  90480E     MOV.B [W14+8], W0
003892  FB8000     ZE W0, W0
003894  400080     ADD W0, W0, W1
003896  209C20     MOV #0x9C2, W0
003898  408000     ADD W1, W0, W0
00389A  780090     MOV [W0], W1
00389C  980721     MOV W1, [W14+4]
995:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
00389E  90002E     MOV [W14+4], W0
0038A0  E00000     CP0 W0
0038A2  3A0004     BRA NZ, 0x38AC
996:                       OS_EXIT_CRITICAL();
0038A4  90009E     MOV [W14+2], W1
0038A6  880211     MOV W1, SR
997:                       return (OS_ERR_TASK_SUSPEND_PRIO);
0038A8  B3C480     MOV.B #0x48, W0
0038AA  37002F     BRA 0x390A
998:                   }
999:                   if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
0038AC  90002E     MOV [W14+4], W0
0038AE  500FE1     SUB W0, #0x1, [W15]
0038B0  3A0004     BRA NZ, 0x38BA
1000:                      OS_EXIT_CRITICAL();
0038B2  90009E     MOV [W14+2], W1
0038B4  880211     MOV W1, SR
1001:                      return (OS_ERR_TASK_NOT_EXIST);
0038B6  B3C430     MOV.B #0x43, W0
0038B8  370028     BRA 0x390A
1002:                  }
1003:                  y            = ptcb->OSTCBY;
0038BA  90002E     MOV [W14+4], W0
0038BC  9060C0     MOV.B [W0+36], W1
0038BE  984761     MOV.B W1, [W14+6]
1004:                  OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
0038C0  90406E     MOV.B [W14+6], W0
0038C2  FB8000     ZE W0, W0
0038C4  9040EE     MOV.B [W14+6], W1
0038C6  FB8081     ZE W1, W1
0038C8  209402     MOV #0x940, W2
0038CA  78C162     MOV.B [W2+W1], W2
0038CC  9000AE     MOV [W14+4], W1
0038CE  9060D1     MOV.B [W1+37], W1
0038D0  EAC081     COM.B W1, W1
0038D2  614101     AND.B W2, W1, W2
0038D4  209401     MOV #0x940, W1
0038D6  787082     MOV.B W2, [W1+W0]
1005:                  if (OSRdyTbl[y] == 0u) {
0038D8  90406E     MOV.B [W14+6], W0
0038DA  FB8000     ZE W0, W0
0038DC  209401     MOV #0x940, W1
0038DE  784061     MOV.B [W1+W0], W0
0038E0  E00400     CP0.B W0
0038E2  3A0006     BRA NZ, 0x38F0
1006:                      OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0038E4  90002E     MOV [W14+4], W0
0038E6  906060     MOV.B [W0+38], W0
0038E8  EAC080     COM.B W0, W1
0038EA  BFC86F     MOV.B OSRdyGrp, WREG
0038EC  60C000     AND.B W1, W0, W0
0038EE  B7E86F     MOV.B WREG, OSRdyGrp
1007:                  }
1008:                  ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
0038F0  90002E     MOV [W14+4], W0
0038F2  906000     MOV.B [W0+32], W0
0038F4  784080     MOV.B W0, W1
0038F6  A03401     BSET.B W1, #3
0038F8  90002E     MOV [W14+4], W0
0038FA  986001     MOV.B W1, [W0+32]
1009:                  OS_EXIT_CRITICAL();
0038FC  90009E     MOV [W14+2], W1
0038FE  880211     MOV W1, SR
1010:                  if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
003900  78401E     MOV.B [W14], W0
003902  504FE1     SUB.B W0, #0x1, [W15]
003904  3A0001     BRA NZ, 0x3908
1011:                      OS_Sched();                                             /* Find new highest priority task      */
003906  07ED14     RCALL OS_Sched
1012:                  }
1013:                  return (OS_ERR_NONE);
003908  EB4000     CLR.B W0
1014:              }
00390A  FA8000     ULNK
00390C  060000     RETURN
1015:              #endif
1016:              /*$PAGE*/
1017:              /*
1018:              *********************************************************************************************************
1019:              *                                            QUERY A TASK
1020:              *
1021:              * Description: This function is called to obtain a copy of the desired task's TCB.
1022:              *
1023:              * Arguments  : prio         is the priority of the task to obtain information from.
1024:              *
1025:              *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
1026:              *
1027:              * Returns    : OS_ERR_NONE            if the requested task is suspended
1028:              *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
1029:              *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
1030:              *              OS_ERR_PRIO            if the desired task has not been created
1031:              *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
1032:              *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
1033:              *********************************************************************************************************
1034:              */
1035:              
1036:              #if OS_TASK_QUERY_EN > 0u
1037:              INT8U  OSTaskQuery (INT8U    prio,
1038:                                  OS_TCB  *p_task_data)
1039:              {
00390E  FA0008     LNK #0x8
003910  984740     MOV.B W0, [W14+4]
003912  980731     MOV W1, [W14+6]
1040:                  OS_TCB    *ptcb;
1041:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1042:                  OS_CPU_SR  cpu_sr = 0u;
003914  EB0000     CLR W0
003916  780F00     MOV W0, [W14]
1043:              #endif
1044:              
1045:              
1046:              
1047:              #if OS_ARG_CHK_EN > 0u
1048:                  if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
003918  90404E     MOV.B [W14+4], W0
00391A  504FEC     SUB.B W0, #0xC, [W15]
00391C  360005     BRA LEU, 0x3928
1049:                      if (prio != OS_PRIO_SELF) {
00391E  90404E     MOV.B [W14+4], W0
003920  404FE1     ADD.B W0, #0x1, [W15]
003922  320002     BRA Z, 0x3928
1050:                          return (OS_ERR_PRIO_INVALID);
003924  B3C2A0     MOV.B #0x2A, W0
003926  37002D     BRA 0x3982
1051:                      }
1052:                  }
1053:                  if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
003928  90003E     MOV [W14+6], W0
00392A  E00000     CP0 W0
00392C  3A0002     BRA NZ, 0x3932
1054:                      return (OS_ERR_PDATA_NULL);
00392E  B3C090     MOV.B #0x9, W0
003930  370028     BRA 0x3982
1055:                  }
1056:              #endif
1057:                  OS_ENTER_CRITICAL();
003932  800211     MOV SR, W1
003934  780F01     MOV W1, [W14]
003936  800211     MOV SR, W1
003938  200E00     MOV #0xE0, W0
00393A  700001     IOR W0, W1, W0
00393C  880210     MOV W0, SR
1058:                  if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00393E  90404E     MOV.B [W14+4], W0
003940  404FE1     ADD.B W0, #0x1, [W15]
003942  3A0003     BRA NZ, 0x394A
1059:                      prio = OSTCBCur->OSTCBPrio;
003944  8043B0     MOV OSTCBCur, W0
003946  9060A0     MOV.B [W0+34], W1
003948  984741     MOV.B W1, [W14+4]
1060:                  }
1061:                  ptcb = OSTCBPrioTbl[prio];
00394A  90404E     MOV.B [W14+4], W0
00394C  FB8000     ZE W0, W0
00394E  400080     ADD W0, W0, W1
003950  209C20     MOV #0x9C2, W0
003952  408000     ADD W1, W0, W0
003954  780090     MOV [W0], W1
003956  980711     MOV W1, [W14+2]
1062:                  if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
003958  90001E     MOV [W14+2], W0
00395A  E00000     CP0 W0
00395C  3A0004     BRA NZ, 0x3966
1063:                      OS_EXIT_CRITICAL();
00395E  78009E     MOV [W14], W1
003960  880211     MOV W1, SR
1064:                      return (OS_ERR_PRIO);
003962  B3C290     MOV.B #0x29, W0
003964  37000E     BRA 0x3982
1065:                  }
1066:                  if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
003966  90001E     MOV [W14+2], W0
003968  500FE1     SUB W0, #0x1, [W15]
00396A  3A0004     BRA NZ, 0x3974
1067:                      OS_EXIT_CRITICAL();
00396C  78009E     MOV [W14], W1
00396E  880211     MOV W1, SR
1068:                      return (OS_ERR_TASK_NOT_EXIST);
003970  B3C430     MOV.B #0x43, W0
003972  370007     BRA 0x3982
1069:                  }
1070:                                                               /* Copy TCB into user storage area                    */
1071:                  OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
003974  90009E     MOV [W14+2], W1
003976  90003E     MOV [W14+6], W0
003978  200402     MOV #0x40, W2
00397A  07ECC5     RCALL OS_MemCopy
1072:                  OS_EXIT_CRITICAL();
00397C  78009E     MOV [W14], W1
00397E  880211     MOV W1, SR
1073:                  return (OS_ERR_NONE);
003980  EB4000     CLR.B W0
1074:              }
003982  FA8000     ULNK
003984  060000     RETURN
1075:              #endif
1076:              /*$PAGE*/
1077:              /*
1078:              *********************************************************************************************************
1079:              *                              GET THE CURRENT VALUE OF A TASK REGISTER
1080:              *
1081:              * Description: This function is called to obtain the current value of a task register.  Task registers
1082:              *              are application specific and can be used to store task specific values such as 'error
1083:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1084:              *
1085:              * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
1086:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1087:              *
1088:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1089:              *                        than OS_TASK_REG_TBL_SIZE
1090:              *
1091:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1092:              *
1093:              *                        OS_ERR_NONE            if the call was successful
1094:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1095:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1096:              *
1097:              * Returns    : The current value of the task's register or 0 if an error is detected.
1098:              *
1099:              * Note(s)    : The maximum number of task variables is 254
1100:              *********************************************************************************************************
1101:              */
1102:              
1103:              #if OS_TASK_REG_TBL_SIZE > 0u
1104:              INT32U  OSTaskRegGet (INT8U   prio,
1105:                                    INT8U   id,
1106:                                    INT8U  *perr)
1107:              {
003986  FA000C     LNK #0xC
003988  984F00     MOV.B W0, [W14+8]
00398A  984F11     MOV.B W1, [W14+9]
00398C  980752     MOV W2, [W14+10]
1108:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1109:                  OS_CPU_SR  cpu_sr = 0u;
00398E  EB0000     CLR W0
003990  980710     MOV W0, [W14+2]
1110:              #endif
1111:                  INT32U     value;
1112:                  OS_TCB    *ptcb;
1113:              
1114:              
1115:              
1116:              #ifdef OS_SAFETY_CRITICAL
1117:                  if (perr == (INT8U *)0) {
1118:                      OS_SAFETY_CRITICAL_EXCEPTION();
1119:                      return (0u);
1120:                  }
1121:              #endif
1122:              
1123:              #if OS_ARG_CHK_EN > 0u
1124:                  if (prio >= OS_LOWEST_PRIO) {
003992  90480E     MOV.B [W14+8], W0
003994  504FEB     SUB.B W0, #0xB, [W15]
003996  360008     BRA LEU, 0x39A8
1125:                      if (prio != OS_PRIO_SELF) {
003998  90480E     MOV.B [W14+8], W0
00399A  404FE1     ADD.B W0, #0x1, [W15]
00399C  320005     BRA Z, 0x39A8
1126:                          *perr = OS_ERR_PRIO_INVALID;
00399E  90005E     MOV [W14+10], W0
0039A0  B3C2A1     MOV.B #0x2A, W1
0039A2  784801     MOV.B W1, [W0]
1127:                          return (0u);
0039A4  B80060     MUL.UU W0, #0, W0
0039A6  37002A     BRA 0x39FC
1128:                      }
1129:                  }
1130:                  if (id >= OS_TASK_REG_TBL_SIZE) {
0039A8  90481E     MOV.B [W14+9], W0
0039AA  E00400     CP0.B W0
0039AC  320005     BRA Z, 0x39B8
1131:                      *perr = OS_ERR_ID_INVALID;
0039AE  90005E     MOV [W14+10], W0
0039B0  B3C081     MOV.B #0x8, W1
0039B2  784801     MOV.B W1, [W0]
1132:                      return (0u);
0039B4  B80060     MUL.UU W0, #0, W0
0039B6  370022     BRA 0x39FC
1133:                  }
1134:              #endif
1135:                  OS_ENTER_CRITICAL();
0039B8  800211     MOV SR, W1
0039BA  980711     MOV W1, [W14+2]
0039BC  800211     MOV SR, W1
0039BE  200E00     MOV #0xE0, W0
0039C0  700001     IOR W0, W1, W0
0039C2  880210     MOV W0, SR
1136:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
0039C4  90480E     MOV.B [W14+8], W0
0039C6  404FE1     ADD.B W0, #0x1, [W15]
0039C8  3A0003     BRA NZ, 0x39D0
1137:                      ptcb = OSTCBCur;
0039CA  8043B2     MOV OSTCBCur, W2
0039CC  780F02     MOV W2, [W14]
0039CE  370006     BRA 0x39DC
1138:                  } else {
1139:                      ptcb = OSTCBPrioTbl[prio];
0039D0  90480E     MOV.B [W14+8], W0
0039D2  FB8000     ZE W0, W0
0039D4  400080     ADD W0, W0, W1
0039D6  209C20     MOV #0x9C2, W0
0039D8  408000     ADD W1, W0, W0
0039DA  780F10     MOV [W0], [W14]
1140:                  }
1141:                  value = ptcb->OSTCBRegTbl[id];
0039DC  90481E     MOV.B [W14+9], W0
0039DE  FB8000     ZE W0, W0
0039E0  78009E     MOV [W14], W1
0039E2  40006F     ADD W0, #0xF, W0
0039E4  DD0042     SL W0, #2, W0
0039E6  408000     ADD W1, W0, W0
0039E8  BE0110     MOV.D [W0], W2
0039EA  980722     MOV W2, [W14+4]
0039EC  980733     MOV W3, [W14+6]
1142:                  OS_EXIT_CRITICAL();
0039EE  90019E     MOV [W14+2], W3
0039F0  880213     MOV W3, SR
1143:                  *perr = OS_ERR_NONE;
0039F2  90005E     MOV [W14+10], W0
0039F4  EB4080     CLR.B W1
0039F6  784801     MOV.B W1, [W0]
1144:                  return (value);
0039F8  90002E     MOV [W14+4], W0
0039FA  9000BE     MOV [W14+6], W1
1145:              }
0039FC  FA8000     ULNK
0039FE  060000     RETURN
1146:              #endif
1147:              
1148:              /*$PAGE*/
1149:              /*
1150:              ************************************************************************************************************************
1151:              *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
1152:              *
1153:              * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
1154:              *              allocated dynamically instead of statically.
1155:              *
1156:              * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
1157:              *
1158:              *                            OS_ERR_NONE               if the call was successful
1159:              *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
1160:              *                                                           have available through OS_TASK_REG_TBL_SIZE.
1161:              *
1162:              * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
1163:              ************************************************************************************************************************
1164:              */
1165:              
1166:              #if OS_TASK_REG_TBL_SIZE > 0u
1167:              INT8U  OSTaskRegGetID (INT8U  *perr)
1168:              {
003A00  FA0006     LNK #0x6
003A02  980720     MOV W0, [W14+4]
1169:              #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
1170:                  OS_CPU_SR  cpu_sr = 0u;
003A04  EB0000     CLR W0
003A06  780F00     MOV W0, [W14]
1171:              #endif
1172:                  INT8U      id;
1173:              
1174:              
1175:              #ifdef OS_SAFETY_CRITICAL
1176:                  if (perr == (INT8U *)0) {
1177:                      OS_SAFETY_CRITICAL_EXCEPTION();
1178:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
1179:                  }
1180:              #endif
1181:              
1182:                  OS_ENTER_CRITICAL();
003A08  800211     MOV SR, W1
003A0A  780F01     MOV W1, [W14]
003A0C  800211     MOV SR, W1
003A0E  200E00     MOV #0xE0, W0
003A10  700001     IOR W0, W1, W0
003A12  880210     MOV W0, SR
1183:                  if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
003A14  BFC882     MOV.B OSTaskRegNextAvailID, WREG
003A16  E00400     CP0.B W0
003A18  320007     BRA Z, 0x3A28
1184:                     *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
003A1A  90002E     MOV [W14+4], W0
003A1C  B3C961     MOV.B #0x96, W1
003A1E  784801     MOV.B W1, [W0]
1185:                      OS_EXIT_CRITICAL();
003A20  78009E     MOV [W14], W1
003A22  880211     MOV W1, SR
1186:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
003A24  B3C010     MOV.B #0x1, W0
003A26  37000C     BRA 0x3A40
1187:                  }
1188:                   
1189:                  id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
003A28  208821     MOV #0x882, W1
003A2A  784091     MOV.B [W1], W1
003A2C  984721     MOV.B W1, [W14+2]
1190:                  OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
003A2E  BFC882     MOV.B OSTaskRegNextAvailID, WREG
003A30  E84000     INC.B W0, W0
003A32  B7E882     MOV.B WREG, OSTaskRegNextAvailID
1191:                  OS_EXIT_CRITICAL();
003A34  78009E     MOV [W14], W1
003A36  880211     MOV W1, SR
1192:                 *perr = OS_ERR_NONE;
003A38  90002E     MOV [W14+4], W0
003A3A  EB4080     CLR.B W1
003A3C  784801     MOV.B W1, [W0]
1193:                  return (id);
003A3E  90402E     MOV.B [W14+2], W0
1194:              }
003A40  FA8000     ULNK
003A42  060000     RETURN
1195:              #endif
1196:              
1197:              /*$PAGE*/
1198:              /*
1199:              *********************************************************************************************************
1200:              *                              SET THE CURRENT VALUE OF A TASK VARIABLE
1201:              *
1202:              * Description: This function is called to change the current value of a task register.  Task registers
1203:              *              are application specific and can be used to store task specific values such as 'error
1204:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1205:              *
1206:              * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
1207:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1208:              *
1209:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1210:              *                        than OS_TASK_REG_TBL_SIZE
1211:              *
1212:              *              value     is the desired value for the task register.
1213:              *
1214:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1215:              *
1216:              *                        OS_ERR_NONE            if the call was successful
1217:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1218:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1219:              *
1220:              * Returns    : The current value of the task's variable or 0 if an error is detected.
1221:              *
1222:              * Note(s)    : The maximum number of task variables is 254
1223:              *********************************************************************************************************
1224:              */
1225:              
1226:              #if OS_TASK_REG_TBL_SIZE > 0u
1227:              void  OSTaskRegSet (INT8U    prio,
1228:                                  INT8U    id,
1229:                                  INT32U   value,
1230:                                  INT8U   *perr)
1231:              {
003A44  FA000C     LNK #0xC
003A46  984740     MOV.B W0, [W14+4]
003A48  984751     MOV.B W1, [W14+5]
003A4A  980732     MOV W2, [W14+6]
003A4C  980743     MOV W3, [W14+8]
003A4E  980754     MOV W4, [W14+10]
1232:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1233:                  OS_CPU_SR  cpu_sr = 0u;
003A50  EB0000     CLR W0
003A52  980710     MOV W0, [W14+2]
1234:              #endif
1235:                  OS_TCB    *ptcb;
1236:              
1237:              
1238:              #ifdef OS_SAFETY_CRITICAL
1239:                  if (perr == (INT8U *)0) {
1240:                      OS_SAFETY_CRITICAL_EXCEPTION();
1241:                      return;
1242:                  }
1243:              #endif
1244:              
1245:              #if OS_ARG_CHK_EN > 0u
1246:                  if (prio >= OS_LOWEST_PRIO) {
003A54  90404E     MOV.B [W14+4], W0
003A56  504FEB     SUB.B W0, #0xB, [W15]
003A58  360007     BRA LEU, 0x3A68
1247:                      if (prio != OS_PRIO_SELF) {
003A5A  90404E     MOV.B [W14+4], W0
003A5C  404FE1     ADD.B W0, #0x1, [W15]
003A5E  320004     BRA Z, 0x3A68
1248:                          *perr = OS_ERR_PRIO_INVALID;
003A60  90005E     MOV [W14+10], W0
003A62  B3C2A1     MOV.B #0x2A, W1
003A64  784801     MOV.B W1, [W0]
1249:                          return;
003A66  370027     BRA 0x3AB6
1250:                      }
1251:                  }
1252:                  if (id >= OS_TASK_REG_TBL_SIZE) {
003A68  90405E     MOV.B [W14+5], W0
003A6A  E00400     CP0.B W0
003A6C  320004     BRA Z, 0x3A76
1253:                      *perr = OS_ERR_ID_INVALID;
003A6E  90005E     MOV [W14+10], W0
003A70  B3C081     MOV.B #0x8, W1
003A72  784801     MOV.B W1, [W0]
1254:                      return;
003A74  370020     BRA 0x3AB6
1255:                  }
1256:              #endif
1257:                  OS_ENTER_CRITICAL();
003A76  800211     MOV SR, W1
003A78  980711     MOV W1, [W14+2]
003A7A  800211     MOV SR, W1
003A7C  200E00     MOV #0xE0, W0
003A7E  700001     IOR W0, W1, W0
003A80  880210     MOV W0, SR
1258:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
003A82  90404E     MOV.B [W14+4], W0
003A84  404FE1     ADD.B W0, #0x1, [W15]
003A86  3A0003     BRA NZ, 0x3A8E
1259:                      ptcb = OSTCBCur;
003A88  8043B2     MOV OSTCBCur, W2
003A8A  780F02     MOV W2, [W14]
003A8C  370006     BRA 0x3A9A
1260:                  } else {
1261:                      ptcb = OSTCBPrioTbl[prio];
003A8E  90404E     MOV.B [W14+4], W0
003A90  FB8000     ZE W0, W0
003A92  400080     ADD W0, W0, W1
003A94  209C20     MOV #0x9C2, W0
003A96  408000     ADD W1, W0, W0
003A98  780F10     MOV [W0], [W14]
1262:                  }
1263:                  ptcb->OSTCBRegTbl[id] = value;
003A9A  90405E     MOV.B [W14+5], W0
003A9C  FB8000     ZE W0, W0
003A9E  78009E     MOV [W14], W1
003AA0  40006F     ADD W0, #0xF, W0
003AA2  DD0042     SL W0, #2, W0
003AA4  408000     ADD W1, W0, W0
003AA6  90013E     MOV [W14+6], W2
003AA8  9001CE     MOV [W14+8], W3
003AAA  BE8802     MOV.D W2, [W0]
1264:                  OS_EXIT_CRITICAL();
003AAC  90019E     MOV [W14+2], W3
003AAE  880213     MOV W3, SR
1265:                  *perr                 = OS_ERR_NONE;
003AB0  90005E     MOV [W14+10], W0
003AB2  EB4080     CLR.B W1
003AB4  784801     MOV.B W1, [W0]
1266:              }
003AB6  FA8000     ULNK
003AB8  060000     RETURN
1267:              #endif
1268:              
1269:              /*$PAGE*/
1270:              /*
1271:              *********************************************************************************************************
1272:              *                                    CATCH ACCIDENTAL TASK RETURN
1273:              *
1274:              * Description: This function is called if a task accidentally returns without deleting itself.  In other
1275:              *              words, a task should either be an infinite loop or delete itself if it's done.
1276:              *
1277:              * Arguments  : none
1278:              *
1279:              * Returns    : none
1280:              *
1281:              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
1282:              *********************************************************************************************************
1283:              */
1284:              
1285:              void  OS_TaskReturn (void)
1286:              {
003ABA  FA0000     LNK #0x0
1287:                  OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
003ABC  8043B0     MOV OSTCBCur, W0
003ABE  0717FA     RCALL OSTaskReturnHook
1288:              
1289:              #if OS_TASK_DEL_EN > 0u
1290:                  (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
003AC0  EBC000     SETM.B W0
003AC2  07FC42     RCALL OSTaskDel
1291:              #else
1292:                  for (;;) {
1293:                      OSTimeDly(OS_TICKS_PER_SEC);
1294:                  }
1295:              #endif
1296:              }
003AC4  FA8000     ULNK
003AC6  060000     RETURN
1297:              
1298:              /*$PAGE*/
1299:              /*
1300:              *********************************************************************************************************
1301:              *                                          CLEAR TASK STACK
1302:              *
1303:              * Description: This function is used to clear the stack of a task (i.e. write all zeros)
1304:              *
1305:              * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
1306:              *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
1307:              *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
1308:              *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
1309:              *                       highest memory location of the stack and the stack will grow with increasing
1310:              *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
1311:              *
1312:              *              size     is the number of 'stack elements' to clear.
1313:              *
1314:              *              opt      contains additional information (or options) about the behavior of the task.  The
1315:              *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
1316:              *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
1317:              *
1318:              * Returns    : none
1319:              *********************************************************************************************************
1320:              */
1321:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1322:              void  OS_TaskStkClr (OS_STK  *pbos,
1323:                                   INT32U   size,
1324:                                   INT16U   opt)
1325:              {
003AC8  FA0008     LNK #0x8
003ACA  780F00     MOV W0, [W14]
003ACC  980712     MOV W2, [W14+2]
003ACE  980723     MOV W3, [W14+4]
003AD0  980731     MOV W1, [W14+6]
1326:                  if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
003AD2  90003E     MOV [W14+6], W0
003AD4  600061     AND W0, #0x1, W0
003AD6  784000     MOV.B W0, W0
003AD8  E00400     CP0.B W0
003ADA  320014     BRA Z, 0x3B04
1327:                      if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
003ADC  90003E     MOV [W14+6], W0
003ADE  600062     AND W0, #0x2, W0
003AE0  E00000     CP0 W0
003AE2  320010     BRA Z, 0x3B04
1328:              #if OS_STK_GROWTH == 1u
1329:                          while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
1330:                              size--;
1331:                              *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
1332:                          }
1333:              #else
1334:                          while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
003AE4  37000A     BRA 0x3AFA
003AFA  90001E     MOV [W14+2], W0
003AFC  9000AE     MOV [W14+4], W1
003AFE  500FE0     SUB W0, #0x0, [W15]
003B00  588FE0     SUBB W1, #0x0, [W15]
003B02  3AFFF1     BRA NZ, 0x3AE6
1335:                              size--;
003AE6  90001E     MOV [W14+2], W0
003AE8  9000AE     MOV [W14+4], W1
003AEA  500061     SUB W0, #0x1, W0
003AEC  5880E0     SUBB W1, #0x0, W1
003AEE  980710     MOV W0, [W14+2]
003AF0  980721     MOV W1, [W14+4]
1336:                              *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
003AF2  78001E     MOV [W14], W0
003AF4  EB0080     CLR W1
003AF6  780801     MOV W1, [W0]
003AF8  E98F1E     DEC2 [W14], [W14]
1337:                          }
1338:              #endif
1339:                      }
1340:                  }
1341:              }
003B04  FA8000     ULNK
1342:              
1343:              #endif
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_sem.c  -------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                          SEMAPHORE MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_SEM.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if OS_SEM_EN > 0u
31:                /*$PAGE*/
32:                /*
33:                *********************************************************************************************************
34:                *                                          ACCEPT SEMAPHORE
35:                *
36:                * Description: This function checks the semaphore to see if a resource is available or, if an event
37:                *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
38:                *              resource is not available or the event did not occur.
39:                *
40:                * Arguments  : pevent     is a pointer to the event control block
41:                *
42:                * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
43:                *                         decremented to obtain the resource.
44:                *              == 0       if the resource is not available or the event did not occur or,
45:                *                         if 'pevent' is a NULL pointer or,
46:                *                         if you didn't pass a pointer to a semaphore
47:                *********************************************************************************************************
48:                */
49:                
50:                #if OS_SEM_ACCEPT_EN > 0u
51:                INT16U  OSSemAccept (OS_EVENT *pevent)
52:                {
0059BA  FA0006     LNK #0x6
0059BC  980720     MOV W0, [W14+4]
53:                    INT16U     cnt;
54:                #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
55:                    OS_CPU_SR  cpu_sr = 0u;
0059BE  EB0000     CLR W0
0059C0  780F00     MOV W0, [W14]
56:                #endif
57:                
58:                
59:                
60:                #if OS_ARG_CHK_EN > 0u
61:                    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0059C2  90002E     MOV [W14+4], W0
0059C4  E00000     CP0 W0
0059C6  3A0002     BRA NZ, 0x59CC
62:                        return (0u);
0059C8  EB0000     CLR W0
0059CA  37001A     BRA 0x5A00
63:                    }
64:                #endif
65:                    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0059CC  90002E     MOV [W14+4], W0
0059CE  784010     MOV.B [W0], W0
0059D0  504FE3     SUB.B W0, #0x3, [W15]
0059D2  320002     BRA Z, 0x59D8
66:                        return (0u);
0059D4  EB0000     CLR W0
0059D6  370014     BRA 0x5A00
67:                    }
68:                    OS_ENTER_CRITICAL();
0059D8  800211     MOV SR, W1
0059DA  780F01     MOV W1, [W14]
0059DC  800211     MOV SR, W1
0059DE  200E00     MOV #0xE0, W0
0059E0  700001     IOR W0, W1, W0
0059E2  880210     MOV W0, SR
69:                    cnt = pevent->OSEventCnt;
0059E4  90002E     MOV [W14+4], W0
0059E6  9000A0     MOV [W0+4], W1
0059E8  980711     MOV W1, [W14+2]
70:                    if (cnt > 0u) {                                   /* See if resource is available                  */
0059EA  90001E     MOV [W14+2], W0
0059EC  E00000     CP0 W0
0059EE  320005     BRA Z, 0x59FA
71:                        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
0059F0  90002E     MOV [W14+4], W0
0059F2  900020     MOV [W0+4], W0
0059F4  E90080     DEC W0, W1
0059F6  90002E     MOV [W14+4], W0
0059F8  980021     MOV W1, [W0+4]
72:                    }
73:                    OS_EXIT_CRITICAL();
0059FA  78009E     MOV [W14], W1
0059FC  880211     MOV W1, SR
74:                    return (cnt);                                     /* Return semaphore count                        */
0059FE  90001E     MOV [W14+2], W0
75:                }
005A00  FA8000     ULNK
005A02  060000     RETURN
76:                #endif
77:                
78:                /*$PAGE*/
79:                /*
80:                *********************************************************************************************************
81:                *                                         CREATE A SEMAPHORE
82:                *
83:                * Description: This function creates a semaphore.
84:                *
85:                * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
86:                *                            available (or no event has occurred).  You initialize the semaphore to a
87:                *                            non-zero value to specify how many resources are available (e.g. if you have
88:                *                            10 resources, you would initialize the semaphore to 10).
89:                *
90:                * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
91:                *                            created semaphore
92:                *              == (void *)0  if no event control blocks were available
93:                *********************************************************************************************************
94:                */
95:                
96:                OS_EVENT  *OSSemCreate (INT16U cnt)
97:                {
005A04  FA0006     LNK #0x6
005A06  980720     MOV W0, [W14+4]
98:                    OS_EVENT  *pevent;
99:                #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
100:                   OS_CPU_SR  cpu_sr = 0u;
005A08  EB0000     CLR W0
005A0A  780F00     MOV W0, [W14]
101:               #endif
102:               
103:               
104:               
105:               #ifdef OS_SAFETY_CRITICAL_IEC61508
106:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
107:                       OS_SAFETY_CRITICAL_EXCEPTION();
108:                       return ((OS_EVENT *)0);
109:                   }
110:               #endif
111:               
112:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
005A0C  BFC86B     MOV.B OSIntNesting, WREG
005A0E  E00400     CP0.B W0
005A10  320002     BRA Z, 0x5A16
113:                       return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
005A12  EB0000     CLR W0
005A14  370022     BRA 0x5A5A
114:                   }
115:                   OS_ENTER_CRITICAL();
005A16  800211     MOV SR, W1
005A18  780F01     MOV W1, [W14]
005A1A  800211     MOV SR, W1
005A1C  200E00     MOV #0xE0, W0
005A1E  700001     IOR W0, W1, W0
005A20  880210     MOV W0, SR
116:                   pevent = OSEventFreeList;                              /* Get next free event control block        */
005A22  8042A1     MOV OSEventFreeList, W1
005A24  980711     MOV W1, [W14+2]
117:                   if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
005A26  8042A0     MOV OSEventFreeList, W0
005A28  E00000     CP0 W0
005A2A  320003     BRA Z, 0x5A32
118:                       OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
005A2C  8042A0     MOV OSEventFreeList, W0
005A2E  900010     MOV [W0+2], W0
005A30  8842A0     MOV W0, OSEventFreeList
119:                   }
120:                   OS_EXIT_CRITICAL();
005A32  78009E     MOV [W14], W1
005A34  880211     MOV W1, SR
121:                   if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
005A36  90001E     MOV [W14+2], W0
005A38  E00000     CP0 W0
005A3A  32000E     BRA Z, 0x5A58
122:                       pevent->OSEventType    = OS_EVENT_TYPE_SEM;
005A3C  90001E     MOV [W14+2], W0
005A3E  B3C031     MOV.B #0x3, W1
005A40  784801     MOV.B W1, [W0]
123:                       pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
005A42  90001E     MOV [W14+2], W0
005A44  9000AE     MOV [W14+4], W1
005A46  980021     MOV W1, [W0+4]
124:                       pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
005A48  90001E     MOV [W14+2], W0
005A4A  EB0080     CLR W1
005A4C  980011     MOV W1, [W0+2]
125:               #if OS_EVENT_NAME_EN > 0u
126:                       pevent->OSEventName    = (INT8U *)(void *)"?";
005A4E  288441     MOV #0x8844, W1
005A50  90001E     MOV [W14+2], W0
005A52  980051     MOV W1, [W0+10]
127:               #endif
128:                       OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
005A54  90001E     MOV [W14+2], W0
005A56  07DB7E     RCALL OS_EventWaitListInit
129:                   }
130:                   return (pevent);
005A58  90001E     MOV [W14+2], W0
131:               }
005A5A  FA8000     ULNK
005A5C  060000     RETURN
132:               
133:               /*$PAGE*/
134:               /*
135:               *********************************************************************************************************
136:               *                                         DELETE A SEMAPHORE
137:               *
138:               * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
139:               *
140:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
141:               *                            semaphore.
142:               *
143:               *              opt           determines delete options as follows:
144:               *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
145:               *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
146:               *                                                    In this case, all the tasks pending will be readied.
147:               *
148:               *              perr          is a pointer to an error code that can contain one of the following values:
149:               *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
150:               *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
151:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
152:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
153:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
154:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
155:               *
156:               * Returns    : pevent        upon error
157:               *              (OS_EVENT *)0 if the semaphore was successfully deleted.
158:               *
159:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
160:               *                 the semaphore MUST check the return code of OSSemPend().
161:               *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
162:               *                 they check 'pevent' to see that it's a NULL pointer.
163:               *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
164:               *                 time is directly proportional to the number of tasks waiting on the semaphore.
165:               *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
166:               *                 applications where the semaphore is used for mutual exclusion because the resource(s)
167:               *                 will no longer be guarded by the semaphore.
168:               *              5) All tasks that were waiting for the semaphore will be readied and returned an 
169:               *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
170:               *********************************************************************************************************
171:               */
172:               
173:               #if OS_SEM_DEL_EN > 0u
174:               OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
175:                                    INT8U      opt,
176:                                    INT8U     *perr)
177:               {
005A5E  FA000C     LNK #0xC
005A60  980730     MOV W0, [W14+6]
005A62  984F01     MOV.B W1, [W14+8]
005A64  980752     MOV W2, [W14+10]
178:                   BOOLEAN    tasks_waiting;
179:                   OS_EVENT  *pevent_return;
180:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
181:                   OS_CPU_SR  cpu_sr = 0u;
005A66  EB0000     CLR W0
005A68  980720     MOV W0, [W14+4]
182:               #endif
183:               
184:               
185:               
186:               #ifdef OS_SAFETY_CRITICAL
187:                   if (perr == (INT8U *)0) {
188:                       OS_SAFETY_CRITICAL_EXCEPTION();
189:                       return ((OS_EVENT *)0);
190:                   }
191:               #endif
192:               
193:               #if OS_ARG_CHK_EN > 0u
194:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
005A6A  90003E     MOV [W14+6], W0
005A6C  E00000     CP0 W0
005A6E  3A0005     BRA NZ, 0x5A7A
195:                       *perr = OS_ERR_PEVENT_NULL;
005A70  90005E     MOV [W14+10], W0
005A72  B3C041     MOV.B #0x4, W1
005A74  784801     MOV.B W1, [W0]
196:                       return (pevent);
005A76  90003E     MOV [W14+6], W0
005A78  370076     BRA 0x5B66
197:                   }
198:               #endif
199:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
005A7A  90003E     MOV [W14+6], W0
005A7C  784010     MOV.B [W0], W0
005A7E  504FE3     SUB.B W0, #0x3, [W15]
005A80  320005     BRA Z, 0x5A8C
200:                       *perr = OS_ERR_EVENT_TYPE;
005A82  90005E     MOV [W14+10], W0
005A84  B3C011     MOV.B #0x1, W1
005A86  784801     MOV.B W1, [W0]
201:                       return (pevent);
005A88  90003E     MOV [W14+6], W0
005A8A  37006D     BRA 0x5B66
202:                   }
203:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
005A8C  BFC86B     MOV.B OSIntNesting, WREG
005A8E  E00400     CP0.B W0
005A90  320005     BRA Z, 0x5A9C
204:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
005A92  90005E     MOV [W14+10], W0
005A94  B3C0F1     MOV.B #0xF, W1
005A96  784801     MOV.B W1, [W0]
205:                       return (pevent);
005A98  90003E     MOV [W14+6], W0
005A9A  370065     BRA 0x5B66
206:                   }
207:                   OS_ENTER_CRITICAL();
005A9C  800211     MOV SR, W1
005A9E  980721     MOV W1, [W14+4]
005AA0  800211     MOV SR, W1
005AA2  200E00     MOV #0xE0, W0
005AA4  700001     IOR W0, W1, W0
005AA6  880210     MOV W0, SR
208:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
005AA8  90003E     MOV [W14+6], W0
005AAA  904060     MOV.B [W0+6], W0
005AAC  E00400     CP0.B W0
005AAE  320003     BRA Z, 0x5AB6
209:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
005AB0  B3C010     MOV.B #0x1, W0
005AB2  784F00     MOV.B W0, [W14]
005AB4  370002     BRA 0x5ABA
210:                   } else {
211:                       tasks_waiting = OS_FALSE;                          /* No                                       */
005AB6  EB4000     CLR.B W0
005AB8  784F00     MOV.B W0, [W14]
212:                   }
213:                   switch (opt) {
005ABA  90480E     MOV.B [W14+8], W0
005ABC  FB8000     ZE W0, W0
005ABE  E00000     CP0 W0
005AC0  320003     BRA Z, 0x5AC8
005AC2  500FE1     SUB W0, #0x1, [W15]
005AC4  320028     BRA Z, 0x5B16
005AC6  370046     BRA 0x5B54
214:                       case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
215:                            if (tasks_waiting == OS_FALSE) {
005AC8  78401E     MOV.B [W14], W0
005ACA  E00400     CP0.B W0
005ACC  3A0016     BRA NZ, 0x5AFA
216:               #if OS_EVENT_NAME_EN > 0u
217:                                pevent->OSEventName    = (INT8U *)(void *)"?";
005ACE  288441     MOV #0x8844, W1
005AD0  90003E     MOV [W14+6], W0
005AD2  980051     MOV W1, [W0+10]
218:               #endif
219:                                pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
005AD4  90003E     MOV [W14+6], W0
005AD6  EB4080     CLR.B W1
005AD8  784801     MOV.B W1, [W0]
220:                                pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
005ADA  8042A1     MOV OSEventFreeList, W1
005ADC  90003E     MOV [W14+6], W0
005ADE  980011     MOV W1, [W0+2]
221:                                pevent->OSEventCnt     = 0u;
005AE0  90003E     MOV [W14+6], W0
005AE2  EB0080     CLR W1
005AE4  980021     MOV W1, [W0+4]
222:                                OSEventFreeList        = pevent;          /* Get next free event control block        */
005AE6  9000BE     MOV [W14+6], W1
005AE8  8842A1     MOV W1, OSEventFreeList
223:                                OS_EXIT_CRITICAL();
005AEA  9000AE     MOV [W14+4], W1
005AEC  880211     MOV W1, SR
224:                                *perr                  = OS_ERR_NONE;
005AEE  90005E     MOV [W14+10], W0
005AF0  EB4080     CLR.B W1
005AF2  784801     MOV.B W1, [W0]
225:                                pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
005AF4  EB0000     CLR W0
005AF6  980710     MOV W0, [W14+2]
226:                            } else {
227:                                OS_EXIT_CRITICAL();
005AFA  9000AE     MOV [W14+4], W1
005AFC  880211     MOV W1, SR
228:                                *perr                  = OS_ERR_TASK_WAITING;
005AFE  90005E     MOV [W14+10], W0
005B00  B3C491     MOV.B #0x49, W1
005B02  784801     MOV.B W1, [W0]
229:                                pevent_return          = pevent;
005B04  9000BE     MOV [W14+6], W1
005B06  980711     MOV W1, [W14+2]
230:                            }
231:                            break;
005AF8  370035     BRA 0x5B64
005B08  37002D     BRA 0x5B64
232:               
233:                       case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
234:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
005B16  000000     NOP
005B18  90003E     MOV [W14+6], W0
005B1A  904060     MOV.B [W0+6], W0
005B1C  E00400     CP0.B W0
005B1E  3AFFF5     BRA NZ, 0x5B0A
235:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
005B0A  B3C023     MOV.B #0x2, W3
005B0C  B3C012     MOV.B #0x1, W2
005B0E  EB0080     CLR W1
005B10  90003E     MOV [W14+6], W0
005B12  07D9EB     RCALL OS_EventTaskRdy
005B14  370001     BRA 0x5B18
236:                            }
237:               #if OS_EVENT_NAME_EN > 0u
238:                            pevent->OSEventName    = (INT8U *)(void *)"?";
005B20  288441     MOV #0x8844, W1
005B22  90003E     MOV [W14+6], W0
005B24  980051     MOV W1, [W0+10]
239:               #endif
240:                            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
005B26  90003E     MOV [W14+6], W0
005B28  EB4080     CLR.B W1
005B2A  784801     MOV.B W1, [W0]
241:                            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
005B2C  8042A1     MOV OSEventFreeList, W1
005B2E  90003E     MOV [W14+6], W0
005B30  980011     MOV W1, [W0+2]
242:                            pevent->OSEventCnt     = 0u;
005B32  90003E     MOV [W14+6], W0
005B34  EB0080     CLR W1
005B36  980021     MOV W1, [W0+4]
243:                            OSEventFreeList        = pevent;              /* Get next free event control block        */
005B38  9000BE     MOV [W14+6], W1
005B3A  8842A1     MOV W1, OSEventFreeList
244:                            OS_EXIT_CRITICAL();
005B3C  9000AE     MOV [W14+4], W1
005B3E  880211     MOV W1, SR
245:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
005B40  78401E     MOV.B [W14], W0
005B42  504FE1     SUB.B W0, #0x1, [W15]
005B44  3A0001     BRA NZ, 0x5B48
246:                                OS_Sched();                               /* Find highest priority task ready to run  */
005B46  07DBF4     RCALL OS_Sched
247:                            }
248:                            *perr                  = OS_ERR_NONE;
005B48  90005E     MOV [W14+10], W0
005B4A  EB4080     CLR.B W1
005B4C  784801     MOV.B W1, [W0]
249:                            pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
005B4E  EB0000     CLR W0
005B50  980710     MOV W0, [W14+2]
250:                            break;
005B52  370008     BRA 0x5B64
251:               
252:                       default:
253:                            OS_EXIT_CRITICAL();
005B54  9000AE     MOV [W14+4], W1
005B56  880211     MOV W1, SR
254:                            *perr                  = OS_ERR_INVALID_OPT;
005B58  90005E     MOV [W14+10], W0
005B5A  B3C071     MOV.B #0x7, W1
005B5C  784801     MOV.B W1, [W0]
255:                            pevent_return          = pevent;
005B5E  9000BE     MOV [W14+6], W1
005B60  980711     MOV W1, [W14+2]
256:                            break;
005B62  000000     NOP
257:                   }
258:                   return (pevent_return);
005B64  90001E     MOV [W14+2], W0
259:               }
005B66  FA8000     ULNK
005B68  060000     RETURN
260:               #endif
261:               
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                          PEND ON SEMAPHORE
266:               *
267:               * Description: This function waits for a semaphore.
268:               *
269:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
270:               *                            semaphore.
271:               *
272:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
273:               *                            wait for the resource up to the amount of time specified by this argument.
274:               *                            If you specify 0, however, your task will wait forever at the specified
275:               *                            semaphore or, until the resource becomes available (or the event occurs).
276:               *
277:               *              perr          is a pointer to where an error message will be deposited.  Possible error
278:               *                            messages are:
279:               *
280:               *                            OS_ERR_NONE         The call was successful and your task owns the resource
281:               *                                                or, the event you are waiting for occurred.
282:               *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
283:               *                                                'timeout'.
284:               *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
285:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
286:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
287:               *                                                would lead to a suspension.
288:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
289:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
290:               *
291:               * Returns    : none
292:               *********************************************************************************************************
293:               */
294:               /*$PAGE*/
295:               void  OSSemPend (OS_EVENT  *pevent,
296:                                INT32U     timeout,
297:                                INT8U     *perr)
298:               {
005B6A  FA000A     LNK #0xA
005B6C  980710     MOV W0, [W14+2]
005B6E  980722     MOV W2, [W14+4]
005B70  980733     MOV W3, [W14+6]
005B72  980741     MOV W1, [W14+8]
299:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
300:                   OS_CPU_SR  cpu_sr = 0u;
005B74  EB0000     CLR W0
005B76  780F00     MOV W0, [W14]
301:               #endif
302:               
303:               
304:               
305:               #ifdef OS_SAFETY_CRITICAL
306:                   if (perr == (INT8U *)0) {
307:                       OS_SAFETY_CRITICAL_EXCEPTION();
308:                       return;
309:                   }
310:               #endif
311:               
312:               #if OS_ARG_CHK_EN > 0u
313:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005B78  90001E     MOV [W14+2], W0
005B7A  E00000     CP0 W0
005B7C  3A0004     BRA NZ, 0x5B86
314:                       *perr = OS_ERR_PEVENT_NULL;
005B7E  90004E     MOV [W14+8], W0
005B80  B3C041     MOV.B #0x4, W1
005B82  784801     MOV.B W1, [W0]
315:                       return;
005B84  370068     BRA 0x5C56
316:                   }
317:               #endif
318:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005B86  90001E     MOV [W14+2], W0
005B88  784010     MOV.B [W0], W0
005B8A  504FE3     SUB.B W0, #0x3, [W15]
005B8C  320004     BRA Z, 0x5B96
319:                       *perr = OS_ERR_EVENT_TYPE;
005B8E  90004E     MOV [W14+8], W0
005B90  B3C011     MOV.B #0x1, W1
005B92  784801     MOV.B W1, [W0]
320:                       return;
005B94  370060     BRA 0x5C56
321:                   }
322:                   if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
005B96  BFC86B     MOV.B OSIntNesting, WREG
005B98  E00400     CP0.B W0
005B9A  320004     BRA Z, 0x5BA4
323:                       *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
005B9C  90004E     MOV [W14+8], W0
005B9E  B3C021     MOV.B #0x2, W1
005BA0  784801     MOV.B W1, [W0]
324:                       return;
005BA2  370059     BRA 0x5C56
325:                   }
326:                   if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
005BA4  BFC86C     MOV.B OSLockNesting, WREG
005BA6  E00400     CP0.B W0
005BA8  320004     BRA Z, 0x5BB2
327:                       *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
005BAA  90004E     MOV [W14+8], W0
005BAC  B3C0D1     MOV.B #0xD, W1
005BAE  784801     MOV.B W1, [W0]
328:                       return;
005BB0  370052     BRA 0x5C56
329:                   }
330:                   OS_ENTER_CRITICAL();
005BB2  800211     MOV SR, W1
005BB4  780F01     MOV W1, [W14]
005BB6  800211     MOV SR, W1
005BB8  200E00     MOV #0xE0, W0
005BBA  700001     IOR W0, W1, W0
005BBC  880210     MOV W0, SR
331:                   if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
005BBE  90001E     MOV [W14+2], W0
005BC0  900020     MOV [W0+4], W0
005BC2  E00000     CP0 W0
005BC4  32000B     BRA Z, 0x5BDC
332:                       pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
005BC6  90001E     MOV [W14+2], W0
005BC8  900020     MOV [W0+4], W0
005BCA  E90080     DEC W0, W1
005BCC  90001E     MOV [W14+2], W0
005BCE  980021     MOV W1, [W0+4]
333:                       OS_EXIT_CRITICAL();
005BD0  78011E     MOV [W14], W2
005BD2  880212     MOV W2, SR
334:                       *perr = OS_ERR_NONE;
005BD4  90004E     MOV [W14+8], W0
005BD6  EB4080     CLR.B W1
005BD8  784801     MOV.B W1, [W0]
335:                       return;
005BDA  37003D     BRA 0x5C56
336:                   }
337:                                                                     /* Otherwise, must wait until event occurs       */
338:                   OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
005BDC  8043B0     MOV OSTCBCur, W0
005BDE  8043B1     MOV OSTCBCur, W1
005BE0  906081     MOV.B [W1+32], W1
005BE2  A00401     BSET.B W1, #0
005BE4  986001     MOV.B W1, [W0+32]
339:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
005BE6  8043B0     MOV OSTCBCur, W0
005BE8  EB4080     CLR.B W1
005BEA  986011     MOV.B W1, [W0+33]
340:                   OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
005BEC  8043B0     MOV OSTCBCur, W0
005BEE  90012E     MOV [W14+4], W2
005BF0  9001BE     MOV [W14+6], W3
005BF2  980862     MOV W2, [W0+28]
005BF4  980873     MOV W3, [W0+30]
341:                   OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
005BF6  90001E     MOV [W14+2], W0
005BF8  07D9CF     RCALL OS_EventTaskWait
342:                   OS_EXIT_CRITICAL();
005BFA  78019E     MOV [W14], W3
005BFC  880213     MOV W3, SR
343:                   OS_Sched();                                       /* Find next highest priority task ready         */
005BFE  07DB98     RCALL OS_Sched
344:                   OS_ENTER_CRITICAL();
005C00  800211     MOV SR, W1
005C02  780F01     MOV W1, [W14]
005C04  800211     MOV SR, W1
005C06  200E00     MOV #0xE0, W0
005C08  700001     IOR W0, W1, W0
005C0A  880210     MOV W0, SR
345:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
005C0C  8043B0     MOV OSTCBCur, W0
005C0E  906010     MOV.B [W0+33], W0
005C10  FB8000     ZE W0, W0
005C12  E00000     CP0 W0
005C14  320003     BRA Z, 0x5C1C
005C16  500FE2     SUB W0, #0x2, [W15]
005C18  320005     BRA Z, 0x5C24
005C1A  370008     BRA 0x5C2C
346:                       case OS_STAT_PEND_OK:
347:                            *perr = OS_ERR_NONE;
005C1C  90004E     MOV [W14+8], W0
005C1E  EB4080     CLR.B W1
005C20  784801     MOV.B W1, [W0]
348:                            break;
005C22  37000B     BRA 0x5C3A
349:               
350:                       case OS_STAT_PEND_ABORT:
351:                            *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
005C24  90004E     MOV [W14+8], W0
005C26  B3C0E1     MOV.B #0xE, W1
005C28  784801     MOV.B W1, [W0]
352:                            break;
005C2A  370007     BRA 0x5C3A
353:               
354:                       case OS_STAT_PEND_TO:
355:                       default:
356:                            OS_EventTaskRemove(OSTCBCur, pevent);
005C2C  8043B0     MOV OSTCBCur, W0
005C2E  90009E     MOV [W14+2], W1
005C30  07DA32     RCALL OS_EventTaskRemove
357:                            *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
005C32  90004E     MOV [W14+8], W0
005C34  B3C0A1     MOV.B #0xA, W1
005C36  784801     MOV.B W1, [W0]
358:                            break;
005C38  000000     NOP
359:                   }
360:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
005C3A  8043B0     MOV OSTCBCur, W0
005C3C  EB4080     CLR.B W1
005C3E  986001     MOV.B W1, [W0+32]
361:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
005C40  8043B0     MOV OSTCBCur, W0
005C42  EB4080     CLR.B W1
005C44  986011     MOV.B W1, [W0+33]
362:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
005C46  8043B0     MOV OSTCBCur, W0
005C48  EB0080     CLR W1
005C4A  980811     MOV W1, [W0+18]
363:               #if (OS_EVENT_MULTI_EN > 0u)
364:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
005C4C  8043B0     MOV OSTCBCur, W0
005C4E  EB0080     CLR W1
005C50  980821     MOV W1, [W0+20]
365:               #endif
366:                   OS_EXIT_CRITICAL();
005C52  78011E     MOV [W14], W2
005C54  880212     MOV W2, SR
367:               }
005C56  FA8000     ULNK
005C58  060000     RETURN
368:               
369:               /*$PAGE*/
370:               /*
371:               *********************************************************************************************************
372:               *                                    ABORT WAITING ON A SEMAPHORE
373:               *
374:               * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
375:               *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
376:               *              the semaphore via OSSemPost().
377:               *
378:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
379:               *                            semaphore.
380:               *
381:               *              opt           determines the type of ABORT performed:
382:               *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
383:               *                                                     semaphore
384:               *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
385:               *                                                     semaphore
386:               *
387:               *              perr          is a pointer to where an error message will be deposited.  Possible error
388:               *                            messages are:
389:               *
390:               *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
391:               *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
392:               *                                                and informed of the aborted wait; check return value
393:               *                                                for the number of tasks whose wait on the semaphore
394:               *                                                was aborted.
395:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
396:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
397:               *
398:               * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
399:               *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
400:               *********************************************************************************************************
401:               */
402:               
403:               #if OS_SEM_PEND_ABORT_EN > 0u
404:               INT8U  OSSemPendAbort (OS_EVENT  *pevent,
405:                                      INT8U      opt,
406:                                      INT8U     *perr)
407:               {
005C5A  FA000A     LNK #0xA
005C5C  980720     MOV W0, [W14+4]
005C5E  984761     MOV.B W1, [W14+6]
005C60  980742     MOV W2, [W14+8]
408:                   INT8U      nbr_tasks;
409:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
410:                   OS_CPU_SR  cpu_sr = 0u;
005C62  EB0000     CLR W0
005C64  980710     MOV W0, [W14+2]
411:               #endif
412:               
413:               
414:               
415:               #ifdef OS_SAFETY_CRITICAL
416:                   if (perr == (INT8U *)0) {
417:                       OS_SAFETY_CRITICAL_EXCEPTION();
418:                       return (0u);
419:                   }
420:               #endif
421:               
422:               #if OS_ARG_CHK_EN > 0u
423:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005C66  90002E     MOV [W14+4], W0
005C68  E00000     CP0 W0
005C6A  3A0005     BRA NZ, 0x5C76
424:                       *perr = OS_ERR_PEVENT_NULL;
005C6C  90004E     MOV [W14+8], W0
005C6E  B3C041     MOV.B #0x4, W1
005C70  784801     MOV.B W1, [W0]
425:                       return (0u);
005C72  EB4000     CLR.B W0
005C74  37003C     BRA 0x5CEE
426:                   }
427:               #endif
428:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005C76  90002E     MOV [W14+4], W0
005C78  784010     MOV.B [W0], W0
005C7A  504FE3     SUB.B W0, #0x3, [W15]
005C7C  320005     BRA Z, 0x5C88
429:                       *perr = OS_ERR_EVENT_TYPE;
005C7E  90004E     MOV [W14+8], W0
005C80  B3C011     MOV.B #0x1, W1
005C82  784801     MOV.B W1, [W0]
430:                       return (0u);
005C84  EB4000     CLR.B W0
005C86  370033     BRA 0x5CEE
431:                   }
432:                   OS_ENTER_CRITICAL();
005C88  800211     MOV SR, W1
005C8A  980711     MOV W1, [W14+2]
005C8C  800211     MOV SR, W1
005C8E  200E00     MOV #0xE0, W0
005C90  700001     IOR W0, W1, W0
005C92  880210     MOV W0, SR
433:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
005C94  90002E     MOV [W14+4], W0
005C96  904060     MOV.B [W0+6], W0
005C98  E00400     CP0.B W0
005C9A  320023     BRA Z, 0x5CE2
434:                       nbr_tasks = 0u;
005C9C  EB4000     CLR.B W0
005C9E  784F00     MOV.B W0, [W14]
435:                       switch (opt) {
005CA0  90406E     MOV.B [W14+6], W0
005CA2  FB8000     ZE W0, W0
005CA4  500FE1     SUB W0, #0x1, [W15]
005CA6  320008     BRA Z, 0x5CB8
005CA8  37000D     BRA 0x5CC4
436:                           case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
437:                                while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
005CB8  000000     NOP
005CBA  90002E     MOV [W14+4], W0
005CBC  904060     MOV.B [W0+6], W0
005CBE  E00400     CP0.B W0
005CC0  3AFFF4     BRA NZ, 0x5CAA
438:                                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
005CAA  B3C023     MOV.B #0x2, W3
005CAC  B3C012     MOV.B #0x1, W2
005CAE  EB0080     CLR W1
005CB0  90002E     MOV [W14+4], W0
005CB2  07D91B     RCALL OS_EventTaskRdy
439:                                    nbr_tasks++;
005CB4  E84F1E     INC.B [W14], [W14]
005CB6  370001     BRA 0x5CBA
440:                                }
441:                                break;
005CC2  370007     BRA 0x5CD2
442:               
443:                           case OS_PEND_OPT_NONE:
444:                           default:                                  /* No,  ready HPT       waiting on semaphore     */
445:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
005CC4  B3C023     MOV.B #0x2, W3
005CC6  B3C012     MOV.B #0x1, W2
005CC8  EB0080     CLR W1
005CCA  90002E     MOV [W14+4], W0
005CCC  07D90E     RCALL OS_EventTaskRdy
446:                                nbr_tasks++;
005CCE  E84F1E     INC.B [W14], [W14]
447:                                break;
005CD0  000000     NOP
448:                       }
449:                       OS_EXIT_CRITICAL();
005CD2  90009E     MOV [W14+2], W1
005CD4  880211     MOV W1, SR
450:                       OS_Sched();                                   /* Find HPT ready to run                         */
005CD6  07DB2C     RCALL OS_Sched
451:                       *perr = OS_ERR_PEND_ABORT;
005CD8  90004E     MOV [W14+8], W0
005CDA  B3C0E1     MOV.B #0xE, W1
005CDC  784801     MOV.B W1, [W0]
452:                       return (nbr_tasks);
005CDE  78401E     MOV.B [W14], W0
005CE0  370006     BRA 0x5CEE
453:                   }
454:                   OS_EXIT_CRITICAL();
005CE2  90009E     MOV [W14+2], W1
005CE4  880211     MOV W1, SR
455:                   *perr = OS_ERR_NONE;
005CE6  90004E     MOV [W14+8], W0
005CE8  EB4080     CLR.B W1
005CEA  784801     MOV.B W1, [W0]
456:                   return (0u);                                      /* No tasks waiting on semaphore                 */
005CEC  EB4000     CLR.B W0
457:               }
005CEE  FA8000     ULNK
005CF0  060000     RETURN
458:               #endif
459:               
460:               /*$PAGE*/
461:               /*
462:               *********************************************************************************************************
463:               *                                         POST TO A SEMAPHORE
464:               *
465:               * Description: This function signals a semaphore
466:               *
467:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
468:               *                            semaphore.
469:               *
470:               * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
471:               *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
472:               *                                  signaled the semaphore more often than you waited on it with either
473:               *                                  OSSemAccept() or OSSemPend().
474:               *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
475:               *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
476:               *********************************************************************************************************
477:               */
478:               
479:               INT8U  OSSemPost (OS_EVENT *pevent)
480:               {
005CF2  FA0004     LNK #0x4
005CF4  980710     MOV W0, [W14+2]
481:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
482:                   OS_CPU_SR  cpu_sr = 0u;
005CF6  EB0000     CLR W0
005CF8  780F00     MOV W0, [W14]
483:               #endif
484:               
485:               
486:               
487:               #if OS_ARG_CHK_EN > 0u
488:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005CFA  90001E     MOV [W14+2], W0
005CFC  E00000     CP0 W0
005CFE  3A0002     BRA NZ, 0x5D04
489:                       return (OS_ERR_PEVENT_NULL);
005D00  B3C040     MOV.B #0x4, W0
005D02  37002A     BRA 0x5D58
490:                   }
491:               #endif
492:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005D04  90001E     MOV [W14+2], W0
005D06  784010     MOV.B [W0], W0
005D08  504FE3     SUB.B W0, #0x3, [W15]
005D0A  320002     BRA Z, 0x5D10
493:                       return (OS_ERR_EVENT_TYPE);
005D0C  B3C010     MOV.B #0x1, W0
005D0E  370024     BRA 0x5D58
494:                   }
495:                   OS_ENTER_CRITICAL();
005D10  800211     MOV SR, W1
005D12  780F01     MOV W1, [W14]
005D14  800211     MOV SR, W1
005D16  200E00     MOV #0xE0, W0
005D18  700001     IOR W0, W1, W0
005D1A  880210     MOV W0, SR
496:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
005D1C  90001E     MOV [W14+2], W0
005D1E  904060     MOV.B [W0+6], W0
005D20  E00400     CP0.B W0
005D22  32000A     BRA Z, 0x5D38
497:                                                                     /* Ready HPT waiting on event                    */
498:                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
005D24  EB4180     CLR.B W3
005D26  B3C012     MOV.B #0x1, W2
005D28  EB0080     CLR W1
005D2A  90001E     MOV [W14+2], W0
005D2C  07D8DE     RCALL OS_EventTaskRdy
499:                       OS_EXIT_CRITICAL();
005D2E  78009E     MOV [W14], W1
005D30  880211     MOV W1, SR
500:                       OS_Sched();                                   /* Find HPT ready to run                         */
005D32  07DAFE     RCALL OS_Sched
501:                       return (OS_ERR_NONE);
005D34  EB4000     CLR.B W0
005D36  370010     BRA 0x5D58
502:                   }
503:                   if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
005D38  90001E     MOV [W14+2], W0
005D3A  900020     MOV [W0+4], W0
005D3C  400FE1     ADD W0, #0x1, [W15]
005D3E  320009     BRA Z, 0x5D52
504:                       pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
005D40  90001E     MOV [W14+2], W0
005D42  900020     MOV [W0+4], W0
005D44  E80080     INC W0, W1
005D46  90001E     MOV [W14+2], W0
005D48  980021     MOV W1, [W0+4]
505:                       OS_EXIT_CRITICAL();
005D4A  78009E     MOV [W14], W1
005D4C  880211     MOV W1, SR
506:                       return (OS_ERR_NONE);
005D4E  EB4000     CLR.B W0
005D50  370003     BRA 0x5D58
507:                   }
508:                   OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
005D52  78009E     MOV [W14], W1
005D54  880211     MOV W1, SR
509:                   return (OS_ERR_SEM_OVF);
005D56  B3C330     MOV.B #0x33, W0
510:               }
005D58  FA8000     ULNK
005D5A  060000     RETURN
511:               
512:               /*$PAGE*/
513:               /*
514:               *********************************************************************************************************
515:               *                                          QUERY A SEMAPHORE
516:               *
517:               * Description: This function obtains information about a semaphore
518:               *
519:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
520:               *                            semaphore
521:               *
522:               *              p_sem_data    is a pointer to a structure that will contain information about the
523:               *                            semaphore.
524:               *
525:               * Returns    : OS_ERR_NONE         The call was successful and the message was sent
526:               *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
527:               *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
528:               *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
529:               *********************************************************************************************************
530:               */
531:               
532:               #if OS_SEM_QUERY_EN > 0u
533:               INT8U  OSSemQuery (OS_EVENT     *pevent,
534:                                  OS_SEM_DATA  *p_sem_data)
535:               {
005D5C  FA000C     LNK #0xC
005D5E  980740     MOV W0, [W14+8]
005D60  980751     MOV W1, [W14+10]
536:                   INT8U       i;
537:                   OS_PRIO    *psrc;
538:                   OS_PRIO    *pdest;
539:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
540:                   OS_CPU_SR   cpu_sr = 0u;
005D62  EB0000     CLR W0
005D64  980730     MOV W0, [W14+6]
541:               #endif
542:               
543:               
544:               
545:               #if OS_ARG_CHK_EN > 0u
546:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
005D66  90004E     MOV [W14+8], W0
005D68  E00000     CP0 W0
005D6A  3A0002     BRA NZ, 0x5D70
547:                       return (OS_ERR_PEVENT_NULL);
005D6C  B3C040     MOV.B #0x4, W0
005D6E  370033     BRA 0x5DD6
548:                   }
549:                   if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
005D70  90005E     MOV [W14+10], W0
005D72  E00000     CP0 W0
005D74  3A0002     BRA NZ, 0x5D7A
550:                       return (OS_ERR_PDATA_NULL);
005D76  B3C090     MOV.B #0x9, W0
005D78  37002E     BRA 0x5DD6
551:                   }
552:               #endif
553:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
005D7A  90004E     MOV [W14+8], W0
005D7C  784010     MOV.B [W0], W0
005D7E  504FE3     SUB.B W0, #0x3, [W15]
005D80  320002     BRA Z, 0x5D86
554:                       return (OS_ERR_EVENT_TYPE);
005D82  B3C010     MOV.B #0x1, W0
005D84  370028     BRA 0x5DD6
555:                   }
556:                   OS_ENTER_CRITICAL();
005D86  800211     MOV SR, W1
005D88  980731     MOV W1, [W14+6]
005D8A  800211     MOV SR, W1
005D8C  200E00     MOV #0xE0, W0
005D8E  700001     IOR W0, W1, W0
005D90  880210     MOV W0, SR
557:                   p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
005D92  90004E     MOV [W14+8], W0
005D94  9040E0     MOV.B [W0+6], W1
005D96  90005E     MOV [W14+10], W0
005D98  984041     MOV.B W1, [W0+4]
558:                   psrc                   = &pevent->OSEventTbl[0];
005D9A  90004E     MOV [W14+8], W0
005D9C  400067     ADD W0, #0x7, W0
005D9E  980710     MOV W0, [W14+2]
559:                   pdest                  = &p_sem_data->OSEventTbl[0];
005DA0  90005E     MOV [W14+10], W0
005DA2  E88000     INC2 W0, W0
005DA4  980720     MOV W0, [W14+4]
560:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
005DA6  EB4000     CLR.B W0
005DA8  784F00     MOV.B W0, [W14]
005DAA  37000B     BRA 0x5DC2
005DC0  E84F1E     INC.B [W14], [W14]
005DC2  78401E     MOV.B [W14], W0
005DC4  504FE1     SUB.B W0, #0x1, [W15]
005DC6  36FFF2     BRA LEU, 0x5DAC
561:                       *pdest++ = *psrc++;
005DAC  90001E     MOV [W14+2], W0
005DAE  784090     MOV.B [W0], W1
005DB0  90002E     MOV [W14+4], W0
005DB2  784801     MOV.B W1, [W0]
005DB4  90002E     MOV [W14+4], W0
005DB6  E80000     INC W0, W0
005DB8  980720     MOV W0, [W14+4]
005DBA  90001E     MOV [W14+2], W0
005DBC  E80000     INC W0, W0
005DBE  980710     MOV W0, [W14+2]
562:                   }
563:                   p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
005DC8  90004E     MOV [W14+8], W0
005DCA  9000A0     MOV [W0+4], W1
005DCC  90005E     MOV [W14+10], W0
005DCE  780801     MOV W1, [W0]
564:                   OS_EXIT_CRITICAL();
005DD0  9000BE     MOV [W14+6], W1
005DD2  880211     MOV W1, SR
565:                   return (OS_ERR_NONE);
005DD4  EB4000     CLR.B W0
566:               }
005DD6  FA8000     ULNK
005DD8  060000     RETURN
567:               #endif                                                     /* OS_SEM_QUERY_EN                          */
568:               
569:               /*$PAGE*/
570:               /*
571:               *********************************************************************************************************
572:               *                                            SET SEMAPHORE
573:               *
574:               * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
575:               *              this value would be 0.
576:               *
577:               *              You would typically use this function when a semaphore is used as a signaling mechanism
578:               *              and, you want to reset the count value.
579:               *
580:               * Arguments  : pevent     is a pointer to the event control block
581:               *
582:               *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
583:               *                         semaphore count.
584:               *
585:               *              perr       is a pointer to an error code returned by the function as follows:
586:               *
587:               *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
588:               *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
589:               *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
590:               *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
591:               *********************************************************************************************************
592:               */
593:               
594:               #if OS_SEM_SET_EN > 0u
595:               void  OSSemSet (OS_EVENT  *pevent,
596:                               INT16U     cnt,
597:                               INT8U     *perr)
598:               {
005DDA  FA0008     LNK #0x8
005DDC  980710     MOV W0, [W14+2]
005DDE  980721     MOV W1, [W14+4]
005DE0  980732     MOV W2, [W14+6]
599:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
600:                   OS_CPU_SR  cpu_sr = 0u;
005DE2  EB0000     CLR W0
005DE4  780F00     MOV W0, [W14]
601:               #endif
602:               
603:               
604:               
605:               #ifdef OS_SAFETY_CRITICAL
606:                   if (perr == (INT8U *)0) {
607:                       OS_SAFETY_CRITICAL_EXCEPTION();
608:                       return;
609:                   }
610:               #endif
611:               
612:               #if OS_ARG_CHK_EN > 0u
613:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005DE6  90001E     MOV [W14+2], W0
005DE8  E00000     CP0 W0
005DEA  3A0004     BRA NZ, 0x5DF4
614:                       *perr = OS_ERR_PEVENT_NULL;
005DEC  90003E     MOV [W14+6], W0
005DEE  B3C041     MOV.B #0x4, W1
005DF0  784801     MOV.B W1, [W0]
615:                       return;
005DF2  370026     BRA 0x5E40
616:                   }
617:               #endif
618:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005DF4  90001E     MOV [W14+2], W0
005DF6  784010     MOV.B [W0], W0
005DF8  504FE3     SUB.B W0, #0x3, [W15]
005DFA  320004     BRA Z, 0x5E04
619:                       *perr = OS_ERR_EVENT_TYPE;
005DFC  90003E     MOV [W14+6], W0
005DFE  B3C011     MOV.B #0x1, W1
005E00  784801     MOV.B W1, [W0]
620:                       return;
005E02  37001E     BRA 0x5E40
621:                   }
622:                   OS_ENTER_CRITICAL();
005E04  800211     MOV SR, W1
005E06  780F01     MOV W1, [W14]
005E08  800211     MOV SR, W1
005E0A  200E00     MOV #0xE0, W0
005E0C  700001     IOR W0, W1, W0
005E0E  880210     MOV W0, SR
623:                   *perr = OS_ERR_NONE;
005E10  90003E     MOV [W14+6], W0
005E12  EB4080     CLR.B W1
005E14  784801     MOV.B W1, [W0]
624:                   if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
005E16  90001E     MOV [W14+2], W0
005E18  900020     MOV [W0+4], W0
005E1A  E00000     CP0 W0
005E1C  320004     BRA Z, 0x5E26
625:                       pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
005E1E  90001E     MOV [W14+2], W0
005E20  9000AE     MOV [W14+4], W1
005E22  980021     MOV W1, [W0+4]
005E24  37000B     BRA 0x5E3C
626:                   } else {                                          /* No                                            */
627:                       if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
005E26  90001E     MOV [W14+2], W0
005E28  904060     MOV.B [W0+6], W0
005E2A  E00400     CP0.B W0
005E2C  3A0004     BRA NZ, 0x5E36
628:                           pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
005E2E  90001E     MOV [W14+2], W0
005E30  9000AE     MOV [W14+4], W1
005E32  980021     MOV W1, [W0+4]
005E34  370003     BRA 0x5E3C
629:                       } else {
630:                           *perr              = OS_ERR_TASK_WAITING;
005E36  90003E     MOV [W14+6], W0
005E38  B3C491     MOV.B #0x49, W1
005E3A  784801     MOV.B W1, [W0]
631:                       }
632:                   }
633:                   OS_EXIT_CRITICAL();
005E3C  78009E     MOV [W14], W1
005E3E  880211     MOV W1, SR
634:               }
005E40  FA8000     ULNK
635:               #endif
636:               
637:               #endif                                                /* OS_SEM_EN                                     */
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_q.c  ---------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                        MESSAGE QUEUE MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_Q.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
31:                /*
32:                *********************************************************************************************************
33:                *                                      ACCEPT MESSAGE FROM QUEUE
34:                *
35:                * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
36:                *              OSQAccept() does not suspend the calling task if a message is not available.
37:                *
38:                * Arguments  : pevent        is a pointer to the event control block
39:                *
40:                *              perr          is a pointer to where an error message will be deposited.  Possible error
41:                *                            messages are:
42:                *
43:                *                            OS_ERR_NONE         The call was successful and your task received a
44:                *                                                message.
45:                *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
46:                *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
47:                *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
48:                *
49:                * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
50:                *                            from the so the next time OSQAccept() is called, the queue will contain
51:                *                            one less entry.
52:                *              == (void *)0  if you received a NULL pointer message
53:                *                            if the queue is empty or,
54:                *                            if 'pevent' is a NULL pointer or,
55:                *                            if you passed an invalid event type
56:                *
57:                * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
58:                *              'perr' has been added to the API to tell you about the outcome of the call.
59:                *********************************************************************************************************
60:                */
61:                
62:                #if OS_Q_ACCEPT_EN > 0u
63:                void  *OSQAccept (OS_EVENT  *pevent,
64:                                  INT8U     *perr)
65:                {
004D28  FA000A     LNK #0xA
004D2A  980730     MOV W0, [W14+6]
004D2C  980741     MOV W1, [W14+8]
66:                    void      *pmsg;
67:                    OS_Q      *pq;
68:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
69:                    OS_CPU_SR  cpu_sr = 0u;
004D2E  EB0000     CLR W0
004D30  980710     MOV W0, [W14+2]
70:                #endif
71:                
72:                
73:                
74:                #ifdef OS_SAFETY_CRITICAL
75:                    if (perr == (INT8U *)0) {
76:                        OS_SAFETY_CRITICAL_EXCEPTION();
77:                        return ((void *)0);
78:                    }
79:                #endif
80:                
81:                #if OS_ARG_CHK_EN > 0u
82:                    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
004D32  90003E     MOV [W14+6], W0
004D34  E00000     CP0 W0
004D36  3A0005     BRA NZ, 0x4D42
83:                        *perr = OS_ERR_PEVENT_NULL;
004D38  90004E     MOV [W14+8], W0
004D3A  B3C041     MOV.B #0x4, W1
004D3C  784801     MOV.B W1, [W0]
84:                        return ((void *)0);
004D3E  EB0000     CLR W0
004D40  370037     BRA 0x4DB0
85:                    }
86:                #endif
87:                    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
004D42  90003E     MOV [W14+6], W0
004D44  784010     MOV.B [W0], W0
004D46  504FE2     SUB.B W0, #0x2, [W15]
004D48  320005     BRA Z, 0x4D54
88:                        *perr = OS_ERR_EVENT_TYPE;
004D4A  90004E     MOV [W14+8], W0
004D4C  B3C011     MOV.B #0x1, W1
004D4E  784801     MOV.B W1, [W0]
89:                        return ((void *)0);
004D50  EB0000     CLR W0
004D52  37002E     BRA 0x4DB0
90:                    }
91:                    OS_ENTER_CRITICAL();
004D54  800211     MOV SR, W1
004D56  980711     MOV W1, [W14+2]
004D58  800211     MOV SR, W1
004D5A  200E00     MOV #0xE0, W0
004D5C  700001     IOR W0, W1, W0
004D5E  880210     MOV W0, SR
92:                    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
004D60  90003E     MOV [W14+6], W0
004D62  900010     MOV [W0+2], W0
004D64  980720     MOV W0, [W14+4]
93:                    if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
004D66  90002E     MOV [W14+4], W0
004D68  900060     MOV [W0+12], W0
004D6A  E00000     CP0 W0
004D6C  320019     BRA Z, 0x4DA0
94:                        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
004D6E  90002E     MOV [W14+4], W0
004D70  900040     MOV [W0+8], W0
004D72  780F10     MOV [W0], [W14]
004D74  E88080     INC2 W0, W1
004D76  90002E     MOV [W14+4], W0
004D78  980041     MOV W1, [W0+8]
95:                        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
004D7A  90002E     MOV [W14+4], W0
004D7C  900060     MOV [W0+12], W0
004D7E  E90080     DEC W0, W1
004D80  90002E     MOV [W14+4], W0
004D82  980061     MOV W1, [W0+12]
96:                        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
004D84  90002E     MOV [W14+4], W0
004D86  9000C0     MOV [W0+8], W1
004D88  90002E     MOV [W14+4], W0
004D8A  900020     MOV [W0+4], W0
004D8C  508F80     SUB W1, W0, [W15]
004D8E  3A0004     BRA NZ, 0x4D98
97:                            pq->OSQOut = pq->OSQStart;
004D90  90002E     MOV [W14+4], W0
004D92  900090     MOV [W0+2], W1
004D94  90002E     MOV [W14+4], W0
004D96  980041     MOV W1, [W0+8]
98:                        }
99:                        *perr = OS_ERR_NONE;
004D98  90004E     MOV [W14+8], W0
004D9A  EB4080     CLR.B W1
004D9C  784801     MOV.B W1, [W0]
004D9E  370005     BRA 0x4DAA
100:                   } else {
101:                       *perr = OS_ERR_Q_EMPTY;
004DA0  90004E     MOV [W14+8], W0
004DA2  B3C1F1     MOV.B #0x1F, W1
004DA4  784801     MOV.B W1, [W0]
102:                       pmsg  = (void *)0;                       /* Queue is empty                                     */
004DA6  EB0000     CLR W0
004DA8  780F00     MOV W0, [W14]
103:                   }
104:                   OS_EXIT_CRITICAL();
004DAA  90009E     MOV [W14+2], W1
004DAC  880211     MOV W1, SR
105:                   return (pmsg);                               /* Return message received (or NULL)                  */
004DAE  78001E     MOV [W14], W0
106:               }
004DB0  FA8000     ULNK
004DB2  060000     RETURN
107:               #endif
108:               /*$PAGE*/
109:               /*
110:               *********************************************************************************************************
111:               *                                       CREATE A MESSAGE QUEUE
112:               *
113:               * Description: This function creates a message queue if free event control blocks are available.
114:               *
115:               * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
116:               *                            storage area MUST be declared as an array of pointers to 'void' as follows
117:               *
118:               *                            void *MessageStorage[size]
119:               *
120:               *              size          is the number of elements in the storage area
121:               *
122:               * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
123:               *                                created queue
124:               *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
125:               *********************************************************************************************************
126:               */
127:               
128:               OS_EVENT  *OSQCreate (void    **start,
129:                                     INT16U    size)
130:               {
004DB4  FA000A     LNK #0xA
004DB6  980730     MOV W0, [W14+6]
004DB8  980741     MOV W1, [W14+8]
131:                   OS_EVENT  *pevent;
132:                   OS_Q      *pq;
133:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
134:                   OS_CPU_SR  cpu_sr = 0u;
004DBA  EB0000     CLR W0
004DBC  980710     MOV W0, [W14+2]
135:               #endif
136:               
137:               
138:               
139:               #ifdef OS_SAFETY_CRITICAL_IEC61508
140:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
141:                       OS_SAFETY_CRITICAL_EXCEPTION();
142:                       return ((OS_EVENT *)0);
143:                   }
144:               #endif
145:               
146:                   if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
004DBE  BFC86B     MOV.B OSIntNesting, WREG
004DC0  E00400     CP0.B W0
004DC2  320002     BRA Z, 0x4DC8
147:                       return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
004DC4  EB0000     CLR W0
004DC6  370051     BRA 0x4E6A
148:                   }
149:                   OS_ENTER_CRITICAL();
004DC8  800211     MOV SR, W1
004DCA  980711     MOV W1, [W14+2]
004DCC  800211     MOV SR, W1
004DCE  200E00     MOV #0xE0, W0
004DD0  700001     IOR W0, W1, W0
004DD2  880210     MOV W0, SR
150:                   pevent = OSEventFreeList;                    /* Get next free event control block                  */
004DD4  8042A1     MOV OSEventFreeList, W1
004DD6  780F01     MOV W1, [W14]
151:                   if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
004DD8  8042A0     MOV OSEventFreeList, W0
004DDA  E00000     CP0 W0
004DDC  320003     BRA Z, 0x4DE4
152:                       OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
004DDE  8042A0     MOV OSEventFreeList, W0
004DE0  900010     MOV [W0+2], W0
004DE2  8842A0     MOV W0, OSEventFreeList
153:                   }
154:                   OS_EXIT_CRITICAL();
004DE4  90009E     MOV [W14+2], W1
004DE6  880211     MOV W1, SR
155:                   if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
004DE8  78001E     MOV [W14], W0
004DEA  E00000     CP0 W0
004DEC  32003D     BRA Z, 0x4E68
156:                       OS_ENTER_CRITICAL();
004DEE  800211     MOV SR, W1
004DF0  980711     MOV W1, [W14+2]
004DF2  800211     MOV SR, W1
004DF4  200E00     MOV #0xE0, W0
004DF6  700001     IOR W0, W1, W0
004DF8  880210     MOV W0, SR
157:                       pq = OSQFreeList;                        /* Get a free queue control block                     */
004DFA  804401     MOV OSQFreeList, W1
004DFC  980721     MOV W1, [W14+4]
158:                       if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
004DFE  90002E     MOV [W14+4], W0
004E00  E00000     CP0 W0
004E02  320029     BRA Z, 0x4E56
159:                           OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
004E04  804400     MOV OSQFreeList, W0
004E06  780010     MOV [W0], W0
004E08  884400     MOV W0, OSQFreeList
160:                           OS_EXIT_CRITICAL();
004E0A  90009E     MOV [W14+2], W1
004E0C  880211     MOV W1, SR
161:                           pq->OSQStart           = start;               /*      Initialize the queue                 */
004E0E  90002E     MOV [W14+4], W0
004E10  9000BE     MOV [W14+6], W1
004E12  980011     MOV W1, [W0+2]
162:                           pq->OSQEnd             = &start[size];
004E14  90004E     MOV [W14+8], W0
004E16  400000     ADD W0, W0, W0
004E18  9000BE     MOV [W14+6], W1
004E1A  408080     ADD W1, W0, W1
004E1C  90002E     MOV [W14+4], W0
004E1E  980021     MOV W1, [W0+4]
163:                           pq->OSQIn              = start;
004E20  90002E     MOV [W14+4], W0
004E22  9000BE     MOV [W14+6], W1
004E24  980031     MOV W1, [W0+6]
164:                           pq->OSQOut             = start;
004E26  90002E     MOV [W14+4], W0
004E28  9000BE     MOV [W14+6], W1
004E2A  980041     MOV W1, [W0+8]
165:                           pq->OSQSize            = size;
004E2C  90002E     MOV [W14+4], W0
004E2E  9000CE     MOV [W14+8], W1
004E30  980051     MOV W1, [W0+10]
166:                           pq->OSQEntries         = 0u;
004E32  90002E     MOV [W14+4], W0
004E34  EB0080     CLR W1
004E36  980061     MOV W1, [W0+12]
167:                           pevent->OSEventType    = OS_EVENT_TYPE_Q;
004E38  78001E     MOV [W14], W0
004E3A  B3C021     MOV.B #0x2, W1
004E3C  784801     MOV.B W1, [W0]
168:                           pevent->OSEventCnt     = 0u;
004E3E  78001E     MOV [W14], W0
004E40  EB0080     CLR W1
004E42  980021     MOV W1, [W0+4]
169:                           pevent->OSEventPtr     = pq;
004E44  78001E     MOV [W14], W0
004E46  9000AE     MOV [W14+4], W1
004E48  980011     MOV W1, [W0+2]
170:               #if OS_EVENT_NAME_EN > 0u
171:                           pevent->OSEventName    = (INT8U *)(void *)"?";
004E4A  288421     MOV #0x8842, W1
004E4C  78001E     MOV [W14], W0
004E4E  980051     MOV W1, [W0+10]
172:               #endif
173:                           OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
004E50  78001E     MOV [W14], W0
004E52  07E180     RCALL OS_EventWaitListInit
004E54  370009     BRA 0x4E68
174:                       } else {
175:                           pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
004E56  8042A1     MOV OSEventFreeList, W1
004E58  78001E     MOV [W14], W0
004E5A  980011     MOV W1, [W0+2]
176:                           OSEventFreeList    = pevent;
004E5C  78009E     MOV [W14], W1
004E5E  8842A1     MOV W1, OSEventFreeList
177:                           OS_EXIT_CRITICAL();
004E60  90009E     MOV [W14+2], W1
004E62  880211     MOV W1, SR
178:                           pevent = (OS_EVENT *)0;
004E64  EB0000     CLR W0
004E66  780F00     MOV W0, [W14]
179:                       }
180:                   }
181:                   return (pevent);
004E68  78001E     MOV [W14], W0
182:               }
004E6A  FA8000     ULNK
004E6C  060000     RETURN
183:               /*$PAGE*/
184:               /*
185:               *********************************************************************************************************
186:               *                                       DELETE A MESSAGE QUEUE
187:               *
188:               * Description: This function deletes a message queue and readies all tasks pending on the queue.
189:               *
190:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
191:               *                            queue.
192:               *
193:               *              opt           determines delete options as follows:
194:               *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
195:               *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
196:               *                                                    In this case, all the tasks pending will be readied.
197:               *
198:               *              perr          is a pointer to an error code that can contain one of the following values:
199:               *                            OS_ERR_NONE             The call was successful and the queue was deleted
200:               *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
201:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
202:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
203:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
204:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
205:               *
206:               * Returns    : pevent        upon error
207:               *              (OS_EVENT *)0 if the queue was successfully deleted.
208:               *
209:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
210:               *                 the queue MUST check the return code of OSQPend().
211:               *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
212:               *                 they check 'pevent' to see that it's a NULL pointer.
213:               *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
214:               *                 time is directly proportional to the number of tasks waiting on the queue.
215:               *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
216:               *                 applications where the queue is used for mutual exclusion because the resource(s)
217:               *                 will no longer be guarded by the queue.
218:               *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
219:               *                 type call) then your application MUST release the memory storage by call the counterpart
220:               *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
221:               *                 then, the storage can be reused.
222:               *              6) All tasks that were waiting for the queue will be readied and returned an 
223:               *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
224:               *********************************************************************************************************
225:               */
226:               
227:               #if OS_Q_DEL_EN > 0u
228:               OS_EVENT  *OSQDel (OS_EVENT  *pevent,
229:                                  INT8U      opt,
230:                                  INT8U     *perr)
231:               {
004E6E  FA000E     LNK #0xE
004E70  980740     MOV W0, [W14+8]
004E72  984F21     MOV.B W1, [W14+10]
004E74  980762     MOV W2, [W14+12]
232:                   BOOLEAN    tasks_waiting;
233:                   OS_EVENT  *pevent_return;
234:                   OS_Q      *pq;
235:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
236:                   OS_CPU_SR  cpu_sr = 0u;
004E76  EB0000     CLR W0
004E78  980720     MOV W0, [W14+4]
237:               #endif
238:               
239:               
240:               
241:               #ifdef OS_SAFETY_CRITICAL
242:                   if (perr == (INT8U *)0) {
243:                       OS_SAFETY_CRITICAL_EXCEPTION();
244:                       return ((OS_EVENT *)0);
245:                   }
246:               #endif
247:               
248:               #if OS_ARG_CHK_EN > 0u
249:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
004E7A  90004E     MOV [W14+8], W0
004E7C  E00000     CP0 W0
004E7E  3A0005     BRA NZ, 0x4E8A
250:                       *perr = OS_ERR_PEVENT_NULL;
004E80  90006E     MOV [W14+12], W0
004E82  B3C041     MOV.B #0x4, W1
004E84  784801     MOV.B W1, [W0]
251:                       return (pevent);
004E86  90004E     MOV [W14+8], W0
004E88  370086     BRA 0x4F96
252:                   }
253:               #endif
254:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
004E8A  90004E     MOV [W14+8], W0
004E8C  784010     MOV.B [W0], W0
004E8E  504FE2     SUB.B W0, #0x2, [W15]
004E90  320005     BRA Z, 0x4E9C
255:                       *perr = OS_ERR_EVENT_TYPE;
004E92  90006E     MOV [W14+12], W0
004E94  B3C011     MOV.B #0x1, W1
004E96  784801     MOV.B W1, [W0]
256:                       return (pevent);
004E98  90004E     MOV [W14+8], W0
004E9A  37007D     BRA 0x4F96
257:                   }
258:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
004E9C  BFC86B     MOV.B OSIntNesting, WREG
004E9E  E00400     CP0.B W0
004EA0  320005     BRA Z, 0x4EAC
259:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
004EA2  90006E     MOV [W14+12], W0
004EA4  B3C0F1     MOV.B #0xF, W1
004EA6  784801     MOV.B W1, [W0]
260:                       return (pevent);
004EA8  90004E     MOV [W14+8], W0
004EAA  370075     BRA 0x4F96
261:                   }
262:                   OS_ENTER_CRITICAL();
004EAC  800211     MOV SR, W1
004EAE  980721     MOV W1, [W14+4]
004EB0  800211     MOV SR, W1
004EB2  200E00     MOV #0xE0, W0
004EB4  700001     IOR W0, W1, W0
004EB6  880210     MOV W0, SR
263:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
004EB8  90004E     MOV [W14+8], W0
004EBA  904060     MOV.B [W0+6], W0
004EBC  E00400     CP0.B W0
004EBE  320003     BRA Z, 0x4EC6
264:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
004EC0  B3C010     MOV.B #0x1, W0
004EC2  784F00     MOV.B W0, [W14]
004EC4  370002     BRA 0x4ECA
265:                   } else {
266:                       tasks_waiting = OS_FALSE;                          /* No                                       */
004EC6  EB4000     CLR.B W0
004EC8  784F00     MOV.B W0, [W14]
267:                   }
268:                   switch (opt) {
004ECA  90482E     MOV.B [W14+10], W0
004ECC  FB8000     ZE W0, W0
004ECE  E00000     CP0 W0
004ED0  320003     BRA Z, 0x4ED8
004ED2  500FE1     SUB W0, #0x1, [W15]
004ED4  320030     BRA Z, 0x4F36
004ED6  370056     BRA 0x4F84
269:                       case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
270:                            if (tasks_waiting == OS_FALSE) {
004ED8  78401E     MOV.B [W14], W0
004EDA  E00400     CP0.B W0
004EDC  3A001E     BRA NZ, 0x4F1A
271:               #if OS_EVENT_NAME_EN > 0u
272:                                pevent->OSEventName    = (INT8U *)(void *)"?";
004EDE  288421     MOV #0x8842, W1
004EE0  90004E     MOV [W14+8], W0
004EE2  980051     MOV W1, [W0+10]
273:               #endif
274:                                pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
004EE4  90004E     MOV [W14+8], W0
004EE6  900010     MOV [W0+2], W0
004EE8  980730     MOV W0, [W14+6]
275:                                pq->OSQPtr             = OSQFreeList;
004EEA  804401     MOV OSQFreeList, W1
004EEC  90003E     MOV [W14+6], W0
004EEE  780801     MOV W1, [W0]
276:                                OSQFreeList            = pq;
004EF0  9000BE     MOV [W14+6], W1
004EF2  884401     MOV W1, OSQFreeList
277:                                pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
004EF4  90004E     MOV [W14+8], W0
004EF6  EB4080     CLR.B W1
004EF8  784801     MOV.B W1, [W0]
278:                                pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
004EFA  8042A1     MOV OSEventFreeList, W1
004EFC  90004E     MOV [W14+8], W0
004EFE  980011     MOV W1, [W0+2]
279:                                pevent->OSEventCnt     = 0u;
004F00  90004E     MOV [W14+8], W0
004F02  EB0080     CLR W1
004F04  980021     MOV W1, [W0+4]
280:                                OSEventFreeList        = pevent;          /* Get next free event control block        */
004F06  9000CE     MOV [W14+8], W1
004F08  8842A1     MOV W1, OSEventFreeList
281:                                OS_EXIT_CRITICAL();
004F0A  9000AE     MOV [W14+4], W1
004F0C  880211     MOV W1, SR
282:                                *perr                  = OS_ERR_NONE;
004F0E  90006E     MOV [W14+12], W0
004F10  EB4080     CLR.B W1
004F12  784801     MOV.B W1, [W0]
283:                                pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
004F14  EB0000     CLR W0
004F16  980710     MOV W0, [W14+2]
284:                            } else {
285:                                OS_EXIT_CRITICAL();
004F1A  9000AE     MOV [W14+4], W1
004F1C  880211     MOV W1, SR
286:                                *perr                  = OS_ERR_TASK_WAITING;
004F1E  90006E     MOV [W14+12], W0
004F20  B3C491     MOV.B #0x49, W1
004F22  784801     MOV.B W1, [W0]
287:                                pevent_return          = pevent;
004F24  9000CE     MOV [W14+8], W1
004F26  980711     MOV W1, [W14+2]
288:                            }
289:                            break;
004F18  37003D     BRA 0x4F94
004F28  370035     BRA 0x4F94
290:               
291:                       case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
292:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
004F36  000000     NOP
004F38  90004E     MOV [W14+8], W0
004F3A  904060     MOV.B [W0+6], W0
004F3C  E00400     CP0.B W0
004F3E  3AFFF5     BRA NZ, 0x4F2A
293:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
004F2A  B3C023     MOV.B #0x2, W3
004F2C  B3C042     MOV.B #0x4, W2
004F2E  EB0080     CLR W1
004F30  90004E     MOV [W14+8], W0
004F32  07DFDB     RCALL OS_EventTaskRdy
004F34  370001     BRA 0x4F38
294:                            }
295:               #if OS_EVENT_NAME_EN > 0u
296:                            pevent->OSEventName    = (INT8U *)(void *)"?";
004F40  288421     MOV #0x8842, W1
004F42  90004E     MOV [W14+8], W0
004F44  980051     MOV W1, [W0+10]
297:               #endif
298:                            pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
004F46  90004E     MOV [W14+8], W0
004F48  900010     MOV [W0+2], W0
004F4A  980730     MOV W0, [W14+6]
299:                            pq->OSQPtr             = OSQFreeList;
004F4C  804401     MOV OSQFreeList, W1
004F4E  90003E     MOV [W14+6], W0
004F50  780801     MOV W1, [W0]
300:                            OSQFreeList            = pq;
004F52  9000BE     MOV [W14+6], W1
004F54  884401     MOV W1, OSQFreeList
301:                            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
004F56  90004E     MOV [W14+8], W0
004F58  EB4080     CLR.B W1
004F5A  784801     MOV.B W1, [W0]
302:                            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
004F5C  8042A1     MOV OSEventFreeList, W1
004F5E  90004E     MOV [W14+8], W0
004F60  980011     MOV W1, [W0+2]
303:                            pevent->OSEventCnt     = 0u;
004F62  90004E     MOV [W14+8], W0
004F64  EB0080     CLR W1
004F66  980021     MOV W1, [W0+4]
304:                            OSEventFreeList        = pevent;              /* Get next free event control block        */
004F68  9000CE     MOV [W14+8], W1
004F6A  8842A1     MOV W1, OSEventFreeList
305:                            OS_EXIT_CRITICAL();
004F6C  9000AE     MOV [W14+4], W1
004F6E  880211     MOV W1, SR
306:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
004F70  78401E     MOV.B [W14], W0
004F72  504FE1     SUB.B W0, #0x1, [W15]
004F74  3A0001     BRA NZ, 0x4F78
307:                                OS_Sched();                               /* Find highest priority task ready to run  */
004F76  07E1DC     RCALL OS_Sched
308:                            }
309:                            *perr                  = OS_ERR_NONE;
004F78  90006E     MOV [W14+12], W0
004F7A  EB4080     CLR.B W1
004F7C  784801     MOV.B W1, [W0]
310:                            pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
004F7E  EB0000     CLR W0
004F80  980710     MOV W0, [W14+2]
311:                            break;
004F82  370008     BRA 0x4F94
312:               
313:                       default:
314:                            OS_EXIT_CRITICAL();
004F84  9000AE     MOV [W14+4], W1
004F86  880211     MOV W1, SR
315:                            *perr                  = OS_ERR_INVALID_OPT;
004F88  90006E     MOV [W14+12], W0
004F8A  B3C071     MOV.B #0x7, W1
004F8C  784801     MOV.B W1, [W0]
316:                            pevent_return          = pevent;
004F8E  9000CE     MOV [W14+8], W1
004F90  980711     MOV W1, [W14+2]
317:                            break;
004F92  000000     NOP
318:                   }
319:                   return (pevent_return);
004F94  90001E     MOV [W14+2], W0
320:               }
004F96  FA8000     ULNK
004F98  060000     RETURN
321:               #endif
322:               
323:               /*$PAGE*/
324:               /*
325:               *********************************************************************************************************
326:               *                                             FLUSH QUEUE
327:               *
328:               * Description : This function is used to flush the contents of the message queue.
329:               *
330:               * Arguments   : none
331:               *
332:               * Returns     : OS_ERR_NONE         upon success
333:               *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
334:               *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
335:               *
336:               * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
337:               *               the references to what the queue entries are pointing to and thus, you could cause
338:               *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
339:               *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
340:               *********************************************************************************************************
341:               */
342:               
343:               #if OS_Q_FLUSH_EN > 0u
344:               INT8U  OSQFlush (OS_EVENT *pevent)
345:               {
004F9A  FA0006     LNK #0x6
004F9C  980720     MOV W0, [W14+4]
346:                   OS_Q      *pq;
347:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
348:                   OS_CPU_SR  cpu_sr = 0u;
004F9E  EB0000     CLR W0
004FA0  780F00     MOV W0, [W14]
349:               #endif
350:               
351:               
352:               
353:               #if OS_ARG_CHK_EN > 0u
354:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
004FA2  90002E     MOV [W14+4], W0
004FA4  E00000     CP0 W0
004FA6  3A0002     BRA NZ, 0x4FAC
355:                       return (OS_ERR_PEVENT_NULL);
004FA8  B3C040     MOV.B #0x4, W0
004FAA  37001D     BRA 0x4FE6
356:                   }
357:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
004FAC  90002E     MOV [W14+4], W0
004FAE  784010     MOV.B [W0], W0
004FB0  504FE2     SUB.B W0, #0x2, [W15]
004FB2  320002     BRA Z, 0x4FB8
358:                       return (OS_ERR_EVENT_TYPE);
004FB4  B3C010     MOV.B #0x1, W0
004FB6  370017     BRA 0x4FE6
359:                   }
360:               #endif
361:                   OS_ENTER_CRITICAL();
004FB8  800211     MOV SR, W1
004FBA  780F01     MOV W1, [W14]
004FBC  800211     MOV SR, W1
004FBE  200E00     MOV #0xE0, W0
004FC0  700001     IOR W0, W1, W0
004FC2  880210     MOV W0, SR
362:                   pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
004FC4  90002E     MOV [W14+4], W0
004FC6  900010     MOV [W0+2], W0
004FC8  980710     MOV W0, [W14+2]
363:                   pq->OSQIn      = pq->OSQStart;
004FCA  90001E     MOV [W14+2], W0
004FCC  900090     MOV [W0+2], W1
004FCE  90001E     MOV [W14+2], W0
004FD0  980031     MOV W1, [W0+6]
364:                   pq->OSQOut     = pq->OSQStart;
004FD2  90001E     MOV [W14+2], W0
004FD4  900090     MOV [W0+2], W1
004FD6  90001E     MOV [W14+2], W0
004FD8  980041     MOV W1, [W0+8]
365:                   pq->OSQEntries = 0u;
004FDA  90001E     MOV [W14+2], W0
004FDC  EB0080     CLR W1
004FDE  980061     MOV W1, [W0+12]
366:                   OS_EXIT_CRITICAL();
004FE0  78009E     MOV [W14], W1
004FE2  880211     MOV W1, SR
367:                   return (OS_ERR_NONE);
004FE4  EB4000     CLR.B W0
368:               }
004FE6  FA8000     ULNK
004FE8  060000     RETURN
369:               #endif
370:               
371:               /*$PAGE*/
372:               /*
373:               *********************************************************************************************************
374:               *                                    PEND ON A QUEUE FOR A MESSAGE
375:               *
376:               * Description: This function waits for a message to be sent to a queue
377:               *
378:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
379:               *
380:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
381:               *                            wait for a message to arrive at the queue up to the amount of time
382:               *                            specified by this argument.  If you specify 0, however, your task will wait
383:               *                            forever at the specified queue or, until a message arrives.
384:               *
385:               *              perr          is a pointer to where an error message will be deposited.  Possible error
386:               *                            messages are:
387:               *
388:               *                            OS_ERR_NONE         The call was successful and your task received a
389:               *                                                message.
390:               *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
391:               *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
392:               *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
393:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
394:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
395:               *                                                would lead to a suspension.
396:               *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
397:               *
398:               * Returns    : != (void *)0  is a pointer to the message received
399:               *              == (void *)0  if you received a NULL pointer message or,
400:               *                            if no message was received or,
401:               *                            if 'pevent' is a NULL pointer or,
402:               *                            if you didn't pass a pointer to a queue.
403:               *
404:               * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
405:               *********************************************************************************************************
406:               */
407:               
408:               void  *OSQPend (OS_EVENT  *pevent,
409:                               INT32U     timeout,
410:                               INT8U     *perr)
411:               {
004FEA  FA000E     LNK #0xE
004FEC  980730     MOV W0, [W14+6]
004FEE  980742     MOV W2, [W14+8]
004FF0  980753     MOV W3, [W14+10]
004FF2  980761     MOV W1, [W14+12]
412:                   void      *pmsg;
413:                   OS_Q      *pq;
414:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
415:                   OS_CPU_SR  cpu_sr = 0u;
004FF4  EB0000     CLR W0
004FF6  980710     MOV W0, [W14+2]
416:               #endif
417:               
418:               
419:               
420:               #ifdef OS_SAFETY_CRITICAL
421:                   if (perr == (INT8U *)0) {
422:                       OS_SAFETY_CRITICAL_EXCEPTION();
423:                       return ((void *)0);
424:                   }
425:               #endif
426:               
427:               #if OS_ARG_CHK_EN > 0u
428:                   if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
004FF8  90003E     MOV [W14+6], W0
004FFA  E00000     CP0 W0
004FFC  3A0005     BRA NZ, 0x5008
429:                       *perr = OS_ERR_PEVENT_NULL;
004FFE  90006E     MOV [W14+12], W0
005000  B3C041     MOV.B #0x4, W1
005002  784801     MOV.B W1, [W0]
430:                       return ((void *)0);
005004  EB0000     CLR W0
005006  37008A     BRA 0x511C
431:                   }
432:               #endif
433:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
005008  90003E     MOV [W14+6], W0
00500A  784010     MOV.B [W0], W0
00500C  504FE2     SUB.B W0, #0x2, [W15]
00500E  320005     BRA Z, 0x501A
434:                       *perr = OS_ERR_EVENT_TYPE;
005010  90006E     MOV [W14+12], W0
005012  B3C011     MOV.B #0x1, W1
005014  784801     MOV.B W1, [W0]
435:                       return ((void *)0);
005016  EB0000     CLR W0
005018  370081     BRA 0x511C
436:                   }
437:                   if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
00501A  BFC86B     MOV.B OSIntNesting, WREG
00501C  E00400     CP0.B W0
00501E  320005     BRA Z, 0x502A
438:                       *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
005020  90006E     MOV [W14+12], W0
005022  B3C021     MOV.B #0x2, W1
005024  784801     MOV.B W1, [W0]
439:                       return ((void *)0);
005026  EB0000     CLR W0
005028  370079     BRA 0x511C
440:                   }
441:                   if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00502A  BFC86C     MOV.B OSLockNesting, WREG
00502C  E00400     CP0.B W0
00502E  320005     BRA Z, 0x503A
442:                       *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
005030  90006E     MOV [W14+12], W0
005032  B3C0D1     MOV.B #0xD, W1
005034  784801     MOV.B W1, [W0]
443:                       return ((void *)0);
005036  EB0000     CLR W0
005038  370071     BRA 0x511C
444:                   }
445:                   OS_ENTER_CRITICAL();
00503A  800211     MOV SR, W1
00503C  980711     MOV W1, [W14+2]
00503E  800211     MOV SR, W1
005040  200E00     MOV #0xE0, W0
005042  700001     IOR W0, W1, W0
005044  880210     MOV W0, SR
446:                   pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
005046  90003E     MOV [W14+6], W0
005048  900010     MOV [W0+2], W0
00504A  980720     MOV W0, [W14+4]
447:                   if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00504C  90002E     MOV [W14+4], W0
00504E  900060     MOV [W0+12], W0
005050  E00000     CP0 W0
005052  32001C     BRA Z, 0x508C
448:                       pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
005054  90002E     MOV [W14+4], W0
005056  900040     MOV [W0+8], W0
005058  780F10     MOV [W0], [W14]
00505A  E88080     INC2 W0, W1
00505C  90002E     MOV [W14+4], W0
00505E  980041     MOV W1, [W0+8]
449:                       pq->OSQEntries--;                        /* Update the number of entries in the queue          */
005060  90002E     MOV [W14+4], W0
005062  900060     MOV [W0+12], W0
005064  E90080     DEC W0, W1
005066  90002E     MOV [W14+4], W0
005068  980061     MOV W1, [W0+12]
450:                       if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00506A  90002E     MOV [W14+4], W0
00506C  9000C0     MOV [W0+8], W1
00506E  90002E     MOV [W14+4], W0
005070  900020     MOV [W0+4], W0
005072  508F80     SUB W1, W0, [W15]
005074  3A0004     BRA NZ, 0x507E
451:                           pq->OSQOut = pq->OSQStart;
005076  90002E     MOV [W14+4], W0
005078  900090     MOV [W0+2], W1
00507A  90002E     MOV [W14+4], W0
00507C  980041     MOV W1, [W0+8]
452:                       }
453:                       OS_EXIT_CRITICAL();
00507E  90011E     MOV [W14+2], W2
005080  880212     MOV W2, SR
454:                       *perr = OS_ERR_NONE;
005082  90006E     MOV [W14+12], W0
005084  EB4080     CLR.B W1
005086  784801     MOV.B W1, [W0]
455:                       return (pmsg);                           /* Return message received                            */
005088  78001E     MOV [W14], W0
00508A  370048     BRA 0x511C
456:                   }
457:                   OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
00508C  8043B0     MOV OSTCBCur, W0
00508E  8043B1     MOV OSTCBCur, W1
005090  906081     MOV.B [W1+32], W1
005092  A02401     BSET.B W1, #2
005094  986001     MOV.B W1, [W0+32]
458:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
005096  8043B0     MOV OSTCBCur, W0
005098  EB4080     CLR.B W1
00509A  986011     MOV.B W1, [W0+33]
459:                   OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
00509C  8043B0     MOV OSTCBCur, W0
00509E  90014E     MOV [W14+8], W2
0050A0  9001DE     MOV [W14+10], W3
0050A2  980862     MOV W2, [W0+28]
0050A4  980873     MOV W3, [W0+30]
460:                   OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
0050A6  90003E     MOV [W14+6], W0
0050A8  07DF77     RCALL OS_EventTaskWait
461:                   OS_EXIT_CRITICAL();
0050AA  90019E     MOV [W14+2], W3
0050AC  880213     MOV W3, SR
462:                   OS_Sched();                                  /* Find next highest priority task ready to run       */
0050AE  07E140     RCALL OS_Sched
463:                   OS_ENTER_CRITICAL();
0050B0  800211     MOV SR, W1
0050B2  980711     MOV W1, [W14+2]
0050B4  800211     MOV SR, W1
0050B6  200E00     MOV #0xE0, W0
0050B8  700001     IOR W0, W1, W0
0050BA  880210     MOV W0, SR
464:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
0050BC  8043B0     MOV OSTCBCur, W0
0050BE  906010     MOV.B [W0+33], W0
0050C0  FB8000     ZE W0, W0
0050C2  E00000     CP0 W0
0050C4  320003     BRA Z, 0x50CC
0050C6  500FE2     SUB W0, #0x2, [W15]
0050C8  320008     BRA Z, 0x50DA
0050CA  37000D     BRA 0x50E6
465:                       case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
466:                            pmsg =  OSTCBCur->OSTCBMsg;
0050CC  8043B0     MOV OSTCBCur, W0
0050CE  900930     MOV [W0+22], W2
0050D0  780F02     MOV W2, [W14]
467:                           *perr =  OS_ERR_NONE;
0050D2  90006E     MOV [W14+12], W0
0050D4  EB4080     CLR.B W1
0050D6  784801     MOV.B W1, [W0]
468:                            break;
0050D8  37000F     BRA 0x50F8
469:               
470:                       case OS_STAT_PEND_ABORT:
471:                            pmsg = (void *)0;
0050DA  EB0000     CLR W0
0050DC  780F00     MOV W0, [W14]
472:                           *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
0050DE  90006E     MOV [W14+12], W0
0050E0  B3C0E1     MOV.B #0xE, W1
0050E2  784801     MOV.B W1, [W0]
473:                            break;
0050E4  370009     BRA 0x50F8
474:               
475:                       case OS_STAT_PEND_TO:
476:                       default:
477:                            OS_EventTaskRemove(OSTCBCur, pevent);
0050E6  8043B0     MOV OSTCBCur, W0
0050E8  9000BE     MOV [W14+6], W1
0050EA  07DFD5     RCALL OS_EventTaskRemove
478:                            pmsg = (void *)0;
0050EC  EB0000     CLR W0
0050EE  780F00     MOV W0, [W14]
479:                           *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
0050F0  90006E     MOV [W14+12], W0
0050F2  B3C0A1     MOV.B #0xA, W1
0050F4  784801     MOV.B W1, [W0]
480:                            break;
0050F6  000000     NOP
481:                   }
482:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0050F8  8043B0     MOV OSTCBCur, W0
0050FA  EB4080     CLR.B W1
0050FC  986001     MOV.B W1, [W0+32]
483:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0050FE  8043B0     MOV OSTCBCur, W0
005100  EB4080     CLR.B W1
005102  986011     MOV.B W1, [W0+33]
484:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
005104  8043B0     MOV OSTCBCur, W0
005106  EB0080     CLR W1
005108  980811     MOV W1, [W0+18]
485:               #if (OS_EVENT_MULTI_EN > 0u)
486:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00510A  8043B0     MOV OSTCBCur, W0
00510C  EB0080     CLR W1
00510E  980821     MOV W1, [W0+20]
487:               #endif
488:                   OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
005110  8043B0     MOV OSTCBCur, W0
005112  EB0080     CLR W1
005114  980831     MOV W1, [W0+22]
489:                   OS_EXIT_CRITICAL();
005116  90019E     MOV [W14+2], W3
005118  880213     MOV W3, SR
490:                   return (pmsg);                                    /* Return received message                       */
00511A  78001E     MOV [W14], W0
491:               }
00511C  FA8000     ULNK
00511E  060000     RETURN
492:               /*$PAGE*/
493:               /*
494:               *********************************************************************************************************
495:               *                                  ABORT WAITING ON A MESSAGE QUEUE
496:               *
497:               * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
498:               *              should be used to fault-abort the wait on the queue, rather than to normally signal
499:               *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
500:               *
501:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
502:               *
503:               *              opt           determines the type of ABORT performed:
504:               *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
505:               *                                                     queue
506:               *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
507:               *                                                     queue
508:               *
509:               *              perr          is a pointer to where an error message will be deposited.  Possible error
510:               *                            messages are:
511:               *
512:               *                            OS_ERR_NONE         No tasks were     waiting on the queue.
513:               *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
514:               *                                                and informed of the aborted wait; check return value
515:               *                                                for the number of tasks whose wait on the queue
516:               *                                                was aborted.
517:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
518:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
519:               *
520:               * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
521:               *              >  0          if one or more tasks waiting on the queue are now readied and informed.
522:               *********************************************************************************************************
523:               */
524:               
525:               #if OS_Q_PEND_ABORT_EN > 0u
526:               INT8U  OSQPendAbort (OS_EVENT  *pevent,
527:                                    INT8U      opt,
528:                                    INT8U     *perr)
529:               {
005120  FA000A     LNK #0xA
005122  980720     MOV W0, [W14+4]
005124  984761     MOV.B W1, [W14+6]
005126  980742     MOV W2, [W14+8]
530:                   INT8U      nbr_tasks;
531:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
532:                   OS_CPU_SR  cpu_sr = 0u;
005128  EB0000     CLR W0
00512A  980710     MOV W0, [W14+2]
533:               #endif
534:               
535:               
536:               
537:               #ifdef OS_SAFETY_CRITICAL
538:                   if (perr == (INT8U *)0) {
539:                       OS_SAFETY_CRITICAL_EXCEPTION();
540:                       return (0u);
541:                   }
542:               #endif
543:               
544:               #if OS_ARG_CHK_EN > 0u
545:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
00512C  90002E     MOV [W14+4], W0
00512E  E00000     CP0 W0
005130  3A0005     BRA NZ, 0x513C
546:                       *perr = OS_ERR_PEVENT_NULL;
005132  90004E     MOV [W14+8], W0
005134  B3C041     MOV.B #0x4, W1
005136  784801     MOV.B W1, [W0]
547:                       return (0u);
005138  EB4000     CLR.B W0
00513A  37003C     BRA 0x51B4
548:                   }
549:               #endif
550:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
00513C  90002E     MOV [W14+4], W0
00513E  784010     MOV.B [W0], W0
005140  504FE2     SUB.B W0, #0x2, [W15]
005142  320005     BRA Z, 0x514E
551:                       *perr = OS_ERR_EVENT_TYPE;
005144  90004E     MOV [W14+8], W0
005146  B3C011     MOV.B #0x1, W1
005148  784801     MOV.B W1, [W0]
552:                       return (0u);
00514A  EB4000     CLR.B W0
00514C  370033     BRA 0x51B4
553:                   }
554:                   OS_ENTER_CRITICAL();
00514E  800211     MOV SR, W1
005150  980711     MOV W1, [W14+2]
005152  800211     MOV SR, W1
005154  200E00     MOV #0xE0, W0
005156  700001     IOR W0, W1, W0
005158  880210     MOV W0, SR
555:                   if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00515A  90002E     MOV [W14+4], W0
00515C  904060     MOV.B [W0+6], W0
00515E  E00400     CP0.B W0
005160  320023     BRA Z, 0x51A8
556:                       nbr_tasks = 0u;
005162  EB4000     CLR.B W0
005164  784F00     MOV.B W0, [W14]
557:                       switch (opt) {
005166  90406E     MOV.B [W14+6], W0
005168  FB8000     ZE W0, W0
00516A  500FE1     SUB W0, #0x1, [W15]
00516C  320008     BRA Z, 0x517E
00516E  37000D     BRA 0x518A
558:                           case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
559:                                while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
00517E  000000     NOP
005180  90002E     MOV [W14+4], W0
005182  904060     MOV.B [W0+6], W0
005184  E00400     CP0.B W0
005186  3AFFF4     BRA NZ, 0x5170
560:                                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
005170  B3C023     MOV.B #0x2, W3
005172  B3C042     MOV.B #0x4, W2
005174  EB0080     CLR W1
005176  90002E     MOV [W14+4], W0
005178  07DEB8     RCALL OS_EventTaskRdy
561:                                    nbr_tasks++;
00517A  E84F1E     INC.B [W14], [W14]
00517C  370001     BRA 0x5180
562:                                }
563:                                break;
005188  370007     BRA 0x5198
564:               
565:                           case OS_PEND_OPT_NONE:
566:                           default:                                       /* No,  ready HPT       waiting on queue    */
567:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
00518A  B3C023     MOV.B #0x2, W3
00518C  B3C042     MOV.B #0x4, W2
00518E  EB0080     CLR W1
005190  90002E     MOV [W14+4], W0
005192  07DEAB     RCALL OS_EventTaskRdy
568:                                nbr_tasks++;
005194  E84F1E     INC.B [W14], [W14]
569:                                break;
005196  000000     NOP
570:                       }
571:                       OS_EXIT_CRITICAL();
005198  90009E     MOV [W14+2], W1
00519A  880211     MOV W1, SR
572:                       OS_Sched();                                        /* Find HPT ready to run                    */
00519C  07E0C9     RCALL OS_Sched
573:                       *perr = OS_ERR_PEND_ABORT;
00519E  90004E     MOV [W14+8], W0
0051A0  B3C0E1     MOV.B #0xE, W1
0051A2  784801     MOV.B W1, [W0]
574:                       return (nbr_tasks);
0051A4  78401E     MOV.B [W14], W0
0051A6  370006     BRA 0x51B4
575:                   }
576:                   OS_EXIT_CRITICAL();
0051A8  90009E     MOV [W14+2], W1
0051AA  880211     MOV W1, SR
577:                   *perr = OS_ERR_NONE;
0051AC  90004E     MOV [W14+8], W0
0051AE  EB4080     CLR.B W1
0051B0  784801     MOV.B W1, [W0]
578:                   return (0u);                                           /* No tasks waiting on queue                */
0051B2  EB4000     CLR.B W0
579:               }
0051B4  FA8000     ULNK
0051B6  060000     RETURN
580:               #endif
581:               
582:               /*$PAGE*/
583:               /*
584:               *********************************************************************************************************
585:               *                                       POST MESSAGE TO A QUEUE
586:               *
587:               * Description: This function sends a message to a queue
588:               *
589:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
590:               *
591:               *              pmsg          is a pointer to the message to send.
592:               *
593:               * Returns    : OS_ERR_NONE           The call was successful and the message was sent
594:               *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
595:               *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
596:               *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
597:               *
598:               * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
599:               *********************************************************************************************************
600:               */
601:               
602:               #if OS_Q_POST_EN > 0u
603:               INT8U  OSQPost (OS_EVENT  *pevent,
604:                               void      *pmsg)
605:               {
0051B8  FA0008     LNK #0x8
0051BA  980720     MOV W0, [W14+4]
0051BC  980731     MOV W1, [W14+6]
606:                   OS_Q      *pq;
607:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
608:                   OS_CPU_SR  cpu_sr = 0u;
0051BE  EB0000     CLR W0
0051C0  780F00     MOV W0, [W14]
609:               #endif
610:               
611:               
612:               
613:               #if OS_ARG_CHK_EN > 0u
614:                   if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
0051C2  90002E     MOV [W14+4], W0
0051C4  E00000     CP0 W0
0051C6  3A0002     BRA NZ, 0x51CC
615:                       return (OS_ERR_PEVENT_NULL);
0051C8  B3C040     MOV.B #0x4, W0
0051CA  370040     BRA 0x524C
616:                   }
617:               #endif
618:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
0051CC  90002E     MOV [W14+4], W0
0051CE  784010     MOV.B [W0], W0
0051D0  504FE2     SUB.B W0, #0x2, [W15]
0051D2  320002     BRA Z, 0x51D8
619:                       return (OS_ERR_EVENT_TYPE);
0051D4  B3C010     MOV.B #0x1, W0
0051D6  37003A     BRA 0x524C
620:                   }
621:                   OS_ENTER_CRITICAL();
0051D8  800211     MOV SR, W1
0051DA  780F01     MOV W1, [W14]
0051DC  800211     MOV SR, W1
0051DE  200E00     MOV #0xE0, W0
0051E0  700001     IOR W0, W1, W0
0051E2  880210     MOV W0, SR
622:                   if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
0051E4  90002E     MOV [W14+4], W0
0051E6  904060     MOV.B [W0+6], W0
0051E8  E00400     CP0.B W0
0051EA  32000A     BRA Z, 0x5200
623:                                                                      /* Ready highest priority task waiting on event */
624:                       (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
0051EC  EB4180     CLR.B W3
0051EE  B3C042     MOV.B #0x4, W2
0051F0  9000BE     MOV [W14+6], W1
0051F2  90002E     MOV [W14+4], W0
0051F4  07DE7A     RCALL OS_EventTaskRdy
625:                       OS_EXIT_CRITICAL();
0051F6  78009E     MOV [W14], W1
0051F8  880211     MOV W1, SR
626:                       OS_Sched();                                    /* Find highest priority task ready to run      */
0051FA  07E09A     RCALL OS_Sched
627:                       return (OS_ERR_NONE);
0051FC  EB4000     CLR.B W0
0051FE  370026     BRA 0x524C
628:                   }
629:                   pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
005200  90002E     MOV [W14+4], W0
005202  900010     MOV [W0+2], W0
005204  980710     MOV W0, [W14+2]
630:                   if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
005206  90001E     MOV [W14+2], W0
005208  9000E0     MOV [W0+12], W1
00520A  90001E     MOV [W14+2], W0
00520C  900050     MOV [W0+10], W0
00520E  508F80     SUB W1, W0, [W15]
005210  390004     BRA NC, 0x521A
631:                       OS_EXIT_CRITICAL();
005212  78009E     MOV [W14], W1
005214  880211     MOV W1, SR
632:                       return (OS_ERR_Q_FULL);
005216  B3C1E0     MOV.B #0x1E, W0
005218  370019     BRA 0x524C
633:                   }
634:                   *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00521A  90001E     MOV [W14+2], W0
00521C  900030     MOV [W0+6], W0
00521E  9000BE     MOV [W14+6], W1
005220  780801     MOV W1, [W0]
005222  E88080     INC2 W0, W1
005224  90001E     MOV [W14+2], W0
005226  980031     MOV W1, [W0+6]
635:                   pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
005228  90001E     MOV [W14+2], W0
00522A  900060     MOV [W0+12], W0
00522C  E80080     INC W0, W1
00522E  90001E     MOV [W14+2], W0
005230  980061     MOV W1, [W0+12]
636:                   if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
005232  90001E     MOV [W14+2], W0
005234  9000B0     MOV [W0+6], W1
005236  90001E     MOV [W14+2], W0
005238  900020     MOV [W0+4], W0
00523A  508F80     SUB W1, W0, [W15]
00523C  3A0004     BRA NZ, 0x5246
637:                       pq->OSQIn = pq->OSQStart;
00523E  90001E     MOV [W14+2], W0
005240  900090     MOV [W0+2], W1
005242  90001E     MOV [W14+2], W0
005244  980031     MOV W1, [W0+6]
638:                   }
639:                   OS_EXIT_CRITICAL();
005246  78009E     MOV [W14], W1
005248  880211     MOV W1, SR
640:                   return (OS_ERR_NONE);
00524A  EB4000     CLR.B W0
641:               }
00524C  FA8000     ULNK
00524E  060000     RETURN
642:               #endif
643:               /*$PAGE*/
644:               /*
645:               *********************************************************************************************************
646:               *                                POST MESSAGE TO THE FRONT OF A QUEUE
647:               *
648:               * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
649:               *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
650:               *              'priority' messages.
651:               *
652:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
653:               *
654:               *              pmsg          is a pointer to the message to send.
655:               *
656:               * Returns    : OS_ERR_NONE           The call was successful and the message was sent
657:               *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
658:               *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
659:               *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
660:               *
661:               * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
662:               *********************************************************************************************************
663:               */
664:               
665:               #if OS_Q_POST_FRONT_EN > 0u
666:               INT8U  OSQPostFront (OS_EVENT  *pevent,
667:                                    void      *pmsg)
668:               {
005250  FA0008     LNK #0x8
005252  980720     MOV W0, [W14+4]
005254  980731     MOV W1, [W14+6]
669:                   OS_Q      *pq;
670:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
671:                   OS_CPU_SR  cpu_sr = 0u;
005256  EB0000     CLR W0
005258  780F00     MOV W0, [W14]
672:               #endif
673:               
674:               
675:               
676:               #if OS_ARG_CHK_EN > 0u
677:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00525A  90002E     MOV [W14+4], W0
00525C  E00000     CP0 W0
00525E  3A0002     BRA NZ, 0x5264
678:                       return (OS_ERR_PEVENT_NULL);
005260  B3C040     MOV.B #0x4, W0
005262  370042     BRA 0x52E8
679:                   }
680:               #endif
681:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
005264  90002E     MOV [W14+4], W0
005266  784010     MOV.B [W0], W0
005268  504FE2     SUB.B W0, #0x2, [W15]
00526A  320002     BRA Z, 0x5270
682:                       return (OS_ERR_EVENT_TYPE);
00526C  B3C010     MOV.B #0x1, W0
00526E  37003C     BRA 0x52E8
683:                   }
684:                   OS_ENTER_CRITICAL();
005270  800211     MOV SR, W1
005272  780F01     MOV W1, [W14]
005274  800211     MOV SR, W1
005276  200E00     MOV #0xE0, W0
005278  700001     IOR W0, W1, W0
00527A  880210     MOV W0, SR
685:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
00527C  90002E     MOV [W14+4], W0
00527E  904060     MOV.B [W0+6], W0
005280  E00400     CP0.B W0
005282  32000A     BRA Z, 0x5298
686:                                                                     /* Ready highest priority task waiting on event  */
687:                       (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
005284  EB4180     CLR.B W3
005286  B3C042     MOV.B #0x4, W2
005288  9000BE     MOV [W14+6], W1
00528A  90002E     MOV [W14+4], W0
00528C  07DE2E     RCALL OS_EventTaskRdy
688:                       OS_EXIT_CRITICAL();
00528E  78009E     MOV [W14], W1
005290  880211     MOV W1, SR
689:                       OS_Sched();                                   /* Find highest priority task ready to run       */
005292  07E04E     RCALL OS_Sched
690:                       return (OS_ERR_NONE);
005294  EB4000     CLR.B W0
005296  370028     BRA 0x52E8
691:                   }
692:                   pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
005298  90002E     MOV [W14+4], W0
00529A  900010     MOV [W0+2], W0
00529C  980710     MOV W0, [W14+2]
693:                   if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00529E  90001E     MOV [W14+2], W0
0052A0  9000E0     MOV [W0+12], W1
0052A2  90001E     MOV [W14+2], W0
0052A4  900050     MOV [W0+10], W0
0052A6  508F80     SUB W1, W0, [W15]
0052A8  390004     BRA NC, 0x52B2
694:                       OS_EXIT_CRITICAL();
0052AA  78009E     MOV [W14], W1
0052AC  880211     MOV W1, SR
695:                       return (OS_ERR_Q_FULL);
0052AE  B3C1E0     MOV.B #0x1E, W0
0052B0  37001B     BRA 0x52E8
696:                   }
697:                   if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
0052B2  90001E     MOV [W14+2], W0
0052B4  9000C0     MOV [W0+8], W1
0052B6  90001E     MOV [W14+2], W0
0052B8  900010     MOV [W0+2], W0
0052BA  508F80     SUB W1, W0, [W15]
0052BC  3A0004     BRA NZ, 0x52C6
698:                       pq->OSQOut = pq->OSQEnd;
0052BE  90001E     MOV [W14+2], W0
0052C0  9000A0     MOV [W0+4], W1
0052C2  90001E     MOV [W14+2], W0
0052C4  980041     MOV W1, [W0+8]
699:                   }
700:                   pq->OSQOut--;
0052C6  90001E     MOV [W14+2], W0
0052C8  900040     MOV [W0+8], W0
0052CA  E98080     DEC2 W0, W1
0052CC  90001E     MOV [W14+2], W0
0052CE  980041     MOV W1, [W0+8]
701:                   *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
0052D0  90001E     MOV [W14+2], W0
0052D2  900040     MOV [W0+8], W0
0052D4  9000BE     MOV [W14+6], W1
0052D6  780801     MOV W1, [W0]
702:                   pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
0052D8  90001E     MOV [W14+2], W0
0052DA  900060     MOV [W0+12], W0
0052DC  E80080     INC W0, W1
0052DE  90001E     MOV [W14+2], W0
0052E0  980061     MOV W1, [W0+12]
703:                   OS_EXIT_CRITICAL();
0052E2  78009E     MOV [W14], W1
0052E4  880211     MOV W1, SR
704:                   return (OS_ERR_NONE);
0052E6  EB4000     CLR.B W0
705:               }
0052E8  FA8000     ULNK
0052EA  060000     RETURN
706:               #endif
707:               /*$PAGE*/
708:               /*
709:               *********************************************************************************************************
710:               *                                       POST MESSAGE TO A QUEUE
711:               *
712:               * Description: This function sends a message to a queue.  This call has been added to reduce code size
713:               *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
714:               *              capability to broadcast a message to ALL tasks waiting on the message queue.
715:               *
716:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
717:               *
718:               *              pmsg          is a pointer to the message to send.
719:               *
720:               *              opt           determines the type of POST performed:
721:               *                            OS_POST_OPT_NONE         POST to a single waiting task
722:               *                                                     (Identical to OSQPost())
723:               *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
724:               *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
725:               *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
726:               *
727:               * Returns    : OS_ERR_NONE           The call was successful and the message was sent
728:               *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
729:               *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
730:               *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
731:               *
732:               * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
733:               *              interrupt disable time is proportional to the number of tasks waiting on the queue.
734:               *********************************************************************************************************
735:               */
736:               
737:               #if OS_Q_POST_OPT_EN > 0u
738:               INT8U  OSQPostOpt (OS_EVENT  *pevent,
739:                                  void      *pmsg,
740:                                  INT8U      opt)
741:               {
0052EC  FA000A     LNK #0xA
0052EE  980720     MOV W0, [W14+4]
0052F0  980731     MOV W1, [W14+6]
0052F2  984F02     MOV.B W2, [W14+8]
742:                   OS_Q      *pq;
743:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
744:                   OS_CPU_SR  cpu_sr = 0u;
0052F4  EB0000     CLR W0
0052F6  780F00     MOV W0, [W14]
745:               #endif
746:               
747:               
748:               
749:               #if OS_ARG_CHK_EN > 0u
750:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0052F8  90002E     MOV [W14+4], W0
0052FA  E00000     CP0 W0
0052FC  3A0002     BRA NZ, 0x5302
751:                       return (OS_ERR_PEVENT_NULL);
0052FE  B3C040     MOV.B #0x4, W0
005300  37006F     BRA 0x53E0
752:                   }
753:               #endif
754:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
005302  90002E     MOV [W14+4], W0
005304  784010     MOV.B [W0], W0
005306  504FE2     SUB.B W0, #0x2, [W15]
005308  320002     BRA Z, 0x530E
755:                       return (OS_ERR_EVENT_TYPE);
00530A  B3C010     MOV.B #0x1, W0
00530C  370069     BRA 0x53E0
756:                   }
757:                   OS_ENTER_CRITICAL();
00530E  800211     MOV SR, W1
005310  780F01     MOV W1, [W14]
005312  800211     MOV SR, W1
005314  200E00     MOV #0xE0, W0
005316  700001     IOR W0, W1, W0
005318  880210     MOV W0, SR
758:                   if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00531A  90002E     MOV [W14+4], W0
00531C  904060     MOV.B [W0+6], W0
00531E  E00400     CP0.B W0
005320  320020     BRA Z, 0x5362
759:                       if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
005322  90480E     MOV.B [W14+8], W0
005324  FB8000     ZE W0, W0
005326  600061     AND W0, #0x1, W0
005328  784000     MOV.B W0, W0
00532A  E00400     CP0.B W0
00532C  32000B     BRA Z, 0x5344
760:                           while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
00532E  370005     BRA 0x533A
00533A  90002E     MOV [W14+4], W0
00533C  904060     MOV.B [W0+6], W0
00533E  E00400     CP0.B W0
005340  3AFFF7     BRA NZ, 0x5330
005342  370005     BRA 0x534E
761:                               (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
005330  EB4180     CLR.B W3
005332  B3C042     MOV.B #0x4, W2
005334  9000BE     MOV [W14+6], W1
005336  90002E     MOV [W14+4], W0
005338  07DDD8     RCALL OS_EventTaskRdy
762:                           }
763:                       } else {                                      /* No,  Post to HPT waiting on queue             */
764:                           (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
005344  EB4180     CLR.B W3
005346  B3C042     MOV.B #0x4, W2
005348  9000BE     MOV [W14+6], W1
00534A  90002E     MOV [W14+4], W0
00534C  07DDCE     RCALL OS_EventTaskRdy
765:                       }
766:                       OS_EXIT_CRITICAL();
00534E  78009E     MOV [W14], W1
005350  880211     MOV W1, SR
767:                       if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
005352  90480E     MOV.B [W14+8], W0
005354  FB8000     ZE W0, W0
005356  600064     AND W0, #0x4, W0
005358  E00000     CP0 W0
00535A  3A0001     BRA NZ, 0x535E
768:                           OS_Sched();                               /* Find highest priority task ready to run       */
00535C  07DFE9     RCALL OS_Sched
769:                       }
770:                       return (OS_ERR_NONE);
00535E  EB4000     CLR.B W0
005360  37003F     BRA 0x53E0
771:                   }
772:                   pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
005362  90002E     MOV [W14+4], W0
005364  900010     MOV [W0+2], W0
005366  980710     MOV W0, [W14+2]
773:                   if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
005368  90001E     MOV [W14+2], W0
00536A  9000E0     MOV [W0+12], W1
00536C  90001E     MOV [W14+2], W0
00536E  900050     MOV [W0+10], W0
005370  508F80     SUB W1, W0, [W15]
005372  390004     BRA NC, 0x537C
774:                       OS_EXIT_CRITICAL();
005374  78009E     MOV [W14], W1
005376  880211     MOV W1, SR
775:                       return (OS_ERR_Q_FULL);
005378  B3C1E0     MOV.B #0x1E, W0
00537A  370032     BRA 0x53E0
776:                   }
777:                   if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00537C  90480E     MOV.B [W14+8], W0
00537E  FB8000     ZE W0, W0
005380  600062     AND W0, #0x2, W0
005382  E00000     CP0 W0
005384  320014     BRA Z, 0x53AE
778:                       if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
005386  90001E     MOV [W14+2], W0
005388  9000C0     MOV [W0+8], W1
00538A  90001E     MOV [W14+2], W0
00538C  900010     MOV [W0+2], W0
00538E  508F80     SUB W1, W0, [W15]
005390  3A0004     BRA NZ, 0x539A
779:                           pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
005392  90001E     MOV [W14+2], W0
005394  9000A0     MOV [W0+4], W1
005396  90001E     MOV [W14+2], W0
005398  980041     MOV W1, [W0+8]
780:                       }
781:                       pq->OSQOut--;
00539A  90001E     MOV [W14+2], W0
00539C  900040     MOV [W0+8], W0
00539E  E98080     DEC2 W0, W1
0053A0  90001E     MOV [W14+2], W0
0053A2  980041     MOV W1, [W0+8]
782:                       *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
0053A4  90001E     MOV [W14+2], W0
0053A6  900040     MOV [W0+8], W0
0053A8  9000BE     MOV [W14+6], W1
0053AA  780801     MOV W1, [W0]
0053AC  370011     BRA 0x53D0
783:                   } else {                                          /* No,  Post as FIFO                             */
784:                       *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
0053AE  90001E     MOV [W14+2], W0
0053B0  900030     MOV [W0+6], W0
0053B2  9000BE     MOV [W14+6], W1
0053B4  780801     MOV W1, [W0]
0053B6  E88080     INC2 W0, W1
0053B8  90001E     MOV [W14+2], W0
0053BA  980031     MOV W1, [W0+6]
785:                       if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
0053BC  90001E     MOV [W14+2], W0
0053BE  9000B0     MOV [W0+6], W1
0053C0  90001E     MOV [W14+2], W0
0053C2  900020     MOV [W0+4], W0
0053C4  508F80     SUB W1, W0, [W15]
0053C6  3A0004     BRA NZ, 0x53D0
786:                           pq->OSQIn = pq->OSQStart;
0053C8  90001E     MOV [W14+2], W0
0053CA  900090     MOV [W0+2], W1
0053CC  90001E     MOV [W14+2], W0
0053CE  980031     MOV W1, [W0+6]
787:                       }
788:                   }
789:                   pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
0053D0  90001E     MOV [W14+2], W0
0053D2  900060     MOV [W0+12], W0
0053D4  E80080     INC W0, W1
0053D6  90001E     MOV [W14+2], W0
0053D8  980061     MOV W1, [W0+12]
790:                   OS_EXIT_CRITICAL();
0053DA  78009E     MOV [W14], W1
0053DC  880211     MOV W1, SR
791:                   return (OS_ERR_NONE);
0053DE  EB4000     CLR.B W0
792:               }
0053E0  FA8000     ULNK
0053E2  060000     RETURN
793:               #endif
794:               /*$PAGE*/
795:               /*
796:               *********************************************************************************************************
797:               *                                        QUERY A MESSAGE QUEUE
798:               *
799:               * Description: This function obtains information about a message queue.
800:               *
801:               * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
802:               *
803:               *              p_q_data      is a pointer to a structure that will contain information about the message
804:               *                            queue.
805:               *
806:               * Returns    : OS_ERR_NONE         The call was successful and the message was sent
807:               *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
808:               *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
809:               *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
810:               *********************************************************************************************************
811:               */
812:               
813:               #if OS_Q_QUERY_EN > 0u
814:               INT8U  OSQQuery (OS_EVENT  *pevent,
815:                                OS_Q_DATA *p_q_data)
816:               {
0053E4  FA000E     LNK #0xE
0053E6  980750     MOV W0, [W14+10]
0053E8  980761     MOV W1, [W14+12]
817:                   OS_Q       *pq;
818:                   INT8U       i;
819:                   OS_PRIO    *psrc;
820:                   OS_PRIO    *pdest;
821:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
822:                   OS_CPU_SR   cpu_sr = 0u;
0053EA  EB0000     CLR W0
0053EC  980730     MOV W0, [W14+6]
823:               #endif
824:               
825:               
826:               
827:               #if OS_ARG_CHK_EN > 0u
828:                   if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
0053EE  90005E     MOV [W14+10], W0
0053F0  E00000     CP0 W0
0053F2  3A0002     BRA NZ, 0x53F8
829:                       return (OS_ERR_PEVENT_NULL);
0053F4  B3C040     MOV.B #0x4, W0
0053F6  370047     BRA 0x5486
830:                   }
831:                   if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
0053F8  90006E     MOV [W14+12], W0
0053FA  E00000     CP0 W0
0053FC  3A0002     BRA NZ, 0x5402
832:                       return (OS_ERR_PDATA_NULL);
0053FE  B3C090     MOV.B #0x9, W0
005400  370042     BRA 0x5486
833:                   }
834:               #endif
835:                   if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
005402  90005E     MOV [W14+10], W0
005404  784010     MOV.B [W0], W0
005406  504FE2     SUB.B W0, #0x2, [W15]
005408  320002     BRA Z, 0x540E
836:                       return (OS_ERR_EVENT_TYPE);
00540A  B3C010     MOV.B #0x1, W0
00540C  37003C     BRA 0x5486
837:                   }
838:                   OS_ENTER_CRITICAL();
00540E  800211     MOV SR, W1
005410  980731     MOV W1, [W14+6]
005412  800211     MOV SR, W1
005414  200E00     MOV #0xE0, W0
005416  700001     IOR W0, W1, W0
005418  880210     MOV W0, SR
839:                   p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00541A  90005E     MOV [W14+10], W0
00541C  9040E0     MOV.B [W0+6], W1
00541E  90006E     MOV [W14+12], W0
005420  984801     MOV.B W1, [W0+8]
840:                   psrc                 = &pevent->OSEventTbl[0];
005422  90005E     MOV [W14+10], W0
005424  400067     ADD W0, #0x7, W0
005426  980710     MOV W0, [W14+2]
841:                   pdest                = &p_q_data->OSEventTbl[0];
005428  90006E     MOV [W14+12], W0
00542A  400066     ADD W0, #0x6, W0
00542C  980720     MOV W0, [W14+4]
842:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00542E  EB4000     CLR.B W0
005430  784F00     MOV.B W0, [W14]
005432  37000B     BRA 0x544A
005448  E84F1E     INC.B [W14], [W14]
00544A  78401E     MOV.B [W14], W0
00544C  504FE1     SUB.B W0, #0x1, [W15]
00544E  36FFF2     BRA LEU, 0x5434
843:                       *pdest++ = *psrc++;
005434  90001E     MOV [W14+2], W0
005436  784090     MOV.B [W0], W1
005438  90002E     MOV [W14+4], W0
00543A  784801     MOV.B W1, [W0]
00543C  90002E     MOV [W14+4], W0
00543E  E80000     INC W0, W0
005440  980720     MOV W0, [W14+4]
005442  90001E     MOV [W14+2], W0
005444  E80000     INC W0, W0
005446  980710     MOV W0, [W14+2]
844:                   }
845:                   pq = (OS_Q *)pevent->OSEventPtr;
005450  90005E     MOV [W14+10], W0
005452  900010     MOV [W0+2], W0
005454  980740     MOV W0, [W14+8]
846:                   if (pq->OSQEntries > 0u) {
005456  90004E     MOV [W14+8], W0
005458  900060     MOV [W0+12], W0
00545A  E00000     CP0 W0
00545C  320006     BRA Z, 0x546A
847:                       p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00545E  90004E     MOV [W14+8], W0
005460  900040     MOV [W0+8], W0
005462  780090     MOV [W0], W1
005464  90006E     MOV [W14+12], W0
005466  780801     MOV W1, [W0]
005468  370003     BRA 0x5470
848:                   } else {
849:                       p_q_data->OSMsg = (void *)0;
00546A  90006E     MOV [W14+12], W0
00546C  EB0080     CLR W1
00546E  780801     MOV W1, [W0]
850:                   }
851:                   p_q_data->OSNMsgs = pq->OSQEntries;
005470  90004E     MOV [W14+8], W0
005472  9000E0     MOV [W0+12], W1
005474  90006E     MOV [W14+12], W0
005476  980011     MOV W1, [W0+2]
852:                   p_q_data->OSQSize = pq->OSQSize;
005478  90004E     MOV [W14+8], W0
00547A  9000D0     MOV [W0+10], W1
00547C  90006E     MOV [W14+12], W0
00547E  980021     MOV W1, [W0+4]
853:                   OS_EXIT_CRITICAL();
005480  9000BE     MOV [W14+6], W1
005482  880211     MOV W1, SR
854:                   return (OS_ERR_NONE);
005484  EB4000     CLR.B W0
855:               }
005486  FA8000     ULNK
005488  060000     RETURN
856:               #endif                                                 /* OS_Q_QUERY_EN                                */
857:               
858:               /*$PAGE*/
859:               /*
860:               *********************************************************************************************************
861:               *                                     QUEUE MODULE INITIALIZATION
862:               *
863:               * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
864:               *               application MUST NOT call this function.
865:               *
866:               * Arguments   :  none
867:               *
868:               * Returns     : none
869:               *
870:               * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
871:               *********************************************************************************************************
872:               */
873:               
874:               void  OS_QInit (void)
875:               {
00548A  FA0008     LNK #0x8
876:               #if OS_MAX_QS == 1u
877:                   OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
878:                   OSQFreeList->OSQPtr = (OS_Q *)0;
879:               #endif
880:               
881:               #if OS_MAX_QS >= 2u
882:                   INT16U   ix;
883:                   INT16U   ix_next;
884:                   OS_Q    *pq1;
885:                   OS_Q    *pq2;
886:               
887:               
888:               
889:                   OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00548C  20C9C0     MOV #0xC9C, W0
00548E  2001C1     MOV #0x1C, W1
005490  07DF2A     RCALL OS_MemClr
890:                   for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
005492  EB0000     CLR W0
005494  780F00     MOV W0, [W14]
005496  370012     BRA 0x54BC
0054BA  E80F1E     INC [W14], [W14]
0054BC  78001E     MOV [W14], W0
0054BE  E00000     CP0 W0
0054C0  32FFEB     BRA Z, 0x5498
891:                       ix_next = ix + 1u;
005498  E8001E     INC [W14], W0
00549A  980710     MOV W0, [W14+2]
892:                       pq1 = &OSQTbl[ix];
00549C  78001E     MOV [W14], W0
00549E  B9006E     MUL.SU W0, #14, W0
0054A0  780080     MOV W0, W1
0054A2  20C9C0     MOV #0xC9C, W0
0054A4  408000     ADD W1, W0, W0
0054A6  980720     MOV W0, [W14+4]
893:                       pq2 = &OSQTbl[ix_next];
0054A8  90001E     MOV [W14+2], W0
0054AA  B9006E     MUL.SU W0, #14, W0
0054AC  780080     MOV W0, W1
0054AE  20C9C0     MOV #0xC9C, W0
0054B0  408000     ADD W1, W0, W0
0054B2  980730     MOV W0, [W14+6]
894:                       pq1->OSQPtr = pq2;
0054B4  90002E     MOV [W14+4], W0
0054B6  9000BE     MOV [W14+6], W1
0054B8  780801     MOV W1, [W0]
895:                   }
896:                   pq1         = &OSQTbl[ix];
0054C2  78001E     MOV [W14], W0
0054C4  B9006E     MUL.SU W0, #14, W0
0054C6  780080     MOV W0, W1
0054C8  20C9C0     MOV #0xC9C, W0
0054CA  408000     ADD W1, W0, W0
0054CC  980720     MOV W0, [W14+4]
897:                   pq1->OSQPtr = (OS_Q *)0;
0054CE  90002E     MOV [W14+4], W0
0054D0  EB0080     CLR W1
0054D2  780801     MOV W1, [W0]
898:                   OSQFreeList = &OSQTbl[0];
0054D4  20C9C0     MOV #0xC9C, W0
0054D6  884400     MOV W0, OSQFreeList
899:               #endif
900:               }
0054D8  FA8000     ULNK
901:               #endif                                               /* OS_Q_EN                                        */
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_mutex.c  -----------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_MUTEX.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                
31:                #if OS_MUTEX_EN > 0u
32:                /*
33:                *********************************************************************************************************
34:                *                                           LOCAL CONSTANTS
35:                *********************************************************************************************************
36:                */
37:                
38:                #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
39:                #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
40:                
41:                #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
42:                
43:                /*
44:                *********************************************************************************************************
45:                *                                           LOCAL CONSTANTS
46:                *********************************************************************************************************
47:                */
48:                
49:                static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
50:                
51:                /*$PAGE*/
52:                /*
53:                *********************************************************************************************************
54:                *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
55:                *
56:                * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
57:                *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
58:                *              not available or the event did not occur.
59:                *
60:                * Arguments  : pevent     is a pointer to the event control block
61:                *
62:                *              perr       is a pointer to an error code which will be returned to your application:
63:                *                            OS_ERR_NONE         if the call was successful.
64:                *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
65:                *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
66:                *                            OS_ERR_PEND_ISR     if you called this function from an ISR
67:                *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
68:                *                                                HIGHER (i.e. a lower number) than the PCP.  This error
69:                *                                                indicates that you did not set the PCP higher (lower
70:                *                                                number) than ALL the tasks that compete for the Mutex.
71:                *                                                Unfortunately, this is something that could not be
72:                *                                                detected when the Mutex is created because we don't know
73:                *                                                what tasks will be using the Mutex.
74:                *
75:                * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
76:                *              == OS_FALSE   a) if the resource is not available
77:                *                            b) you didn't pass a pointer to a mutual exclusion semaphore
78:                *                            c) you called this function from an ISR
79:                *
80:                * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
81:                *              intended to be used by tasks only.
82:                *********************************************************************************************************
83:                */
84:                
85:                #if OS_MUTEX_ACCEPT_EN > 0u
86:                BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
87:                                        INT8U     *perr)
88:                {
0044F6  FA0008     LNK #0x8
0044F8  980720     MOV W0, [W14+4]
0044FA  980731     MOV W1, [W14+6]
89:                    INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
90:                #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
91:                    OS_CPU_SR  cpu_sr = 0u;
0044FC  EB0000     CLR W0
0044FE  780F00     MOV W0, [W14]
92:                #endif
93:                
94:                
95:                
96:                #ifdef OS_SAFETY_CRITICAL
97:                    if (perr == (INT8U *)0) {
98:                        OS_SAFETY_CRITICAL_EXCEPTION();
99:                        return (OS_FALSE);
100:                   }
101:               #endif
102:               
103:               #if OS_ARG_CHK_EN > 0u
104:                   if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
004500  90002E     MOV [W14+4], W0
004502  E00000     CP0 W0
004504  3A0005     BRA NZ, 0x4510
105:                       *perr = OS_ERR_PEVENT_NULL;
004506  90003E     MOV [W14+6], W0
004508  B3C041     MOV.B #0x4, W1
00450A  784801     MOV.B W1, [W0]
106:                       return (OS_FALSE);
00450C  EB4000     CLR.B W0
00450E  37004E     BRA 0x45AC
107:                   }
108:               #endif
109:                   if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
004510  90002E     MOV [W14+4], W0
004512  784010     MOV.B [W0], W0
004514  504FE4     SUB.B W0, #0x4, [W15]
004516  320005     BRA Z, 0x4522
110:                       *perr = OS_ERR_EVENT_TYPE;
004518  90003E     MOV [W14+6], W0
00451A  B3C011     MOV.B #0x1, W1
00451C  784801     MOV.B W1, [W0]
111:                       return (OS_FALSE);
00451E  EB4000     CLR.B W0
004520  370045     BRA 0x45AC
112:                   }
113:                   if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
004522  BFC86B     MOV.B OSIntNesting, WREG
004524  E00400     CP0.B W0
004526  320005     BRA Z, 0x4532
114:                       *perr = OS_ERR_PEND_ISR;
004528  90003E     MOV [W14+6], W0
00452A  B3C021     MOV.B #0x2, W1
00452C  784801     MOV.B W1, [W0]
115:                       return (OS_FALSE);
00452E  EB4000     CLR.B W0
004530  37003D     BRA 0x45AC
116:                   }
117:                   OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
004532  800211     MOV SR, W1
004534  780F01     MOV W1, [W14]
004536  800211     MOV SR, W1
004538  200E00     MOV #0xE0, W0
00453A  700001     IOR W0, W1, W0
00453C  880210     MOV W0, SR
118:                   pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00453E  90002E     MOV [W14+4], W0
004540  900020     MOV [W0+4], W0
004542  DE0048     LSR W0, #8, W0
004544  984720     MOV.B W0, [W14+2]
119:                   if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
004546  90002E     MOV [W14+4], W0
004548  9000A0     MOV [W0+4], W1
00454A  200FF0     MOV #0xFF, W0
00454C  608080     AND W1, W0, W1
00454E  200FF0     MOV #0xFF, W0
004550  508F80     SUB W1, W0, [W15]
004552  3A0026     BRA NZ, 0x45A0
120:                       pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
004554  90002E     MOV [W14+4], W0
004556  9000A0     MOV [W0+4], W1
004558  2FF000     MOV #0xFF00, W0
00455A  608080     AND W1, W0, W1
00455C  90002E     MOV [W14+4], W0
00455E  980021     MOV W1, [W0+4]
121:                       pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
004560  90002E     MOV [W14+4], W0
004562  9000A0     MOV [W0+4], W1
004564  8043B0     MOV OSTCBCur, W0
004566  906020     MOV.B [W0+34], W0
004568  FB8000     ZE W0, W0
00456A  700081     IOR W0, W1, W1
00456C  90002E     MOV [W14+4], W0
00456E  980021     MOV W1, [W0+4]
122:                       pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
004570  8043B1     MOV OSTCBCur, W1
004572  90002E     MOV [W14+4], W0
004574  980011     MOV W1, [W0+2]
123:                       if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
004576  90402E     MOV.B [W14+2], W0
004578  404FE1     ADD.B W0, #0x1, [W15]
00457A  32000B     BRA Z, 0x4592
004580  90402E     MOV.B [W14+2], W0
004582  50CF80     SUB.B W1, W0, [W15]
004584  3E0006     BRA GTU, 0x4592
124:                           (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
00457C  8043B0     MOV OSTCBCur, W0
00457E  9060A0     MOV.B [W0+34], W1
125:                            OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
004586  78009E     MOV [W14], W1
004588  880211     MOV W1, SR
126:                           *perr = OS_ERR_PCP_LOWER;
00458A  90003E     MOV [W14+6], W0
00458C  B3C781     MOV.B #0x78, W1
00458E  784801     MOV.B W1, [W0]
004590  370005     BRA 0x459C
127:                       } else {
128:                            OS_EXIT_CRITICAL();
004592  78009E     MOV [W14], W1
004594  880211     MOV W1, SR
129:                           *perr = OS_ERR_NONE;
004596  90003E     MOV [W14+6], W0
004598  EB4080     CLR.B W1
00459A  784801     MOV.B W1, [W0]
130:                       }
131:                       return (OS_TRUE);
00459C  B3C010     MOV.B #0x1, W0
00459E  370006     BRA 0x45AC
132:                   }
133:                   OS_EXIT_CRITICAL();
0045A0  78009E     MOV [W14], W1
0045A2  880211     MOV W1, SR
134:                   *perr = OS_ERR_NONE;
0045A4  90003E     MOV [W14+6], W0
0045A6  EB4080     CLR.B W1
0045A8  784801     MOV.B W1, [W0]
135:                   return (OS_FALSE);
0045AA  EB4000     CLR.B W0
136:               }
0045AC  FA8000     ULNK
0045AE  060000     RETURN
137:               #endif
138:               
139:               /*$PAGE*/
140:               /*
141:               *********************************************************************************************************
142:               *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
143:               *
144:               * Description: This function creates a mutual exclusion semaphore.
145:               *
146:               * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
147:               *                            other words, when the semaphore is acquired and a higher priority task
148:               *                            attempts to obtain the semaphore then the priority of the task owning the
149:               *                            semaphore is raised to this priority.  It is assumed that you will specify
150:               *                            a priority that is LOWER in value than ANY of the tasks competing for the
151:               *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
152:               *                            priority ceiling promotion is disabled. This way, the tasks accessing the
153:               *                            semaphore do not have their priority promoted.
154:               *
155:               *              perr          is a pointer to an error code which will be returned to your application:
156:               *                               OS_ERR_NONE         if the call was successful.
157:               *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
158:               *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
159:               *                                                   already exist.
160:               *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
161:               *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
162:               *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
163:               *
164:               * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
165:               *                            created mutex.
166:               *              == (void *)0  if an error is detected.
167:               *
168:               * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
169:               *                 owning the mutex or 0xFF if no task owns the mutex.
170:               *
171:               *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
172:               *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
173:               *                 promotion is disabled.
174:               *********************************************************************************************************
175:               */
176:               
177:               OS_EVENT  *OSMutexCreate (INT8U   prio,
178:                                         INT8U  *perr)
179:               {
0045B0  FA0008     LNK #0x8
0045B2  984740     MOV.B W0, [W14+4]
0045B4  980731     MOV W1, [W14+6]
180:                   OS_EVENT  *pevent;
181:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
182:                   OS_CPU_SR  cpu_sr = 0u;
0045B6  EB0000     CLR W0
0045B8  780F00     MOV W0, [W14]
183:               #endif
184:               
185:               
186:               
187:               #ifdef OS_SAFETY_CRITICAL
188:                   if (perr == (INT8U *)0) {
189:                       OS_SAFETY_CRITICAL_EXCEPTION();
190:                       return ((OS_EVENT *)0);
191:                   }
192:               #endif
193:               
194:               #ifdef OS_SAFETY_CRITICAL_IEC61508
195:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
196:                       OS_SAFETY_CRITICAL_EXCEPTION();
197:                       return ((OS_EVENT *)0);
198:                   }
199:               #endif
200:               
201:               #if OS_ARG_CHK_EN > 0u
202:                   if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
0045BA  90404E     MOV.B [W14+4], W0
0045BC  404FE1     ADD.B W0, #0x1, [W15]
0045BE  320008     BRA Z, 0x45D0
203:                       if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
0045C0  90404E     MOV.B [W14+4], W0
0045C2  504FEB     SUB.B W0, #0xB, [W15]
0045C4  360005     BRA LEU, 0x45D0
204:                          *perr = OS_ERR_PRIO_INVALID;
0045C6  90003E     MOV [W14+6], W0
0045C8  B3C2A1     MOV.B #0x2A, W1
0045CA  784801     MOV.B W1, [W0]
205:                           return ((OS_EVENT *)0);
0045CC  EB0000     CLR W0
0045CE  370058     BRA 0x4680
206:                       }
207:                   }
208:               #endif
209:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0045D0  BFC86B     MOV.B OSIntNesting, WREG
0045D2  E00400     CP0.B W0
0045D4  320005     BRA Z, 0x45E0
210:                       *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
0045D6  90003E     MOV [W14+6], W0
0045D8  B3C101     MOV.B #0x10, W1
0045DA  784801     MOV.B W1, [W0]
211:                       return ((OS_EVENT *)0);
0045DC  EB0000     CLR W0
0045DE  370050     BRA 0x4680
212:                   }
213:                   OS_ENTER_CRITICAL();
0045E0  800211     MOV SR, W1
0045E2  780F01     MOV W1, [W14]
0045E4  800211     MOV SR, W1
0045E6  200E00     MOV #0xE0, W0
0045E8  700001     IOR W0, W1, W0
0045EA  880210     MOV W0, SR
214:                   if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
0045EC  90404E     MOV.B [W14+4], W0
0045EE  404FE1     ADD.B W0, #0x1, [W15]
0045F0  320016     BRA Z, 0x461E
215:                       if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
0045F2  90404E     MOV.B [W14+4], W0
0045F4  FB8000     ZE W0, W0
0045F6  400080     ADD W0, W0, W1
0045F8  209C20     MOV #0x9C2, W0
0045FA  408000     ADD W1, W0, W0
0045FC  780010     MOV [W0], W0
0045FE  E00000     CP0 W0
004600  320007     BRA Z, 0x4610
216:                           OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
004602  78009E     MOV [W14], W1
004604  880211     MOV W1, SR
217:                          *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
004606  90003E     MOV [W14+6], W0
004608  B3C281     MOV.B #0x28, W1
00460A  784801     MOV.B W1, [W0]
218:                           return ((OS_EVENT *)0);
00460C  EB0000     CLR W0
00460E  370038     BRA 0x4680
219:                       }
220:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
004610  90404E     MOV.B [W14+4], W0
004612  FB8000     ZE W0, W0
004614  400080     ADD W0, W0, W1
004616  209C20     MOV #0x9C2, W0
004618  408000     ADD W1, W0, W0
00461A  200011     MOV #0x1, W1
00461C  780801     MOV W1, [W0]
221:                   }
222:               
223:                   pevent = OSEventFreeList;                              /* Get next free event control block        */
00461E  8042A1     MOV OSEventFreeList, W1
004620  980711     MOV W1, [W14+2]
224:                   if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
004622  90001E     MOV [W14+2], W0
004624  E00000     CP0 W0
004626  3A0011     BRA NZ, 0x464A
225:                       if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
004628  90404E     MOV.B [W14+4], W0
00462A  404FE1     ADD.B W0, #0x1, [W15]
00462C  320007     BRA Z, 0x463C
226:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
00462E  90404E     MOV.B [W14+4], W0
004630  FB8000     ZE W0, W0
004632  400080     ADD W0, W0, W1
004634  209C20     MOV #0x9C2, W0
004636  408000     ADD W1, W0, W0
004638  EB0080     CLR W1
00463A  780801     MOV W1, [W0]
227:                       }
228:                       OS_EXIT_CRITICAL();
00463C  78009E     MOV [W14], W1
00463E  880211     MOV W1, SR
229:                      *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
004640  90003E     MOV [W14+6], W0
004642  B3C041     MOV.B #0x4, W1
004644  784801     MOV.B W1, [W0]
230:                       return (pevent);
004646  90001E     MOV [W14+2], W0
004648  37001B     BRA 0x4680
231:                   }
232:                   OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
00464A  8042A0     MOV OSEventFreeList, W0
00464C  900010     MOV [W0+2], W0
00464E  8842A0     MOV W0, OSEventFreeList
233:                   OS_EXIT_CRITICAL();
004650  78009E     MOV [W14], W1
004652  880211     MOV W1, SR
234:                   pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
004654  90001E     MOV [W14+2], W0
004656  B3C041     MOV.B #0x4, W1
004658  784801     MOV.B W1, [W0]
235:                   pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
00465A  90404E     MOV.B [W14+4], W0
00465C  FB8000     ZE W0, W0
00465E  DD00C8     SL W0, #8, W1
004660  200FF0     MOV #0xFF, W0
004662  700081     IOR W0, W1, W1
004664  90001E     MOV [W14+2], W0
004666  980021     MOV W1, [W0+4]
236:                   pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
004668  90001E     MOV [W14+2], W0
00466A  EB0080     CLR W1
00466C  980011     MOV W1, [W0+2]
237:               #if OS_EVENT_NAME_EN > 0u
238:                   pevent->OSEventName = (INT8U *)(void *)"?";
00466E  288401     MOV #0x8840, W1
004670  90001E     MOV [W14+2], W0
004672  980051     MOV W1, [W0+10]
239:               #endif
240:                   OS_EventWaitListInit(pevent);
004674  90001E     MOV [W14+2], W0
004676  07E56E     RCALL OS_EventWaitListInit
241:                  *perr = OS_ERR_NONE;
004678  90003E     MOV [W14+6], W0
00467A  EB4080     CLR.B W1
00467C  784801     MOV.B W1, [W0]
242:                   return (pevent);
00467E  90001E     MOV [W14+2], W0
243:               }
004680  FA8000     ULNK
004682  060000     RETURN
244:               
245:               /*$PAGE*/
246:               /*
247:               *********************************************************************************************************
248:               *                                           DELETE A MUTEX
249:               *
250:               * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
251:               *
252:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
253:               *
254:               *              opt           determines delete options as follows:
255:               *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
256:               *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
257:               *                                                    In this case, all the tasks pending will be readied.
258:               *
259:               *              perr          is a pointer to an error code that can contain one of the following values:
260:               *                            OS_ERR_NONE             The call was successful and the mutex was deleted
261:               *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
262:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
263:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
264:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
265:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
266:               *
267:               * Returns    : pevent        upon error
268:               *              (OS_EVENT *)0 if the mutex was successfully deleted.
269:               *
270:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
271:               *                 the mutex MUST check the return code of OSMutexPend().
272:               *
273:               *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
274:               *                 time is directly proportional to the number of tasks waiting on the mutex.
275:               *
276:               *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
277:               *                 resource(s) will no longer be guarded by the mutex.
278:               *
279:               *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
280:               *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
281:               *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
282:               *                            that task will be made ready-to-run at its original priority.
283:               *********************************************************************************************************
284:               */
285:               
286:               #if OS_MUTEX_DEL_EN > 0u
287:               OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
288:                                      INT8U      opt,
289:                                      INT8U     *perr)
290:               {
004684  FA0010     LNK #0x10
004686  980750     MOV W0, [W14+10]
004688  984F41     MOV.B W1, [W14+12]
00468A  980772     MOV W2, [W14+14]
291:                   BOOLEAN    tasks_waiting;
292:                   OS_EVENT  *pevent_return;
293:                   INT8U      pcp;                                        /* Priority ceiling priority                */
294:                   INT8U      prio;
295:                   OS_TCB    *ptcb;
296:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
297:                   OS_CPU_SR  cpu_sr = 0u;
00468C  EB0000     CLR W0
00468E  980720     MOV W0, [W14+4]
298:               #endif
299:               
300:               
301:               
302:               #ifdef OS_SAFETY_CRITICAL
303:                   if (perr == (INT8U *)0) {
304:                       OS_SAFETY_CRITICAL_EXCEPTION();
305:                       return ((OS_EVENT *)0);
306:                   }
307:               #endif
308:               
309:               #if OS_ARG_CHK_EN > 0u
310:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
004690  90005E     MOV [W14+10], W0
004692  E00000     CP0 W0
004694  3A0005     BRA NZ, 0x46A0
311:                       *perr = OS_ERR_PEVENT_NULL;
004696  90007E     MOV [W14+14], W0
004698  B3C041     MOV.B #0x4, W1
00469A  784801     MOV.B W1, [W0]
312:                       return (pevent);
00469C  90005E     MOV [W14+10], W0
00469E  3700AF     BRA 0x47FE
313:                   }
314:               #endif
315:                   if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
0046A0  90005E     MOV [W14+10], W0
0046A2  784010     MOV.B [W0], W0
0046A4  504FE4     SUB.B W0, #0x4, [W15]
0046A6  320005     BRA Z, 0x46B2
316:                       *perr = OS_ERR_EVENT_TYPE;
0046A8  90007E     MOV [W14+14], W0
0046AA  B3C011     MOV.B #0x1, W1
0046AC  784801     MOV.B W1, [W0]
317:                       return (pevent);
0046AE  90005E     MOV [W14+10], W0
0046B0  3700A6     BRA 0x47FE
318:                   }
319:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0046B2  BFC86B     MOV.B OSIntNesting, WREG
0046B4  E00400     CP0.B W0
0046B6  320005     BRA Z, 0x46C2
320:                       *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
0046B8  90007E     MOV [W14+14], W0
0046BA  B3C0F1     MOV.B #0xF, W1
0046BC  784801     MOV.B W1, [W0]
321:                       return (pevent);
0046BE  90005E     MOV [W14+10], W0
0046C0  37009E     BRA 0x47FE
322:                   }
323:                   OS_ENTER_CRITICAL();
0046C2  800211     MOV SR, W1
0046C4  980721     MOV W1, [W14+4]
0046C6  800211     MOV SR, W1
0046C8  200E00     MOV #0xE0, W0
0046CA  700001     IOR W0, W1, W0
0046CC  880210     MOV W0, SR
324:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
0046CE  90005E     MOV [W14+10], W0
0046D0  904060     MOV.B [W0+6], W0
0046D2  E00400     CP0.B W0
0046D4  320003     BRA Z, 0x46DC
325:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
0046D6  B3C010     MOV.B #0x1, W0
0046D8  784F00     MOV.B W0, [W14]
0046DA  370002     BRA 0x46E0
326:                   } else {
327:                       tasks_waiting = OS_FALSE;                          /* No                                       */
0046DC  EB4000     CLR.B W0
0046DE  784F00     MOV.B W0, [W14]
328:                   }
329:                   switch (opt) {
0046E0  90484E     MOV.B [W14+12], W0
0046E2  FB8000     ZE W0, W0
0046E4  E00000     CP0 W0
0046E6  320003     BRA Z, 0x46EE
0046E8  500FE1     SUB W0, #0x1, [W15]
0046EA  320030     BRA Z, 0x474C
0046EC  37007F     BRA 0x47EC
330:                       case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
331:                            if (tasks_waiting == OS_FALSE) {
0046EE  78401E     MOV.B [W14], W0
0046F0  E00400     CP0.B W0
0046F2  3A0024     BRA NZ, 0x473C
332:               #if OS_EVENT_NAME_EN > 0u
333:                                pevent->OSEventName   = (INT8U *)(void *)"?";
0046F4  288401     MOV #0x8840, W1
0046F6  90005E     MOV [W14+10], W0
0046F8  980051     MOV W1, [W0+10]
334:               #endif
335:                                pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
0046FA  90005E     MOV [W14+10], W0
0046FC  900020     MOV [W0+4], W0
0046FE  DE0048     LSR W0, #8, W0
004700  984760     MOV.B W0, [W14+6]
336:                                if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
004702  90406E     MOV.B [W14+6], W0
004704  404FE1     ADD.B W0, #0x1, [W15]
004706  320007     BRA Z, 0x4716
337:                                    OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
004708  90406E     MOV.B [W14+6], W0
00470A  FB8000     ZE W0, W0
00470C  400080     ADD W0, W0, W1
00470E  209C20     MOV #0x9C2, W0
004710  408000     ADD W1, W0, W0
004712  EB0080     CLR W1
004714  780801     MOV W1, [W0]
338:                                }
339:                                pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
004716  90005E     MOV [W14+10], W0
004718  EB4080     CLR.B W1
00471A  784801     MOV.B W1, [W0]
340:                                pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
00471C  8042A1     MOV OSEventFreeList, W1
00471E  90005E     MOV [W14+10], W0
004720  980011     MOV W1, [W0+2]
341:                                pevent->OSEventCnt    = 0u;
004722  90005E     MOV [W14+10], W0
004724  EB0080     CLR W1
004726  980021     MOV W1, [W0+4]
342:                                OSEventFreeList       = pevent;
004728  9000DE     MOV [W14+10], W1
00472A  8842A1     MOV W1, OSEventFreeList
343:                                OS_EXIT_CRITICAL();
00472C  9000AE     MOV [W14+4], W1
00472E  880211     MOV W1, SR
344:                                *perr                 = OS_ERR_NONE;
004730  90007E     MOV [W14+14], W0
004732  EB4080     CLR.B W1
004734  784801     MOV.B W1, [W0]
345:                                pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
004736  EB0000     CLR W0
004738  980710     MOV W0, [W14+2]
346:                            } else {
347:                                OS_EXIT_CRITICAL();
00473C  9000AE     MOV [W14+4], W1
00473E  880211     MOV W1, SR
348:                                *perr                 = OS_ERR_TASK_WAITING;
004740  90007E     MOV [W14+14], W0
004742  B3C491     MOV.B #0x49, W1
004744  784801     MOV.B W1, [W0]
349:                                pevent_return         = pevent;
004746  9000DE     MOV [W14+10], W1
004748  980711     MOV W1, [W14+2]
350:                            }
351:                            break;
00473A  370060     BRA 0x47FC
00474A  370058     BRA 0x47FC
352:               
353:                       case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
354:                            pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
00474C  90005E     MOV [W14+10], W0
00474E  900020     MOV [W0+4], W0
004750  DE0048     LSR W0, #8, W0
004752  984760     MOV.B W0, [W14+6]
355:                            if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
004754  90406E     MOV.B [W14+6], W0
004756  404FE1     ADD.B W0, #0x1, [W15]
004758  320018     BRA Z, 0x478A
356:                                prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
00475A  90005E     MOV [W14+10], W0
00475C  900020     MOV [W0+4], W0
00475E  984770     MOV.B W0, [W14+7]
357:                                ptcb = (OS_TCB *)pevent->OSEventPtr;
004760  90005E     MOV [W14+10], W0
004762  900010     MOV [W0+2], W0
004764  980740     MOV W0, [W14+8]
358:                                if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
004766  90004E     MOV [W14+8], W0
004768  E00000     CP0 W0
00476A  320011     BRA Z, 0x478E
359:                                    if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00476C  90004E     MOV [W14+8], W0
00476E  9060A0     MOV.B [W0+34], W1
004770  90406E     MOV.B [W14+6], W0
004772  50CF80     SUB.B W1, W0, [W15]
004774  3A000E     BRA NZ, 0x4792
360:                                        OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
004776  9040FE     MOV.B [W14+7], W1
004778  90004E     MOV [W14+8], W0
00477A  070273     RCALL _OSMutex_RdyAtPrio
361:                                    }
362:                                }
363:                            }
364:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
00477C  37000B     BRA 0x4794
00478A  000000     NOP
00478C  370003     BRA 0x4794
00478E  000000     NOP
004790  370001     BRA 0x4794
004792  000000     NOP
004794  90005E     MOV [W14+10], W0
004796  904060     MOV.B [W0+6], W0
004798  E00400     CP0.B W0
00479A  3AFFF1     BRA NZ, 0x477E
365:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00477E  B3C023     MOV.B #0x2, W3
004780  B3C102     MOV.B #0x10, W2
004782  EB0080     CLR W1
004784  90005E     MOV [W14+10], W0
004786  07E3B1     RCALL OS_EventTaskRdy
004788  370005     BRA 0x4794
366:                            }
367:               #if OS_EVENT_NAME_EN > 0u
368:                            pevent->OSEventName   = (INT8U *)(void *)"?";
00479C  288401     MOV #0x8840, W1
00479E  90005E     MOV [W14+10], W0
0047A0  980051     MOV W1, [W0+10]
369:               #endif
370:                            pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
0047A2  90005E     MOV [W14+10], W0
0047A4  900020     MOV [W0+4], W0
0047A6  DE0048     LSR W0, #8, W0
0047A8  984760     MOV.B W0, [W14+6]
371:                            if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0047AA  90406E     MOV.B [W14+6], W0
0047AC  404FE1     ADD.B W0, #0x1, [W15]
0047AE  320007     BRA Z, 0x47BE
372:                                OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
0047B0  90406E     MOV.B [W14+6], W0
0047B2  FB8000     ZE W0, W0
0047B4  400080     ADD W0, W0, W1
0047B6  209C20     MOV #0x9C2, W0
0047B8  408000     ADD W1, W0, W0
0047BA  EB0080     CLR W1
0047BC  780801     MOV W1, [W0]
373:                            }
374:                            pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
0047BE  90005E     MOV [W14+10], W0
0047C0  EB4080     CLR.B W1
0047C2  784801     MOV.B W1, [W0]
375:                            pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
0047C4  8042A1     MOV OSEventFreeList, W1
0047C6  90005E     MOV [W14+10], W0
0047C8  980011     MOV W1, [W0+2]
376:                            pevent->OSEventCnt    = 0u;
0047CA  90005E     MOV [W14+10], W0
0047CC  EB0080     CLR W1
0047CE  980021     MOV W1, [W0+4]
377:                            OSEventFreeList       = pevent;               /* Get next free event control block        */
0047D0  9000DE     MOV [W14+10], W1
0047D2  8842A1     MOV W1, OSEventFreeList
378:                            OS_EXIT_CRITICAL();
0047D4  9000AE     MOV [W14+4], W1
0047D6  880211     MOV W1, SR
379:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0047D8  78401E     MOV.B [W14], W0
0047DA  504FE1     SUB.B W0, #0x1, [W15]
0047DC  3A0001     BRA NZ, 0x47E0
380:                                OS_Sched();                               /* Find highest priority task ready to run  */
0047DE  07E5A8     RCALL OS_Sched
381:                            }
382:                            *perr         = OS_ERR_NONE;
0047E0  90007E     MOV [W14+14], W0
0047E2  EB4080     CLR.B W1
0047E4  784801     MOV.B W1, [W0]
383:                            pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
0047E6  EB0000     CLR W0
0047E8  980710     MOV W0, [W14+2]
384:                            break;
0047EA  370008     BRA 0x47FC
385:               
386:                       default:
387:                            OS_EXIT_CRITICAL();
0047EC  9000AE     MOV [W14+4], W1
0047EE  880211     MOV W1, SR
388:                            *perr         = OS_ERR_INVALID_OPT;
0047F0  90007E     MOV [W14+14], W0
0047F2  B3C071     MOV.B #0x7, W1
0047F4  784801     MOV.B W1, [W0]
389:                            pevent_return = pevent;
0047F6  9000DE     MOV [W14+10], W1
0047F8  980711     MOV W1, [W14+2]
390:                            break;
0047FA  000000     NOP
391:                   }
392:                   return (pevent_return);
0047FC  90001E     MOV [W14+2], W0
393:               }
0047FE  FA8000     ULNK
004800  060000     RETURN
394:               #endif
395:               
396:               /*$PAGE*/
397:               /*
398:               *********************************************************************************************************
399:               *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
400:               *
401:               * Description: This function waits for a mutual exclusion semaphore.
402:               *
403:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
404:               *                            mutex.
405:               *
406:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
407:               *                            wait for the resource up to the amount of time specified by this argument.
408:               *                            If you specify 0, however, your task will wait forever at the specified
409:               *                            mutex or, until the resource becomes available.
410:               *
411:               *              perr          is a pointer to where an error message will be deposited.  Possible error
412:               *                            messages are:
413:               *                               OS_ERR_NONE        The call was successful and your task owns the mutex
414:               *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
415:               *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
416:               *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
417:               *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
418:               *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
419:               *                                                  would lead to a suspension.
420:               *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
421:               *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
422:               *                                                  indicates that you did not set the PCP higher (lower
423:               *                                                  number) than ALL the tasks that compete for the Mutex.
424:               *                                                  Unfortunately, this is something that could not be
425:               *                                                  detected when the Mutex is created because we don't know
426:               *                                                  what tasks will be using the Mutex.
427:               *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
428:               *
429:               * Returns    : none
430:               *
431:               * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
432:               *
433:               *              2) You MUST NOT change the priority of the task that owns the mutex
434:               *********************************************************************************************************
435:               */
436:               
437:               void  OSMutexPend (OS_EVENT  *pevent,
438:                                  INT32U     timeout,
439:                                  INT8U     *perr)
440:               {
004802  FA0014     LNK #0x14
004804  980760     MOV W0, [W14+12]
004806  980772     MOV W2, [W14+14]
004808  980F03     MOV W3, [W14+16]
00480A  980F11     MOV W1, [W14+18]
441:                   INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
442:                   INT8U      mprio;                                      /* Mutex owner priority                     */
443:                   BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
444:                   OS_TCB    *ptcb;
445:                   OS_EVENT  *pevent2;
446:                   INT8U      y;
447:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
448:                   OS_CPU_SR  cpu_sr = 0u;
00480C  EB0000     CLR W0
00480E  980710     MOV W0, [W14+2]
449:               #endif
450:               
451:               
452:               
453:               #ifdef OS_SAFETY_CRITICAL
454:                   if (perr == (INT8U *)0) {
455:                       OS_SAFETY_CRITICAL_EXCEPTION();
456:                       return;
457:                   }
458:               #endif
459:               
460:               #if OS_ARG_CHK_EN > 0u
461:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
004810  90006E     MOV [W14+12], W0
004812  E00000     CP0 W0
004814  3A0004     BRA NZ, 0x481E
462:                       *perr = OS_ERR_PEVENT_NULL;
004816  90081E     MOV [W14+18], W0
004818  B3C041     MOV.B #0x4, W1
00481A  784801     MOV.B W1, [W0]
463:                       return;
00481C  370150     BRA 0x4ABE
464:                   }
465:               #endif
466:                   if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00481E  90006E     MOV [W14+12], W0
004820  784010     MOV.B [W0], W0
004822  504FE4     SUB.B W0, #0x4, [W15]
004824  320004     BRA Z, 0x482E
467:                       *perr = OS_ERR_EVENT_TYPE;
004826  90081E     MOV [W14+18], W0
004828  B3C011     MOV.B #0x1, W1
00482A  784801     MOV.B W1, [W0]
468:                       return;
00482C  370148     BRA 0x4ABE
469:                   }
470:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00482E  BFC86B     MOV.B OSIntNesting, WREG
004830  E00400     CP0.B W0
004832  320004     BRA Z, 0x483C
471:                       *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
004834  90081E     MOV [W14+18], W0
004836  B3C021     MOV.B #0x2, W1
004838  784801     MOV.B W1, [W0]
472:                       return;
00483A  370141     BRA 0x4ABE
473:                   }
474:                   if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00483C  BFC86C     MOV.B OSLockNesting, WREG
00483E  E00400     CP0.B W0
004840  320004     BRA Z, 0x484A
475:                       *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
004842  90081E     MOV [W14+18], W0
004844  B3C0D1     MOV.B #0xD, W1
004846  784801     MOV.B W1, [W0]
476:                       return;
004848  37013A     BRA 0x4ABE
477:                   }
478:               /*$PAGE*/
479:                   OS_ENTER_CRITICAL();
00484A  800211     MOV SR, W1
00484C  980711     MOV W1, [W14+2]
00484E  800211     MOV SR, W1
004850  200E00     MOV #0xE0, W0
004852  700001     IOR W0, W1, W0
004854  880210     MOV W0, SR
480:                   pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
004856  90006E     MOV [W14+12], W0
004858  900020     MOV [W0+4], W0
00485A  DE0048     LSR W0, #8, W0
00485C  984740     MOV.B W0, [W14+4]
481:                                                                          /* Is Mutex available?                      */
482:                   if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00485E  90006E     MOV [W14+12], W0
004860  900020     MOV [W0+4], W0
004862  784000     MOV.B W0, W0
004864  404FE1     ADD.B W0, #0x1, [W15]
004866  3A0025     BRA NZ, 0x48B2
483:                       pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
004868  90006E     MOV [W14+12], W0
00486A  9000A0     MOV [W0+4], W1
00486C  2FF000     MOV #0xFF00, W0
00486E  608080     AND W1, W0, W1
004870  90006E     MOV [W14+12], W0
004872  980021     MOV W1, [W0+4]
484:                       pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
004874  90006E     MOV [W14+12], W0
004876  9000A0     MOV [W0+4], W1
004878  8043B0     MOV OSTCBCur, W0
00487A  906020     MOV.B [W0+34], W0
00487C  FB8000     ZE W0, W0
00487E  700081     IOR W0, W1, W1
004880  90006E     MOV [W14+12], W0
004882  980021     MOV W1, [W0+4]
485:                       pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
004884  8043B1     MOV OSTCBCur, W1
004886  90006E     MOV [W14+12], W0
004888  980011     MOV W1, [W0+2]
486:                       if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00488A  90404E     MOV.B [W14+4], W0
00488C  404FE1     ADD.B W0, #0x1, [W15]
00488E  32000B     BRA Z, 0x48A6
004894  90404E     MOV.B [W14+4], W0
004896  50CF80     SUB.B W1, W0, [W15]
004898  3E0006     BRA GTU, 0x48A6
487:                           (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
004890  8043B0     MOV OSTCBCur, W0
004892  9060A0     MOV.B [W0+34], W1
488:                            OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00489A  90011E     MOV [W14+2], W2
00489C  880212     MOV W2, SR
489:                           *perr = OS_ERR_PCP_LOWER;
00489E  90081E     MOV [W14+18], W0
0048A0  B3C781     MOV.B #0x78, W1
0048A2  784801     MOV.B W1, [W0]
490:                       } else {
491:                            OS_EXIT_CRITICAL();
0048A6  90019E     MOV [W14+2], W3
0048A8  880213     MOV W3, SR
492:                           *perr = OS_ERR_NONE;
0048AA  90081E     MOV [W14+18], W0
0048AC  EB4080     CLR.B W1
0048AE  784801     MOV.B W1, [W0]
493:                       }
494:                       return;
0048A4  37010C     BRA 0x4ABE
0048B0  370106     BRA 0x4ABE
495:                   }
496:                   if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
0048B2  90404E     MOV.B [W14+4], W0
0048B4  404FE1     ADD.B W0, #0x1, [W15]
0048B6  3200C6     BRA Z, 0x4A44
497:                       mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
0048B8  90006E     MOV [W14+12], W0
0048BA  900020     MOV [W0+4], W0
0048BC  984750     MOV.B W0, [W14+5]
498:                       ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
0048BE  90006E     MOV [W14+12], W0
0048C0  900010     MOV [W0+2], W0
0048C2  980730     MOV W0, [W14+6]
499:                       if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
0048C4  90003E     MOV [W14+6], W0
0048C6  9060A0     MOV.B [W0+34], W1
0048C8  90404E     MOV.B [W14+4], W0
0048CA  50CF80     SUB.B W1, W0, [W15]
0048CC  3600BB     BRA LEU, 0x4A44
500:                           if (mprio > OSTCBCur->OSTCBPrio) {
0048CE  8043B0     MOV OSTCBCur, W0
0048D0  9060A0     MOV.B [W0+34], W1
0048D2  90405E     MOV.B [W14+5], W0
0048D4  50CF80     SUB.B W1, W0, [W15]
0048D6  3100B6     BRA C, 0x4A44
501:                               y = ptcb->OSTCBY;
0048D8  90003E     MOV [W14+6], W0
0048DA  9060C0     MOV.B [W0+36], W1
0048DC  984F01     MOV.B W1, [W14+8]
502:                               if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
0048DE  90480E     MOV.B [W14+8], W0
0048E0  FB8000     ZE W0, W0
0048E2  209401     MOV #0x940, W1
0048E4  7840E1     MOV.B [W1+W0], W1
0048E6  90003E     MOV [W14+6], W0
0048E8  906050     MOV.B [W0+37], W0
0048EA  60C000     AND.B W1, W0, W0
0048EC  E00400     CP0.B W0
0048EE  32001B     BRA Z, 0x4926
503:                                   OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
0048F0  90480E     MOV.B [W14+8], W0
0048F2  FB8000     ZE W0, W0
0048F4  90488E     MOV.B [W14+8], W1
0048F6  FB8081     ZE W1, W1
0048F8  209402     MOV #0x940, W2
0048FA  78C162     MOV.B [W2+W1], W2
0048FC  9000BE     MOV [W14+6], W1
0048FE  9060D1     MOV.B [W1+37], W1
004900  EAC081     COM.B W1, W1
004902  614101     AND.B W2, W1, W2
004904  209401     MOV #0x940, W1
004906  787082     MOV.B W2, [W1+W0]
504:                                   if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
004908  90480E     MOV.B [W14+8], W0
00490A  FB8000     ZE W0, W0
00490C  209401     MOV #0x940, W1
00490E  784061     MOV.B [W1+W0], W0
004910  E00400     CP0.B W0
004912  3A0006     BRA NZ, 0x4920
505:                                       OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
004914  90003E     MOV [W14+6], W0
004916  906060     MOV.B [W0+38], W0
004918  EAC080     COM.B W0, W1
00491A  BFC86F     MOV.B OSRdyGrp, WREG
00491C  60C000     AND.B W1, W0, W0
00491E  B7E86F     MOV.B WREG, OSRdyGrp
506:                                   }
507:                                   rdy = OS_TRUE;
004920  B3C010     MOV.B #0x1, W0
004922  784F00     MOV.B W0, [W14]
004924  37002A     BRA 0x497A
508:                               } else {
509:                                   pevent2 = ptcb->OSTCBEventPtr;
004926  90003E     MOV [W14+6], W0
004928  900910     MOV [W0+18], W2
00492A  980752     MOV W2, [W14+10]
510:                                   if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
00492C  90005E     MOV [W14+10], W0
00492E  E00000     CP0 W0
004930  320022     BRA Z, 0x4976
511:                                       y = ptcb->OSTCBY;
004932  90003E     MOV [W14+6], W0
004934  9061C0     MOV.B [W0+36], W3
004936  984F03     MOV.B W3, [W14+8]
512:                                       pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
004938  90480E     MOV.B [W14+8], W0
00493A  FB8000     ZE W0, W0
00493C  90488E     MOV.B [W14+8], W1
00493E  FB8081     ZE W1, W1
004940  90015E     MOV [W14+10], W2
004942  4080E6     ADD W1, #0x6, W1
004944  410081     ADD W2, W1, W1
004946  904111     MOV.B [W1+1], W2
004948  9000BE     MOV [W14+6], W1
00494A  9060D1     MOV.B [W1+37], W1
00494C  EAC081     COM.B W1, W1
00494E  614081     AND.B W2, W1, W1
004950  90015E     MOV [W14+10], W2
004952  410000     ADD W2, W0, W0
004954  984071     MOV.B W1, [W0+7]
513:                                       if (pevent2->OSEventTbl[y] == 0u) {
004956  90480E     MOV.B [W14+8], W0
004958  FB8000     ZE W0, W0
00495A  9000DE     MOV [W14+10], W1
00495C  400066     ADD W0, #0x6, W0
00495E  408000     ADD W1, W0, W0
004960  904010     MOV.B [W0+1], W0
004962  E00400     CP0.B W0
004964  3A0008     BRA NZ, 0x4976
514:                                           pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
004966  90005E     MOV [W14+10], W0
004968  9040E0     MOV.B [W0+6], W1
00496A  90003E     MOV [W14+6], W0
00496C  906060     MOV.B [W0+38], W0
00496E  EAC000     COM.B W0, W0
004970  60C080     AND.B W1, W0, W1
004972  90005E     MOV [W14+10], W0
004974  984061     MOV.B W1, [W0+6]
515:                                       }
516:                                   }
517:                                   rdy = OS_FALSE;                        /* No                                       */
004976  EB4000     CLR.B W0
004978  784F00     MOV.B W0, [W14]
518:                               }
519:                               ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
00497A  90003E     MOV [W14+6], W0
00497C  9040CE     MOV.B [W14+4], W1
00497E  986021     MOV.B W1, [W0+34]
520:               #if OS_LOWEST_PRIO <= 63u
521:                               ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
004980  90003E     MOV [W14+6], W0
004982  906020     MOV.B [W0+34], W0
004984  FB8000     ZE W0, W0
004986  DE0043     LSR W0, #3, W0
004988  784080     MOV.B W0, W1
00498A  90003E     MOV [W14+6], W0
00498C  986041     MOV.B W1, [W0+36]
522:                               ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
00498E  90003E     MOV [W14+6], W0
004990  906020     MOV.B [W0+34], W0
004992  6040E7     AND.B W0, #0x7, W1
004994  90003E     MOV [W14+6], W0
004996  986031     MOV.B W1, [W0+35]
523:               #else
524:                               ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
525:                               ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
526:               #endif
527:                               ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
004998  90003E     MOV [W14+6], W0
00499A  906040     MOV.B [W0+36], W0
00499C  FB8100     ZE W0, W2
00499E  200010     MOV #0x1, W0
0049A0  200001     MOV #0x0, W1
0049A2  780182     MOV W2, W3
0049A4  E90183     DEC W3, W3
0049A6  330003     BRA N, 0x49AE
0049A8  400000     ADD W0, W0, W0
0049AA  488081     ADDC W1, W1, W1
0049AC  37FFFB     BRA 0x49A4
0049AE  784080     MOV.B W0, W1
0049B0  90003E     MOV [W14+6], W0
0049B2  986061     MOV.B W1, [W0+38]
528:                               ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
0049B4  90003E     MOV [W14+6], W0
0049B6  906030     MOV.B [W0+35], W0
0049B8  FB8100     ZE W0, W2
0049BA  200010     MOV #0x1, W0
0049BC  200001     MOV #0x0, W1
0049BE  780182     MOV W2, W3
0049C0  E90183     DEC W3, W3
0049C2  330003     BRA N, 0x49CA
0049C4  400000     ADD W0, W0, W0
0049C6  488081     ADDC W1, W1, W1
0049C8  37FFFB     BRA 0x49C0
0049CA  784080     MOV.B W0, W1
0049CC  90003E     MOV [W14+6], W0
0049CE  986051     MOV.B W1, [W0+37]
529:               
530:                               if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
0049D0  78401E     MOV.B [W14], W0
0049D2  504FE1     SUB.B W0, #0x1, [W15]
0049D4  3A0013     BRA NZ, 0x49FC
531:                                   OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
0049D6  90003E     MOV [W14+6], W0
0049D8  9060E0     MOV.B [W0+38], W1
0049DA  BFC86F     MOV.B OSRdyGrp, WREG
0049DC  70C000     IOR.B W1, W0, W0
0049DE  B7E86F     MOV.B WREG, OSRdyGrp
532:                                   OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0049E0  90003E     MOV [W14+6], W0
0049E2  906040     MOV.B [W0+36], W0
0049E4  FB8000     ZE W0, W0
0049E6  9000BE     MOV [W14+6], W1
0049E8  9060C1     MOV.B [W1+36], W1
0049EA  FB8081     ZE W1, W1
0049EC  209402     MOV #0x940, W2
0049EE  78C162     MOV.B [W2+W1], W2
0049F0  9000BE     MOV [W14+6], W1
0049F2  9060D1     MOV.B [W1+37], W1
0049F4  714101     IOR.B W2, W1, W2
0049F6  209401     MOV #0x940, W1
0049F8  787082     MOV.B W2, [W1+W0]
0049FA  37001D     BRA 0x4A36
533:                               } else {
534:                                   pevent2 = ptcb->OSTCBEventPtr;
0049FC  90003E     MOV [W14+6], W0
0049FE  900890     MOV [W0+18], W1
004A00  980751     MOV W1, [W14+10]
535:                                   if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
004A02  90005E     MOV [W14+10], W0
004A04  E00000     CP0 W0
004A06  320017     BRA Z, 0x4A36
536:                                       pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
004A08  90005E     MOV [W14+10], W0
004A0A  9040E0     MOV.B [W0+6], W1
004A0C  90003E     MOV [W14+6], W0
004A0E  906060     MOV.B [W0+38], W0
004A10  70C080     IOR.B W1, W0, W1
004A12  90005E     MOV [W14+10], W0
004A14  984061     MOV.B W1, [W0+6]
537:                                       pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
004A16  90003E     MOV [W14+6], W0
004A18  906040     MOV.B [W0+36], W0
004A1A  FB8000     ZE W0, W0
004A1C  9000BE     MOV [W14+6], W1
004A1E  9060C1     MOV.B [W1+36], W1
004A20  FB8081     ZE W1, W1
004A22  90015E     MOV [W14+10], W2
004A24  4080E6     ADD W1, #0x6, W1
004A26  410081     ADD W2, W1, W1
004A28  904111     MOV.B [W1+1], W2
004A2A  9000BE     MOV [W14+6], W1
004A2C  9060D1     MOV.B [W1+37], W1
004A2E  714081     IOR.B W2, W1, W1
004A30  90015E     MOV [W14+10], W2
004A32  410000     ADD W2, W0, W0
004A34  984071     MOV.B W1, [W0+7]
538:                                   }
539:                               }
540:                               OSTCBPrioTbl[pcp] = ptcb;
004A36  90404E     MOV.B [W14+4], W0
004A38  FB8000     ZE W0, W0
004A3A  400080     ADD W0, W0, W1
004A3C  209C20     MOV #0x9C2, W0
004A3E  408000     ADD W1, W0, W0
004A40  90013E     MOV [W14+6], W2
004A42  780802     MOV W2, [W0]
541:                           }
542:                       }
543:                   }
544:                   OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
004A44  8043B0     MOV OSTCBCur, W0
004A46  8043B1     MOV OSTCBCur, W1
004A48  906081     MOV.B [W1+32], W1
004A4A  A04401     BSET.B W1, #4
004A4C  986001     MOV.B W1, [W0+32]
545:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
004A4E  8043B0     MOV OSTCBCur, W0
004A50  EB4080     CLR.B W1
004A52  986011     MOV.B W1, [W0+33]
546:                   OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
004A54  8043B0     MOV OSTCBCur, W0
004A56  90017E     MOV [W14+14], W2
004A58  90098E     MOV [W14+16], W3
004A5A  980862     MOV W2, [W0+28]
004A5C  980873     MOV W3, [W0+30]
547:                   OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
004A5E  90006E     MOV [W14+12], W0
004A60  07E29B     RCALL OS_EventTaskWait
548:                   OS_EXIT_CRITICAL();
004A62  90019E     MOV [W14+2], W3
004A64  880213     MOV W3, SR
549:                   OS_Sched();                                       /* Find next highest priority task ready         */
004A66  07E464     RCALL OS_Sched
550:                   OS_ENTER_CRITICAL();
004A68  800211     MOV SR, W1
004A6A  980711     MOV W1, [W14+2]
004A6C  800211     MOV SR, W1
004A6E  200E00     MOV #0xE0, W0
004A70  700001     IOR W0, W1, W0
004A72  880210     MOV W0, SR
551:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
004A74  8043B0     MOV OSTCBCur, W0
004A76  906010     MOV.B [W0+33], W0
004A78  FB8000     ZE W0, W0
004A7A  E00000     CP0 W0
004A7C  320003     BRA Z, 0x4A84
004A7E  500FE2     SUB W0, #0x2, [W15]
004A80  320005     BRA Z, 0x4A8C
004A82  370008     BRA 0x4A94
552:                       case OS_STAT_PEND_OK:
553:                            *perr = OS_ERR_NONE;
004A84  90081E     MOV [W14+18], W0
004A86  EB4080     CLR.B W1
004A88  784801     MOV.B W1, [W0]
554:                            break;
004A8A  37000B     BRA 0x4AA2
555:               
556:                       case OS_STAT_PEND_ABORT:
557:                            *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
004A8C  90081E     MOV [W14+18], W0
004A8E  B3C0E1     MOV.B #0xE, W1
004A90  784801     MOV.B W1, [W0]
558:                            break;
004A92  370007     BRA 0x4AA2
559:               
560:                       case OS_STAT_PEND_TO:
561:                       default:
562:                            OS_EventTaskRemove(OSTCBCur, pevent);
004A94  8043B0     MOV OSTCBCur, W0
004A96  9000EE     MOV [W14+12], W1
004A98  07E2FE     RCALL OS_EventTaskRemove
563:                            *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
004A9A  90081E     MOV [W14+18], W0
004A9C  B3C0A1     MOV.B #0xA, W1
004A9E  784801     MOV.B W1, [W0]
564:                            break;
004AA0  000000     NOP
565:                   }
566:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
004AA2  8043B0     MOV OSTCBCur, W0
004AA4  EB4080     CLR.B W1
004AA6  986001     MOV.B W1, [W0+32]
567:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
004AA8  8043B0     MOV OSTCBCur, W0
004AAA  EB4080     CLR.B W1
004AAC  986011     MOV.B W1, [W0+33]
568:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
004AAE  8043B0     MOV OSTCBCur, W0
004AB0  EB0080     CLR W1
004AB2  980811     MOV W1, [W0+18]
569:               #if (OS_EVENT_MULTI_EN > 0u)
570:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
004AB4  8043B0     MOV OSTCBCur, W0
004AB6  EB0080     CLR W1
004AB8  980821     MOV W1, [W0+20]
571:               #endif
572:                   OS_EXIT_CRITICAL();
004ABA  90011E     MOV [W14+2], W2
004ABC  880212     MOV W2, SR
573:               }
004ABE  FA8000     ULNK
004AC0  060000     RETURN
574:               /*$PAGE*/
575:               /*
576:               *********************************************************************************************************
577:               *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
578:               *
579:               * Description: This function signals a mutual exclusion semaphore
580:               *
581:               * Arguments  : pevent              is a pointer to the event control block associated with the desired
582:               *                                  mutex.
583:               *
584:               * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
585:               *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
586:               *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
587:               *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
588:               *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
589:               *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
590:               *                                      HIGHER (i.e. a lower number) than the PCP.  This error
591:               *                                      indicates that you did not set the PCP higher (lower
592:               *                                      number) than ALL the tasks that compete for the Mutex.
593:               *                                      Unfortunately, this is something that could not be
594:               *                                      detected when the Mutex is created because we don't know
595:               *                                      what tasks will be using the Mutex.
596:               *********************************************************************************************************
597:               */
598:               
599:               INT8U  OSMutexPost (OS_EVENT *pevent)
600:               {
004AC2  FA0006     LNK #0x6
004AC4  980720     MOV W0, [W14+4]
601:                   INT8U      pcp;                                   /* Priority ceiling priority                     */
602:                   INT8U      prio;
603:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
604:                   OS_CPU_SR  cpu_sr = 0u;
004AC6  EB0000     CLR W0
004AC8  780F00     MOV W0, [W14]
605:               #endif
606:               
607:               
608:               
609:                   if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
004ACA  BFC86B     MOV.B OSIntNesting, WREG
004ACC  E00400     CP0.B W0
004ACE  320002     BRA Z, 0x4AD4
610:                       return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
004AD0  B3C050     MOV.B #0x5, W0
004AD2  370070     BRA 0x4BB4
611:                   }
612:               #if OS_ARG_CHK_EN > 0u
613:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
004AD4  90002E     MOV [W14+4], W0
004AD6  E00000     CP0 W0
004AD8  3A0002     BRA NZ, 0x4ADE
614:                       return (OS_ERR_PEVENT_NULL);
004ADA  B3C040     MOV.B #0x4, W0
004ADC  37006B     BRA 0x4BB4
615:                   }
616:               #endif
617:                   if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
004ADE  90002E     MOV [W14+4], W0
004AE0  784010     MOV.B [W0], W0
004AE2  504FE4     SUB.B W0, #0x4, [W15]
004AE4  320002     BRA Z, 0x4AEA
618:                       return (OS_ERR_EVENT_TYPE);
004AE6  B3C010     MOV.B #0x1, W0
004AE8  370065     BRA 0x4BB4
619:                   }
620:                   OS_ENTER_CRITICAL();
004AEA  800211     MOV SR, W1
004AEC  780F01     MOV W1, [W14]
004AEE  800211     MOV SR, W1
004AF0  200E00     MOV #0xE0, W0
004AF2  700001     IOR W0, W1, W0
004AF4  880210     MOV W0, SR
621:                   pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
004AF6  90002E     MOV [W14+4], W0
004AF8  900020     MOV [W0+4], W0
004AFA  DE0048     LSR W0, #8, W0
004AFC  984720     MOV.B W0, [W14+2]
622:                   prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
004AFE  90002E     MOV [W14+4], W0
004B00  900020     MOV [W0+4], W0
004B02  984730     MOV.B W0, [W14+3]
623:                   if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
004B04  90002E     MOV [W14+4], W0
004B06  900010     MOV [W0+2], W0
004B08  780080     MOV W0, W1
004B0A  8043B0     MOV OSTCBCur, W0
004B0C  508F80     SUB W1, W0, [W15]
004B0E  320004     BRA Z, 0x4B18
624:                       OS_EXIT_CRITICAL();
004B10  78009E     MOV [W14], W1
004B12  880211     MOV W1, SR
625:                       return (OS_ERR_NOT_MUTEX_OWNER);
004B14  B3C640     MOV.B #0x64, W0
004B16  37004E     BRA 0x4BB4
626:                   }
627:                   if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
004B18  90402E     MOV.B [W14+2], W0
004B1A  404FE1     ADD.B W0, #0x1, [W15]
004B1C  32000F     BRA Z, 0x4B3C
628:                       if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
004B1E  8043B0     MOV OSTCBCur, W0
004B20  9060A0     MOV.B [W0+34], W1
004B22  90402E     MOV.B [W14+2], W0
004B24  50CF80     SUB.B W1, W0, [W15]
004B26  3A0003     BRA NZ, 0x4B2E
629:                           OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
004B28  8043B0     MOV OSTCBCur, W0
004B2A  9040BE     MOV.B [W14+3], W1
004B2C  07009A     RCALL _OSMutex_RdyAtPrio
630:                       }
631:                       OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
004B2E  90402E     MOV.B [W14+2], W0
004B30  FB8000     ZE W0, W0
004B32  400080     ADD W0, W0, W1
004B34  209C20     MOV #0x9C2, W0
004B36  408000     ADD W1, W0, W0
004B38  200011     MOV #0x1, W1
004B3A  780801     MOV W1, [W0]
632:                   }
633:                   if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
004B3C  90002E     MOV [W14+4], W0
004B3E  904060     MOV.B [W0+6], W0
004B40  E00400     CP0.B W0
004B42  32002C     BRA Z, 0x4B9C
634:                                                                     /* Yes, Make HPT waiting for mutex ready         */
635:                       prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
004B44  EB4180     CLR.B W3
004B46  B3C102     MOV.B #0x10, W2
004B48  EB0080     CLR W1
004B4A  90002E     MOV [W14+4], W0
004B4C  07E1CE     RCALL OS_EventTaskRdy
004B4E  984730     MOV.B W0, [W14+3]
636:                       pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
004B50  90002E     MOV [W14+4], W0
004B52  9000A0     MOV [W0+4], W1
004B54  2FF000     MOV #0xFF00, W0
004B56  608080     AND W1, W0, W1
004B58  90002E     MOV [W14+4], W0
004B5A  980021     MOV W1, [W0+4]
637:                       pevent->OSEventCnt |= prio;
004B5C  90002E     MOV [W14+4], W0
004B5E  9000A0     MOV [W0+4], W1
004B60  90403E     MOV.B [W14+3], W0
004B62  FB8000     ZE W0, W0
004B64  700081     IOR W0, W1, W1
004B66  90002E     MOV [W14+4], W0
004B68  980021     MOV W1, [W0+4]
638:                       pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
004B6A  90403E     MOV.B [W14+3], W0
004B6C  FB8000     ZE W0, W0
004B6E  400080     ADD W0, W0, W1
004B70  209C20     MOV #0x9C2, W0
004B72  408000     ADD W1, W0, W0
004B74  780090     MOV [W0], W1
004B76  90002E     MOV [W14+4], W0
004B78  980011     MOV W1, [W0+2]
639:                       if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
004B7A  90402E     MOV.B [W14+2], W0
004B7C  404FE1     ADD.B W0, #0x1, [W15]
004B7E  320009     BRA Z, 0x4B92
004B80  9040BE     MOV.B [W14+3], W1
004B82  90402E     MOV.B [W14+2], W0
004B84  50CF80     SUB.B W1, W0, [W15]
004B86  3E0005     BRA GTU, 0x4B92
640:                           (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
641:                           OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
004B88  78009E     MOV [W14], W1
004B8A  880211     MOV W1, SR
642:                           OS_Sched();                               /*      Find highest priority task ready to run  */
004B8C  07E3D1     RCALL OS_Sched
643:                           return (OS_ERR_PCP_LOWER);
004B8E  B3C780     MOV.B #0x78, W0
004B90  370011     BRA 0x4BB4
644:                       } else {
645:                           OS_EXIT_CRITICAL();
004B92  78009E     MOV [W14], W1
004B94  880211     MOV W1, SR
646:                           OS_Sched();                               /*      Find highest priority task ready to run  */
004B96  07E3CC     RCALL OS_Sched
647:                           return (OS_ERR_NONE);
004B98  EB4000     CLR.B W0
004B9A  37000C     BRA 0x4BB4
648:                       }
649:                   }
650:                   pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
004B9C  90002E     MOV [W14+4], W0
004B9E  9000A0     MOV [W0+4], W1
004BA0  200FF0     MOV #0xFF, W0
004BA2  700081     IOR W0, W1, W1
004BA4  90002E     MOV [W14+4], W0
004BA6  980021     MOV W1, [W0+4]
651:                   pevent->OSEventPtr  = (void *)0;
004BA8  90002E     MOV [W14+4], W0
004BAA  EB0080     CLR W1
004BAC  980011     MOV W1, [W0+2]
652:                   OS_EXIT_CRITICAL();
004BAE  78009E     MOV [W14], W1
004BB0  880211     MOV W1, SR
653:                   return (OS_ERR_NONE);
004BB2  EB4000     CLR.B W0
654:               }
004BB4  FA8000     ULNK
004BB6  060000     RETURN
655:               /*$PAGE*/
656:               /*
657:               *********************************************************************************************************
658:               *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
659:               *
660:               * Description: This function obtains information about a mutex
661:               *
662:               * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
663:               *
664:               *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
665:               *
666:               * Returns    : OS_ERR_NONE          The call was successful and the message was sent
667:               *              OS_ERR_QUERY_ISR     If you called this function from an ISR
668:               *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
669:               *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
670:               *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
671:               *********************************************************************************************************
672:               */
673:               
674:               #if OS_MUTEX_QUERY_EN > 0u
675:               INT8U  OSMutexQuery (OS_EVENT       *pevent,
676:                                    OS_MUTEX_DATA  *p_mutex_data)
677:               {
004BB8  FA000C     LNK #0xC
004BBA  980740     MOV W0, [W14+8]
004BBC  980751     MOV W1, [W14+10]
678:                   INT8U       i;
679:                   OS_PRIO    *psrc;
680:                   OS_PRIO    *pdest;
681:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
682:                   OS_CPU_SR   cpu_sr = 0u;
004BBE  EB0000     CLR W0
004BC0  980730     MOV W0, [W14+6]
683:               #endif
684:               
685:               
686:               
687:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
004BC2  BFC86B     MOV.B OSIntNesting, WREG
004BC4  E00400     CP0.B W0
004BC6  320002     BRA Z, 0x4BCC
688:                       return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
004BC8  B3C060     MOV.B #0x6, W0
004BCA  370049     BRA 0x4C5E
689:                   }
690:               #if OS_ARG_CHK_EN > 0u
691:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
004BCC  90004E     MOV [W14+8], W0
004BCE  E00000     CP0 W0
004BD0  3A0002     BRA NZ, 0x4BD6
692:                       return (OS_ERR_PEVENT_NULL);
004BD2  B3C040     MOV.B #0x4, W0
004BD4  370044     BRA 0x4C5E
693:                   }
694:                   if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
004BD6  90005E     MOV [W14+10], W0
004BD8  E00000     CP0 W0
004BDA  3A0002     BRA NZ, 0x4BE0
695:                       return (OS_ERR_PDATA_NULL);
004BDC  B3C090     MOV.B #0x9, W0
004BDE  37003F     BRA 0x4C5E
696:                   }
697:               #endif
698:                   if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
004BE0  90004E     MOV [W14+8], W0
004BE2  784010     MOV.B [W0], W0
004BE4  504FE4     SUB.B W0, #0x4, [W15]
004BE6  320002     BRA Z, 0x4BEC
699:                       return (OS_ERR_EVENT_TYPE);
004BE8  B3C010     MOV.B #0x1, W0
004BEA  370039     BRA 0x4C5E
700:                   }
701:                   OS_ENTER_CRITICAL();
004BEC  800211     MOV SR, W1
004BEE  980731     MOV W1, [W14+6]
004BF0  800211     MOV SR, W1
004BF2  200E00     MOV #0xE0, W0
004BF4  700001     IOR W0, W1, W0
004BF6  880210     MOV W0, SR
702:                   p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
004BF8  90004E     MOV [W14+8], W0
004BFA  900020     MOV [W0+4], W0
004BFC  DE0048     LSR W0, #8, W0
004BFE  784080     MOV.B W0, W1
004C00  90005E     MOV [W14+10], W0
004C02  984051     MOV.B W1, [W0+5]
703:                   p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
004C04  90004E     MOV [W14+8], W0
004C06  900020     MOV [W0+4], W0
004C08  784080     MOV.B W0, W1
004C0A  90005E     MOV [W14+10], W0
004C0C  984041     MOV.B W1, [W0+4]
704:                   if (p_mutex_data->OSOwnerPrio == 0xFFu) {
004C0E  90005E     MOV [W14+10], W0
004C10  904040     MOV.B [W0+4], W0
004C12  404FE1     ADD.B W0, #0x1, [W15]
004C14  3A0004     BRA NZ, 0x4C1E
705:                       p_mutex_data->OSValue = OS_TRUE;
004C16  90005E     MOV [W14+10], W0
004C18  B3C011     MOV.B #0x1, W1
004C1A  984031     MOV.B W1, [W0+3]
004C1C  370003     BRA 0x4C24
706:                   } else {
707:                       p_mutex_data->OSValue = OS_FALSE;
004C1E  90005E     MOV [W14+10], W0
004C20  EB4080     CLR.B W1
004C22  984031     MOV.B W1, [W0+3]
708:                   }
709:                   p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
004C24  90004E     MOV [W14+8], W0
004C26  9040E0     MOV.B [W0+6], W1
004C28  90005E     MOV [W14+10], W0
004C2A  984021     MOV.B W1, [W0+2]
710:                   psrc                      = &pevent->OSEventTbl[0];
004C2C  90004E     MOV [W14+8], W0
004C2E  400067     ADD W0, #0x7, W0
004C30  980710     MOV W0, [W14+2]
711:                   pdest                     = &p_mutex_data->OSEventTbl[0];
004C32  9000DE     MOV [W14+10], W1
004C34  980721     MOV W1, [W14+4]
712:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
004C36  EB4000     CLR.B W0
004C38  784F00     MOV.B W0, [W14]
004C3A  37000B     BRA 0x4C52
004C50  E84F1E     INC.B [W14], [W14]
004C52  78401E     MOV.B [W14], W0
004C54  504FE1     SUB.B W0, #0x1, [W15]
004C56  36FFF2     BRA LEU, 0x4C3C
713:                       *pdest++ = *psrc++;
004C3C  90001E     MOV [W14+2], W0
004C3E  784090     MOV.B [W0], W1
004C40  90002E     MOV [W14+4], W0
004C42  784801     MOV.B W1, [W0]
004C44  90002E     MOV [W14+4], W0
004C46  E80000     INC W0, W0
004C48  980720     MOV W0, [W14+4]
004C4A  90001E     MOV [W14+2], W0
004C4C  E80000     INC W0, W0
004C4E  980710     MOV W0, [W14+2]
714:                   }
715:                   OS_EXIT_CRITICAL();
004C58  9000BE     MOV [W14+6], W1
004C5A  880211     MOV W1, SR
716:                   return (OS_ERR_NONE);
004C5C  EB4000     CLR.B W0
717:               }
004C5E  FA8000     ULNK
004C60  060000     RETURN
718:               #endif                                                     /* OS_MUTEX_QUERY_EN                        */
719:               
720:               /*$PAGE*/
721:               /*
722:               *********************************************************************************************************
723:               *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
724:               *
725:               * Description: This function makes a task ready at the specified priority
726:               *
727:               * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
728:               *
729:               *              prio            is the desired priority
730:               *
731:               * Returns    : none
732:               *********************************************************************************************************
733:               */
734:               
735:               static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
736:                                                INT8U    prio)
737:               {
004C62  FA0006     LNK #0x6
004C64  980710     MOV W0, [W14+2]
004C66  984741     MOV.B W1, [W14+4]
738:                   INT8U  y;
739:               
740:               
741:                   y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
004C68  90001E     MOV [W14+2], W0
004C6A  9060C0     MOV.B [W0+36], W1
004C6C  784F01     MOV.B W1, [W14]
742:                   OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
004C6E  FB801E     ZE [W14], W0
004C70  FB809E     ZE [W14], W1
004C72  209402     MOV #0x940, W2
004C74  78C162     MOV.B [W2+W1], W2
004C76  90009E     MOV [W14+2], W1
004C78  9060D1     MOV.B [W1+37], W1
004C7A  EAC081     COM.B W1, W1
004C7C  614101     AND.B W2, W1, W2
004C7E  209401     MOV #0x940, W1
004C80  787082     MOV.B W2, [W1+W0]
743:                   if (OSRdyTbl[y] == 0u) {
004C82  FB801E     ZE [W14], W0
004C84  209401     MOV #0x940, W1
004C86  784061     MOV.B [W1+W0], W0
004C88  E00400     CP0.B W0
004C8A  3A0006     BRA NZ, 0x4C98
744:                       OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
004C8C  90001E     MOV [W14+2], W0
004C8E  906060     MOV.B [W0+38], W0
004C90  EAC080     COM.B W0, W1
004C92  BFC86F     MOV.B OSRdyGrp, WREG
004C94  60C000     AND.B W1, W0, W0
004C96  B7E86F     MOV.B WREG, OSRdyGrp
745:                   }
746:                   ptcb->OSTCBPrio         = prio;
004C98  90001E     MOV [W14+2], W0
004C9A  90414E     MOV.B [W14+4], W2
004C9C  986022     MOV.B W2, [W0+34]
747:                   OSPrioCur               = prio;                        /* The current task is now at this priority */
004C9E  9040CE     MOV.B [W14+4], W1
004CA0  2086D3     MOV #0x86D, W3
004CA2  784981     MOV.B W1, [W3]
748:               #if OS_LOWEST_PRIO <= 63u
749:                   ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
004CA4  90404E     MOV.B [W14+4], W0
004CA6  FB8000     ZE W0, W0
004CA8  DE0043     LSR W0, #3, W0
004CAA  784000     MOV.B W0, W0
004CAC  6040E7     AND.B W0, #0x7, W1
004CAE  90001E     MOV [W14+2], W0
004CB0  986041     MOV.B W1, [W0+36]
750:                   ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
004CB2  90404E     MOV.B [W14+4], W0
004CB4  6040E7     AND.B W0, #0x7, W1
004CB6  90001E     MOV [W14+2], W0
004CB8  986031     MOV.B W1, [W0+35]
751:               #else
752:                   ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
753:                   ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
754:               #endif
755:                   ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
004CBA  90001E     MOV [W14+2], W0
004CBC  906040     MOV.B [W0+36], W0
004CBE  FB8100     ZE W0, W2
004CC0  200010     MOV #0x1, W0
004CC2  200001     MOV #0x0, W1
004CC4  780182     MOV W2, W3
004CC6  E90183     DEC W3, W3
004CC8  330003     BRA N, 0x4CD0
004CCA  400000     ADD W0, W0, W0
004CCC  488081     ADDC W1, W1, W1
004CCE  37FFFB     BRA 0x4CC6
004CD0  784080     MOV.B W0, W1
004CD2  90001E     MOV [W14+2], W0
004CD4  986061     MOV.B W1, [W0+38]
756:                   ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
004CD6  90001E     MOV [W14+2], W0
004CD8  906030     MOV.B [W0+35], W0
004CDA  FB8100     ZE W0, W2
004CDC  200010     MOV #0x1, W0
004CDE  200001     MOV #0x0, W1
004CE0  780182     MOV W2, W3
004CE2  E90183     DEC W3, W3
004CE4  330003     BRA N, 0x4CEC
004CE6  400000     ADD W0, W0, W0
004CE8  488081     ADDC W1, W1, W1
004CEA  37FFFB     BRA 0x4CE2
004CEC  784080     MOV.B W0, W1
004CEE  90001E     MOV [W14+2], W0
004CF0  986051     MOV.B W1, [W0+37]
757:                   OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
004CF2  90001E     MOV [W14+2], W0
004CF4  9060E0     MOV.B [W0+38], W1
004CF6  BFC86F     MOV.B OSRdyGrp, WREG
004CF8  70C000     IOR.B W1, W0, W0
004CFA  B7E86F     MOV.B WREG, OSRdyGrp
758:                   OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
004CFC  90001E     MOV [W14+2], W0
004CFE  906040     MOV.B [W0+36], W0
004D00  FB8000     ZE W0, W0
004D02  90009E     MOV [W14+2], W1
004D04  9060C1     MOV.B [W1+36], W1
004D06  FB8081     ZE W1, W1
004D08  209402     MOV #0x940, W2
004D0A  78C162     MOV.B [W2+W1], W2
004D0C  90009E     MOV [W14+2], W1
004D0E  9060D1     MOV.B [W1+37], W1
004D10  714101     IOR.B W2, W1, W2
004D12  209401     MOV #0x940, W1
004D14  787082     MOV.B W2, [W1+W0]
759:                   OSTCBPrioTbl[prio]      = ptcb;
004D16  90404E     MOV.B [W14+4], W0
004D18  FB8000     ZE W0, W0
004D1A  400080     ADD W0, W0, W1
004D1C  209C20     MOV #0x9C2, W0
004D1E  408000     ADD W1, W0, W0
004D20  90009E     MOV [W14+2], W1
004D22  780801     MOV W1, [W0]
760:               }
004D24  FA8000     ULNK
761:               
762:               
763:               #endif                                                     /* OS_MUTEX_EN                              */
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_mbox.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                       MESSAGE MAILBOX MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_MBOX.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if OS_MBOX_EN > 0u
31:                /*
32:                *********************************************************************************************************
33:                *                                        ACCEPT MESSAGE FROM MAILBOX
34:                *
35:                * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
36:                *              OSMboxAccept() does not suspend the calling task if a message is not available.
37:                *
38:                * Arguments  : pevent        is a pointer to the event control block
39:                *
40:                * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
41:                *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
42:                *              == (void *)0  if the mailbox is empty or,
43:                *                            if 'pevent' is a NULL pointer or,
44:                *                            if you didn't pass the proper event pointer.
45:                *********************************************************************************************************
46:                */
47:                
48:                #if OS_MBOX_ACCEPT_EN > 0u
49:                void  *OSMboxAccept (OS_EVENT *pevent)
50:                {
0054DC  FA0006     LNK #0x6
0054DE  980720     MOV W0, [W14+4]
51:                    void      *pmsg;
52:                #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
53:                    OS_CPU_SR  cpu_sr = 0u;
0054E0  EB0000     CLR W0
0054E2  780F00     MOV W0, [W14]
54:                #endif
55:                
56:                
57:                
58:                #if OS_ARG_CHK_EN > 0u
59:                    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
0054E4  90002E     MOV [W14+4], W0
0054E6  E00000     CP0 W0
0054E8  3A0002     BRA NZ, 0x54EE
60:                        return ((void *)0);
0054EA  EB0000     CLR W0
0054EC  370015     BRA 0x5518
61:                    }
62:                #endif
63:                    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
0054EE  90002E     MOV [W14+4], W0
0054F0  784010     MOV.B [W0], W0
0054F2  504FE1     SUB.B W0, #0x1, [W15]
0054F4  320002     BRA Z, 0x54FA
64:                        return ((void *)0);
0054F6  EB0000     CLR W0
0054F8  37000F     BRA 0x5518
65:                    }
66:                    OS_ENTER_CRITICAL();
0054FA  800211     MOV SR, W1
0054FC  780F01     MOV W1, [W14]
0054FE  800211     MOV SR, W1
005500  200E00     MOV #0xE0, W0
005502  700001     IOR W0, W1, W0
005504  880210     MOV W0, SR
67:                    pmsg               = pevent->OSEventPtr;
005506  90002E     MOV [W14+4], W0
005508  900090     MOV [W0+2], W1
00550A  980711     MOV W1, [W14+2]
68:                    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
00550C  90002E     MOV [W14+4], W0
00550E  EB0080     CLR W1
005510  980011     MOV W1, [W0+2]
69:                    OS_EXIT_CRITICAL();
005512  78009E     MOV [W14], W1
005514  880211     MOV W1, SR
70:                    return (pmsg);                                        /* Return the message received (or NULL)     */
005516  90001E     MOV [W14+2], W0
71:                }
005518  FA8000     ULNK
00551A  060000     RETURN
72:                #endif
73:                /*$PAGE*/
74:                /*
75:                *********************************************************************************************************
76:                *                                          CREATE A MESSAGE MAILBOX
77:                *
78:                * Description: This function creates a message mailbox if free event control blocks are available.
79:                *
80:                * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
81:                *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
82:                *                            will be considered empty.
83:                *
84:                * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
85:                *                                created mailbox
86:                *              == (OS_EVENT *)0  if no event control blocks were available
87:                *********************************************************************************************************
88:                */
89:                
90:                OS_EVENT  *OSMboxCreate (void *pmsg)
91:                {
00551C  FA0006     LNK #0x6
00551E  980720     MOV W0, [W14+4]
92:                    OS_EVENT  *pevent;
93:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
94:                    OS_CPU_SR  cpu_sr = 0u;
005520  EB0000     CLR W0
005522  780F00     MOV W0, [W14]
95:                #endif
96:                
97:                
98:                
99:                #ifdef OS_SAFETY_CRITICAL_IEC61508
100:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
101:                       OS_SAFETY_CRITICAL_EXCEPTION();
102:                       return ((OS_EVENT *)0);
103:                   }
104:               #endif
105:               
106:                   if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
005524  BFC86B     MOV.B OSIntNesting, WREG
005526  E00400     CP0.B W0
005528  320002     BRA Z, 0x552E
107:                       return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00552A  EB0000     CLR W0
00552C  370022     BRA 0x5572
108:                   }
109:                   OS_ENTER_CRITICAL();
00552E  800211     MOV SR, W1
005530  780F01     MOV W1, [W14]
005532  800211     MOV SR, W1
005534  200E00     MOV #0xE0, W0
005536  700001     IOR W0, W1, W0
005538  880210     MOV W0, SR
110:                   pevent = OSEventFreeList;                    /* Get next free event control block                  */
00553A  8042A1     MOV OSEventFreeList, W1
00553C  980711     MOV W1, [W14+2]
111:                   if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
00553E  8042A0     MOV OSEventFreeList, W0
005540  E00000     CP0 W0
005542  320003     BRA Z, 0x554A
112:                       OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
005544  8042A0     MOV OSEventFreeList, W0
005546  900010     MOV [W0+2], W0
005548  8842A0     MOV W0, OSEventFreeList
113:                   }
114:                   OS_EXIT_CRITICAL();
00554A  78009E     MOV [W14], W1
00554C  880211     MOV W1, SR
115:                   if (pevent != (OS_EVENT *)0) {
00554E  90001E     MOV [W14+2], W0
005550  E00000     CP0 W0
005552  32000E     BRA Z, 0x5570
116:                       pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
005554  90001E     MOV [W14+2], W0
005556  B3C011     MOV.B #0x1, W1
005558  784801     MOV.B W1, [W0]
117:                       pevent->OSEventCnt     = 0u;
00555A  90001E     MOV [W14+2], W0
00555C  EB0080     CLR W1
00555E  980021     MOV W1, [W0+4]
118:                       pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
005560  90001E     MOV [W14+2], W0
005562  9000AE     MOV [W14+4], W1
005564  980011     MOV W1, [W0+2]
119:               #if OS_EVENT_NAME_EN > 0u
120:                       pevent->OSEventName    = (INT8U *)(void *)"?";
005566  2883E1     MOV #0x883E, W1
005568  90001E     MOV [W14+2], W0
00556A  980051     MOV W1, [W0+10]
121:               #endif
122:                       OS_EventWaitListInit(pevent);
00556C  90001E     MOV [W14+2], W0
00556E  07DDF2     RCALL OS_EventWaitListInit
123:                   }
124:                   return (pevent);                             /* Return pointer to event control block              */
005570  90001E     MOV [W14+2], W0
125:               }
005572  FA8000     ULNK
005574  060000     RETURN
126:               /*$PAGE*/
127:               /*
128:               *********************************************************************************************************
129:               *                                           DELETE A MAIBOX
130:               *
131:               * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
132:               *
133:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
134:               *                            mailbox.
135:               *
136:               *              opt           determines delete options as follows:
137:               *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
138:               *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
139:               *                                                    In this case, all the tasks pending will be readied.
140:               *
141:               *              perr          is a pointer to an error code that can contain one of the following values:
142:               *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
143:               *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
144:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
145:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
146:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
147:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
148:               *
149:               * Returns    : pevent        upon error
150:               *              (OS_EVENT *)0 if the mailbox was successfully deleted.
151:               *
152:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
153:               *                 the mailbox MUST check the return code of OSMboxPend().
154:               *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
155:               *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
156:               *                 time is directly proportional to the number of tasks waiting on the mailbox.
157:               *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
158:               *                 applications where the mailbox is used for mutual exclusion because the resource(s)
159:               *                 will no longer be guarded by the mailbox.
160:               *              5) All tasks that were waiting for the mailbox will be readied and returned an 
161:               *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
162:               *********************************************************************************************************
163:               */
164:               
165:               #if OS_MBOX_DEL_EN > 0u
166:               OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
167:                                     INT8U      opt,
168:                                     INT8U     *perr)
169:               {
005576  FA000C     LNK #0xC
005578  980730     MOV W0, [W14+6]
00557A  984F01     MOV.B W1, [W14+8]
00557C  980752     MOV W2, [W14+10]
170:                   BOOLEAN    tasks_waiting;
171:                   OS_EVENT  *pevent_return;
172:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
173:                   OS_CPU_SR  cpu_sr = 0u;
00557E  EB0000     CLR W0
005580  980720     MOV W0, [W14+4]
174:               #endif
175:               
176:               
177:               
178:               #ifdef OS_SAFETY_CRITICAL
179:                   if (perr == (INT8U *)0) {
180:                       OS_SAFETY_CRITICAL_EXCEPTION();
181:                       return ((OS_EVENT *)0);
182:                   }
183:               #endif
184:               
185:               #if OS_ARG_CHK_EN > 0u
186:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
005582  90003E     MOV [W14+6], W0
005584  E00000     CP0 W0
005586  3A0005     BRA NZ, 0x5592
187:                       *perr = OS_ERR_PEVENT_NULL;
005588  90005E     MOV [W14+10], W0
00558A  B3C041     MOV.B #0x4, W1
00558C  784801     MOV.B W1, [W0]
188:                       return (pevent);
00558E  90003E     MOV [W14+6], W0
005590  370076     BRA 0x567E
189:                   }
190:               #endif
191:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
005592  90003E     MOV [W14+6], W0
005594  784010     MOV.B [W0], W0
005596  504FE1     SUB.B W0, #0x1, [W15]
005598  320005     BRA Z, 0x55A4
192:                       *perr = OS_ERR_EVENT_TYPE;
00559A  90005E     MOV [W14+10], W0
00559C  B3C011     MOV.B #0x1, W1
00559E  784801     MOV.B W1, [W0]
193:                       return (pevent);
0055A0  90003E     MOV [W14+6], W0
0055A2  37006D     BRA 0x567E
194:                   }
195:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0055A4  BFC86B     MOV.B OSIntNesting, WREG
0055A6  E00400     CP0.B W0
0055A8  320005     BRA Z, 0x55B4
196:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0055AA  90005E     MOV [W14+10], W0
0055AC  B3C0F1     MOV.B #0xF, W1
0055AE  784801     MOV.B W1, [W0]
197:                       return (pevent);
0055B0  90003E     MOV [W14+6], W0
0055B2  370065     BRA 0x567E
198:                   }
199:                   OS_ENTER_CRITICAL();
0055B4  800211     MOV SR, W1
0055B6  980721     MOV W1, [W14+4]
0055B8  800211     MOV SR, W1
0055BA  200E00     MOV #0xE0, W0
0055BC  700001     IOR W0, W1, W0
0055BE  880210     MOV W0, SR
200:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
0055C0  90003E     MOV [W14+6], W0
0055C2  904060     MOV.B [W0+6], W0
0055C4  E00400     CP0.B W0
0055C6  320003     BRA Z, 0x55CE
201:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
0055C8  B3C010     MOV.B #0x1, W0
0055CA  784F00     MOV.B W0, [W14]
0055CC  370002     BRA 0x55D2
202:                   } else {
203:                       tasks_waiting = OS_FALSE;                          /* No                                       */
0055CE  EB4000     CLR.B W0
0055D0  784F00     MOV.B W0, [W14]
204:                   }
205:                   switch (opt) {
0055D2  90480E     MOV.B [W14+8], W0
0055D4  FB8000     ZE W0, W0
0055D6  E00000     CP0 W0
0055D8  320003     BRA Z, 0x55E0
0055DA  500FE1     SUB W0, #0x1, [W15]
0055DC  320028     BRA Z, 0x562E
0055DE  370046     BRA 0x566C
206:                       case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
207:                            if (tasks_waiting == OS_FALSE) {
0055E0  78401E     MOV.B [W14], W0
0055E2  E00400     CP0.B W0
0055E4  3A0016     BRA NZ, 0x5612
208:               #if OS_EVENT_NAME_EN > 0u
209:                                pevent->OSEventName = (INT8U *)(void *)"?";
0055E6  2883E1     MOV #0x883E, W1
0055E8  90003E     MOV [W14+6], W0
0055EA  980051     MOV W1, [W0+10]
210:               #endif
211:                                pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
0055EC  90003E     MOV [W14+6], W0
0055EE  EB4080     CLR.B W1
0055F0  784801     MOV.B W1, [W0]
212:                                pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
0055F2  8042A1     MOV OSEventFreeList, W1
0055F4  90003E     MOV [W14+6], W0
0055F6  980011     MOV W1, [W0+2]
213:                                pevent->OSEventCnt  = 0u;
0055F8  90003E     MOV [W14+6], W0
0055FA  EB0080     CLR W1
0055FC  980021     MOV W1, [W0+4]
214:                                OSEventFreeList     = pevent;             /* Get next free event control block        */
0055FE  9000BE     MOV [W14+6], W1
005600  8842A1     MOV W1, OSEventFreeList
215:                                OS_EXIT_CRITICAL();
005602  9000AE     MOV [W14+4], W1
005604  880211     MOV W1, SR
216:                                *perr               = OS_ERR_NONE;
005606  90005E     MOV [W14+10], W0
005608  EB4080     CLR.B W1
00560A  784801     MOV.B W1, [W0]
217:                                pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
00560C  EB0000     CLR W0
00560E  980710     MOV W0, [W14+2]
218:                            } else {
219:                                OS_EXIT_CRITICAL();
005612  9000AE     MOV [W14+4], W1
005614  880211     MOV W1, SR
220:                                *perr               = OS_ERR_TASK_WAITING;
005616  90005E     MOV [W14+10], W0
005618  B3C491     MOV.B #0x49, W1
00561A  784801     MOV.B W1, [W0]
221:                                pevent_return       = pevent;
00561C  9000BE     MOV [W14+6], W1
00561E  980711     MOV W1, [W14+2]
222:                            }
223:                            break;
005610  370035     BRA 0x567C
005620  37002D     BRA 0x567C
224:               
225:                       case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
226:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
00562E  000000     NOP
005630  90003E     MOV [W14+6], W0
005632  904060     MOV.B [W0+6], W0
005634  E00400     CP0.B W0
005636  3AFFF5     BRA NZ, 0x5622
227:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
005622  B3C023     MOV.B #0x2, W3
005624  B3C022     MOV.B #0x2, W2
005626  EB0080     CLR W1
005628  90003E     MOV [W14+6], W0
00562A  07DC5F     RCALL OS_EventTaskRdy
00562C  370001     BRA 0x5630
228:                            }
229:               #if OS_EVENT_NAME_EN > 0u
230:                            pevent->OSEventName    = (INT8U *)(void *)"?";
005638  2883E1     MOV #0x883E, W1
00563A  90003E     MOV [W14+6], W0
00563C  980051     MOV W1, [W0+10]
231:               #endif
232:                            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00563E  90003E     MOV [W14+6], W0
005640  EB4080     CLR.B W1
005642  784801     MOV.B W1, [W0]
233:                            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
005644  8042A1     MOV OSEventFreeList, W1
005646  90003E     MOV [W14+6], W0
005648  980011     MOV W1, [W0+2]
234:                            pevent->OSEventCnt     = 0u;
00564A  90003E     MOV [W14+6], W0
00564C  EB0080     CLR W1
00564E  980021     MOV W1, [W0+4]
235:                            OSEventFreeList        = pevent;              /* Get next free event control block        */
005650  9000BE     MOV [W14+6], W1
005652  8842A1     MOV W1, OSEventFreeList
236:                            OS_EXIT_CRITICAL();
005654  9000AE     MOV [W14+4], W1
005656  880211     MOV W1, SR
237:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
005658  78401E     MOV.B [W14], W0
00565A  504FE1     SUB.B W0, #0x1, [W15]
00565C  3A0001     BRA NZ, 0x5660
238:                                OS_Sched();                               /* Find highest priority task ready to run  */
00565E  07DE68     RCALL OS_Sched
239:                            }
240:                            *perr         = OS_ERR_NONE;
005660  90005E     MOV [W14+10], W0
005662  EB4080     CLR.B W1
005664  784801     MOV.B W1, [W0]
241:                            pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
005666  EB0000     CLR W0
005668  980710     MOV W0, [W14+2]
242:                            break;
00566A  370008     BRA 0x567C
243:               
244:                       default:
245:                            OS_EXIT_CRITICAL();
00566C  9000AE     MOV [W14+4], W1
00566E  880211     MOV W1, SR
246:                            *perr         = OS_ERR_INVALID_OPT;
005670  90005E     MOV [W14+10], W0
005672  B3C071     MOV.B #0x7, W1
005674  784801     MOV.B W1, [W0]
247:                            pevent_return = pevent;
005676  9000BE     MOV [W14+6], W1
005678  980711     MOV W1, [W14+2]
248:                            break;
00567A  000000     NOP
249:                   }
250:                   return (pevent_return);
00567C  90001E     MOV [W14+2], W0
251:               }
00567E  FA8000     ULNK
005680  060000     RETURN
252:               #endif
253:               
254:               /*$PAGE*/
255:               /*
256:               *********************************************************************************************************
257:               *                                    PEND ON MAILBOX FOR A MESSAGE
258:               *
259:               * Description: This function waits for a message to be sent to a mailbox
260:               *
261:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
262:               *
263:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
264:               *                            wait for a message to arrive at the mailbox up to the amount of time
265:               *                            specified by this argument.  If you specify 0, however, your task will wait
266:               *                            forever at the specified mailbox or, until a message arrives.
267:               *
268:               *              perr          is a pointer to where an error message will be deposited.  Possible error
269:               *                            messages are:
270:               *
271:               *                            OS_ERR_NONE         The call was successful and your task received a
272:               *                                                message.
273:               *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
274:               *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
275:               *                            OS_ERR_EVENT_TYPE   Invalid event type
276:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
277:               *                                                would lead to a suspension.
278:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
279:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
280:               *
281:               * Returns    : != (void *)0  is a pointer to the message received
282:               *              == (void *)0  if no message was received or,
283:               *                            if 'pevent' is a NULL pointer or,
284:               *                            if you didn't pass the proper pointer to the event control block.
285:               *********************************************************************************************************
286:               */
287:               /*$PAGE*/
288:               void  *OSMboxPend (OS_EVENT  *pevent,
289:                                  INT32U     timeout,
290:                                  INT8U     *perr)
291:               {
005682  FA000C     LNK #0xC
005684  980720     MOV W0, [W14+4]
005686  980732     MOV W2, [W14+6]
005688  980743     MOV W3, [W14+8]
00568A  980751     MOV W1, [W14+10]
292:                   void      *pmsg;
293:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
294:                   OS_CPU_SR  cpu_sr = 0u;
00568C  EB0000     CLR W0
00568E  980710     MOV W0, [W14+2]
295:               #endif
296:               
297:               
298:               
299:               #ifdef OS_SAFETY_CRITICAL
300:                   if (perr == (INT8U *)0) {
301:                       OS_SAFETY_CRITICAL_EXCEPTION();
302:                       return ((void *)0);
303:                   }
304:               #endif
305:               
306:               #if OS_ARG_CHK_EN > 0u
307:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005690  90002E     MOV [W14+4], W0
005692  E00000     CP0 W0
005694  3A0005     BRA NZ, 0x56A0
308:                       *perr = OS_ERR_PEVENT_NULL;
005696  90005E     MOV [W14+10], W0
005698  B3C041     MOV.B #0x4, W1
00569A  784801     MOV.B W1, [W0]
309:                       return ((void *)0);
00569C  EB0000     CLR W0
00569E  370077     BRA 0x578E
310:                   }
311:               #endif
312:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
0056A0  90002E     MOV [W14+4], W0
0056A2  784010     MOV.B [W0], W0
0056A4  504FE1     SUB.B W0, #0x1, [W15]
0056A6  320005     BRA Z, 0x56B2
313:                       *perr = OS_ERR_EVENT_TYPE;
0056A8  90005E     MOV [W14+10], W0
0056AA  B3C011     MOV.B #0x1, W1
0056AC  784801     MOV.B W1, [W0]
314:                       return ((void *)0);
0056AE  EB0000     CLR W0
0056B0  37006E     BRA 0x578E
315:                   }
316:                   if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0056B2  BFC86B     MOV.B OSIntNesting, WREG
0056B4  E00400     CP0.B W0
0056B6  320005     BRA Z, 0x56C2
317:                       *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
0056B8  90005E     MOV [W14+10], W0
0056BA  B3C021     MOV.B #0x2, W1
0056BC  784801     MOV.B W1, [W0]
318:                       return ((void *)0);
0056BE  EB0000     CLR W0
0056C0  370066     BRA 0x578E
319:                   }
320:                   if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
0056C2  BFC86C     MOV.B OSLockNesting, WREG
0056C4  E00400     CP0.B W0
0056C6  320005     BRA Z, 0x56D2
321:                       *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
0056C8  90005E     MOV [W14+10], W0
0056CA  B3C0D1     MOV.B #0xD, W1
0056CC  784801     MOV.B W1, [W0]
322:                       return ((void *)0);
0056CE  EB0000     CLR W0
0056D0  37005E     BRA 0x578E
323:                   }
324:                   OS_ENTER_CRITICAL();
0056D2  800211     MOV SR, W1
0056D4  980711     MOV W1, [W14+2]
0056D6  800211     MOV SR, W1
0056D8  200E00     MOV #0xE0, W0
0056DA  700001     IOR W0, W1, W0
0056DC  880210     MOV W0, SR
325:                   pmsg = pevent->OSEventPtr;
0056DE  90002E     MOV [W14+4], W0
0056E0  900110     MOV [W0+2], W2
0056E2  780F02     MOV W2, [W14]
326:                   if (pmsg != (void *)0) {                          /* See if there is already a message             */
0056E4  78001E     MOV [W14], W0
0056E6  E00000     CP0 W0
0056E8  32000A     BRA Z, 0x56FE
327:                       pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
0056EA  90002E     MOV [W14+4], W0
0056EC  EB0080     CLR W1
0056EE  980011     MOV W1, [W0+2]
328:                       OS_EXIT_CRITICAL();
0056F0  90019E     MOV [W14+2], W3
0056F2  880213     MOV W3, SR
329:                       *perr = OS_ERR_NONE;
0056F4  90005E     MOV [W14+10], W0
0056F6  EB4080     CLR.B W1
0056F8  784801     MOV.B W1, [W0]
330:                       return (pmsg);                                /* Return the message received (or NULL)         */
0056FA  78001E     MOV [W14], W0
0056FC  370048     BRA 0x578E
331:                   }
332:                   OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
0056FE  8043B0     MOV OSTCBCur, W0
005700  8043B1     MOV OSTCBCur, W1
005702  906081     MOV.B [W1+32], W1
005704  A01401     BSET.B W1, #1
005706  986001     MOV.B W1, [W0+32]
333:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
005708  8043B0     MOV OSTCBCur, W0
00570A  EB4080     CLR.B W1
00570C  986011     MOV.B W1, [W0+33]
334:                   OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
00570E  8043B0     MOV OSTCBCur, W0
005710  90013E     MOV [W14+6], W2
005712  9001CE     MOV [W14+8], W3
005714  980862     MOV W2, [W0+28]
005716  980873     MOV W3, [W0+30]
335:                   OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
005718  90002E     MOV [W14+4], W0
00571A  07DC3E     RCALL OS_EventTaskWait
336:                   OS_EXIT_CRITICAL();
00571C  90019E     MOV [W14+2], W3
00571E  880213     MOV W3, SR
337:                   OS_Sched();                                       /* Find next highest priority task ready to run  */
005720  07DE07     RCALL OS_Sched
338:                   OS_ENTER_CRITICAL();
005722  800211     MOV SR, W1
005724  980711     MOV W1, [W14+2]
005726  800211     MOV SR, W1
005728  200E00     MOV #0xE0, W0
00572A  700001     IOR W0, W1, W0
00572C  880210     MOV W0, SR
339:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00572E  8043B0     MOV OSTCBCur, W0
005730  906010     MOV.B [W0+33], W0
005732  FB8000     ZE W0, W0
005734  E00000     CP0 W0
005736  320003     BRA Z, 0x573E
005738  500FE2     SUB W0, #0x2, [W15]
00573A  320008     BRA Z, 0x574C
00573C  37000D     BRA 0x5758
340:                       case OS_STAT_PEND_OK:
341:                            pmsg =  OSTCBCur->OSTCBMsg;
00573E  8043B0     MOV OSTCBCur, W0
005740  900930     MOV [W0+22], W2
005742  780F02     MOV W2, [W14]
342:                           *perr =  OS_ERR_NONE;
005744  90005E     MOV [W14+10], W0
005746  EB4080     CLR.B W1
005748  784801     MOV.B W1, [W0]
343:                            break;
00574A  37000F     BRA 0x576A
344:               
345:                       case OS_STAT_PEND_ABORT:
346:                            pmsg = (void *)0;
00574C  EB0000     CLR W0
00574E  780F00     MOV W0, [W14]
347:                           *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
005750  90005E     MOV [W14+10], W0
005752  B3C0E1     MOV.B #0xE, W1
005754  784801     MOV.B W1, [W0]
348:                            break;
005756  370009     BRA 0x576A
349:               
350:                       case OS_STAT_PEND_TO:
351:                       default:
352:                            OS_EventTaskRemove(OSTCBCur, pevent);
005758  8043B0     MOV OSTCBCur, W0
00575A  9000AE     MOV [W14+4], W1
00575C  07DC9C     RCALL OS_EventTaskRemove
353:                            pmsg = (void *)0;
00575E  EB0000     CLR W0
005760  780F00     MOV W0, [W14]
354:                           *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
005762  90005E     MOV [W14+10], W0
005764  B3C0A1     MOV.B #0xA, W1
005766  784801     MOV.B W1, [W0]
355:                            break;
005768  000000     NOP
356:                   }
357:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00576A  8043B0     MOV OSTCBCur, W0
00576C  EB4080     CLR.B W1
00576E  986001     MOV.B W1, [W0+32]
358:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
005770  8043B0     MOV OSTCBCur, W0
005772  EB4080     CLR.B W1
005774  986011     MOV.B W1, [W0+33]
359:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
005776  8043B0     MOV OSTCBCur, W0
005778  EB0080     CLR W1
00577A  980811     MOV W1, [W0+18]
360:               #if (OS_EVENT_MULTI_EN > 0u)
361:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00577C  8043B0     MOV OSTCBCur, W0
00577E  EB0080     CLR W1
005780  980821     MOV W1, [W0+20]
362:               #endif
363:                   OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
005782  8043B0     MOV OSTCBCur, W0
005784  EB0080     CLR W1
005786  980831     MOV W1, [W0+22]
364:                   OS_EXIT_CRITICAL();
005788  90019E     MOV [W14+2], W3
00578A  880213     MOV W3, SR
365:                   return (pmsg);                                    /* Return received message                       */
00578C  78001E     MOV [W14], W0
366:               }
00578E  FA8000     ULNK
005790  060000     RETURN
367:               /*$PAGE*/
368:               /*
369:               *********************************************************************************************************
370:               *                                     ABORT WAITING ON A MESSAGE MAILBOX
371:               *
372:               * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
373:               *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
374:               *              the mailbox via OSMboxPost() or OSMboxPostOpt().
375:               *
376:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
377:               *
378:               *              opt           determines the type of ABORT performed:
379:               *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
380:               *                                                     mailbox
381:               *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
382:               *                                                     mailbox
383:               *
384:               *              perr          is a pointer to where an error message will be deposited.  Possible error
385:               *                            messages are:
386:               *
387:               *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
388:               *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
389:               *                                                and informed of the aborted wait; check return value
390:               *                                                for the number of tasks whose wait on the mailbox
391:               *                                                was aborted.
392:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
393:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
394:               *
395:               * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
396:               *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
397:               *********************************************************************************************************
398:               */
399:               
400:               #if OS_MBOX_PEND_ABORT_EN > 0u
401:               INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
402:                                       INT8U      opt,
403:                                       INT8U     *perr)
404:               {
005792  FA000A     LNK #0xA
005794  980720     MOV W0, [W14+4]
005796  984761     MOV.B W1, [W14+6]
005798  980742     MOV W2, [W14+8]
405:                   INT8U      nbr_tasks;
406:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
407:                   OS_CPU_SR  cpu_sr = 0u;
00579A  EB0000     CLR W0
00579C  980710     MOV W0, [W14+2]
408:               #endif
409:               
410:               
411:               
412:               #ifdef OS_SAFETY_CRITICAL
413:                   if (perr == (INT8U *)0) {
414:                       OS_SAFETY_CRITICAL_EXCEPTION();
415:                       return (0u);
416:                   }
417:               #endif
418:               
419:               #if OS_ARG_CHK_EN > 0u
420:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
00579E  90002E     MOV [W14+4], W0
0057A0  E00000     CP0 W0
0057A2  3A0005     BRA NZ, 0x57AE
421:                       *perr = OS_ERR_PEVENT_NULL;
0057A4  90004E     MOV [W14+8], W0
0057A6  B3C041     MOV.B #0x4, W1
0057A8  784801     MOV.B W1, [W0]
422:                       return (0u);
0057AA  EB4000     CLR.B W0
0057AC  37003C     BRA 0x5826
423:                   }
424:               #endif
425:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
0057AE  90002E     MOV [W14+4], W0
0057B0  784010     MOV.B [W0], W0
0057B2  504FE1     SUB.B W0, #0x1, [W15]
0057B4  320005     BRA Z, 0x57C0
426:                       *perr = OS_ERR_EVENT_TYPE;
0057B6  90004E     MOV [W14+8], W0
0057B8  B3C011     MOV.B #0x1, W1
0057BA  784801     MOV.B W1, [W0]
427:                       return (0u);
0057BC  EB4000     CLR.B W0
0057BE  370033     BRA 0x5826
428:                   }
429:                   OS_ENTER_CRITICAL();
0057C0  800211     MOV SR, W1
0057C2  980711     MOV W1, [W14+2]
0057C4  800211     MOV SR, W1
0057C6  200E00     MOV #0xE0, W0
0057C8  700001     IOR W0, W1, W0
0057CA  880210     MOV W0, SR
430:                   if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
0057CC  90002E     MOV [W14+4], W0
0057CE  904060     MOV.B [W0+6], W0
0057D0  E00400     CP0.B W0
0057D2  320023     BRA Z, 0x581A
431:                       nbr_tasks = 0u;
0057D4  EB4000     CLR.B W0
0057D6  784F00     MOV.B W0, [W14]
432:                       switch (opt) {
0057D8  90406E     MOV.B [W14+6], W0
0057DA  FB8000     ZE W0, W0
0057DC  500FE1     SUB W0, #0x1, [W15]
0057DE  320008     BRA Z, 0x57F0
0057E0  37000D     BRA 0x57FC
433:                           case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
434:                                while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
0057F0  000000     NOP
0057F2  90002E     MOV [W14+4], W0
0057F4  904060     MOV.B [W0+6], W0
0057F6  E00400     CP0.B W0
0057F8  3AFFF4     BRA NZ, 0x57E2
435:                                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
0057E2  B3C023     MOV.B #0x2, W3
0057E4  B3C022     MOV.B #0x2, W2
0057E6  EB0080     CLR W1
0057E8  90002E     MOV [W14+4], W0
0057EA  07DB7F     RCALL OS_EventTaskRdy
436:                                    nbr_tasks++;
0057EC  E84F1E     INC.B [W14], [W14]
0057EE  370001     BRA 0x57F2
437:                                }
438:                                break;
0057FA  370007     BRA 0x580A
439:               
440:                           case OS_PEND_OPT_NONE:
441:                           default:                                       /* No,  ready HPT       waiting on mailbox  */
442:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
0057FC  B3C023     MOV.B #0x2, W3
0057FE  B3C022     MOV.B #0x2, W2
005800  EB0080     CLR W1
005802  90002E     MOV [W14+4], W0
005804  07DB72     RCALL OS_EventTaskRdy
443:                                nbr_tasks++;
005806  E84F1E     INC.B [W14], [W14]
444:                                break;
005808  000000     NOP
445:                       }
446:                       OS_EXIT_CRITICAL();
00580A  90009E     MOV [W14+2], W1
00580C  880211     MOV W1, SR
447:                       OS_Sched();                                        /* Find HPT ready to run                    */
00580E  07DD90     RCALL OS_Sched
448:                       *perr = OS_ERR_PEND_ABORT;
005810  90004E     MOV [W14+8], W0
005812  B3C0E1     MOV.B #0xE, W1
005814  784801     MOV.B W1, [W0]
449:                       return (nbr_tasks);
005816  78401E     MOV.B [W14], W0
005818  370006     BRA 0x5826
450:                   }
451:                   OS_EXIT_CRITICAL();
00581A  90009E     MOV [W14+2], W1
00581C  880211     MOV W1, SR
452:                   *perr = OS_ERR_NONE;
00581E  90004E     MOV [W14+8], W0
005820  EB4080     CLR.B W1
005822  784801     MOV.B W1, [W0]
453:                   return (0u);                                           /* No tasks waiting on mailbox              */
005824  EB4000     CLR.B W0
454:               }
005826  FA8000     ULNK
005828  060000     RETURN
455:               #endif
456:               
457:               /*$PAGE*/
458:               /*
459:               *********************************************************************************************************
460:               *                                      POST MESSAGE TO A MAILBOX
461:               *
462:               * Description: This function sends a message to a mailbox
463:               *
464:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
465:               *
466:               *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
467:               *
468:               * Returns    : OS_ERR_NONE          The call was successful and the message was sent
469:               *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
470:               *                                   message at a time and thus, the message MUST be consumed before you
471:               *                                   are allowed to send another one.
472:               *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
473:               *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
474:               *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
475:               *
476:               * Note(s)    : 1) HPT means Highest Priority Task
477:               *********************************************************************************************************
478:               */
479:               
480:               #if OS_MBOX_POST_EN > 0u
481:               INT8U  OSMboxPost (OS_EVENT  *pevent,
482:                                  void      *pmsg)
483:               {
00582A  FA0006     LNK #0x6
00582C  980710     MOV W0, [W14+2]
00582E  980721     MOV W1, [W14+4]
484:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
485:                   OS_CPU_SR  cpu_sr = 0u;
005830  EB0000     CLR W0
005832  780F00     MOV W0, [W14]
486:               #endif
487:               
488:               
489:               
490:               #if OS_ARG_CHK_EN > 0u
491:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005834  90001E     MOV [W14+2], W0
005836  E00000     CP0 W0
005838  3A0002     BRA NZ, 0x583E
492:                       return (OS_ERR_PEVENT_NULL);
00583A  B3C040     MOV.B #0x4, W0
00583C  37002D     BRA 0x5898
493:                   }
494:                   if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
00583E  90002E     MOV [W14+4], W0
005840  E00000     CP0 W0
005842  3A0002     BRA NZ, 0x5848
495:                       return (OS_ERR_POST_NULL_PTR);
005844  B3C030     MOV.B #0x3, W0
005846  370028     BRA 0x5898
496:                   }
497:               #endif
498:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
005848  90001E     MOV [W14+2], W0
00584A  784010     MOV.B [W0], W0
00584C  504FE1     SUB.B W0, #0x1, [W15]
00584E  320002     BRA Z, 0x5854
499:                       return (OS_ERR_EVENT_TYPE);
005850  B3C010     MOV.B #0x1, W0
005852  370022     BRA 0x5898
500:                   }
501:                   OS_ENTER_CRITICAL();
005854  800211     MOV SR, W1
005856  780F01     MOV W1, [W14]
005858  800211     MOV SR, W1
00585A  200E00     MOV #0xE0, W0
00585C  700001     IOR W0, W1, W0
00585E  880210     MOV W0, SR
502:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
005860  90001E     MOV [W14+2], W0
005862  904060     MOV.B [W0+6], W0
005864  E00400     CP0.B W0
005866  32000A     BRA Z, 0x587C
503:                                                                     /* Ready HPT waiting on event                    */
504:                       (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
005868  EB4180     CLR.B W3
00586A  B3C022     MOV.B #0x2, W2
00586C  9000AE     MOV [W14+4], W1
00586E  90001E     MOV [W14+2], W0
005870  07DB3C     RCALL OS_EventTaskRdy
505:                       OS_EXIT_CRITICAL();
005872  78009E     MOV [W14], W1
005874  880211     MOV W1, SR
506:                       OS_Sched();                                   /* Find highest priority task ready to run       */
005876  07DD5C     RCALL OS_Sched
507:                       return (OS_ERR_NONE);
005878  EB4000     CLR.B W0
00587A  37000E     BRA 0x5898
508:                   }
509:                   if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00587C  90001E     MOV [W14+2], W0
00587E  900010     MOV [W0+2], W0
005880  E00000     CP0 W0
005882  320004     BRA Z, 0x588C
510:                       OS_EXIT_CRITICAL();
005884  78009E     MOV [W14], W1
005886  880211     MOV W1, SR
511:                       return (OS_ERR_MBOX_FULL);
005888  B3C140     MOV.B #0x14, W0
00588A  370006     BRA 0x5898
512:                   }
513:                   pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00588C  90001E     MOV [W14+2], W0
00588E  9000AE     MOV [W14+4], W1
005890  980011     MOV W1, [W0+2]
514:                   OS_EXIT_CRITICAL();
005892  78009E     MOV [W14], W1
005894  880211     MOV W1, SR
515:                   return (OS_ERR_NONE);
005896  EB4000     CLR.B W0
516:               }
005898  FA8000     ULNK
00589A  060000     RETURN
517:               #endif
518:               
519:               /*$PAGE*/
520:               /*
521:               *********************************************************************************************************
522:               *                                      POST MESSAGE TO A MAILBOX
523:               *
524:               * Description: This function sends a message to a mailbox
525:               *
526:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
527:               *
528:               *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
529:               *
530:               *              opt           determines the type of POST performed:
531:               *                            OS_POST_OPT_NONE         POST to a single waiting task
532:               *                                                     (Identical to OSMboxPost())
533:               *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
534:               *
535:               *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
536:               *
537:               * Returns    : OS_ERR_NONE          The call was successful and the message was sent
538:               *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
539:               *                                   message at a time and thus, the message MUST be consumed before you
540:               *                                   are allowed to send another one.
541:               *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
542:               *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
543:               *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
544:               *
545:               * Note(s)    : 1) HPT means Highest Priority Task
546:               *
547:               * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
548:               *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
549:               *********************************************************************************************************
550:               */
551:               
552:               #if OS_MBOX_POST_OPT_EN > 0u
553:               INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
554:                                     void      *pmsg,
555:                                     INT8U      opt)
556:               {
00589C  FA0008     LNK #0x8
00589E  980710     MOV W0, [W14+2]
0058A0  980721     MOV W1, [W14+4]
0058A2  984762     MOV.B W2, [W14+6]
557:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
558:                   OS_CPU_SR  cpu_sr = 0u;
0058A4  EB0000     CLR W0
0058A6  780F00     MOV W0, [W14]
559:               #endif
560:               
561:               
562:               
563:               #if OS_ARG_CHK_EN > 0u
564:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0058A8  90001E     MOV [W14+2], W0
0058AA  E00000     CP0 W0
0058AC  3A0002     BRA NZ, 0x58B2
565:                       return (OS_ERR_PEVENT_NULL);
0058AE  B3C040     MOV.B #0x4, W0
0058B0  370043     BRA 0x5938
566:                   }
567:                   if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
0058B2  90002E     MOV [W14+4], W0
0058B4  E00000     CP0 W0
0058B6  3A0002     BRA NZ, 0x58BC
568:                       return (OS_ERR_POST_NULL_PTR);
0058B8  B3C030     MOV.B #0x3, W0
0058BA  37003E     BRA 0x5938
569:                   }
570:               #endif
571:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
0058BC  90001E     MOV [W14+2], W0
0058BE  784010     MOV.B [W0], W0
0058C0  504FE1     SUB.B W0, #0x1, [W15]
0058C2  320002     BRA Z, 0x58C8
572:                       return (OS_ERR_EVENT_TYPE);
0058C4  B3C010     MOV.B #0x1, W0
0058C6  370038     BRA 0x5938
573:                   }
574:                   OS_ENTER_CRITICAL();
0058C8  800211     MOV SR, W1
0058CA  780F01     MOV W1, [W14]
0058CC  800211     MOV SR, W1
0058CE  200E00     MOV #0xE0, W0
0058D0  700001     IOR W0, W1, W0
0058D2  880210     MOV W0, SR
575:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
0058D4  90001E     MOV [W14+2], W0
0058D6  904060     MOV.B [W0+6], W0
0058D8  E00400     CP0.B W0
0058DA  320020     BRA Z, 0x591C
576:                       if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
0058DC  90406E     MOV.B [W14+6], W0
0058DE  FB8000     ZE W0, W0
0058E0  600061     AND W0, #0x1, W0
0058E2  784000     MOV.B W0, W0
0058E4  E00400     CP0.B W0
0058E6  32000B     BRA Z, 0x58FE
577:                           while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
0058E8  370005     BRA 0x58F4
0058F4  90001E     MOV [W14+2], W0
0058F6  904060     MOV.B [W0+6], W0
0058F8  E00400     CP0.B W0
0058FA  3AFFF7     BRA NZ, 0x58EA
0058FC  370005     BRA 0x5908
578:                               (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
0058EA  EB4180     CLR.B W3
0058EC  B3C022     MOV.B #0x2, W2
0058EE  9000AE     MOV [W14+4], W1
0058F0  90001E     MOV [W14+2], W0
0058F2  07DAFB     RCALL OS_EventTaskRdy
579:                           }
580:                       } else {                                      /* No,  Post to HPT waiting on mbox              */
581:                           (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
0058FE  EB4180     CLR.B W3
005900  B3C022     MOV.B #0x2, W2
005902  9000AE     MOV [W14+4], W1
005904  90001E     MOV [W14+2], W0
005906  07DAF1     RCALL OS_EventTaskRdy
582:                       }
583:                       OS_EXIT_CRITICAL();
005908  78009E     MOV [W14], W1
00590A  880211     MOV W1, SR
584:                       if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00590C  90406E     MOV.B [W14+6], W0
00590E  FB8000     ZE W0, W0
005910  600064     AND W0, #0x4, W0
005912  E00000     CP0 W0
005914  3A0001     BRA NZ, 0x5918
585:                           OS_Sched();                               /* Find HPT ready to run                         */
005916  07DD0C     RCALL OS_Sched
586:                       }
587:                       return (OS_ERR_NONE);
005918  EB4000     CLR.B W0
00591A  37000E     BRA 0x5938
588:                   }
589:                   if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00591C  90001E     MOV [W14+2], W0
00591E  900010     MOV [W0+2], W0
005920  E00000     CP0 W0
005922  320004     BRA Z, 0x592C
590:                       OS_EXIT_CRITICAL();
005924  78009E     MOV [W14], W1
005926  880211     MOV W1, SR
591:                       return (OS_ERR_MBOX_FULL);
005928  B3C140     MOV.B #0x14, W0
00592A  370006     BRA 0x5938
592:                   }
593:                   pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00592C  90001E     MOV [W14+2], W0
00592E  9000AE     MOV [W14+4], W1
005930  980011     MOV W1, [W0+2]
594:                   OS_EXIT_CRITICAL();
005932  78009E     MOV [W14], W1
005934  880211     MOV W1, SR
595:                   return (OS_ERR_NONE);
005936  EB4000     CLR.B W0
596:               }
005938  FA8000     ULNK
00593A  060000     RETURN
597:               #endif
598:               
599:               /*$PAGE*/
600:               /*
601:               *********************************************************************************************************
602:               *                                       QUERY A MESSAGE MAILBOX
603:               *
604:               * Description: This function obtains information about a message mailbox.
605:               *
606:               * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
607:               *
608:               *              p_mbox_data   is a pointer to a structure that will contain information about the message
609:               *                            mailbox.
610:               *
611:               * Returns    : OS_ERR_NONE         The call was successful and the message was sent
612:               *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
613:               *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
614:               *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
615:               *********************************************************************************************************
616:               */
617:               
618:               #if OS_MBOX_QUERY_EN > 0u
619:               INT8U  OSMboxQuery (OS_EVENT      *pevent,
620:                                   OS_MBOX_DATA  *p_mbox_data)
621:               {
00593C  FA000C     LNK #0xC
00593E  980740     MOV W0, [W14+8]
005940  980751     MOV W1, [W14+10]
622:                   INT8U       i;
623:                   OS_PRIO    *psrc;
624:                   OS_PRIO    *pdest;
625:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
626:                   OS_CPU_SR   cpu_sr = 0u;
005942  EB0000     CLR W0
005944  980730     MOV W0, [W14+6]
627:               #endif
628:               
629:               
630:               
631:               #if OS_ARG_CHK_EN > 0u
632:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
005946  90004E     MOV [W14+8], W0
005948  E00000     CP0 W0
00594A  3A0002     BRA NZ, 0x5950
633:                       return (OS_ERR_PEVENT_NULL);
00594C  B3C040     MOV.B #0x4, W0
00594E  370033     BRA 0x59B6
634:                   }
635:                   if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
005950  90005E     MOV [W14+10], W0
005952  E00000     CP0 W0
005954  3A0002     BRA NZ, 0x595A
636:                       return (OS_ERR_PDATA_NULL);
005956  B3C090     MOV.B #0x9, W0
005958  37002E     BRA 0x59B6
637:                   }
638:               #endif
639:                   if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00595A  90004E     MOV [W14+8], W0
00595C  784010     MOV.B [W0], W0
00595E  504FE1     SUB.B W0, #0x1, [W15]
005960  320002     BRA Z, 0x5966
640:                       return (OS_ERR_EVENT_TYPE);
005962  B3C010     MOV.B #0x1, W0
005964  370028     BRA 0x59B6
641:                   }
642:                   OS_ENTER_CRITICAL();
005966  800211     MOV SR, W1
005968  980731     MOV W1, [W14+6]
00596A  800211     MOV SR, W1
00596C  200E00     MOV #0xE0, W0
00596E  700001     IOR W0, W1, W0
005970  880210     MOV W0, SR
643:                   p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
005972  90004E     MOV [W14+8], W0
005974  9040E0     MOV.B [W0+6], W1
005976  90005E     MOV [W14+10], W0
005978  984041     MOV.B W1, [W0+4]
644:                   psrc                    = &pevent->OSEventTbl[0];
00597A  90004E     MOV [W14+8], W0
00597C  400067     ADD W0, #0x7, W0
00597E  980710     MOV W0, [W14+2]
645:                   pdest                   = &p_mbox_data->OSEventTbl[0];
005980  90005E     MOV [W14+10], W0
005982  E88000     INC2 W0, W0
005984  980720     MOV W0, [W14+4]
646:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
005986  EB4000     CLR.B W0
005988  784F00     MOV.B W0, [W14]
00598A  37000B     BRA 0x59A2
0059A0  E84F1E     INC.B [W14], [W14]
0059A2  78401E     MOV.B [W14], W0
0059A4  504FE1     SUB.B W0, #0x1, [W15]
0059A6  36FFF2     BRA LEU, 0x598C
647:                       *pdest++ = *psrc++;
00598C  90001E     MOV [W14+2], W0
00598E  784090     MOV.B [W0], W1
005990  90002E     MOV [W14+4], W0
005992  784801     MOV.B W1, [W0]
005994  90002E     MOV [W14+4], W0
005996  E80000     INC W0, W0
005998  980720     MOV W0, [W14+4]
00599A  90001E     MOV [W14+2], W0
00599C  E80000     INC W0, W0
00599E  980710     MOV W0, [W14+2]
648:                   }
649:                   p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
0059A8  90004E     MOV [W14+8], W0
0059AA  900090     MOV [W0+2], W1
0059AC  90005E     MOV [W14+10], W0
0059AE  780801     MOV W1, [W0]
650:                   OS_EXIT_CRITICAL();
0059B0  9000BE     MOV [W14+6], W1
0059B2  880211     MOV W1, SR
651:                   return (OS_ERR_NONE);
0059B4  EB4000     CLR.B W0
652:               }
0059B6  FA8000     ULNK
653:               #endif                                                     /* OS_MBOX_QUERY_EN                         */
654:               #endif                                                     /* OS_MBOX_EN                               */
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_flag.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                         EVENT FLAG  MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_FLAG.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
31:                /*
32:                *********************************************************************************************************
33:                *                                          LOCAL PROTOTYPES
34:                *********************************************************************************************************
35:                */
36:                
37:                static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
38:                static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
39:                
40:                /*$PAGE*/
41:                /*
42:                *********************************************************************************************************
43:                *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
44:                *
45:                * Description: This function is called to check the status of a combination of bits to be set or cleared
46:                *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
47:                *              bits to be set/cleared.
48:                *
49:                *              This call does not block if the desired flags are not present.
50:                *
51:                * Arguments  : pgrp          is a pointer to the desired event flag group.
52:                *
53:                *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
54:                *                            The bits you want are specified by setting the corresponding bits in
55:                *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
56:                *                            'flags' would contain 0x03.
57:                *
58:                *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
59:                *                            to be set/cleared.
60:                *                            You can specify the following argument:
61:                *
62:                *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
63:                *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
64:                *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
65:                *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
66:                *
67:                *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
68:                *                                  the call.  Example, to wait for any flag in a group AND then clear
69:                *                                  the flags that are present, set 'wait_type' to:
70:                *
71:                *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
72:                *
73:                *              perr          is a pointer to an error code and can be:
74:                *                            OS_ERR_NONE               No error
75:                *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
76:                *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
77:                *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
78:                *                                                      group handle.
79:                *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
80:                *                                                      available.
81:                *
82:                * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
83:                *              occurred.
84:                *
85:                * Called from: Task or ISR
86:                *
87:                * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
88:                *                 function NOW returns the flags that were ready INSTEAD of the current state of the
89:                *                 event flags.
90:                *********************************************************************************************************
91:                */
92:                
93:                #if OS_FLAG_ACCEPT_EN > 0u
94:                OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
95:                                        OS_FLAGS      flags,
96:                                        INT8U         wait_type,
97:                                        INT8U        *perr)
98:                {
003B08  FA0010     LNK #0x10
003B0A  980740     MOV W0, [W14+8]
003B0C  980751     MOV W1, [W14+10]
003B0E  984F42     MOV.B W2, [W14+12]
003B10  980773     MOV W3, [W14+14]
99:                    OS_FLAGS      flags_rdy;
100:                   INT8U         result;
101:                   BOOLEAN       consume;
102:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
103:                   OS_CPU_SR     cpu_sr = 0u;
003B12  EB0000     CLR W0
003B14  980720     MOV W0, [W14+4]
104:               #endif
105:               
106:               
107:               
108:               #ifdef OS_SAFETY_CRITICAL
109:                   if (perr == (INT8U *)0) {
110:                       OS_SAFETY_CRITICAL_EXCEPTION();
111:                       return ((OS_FLAGS)0);
112:                   }
113:               #endif
114:               
115:               #if OS_ARG_CHK_EN > 0u
116:                   if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
003B16  90004E     MOV [W14+8], W0
003B18  E00000     CP0 W0
003B1A  3A0005     BRA NZ, 0x3B26
117:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
003B1C  90007E     MOV [W14+14], W0
003B1E  B3C6E1     MOV.B #0x6E, W1
003B20  784801     MOV.B W1, [W0]
118:                       return ((OS_FLAGS)0);
003B22  EB0000     CLR W0
003B24  370096     BRA 0x3C52
119:                   }
120:               #endif
121:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
003B26  90004E     MOV [W14+8], W0
003B28  784010     MOV.B [W0], W0
003B2A  504FE5     SUB.B W0, #0x5, [W15]
003B2C  320005     BRA Z, 0x3B38
122:                       *perr = OS_ERR_EVENT_TYPE;
003B2E  90007E     MOV [W14+14], W0
003B30  B3C011     MOV.B #0x1, W1
003B32  784801     MOV.B W1, [W0]
123:                       return ((OS_FLAGS)0);
003B34  EB0000     CLR W0
003B36  37008D     BRA 0x3C52
124:                   }
125:                   result = (INT8U)(wait_type & OS_FLAG_CONSUME);
003B38  9048CE     MOV.B [W14+12], W1
003B3A  B3C800     MOV.B #0x80, W0
003B3C  60C000     AND.B W1, W0, W0
003B3E  984760     MOV.B W0, [W14+6]
126:                   if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
003B40  90406E     MOV.B [W14+6], W0
003B42  E00400     CP0.B W0
003B44  320006     BRA Z, 0x3B52
127:                       wait_type &= ~OS_FLAG_CONSUME;
003B46  90484E     MOV.B [W14+12], W0
003B48  A17400     BCLR.B W0, #7
003B4A  984F40     MOV.B W0, [W14+12]
128:                       consume    = OS_TRUE;
003B4C  B3C010     MOV.B #0x1, W0
003B4E  984720     MOV.B W0, [W14+2]
003B50  370002     BRA 0x3B56
129:                   } else {
130:                       consume    = OS_FALSE;
003B52  EB4000     CLR.B W0
003B54  984720     MOV.B W0, [W14+2]
131:                   }
132:               /*$PAGE*/
133:                   *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
003B56  90007E     MOV [W14+14], W0
003B58  EB4080     CLR.B W1
003B5A  784801     MOV.B W1, [W0]
134:                   OS_ENTER_CRITICAL();
003B5C  800211     MOV SR, W1
003B5E  980721     MOV W1, [W14+4]
003B60  800211     MOV SR, W1
003B62  200E00     MOV #0xE0, W0
003B64  700001     IOR W0, W1, W0
003B66  880210     MOV W0, SR
135:                   switch (wait_type) {
003B68  90484E     MOV.B [W14+12], W0
003B6A  FB8000     ZE W0, W0
003B6C  500FE1     SUB W0, #0x1, [W15]
003B6E  320051     BRA Z, 0x3C12
003B70  500FE1     SUB W0, #0x1, [W15]
003B72  3C0003     BRA GT, 0x3B7A
003B74  E00000     CP0 W0
003B76  320035     BRA Z, 0x3BE2
003B78  370063     BRA 0x3C40
003B7A  500FE2     SUB W0, #0x2, [W15]
003B7C  320003     BRA Z, 0x3B84
003B7E  500FE3     SUB W0, #0x3, [W15]
003B80  320019     BRA Z, 0x3BB4
003B82  37005E     BRA 0x3C40
136:                       case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
137:                            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
003B84  90004E     MOV [W14+8], W0
003B86  9000A0     MOV [W0+4], W1
003B88  90005E     MOV [W14+10], W0
003B8A  608F00     AND W1, W0, [W14]
138:                            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
003B8C  90005E     MOV [W14+10], W0
003B8E  78009E     MOV [W14], W1
003B90  508F80     SUB W1, W0, [W15]
003B92  3A000A     BRA NZ, 0x3BA8
139:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003B94  90402E     MOV.B [W14+2], W0
003B96  504FE1     SUB.B W0, #0x1, [W15]
003B98  3A000A     BRA NZ, 0x3BAE
140:                                    pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
003B9A  90004E     MOV [W14+8], W0
003B9C  9000A0     MOV [W0+4], W1
003B9E  EA801E     COM [W14], W0
003BA0  608080     AND W1, W0, W1
003BA2  90004E     MOV [W14+8], W0
003BA4  980021     MOV W1, [W0+4]
003BA6  370003     BRA 0x3BAE
141:                                }
142:                            } else {
143:                                *perr = OS_ERR_FLAG_NOT_RDY;
003BA8  90007E     MOV [W14+14], W0
003BAA  B3C701     MOV.B #0x70, W1
003BAC  784801     MOV.B W1, [W0]
144:                            }
145:                            OS_EXIT_CRITICAL();
003BAE  9000AE     MOV [W14+4], W1
003BB0  880211     MOV W1, SR
146:                            break;
003BB2  37004E     BRA 0x3C50
147:               
148:                       case OS_FLAG_WAIT_SET_ANY:
149:                            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
003BB4  90004E     MOV [W14+8], W0
003BB6  9000A0     MOV [W0+4], W1
003BB8  90005E     MOV [W14+10], W0
003BBA  608F00     AND W1, W0, [W14]
150:                            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
003BBC  78001E     MOV [W14], W0
003BBE  E00000     CP0 W0
003BC0  32000A     BRA Z, 0x3BD6
151:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003BC2  90402E     MOV.B [W14+2], W0
003BC4  504FE1     SUB.B W0, #0x1, [W15]
003BC6  3A000A     BRA NZ, 0x3BDC
152:                                    pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
003BC8  90004E     MOV [W14+8], W0
003BCA  9000A0     MOV [W0+4], W1
003BCC  EA801E     COM [W14], W0
003BCE  608080     AND W1, W0, W1
003BD0  90004E     MOV [W14+8], W0
003BD2  980021     MOV W1, [W0+4]
003BD4  370003     BRA 0x3BDC
153:                                }
154:                            } else {
155:                                *perr = OS_ERR_FLAG_NOT_RDY;
003BD6  90007E     MOV [W14+14], W0
003BD8  B3C701     MOV.B #0x70, W1
003BDA  784801     MOV.B W1, [W0]
156:                            }
157:                            OS_EXIT_CRITICAL();
003BDC  9000AE     MOV [W14+4], W1
003BDE  880211     MOV W1, SR
158:                            break;
003BE0  370037     BRA 0x3C50
159:               
160:               #if OS_FLAG_WAIT_CLR_EN > 0u
161:                       case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
162:                            flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
003BE2  90004E     MOV [W14+8], W0
003BE4  900020     MOV [W0+4], W0
003BE6  EA8080     COM W0, W1
003BE8  90005E     MOV [W14+10], W0
003BEA  608F00     AND W1, W0, [W14]
163:                            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
003BEC  90005E     MOV [W14+10], W0
003BEE  78009E     MOV [W14], W1
003BF0  508F80     SUB W1, W0, [W15]
003BF2  3A0009     BRA NZ, 0x3C06
164:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003BF4  90402E     MOV.B [W14+2], W0
003BF6  504FE1     SUB.B W0, #0x1, [W15]
003BF8  3A0009     BRA NZ, 0x3C0C
165:                                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
003BFA  90004E     MOV [W14+8], W0
003BFC  900020     MOV [W0+4], W0
003BFE  70009E     IOR W0, [W14], W1
003C00  90004E     MOV [W14+8], W0
003C02  980021     MOV W1, [W0+4]
003C04  370003     BRA 0x3C0C
166:                                }
167:                            } else {
168:                                *perr = OS_ERR_FLAG_NOT_RDY;
003C06  90007E     MOV [W14+14], W0
003C08  B3C701     MOV.B #0x70, W1
003C0A  784801     MOV.B W1, [W0]
169:                            }
170:                            OS_EXIT_CRITICAL();
003C0C  9000AE     MOV [W14+4], W1
003C0E  880211     MOV W1, SR
171:                            break;
003C10  37001F     BRA 0x3C50
172:               
173:                       case OS_FLAG_WAIT_CLR_ANY:
174:                            flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
003C12  90004E     MOV [W14+8], W0
003C14  900020     MOV [W0+4], W0
003C16  EA8080     COM W0, W1
003C18  90005E     MOV [W14+10], W0
003C1A  608F00     AND W1, W0, [W14]
175:                            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
003C1C  78001E     MOV [W14], W0
003C1E  E00000     CP0 W0
003C20  320009     BRA Z, 0x3C34
176:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003C22  90402E     MOV.B [W14+2], W0
003C24  504FE1     SUB.B W0, #0x1, [W15]
003C26  3A0009     BRA NZ, 0x3C3A
177:                                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
003C28  90004E     MOV [W14+8], W0
003C2A  900020     MOV [W0+4], W0
003C2C  70009E     IOR W0, [W14], W1
003C2E  90004E     MOV [W14+8], W0
003C30  980021     MOV W1, [W0+4]
003C32  370003     BRA 0x3C3A
178:                                }
179:                            } else {
180:                                *perr = OS_ERR_FLAG_NOT_RDY;
003C34  90007E     MOV [W14+14], W0
003C36  B3C701     MOV.B #0x70, W1
003C38  784801     MOV.B W1, [W0]
181:                            }
182:                            OS_EXIT_CRITICAL();
003C3A  9000AE     MOV [W14+4], W1
003C3C  880211     MOV W1, SR
183:                            break;
003C3E  370008     BRA 0x3C50
184:               #endif
185:               
186:                       default:
187:                            OS_EXIT_CRITICAL();
003C40  9000AE     MOV [W14+4], W1
003C42  880211     MOV W1, SR
188:                            flags_rdy = (OS_FLAGS)0;
003C44  EB0000     CLR W0
003C46  780F00     MOV W0, [W14]
189:                            *perr     = OS_ERR_FLAG_WAIT_TYPE;
003C48  90007E     MOV [W14+14], W0
003C4A  B3C6F1     MOV.B #0x6F, W1
003C4C  784801     MOV.B W1, [W0]
190:                            break;
003C4E  000000     NOP
191:                   }
192:                   return (flags_rdy);
003C50  78001E     MOV [W14], W0
193:               }
003C52  FA8000     ULNK
003C54  060000     RETURN
194:               #endif
195:               
196:               /*$PAGE*/
197:               /*
198:               *********************************************************************************************************
199:               *                                        CREATE AN EVENT FLAG
200:               *
201:               * Description: This function is called to create an event flag group.
202:               *
203:               * Arguments  : flags         Contains the initial value to store in the event flag group.
204:               *
205:               *              perr          is a pointer to an error code which will be returned to your application:
206:               *                               OS_ERR_NONE               if the call was successful.
207:               *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
208:               *                                                         ISR.
209:               *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
210:               *
211:               * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
212:               *
213:               * Called from: Task ONLY
214:               *********************************************************************************************************
215:               */
216:               
217:               OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
218:                                           INT8U    *perr)
219:               {
003C56  FA0008     LNK #0x8
003C58  980720     MOV W0, [W14+4]
003C5A  980731     MOV W1, [W14+6]
220:                   OS_FLAG_GRP *pgrp;
221:               #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
222:                   OS_CPU_SR    cpu_sr = 0u;
003C5C  EB0000     CLR W0
003C5E  780F00     MOV W0, [W14]
223:               #endif
224:               
225:               
226:               
227:               #ifdef OS_SAFETY_CRITICAL
228:                   if (perr == (INT8U *)0) {
229:                       OS_SAFETY_CRITICAL_EXCEPTION();
230:                       return ((OS_FLAG_GRP *)0);
231:                   }
232:               #endif
233:               
234:               #ifdef OS_SAFETY_CRITICAL_IEC61508
235:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
236:                       OS_SAFETY_CRITICAL_EXCEPTION();
237:                       return ((OS_FLAG_GRP *)0);
238:                   }
239:               #endif
240:               
241:                   if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
003C60  BFC86B     MOV.B OSIntNesting, WREG
003C62  E00400     CP0.B W0
003C64  320005     BRA Z, 0x3C70
242:                       *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
003C66  90003E     MOV [W14+6], W0
003C68  B3C101     MOV.B #0x10, W1
003C6A  784801     MOV.B W1, [W0]
243:                       return ((OS_FLAG_GRP *)0);
003C6C  EB0000     CLR W0
003C6E  370026     BRA 0x3CBC
244:                   }
245:                   OS_ENTER_CRITICAL();
003C70  800211     MOV SR, W1
003C72  780F01     MOV W1, [W14]
003C74  800211     MOV SR, W1
003C76  200E00     MOV #0xE0, W0
003C78  700001     IOR W0, W1, W0
003C7A  880210     MOV W0, SR
246:                   pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
003C7C  8042F1     MOV OSFlagFreeList, W1
003C7E  980711     MOV W1, [W14+2]
247:                   if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
003C80  90001E     MOV [W14+2], W0
003C82  E00000     CP0 W0
003C84  320015     BRA Z, 0x3CB0
248:                                                                   /* Adjust free list                                */
249:                       OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
003C86  8042F0     MOV OSFlagFreeList, W0
003C88  900010     MOV [W0+2], W0
003C8A  8842F0     MOV W0, OSFlagFreeList
250:                       pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
003C8C  90001E     MOV [W14+2], W0
003C8E  B3C051     MOV.B #0x5, W1
003C90  784801     MOV.B W1, [W0]
251:                       pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
003C92  90001E     MOV [W14+2], W0
003C94  9000AE     MOV [W14+4], W1
003C96  980021     MOV W1, [W0+4]
252:                       pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
003C98  90001E     MOV [W14+2], W0
003C9A  EB0080     CLR W1
003C9C  980011     MOV W1, [W0+2]
253:               #if OS_FLAG_NAME_EN > 0u
254:                       pgrp->OSFlagName     = (INT8U *)(void *)"?";
003C9E  2883C1     MOV #0x883C, W1
003CA0  90001E     MOV [W14+2], W0
003CA2  980031     MOV W1, [W0+6]
255:               #endif
256:                       OS_EXIT_CRITICAL();
003CA4  78009E     MOV [W14], W1
003CA6  880211     MOV W1, SR
257:                       *perr                = OS_ERR_NONE;
003CA8  90003E     MOV [W14+6], W0
003CAA  EB4080     CLR.B W1
003CAC  784801     MOV.B W1, [W0]
003CAE  370005     BRA 0x3CBA
258:                   } else {
259:                       OS_EXIT_CRITICAL();
003CB0  78009E     MOV [W14], W1
003CB2  880211     MOV W1, SR
260:                       *perr                = OS_ERR_FLAG_GRP_DEPLETED;
003CB4  90003E     MOV [W14+6], W0
003CB6  B3C721     MOV.B #0x72, W1
003CB8  784801     MOV.B W1, [W0]
261:                   }
262:                   return (pgrp);                                  /* Return pointer to event flag group              */
003CBA  90001E     MOV [W14+2], W0
263:               }
003CBC  FA8000     ULNK
003CBE  060000     RETURN
264:               
265:               /*$PAGE*/
266:               /*
267:               *********************************************************************************************************
268:               *                                     DELETE AN EVENT FLAG GROUP
269:               *
270:               * Description: This function deletes an event flag group and readies all tasks pending on the event flag
271:               *              group.
272:               *
273:               * Arguments  : pgrp          is a pointer to the desired event flag group.
274:               *
275:               *              opt           determines delete options as follows:
276:               *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
277:               *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
278:               *                                                    waiting.  In this case, all the tasks pending will be
279:               *                                                    readied.
280:               *
281:               *              perr          is a pointer to an error code that can contain one of the following values:
282:               *                            OS_ERR_NONE               The call was successful and the event flag group was
283:               *                                                      deleted
284:               *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
285:               *                                                      an ISR
286:               *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
287:               *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
288:               *                            OS_ERR_INVALID_OPT        An invalid option was specified
289:               *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
290:               *                                                      group.
291:               *
292:               * Returns    : pgrp          upon error
293:               *              (OS_EVENT *)0 if the event flag group was successfully deleted.
294:               *
295:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
296:               *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
297:               *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
298:               *                 time is directly proportional to the number of tasks waiting on the event flag group.
299:               *              3) All tasks that were waiting for the event flag will be readied and returned an 
300:               *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
301:               *********************************************************************************************************
302:               */
303:               
304:               #if OS_FLAG_DEL_EN > 0u
305:               OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
306:                                        INT8U         opt,
307:                                        INT8U        *perr)
308:               {
003CC0  FA000E     LNK #0xE
003CC2  980740     MOV W0, [W14+8]
003CC4  984F21     MOV.B W1, [W14+10]
003CC6  980762     MOV W2, [W14+12]
309:                   BOOLEAN       tasks_waiting;
310:                   OS_FLAG_NODE *pnode;
311:                   OS_FLAG_GRP  *pgrp_return;
312:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
313:                   OS_CPU_SR     cpu_sr = 0u;
003CC8  EB0000     CLR W0
003CCA  980730     MOV W0, [W14+6]
314:               #endif
315:               
316:               
317:               
318:               #ifdef OS_SAFETY_CRITICAL
319:                   if (perr == (INT8U *)0) {
320:                       OS_SAFETY_CRITICAL_EXCEPTION();
321:                       return ((OS_FLAG_GRP *)0);
322:                   }
323:               #endif
324:               
325:               #if OS_ARG_CHK_EN > 0u
326:                   if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
003CCC  90004E     MOV [W14+8], W0
003CCE  E00000     CP0 W0
003CD0  3A0005     BRA NZ, 0x3CDC
327:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
003CD2  90006E     MOV [W14+12], W0
003CD4  B3C6E1     MOV.B #0x6E, W1
003CD6  784801     MOV.B W1, [W0]
328:                       return (pgrp);
003CD8  90004E     MOV [W14+8], W0
003CDA  370079     BRA 0x3DCE
329:                   }
330:               #endif
331:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
003CDC  BFC86B     MOV.B OSIntNesting, WREG
003CDE  E00400     CP0.B W0
003CE0  320005     BRA Z, 0x3CEC
332:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
003CE2  90006E     MOV [W14+12], W0
003CE4  B3C0F1     MOV.B #0xF, W1
003CE6  784801     MOV.B W1, [W0]
333:                       return (pgrp);
003CE8  90004E     MOV [W14+8], W0
003CEA  370071     BRA 0x3DCE
334:                   }
335:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
003CEC  90004E     MOV [W14+8], W0
003CEE  784010     MOV.B [W0], W0
003CF0  504FE5     SUB.B W0, #0x5, [W15]
003CF2  320005     BRA Z, 0x3CFE
336:                       *perr = OS_ERR_EVENT_TYPE;
003CF4  90006E     MOV [W14+12], W0
003CF6  B3C011     MOV.B #0x1, W1
003CF8  784801     MOV.B W1, [W0]
337:                       return (pgrp);
003CFA  90004E     MOV [W14+8], W0
003CFC  370068     BRA 0x3DCE
338:                   }
339:                   OS_ENTER_CRITICAL();
003CFE  800211     MOV SR, W1
003D00  980731     MOV W1, [W14+6]
003D02  800211     MOV SR, W1
003D04  200E00     MOV #0xE0, W0
003D06  700001     IOR W0, W1, W0
003D08  880210     MOV W0, SR
340:                   if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
003D0A  90004E     MOV [W14+8], W0
003D0C  900010     MOV [W0+2], W0
003D0E  E00000     CP0 W0
003D10  320003     BRA Z, 0x3D18
341:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
003D12  B3C010     MOV.B #0x1, W0
003D14  784F00     MOV.B W0, [W14]
003D16  370002     BRA 0x3D1C
342:                   } else {
343:                       tasks_waiting = OS_FALSE;                          /* No                                       */
003D18  EB4000     CLR.B W0
003D1A  784F00     MOV.B W0, [W14]
344:                   }
345:                   switch (opt) {
003D1C  90482E     MOV.B [W14+10], W0
003D1E  FB8000     ZE W0, W0
003D20  E00000     CP0 W0
003D22  320003     BRA Z, 0x3D2A
003D24  500FE1     SUB W0, #0x1, [W15]
003D26  320022     BRA Z, 0x3D6C
003D28  370049     BRA 0x3DBC
346:                       case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
347:                            if (tasks_waiting == OS_FALSE) {
003D2A  78401E     MOV.B [W14], W0
003D2C  E00400     CP0.B W0
003D2E  3A0016     BRA NZ, 0x3D5C
348:               #if OS_FLAG_NAME_EN > 0u
349:                                pgrp->OSFlagName     = (INT8U *)(void *)"?";
003D30  2883C1     MOV #0x883C, W1
003D32  90004E     MOV [W14+8], W0
003D34  980031     MOV W1, [W0+6]
350:               #endif
351:                                pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
003D36  90004E     MOV [W14+8], W0
003D38  EB4080     CLR.B W1
003D3A  784801     MOV.B W1, [W0]
352:                                pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
003D3C  8042F1     MOV OSFlagFreeList, W1
003D3E  90004E     MOV [W14+8], W0
003D40  980011     MOV W1, [W0+2]
353:                                pgrp->OSFlagFlags    = (OS_FLAGS)0;
003D42  90004E     MOV [W14+8], W0
003D44  EB0080     CLR W1
003D46  980021     MOV W1, [W0+4]
354:                                OSFlagFreeList       = pgrp;
003D48  9000CE     MOV [W14+8], W1
003D4A  8842F1     MOV W1, OSFlagFreeList
355:                                OS_EXIT_CRITICAL();
003D4C  9000BE     MOV [W14+6], W1
003D4E  880211     MOV W1, SR
356:                                *perr                = OS_ERR_NONE;
003D50  90006E     MOV [W14+12], W0
003D52  EB4080     CLR.B W1
003D54  784801     MOV.B W1, [W0]
357:                                pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
003D56  EB0000     CLR W0
003D58  980720     MOV W0, [W14+4]
358:                            } else {
359:                                OS_EXIT_CRITICAL();
003D5C  9000BE     MOV [W14+6], W1
003D5E  880211     MOV W1, SR
360:                                *perr                = OS_ERR_TASK_WAITING;
003D60  90006E     MOV [W14+12], W0
003D62  B3C491     MOV.B #0x49, W1
003D64  784801     MOV.B W1, [W0]
361:                                pgrp_return          = pgrp;
003D66  9000CE     MOV [W14+8], W1
003D68  980721     MOV W1, [W14+4]
362:                            }
363:                            break;
003D5A  370038     BRA 0x3DCC
003D6A  370030     BRA 0x3DCC
364:               
365:                       case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
366:                            pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
003D6C  90004E     MOV [W14+8], W0
003D6E  900010     MOV [W0+2], W0
003D70  980710     MOV W0, [W14+2]
367:                            while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
003D72  370007     BRA 0x3D82
003D82  90001E     MOV [W14+2], W0
003D84  E00000     CP0 W0
003D86  3AFFF6     BRA NZ, 0x3D74
368:                                (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
003D74  B3C022     MOV.B #0x2, W2
003D76  EB0080     CLR W1
003D78  90001E     MOV [W14+2], W0
003D7A  07035D     RCALL _OS_FlagTaskRdy
369:                                pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
003D7C  90001E     MOV [W14+2], W0
003D7E  780010     MOV [W0], W0
003D80  980710     MOV W0, [W14+2]
370:                            }
371:               #if OS_FLAG_NAME_EN > 0u
372:                            pgrp->OSFlagName     = (INT8U *)(void *)"?";
003D88  2883C1     MOV #0x883C, W1
003D8A  90004E     MOV [W14+8], W0
003D8C  980031     MOV W1, [W0+6]
373:               #endif
374:                            pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
003D8E  90004E     MOV [W14+8], W0
003D90  EB4080     CLR.B W1
003D92  784801     MOV.B W1, [W0]
375:                            pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
003D94  8042F1     MOV OSFlagFreeList, W1
003D96  90004E     MOV [W14+8], W0
003D98  980011     MOV W1, [W0+2]
376:                            pgrp->OSFlagFlags    = (OS_FLAGS)0;
003D9A  90004E     MOV [W14+8], W0
003D9C  EB0080     CLR W1
003D9E  980021     MOV W1, [W0+4]
377:                            OSFlagFreeList       = pgrp;
003DA0  9000CE     MOV [W14+8], W1
003DA2  8842F1     MOV W1, OSFlagFreeList
378:                            OS_EXIT_CRITICAL();
003DA4  9000BE     MOV [W14+6], W1
003DA6  880211     MOV W1, SR
379:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
003DA8  78401E     MOV.B [W14], W0
003DAA  504FE1     SUB.B W0, #0x1, [W15]
003DAC  3A0001     BRA NZ, 0x3DB0
380:                                OS_Sched();                               /* Find highest priority task ready to run  */
003DAE  07EAC0     RCALL OS_Sched
381:                            }
382:                            *perr = OS_ERR_NONE;
003DB0  90006E     MOV [W14+12], W0
003DB2  EB4080     CLR.B W1
003DB4  784801     MOV.B W1, [W0]
383:                            pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
003DB6  EB0000     CLR W0
003DB8  980720     MOV W0, [W14+4]
384:                            break;
003DBA  370008     BRA 0x3DCC
385:               
386:                       default:
387:                            OS_EXIT_CRITICAL();
003DBC  9000BE     MOV [W14+6], W1
003DBE  880211     MOV W1, SR
388:                            *perr                = OS_ERR_INVALID_OPT;
003DC0  90006E     MOV [W14+12], W0
003DC2  B3C071     MOV.B #0x7, W1
003DC4  784801     MOV.B W1, [W0]
389:                            pgrp_return          = pgrp;
003DC6  9000CE     MOV [W14+8], W1
003DC8  980721     MOV W1, [W14+4]
390:                            break;
003DCA  000000     NOP
391:                   }
392:                   return (pgrp_return);
003DCC  90002E     MOV [W14+4], W0
393:               }
003DCE  FA8000     ULNK
003DD0  060000     RETURN
394:               #endif
395:               /*$PAGE*/
396:               /*
397:               *********************************************************************************************************
398:               *                                 GET THE NAME OF AN EVENT FLAG GROUP
399:               *
400:               * Description: This function is used to obtain the name assigned to an event flag group
401:               *
402:               * Arguments  : pgrp      is a pointer to the event flag group.
403:               *
404:               *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
405:               *                        group.
406:               *
407:               *              perr      is a pointer to an error code that can contain one of the following values:
408:               *
409:               *                        OS_ERR_NONE                if the requested task is resumed
410:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
411:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
412:               *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
413:               *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
414:               *
415:               * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
416:               *********************************************************************************************************
417:               */
418:               
419:               #if OS_FLAG_NAME_EN > 0u
420:               INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
421:                                     INT8U        **pname,
422:                                     INT8U         *perr)
423:               {
003DD2  FA000A     LNK #0xA
003DD4  980720     MOV W0, [W14+4]
003DD6  980731     MOV W1, [W14+6]
003DD8  980742     MOV W2, [W14+8]
424:                   INT8U      len;
425:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
426:                   OS_CPU_SR  cpu_sr = 0u;
003DDA  EB0000     CLR W0
003DDC  780F00     MOV W0, [W14]
427:               #endif
428:               
429:               
430:               
431:               #ifdef OS_SAFETY_CRITICAL
432:                   if (perr == (INT8U *)0) {
433:                       OS_SAFETY_CRITICAL_EXCEPTION();
434:                       return (0u);
435:                   }
436:               #endif
437:               
438:               #if OS_ARG_CHK_EN > 0u
439:                   if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
003DDE  90002E     MOV [W14+4], W0
003DE0  E00000     CP0 W0
003DE2  3A0005     BRA NZ, 0x3DEE
440:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
003DE4  90004E     MOV [W14+8], W0
003DE6  B3C6E1     MOV.B #0x6E, W1
003DE8  784801     MOV.B W1, [W0]
441:                       return (0u);
003DEA  EB4000     CLR.B W0
003DEC  37002F     BRA 0x3E4C
442:                   }
443:                   if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
003DEE  90003E     MOV [W14+6], W0
003DF0  E00000     CP0 W0
003DF2  3A0005     BRA NZ, 0x3DFE
444:                       *perr = OS_ERR_PNAME_NULL;
003DF4  90004E     MOV [W14+8], W0
003DF6  B3C0C1     MOV.B #0xC, W1
003DF8  784801     MOV.B W1, [W0]
445:                       return (0u);
003DFA  EB4000     CLR.B W0
003DFC  370027     BRA 0x3E4C
446:                   }
447:               #endif
448:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
003DFE  BFC86B     MOV.B OSIntNesting, WREG
003E00  E00400     CP0.B W0
003E02  320005     BRA Z, 0x3E0E
449:                       *perr = OS_ERR_NAME_GET_ISR;
003E04  90004E     MOV [W14+8], W0
003E06  B3C111     MOV.B #0x11, W1
003E08  784801     MOV.B W1, [W0]
450:                       return (0u);
003E0A  EB4000     CLR.B W0
003E0C  37001F     BRA 0x3E4C
451:                   }
452:                   OS_ENTER_CRITICAL();
003E0E  800211     MOV SR, W1
003E10  780F01     MOV W1, [W14]
003E12  800211     MOV SR, W1
003E14  200E00     MOV #0xE0, W0
003E16  700001     IOR W0, W1, W0
003E18  880210     MOV W0, SR
453:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
003E1A  90002E     MOV [W14+4], W0
003E1C  784010     MOV.B [W0], W0
003E1E  504FE5     SUB.B W0, #0x5, [W15]
003E20  320007     BRA Z, 0x3E30
454:                       OS_EXIT_CRITICAL();
003E22  78009E     MOV [W14], W1
003E24  880211     MOV W1, SR
455:                       *perr = OS_ERR_EVENT_TYPE;
003E26  90004E     MOV [W14+8], W0
003E28  B3C011     MOV.B #0x1, W1
003E2A  784801     MOV.B W1, [W0]
456:                       return (0u);
003E2C  EB4000     CLR.B W0
003E2E  37000E     BRA 0x3E4C
457:                   }
458:                   *pname = pgrp->OSFlagName;
003E30  90002E     MOV [W14+4], W0
003E32  9000B0     MOV [W0+6], W1
003E34  90003E     MOV [W14+6], W0
003E36  780801     MOV W1, [W0]
459:                   len    = OS_StrLen(*pname);
003E38  90003E     MOV [W14+6], W0
003E3A  780010     MOV [W0], W0
003E3C  07EAB9     RCALL OS_StrLen
003E3E  984720     MOV.B W0, [W14+2]
460:                   OS_EXIT_CRITICAL();
003E40  78009E     MOV [W14], W1
003E42  880211     MOV W1, SR
461:                   *perr  = OS_ERR_NONE;
003E44  90004E     MOV [W14+8], W0
003E46  EB4080     CLR.B W1
003E48  784801     MOV.B W1, [W0]
462:                   return (len);
003E4A  90402E     MOV.B [W14+2], W0
463:               }
003E4C  FA8000     ULNK
003E4E  060000     RETURN
464:               #endif
465:               
466:               /*$PAGE*/
467:               /*
468:               *********************************************************************************************************
469:               *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
470:               *
471:               * Description: This function assigns a name to an event flag group.
472:               *
473:               * Arguments  : pgrp      is a pointer to the event flag group.
474:               *
475:               *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
476:               *                        group.
477:               *
478:               *              perr      is a pointer to an error code that can contain one of the following values:
479:               *
480:               *                        OS_ERR_NONE                if the requested task is resumed
481:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
482:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
483:               *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
484:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
485:               *
486:               * Returns    : None
487:               *********************************************************************************************************
488:               */
489:               
490:               #if OS_FLAG_NAME_EN > 0u
491:               void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
492:                                    INT8U        *pname,
493:                                    INT8U        *perr)
494:               {
003E50  FA0008     LNK #0x8
003E52  980710     MOV W0, [W14+2]
003E54  980721     MOV W1, [W14+4]
003E56  980732     MOV W2, [W14+6]
495:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
496:                   OS_CPU_SR  cpu_sr = 0u;
003E58  EB0000     CLR W0
003E5A  780F00     MOV W0, [W14]
497:               #endif
498:               
499:               
500:               
501:               #ifdef OS_SAFETY_CRITICAL
502:                   if (perr == (INT8U *)0) {
503:                       OS_SAFETY_CRITICAL_EXCEPTION();
504:                       return;
505:                   }
506:               #endif
507:               
508:               #if OS_ARG_CHK_EN > 0u
509:                   if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
003E5C  90001E     MOV [W14+2], W0
003E5E  E00000     CP0 W0
003E60  3A0004     BRA NZ, 0x3E6A
510:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
003E62  90003E     MOV [W14+6], W0
003E64  B3C6E1     MOV.B #0x6E, W1
003E66  784801     MOV.B W1, [W0]
511:                       return;
003E68  370027     BRA 0x3EB8
512:                   }
513:                   if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
003E6A  90002E     MOV [W14+4], W0
003E6C  E00000     CP0 W0
003E6E  3A0004     BRA NZ, 0x3E78
514:                       *perr = OS_ERR_PNAME_NULL;
003E70  90003E     MOV [W14+6], W0
003E72  B3C0C1     MOV.B #0xC, W1
003E74  784801     MOV.B W1, [W0]
515:                       return;
003E76  370020     BRA 0x3EB8
516:                   }
517:               #endif
518:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
003E78  BFC86B     MOV.B OSIntNesting, WREG
003E7A  E00400     CP0.B W0
003E7C  320004     BRA Z, 0x3E86
519:                       *perr = OS_ERR_NAME_SET_ISR;
003E7E  90003E     MOV [W14+6], W0
003E80  B3C121     MOV.B #0x12, W1
003E82  784801     MOV.B W1, [W0]
520:                       return;
003E84  370019     BRA 0x3EB8
521:                   }
522:                   OS_ENTER_CRITICAL();
003E86  800211     MOV SR, W1
003E88  780F01     MOV W1, [W14]
003E8A  800211     MOV SR, W1
003E8C  200E00     MOV #0xE0, W0
003E8E  700001     IOR W0, W1, W0
003E90  880210     MOV W0, SR
523:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
003E92  90001E     MOV [W14+2], W0
003E94  784010     MOV.B [W0], W0
003E96  504FE5     SUB.B W0, #0x5, [W15]
003E98  320006     BRA Z, 0x3EA6
524:                       OS_EXIT_CRITICAL();
003E9A  78009E     MOV [W14], W1
003E9C  880211     MOV W1, SR
525:                       *perr = OS_ERR_EVENT_TYPE;
003E9E  90003E     MOV [W14+6], W0
003EA0  B3C011     MOV.B #0x1, W1
003EA2  784801     MOV.B W1, [W0]
526:                       return;
003EA4  370009     BRA 0x3EB8
527:                   }
528:                   pgrp->OSFlagName = pname;
003EA6  90001E     MOV [W14+2], W0
003EA8  9000AE     MOV [W14+4], W1
003EAA  980031     MOV W1, [W0+6]
529:                   OS_EXIT_CRITICAL();
003EAC  78009E     MOV [W14], W1
003EAE  880211     MOV W1, SR
530:                   *perr            = OS_ERR_NONE;
003EB0  90003E     MOV [W14+6], W0
003EB2  EB4080     CLR.B W1
003EB4  784801     MOV.B W1, [W0]
531:                   return;
003EB6  000000     NOP
532:               }
003EB8  FA8000     ULNK
003EBA  060000     RETURN
533:               #endif
534:               
535:               /*$PAGE*/
536:               /*
537:               *********************************************************************************************************
538:               *                                     WAIT ON AN EVENT FLAG GROUP
539:               *
540:               * Description: This function is called to wait for a combination of bits to be set in an event flag
541:               *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
542:               *
543:               * Arguments  : pgrp          is a pointer to the desired event flag group.
544:               *
545:               *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
546:               *                            The bits you want are specified by setting the corresponding bits in
547:               *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
548:               *                            'flags' would contain 0x03.
549:               *
550:               *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
551:               *                            You can specify the following argument:
552:               *
553:               *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
554:               *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
555:               *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
556:               *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
557:               *
558:               *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
559:               *                                  the call.  Example, to wait for any flag in a group AND then clear
560:               *                                  the flags that are present, set 'wait_type' to:
561:               *
562:               *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
563:               *
564:               *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
565:               *                            desired bit combination.  If you specify 0, however, your task will wait
566:               *                            forever at the specified event flag group or, until a message arrives.
567:               *
568:               *              perr          is a pointer to an error code and can be:
569:               *                            OS_ERR_NONE               The desired bits have been set within the specified
570:               *                                                      'timeout'.
571:               *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
572:               *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
573:               *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
574:               *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
575:               *                                                      'timeout'.
576:               *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
577:               *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
578:               *
579:               * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
580:               *              occurred.
581:               *
582:               * Called from: Task ONLY
583:               *
584:               * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
585:               *                 function NOW returns the flags that were ready INSTEAD of the current state of the
586:               *                 event flags.
587:               *********************************************************************************************************
588:               */
589:               
590:               OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
591:                                     OS_FLAGS      flags,
592:                                     INT8U         wait_type,
593:                                     INT32U        timeout,
594:                                     INT8U        *perr)
595:               {
003EBC  FA0022     LNK #0x22
003EBE  980F30     MOV W0, [W14+22]
003EC0  980F41     MOV W1, [W14+24]
003EC2  985F22     MOV.B W2, [W14+26]
003EC4  980F64     MOV W4, [W14+28]
003EC6  980F75     MOV W5, [W14+30]
003EC8  981703     MOV W3, [W14+32]
596:                   OS_FLAG_NODE  node;
597:                   OS_FLAGS      flags_rdy;
598:                   INT8U         result;
599:                   INT8U         pend_stat;
600:                   BOOLEAN       consume;
601:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
602:                   OS_CPU_SR     cpu_sr = 0u;
003ECA  EB0000     CLR W0
003ECC  980710     MOV W0, [W14+2]
603:               #endif
604:               
605:               
606:               
607:               #ifdef OS_SAFETY_CRITICAL
608:                   if (perr == (INT8U *)0) {
609:                       OS_SAFETY_CRITICAL_EXCEPTION();
610:                       return ((OS_FLAGS)0);
611:                   }
612:               #endif
613:               
614:               #if OS_ARG_CHK_EN > 0u
615:                   if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
003ECE  90083E     MOV [W14+22], W0
003ED0  E00000     CP0 W0
003ED2  3A0005     BRA NZ, 0x3EDE
616:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
003ED4  90100E     MOV [W14+32], W0
003ED6  B3C6E1     MOV.B #0x6E, W1
003ED8  784801     MOV.B W1, [W0]
617:                       return ((OS_FLAGS)0);
003EDA  EB0000     CLR W0
003EDC  370135     BRA 0x4148
618:                   }
619:               #endif
620:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
003EDE  BFC86B     MOV.B OSIntNesting, WREG
003EE0  E00400     CP0.B W0
003EE2  320005     BRA Z, 0x3EEE
621:                       *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
003EE4  90100E     MOV [W14+32], W0
003EE6  B3C021     MOV.B #0x2, W1
003EE8  784801     MOV.B W1, [W0]
622:                       return ((OS_FLAGS)0);
003EEA  EB0000     CLR W0
003EEC  37012D     BRA 0x4148
623:                   }
624:                   if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
003EEE  BFC86C     MOV.B OSLockNesting, WREG
003EF0  E00400     CP0.B W0
003EF2  320005     BRA Z, 0x3EFE
625:                       *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
003EF4  90100E     MOV [W14+32], W0
003EF6  B3C0D1     MOV.B #0xD, W1
003EF8  784801     MOV.B W1, [W0]
626:                       return ((OS_FLAGS)0);
003EFA  EB0000     CLR W0
003EFC  370125     BRA 0x4148
627:                   }
628:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
003EFE  90083E     MOV [W14+22], W0
003F00  784010     MOV.B [W0], W0
003F02  504FE5     SUB.B W0, #0x5, [W15]
003F04  320005     BRA Z, 0x3F10
629:                       *perr = OS_ERR_EVENT_TYPE;
003F06  90100E     MOV [W14+32], W0
003F08  B3C011     MOV.B #0x1, W1
003F0A  784801     MOV.B W1, [W0]
630:                       return ((OS_FLAGS)0);
003F0C  EB0000     CLR W0
003F0E  37011C     BRA 0x4148
631:                   }
632:                   result = (INT8U)(wait_type & OS_FLAG_CONSUME);
003F10  9058AE     MOV.B [W14+26], W1
003F12  B3C800     MOV.B #0x80, W0
003F14  60C000     AND.B W1, W0, W0
003F16  984740     MOV.B W0, [W14+4]
633:                   if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
003F18  90404E     MOV.B [W14+4], W0
003F1A  E00400     CP0.B W0
003F1C  320006     BRA Z, 0x3F2A
634:                       wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
003F1E  90582E     MOV.B [W14+26], W0
003F20  A17400     BCLR.B W0, #7
003F22  985F20     MOV.B W0, [W14+26]
635:                       consume    = OS_TRUE;
003F24  B3C010     MOV.B #0x1, W0
003F26  784F00     MOV.B W0, [W14]
003F28  370002     BRA 0x3F2E
636:                   } else {
637:                       consume    = OS_FALSE;
003F2A  EB4000     CLR.B W0
003F2C  784F00     MOV.B W0, [W14]
638:                   }
639:               /*$PAGE*/
640:                   OS_ENTER_CRITICAL();
003F2E  800211     MOV SR, W1
003F30  980711     MOV W1, [W14+2]
003F32  800211     MOV SR, W1
003F34  200E00     MOV #0xE0, W0
003F36  700001     IOR W0, W1, W0
003F38  880210     MOV W0, SR
641:                   switch (wait_type) {
003F3A  90582E     MOV.B [W14+26], W0
003F3C  FB8000     ZE W0, W0
003F3E  500FE1     SUB W0, #0x1, [W15]
003F40  320081     BRA Z, 0x4044
003F42  500FE1     SUB W0, #0x1, [W15]
003F44  3C0003     BRA GT, 0x3F4C
003F46  E00000     CP0 W0
003F48  320055     BRA Z, 0x3FF4
003F4A  3700A3     BRA 0x4092
003F4C  500FE2     SUB W0, #0x2, [W15]
003F4E  320003     BRA Z, 0x3F56
003F50  500FE3     SUB W0, #0x3, [W15]
003F52  320029     BRA Z, 0x3FA6
003F54  37009E     BRA 0x4092
642:                       case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
643:                            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
003F56  90083E     MOV [W14+22], W0
003F58  9000A0     MOV [W0+4], W1
003F5A  90084E     MOV [W14+24], W0
003F5C  608000     AND W1, W0, W0
003F5E  980730     MOV W0, [W14+6]
644:                            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
003F60  9000BE     MOV [W14+6], W1
003F62  90084E     MOV [W14+24], W0
003F64  508F80     SUB W1, W0, [W15]
003F66  3A0014     BRA NZ, 0x3F90
645:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003F68  78401E     MOV.B [W14], W0
003F6A  504FE1     SUB.B W0, #0x1, [W15]
003F6C  3A0007     BRA NZ, 0x3F7C
646:                                    pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
003F6E  90083E     MOV [W14+22], W0
003F70  9000A0     MOV [W0+4], W1
003F72  90003E     MOV [W14+6], W0
003F74  EA8000     COM W0, W0
003F76  608080     AND W1, W0, W1
003F78  90083E     MOV [W14+22], W0
003F7A  980021     MOV W1, [W0+4]
647:                                }
648:                                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
003F7C  8043B0     MOV OSTCBCur, W0
003F7E  9000BE     MOV [W14+6], W1
003F80  980851     MOV W1, [W0+26]
649:                                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
003F82  90009E     MOV [W14+2], W1
003F84  880211     MOV W1, SR
650:                                *perr                   = OS_ERR_NONE;
003F86  90100E     MOV [W14+32], W0
003F88  EB4080     CLR.B W1
003F8A  784801     MOV.B W1, [W0]
651:                                return (flags_rdy);
003F8C  90003E     MOV [W14+6], W0
003F8E  3700DC     BRA 0x4148
652:                            } else {                                      /* Block task until events occur or timeout */
653:                                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
003F90  47006A     ADD W14, #0xA, W0
003F92  900A6E     MOV [W14+28], W4
003F94  900AFE     MOV [W14+30], W5
003F96  9059AE     MOV.B [W14+26], W3
003F98  90094E     MOV [W14+24], W2
003F9A  780080     MOV W0, W1
003F9C  90083E     MOV [W14+22], W0
003F9E  0701E7     RCALL _OS_FlagBlock
654:                                OS_EXIT_CRITICAL();
003FA0  90009E     MOV [W14+2], W1
003FA2  880211     MOV W1, SR
655:                            }
656:                            break;
003FA4  37007F     BRA 0x40A4
657:               
658:                       case OS_FLAG_WAIT_SET_ANY:
659:                            flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
003FA6  90083E     MOV [W14+22], W0
003FA8  9000A0     MOV [W0+4], W1
003FAA  90084E     MOV [W14+24], W0
003FAC  608000     AND W1, W0, W0
003FAE  980730     MOV W0, [W14+6]
660:                            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
003FB0  90003E     MOV [W14+6], W0
003FB2  E00000     CP0 W0
003FB4  320014     BRA Z, 0x3FDE
661:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
003FB6  78401E     MOV.B [W14], W0
003FB8  504FE1     SUB.B W0, #0x1, [W15]
003FBA  3A0007     BRA NZ, 0x3FCA
662:                                    pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
003FBC  90083E     MOV [W14+22], W0
003FBE  9000A0     MOV [W0+4], W1
003FC0  90003E     MOV [W14+6], W0
003FC2  EA8000     COM W0, W0
003FC4  608080     AND W1, W0, W1
003FC6  90083E     MOV [W14+22], W0
003FC8  980021     MOV W1, [W0+4]
663:                                }
664:                                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
003FCA  8043B0     MOV OSTCBCur, W0
003FCC  9000BE     MOV [W14+6], W1
003FCE  980851     MOV W1, [W0+26]
665:                                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
003FD0  90009E     MOV [W14+2], W1
003FD2  880211     MOV W1, SR
666:                                *perr                   = OS_ERR_NONE;
003FD4  90100E     MOV [W14+32], W0
003FD6  EB4080     CLR.B W1
003FD8  784801     MOV.B W1, [W0]
667:                                return (flags_rdy);
003FDA  90003E     MOV [W14+6], W0
003FDC  3700B5     BRA 0x4148
668:                            } else {                                      /* Block task until events occur or timeout */
669:                                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
003FDE  47006A     ADD W14, #0xA, W0
003FE0  900A6E     MOV [W14+28], W4
003FE2  900AFE     MOV [W14+30], W5
003FE4  9059AE     MOV.B [W14+26], W3
003FE6  90094E     MOV [W14+24], W2
003FE8  780080     MOV W0, W1
003FEA  90083E     MOV [W14+22], W0
003FEC  0701C0     RCALL _OS_FlagBlock
670:                                OS_EXIT_CRITICAL();
003FEE  90009E     MOV [W14+2], W1
003FF0  880211     MOV W1, SR
671:                            }
672:                            break;
003FF2  370058     BRA 0x40A4
673:               
674:               #if OS_FLAG_WAIT_CLR_EN > 0u
675:                       case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
676:                            flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
003FF4  90083E     MOV [W14+22], W0
003FF6  900020     MOV [W0+4], W0
003FF8  EA8080     COM W0, W1
003FFA  90084E     MOV [W14+24], W0
003FFC  608000     AND W1, W0, W0
003FFE  980730     MOV W0, [W14+6]
677:                            if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
004000  9000BE     MOV [W14+6], W1
004002  90084E     MOV [W14+24], W0
004004  508F80     SUB W1, W0, [W15]
004006  3A0013     BRA NZ, 0x402E
678:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
004008  78401E     MOV.B [W14], W0
00400A  504FE1     SUB.B W0, #0x1, [W15]
00400C  3A0006     BRA NZ, 0x401A
679:                                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00400E  90083E     MOV [W14+22], W0
004010  9000A0     MOV [W0+4], W1
004012  90003E     MOV [W14+6], W0
004014  700081     IOR W0, W1, W1
004016  90083E     MOV [W14+22], W0
004018  980021     MOV W1, [W0+4]
680:                                }
681:                                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00401A  8043B0     MOV OSTCBCur, W0
00401C  9000BE     MOV [W14+6], W1
00401E  980851     MOV W1, [W0+26]
682:                                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
004020  90009E     MOV [W14+2], W1
004022  880211     MOV W1, SR
683:                                *perr                   = OS_ERR_NONE;
004024  90100E     MOV [W14+32], W0
004026  EB4080     CLR.B W1
004028  784801     MOV.B W1, [W0]
684:                                return (flags_rdy);
00402A  90003E     MOV [W14+6], W0
00402C  37008D     BRA 0x4148
685:                            } else {                                      /* Block task until events occur or timeout */
686:                                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00402E  47006A     ADD W14, #0xA, W0
004030  900A6E     MOV [W14+28], W4
004032  900AFE     MOV [W14+30], W5
004034  9059AE     MOV.B [W14+26], W3
004036  90094E     MOV [W14+24], W2
004038  780080     MOV W0, W1
00403A  90083E     MOV [W14+22], W0
00403C  070198     RCALL _OS_FlagBlock
687:                                OS_EXIT_CRITICAL();
00403E  90009E     MOV [W14+2], W1
004040  880211     MOV W1, SR
688:                            }
689:                            break;
004042  370030     BRA 0x40A4
690:               
691:                       case OS_FLAG_WAIT_CLR_ANY:
692:                            flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
004044  90083E     MOV [W14+22], W0
004046  900020     MOV [W0+4], W0
004048  EA8080     COM W0, W1
00404A  90084E     MOV [W14+24], W0
00404C  608000     AND W1, W0, W0
00404E  980730     MOV W0, [W14+6]
693:                            if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
004050  90003E     MOV [W14+6], W0
004052  E00000     CP0 W0
004054  320013     BRA Z, 0x407C
694:                                if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
004056  78401E     MOV.B [W14], W0
004058  504FE1     SUB.B W0, #0x1, [W15]
00405A  3A0006     BRA NZ, 0x4068
695:                                    pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00405C  90083E     MOV [W14+22], W0
00405E  9000A0     MOV [W0+4], W1
004060  90003E     MOV [W14+6], W0
004062  700081     IOR W0, W1, W1
004064  90083E     MOV [W14+22], W0
004066  980021     MOV W1, [W0+4]
696:                                }
697:                                OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
004068  8043B0     MOV OSTCBCur, W0
00406A  9000BE     MOV [W14+6], W1
00406C  980851     MOV W1, [W0+26]
698:                                OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00406E  90009E     MOV [W14+2], W1
004070  880211     MOV W1, SR
699:                                *perr                   = OS_ERR_NONE;
004072  90100E     MOV [W14+32], W0
004074  EB4080     CLR.B W1
004076  784801     MOV.B W1, [W0]
700:                                return (flags_rdy);
004078  90003E     MOV [W14+6], W0
00407A  370066     BRA 0x4148
701:                            } else {                                      /* Block task until events occur or timeout */
702:                                OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00407C  47006A     ADD W14, #0xA, W0
00407E  900A6E     MOV [W14+28], W4
004080  900AFE     MOV [W14+30], W5
004082  9059AE     MOV.B [W14+26], W3
004084  90094E     MOV [W14+24], W2
004086  780080     MOV W0, W1
004088  90083E     MOV [W14+22], W0
00408A  070171     RCALL _OS_FlagBlock
703:                                OS_EXIT_CRITICAL();
00408C  90009E     MOV [W14+2], W1
00408E  880211     MOV W1, SR
704:                            }
705:                            break;
004090  370009     BRA 0x40A4
706:               #endif
707:               
708:                       default:
709:                            OS_EXIT_CRITICAL();
004092  90009E     MOV [W14+2], W1
004094  880211     MOV W1, SR
710:                            flags_rdy = (OS_FLAGS)0;
004096  EB0000     CLR W0
004098  980730     MOV W0, [W14+6]
711:                            *perr      = OS_ERR_FLAG_WAIT_TYPE;
00409A  90100E     MOV [W14+32], W0
00409C  B3C6F1     MOV.B #0x6F, W1
00409E  784801     MOV.B W1, [W0]
712:                            return (flags_rdy);
0040A0  90003E     MOV [W14+6], W0
0040A2  370052     BRA 0x4148
713:                   }
714:               /*$PAGE*/
715:                   OS_Sched();                                            /* Find next HPT ready to run               */
0040A4  07E945     RCALL OS_Sched
716:                   OS_ENTER_CRITICAL();
0040A6  800211     MOV SR, W1
0040A8  980711     MOV W1, [W14+2]
0040AA  800211     MOV SR, W1
0040AC  200E00     MOV #0xE0, W0
0040AE  700001     IOR W0, W1, W0
0040B0  880210     MOV W0, SR
717:                   if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
0040B2  8043B0     MOV OSTCBCur, W0
0040B4  906010     MOV.B [W0+33], W0
0040B6  E00400     CP0.B W0
0040B8  32001D     BRA Z, 0x40F4
718:                       pend_stat                = OSTCBCur->OSTCBStatPend;
0040BA  8043B0     MOV OSTCBCur, W0
0040BC  906090     MOV.B [W0+33], W1
0040BE  984F01     MOV.B W1, [W14+8]
719:                       OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0040C0  8043B0     MOV OSTCBCur, W0
0040C2  EB4080     CLR.B W1
0040C4  986011     MOV.B W1, [W0+33]
720:                       OS_FlagUnlink(&node);
0040C6  47006A     ADD W14, #0xA, W0
0040C8  0701ED     RCALL OS_FlagUnlink
721:                       OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
0040CA  8043B0     MOV OSTCBCur, W0
0040CC  EB4080     CLR.B W1
0040CE  986001     MOV.B W1, [W0+32]
722:                       OS_EXIT_CRITICAL();
0040D0  90009E     MOV [W14+2], W1
0040D2  880211     MOV W1, SR
723:                       flags_rdy                = (OS_FLAGS)0;
0040D4  EB0000     CLR W0
0040D6  980730     MOV W0, [W14+6]
724:                       switch (pend_stat) {
0040D8  90480E     MOV.B [W14+8], W0
0040DA  FB8000     ZE W0, W0
0040DC  500FE2     SUB W0, #0x2, [W15]
0040DE  3A0004     BRA NZ, 0x40E8
725:                           case OS_STAT_PEND_ABORT:
726:                                *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
0040E0  90100E     MOV [W14+32], W0
0040E2  B3C0E1     MOV.B #0xE, W1
0040E4  784801     MOV.B W1, [W0]
727:                                break;
0040E6  370004     BRA 0x40F0
728:               
729:                           case OS_STAT_PEND_TO:
730:                           default:
731:                                *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
0040E8  90100E     MOV [W14+32], W0
0040EA  B3C0A1     MOV.B #0xA, W1
0040EC  784801     MOV.B W1, [W0]
732:                                break;
0040EE  000000     NOP
733:                       }
734:                       return (flags_rdy);
0040F0  90003E     MOV [W14+6], W0
0040F2  37002A     BRA 0x4148
735:                   }
736:                   flags_rdy = OSTCBCur->OSTCBFlagsRdy;
0040F4  8043B0     MOV OSTCBCur, W0
0040F6  9008D0     MOV [W0+26], W1
0040F8  980731     MOV W1, [W14+6]
737:                   if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
0040FA  78401E     MOV.B [W14], W0
0040FC  504FE1     SUB.B W0, #0x1, [W15]
0040FE  3A001E     BRA NZ, 0x413C
738:                       switch (wait_type) {
004100  90582E     MOV.B [W14+26], W0
004102  FB8000     ZE W0, W0
004104  E00000     CP0 W0
004106  350013     BRA LT, 0x412E
004108  500FE1     SUB W0, #0x1, [W15]
00410A  34000A     BRA LE, 0x4120
00410C  500FE3     SUB W0, #0x3, [W15]
00410E  3C000F     BRA GT, 0x412E
739:                           case OS_FLAG_WAIT_SET_ALL:
740:                           case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
741:                                pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
004110  90083E     MOV [W14+22], W0
004112  9000A0     MOV [W0+4], W1
004114  90003E     MOV [W14+6], W0
004116  EA8000     COM W0, W0
004118  608080     AND W1, W0, W1
00411A  90083E     MOV [W14+22], W0
00411C  980021     MOV W1, [W0+4]
742:                                break;
00411E  37000E     BRA 0x413C
743:               
744:               #if OS_FLAG_WAIT_CLR_EN > 0u
745:                           case OS_FLAG_WAIT_CLR_ALL:
746:                           case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
747:                                pgrp->OSFlagFlags |=  flags_rdy;
004120  90083E     MOV [W14+22], W0
004122  9000A0     MOV [W0+4], W1
004124  90003E     MOV [W14+6], W0
004126  700081     IOR W0, W1, W1
004128  90083E     MOV [W14+22], W0
00412A  980021     MOV W1, [W0+4]
748:                                break;
00412C  370007     BRA 0x413C
749:               #endif
750:                           default:
751:                                OS_EXIT_CRITICAL();
00412E  90009E     MOV [W14+2], W1
004130  880211     MOV W1, SR
752:                                *perr = OS_ERR_FLAG_WAIT_TYPE;
004132  90100E     MOV [W14+32], W0
004134  B3C6F1     MOV.B #0x6F, W1
004136  784801     MOV.B W1, [W0]
753:                                return ((OS_FLAGS)0);
004138  EB0000     CLR W0
00413A  370006     BRA 0x4148
754:                       }
755:                   }
756:                   OS_EXIT_CRITICAL();
00413C  90009E     MOV [W14+2], W1
00413E  880211     MOV W1, SR
757:                   *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
004140  90100E     MOV [W14+32], W0
004142  EB4080     CLR.B W1
004144  784801     MOV.B W1, [W0]
758:                   return (flags_rdy);
004146  90003E     MOV [W14+6], W0
759:               }
004148  FA8000     ULNK
00414A  060000     RETURN
760:               /*$PAGE*/
761:               /*
762:               *********************************************************************************************************
763:               *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
764:               *
765:               * Description: This function is called to obtain the flags that caused the task to become ready to run.
766:               *              In other words, this function allows you to tell "Who done it!".
767:               *
768:               * Arguments  : None
769:               *
770:               * Returns    : The flags that caused the task to be ready.
771:               *
772:               * Called from: Task ONLY
773:               *********************************************************************************************************
774:               */
775:               
776:               OS_FLAGS  OSFlagPendGetFlagsRdy (void)
777:               {
00414C  FA0004     LNK #0x4
778:                   OS_FLAGS      flags;
779:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
780:                   OS_CPU_SR     cpu_sr = 0u;
00414E  EB0000     CLR W0
004150  780F00     MOV W0, [W14]
781:               #endif
782:               
783:               
784:               
785:                   OS_ENTER_CRITICAL();
004152  800211     MOV SR, W1
004154  780F01     MOV W1, [W14]
004156  800211     MOV SR, W1
004158  200E00     MOV #0xE0, W0
00415A  700001     IOR W0, W1, W0
00415C  880210     MOV W0, SR
786:                   flags = OSTCBCur->OSTCBFlagsRdy;
00415E  8043B0     MOV OSTCBCur, W0
004160  9008D0     MOV [W0+26], W1
004162  980711     MOV W1, [W14+2]
787:                   OS_EXIT_CRITICAL();
004164  78009E     MOV [W14], W1
004166  880211     MOV W1, SR
788:                   return (flags);
004168  90001E     MOV [W14+2], W0
789:               }
00416A  FA8000     ULNK
00416C  060000     RETURN
790:               
791:               /*$PAGE*/
792:               /*
793:               *********************************************************************************************************
794:               *                                       POST EVENT FLAG BIT(S)
795:               *
796:               * Description: This function is called to set or clear some bits in an event flag group.  The bits to
797:               *              set or clear are specified by a 'bit mask'.
798:               *
799:               * Arguments  : pgrp          is a pointer to the desired event flag group.
800:               *
801:               *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
802:               *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
803:               *                            and 5 you would set 'flags' to:
804:               *
805:               *                                0x31     (note, bit 0 is least significant bit)
806:               *
807:               *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
808:               *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
809:               *                            4 and 5 you would specify 'flags' as:
810:               *
811:               *                                0x31     (note, bit 0 is least significant bit)
812:               *
813:               *              opt           indicates whether the flags will be:
814:               *                                set     (OS_FLAG_SET) or
815:               *                                cleared (OS_FLAG_CLR)
816:               *
817:               *              perr          is a pointer to an error code and can be:
818:               *                            OS_ERR_NONE                The call was successfull
819:               *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
820:               *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
821:               *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
822:               *
823:               * Returns    : the new value of the event flags bits that are still set.
824:               *
825:               * Called From: Task or ISR
826:               *
827:               * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
828:               *                 flag group.
829:               *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
830:               *                 the event flag group.
831:               *********************************************************************************************************
832:               */
833:               OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
834:                                     OS_FLAGS      flags,
835:                                     INT8U         opt,
836:                                     INT8U        *perr)
837:               {
00416E  FA0014     LNK #0x14
004170  980760     MOV W0, [W14+12]
004172  980771     MOV W1, [W14+14]
004174  985702     MOV.B W2, [W14+16]
004176  980F13     MOV W3, [W14+18]
838:                   OS_FLAG_NODE *pnode;
839:                   BOOLEAN       sched;
840:                   OS_FLAGS      flags_cur;
841:                   OS_FLAGS      flags_rdy;
842:                   BOOLEAN       rdy;
843:               #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
844:                   OS_CPU_SR     cpu_sr = 0u;
004178  EB0000     CLR W0
00417A  980720     MOV W0, [W14+4]
845:               #endif
846:               
847:               
848:               
849:               #ifdef OS_SAFETY_CRITICAL
850:                   if (perr == (INT8U *)0) {
851:                       OS_SAFETY_CRITICAL_EXCEPTION();
852:                       return ((OS_FLAGS)0);
853:                   }
854:               #endif
855:               
856:               #if OS_ARG_CHK_EN > 0u
857:                   if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
00417C  90006E     MOV [W14+12], W0
00417E  E00000     CP0 W0
004180  3A0005     BRA NZ, 0x418C
858:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
004182  90081E     MOV [W14+18], W0
004184  B3C6E1     MOV.B #0x6E, W1
004186  784801     MOV.B W1, [W0]
859:                       return ((OS_FLAGS)0);
004188  EB0000     CLR W0
00418A  3700C8     BRA 0x431C
860:                   }
861:               #endif
862:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00418C  90006E     MOV [W14+12], W0
00418E  784010     MOV.B [W0], W0
004190  504FE5     SUB.B W0, #0x5, [W15]
004192  320005     BRA Z, 0x419E
863:                       *perr = OS_ERR_EVENT_TYPE;
004194  90081E     MOV [W14+18], W0
004196  B3C011     MOV.B #0x1, W1
004198  784801     MOV.B W1, [W0]
864:                       return ((OS_FLAGS)0);
00419A  EB0000     CLR W0
00419C  3700BF     BRA 0x431C
865:                   }
866:               /*$PAGE*/
867:                   OS_ENTER_CRITICAL();
00419E  800211     MOV SR, W1
0041A0  980721     MOV W1, [W14+4]
0041A2  800211     MOV SR, W1
0041A4  200E00     MOV #0xE0, W0
0041A6  700001     IOR W0, W1, W0
0041A8  880210     MOV W0, SR
868:                   switch (opt) {
0041AA  90500E     MOV.B [W14+16], W0
0041AC  FB8000     ZE W0, W0
0041AE  E00000     CP0 W0
0041B0  320003     BRA Z, 0x41B8
0041B2  500FE1     SUB W0, #0x1, [W15]
0041B4  320009     BRA Z, 0x41C8
0041B6  37000F     BRA 0x41D6
869:                       case OS_FLAG_CLR:
870:                            pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
0041B8  90006E     MOV [W14+12], W0
0041BA  9000A0     MOV [W0+4], W1
0041BC  90007E     MOV [W14+14], W0
0041BE  EA8000     COM W0, W0
0041C0  608080     AND W1, W0, W1
0041C2  90006E     MOV [W14+12], W0
0041C4  980021     MOV W1, [W0+4]
871:                            break;
0041C6  37000E     BRA 0x41E4
872:               
873:                       case OS_FLAG_SET:
874:                            pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
0041C8  90006E     MOV [W14+12], W0
0041CA  9000A0     MOV [W0+4], W1
0041CC  90007E     MOV [W14+14], W0
0041CE  700081     IOR W0, W1, W1
0041D0  90006E     MOV [W14+12], W0
0041D2  980021     MOV W1, [W0+4]
875:                            break;
0041D4  370007     BRA 0x41E4
876:               
877:                       default:
878:                            OS_EXIT_CRITICAL();                     /* INVALID option                                 */
0041D6  9000AE     MOV [W14+4], W1
0041D8  880211     MOV W1, SR
879:                            *perr = OS_ERR_FLAG_INVALID_OPT;
0041DA  90081E     MOV [W14+18], W0
0041DC  B3C711     MOV.B #0x71, W1
0041DE  784801     MOV.B W1, [W0]
880:                            return ((OS_FLAGS)0);
0041E0  EB0000     CLR W0
0041E2  37009C     BRA 0x431C
881:                   }
882:                   sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
0041E4  EB4000     CLR.B W0
0041E6  984720     MOV.B W0, [W14+2]
883:                   pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
0041E8  90006E     MOV [W14+12], W0
0041EA  900010     MOV [W0+2], W0
0041EC  780F00     MOV W0, [W14]
884:                   while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
0041EE  37007E     BRA 0x42EC
0042EC  78001E     MOV [W14], W0
0042EE  E00000     CP0 W0
0042F0  3AFF7F     BRA NZ, 0x41F0
885:                       switch (pnode->OSFlagNodeWaitType) {
0041F0  78001E     MOV [W14], W0
0041F2  904820     MOV.B [W0+10], W0
0041F4  FB8000     ZE W0, W0
0041F6  500FE1     SUB W0, #0x1, [W15]
0041F8  32004B     BRA Z, 0x4290
0041FA  500FE1     SUB W0, #0x1, [W15]
0041FC  3C0003     BRA GT, 0x4204
0041FE  E00000     CP0 W0
004200  320030     BRA Z, 0x4262
004202  37005B     BRA 0x42BA
004204  500FE2     SUB W0, #0x2, [W15]
004206  320003     BRA Z, 0x420E
004208  500FE3     SUB W0, #0x3, [W15]
00420A  320017     BRA Z, 0x423A
00420C  370056     BRA 0x42BA
886:                           case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
887:                                flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00420E  90006E     MOV [W14+12], W0
004210  9000A0     MOV [W0+4], W1
004212  78001E     MOV [W14], W0
004214  900040     MOV [W0+8], W0
004216  608000     AND W1, W0, W0
004218  980730     MOV W0, [W14+6]
888:                                if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00421A  78001E     MOV [W14], W0
00421C  9000C0     MOV [W0+8], W1
00421E  90003E     MOV [W14+6], W0
004220  508F80     SUB W1, W0, [W15]
004222  3A0052     BRA NZ, 0x42C8
889:                                    rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
004224  EB4100     CLR.B W2
004226  9000BE     MOV [W14+6], W1
004228  78001E     MOV [W14], W0
00422A  070105     RCALL _OS_FlagTaskRdy
00422C  984F00     MOV.B W0, [W14+8]
890:                                    if (rdy == OS_TRUE) {
00422E  90480E     MOV.B [W14+8], W0
004230  504FE1     SUB.B W0, #0x1, [W15]
004232  3A004C     BRA NZ, 0x42CC
891:                                        sched = OS_TRUE;                     /* When done we will reschedule          */
004234  B3C010     MOV.B #0x1, W0
004236  984720     MOV.B W0, [W14+2]
892:                                    }
893:                                }
894:                                break;
004238  370056     BRA 0x42E6
0042C8  000000     NOP
0042CA  37000D     BRA 0x42E6
0042CC  000000     NOP
0042CE  37000B     BRA 0x42E6
895:               
896:                           case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
897:                                flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00423A  90006E     MOV [W14+12], W0
00423C  9000A0     MOV [W0+4], W1
00423E  78001E     MOV [W14], W0
004240  900040     MOV [W0+8], W0
004242  608000     AND W1, W0, W0
004244  980730     MOV W0, [W14+6]
898:                                if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
004246  90003E     MOV [W14+6], W0
004248  E00000     CP0 W0
00424A  320042     BRA Z, 0x42D0
899:                                    rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
00424C  EB4100     CLR.B W2
00424E  9000BE     MOV [W14+6], W1
004250  78001E     MOV [W14], W0
004252  0700F1     RCALL _OS_FlagTaskRdy
004254  984F00     MOV.B W0, [W14+8]
900:                                    if (rdy == OS_TRUE) {
004256  90480E     MOV.B [W14+8], W0
004258  504FE1     SUB.B W0, #0x1, [W15]
00425A  3A003C     BRA NZ, 0x42D4
901:                                        sched = OS_TRUE;                     /* When done we will reschedule          */
00425C  B3C010     MOV.B #0x1, W0
00425E  984720     MOV.B W0, [W14+2]
902:                                    }
903:                                }
904:                                break;
004260  370042     BRA 0x42E6
0042D0  000000     NOP
0042D2  370009     BRA 0x42E6
0042D4  000000     NOP
0042D6  370007     BRA 0x42E6
905:               
906:               #if OS_FLAG_WAIT_CLR_EN > 0u
907:                           case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
908:                                flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
004262  90006E     MOV [W14+12], W0
004264  900020     MOV [W0+4], W0
004266  EA8080     COM W0, W1
004268  78001E     MOV [W14], W0
00426A  900040     MOV [W0+8], W0
00426C  608000     AND W1, W0, W0
00426E  980730     MOV W0, [W14+6]
909:                                if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
004270  78001E     MOV [W14], W0
004272  9000C0     MOV [W0+8], W1
004274  90003E     MOV [W14+6], W0
004276  508F80     SUB W1, W0, [W15]
004278  3A002F     BRA NZ, 0x42D8
910:                                    rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
00427A  EB4100     CLR.B W2
00427C  9000BE     MOV [W14+6], W1
00427E  78001E     MOV [W14], W0
004280  0700DA     RCALL _OS_FlagTaskRdy
004282  984F00     MOV.B W0, [W14+8]
911:                                    if (rdy == OS_TRUE) {
004284  90480E     MOV.B [W14+8], W0
004286  504FE1     SUB.B W0, #0x1, [W15]
004288  3A0029     BRA NZ, 0x42DC
912:                                        sched = OS_TRUE;                     /* When done we will reschedule          */
00428A  B3C010     MOV.B #0x1, W0
00428C  984720     MOV.B W0, [W14+2]
913:                                    }
914:                                }
915:                                break;
00428E  37002B     BRA 0x42E6
0042D8  000000     NOP
0042DA  370005     BRA 0x42E6
0042DC  000000     NOP
0042DE  370003     BRA 0x42E6
916:               
917:                           case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
918:                                flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
004290  90006E     MOV [W14+12], W0
004292  900020     MOV [W0+4], W0
004294  EA8080     COM W0, W1
004296  78001E     MOV [W14], W0
004298  900040     MOV [W0+8], W0
00429A  608000     AND W1, W0, W0
00429C  980730     MOV W0, [W14+6]
919:                                if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00429E  90003E     MOV [W14+6], W0
0042A0  E00000     CP0 W0
0042A2  32001E     BRA Z, 0x42E0
920:                                    rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
0042A4  EB4100     CLR.B W2
0042A6  9000BE     MOV [W14+6], W1
0042A8  78001E     MOV [W14], W0
0042AA  0700C5     RCALL _OS_FlagTaskRdy
0042AC  984F00     MOV.B W0, [W14+8]
921:                                    if (rdy == OS_TRUE) {
0042AE  90480E     MOV.B [W14+8], W0
0042B0  504FE1     SUB.B W0, #0x1, [W15]
0042B2  3A0018     BRA NZ, 0x42E4
922:                                        sched = OS_TRUE;                     /* When done we will reschedule          */
0042B4  B3C010     MOV.B #0x1, W0
0042B6  984720     MOV.B W0, [W14+2]
923:                                    }
924:                                }
925:                                break;
0042B8  370016     BRA 0x42E6
0042E0  000000     NOP
0042E2  370001     BRA 0x42E6
0042E4  000000     NOP
926:               #endif
927:                           default:
928:                                OS_EXIT_CRITICAL();
0042BA  9000AE     MOV [W14+4], W1
0042BC  880211     MOV W1, SR
929:                                *perr = OS_ERR_FLAG_WAIT_TYPE;
0042BE  90081E     MOV [W14+18], W0
0042C0  B3C6F1     MOV.B #0x6F, W1
0042C2  784801     MOV.B W1, [W0]
930:                                return ((OS_FLAGS)0);
0042C4  EB0000     CLR W0
0042C6  37002A     BRA 0x431C
931:                       }
932:                       pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
0042E6  78001E     MOV [W14], W0
0042E8  780010     MOV [W0], W0
0042EA  780F00     MOV W0, [W14]
933:                   }
934:                   OS_EXIT_CRITICAL();
0042F2  9000AE     MOV [W14+4], W1
0042F4  880211     MOV W1, SR
935:                   if (sched == OS_TRUE) {
0042F6  90402E     MOV.B [W14+2], W0
0042F8  504FE1     SUB.B W0, #0x1, [W15]
0042FA  3A0001     BRA NZ, 0x42FE
936:                       OS_Sched();
0042FC  07E819     RCALL OS_Sched
937:                   }
938:                   OS_ENTER_CRITICAL();
0042FE  800211     MOV SR, W1
004300  980721     MOV W1, [W14+4]
004302  800211     MOV SR, W1
004304  200E00     MOV #0xE0, W0
004306  700001     IOR W0, W1, W0
004308  880210     MOV W0, SR
939:                   flags_cur = pgrp->OSFlagFlags;
00430A  90006E     MOV [W14+12], W0
00430C  9000A0     MOV [W0+4], W1
00430E  980751     MOV W1, [W14+10]
940:                   OS_EXIT_CRITICAL();
004310  9000AE     MOV [W14+4], W1
004312  880211     MOV W1, SR
941:                   *perr     = OS_ERR_NONE;
004314  90081E     MOV [W14+18], W0
004316  EB4080     CLR.B W1
004318  784801     MOV.B W1, [W0]
942:                   return (flags_cur);
00431A  90005E     MOV [W14+10], W0
943:               }
00431C  FA8000     ULNK
00431E  060000     RETURN
944:               /*$PAGE*/
945:               /*
946:               *********************************************************************************************************
947:               *                                          QUERY EVENT FLAG
948:               *
949:               * Description: This function is used to check the value of the event flag group.
950:               *
951:               * Arguments  : pgrp         is a pointer to the desired event flag group.
952:               *
953:               *              perr          is a pointer to an error code returned to the called:
954:               *                            OS_ERR_NONE                The call was successfull
955:               *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
956:               *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
957:               *
958:               * Returns    : The current value of the event flag group.
959:               *
960:               * Called From: Task or ISR
961:               *********************************************************************************************************
962:               */
963:               
964:               #if OS_FLAG_QUERY_EN > 0u
965:               OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
966:                                      INT8U        *perr)
967:               {
004320  FA0008     LNK #0x8
004322  980720     MOV W0, [W14+4]
004324  980731     MOV W1, [W14+6]
968:                   OS_FLAGS   flags;
969:               #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
970:                   OS_CPU_SR  cpu_sr = 0u;
004326  EB0000     CLR W0
004328  780F00     MOV W0, [W14]
971:               #endif
972:               
973:               
974:               
975:               #ifdef OS_SAFETY_CRITICAL
976:                   if (perr == (INT8U *)0) {
977:                       OS_SAFETY_CRITICAL_EXCEPTION();
978:                       return ((OS_FLAGS)0);
979:                   }
980:               #endif
981:               
982:               #if OS_ARG_CHK_EN > 0u
983:                   if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
00432A  90002E     MOV [W14+4], W0
00432C  E00000     CP0 W0
00432E  3A0005     BRA NZ, 0x433A
984:                       *perr = OS_ERR_FLAG_INVALID_PGRP;
004330  90003E     MOV [W14+6], W0
004332  B3C6E1     MOV.B #0x6E, W1
004334  784801     MOV.B W1, [W0]
985:                       return ((OS_FLAGS)0);
004336  EB0000     CLR W0
004338  370018     BRA 0x436A
986:                   }
987:               #endif
988:                   if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00433A  90002E     MOV [W14+4], W0
00433C  784010     MOV.B [W0], W0
00433E  504FE5     SUB.B W0, #0x5, [W15]
004340  320005     BRA Z, 0x434C
989:                       *perr = OS_ERR_EVENT_TYPE;
004342  90003E     MOV [W14+6], W0
004344  B3C011     MOV.B #0x1, W1
004346  784801     MOV.B W1, [W0]
990:                       return ((OS_FLAGS)0);
004348  EB0000     CLR W0
00434A  37000F     BRA 0x436A
991:                   }
992:                   OS_ENTER_CRITICAL();
00434C  800211     MOV SR, W1
00434E  780F01     MOV W1, [W14]
004350  800211     MOV SR, W1
004352  200E00     MOV #0xE0, W0
004354  700001     IOR W0, W1, W0
004356  880210     MOV W0, SR
993:                   flags = pgrp->OSFlagFlags;
004358  90002E     MOV [W14+4], W0
00435A  9000A0     MOV [W0+4], W1
00435C  980711     MOV W1, [W14+2]
994:                   OS_EXIT_CRITICAL();
00435E  78009E     MOV [W14], W1
004360  880211     MOV W1, SR
995:                   *perr = OS_ERR_NONE;
004362  90003E     MOV [W14+6], W0
004364  EB4080     CLR.B W1
004366  784801     MOV.B W1, [W0]
996:                   return (flags);                               /* Return the current value of the event flags       */
004368  90001E     MOV [W14+2], W0
997:               }
00436A  FA8000     ULNK
00436C  060000     RETURN
998:               #endif
999:               
1000:              /*$PAGE*/
1001:              /*
1002:              *********************************************************************************************************
1003:              *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
1004:              *
1005:              * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
1006:              *              event flag bit(s) are set.
1007:              *
1008:              * Arguments  : pgrp          is a pointer to the desired event flag group.
1009:              *
1010:              *              pnode         is a pointer to a structure which contains data about the task waiting for
1011:              *                            event flag bit(s) to be set.
1012:              *
1013:              *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
1014:              *                            The bits you want are specified by setting the corresponding bits in
1015:              *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
1016:              *                            'flags' would contain 0x03.
1017:              *
1018:              *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
1019:              *                            to be set/cleared.
1020:              *                            You can specify the following argument:
1021:              *
1022:              *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
1023:              *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
1024:              *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
1025:              *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
1026:              *
1027:              *              timeout       is the desired amount of time that the task will wait for the event flag
1028:              *                            bit(s) to be set.
1029:              *
1030:              * Returns    : none
1031:              *
1032:              * Called by  : OSFlagPend()  OS_FLAG.C
1033:              *
1034:              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
1035:              *********************************************************************************************************
1036:              */
1037:              
1038:              static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
1039:                                          OS_FLAG_NODE *pnode,
1040:                                          OS_FLAGS      flags,
1041:                                          INT8U         wait_type,
1042:                                          INT32U        timeout)
1043:              {
00436E  FA0010     LNK #0x10
004370  980720     MOV W0, [W14+4]
004372  980731     MOV W1, [W14+6]
004374  980742     MOV W2, [W14+8]
004376  984F23     MOV.B W3, [W14+10]
004378  980764     MOV W4, [W14+12]
00437A  980775     MOV W5, [W14+14]
1044:                  OS_FLAG_NODE  *pnode_next;
1045:                  INT8U          y;
1046:              
1047:              
1048:                  OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
00437C  8043B0     MOV OSTCBCur, W0
00437E  8043B1     MOV OSTCBCur, W1
004380  906081     MOV.B [W1+32], W1
004382  A05401     BSET.B W1, #5
004384  986001     MOV.B W1, [W0+32]
1049:                  OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
004386  8043B0     MOV OSTCBCur, W0
004388  EB4080     CLR.B W1
00438A  986011     MOV.B W1, [W0+33]
1050:                  OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00438C  8043B0     MOV OSTCBCur, W0
00438E  90016E     MOV [W14+12], W2
004390  9001FE     MOV [W14+14], W3
004392  980862     MOV W2, [W0+28]
004394  980873     MOV W3, [W0+30]
1051:              #if OS_TASK_DEL_EN > 0u
1052:                  OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
004396  8043B0     MOV OSTCBCur, W0
004398  9001BE     MOV [W14+6], W3
00439A  980843     MOV W3, [W0+24]
1053:              #endif
1054:                  pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
00439C  90003E     MOV [W14+6], W0
00439E  9000CE     MOV [W14+8], W1
0043A0  980041     MOV W1, [W0+8]
1055:                  pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
0043A2  90003E     MOV [W14+6], W0
0043A4  90492E     MOV.B [W14+10], W2
0043A6  984822     MOV.B W2, [W0+10]
1056:                  pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
0043A8  8043B1     MOV OSTCBCur, W1
0043AA  90003E     MOV [W14+6], W0
0043AC  980021     MOV W1, [W0+4]
1057:                  pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
0043AE  90002E     MOV [W14+4], W0
0043B0  900090     MOV [W0+2], W1
0043B2  90003E     MOV [W14+6], W0
0043B4  780801     MOV W1, [W0]
1058:                  pnode->OSFlagNodePrev     = (void *)0;
0043B6  90003E     MOV [W14+6], W0
0043B8  EB0080     CLR W1
0043BA  980011     MOV W1, [W0+2]
1059:                  pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
0043BC  90003E     MOV [W14+6], W0
0043BE  9001AE     MOV [W14+4], W3
0043C0  980033     MOV W3, [W0+6]
1060:                  pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
0043C2  90002E     MOV [W14+4], W0
0043C4  900010     MOV [W0+2], W0
0043C6  780F00     MOV W0, [W14]
1061:                  if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
0043C8  78001E     MOV [W14], W0
0043CA  E00000     CP0 W0
0043CC  320003     BRA Z, 0x43D4
1062:                      pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
0043CE  78001E     MOV [W14], W0
0043D0  9000BE     MOV [W14+6], W1
0043D2  980011     MOV W1, [W0+2]
1063:                  }
1064:                  pgrp->OSFlagWaitList = (void *)pnode;
0043D4  90002E     MOV [W14+4], W0
0043D6  90013E     MOV [W14+6], W2
0043D8  980012     MOV W2, [W0+2]
1065:              
1066:                  y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
0043DA  8043B0     MOV OSTCBCur, W0
0043DC  9061C0     MOV.B [W0+36], W3
0043DE  984723     MOV.B W3, [W14+2]
1067:                  OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0043E0  90402E     MOV.B [W14+2], W0
0043E2  FB8000     ZE W0, W0
0043E4  9040AE     MOV.B [W14+2], W1
0043E6  FB8081     ZE W1, W1
0043E8  209402     MOV #0x940, W2
0043EA  78C162     MOV.B [W2+W1], W2
0043EC  8043B1     MOV OSTCBCur, W1
0043EE  9060D1     MOV.B [W1+37], W1
0043F0  EAC081     COM.B W1, W1
0043F2  614101     AND.B W2, W1, W2
0043F4  209401     MOV #0x940, W1
0043F6  787082     MOV.B W2, [W1+W0]
1068:                  if (OSRdyTbl[y] == 0x00u) {
0043F8  90402E     MOV.B [W14+2], W0
0043FA  FB8000     ZE W0, W0
0043FC  209401     MOV #0x940, W1
0043FE  784061     MOV.B [W1+W0], W0
004400  E00400     CP0.B W0
004402  3A0006     BRA NZ, 0x4410
1069:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
004404  8043B0     MOV OSTCBCur, W0
004406  906060     MOV.B [W0+38], W0
004408  EAC080     COM.B W0, W1
00440A  BFC86F     MOV.B OSRdyGrp, WREG
00440C  60C000     AND.B W1, W0, W0
00440E  B7E86F     MOV.B WREG, OSRdyGrp
1070:                  }
1071:              }
004410  FA8000     ULNK
004412  060000     RETURN
1072:              
1073:              /*$PAGE*/
1074:              /*
1075:              *********************************************************************************************************
1076:              *                                  INITIALIZE THE EVENT FLAG MODULE
1077:              *
1078:              * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
1079:              *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
1080:              *
1081:              * Arguments  : none
1082:              *
1083:              * Returns    : none
1084:              *
1085:              * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
1086:              *********************************************************************************************************
1087:              */
1088:              
1089:              void  OS_FlagInit (void)
1090:              {
004414  FA0000     LNK #0x0
1091:              #if OS_MAX_FLAGS == 1u
1092:                  OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
004416  208560     MOV #0x856, W0
004418  8842F0     MOV W0, OSFlagFreeList
1093:                  OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00441A  8042F0     MOV OSFlagFreeList, W0
00441C  EB4080     CLR.B W1
00441E  784801     MOV.B W1, [W0]
1094:                  OSFlagFreeList->OSFlagWaitList = (void *)0;
004420  8042F0     MOV OSFlagFreeList, W0
004422  EB0080     CLR W1
004424  980011     MOV W1, [W0+2]
1095:                  OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
004426  8042F0     MOV OSFlagFreeList, W0
004428  EB0080     CLR W1
00442A  980021     MOV W1, [W0+4]
1096:              #if OS_FLAG_NAME_EN > 0u
1097:                  OSFlagFreeList->OSFlagName     = (INT8U *)"?";
00442C  8042F0     MOV OSFlagFreeList, W0
00442E  2883C1     MOV #0x883C, W1
004430  980031     MOV W1, [W0+6]
1098:              #endif
1099:              #endif
1100:              
1101:              #if OS_MAX_FLAGS >= 2u
1102:                  INT16U        ix;
1103:                  INT16U        ix_next;
1104:                  OS_FLAG_GRP  *pgrp1;
1105:                  OS_FLAG_GRP  *pgrp2;
1106:              
1107:              
1108:                  OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
1109:                  for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
1110:                      ix_next = ix + 1u;
1111:                      pgrp1 = &OSFlagTbl[ix];
1112:                      pgrp2 = &OSFlagTbl[ix_next];
1113:                      pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
1114:                      pgrp1->OSFlagWaitList = (void *)pgrp2;
1115:              #if OS_FLAG_NAME_EN > 0u
1116:                      pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
1117:              #endif
1118:                  }
1119:                  pgrp1                 = &OSFlagTbl[ix];
1120:                  pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
1121:                  pgrp1->OSFlagWaitList = (void *)0;
1122:              #if OS_FLAG_NAME_EN > 0u
1123:                  pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
1124:              #endif
1125:                  OSFlagFreeList        = &OSFlagTbl[0];
1126:              #endif
1127:              }
004432  FA8000     ULNK
004434  060000     RETURN
1128:              
1129:              /*$PAGE*/
1130:              /*
1131:              *********************************************************************************************************
1132:              *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
1133:              *
1134:              * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
1135:              *              desired event flag bits have been set.
1136:              *
1137:              * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
1138:              *                            event flag bit(s) to be set.
1139:              *
1140:              *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
1141:              *                            ready-to-run.
1142:              *
1143:              *              pend_stat   is used to indicate the readied task's pending status:
1144:              *
1145:              *
1146:              * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
1147:              *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
1148:              *
1149:              * Called by  : OSFlagsPost() OS_FLAG.C
1150:              *
1151:              * Note(s)    : 1) This function assumes that interrupts are disabled.
1152:              *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
1153:              *********************************************************************************************************
1154:              */
1155:              
1156:              static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
1157:                                               OS_FLAGS      flags_rdy,
1158:                                               INT8U         pend_stat)
1159:              {
004436  FA000A     LNK #0xA
004438  980720     MOV W0, [W14+4]
00443A  980731     MOV W1, [W14+6]
00443C  984F02     MOV.B W2, [W14+8]
1160:                  OS_TCB   *ptcb;
1161:                  BOOLEAN   sched;
1162:              
1163:              
1164:                  ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
00443E  90002E     MOV [W14+4], W0
004440  900020     MOV [W0+4], W0
004442  980710     MOV W0, [W14+2]
1165:                  ptcb->OSTCBDly       = 0u;
004444  90011E     MOV [W14+2], W2
004446  B80060     MUL.UU W0, #0, W0
004448  980960     MOV W0, [W2+28]
00444A  980971     MOV W1, [W2+30]
1166:                  ptcb->OSTCBFlagsRdy  = flags_rdy;
00444C  90001E     MOV [W14+2], W0
00444E  9000BE     MOV [W14+6], W1
004450  980851     MOV W1, [W0+26]
1167:                  ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
004452  90001E     MOV [W14+2], W0
004454  906000     MOV.B [W0+32], W0
004456  784080     MOV.B W0, W1
004458  A15401     BCLR.B W1, #5
00445A  90001E     MOV [W14+2], W0
00445C  986001     MOV.B W1, [W0+32]
1168:                  ptcb->OSTCBStatPend  = pend_stat;
00445E  90001E     MOV [W14+2], W0
004460  90488E     MOV.B [W14+8], W1
004462  986011     MOV.B W1, [W0+33]
1169:                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
004464  90001E     MOV [W14+2], W0
004466  906000     MOV.B [W0+32], W0
004468  E00400     CP0.B W0
00446A  3A0015     BRA NZ, 0x4496
1170:                      OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
00446C  90001E     MOV [W14+2], W0
00446E  9060E0     MOV.B [W0+38], W1
004470  BFC86F     MOV.B OSRdyGrp, WREG
004472  70C000     IOR.B W1, W0, W0
004474  B7E86F     MOV.B WREG, OSRdyGrp
1171:                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
004476  90001E     MOV [W14+2], W0
004478  906040     MOV.B [W0+36], W0
00447A  FB8000     ZE W0, W0
00447C  90009E     MOV [W14+2], W1
00447E  9060C1     MOV.B [W1+36], W1
004480  FB8081     ZE W1, W1
004482  209402     MOV #0x940, W2
004484  78C162     MOV.B [W2+W1], W2
004486  90009E     MOV [W14+2], W1
004488  9060D1     MOV.B [W1+37], W1
00448A  714101     IOR.B W2, W1, W2
00448C  209401     MOV #0x940, W1
00448E  787082     MOV.B W2, [W1+W0]
1172:                      sched                   = OS_TRUE;
004490  B3C010     MOV.B #0x1, W0
004492  784F00     MOV.B W0, [W14]
004494  370002     BRA 0x449A
1173:                  } else {
1174:                      sched                   = OS_FALSE;
004496  EB4000     CLR.B W0
004498  784F00     MOV.B W0, [W14]
1175:                  }
1176:                  OS_FlagUnlink(pnode);
00449A  90002E     MOV [W14+4], W0
00449C  070003     RCALL OS_FlagUnlink
1177:                  return (sched);
00449E  78401E     MOV.B [W14], W0
1178:              }
0044A0  FA8000     ULNK
0044A2  060000     RETURN
1179:              
1180:              /*$PAGE*/
1181:              /*
1182:              *********************************************************************************************************
1183:              *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
1184:              *
1185:              * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
1186:              *              list of tasks waiting for the event flag.
1187:              *
1188:              * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
1189:              *                            event flag bit(s) to be set.
1190:              *
1191:              * Returns    : none
1192:              *
1193:              * Called by  : OS_FlagTaskRdy() OS_FLAG.C
1194:              *              OSFlagPend()     OS_FLAG.C
1195:              *              OSTaskDel()      OS_TASK.C
1196:              *
1197:              * Note(s)    : 1) This function assumes that interrupts are disabled.
1198:              *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
1199:              *********************************************************************************************************
1200:              */
1201:              
1202:              void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
1203:              {
0044A4  FA000A     LNK #0xA
0044A6  980740     MOV W0, [W14+8]
1204:              #if OS_TASK_DEL_EN > 0u
1205:                  OS_TCB       *ptcb;
1206:              #endif
1207:                  OS_FLAG_GRP  *pgrp;
1208:                  OS_FLAG_NODE *pnode_prev;
1209:                  OS_FLAG_NODE *pnode_next;
1210:              
1211:              
1212:                  pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
0044A8  90004E     MOV [W14+8], W0
0044AA  900010     MOV [W0+2], W0
0044AC  780F00     MOV W0, [W14]
1213:                  pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
0044AE  90004E     MOV [W14+8], W0
0044B0  780010     MOV [W0], W0
0044B2  980710     MOV W0, [W14+2]
1214:                  if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
0044B4  78001E     MOV [W14], W0
0044B6  E00000     CP0 W0
0044B8  3A000D     BRA NZ, 0x44D4
1215:                      pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
0044BA  90004E     MOV [W14+8], W0
0044BC  900030     MOV [W0+6], W0
0044BE  980720     MOV W0, [W14+4]
1216:                      pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
0044C0  90002E     MOV [W14+4], W0
0044C2  90009E     MOV [W14+2], W1
0044C4  980011     MOV W1, [W0+2]
1217:                      if (pnode_next != (OS_FLAG_NODE *)0) {
0044C6  90001E     MOV [W14+2], W0
0044C8  E00000     CP0 W0
0044CA  32000D     BRA Z, 0x44E6
1218:                          pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
0044CC  90001E     MOV [W14+2], W0
0044CE  EB0080     CLR W1
0044D0  980011     MOV W1, [W0+2]
0044D2  370009     BRA 0x44E6
1219:                      }
1220:                  } else {                                                    /* No,  A node somewhere in the list   */
1221:                      pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
0044D4  78001E     MOV [W14], W0
0044D6  90009E     MOV [W14+2], W1
0044D8  780801     MOV W1, [W0]
1222:                      if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
0044DA  90001E     MOV [W14+2], W0
0044DC  E00000     CP0 W0
0044DE  320003     BRA Z, 0x44E6
1223:                          pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
0044E0  90001E     MOV [W14+2], W0
0044E2  78009E     MOV [W14], W1
0044E4  980011     MOV W1, [W0+2]
1224:                      }
1225:                  }
1226:              #if OS_TASK_DEL_EN > 0u
1227:                  ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0044E6  90004E     MOV [W14+8], W0
0044E8  900020     MOV [W0+4], W0
0044EA  980730     MOV W0, [W14+6]
1228:                  ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
0044EC  90003E     MOV [W14+6], W0
0044EE  EB0080     CLR W1
0044F0  980841     MOV W1, [W0+24]
1229:              #endif
1230:              }
0044F2  FA8000     ULNK
1231:              #endif
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Source/os_core.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             CORE FUNCTIONS
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_CORE.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.10
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #define  OS_GLOBALS
28:                #include <ucos_ii.h>
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                      PRIORITY RESOLUTION TABLE
34:                *
35:                * Note: Index into table is bit pattern to resolve highest priority
36:                *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
37:                *********************************************************************************************************
38:                */
39:                
40:                INT8U  const  OSUnMapTbl[256] = {
41:                    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
42:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
43:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
44:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
45:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
46:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
47:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
48:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
49:                    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
50:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
51:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
52:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
53:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
54:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
55:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
56:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
57:                };
58:                
59:                /*$PAGE*/
60:                /*
61:                *********************************************************************************************************
62:                *                                         FUNCTION PROTOTYPES
63:                *********************************************************************************************************
64:                */
65:                
66:                static  void  OS_InitEventList(void);
67:                
68:                static  void  OS_InitMisc(void);
69:                
70:                static  void  OS_InitRdyList(void);
71:                
72:                static  void  OS_InitTaskIdle(void);
73:                
74:                #if OS_TASK_STAT_EN > 0u
75:                static  void  OS_InitTaskStat(void);
76:                #endif
77:                
78:                static  void  OS_InitTCBList(void);
79:                
80:                static  void  OS_SchedNew(void);
81:                
82:                /*$PAGE*/
83:                /*
84:                *********************************************************************************************************
85:                *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
86:                *
87:                * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
88:                *
89:                * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
90:                *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
91:                *                        type is irrelevant.
92:                *
93:                *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
94:                *                        mutex, mailbox or queue.
95:                *
96:                *              perr      is a pointer to an error code that can contain one of the following values:
97:                *
98:                *                        OS_ERR_NONE                if the name was copied to 'pname'
99:                *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
100:               *                                                   control block type.
101:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
102:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
103:               *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
104:               *
105:               * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
106:               *********************************************************************************************************
107:               */
108:               
109:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
110:               INT8U  OSEventNameGet (OS_EVENT   *pevent,
111:                                      INT8U     **pname,
112:                                      INT8U      *perr)
113:               {
000848  FA000A     LNK #0xA
00084A  980720     MOV W0, [W14+4]
00084C  980731     MOV W1, [W14+6]
00084E  980742     MOV W2, [W14+8]
114:                   INT8U      len;
115:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
116:                   OS_CPU_SR  cpu_sr = 0u;
000850  EB0000     CLR W0
000852  780F00     MOV W0, [W14]
117:               #endif
118:               
119:               
120:               
121:               #ifdef OS_SAFETY_CRITICAL
122:                   if (perr == (INT8U *)0) {
123:                       OS_SAFETY_CRITICAL_EXCEPTION();
124:                       return (0u);
125:                   }
126:               #endif
127:               
128:               #if OS_ARG_CHK_EN > 0u
129:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
000854  90002E     MOV [W14+4], W0
000856  E00000     CP0 W0
000858  3A0005     BRA NZ, 0x864
130:                       *perr = OS_ERR_PEVENT_NULL;
00085A  90004E     MOV [W14+8], W0
00085C  B3C041     MOV.B #0x4, W1
00085E  784801     MOV.B W1, [W0]
131:                       return (0u);
000860  EB4000     CLR.B W0
000862  37002F     BRA 0x8C2
132:                   }
133:                   if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
000864  90003E     MOV [W14+6], W0
000866  E00000     CP0 W0
000868  3A0005     BRA NZ, 0x874
134:                       *perr = OS_ERR_PNAME_NULL;
00086A  90004E     MOV [W14+8], W0
00086C  B3C0C1     MOV.B #0xC, W1
00086E  784801     MOV.B W1, [W0]
135:                       return (0u);
000870  EB4000     CLR.B W0
000872  370027     BRA 0x8C2
136:                   }
137:               #endif
138:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000874  BFC86B     MOV.B OSIntNesting, WREG
000876  E00400     CP0.B W0
000878  320005     BRA Z, 0x884
139:                       *perr  = OS_ERR_NAME_GET_ISR;
00087A  90004E     MOV [W14+8], W0
00087C  B3C111     MOV.B #0x11, W1
00087E  784801     MOV.B W1, [W0]
140:                       return (0u);
000880  EB4000     CLR.B W0
000882  37001F     BRA 0x8C2
141:                   }
142:                   switch (pevent->OSEventType) {
000884  90002E     MOV [W14+4], W0
000886  784010     MOV.B [W0], W0
000888  FB8000     ZE W0, W0
00088A  E90000     DEC W0, W0
00088C  500FE3     SUB W0, #0x3, [W15]
00088E  3E0015     BRA GTU, 0x8BA
143:                       case OS_EVENT_TYPE_SEM:
144:                       case OS_EVENT_TYPE_MUTEX:
145:                       case OS_EVENT_TYPE_MBOX:
146:                       case OS_EVENT_TYPE_Q:
147:                            break;
148:               
149:                       default:
150:                            *perr = OS_ERR_EVENT_TYPE;
0008BA  90004E     MOV [W14+8], W0
0008BC  B3C011     MOV.B #0x1, W1
0008BE  784801     MOV.B W1, [W0]
151:                            return (0u);
0008C0  EB4000     CLR.B W0
152:                   }
153:                   OS_ENTER_CRITICAL();
000890  800211     MOV SR, W1
000892  780F01     MOV W1, [W14]
000894  800211     MOV SR, W1
000896  200E00     MOV #0xE0, W0
000898  700001     IOR W0, W1, W0
00089A  880210     MOV W0, SR
154:                   *pname = pevent->OSEventName;
00089C  90002E     MOV [W14+4], W0
00089E  9000D0     MOV [W0+10], W1
0008A0  90003E     MOV [W14+6], W0
0008A2  780801     MOV W1, [W0]
155:                   len    = OS_StrLen(*pname);
0008A4  90003E     MOV [W14+6], W0
0008A6  780010     MOV [W0], W0
0008A8  070583     RCALL OS_StrLen
0008AA  984720     MOV.B W0, [W14+2]
156:                   OS_EXIT_CRITICAL();
0008AC  78009E     MOV [W14], W1
0008AE  880211     MOV W1, SR
157:                   *perr  = OS_ERR_NONE;
0008B0  90004E     MOV [W14+8], W0
0008B2  EB4080     CLR.B W1
0008B4  784801     MOV.B W1, [W0]
158:                   return (len);
0008B6  90402E     MOV.B [W14+2], W0
0008B8  370004     BRA 0x8C2
159:               }
0008C2  FA8000     ULNK
0008C4  060000     RETURN
160:               #endif
161:               
162:               /*$PAGE*/
163:               /*
164:               *********************************************************************************************************
165:               *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
166:               *
167:               * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
168:               *
169:               * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
170:               *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
171:               *                        matter the actual type.
172:               *
173:               *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
174:               *                        mutex, mailbox or queue.
175:               *
176:               *              perr      is a pointer to an error code that can contain one of the following values:
177:               *
178:               *                        OS_ERR_NONE                if the requested task is resumed
179:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
180:               *                                                   control block type.
181:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
182:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
183:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
184:               *
185:               * Returns    : None
186:               *********************************************************************************************************
187:               */
188:               
189:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
190:               void  OSEventNameSet (OS_EVENT  *pevent,
191:                                     INT8U     *pname,
192:                                     INT8U     *perr)
193:               {
0008C6  FA0008     LNK #0x8
0008C8  980710     MOV W0, [W14+2]
0008CA  980721     MOV W1, [W14+4]
0008CC  980732     MOV W2, [W14+6]
194:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
195:                   OS_CPU_SR  cpu_sr = 0u;
0008CE  EB0000     CLR W0
0008D0  780F00     MOV W0, [W14]
196:               #endif
197:               
198:               
199:               
200:               #ifdef OS_SAFETY_CRITICAL
201:                   if (perr == (INT8U *)0) {
202:                       OS_SAFETY_CRITICAL_EXCEPTION();
203:                       return;
204:                   }
205:               #endif
206:               
207:               #if OS_ARG_CHK_EN > 0u
208:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
0008D2  90001E     MOV [W14+2], W0
0008D4  E00000     CP0 W0
0008D6  3A0004     BRA NZ, 0x8E0
209:                       *perr = OS_ERR_PEVENT_NULL;
0008D8  90003E     MOV [W14+6], W0
0008DA  B3C041     MOV.B #0x4, W1
0008DC  784801     MOV.B W1, [W0]
210:                       return;
0008DE  370027     BRA 0x92E
211:                   }
212:                   if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
0008E0  90002E     MOV [W14+4], W0
0008E2  E00000     CP0 W0
0008E4  3A0004     BRA NZ, 0x8EE
213:                       *perr = OS_ERR_PNAME_NULL;
0008E6  90003E     MOV [W14+6], W0
0008E8  B3C0C1     MOV.B #0xC, W1
0008EA  784801     MOV.B W1, [W0]
214:                       return;
0008EC  370020     BRA 0x92E
215:                   }
216:               #endif
217:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0008EE  BFC86B     MOV.B OSIntNesting, WREG
0008F0  E00400     CP0.B W0
0008F2  320004     BRA Z, 0x8FC
218:                       *perr = OS_ERR_NAME_SET_ISR;
0008F4  90003E     MOV [W14+6], W0
0008F6  B3C121     MOV.B #0x12, W1
0008F8  784801     MOV.B W1, [W0]
219:                       return;
0008FA  370019     BRA 0x92E
220:                   }
221:                   switch (pevent->OSEventType) {
0008FC  90001E     MOV [W14+2], W0
0008FE  784010     MOV.B [W0], W0
000900  FB8000     ZE W0, W0
000902  E90000     DEC W0, W0
000904  500FE3     SUB W0, #0x3, [W15]
000906  3E000F     BRA GTU, 0x926
222:                       case OS_EVENT_TYPE_SEM:
223:                       case OS_EVENT_TYPE_MUTEX:
224:                       case OS_EVENT_TYPE_MBOX:
225:                       case OS_EVENT_TYPE_Q:
226:                            break;
227:               
228:                       default:
229:                            *perr = OS_ERR_EVENT_TYPE;
000926  90003E     MOV [W14+6], W0
000928  B3C011     MOV.B #0x1, W1
00092A  784801     MOV.B W1, [W0]
230:                            return;
00092C  000000     NOP
231:                   }
232:                   OS_ENTER_CRITICAL();
000908  800211     MOV SR, W1
00090A  780F01     MOV W1, [W14]
00090C  800211     MOV SR, W1
00090E  200E00     MOV #0xE0, W0
000910  700001     IOR W0, W1, W0
000912  880210     MOV W0, SR
233:                   pevent->OSEventName = pname;
000914  90001E     MOV [W14+2], W0
000916  9000AE     MOV [W14+4], W1
000918  980051     MOV W1, [W0+10]
234:                   OS_EXIT_CRITICAL();
00091A  78009E     MOV [W14], W1
00091C  880211     MOV W1, SR
235:                   *perr = OS_ERR_NONE;
00091E  90003E     MOV [W14+6], W0
000920  EB4080     CLR.B W1
000922  784801     MOV.B W1, [W0]
000924  370004     BRA 0x92E
236:               }
00092E  FA8000     ULNK
000930  060000     RETURN
237:               #endif
238:               
239:               /*$PAGE*/
240:               /*
241:               *********************************************************************************************************
242:               *                                       PEND ON MULTIPLE EVENTS
243:               *
244:               * Description: This function waits for multiple events.  If multiple events are ready at the start of the
245:               *              pend call, then all available events are returned as ready.  If the task must pend on the
246:               *              multiple events, then only the first posted or aborted event is returned as ready.
247:               *
248:               * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
249:               *
250:               *              pevents_rdy   is a pointer to an array to return which event control blocks are available
251:               *                            or ready.  The size of the array MUST be greater than or equal to the size
252:               *                            of the 'pevents_pend' array, including terminating NULL.
253:               *
254:               *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
255:               *                            events.  The size of the array MUST be greater than or equal to the size of
256:               *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
257:               *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
258:               *                            every available message-type event returns its messages in the 'pmsgs_rdy'
259:               *                            array at the same index as the event is returned in the 'pevents_rdy' array.
260:               *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
261:               *
262:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
263:               *                            wait for the resources up to the amount of time specified by this argument.
264:               *                            If you specify 0, however, your task will wait forever for the specified
265:               *                            events or, until the resources becomes available (or the events occur).
266:               *
267:               *              perr          is a pointer to where an error message will be deposited.  Possible error
268:               *                            messages are:
269:               *
270:               *                            OS_ERR_NONE         The call was successful and your task owns the resources
271:               *                                                or, the events you are waiting for occurred; check the
272:               *                                                'pevents_rdy' array for which events are available.
273:               *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
274:               *                                                'pevents_rdy' array for which events were aborted.
275:               *                            OS_ERR_TIMEOUT      The events were not received within the specified
276:               *                                                'timeout'.
277:               *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
278:               *                                                NULL pointer.
279:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
280:               *                                                mailboxes, and/or queues.
281:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
282:               *                                                would lead to a suspension.
283:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
284:               *
285:               * Returns    : >  0          the number of events returned as ready or aborted.
286:               *              == 0          if no events are returned as ready because of timeout or upon error.
287:               *
288:               * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
289:               *
290:               *                        semaphores, mailboxes, queues
291:               *
292:               *                 b. Return ALL available events and messages, if any
293:               *
294:               *                 c. Add    current task priority as pending to   each events's wait list
295:               *                      Performed in OS_EventTaskWaitMulti()
296:               *
297:               *                 d. Wait on any of multiple events
298:               *
299:               *                 e. Remove current task priority as pending from each events's wait list
300:               *                      Performed in OS_EventTaskRdy(), if events posted or aborted
301:               *
302:               *                 f. Return any event posted or aborted, if any
303:               *                      else
304:               *                    Return timeout
305:               *
306:               *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
307:               *                 case of any error(s).
308:               *********************************************************************************************************
309:               */
310:               /*$PAGE*/
311:               #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
312:               INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
313:                                         OS_EVENT  **pevents_rdy,
314:                                         void      **pmsgs_rdy,
315:                                         INT32U      timeout,
316:                                         INT8U      *perr)
317:               {
000932  FA001A     LNK #0x1A
000934  980770     MOV W0, [W14+14]
000936  980F01     MOV W1, [W14+16]
000938  980F12     MOV W2, [W14+18]
00093A  980F24     MOV W4, [W14+20]
00093C  980F35     MOV W5, [W14+22]
00093E  980F43     MOV W3, [W14+24]
318:                   OS_EVENT  **pevents;
319:                   OS_EVENT   *pevent;
320:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
321:                   OS_Q       *pq;
322:               #endif
323:                   BOOLEAN     events_rdy;
324:                   INT16U      events_rdy_nbr;
325:                   INT8U       events_stat;
326:               #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
327:                   OS_CPU_SR   cpu_sr = 0u;
000940  EB0000     CLR W0
000942  980750     MOV W0, [W14+10]
328:               #endif
329:               
330:               
331:               
332:               #ifdef OS_SAFETY_CRITICAL
333:                   if (perr == (INT8U *)0) {
334:                       OS_SAFETY_CRITICAL_EXCEPTION();
335:                       return (0u);
336:                   }
337:               #endif
338:               
339:               #if (OS_ARG_CHK_EN > 0u)
340:                   if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
000944  90007E     MOV [W14+14], W0
000946  E00000     CP0 W0
000948  3A0005     BRA NZ, 0x954
341:                      *perr =  OS_ERR_PEVENT_NULL;
00094A  90084E     MOV [W14+24], W0
00094C  B3C041     MOV.B #0x4, W1
00094E  784801     MOV.B W1, [W0]
342:                       return (0u);
000950  EB0000     CLR W0
000952  370187     BRA 0xC62
343:                   }
344:                   if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
000954  90007E     MOV [W14+14], W0
000956  780010     MOV [W0], W0
000958  E00000     CP0 W0
00095A  3A0005     BRA NZ, 0x966
345:                      *perr =  OS_ERR_PEVENT_NULL;
00095C  90084E     MOV [W14+24], W0
00095E  B3C041     MOV.B #0x4, W1
000960  784801     MOV.B W1, [W0]
346:                       return (0u);
000962  EB0000     CLR W0
000964  37017E     BRA 0xC62
347:                   }
348:                   if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
000966  90080E     MOV [W14+16], W0
000968  E00000     CP0 W0
00096A  3A0005     BRA NZ, 0x976
349:                      *perr =  OS_ERR_PEVENT_NULL;
00096C  90084E     MOV [W14+24], W0
00096E  B3C041     MOV.B #0x4, W1
000970  784801     MOV.B W1, [W0]
350:                       return (0u);
000972  EB0000     CLR W0
000974  370176     BRA 0xC62
351:                   }
352:                   if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
000976  90081E     MOV [W14+18], W0
000978  E00000     CP0 W0
00097A  3A0005     BRA NZ, 0x986
353:                      *perr =  OS_ERR_PEVENT_NULL;
00097C  90084E     MOV [W14+24], W0
00097E  B3C041     MOV.B #0x4, W1
000980  784801     MOV.B W1, [W0]
354:                       return (0u);
000982  EB0000     CLR W0
000984  37016E     BRA 0xC62
355:                   }
356:               #endif
357:               
358:                  *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
000986  90080E     MOV [W14+16], W0
000988  EB0080     CLR W1
00098A  780801     MOV W1, [W0]
359:               
360:                   pevents     =  pevents_pend;
00098C  9000FE     MOV [W14+14], W1
00098E  780F01     MOV W1, [W14]
361:                   pevent      = *pevents;
000990  78001E     MOV [W14], W0
000992  780110     MOV [W0], W2
000994  980712     MOV W2, [W14+2]
362:                   while  (pevent != (OS_EVENT *)0) {
000996  370017     BRA 0x9C6
0009C6  90001E     MOV [W14+2], W0
0009C8  E00000     CP0 W0
0009CA  3AFFE6     BRA NZ, 0x998
363:                       switch (pevent->OSEventType) {                  /* Validate event block types                  */
000998  90001E     MOV [W14+2], W0
00099A  784010     MOV.B [W0], W0
00099C  FB8000     ZE W0, W0
00099E  500FE2     SUB W0, #0x2, [W15]
0009A0  320009     BRA Z, 0x9B4
0009A2  500FE3     SUB W0, #0x3, [W15]
0009A4  320009     BRA Z, 0x9B8
0009A6  500FE1     SUB W0, #0x1, [W15]
0009A8  320009     BRA Z, 0x9BC
364:               #if (OS_SEM_EN  > 0u)
365:                           case OS_EVENT_TYPE_SEM:
366:                                break;
0009B8  000000     NOP
0009BA  370001     BRA 0x9BE
367:               #endif
368:               #if (OS_MBOX_EN > 0u)
369:                           case OS_EVENT_TYPE_MBOX:
370:                                break;
0009BC  000000     NOP
371:               #endif
372:               #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
373:                           case OS_EVENT_TYPE_Q:
374:                                break;
0009B4  000000     NOP
0009B6  370003     BRA 0x9BE
375:               #endif
376:               
377:                           case OS_EVENT_TYPE_MUTEX:
378:                           case OS_EVENT_TYPE_FLAG:
379:                           default:
380:                               *perr = OS_ERR_EVENT_TYPE;
0009AA  90084E     MOV [W14+24], W0
0009AC  B3C011     MOV.B #0x1, W1
0009AE  784801     MOV.B W1, [W0]
381:                                return (0u);
0009B0  EB0000     CLR W0
0009B2  370157     BRA 0xC62
382:                       }
383:                       pevents++;
0009BE  E88F1E     INC2 [W14], [W14]
384:                       pevent = *pevents;
0009C0  78001E     MOV [W14], W0
0009C2  780190     MOV [W0], W3
0009C4  980713     MOV W3, [W14+2]
385:                   }
386:               
387:                   if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
0009CC  BFC86B     MOV.B OSIntNesting, WREG
0009CE  E00400     CP0.B W0
0009D0  320005     BRA Z, 0x9DC
388:                      *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
0009D2  90084E     MOV [W14+24], W0
0009D4  B3C021     MOV.B #0x2, W1
0009D6  784801     MOV.B W1, [W0]
389:                       return (0u);
0009D8  EB0000     CLR W0
0009DA  370143     BRA 0xC62
390:                   }
391:                   if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
0009DC  BFC86C     MOV.B OSLockNesting, WREG
0009DE  E00400     CP0.B W0
0009E0  320005     BRA Z, 0x9EC
392:                      *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
0009E2  90084E     MOV [W14+24], W0
0009E4  B3C0D1     MOV.B #0xD, W1
0009E6  784801     MOV.B W1, [W0]
393:                       return (0u);
0009E8  EB0000     CLR W0
0009EA  37013B     BRA 0xC62
394:                   }
395:               
396:               /*$PAGE*/
397:                   events_rdy     =  OS_FALSE;
0009EC  EB4000     CLR.B W0
0009EE  984740     MOV.B W0, [W14+4]
398:                   events_rdy_nbr =  0u;
0009F0  EB0000     CLR W0
0009F2  980730     MOV W0, [W14+6]
399:                   events_stat    =  OS_STAT_RDY;
0009F4  EB4000     CLR.B W0
0009F6  984F00     MOV.B W0, [W14+8]
400:                   pevents        =  pevents_pend;
0009F8  9000FE     MOV [W14+14], W1
0009FA  780F01     MOV W1, [W14]
401:                   pevent         = *pevents;
0009FC  78001E     MOV [W14], W0
0009FE  780110     MOV [W0], W2
000A00  980712     MOV W2, [W14+2]
402:                   OS_ENTER_CRITICAL();
000A02  800213     MOV SR, W3
000A04  980753     MOV W3, [W14+10]
000A06  800211     MOV SR, W1
000A08  200E00     MOV #0xE0, W0
000A0A  700001     IOR W0, W1, W0
000A0C  880210     MOV W0, SR
403:                   while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
000A0E  370086     BRA 0xB1C
000B1C  90001E     MOV [W14+2], W0
000B1E  E00000     CP0 W0
000B20  3AFF77     BRA NZ, 0xA10
404:                       switch (pevent->OSEventType) {
000A10  90001E     MOV [W14+2], W0
000A12  784010     MOV.B [W0], W0
000A14  FB8000     ZE W0, W0
000A16  500FE2     SUB W0, #0x2, [W15]
000A18  320042     BRA Z, 0xA9E
000A1A  500FE3     SUB W0, #0x3, [W15]
000A1C  320003     BRA Z, 0xA24
000A1E  500FE1     SUB W0, #0x1, [W15]
000A20  320020     BRA Z, 0xA62
000A22  37006E     BRA 0xB00
405:               #if (OS_SEM_EN > 0u)
406:                           case OS_EVENT_TYPE_SEM:
407:                                if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
000A24  90001E     MOV [W14+2], W0
000A26  900020     MOV [W0+4], W0
000A28  E00000     CP0 W0
000A2A  320017     BRA Z, 0xA5A
408:                                    pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
000A2C  90001E     MOV [W14+2], W0
000A2E  900020     MOV [W0+4], W0
000A30  E90080     DEC W0, W1
000A32  90001E     MOV [W14+2], W0
000A34  980021     MOV W1, [W0+4]
409:                                   *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
000A36  90080E     MOV [W14+16], W0
000A38  90009E     MOV [W14+2], W1
000A3A  780801     MOV W1, [W0]
000A3C  90080E     MOV [W14+16], W0
000A3E  E88000     INC2 W0, W0
000A40  980F00     MOV W0, [W14+16]
410:                                     events_rdy   =  OS_TRUE;
000A42  B3C010     MOV.B #0x1, W0
000A44  984740     MOV.B W0, [W14+4]
411:                                   *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
000A46  90081E     MOV [W14+18], W0
000A48  EB0080     CLR W1
000A4A  780801     MOV W1, [W0]
000A4C  90081E     MOV [W14+18], W0
000A4E  E88000     INC2 W0, W0
000A50  980F10     MOV W0, [W14+18]
412:                                     events_rdy_nbr++;
000A52  90003E     MOV [W14+6], W0
000A54  E80000     INC W0, W0
000A56  980730     MOV W0, [W14+6]
413:               
414:                                } else {
415:                                     events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
000A5A  90480E     MOV.B [W14+8], W0
000A5C  A00400     BSET.B W0, #0
000A5E  984F00     MOV.B W0, [W14+8]
416:                                }
417:                                break;
000A58  37005D     BRA 0xB14
000A60  370059     BRA 0xB14
418:               #endif
419:               
420:               #if (OS_MBOX_EN > 0u)
421:                           case OS_EVENT_TYPE_MBOX:
422:                                if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
000A62  90001E     MOV [W14+2], W0
000A64  900010     MOV [W0+2], W0
000A66  E00000     CP0 W0
000A68  320016     BRA Z, 0xA96
423:                                                                       /* ... return available message,           ... */
424:                                   *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
000A6A  90001E     MOV [W14+2], W0
000A6C  900090     MOV [W0+2], W1
000A6E  90081E     MOV [W14+18], W0
000A70  780801     MOV W1, [W0]
000A72  90081E     MOV [W14+18], W0
000A74  E88000     INC2 W0, W0
000A76  980F10     MOV W0, [W14+18]
425:                                    pevent->OSEventPtr  = (void *)0;
000A78  90001E     MOV [W14+2], W0
000A7A  EB0080     CLR W1
000A7C  980011     MOV W1, [W0+2]
426:                                   *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
000A7E  90080E     MOV [W14+16], W0
000A80  90011E     MOV [W14+2], W2
000A82  780802     MOV W2, [W0]
000A84  90080E     MOV [W14+16], W0
000A86  E88000     INC2 W0, W0
000A88  980F00     MOV W0, [W14+16]
427:                                     events_rdy         =  OS_TRUE;
000A8A  B3C010     MOV.B #0x1, W0
000A8C  984740     MOV.B W0, [W14+4]
428:                                     events_rdy_nbr++;
000A8E  90003E     MOV [W14+6], W0
000A90  E80000     INC W0, W0
000A92  980730     MOV W0, [W14+6]
429:               
430:                                } else {
431:                                     events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
000A96  90480E     MOV.B [W14+8], W0
000A98  A01400     BSET.B W0, #1
000A9A  984F00     MOV.B W0, [W14+8]
432:                                }
433:                                break;
000A94  37003F     BRA 0xB14
000A9C  37003B     BRA 0xB14
434:               #endif
435:               
436:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
437:                           case OS_EVENT_TYPE_Q:
438:                                pq = (OS_Q *)pevent->OSEventPtr;
000A9E  90001E     MOV [W14+2], W0
000AA0  900010     MOV [W0+2], W0
000AA2  980760     MOV W0, [W14+12]
439:                                if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
000AA4  90006E     MOV [W14+12], W0
000AA6  900060     MOV [W0+12], W0
000AA8  E00000     CP0 W0
000AAA  320026     BRA Z, 0xAF8
440:                                                                       /* ... return available message,           ... */
441:                                   *pmsgs_rdy++ = (void *)*pq->OSQOut++;
000AAC  90006E     MOV [W14+12], W0
000AAE  900040     MOV [W0+8], W0
000AB0  780110     MOV [W0], W2
000AB2  90089E     MOV [W14+18], W1
000AB4  780882     MOV W2, [W1]
000AB6  90089E     MOV [W14+18], W1
000AB8  E88081     INC2 W1, W1
000ABA  980F11     MOV W1, [W14+18]
000ABC  E88080     INC2 W0, W1
000ABE  90006E     MOV [W14+12], W0
000AC0  980041     MOV W1, [W0+8]
442:                                    if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
000AC2  90006E     MOV [W14+12], W0
000AC4  9000C0     MOV [W0+8], W1
000AC6  90006E     MOV [W14+12], W0
000AC8  900020     MOV [W0+4], W0
000ACA  508F80     SUB W1, W0, [W15]
000ACC  3A0004     BRA NZ, 0xAD6
443:                                        pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
000ACE  90006E     MOV [W14+12], W0
000AD0  900090     MOV [W0+2], W1
000AD2  90006E     MOV [W14+12], W0
000AD4  980041     MOV W1, [W0+8]
444:                                    }
445:                                    pq->OSQEntries--;                  /* Update number of queue entries              */
000AD6  90006E     MOV [W14+12], W0
000AD8  900060     MOV [W0+12], W0
000ADA  E90080     DEC W0, W1
000ADC  90006E     MOV [W14+12], W0
000ADE  980061     MOV W1, [W0+12]
446:                                   *pevents_rdy++ = pevent;            /* ... and return available queue event        */
000AE0  90080E     MOV [W14+16], W0
000AE2  90019E     MOV [W14+2], W3
000AE4  780803     MOV W3, [W0]
000AE6  90080E     MOV [W14+16], W0
000AE8  E88000     INC2 W0, W0
000AEA  980F00     MOV W0, [W14+16]
447:                                     events_rdy   = OS_TRUE;
000AEC  B3C010     MOV.B #0x1, W0
000AEE  984740     MOV.B W0, [W14+4]
448:                                     events_rdy_nbr++;
000AF0  90003E     MOV [W14+6], W0
000AF2  E80000     INC W0, W0
000AF4  980730     MOV W0, [W14+6]
449:               
450:                                } else {
451:                                     events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
000AF8  90480E     MOV.B [W14+8], W0
000AFA  A02400     BSET.B W0, #2
000AFC  984F00     MOV.B W0, [W14+8]
452:                                }
453:                                break;
000AF6  37000E     BRA 0xB14
000AFE  37000A     BRA 0xB14
454:               #endif
455:               
456:                           case OS_EVENT_TYPE_MUTEX:
457:                           case OS_EVENT_TYPE_FLAG:
458:                           default:
459:                                OS_EXIT_CRITICAL();
000B00  9000DE     MOV [W14+10], W1
000B02  880211     MOV W1, SR
460:                               *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
000B04  90080E     MOV [W14+16], W0
000B06  EB0080     CLR W1
000B08  780801     MOV W1, [W0]
461:                               *perr        =  OS_ERR_EVENT_TYPE;
000B0A  90084E     MOV [W14+24], W0
000B0C  B3C011     MOV.B #0x1, W1
000B0E  784801     MOV.B W1, [W0]
462:                                return (events_rdy_nbr);
000B10  90003E     MOV [W14+6], W0
000B12  3700A7     BRA 0xC62
463:                       }
464:                       pevents++;
000B14  E88F1E     INC2 [W14], [W14]
465:                       pevent = *pevents;
000B16  78001E     MOV [W14], W0
000B18  780110     MOV [W0], W2
000B1A  980712     MOV W2, [W14+2]
466:                   }
467:               
468:                   if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
000B22  90404E     MOV.B [W14+4], W0
000B24  504FE1     SUB.B W0, #0x1, [W15]
000B26  3A000A     BRA NZ, 0xB3C
469:                      *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
000B28  90080E     MOV [W14+16], W0
000B2A  EB0080     CLR W1
000B2C  780801     MOV W1, [W0]
470:                       OS_EXIT_CRITICAL();
000B2E  9001DE     MOV [W14+10], W3
000B30  880213     MOV W3, SR
471:                      *perr        =  OS_ERR_NONE;
000B32  90084E     MOV [W14+24], W0
000B34  EB4080     CLR.B W1
000B36  784801     MOV.B W1, [W0]
472:                       return (events_rdy_nbr);
000B38  90003E     MOV [W14+6], W0
000B3A  370093     BRA 0xC62
473:                   }
474:               /*$PAGE*/
475:                                                                       /* Otherwise, must wait until any event occurs */
476:                   OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
000B3C  8043B0     MOV OSTCBCur, W0
000B3E  8043B1     MOV OSTCBCur, W1
000B40  906101     MOV.B [W1+32], W2
000B42  90488E     MOV.B [W14+8], W1
000B44  714101     IOR.B W2, W1, W2
000B46  B3C801     MOV.B #0x80, W1
000B48  714081     IOR.B W2, W1, W1
000B4A  986001     MOV.B W1, [W0+32]
477:                                              OS_STAT_MULTI;           /* ... pend on multiple events                 */
478:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000B4C  8043B0     MOV OSTCBCur, W0
000B4E  EB4080     CLR.B W1
000B50  986011     MOV.B W1, [W0+33]
479:                   OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
000B52  8043B0     MOV OSTCBCur, W0
000B54  90092E     MOV [W14+20], W2
000B56  9009BE     MOV [W14+22], W3
000B58  980862     MOV W2, [W0+28]
000B5A  980873     MOV W3, [W0+30]
480:                   OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
000B5C  90007E     MOV [W14+14], W0
000B5E  070252     RCALL OS_EventTaskWaitMulti
481:               
482:                   OS_EXIT_CRITICAL();
000B60  9001DE     MOV [W14+10], W3
000B62  880213     MOV W3, SR
483:                   OS_Sched();                                         /* Find next highest priority task ready       */
000B64  0703E5     RCALL OS_Sched
484:                   OS_ENTER_CRITICAL();
000B66  800211     MOV SR, W1
000B68  980751     MOV W1, [W14+10]
000B6A  800211     MOV SR, W1
000B6C  200E00     MOV #0xE0, W0
000B6E  700001     IOR W0, W1, W0
000B70  880210     MOV W0, SR
485:               
486:                   switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
000B72  8043B0     MOV OSTCBCur, W0
000B74  906010     MOV.B [W0+33], W0
000B76  FB8000     ZE W0, W0
000B78  E00000     CP0 W0
000B7A  320002     BRA Z, 0xB80
000B7C  500FE2     SUB W0, #0x2, [W15]
000B7E  3A0019     BRA NZ, 0xBB2
487:                       case OS_STAT_PEND_OK:
488:                       case OS_STAT_PEND_ABORT:
489:                            pevent = OSTCBCur->OSTCBEventPtr;
000B80  8043B0     MOV OSTCBCur, W0
000B82  900910     MOV [W0+18], W2
000B84  980712     MOV W2, [W14+2]
490:                            if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
000B86  90001E     MOV [W14+2], W0
000B88  E00000     CP0 W0
000B8A  32000C     BRA Z, 0xBA4
491:                               *pevents_rdy++   =  pevent;             /* ... return available event ...              */
000B8C  90080E     MOV [W14+16], W0
000B8E  90019E     MOV [W14+2], W3
000B90  780803     MOV W3, [W0]
000B92  90080E     MOV [W14+16], W0
000B94  E88000     INC2 W0, W0
000B96  980F00     MOV W0, [W14+16]
492:                               *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
000B98  90080E     MOV [W14+16], W0
000B9A  EB0080     CLR W1
000B9C  780801     MOV W1, [W0]
493:                                 events_rdy_nbr =  1;
000B9E  200010     MOV #0x1, W0
000BA0  980730     MOV W0, [W14+6]
494:               
495:                            } else {                                   /* Else NO event available, handle as timeout  */
496:                                OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
000BA4  8043B0     MOV OSTCBCur, W0
000BA6  B3C011     MOV.B #0x1, W1
000BA8  986011     MOV.B W1, [W0+33]
497:                                OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
000BAA  8043B0     MOV OSTCBCur, W0
000BAC  9000FE     MOV [W14+14], W1
000BAE  07029A     RCALL OS_EventTaskRemoveMulti
498:                            }
499:                            break;
000BA2  37000B     BRA 0xBBA
000BB0  370004     BRA 0xBBA
500:               
501:                       case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
502:                       default:                                        /* ... remove task from events' wait lists     */
503:                            OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
000BB2  8043B0     MOV OSTCBCur, W0
000BB4  9000FE     MOV [W14+14], W1
000BB6  070296     RCALL OS_EventTaskRemoveMulti
504:                            break;
000BB8  000000     NOP
505:                   }
506:               
507:                   switch (OSTCBCur->OSTCBStatPend) {
000BBA  8043B0     MOV OSTCBCur, W0
000BBC  906010     MOV.B [W0+33], W0
000BBE  FB8000     ZE W0, W0
000BC0  E00000     CP0 W0
000BC2  320003     BRA Z, 0xBCA
000BC4  500FE2     SUB W0, #0x2, [W15]
000BC6  320027     BRA Z, 0xC16
000BC8  370030     BRA 0xC2A
508:                       case OS_STAT_PEND_OK:
509:                            switch (pevent->OSEventType) {             /* Return event's message                      */
000BCA  90001E     MOV [W14+2], W0
000BCC  784010     MOV.B [W0], W0
000BCE  FB8000     ZE W0, W0
000BD0  500FE1     SUB W0, #0x1, [W15]
000BD2  350013     BRA LT, 0xBFA
000BD4  500FE2     SUB W0, #0x2, [W15]
000BD6  340009     BRA LE, 0xBEA
000BD8  500FE3     SUB W0, #0x3, [W15]
000BDA  3A000F     BRA NZ, 0xBFA
510:               #if (OS_SEM_EN > 0u)
511:                                case OS_EVENT_TYPE_SEM:
512:                                    *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
000BDC  90081E     MOV [W14+18], W0
000BDE  EB0080     CLR W1
000BE0  780801     MOV W1, [W0]
000BE2  90081E     MOV [W14+18], W0
000BE4  E88000     INC2 W0, W0
000BE6  980F10     MOV W0, [W14+18]
513:                                     break;
000BE8  370012     BRA 0xC0E
514:               #endif
515:               
516:               #if ((OS_MBOX_EN > 0u) ||                 \
517:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
518:                                case OS_EVENT_TYPE_MBOX:
519:                                case OS_EVENT_TYPE_Q:
520:                                    *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
000BEA  8043B0     MOV OSTCBCur, W0
000BEC  9008B0     MOV [W0+22], W1
000BEE  90081E     MOV [W14+18], W0
000BF0  780801     MOV W1, [W0]
000BF2  90081E     MOV [W14+18], W0
000BF4  E88000     INC2 W0, W0
000BF6  980F10     MOV W0, [W14+18]
521:                                     break;
000BF8  37000A     BRA 0xC0E
522:               #endif
523:               
524:                                case OS_EVENT_TYPE_MUTEX:
525:                                case OS_EVENT_TYPE_FLAG:
526:                                default:
527:                                     OS_EXIT_CRITICAL();
000BFA  9000DE     MOV [W14+10], W1
000BFC  880211     MOV W1, SR
528:                                    *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
000BFE  90080E     MOV [W14+16], W0
000C00  EB0080     CLR W1
000C02  780801     MOV W1, [W0]
529:                                    *perr        =  OS_ERR_EVENT_TYPE;
000C04  90084E     MOV [W14+24], W0
000C06  B3C011     MOV.B #0x1, W1
000C08  784801     MOV.B W1, [W0]
530:                                     return (events_rdy_nbr);
000C0A  90003E     MOV [W14+6], W0
000C0C  37002A     BRA 0xC62
531:                            }
532:                           *perr = OS_ERR_NONE;
000C0E  90084E     MOV [W14+24], W0
000C10  EB4080     CLR.B W1
000C12  784801     MOV.B W1, [W0]
533:                            break;
000C14  370014     BRA 0xC3E
534:               
535:                       case OS_STAT_PEND_ABORT:
536:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
000C16  90081E     MOV [W14+18], W0
000C18  EB0080     CLR W1
000C1A  780801     MOV W1, [W0]
000C1C  90081E     MOV [W14+18], W0
000C1E  E88000     INC2 W0, W0
000C20  980F10     MOV W0, [W14+18]
537:                           *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
000C22  90084E     MOV [W14+24], W0
000C24  B3C0E1     MOV.B #0xE, W1
000C26  784801     MOV.B W1, [W0]
538:                            break;
000C28  37000A     BRA 0xC3E
539:               
540:                       case OS_STAT_PEND_TO:
541:                       default:
542:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
000C2A  90081E     MOV [W14+18], W0
000C2C  EB0080     CLR W1
000C2E  780801     MOV W1, [W0]
000C30  90081E     MOV [W14+18], W0
000C32  E88000     INC2 W0, W0
000C34  980F10     MOV W0, [W14+18]
543:                           *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
000C36  90084E     MOV [W14+24], W0
000C38  B3C0A1     MOV.B #0xA, W1
000C3A  784801     MOV.B W1, [W0]
544:                            break;
000C3C  000000     NOP
545:                   }
546:               
547:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
000C3E  8043B0     MOV OSTCBCur, W0
000C40  EB4080     CLR.B W1
000C42  986001     MOV.B W1, [W0+32]
548:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
000C44  8043B0     MOV OSTCBCur, W0
000C46  EB4080     CLR.B W1
000C48  986011     MOV.B W1, [W0+33]
549:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
000C4A  8043B0     MOV OSTCBCur, W0
000C4C  EB0080     CLR W1
000C4E  980811     MOV W1, [W0+18]
550:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
000C50  8043B0     MOV OSTCBCur, W0
000C52  EB0080     CLR W1
000C54  980821     MOV W1, [W0+20]
551:               #if ((OS_MBOX_EN > 0u) ||                 \
552:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
553:                   OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
000C56  8043B0     MOV OSTCBCur, W0
000C58  EB0080     CLR W1
000C5A  980831     MOV W1, [W0+22]
554:               #endif
555:                   OS_EXIT_CRITICAL();
000C5C  90015E     MOV [W14+10], W2
000C5E  880212     MOV W2, SR
556:               
557:                   return (events_rdy_nbr);
000C60  90003E     MOV [W14+6], W0
558:               }
000C62  FA8000     ULNK
000C64  060000     RETURN
559:               #endif
560:               
561:               /*$PAGE*/
562:               /*
563:               *********************************************************************************************************
564:               *                                           INITIALIZATION
565:               *
566:               * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
567:               *              creating any uC/OS-II object and, prior to calling OSStart().
568:               *
569:               * Arguments  : none
570:               *
571:               * Returns    : none
572:               *********************************************************************************************************
573:               */
574:               
575:               void  OSInit (void)
576:               {
000C66  FA0000     LNK #0x0
577:               #if OS_TASK_CREATE_EXT_EN > 0u
578:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
579:                   INT8U  err;
580:               #endif
581:               #endif
582:               
583:                   OSInitHookBegin();                                           /* Call port specific initialization code   */
000C68  072F12     RCALL OSInitHookBegin
584:               
585:                   OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000C6A  0702BC     RCALL _OS_InitMisc
586:               
587:                   OS_InitRdyList();                                            /* Initialize the Ready List                */
000C6C  0702CC     RCALL _OS_InitRdyList
588:               
589:                   OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000C6E  07030A     RCALL _OS_InitTCBList
590:               
591:                   OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000C70  070284     RCALL _OS_InitEventList
592:               
593:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
594:                   OS_FlagInit();                                               /* Initialize the event flag structures     */
000C72  071BD0     RCALL OS_FlagInit
595:               #endif
596:               
597:               #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
598:                   OS_MemInit();                                                /* Initialize the memory manager            */
599:               #endif
600:               
601:               #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
602:                   OS_QInit();                                                  /* Initialize the message queue structures  */
000C74  07240A     RCALL OS_QInit
603:               #endif
604:               
605:               #if OS_TASK_CREATE_EXT_EN > 0u
606:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
607:                   OS_TLS_Init(&err);                                           /* Initialize TLS, before creating tasks    */
608:                   if (err != OS_ERR_NONE) {
609:                       return;
610:                   }
611:               #endif
612:               #endif
613:               
614:                   OS_InitTaskIdle();                                           /* Create the Idle Task                     */
000C76  0702DA     RCALL _OS_InitTaskIdle
615:               #if OS_TASK_STAT_EN > 0u
616:                   OS_InitTaskStat();                                           /* Create the Statistic Task                */
000C78  0702EF     RCALL _OS_InitTaskStat
617:               #endif
618:               
619:               #if OS_TMR_EN > 0u
620:                   OSTmr_Init();                                                /* Initialize the Timer Manager             */
621:               #endif
622:               
623:                   OSInitHookEnd();                                             /* Call port specific init. code            */
000C7A  072F0E     RCALL OSInitHookEnd
624:               
625:               #if OS_DEBUG_EN > 0u
626:                   OSDebugInit();
627:               #endif
628:               }
000C7C  FA8000     ULNK
000C7E  060000     RETURN
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                              ENTER ISR
633:               *
634:               * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
635:               *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
636:               *              only perform rescheduling at the last nested ISR.
637:               *
638:               * Arguments  : none
639:               *
640:               * Returns    : none
641:               *
642:               * Notes      : 1) This function should be called with interrupts already disabled
643:               *              2) Your ISR can directly increment OSIntNesting without calling this function because
644:               *                 OSIntNesting has been declared 'global'.
645:               *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
646:               *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
647:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
648:               *                 end of the ISR.
649:               *              5) You are allowed to nest interrupts up to 255 levels deep.
650:               *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
651:               *                 OSIntEnter() is always called with interrupts disabled.
652:               *********************************************************************************************************
653:               */
654:               
655:               void  OSIntEnter (void)
656:               {
000C80  FA0000     LNK #0x0
657:                   if (OSRunning == OS_TRUE) {
000C82  BFC870     MOV.B OSRunning, WREG
000C84  504FE1     SUB.B W0, #0x1, [W15]
000C86  3A0006     BRA NZ, 0xC94
658:                       if (OSIntNesting < 255u) {
000C88  BFC86B     MOV.B OSIntNesting, WREG
000C8A  404FE1     ADD.B W0, #0x1, [W15]
000C8C  320003     BRA Z, 0xC94
659:                           OSIntNesting++;                      /* Increment ISR nesting level                        */
000C8E  BFC86B     MOV.B OSIntNesting, WREG
000C90  E84000     INC.B W0, W0
000C92  B7E86B     MOV.B WREG, OSIntNesting
660:                       }
661:                   }
662:               }
000C94  FA8000     ULNK
000C96  060000     RETURN
663:               /*$PAGE*/
664:               /*
665:               *********************************************************************************************************
666:               *                                              EXIT ISR
667:               *
668:               * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
669:               *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
670:               *              a new, high-priority task, is ready to run.
671:               *
672:               * Arguments  : none
673:               *
674:               * Returns    : none
675:               *
676:               * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
677:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
678:               *                 end of the ISR.
679:               *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
680:               *********************************************************************************************************
681:               */
682:               
683:               void  OSIntExit (void)
684:               {
000C98  FA0002     LNK #0x2
685:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
686:                   OS_CPU_SR  cpu_sr = 0u;
000C9A  EB0000     CLR W0
000C9C  780F00     MOV W0, [W14]
687:               #endif
688:               
689:               
690:               
691:                   if (OSRunning == OS_TRUE) {
000C9E  BFC870     MOV.B OSRunning, WREG
000CA0  504FE1     SUB.B W0, #0x1, [W15]
000CA2  3A002F     BRA NZ, 0xD02
692:                       OS_ENTER_CRITICAL();
000CA4  800211     MOV SR, W1
000CA6  780F01     MOV W1, [W14]
000CA8  800211     MOV SR, W1
000CAA  200E00     MOV #0xE0, W0
000CAC  700001     IOR W0, W1, W0
000CAE  880210     MOV W0, SR
693:                       if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000CB0  BFC86B     MOV.B OSIntNesting, WREG
000CB2  E00400     CP0.B W0
000CB4  320003     BRA Z, 0xCBC
694:                           OSIntNesting--;
000CB6  BFC86B     MOV.B OSIntNesting, WREG
000CB8  E94000     DEC.B W0, W0
000CBA  B7E86B     MOV.B WREG, OSIntNesting
695:                       }
696:                       if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000CBC  BFC86B     MOV.B OSIntNesting, WREG
000CBE  E00400     CP0.B W0
000CC0  3A001E     BRA NZ, 0xCFE
697:                           if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000CC2  BFC86C     MOV.B OSLockNesting, WREG
000CC4  E00400     CP0.B W0
000CC6  3A001B     BRA NZ, 0xCFE
698:                               OS_SchedNew();
000CC8  070361     RCALL _OS_SchedNew
699:                               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000CCA  BFC86E     MOV.B OSPrioHighRdy, WREG
000CCC  FB8000     ZE W0, W0
000CCE  400080     ADD W0, W0, W1
000CD0  209C20     MOV #0x9C2, W0
000CD2  408000     ADD W1, W0, W0
000CD4  780010     MOV [W0], W0
000CD6  8843D0     MOV W0, OSTCBHighRdy
700:                               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000CD8  2086E1     MOV #0x86E, W1
000CDA  784091     MOV.B [W1], W1
000CDC  BFC86D     MOV.B OSPrioCur, WREG
000CDE  50CF80     SUB.B W1, W0, [W15]
000CE0  32000E     BRA Z, 0xCFE
701:               #if OS_TASK_PROFILE_EN > 0u
702:                                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000CE2  8043D2     MOV OSTCBHighRdy, W2
000CE4  901042     MOV [W2+40], W0
000CE6  9010D2     MOV [W2+42], W1
000CE8  400061     ADD W0, #0x1, W0
000CEA  4880E0     ADDC W1, #0x0, W1
000CEC  981140     MOV W0, [W2+40]
000CEE  981151     MOV W1, [W2+42]
703:               #endif
704:                                   OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000CF0  804280     MOV OSCtxSwCtr, W0
000CF2  804291     MOV 0x852, W1
000CF4  400061     ADD W0, #0x1, W0
000CF6  4880E0     ADDC W1, #0x0, W1
000CF8  884280     MOV W0, OSCtxSwCtr
000CFA  884291     MOV W1, 0x852
705:               
706:               #if OS_TASK_CREATE_EXT_EN > 0u
707:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
708:                                   OS_TLS_TaskSw();
709:               #endif
710:               #endif
711:               
712:                                   OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000CFC  073280     RCALL 0x71FE
713:                               }
714:                           }
715:                       }
716:                       OS_EXIT_CRITICAL();
000CFE  78009E     MOV [W14], W1
000D00  880211     MOV W1, SR
717:                   }
718:               }
000D02  FA8000     ULNK
000D04  060000     RETURN
719:               /*$PAGE*/
720:               /*
721:               *********************************************************************************************************
722:               *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
723:               *
724:               * Description: This function is called by the application code to indicate that all initialization has
725:               *              been completed and that kernel objects are no longer allowed to be created.
726:               *
727:               * Arguments  : none
728:               *
729:               * Returns    : none
730:               *
731:               * Note(s)    : 1) You should call this function when you no longer want to allow application code to
732:               *                 create kernel objects.
733:               *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
734:               *********************************************************************************************************
735:               */
736:               
737:               #ifdef OS_SAFETY_CRITICAL_IEC61508
738:               void  OSSafetyCriticalStart (void)
739:               {
740:                   OSSafetyCriticalStartFlag = OS_TRUE;
741:               }
742:               
743:               #endif
744:               
745:               /*$PAGE*/
746:               /*
747:               *********************************************************************************************************
748:               *                                         PREVENT SCHEDULING
749:               *
750:               * Description: This function is used to prevent rescheduling to take place.  This allows your application
751:               *              to prevent context switches until you are ready to permit context switching.
752:               *
753:               * Arguments  : none
754:               *
755:               * Returns    : none
756:               *
757:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
758:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
759:               *********************************************************************************************************
760:               */
761:               
762:               #if OS_SCHED_LOCK_EN > 0u
763:               void  OSSchedLock (void)
764:               {
000D06  FA0002     LNK #0x2
765:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
766:                   OS_CPU_SR  cpu_sr = 0u;
000D08  EB0000     CLR W0
000D0A  780F00     MOV W0, [W14]
767:               #endif
768:               
769:               
770:               
771:                   if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000D0C  BFC870     MOV.B OSRunning, WREG
000D0E  504FE1     SUB.B W0, #0x1, [W15]
000D10  3A0011     BRA NZ, 0xD34
772:                       OS_ENTER_CRITICAL();
000D12  800211     MOV SR, W1
000D14  780F01     MOV W1, [W14]
000D16  800211     MOV SR, W1
000D18  200E00     MOV #0xE0, W0
000D1A  700001     IOR W0, W1, W0
000D1C  880210     MOV W0, SR
773:                       if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
000D1E  BFC86B     MOV.B OSIntNesting, WREG
000D20  E00400     CP0.B W0
000D22  3A0006     BRA NZ, 0xD30
774:                           if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000D24  BFC86C     MOV.B OSLockNesting, WREG
000D26  404FE1     ADD.B W0, #0x1, [W15]
000D28  320003     BRA Z, 0xD30
775:                               OSLockNesting++;                 /* Increment lock nesting level                       */
000D2A  BFC86C     MOV.B OSLockNesting, WREG
000D2C  E84000     INC.B W0, W0
000D2E  B7E86C     MOV.B WREG, OSLockNesting
776:                           }
777:                       }
778:                       OS_EXIT_CRITICAL();
000D30  78009E     MOV [W14], W1
000D32  880211     MOV W1, SR
779:                   }
780:               }
000D34  FA8000     ULNK
000D36  060000     RETURN
781:               #endif
782:               
783:               /*$PAGE*/
784:               /*
785:               *********************************************************************************************************
786:               *                                          ENABLE SCHEDULING
787:               *
788:               * Description: This function is used to re-allow rescheduling.
789:               *
790:               * Arguments  : none
791:               *
792:               * Returns    : none
793:               *
794:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
795:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
796:               *********************************************************************************************************
797:               */
798:               
799:               #if OS_SCHED_LOCK_EN > 0u
800:               void  OSSchedUnlock (void)
801:               {
000D38  FA0002     LNK #0x2
802:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
803:                   OS_CPU_SR  cpu_sr = 0u;
000D3A  EB0000     CLR W0
000D3C  780F00     MOV W0, [W14]
804:               #endif
805:               
806:               
807:               
808:                   if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000D3E  BFC870     MOV.B OSRunning, WREG
000D40  504FE1     SUB.B W0, #0x1, [W15]
000D42  3A001E     BRA NZ, 0xD80
809:                       OS_ENTER_CRITICAL();
000D44  800211     MOV SR, W1
000D46  780F01     MOV W1, [W14]
000D48  800211     MOV SR, W1
000D4A  200E00     MOV #0xE0, W0
000D4C  700001     IOR W0, W1, W0
000D4E  880210     MOV W0, SR
810:                       if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000D50  BFC86B     MOV.B OSIntNesting, WREG
000D52  E00400     CP0.B W0
000D54  3A0013     BRA NZ, 0xD7C
811:                           if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000D56  BFC86C     MOV.B OSLockNesting, WREG
000D58  E00400     CP0.B W0
000D5A  32000D     BRA Z, 0xD76
812:                               OSLockNesting--;                           /* Decrement lock nesting level             */
000D5C  BFC86C     MOV.B OSLockNesting, WREG
000D5E  E94000     DEC.B W0, W0
000D60  B7E86C     MOV.B WREG, OSLockNesting
813:                               if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000D62  BFC86C     MOV.B OSLockNesting, WREG
000D64  E00400     CP0.B W0
000D66  3A0004     BRA NZ, 0xD70
814:                                   OS_EXIT_CRITICAL();
000D68  78009E     MOV [W14], W1
000D6A  880211     MOV W1, SR
815:                                   OS_Sched();                            /* See if a HPT is ready                    */
000D6C  0702E1     RCALL OS_Sched
000D6E  370008     BRA 0xD80
816:                               } else {
817:                                   OS_EXIT_CRITICAL();
000D70  78009E     MOV [W14], W1
000D72  880211     MOV W1, SR
000D74  370005     BRA 0xD80
818:                               }
819:                           } else {
820:                               OS_EXIT_CRITICAL();
000D76  78009E     MOV [W14], W1
000D78  880211     MOV W1, SR
000D7A  370002     BRA 0xD80
821:                           }
822:                       } else {
823:                           OS_EXIT_CRITICAL();
000D7C  78009E     MOV [W14], W1
000D7E  880211     MOV W1, SR
824:                       }
825:                   }
826:               }
000D80  FA8000     ULNK
000D82  060000     RETURN
827:               #endif
828:               
829:               /*$PAGE*/
830:               /*
831:               *********************************************************************************************************
832:               *                                         START MULTITASKING
833:               *
834:               * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
835:               *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
836:               *              and you MUST have created at least one task.
837:               *
838:               * Arguments  : none
839:               *
840:               * Returns    : none
841:               *
842:               * Note       : OSStartHighRdy() MUST:
843:               *                 a) Call OSTaskSwHook() then,
844:               *                 b) Set OSRunning to OS_TRUE.
845:               *                 c) Load the context of the task pointed to by OSTCBHighRdy.
846:               *                 d_ Execute the task.
847:               *********************************************************************************************************
848:               */
849:               
850:               void  OSStart (void)
851:               {
000D84  FA0000     LNK #0x0
852:                   if (OSRunning == OS_FALSE) {
000D86  BFC870     MOV.B OSRunning, WREG
000D88  E00400     CP0.B W0
000D8A  3A000D     BRA NZ, 0xDA6
853:                       OS_SchedNew();                               /* Find highest priority's task priority number   */
000D8C  0702FF     RCALL _OS_SchedNew
854:                       OSPrioCur     = OSPrioHighRdy;
000D8E  BFC86E     MOV.B OSPrioHighRdy, WREG
000D90  B7E86D     MOV.B WREG, OSPrioCur
855:                       OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000D92  BFC86E     MOV.B OSPrioHighRdy, WREG
000D94  FB8000     ZE W0, W0
000D96  400080     ADD W0, W0, W1
000D98  209C20     MOV #0x9C2, W0
000D9A  408000     ADD W1, W0, W0
000D9C  780010     MOV [W0], W0
000D9E  8843D0     MOV W0, OSTCBHighRdy
856:                       OSTCBCur      = OSTCBHighRdy;
000DA0  8043D0     MOV OSTCBHighRdy, W0
000DA2  8843B0     MOV W0, OSTCBCur
857:                       OSStartHighRdy();                            /* Execute target specific code to start task     */
000DA4  0731E9     RCALL 0x7178
858:                   }
859:               }
000DA6  FA8000     ULNK
000DA8  060000     RETURN
860:               /*$PAGE*/
861:               /*
862:               *********************************************************************************************************
863:               *                                      STATISTICS INITIALIZATION
864:               *
865:               * Description: This function is called by your application to establish CPU usage by first determining
866:               *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
867:               *              during that time.  CPU usage is then determined by a low priority task which keeps track
868:               *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
869:               *              determined by:
870:               *
871:               *                                             OSIdleCtr
872:               *                 CPU Usage (%) = 100 * (1 - ------------)
873:               *                                            OSIdleCtrMax
874:               *
875:               * Arguments  : none
876:               *
877:               * Returns    : none
878:               *********************************************************************************************************
879:               */
880:               
881:               #if OS_TASK_STAT_EN > 0u
882:               void  OSStatInit (void)
883:               {
000DAA  FA0002     LNK #0x2
884:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
885:                   OS_CPU_SR  cpu_sr = 0u;
000DAC  EB0000     CLR W0
000DAE  780F00     MOV W0, [W14]
886:               #endif
887:               
888:               
889:               
890:                   OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000DB0  200020     MOV #0x2, W0
000DB2  200001     MOV #0x0, W1
000DB4  072F35     RCALL OSTimeDly
891:                   OS_ENTER_CRITICAL();
000DB6  800211     MOV SR, W1
000DB8  780F01     MOV W1, [W14]
000DBA  800211     MOV SR, W1
000DBC  200E00     MOV #0xE0, W0
000DBE  700001     IOR W0, W1, W0
000DC0  880210     MOV W0, SR
892:                   OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000DC2  EF2872     CLR OSIdleCtr
000DC4  EF2874     CLR 0x874
893:                   OS_EXIT_CRITICAL();
000DC6  78009E     MOV [W14], W1
000DC8  880211     MOV W1, SR
894:                   OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
000DCA  200640     MOV #0x64, W0
000DCC  200001     MOV #0x0, W1
000DCE  072F28     RCALL OSTimeDly
895:                   OS_ENTER_CRITICAL();
000DD0  800211     MOV SR, W1
000DD2  780F01     MOV W1, [W14]
000DD4  800211     MOV SR, W1
000DD6  200E00     MOV #0xE0, W0
000DD8  700001     IOR W0, W1, W0
000DDA  880210     MOV W0, SR
896:                   OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000DDC  804390     MOV OSIdleCtr, W0
000DDE  8043A1     MOV 0x874, W1
000DE0  884310     MOV W0, OSIdleCtrMax
000DE2  884321     MOV W1, 0x864
897:                   OSStatRdy    = OS_TRUE;
000DE4  B3C010     MOV.B #0x1, W0
000DE6  B7E86A     MOV.B WREG, OSStatRdy
898:                   OS_EXIT_CRITICAL();
000DE8  78009E     MOV [W14], W1
000DEA  880211     MOV W1, SR
899:               }
000DEC  FA8000     ULNK
000DEE  060000     RETURN
900:               #endif
901:               /*$PAGE*/
902:               /*
903:               *********************************************************************************************************
904:               *                                         PROCESS SYSTEM TICK
905:               *
906:               * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
907:               *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
908:               *              called by a high priority task.
909:               *
910:               * Arguments  : none
911:               *
912:               * Returns    : none
913:               *********************************************************************************************************
914:               */
915:               
916:               void  OSTimeTick (void)
917:               {
000DF0  FA0006     LNK #0x6
918:                   OS_TCB    *ptcb;
919:               #if OS_TICK_STEP_EN > 0u
920:                   BOOLEAN    step;
921:               #endif
922:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
923:                   OS_CPU_SR  cpu_sr = 0u;
000DF2  EB0000     CLR W0
000DF4  980720     MOV W0, [W14+4]
924:               #endif
925:               
926:               
927:               
928:               #if OS_TIME_TICK_HOOK_EN > 0u
929:                   OSTimeTickHook();                                      /* Call user definable hook                     */
930:               #endif
931:               #if OS_TIME_GET_SET_EN > 0u
932:                   OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
933:                   OSTime++;
934:                   OS_EXIT_CRITICAL();
935:               #endif
936:                   if (OSRunning == OS_TRUE) {
000DF6  BFC870     MOV.B OSRunning, WREG
000DF8  504FE1     SUB.B W0, #0x1, [W15]
000DFA  3A006E     BRA NZ, 0xED8
937:               #if OS_TICK_STEP_EN > 0u
938:                       switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000DFC  BFC87E     MOV.B OSTickStepState, WREG
000DFE  FB8000     ZE W0, W0
000E00  500FE1     SUB W0, #0x1, [W15]
000E02  320007     BRA Z, 0xE12
000E04  500FE2     SUB W0, #0x2, [W15]
000E06  320008     BRA Z, 0xE18
000E08  E00000     CP0 W0
000E0A  3A000B     BRA NZ, 0xE22
939:                           case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
940:                                step = OS_TRUE;
000E0C  B3C010     MOV.B #0x1, W0
000E0E  984720     MOV.B W0, [W14+2]
941:                                break;
000E10  37000C     BRA 0xE2A
942:               
943:                           case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
944:                                step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
000E12  EB4000     CLR.B W0
000E14  984720     MOV.B W0, [W14+2]
945:                                break;
000E16  370009     BRA 0xE2A
946:               
947:                           case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
948:                                step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
000E18  B3C010     MOV.B #0x1, W0
000E1A  984720     MOV.B W0, [W14+2]
949:                                OSTickStepState = OS_TICK_STEP_WAIT;
000E1C  B3C010     MOV.B #0x1, W0
000E1E  B7E87E     MOV.B WREG, OSTickStepState
950:                                break;
000E20  370004     BRA 0xE2A
951:               
952:                           default:                                       /* Invalid case, correct situation              */
953:                                step            = OS_TRUE;
000E22  B3C010     MOV.B #0x1, W0
000E24  984720     MOV.B W0, [W14+2]
954:                                OSTickStepState = OS_TICK_STEP_DIS;
000E26  EF687E     CLR.B OSTickStepState
955:                                break;
000E28  000000     NOP
956:                       }
957:                       if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000E2A  90402E     MOV.B [W14+2], W0
000E2C  E00400     CP0.B W0
000E2E  320053     BRA Z, 0xED6
958:                           return;
000ED6  000000     NOP
959:                       }
960:               #endif
961:                       ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
000E30  8043E1     MOV OSTCBList, W1
000E32  780F01     MOV W1, [W14]
962:                       while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
000E34  37004B     BRA 0xECC
000ECC  78001E     MOV [W14], W0
000ECE  906020     MOV.B [W0+34], W0
000ED0  504FEC     SUB.B W0, #0xC, [W15]
000ED2  3AFFB1     BRA NZ, 0xE36
000ED4  370001     BRA 0xED8
963:                           OS_ENTER_CRITICAL();
000E36  800211     MOV SR, W1
000E38  980721     MOV W1, [W14+4]
000E3A  800211     MOV SR, W1
000E3C  200E00     MOV #0xE0, W0
000E3E  700001     IOR W0, W1, W0
000E40  880210     MOV W0, SR
964:                           if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
000E42  78001E     MOV [W14], W0
000E44  9008F0     MOV [W0+30], W1
000E46  900860     MOV [W0+28], W0
000E48  500FE0     SUB W0, #0x0, [W15]
000E4A  588FE0     SUBB W1, #0x0, [W15]
000E4C  32003A     BRA Z, 0xEC2
965:                               ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
000E4E  78001E     MOV [W14], W0
000E50  9008F0     MOV [W0+30], W1
000E52  900860     MOV [W0+28], W0
000E54  500061     SUB W0, #0x1, W0
000E56  5880E0     SUBB W1, #0x0, W1
000E58  78011E     MOV [W14], W2
000E5A  980960     MOV W0, [W2+28]
000E5C  980971     MOV W1, [W2+30]
966:                               if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
000E5E  78001E     MOV [W14], W0
000E60  9008F0     MOV [W0+30], W1
000E62  900860     MOV [W0+28], W0
000E64  500FE0     SUB W0, #0x0, [W15]
000E66  588FE0     SUBB W1, #0x0, [W15]
000E68  3A002C     BRA NZ, 0xEC2
967:               
968:                                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
000E6A  78001E     MOV [W14], W0
000E6C  906000     MOV.B [W0+32], W0
000E6E  FB8080     ZE W0, W1
000E70  200370     MOV #0x37, W0
000E72  608000     AND W1, W0, W0
000E74  E00000     CP0 W0
000E76  32000A     BRA Z, 0xE8C
969:                                       ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000E78  78001E     MOV [W14], W0
000E7A  906080     MOV.B [W0+32], W1
000E7C  B3CC80     MOV.B #0xC8, W0
000E7E  60C080     AND.B W1, W0, W1
000E80  78001E     MOV [W14], W0
000E82  986001     MOV.B W1, [W0+32]
970:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
000E84  78001E     MOV [W14], W0
000E86  B3C011     MOV.B #0x1, W1
000E88  986011     MOV.B W1, [W0+33]
000E8A  370003     BRA 0xE92
971:                                   } else {
972:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000E8C  78001E     MOV [W14], W0
000E8E  EB4080     CLR.B W1
000E90  986011     MOV.B W1, [W0+33]
973:                                   }
974:               
975:                                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
000E92  78001E     MOV [W14], W0
000E94  906000     MOV.B [W0+32], W0
000E96  FB8000     ZE W0, W0
000E98  600068     AND W0, #0x8, W0
000E9A  E00000     CP0 W0
000E9C  3A0012     BRA NZ, 0xEC2
976:                                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
000E9E  78001E     MOV [W14], W0
000EA0  9060E0     MOV.B [W0+38], W1
000EA2  BFC86F     MOV.B OSRdyGrp, WREG
000EA4  70C000     IOR.B W1, W0, W0
000EA6  B7E86F     MOV.B WREG, OSRdyGrp
977:                                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000EA8  78001E     MOV [W14], W0
000EAA  906040     MOV.B [W0+36], W0
000EAC  FB8000     ZE W0, W0
000EAE  78009E     MOV [W14], W1
000EB0  9060C1     MOV.B [W1+36], W1
000EB2  FB8081     ZE W1, W1
000EB4  209402     MOV #0x940, W2
000EB6  78C162     MOV.B [W2+W1], W2
000EB8  78009E     MOV [W14], W1
000EBA  9060D1     MOV.B [W1+37], W1
000EBC  714101     IOR.B W2, W1, W2
000EBE  209401     MOV #0x940, W1
000EC0  787082     MOV.B W2, [W1+W0]
978:                                   }
979:                               }
980:                           }
981:                           ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
000EC2  78001E     MOV [W14], W0
000EC4  9000F0     MOV [W0+14], W1
000EC6  780F01     MOV W1, [W14]
982:                           OS_EXIT_CRITICAL();
000EC8  9000AE     MOV [W14+4], W1
000ECA  880211     MOV W1, SR
983:                       }
984:                   }
985:               }
000ED8  FA8000     ULNK
000EDA  060000     RETURN
986:               
987:               /*$PAGE*/
988:               /*
989:               *********************************************************************************************************
990:               *                                             GET VERSION
991:               *
992:               * Description: This function is used to return the version number of uC/OS-II.  The returned value 
993:               *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
994:               *              2.01.00 would be returned as 20100.
995:               *
996:               * Arguments  : none
997:               *
998:               * Returns    : The version number of uC/OS-II multiplied by 10000.
999:               *********************************************************************************************************
1000:              */
1001:              
1002:              INT16U  OSVersion (void)
1003:              {
000EDC  FA0000     LNK #0x0
1004:                  return (OS_VERSION);
000EDE  2721B0     MOV #0x721B, W0
1005:              }
000EE0  FA8000     ULNK
000EE2  060000     RETURN
1006:              
1007:              /*$PAGE*/
1008:              /*
1009:              *********************************************************************************************************
1010:              *                                           DUMMY FUNCTION
1011:              *
1012:              * Description: This function doesn't do anything.  It is called by OSTaskDel().
1013:              *
1014:              * Arguments  : none
1015:              *
1016:              * Returns    : none
1017:              *********************************************************************************************************
1018:              */
1019:              
1020:              #if OS_TASK_DEL_EN > 0u
1021:              void  OS_Dummy (void)
1022:              {
000EE4  FA0000     LNK #0x0
1023:              }
000EE6  FA8000     ULNK
000EE8  060000     RETURN
1024:              #endif
1025:              
1026:              /*$PAGE*/
1027:              /*
1028:              *********************************************************************************************************
1029:              *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
1030:              *
1031:              * Description: This function is called by other uC/OS-II services and is used to ready a task that was
1032:              *              waiting for an event to occur.
1033:              *
1034:              * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
1035:              *
1036:              *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
1037:              *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
1038:              *                          service functions.
1039:              *
1040:              *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
1041:              *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
1042:              *
1043:              *              pend_stat   is used to indicate the readied task's pending status:
1044:              *
1045:              *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
1046:              *                                               an abort.
1047:              *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
1048:              *
1049:              * Returns    : none
1050:              *
1051:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1052:              *********************************************************************************************************
1053:              */
1054:              #if (OS_EVENT_EN)
1055:              INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
1056:                                      void      *pmsg,
1057:                                      INT8U      msk,
1058:                                      INT8U      pend_stat)
1059:              {
000EEA  FA000C     LNK #0xC
000EEC  980730     MOV W0, [W14+6]
000EEE  980741     MOV W1, [W14+8]
000EF0  984F22     MOV.B W2, [W14+10]
000EF2  984F33     MOV.B W3, [W14+11]
1060:                  OS_TCB   *ptcb;
1061:                  INT8U     y;
1062:                  INT8U     x;
1063:                  INT8U     prio;
1064:              #if OS_LOWEST_PRIO > 63u
1065:                  OS_PRIO  *ptbl;
1066:              #endif
1067:              
1068:              
1069:              #if OS_LOWEST_PRIO <= 63u
1070:                  y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000EF4  90003E     MOV [W14+6], W0
000EF6  904060     MOV.B [W0+6], W0
000EF8  FB8000     ZE W0, W0
000EFA  284461     MOV #0x8446, W1
000EFC  784F61     MOV.B [W1+W0], [W14]
1071:                  x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000EFE  FB801E     ZE [W14], W0
000F00  9000BE     MOV [W14+6], W1
000F02  400066     ADD W0, #0x6, W0
000F04  408000     ADD W1, W0, W0
000F06  904010     MOV.B [W0+1], W0
000F08  FB8000     ZE W0, W0
000F0A  284461     MOV #0x8446, W1
000F0C  784161     MOV.B [W1+W0], W2
000F0E  984712     MOV.B W2, [W14+1]
1072:                  prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
000F10  78409E     MOV.B [W14], W1
000F12  200030     MOV #0x3, W0
000F14  DD0880     SL W1, W0, W1
000F16  90401E     MOV.B [W14+1], W0
000F18  40C000     ADD.B W1, W0, W0
000F1A  984720     MOV.B W0, [W14+2]
1073:              #else
1074:                  if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
1075:                      y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
1076:                  } else {
1077:                      y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
1078:                  }
1079:                  ptbl = &pevent->OSEventTbl[y];
1080:                  if ((*ptbl & 0xFFu) != 0u) {
1081:                      x = OSUnMapTbl[*ptbl & 0xFFu];
1082:                  } else {
1083:                      x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
1084:                  }
1085:                  prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
1086:              #endif
1087:              
1088:                  ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000F1C  90402E     MOV.B [W14+2], W0
000F1E  FB8000     ZE W0, W0
000F20  400080     ADD W0, W0, W1
000F22  209C20     MOV #0x9C2, W0
000F24  408000     ADD W1, W0, W0
000F26  780090     MOV [W0], W1
000F28  980721     MOV W1, [W14+4]
1089:                  ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
000F2A  90012E     MOV [W14+4], W2
000F2C  B80060     MUL.UU W0, #0, W0
000F2E  980960     MOV W0, [W2+28]
000F30  980971     MOV W1, [W2+30]
1090:              #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
1091:                  ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000F32  90002E     MOV [W14+4], W0
000F34  90014E     MOV [W14+8], W2
000F36  980832     MOV W2, [W0+22]
1092:              #else
1093:                  pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
1094:              #endif
1095:                  ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000F38  90002E     MOV [W14+4], W0
000F3A  906080     MOV.B [W0+32], W1
000F3C  90482E     MOV.B [W14+10], W0
000F3E  EAC000     COM.B W0, W0
000F40  60C080     AND.B W1, W0, W1
000F42  90002E     MOV [W14+4], W0
000F44  986001     MOV.B W1, [W0+32]
1096:                  ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000F46  90002E     MOV [W14+4], W0
000F48  9048BE     MOV.B [W14+11], W1
000F4A  986011     MOV.B W1, [W0+33]
1097:                                                                      /* See if task is ready (could be susp'd)      */
1098:                  if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000F4C  90002E     MOV [W14+4], W0
000F4E  906000     MOV.B [W0+32], W0
000F50  FB8000     ZE W0, W0
000F52  600068     AND W0, #0x8, W0
000F54  E00000     CP0 W0
000F56  3A000E     BRA NZ, 0xF74
1099:                      OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000F58  90002E     MOV [W14+4], W0
000F5A  9060E0     MOV.B [W0+38], W1
000F5C  BFC86F     MOV.B OSRdyGrp, WREG
000F5E  70C000     IOR.B W1, W0, W0
000F60  B7E86F     MOV.B WREG, OSRdyGrp
1100:                      OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000F62  FB801E     ZE [W14], W0
000F64  FB809E     ZE [W14], W1
000F66  209402     MOV #0x940, W2
000F68  78C162     MOV.B [W2+W1], W2
000F6A  9000AE     MOV [W14+4], W1
000F6C  9060D1     MOV.B [W1+37], W1
000F6E  714101     IOR.B W2, W1, W2
000F70  209401     MOV #0x940, W1
000F72  787082     MOV.B W2, [W1+W0]
1101:                  }
1102:              
1103:                  OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000F74  9000BE     MOV [W14+6], W1
000F76  90002E     MOV [W14+4], W0
000F78  07008E     RCALL OS_EventTaskRemove
1104:              #if (OS_EVENT_MULTI_EN > 0u)
1105:                  if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000F7A  90002E     MOV [W14+4], W0
000F7C  900820     MOV [W0+20], W0
000F7E  E00000     CP0 W0
000F80  320008     BRA Z, 0xF92
1106:                      OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000F82  90002E     MOV [W14+4], W0
000F84  900820     MOV [W0+20], W0
000F86  780080     MOV W0, W1
000F88  90002E     MOV [W14+4], W0
000F8A  0700AC     RCALL OS_EventTaskRemoveMulti
1107:                      ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000F8C  90002E     MOV [W14+4], W0
000F8E  90013E     MOV [W14+6], W2
000F90  980812     MOV W2, [W0+18]
1108:                  }
1109:              #endif
1110:              
1111:                  return (prio);
000F92  90402E     MOV.B [W14+2], W0
1112:              }
000F94  FA8000     ULNK
000F96  060000     RETURN
1113:              #endif
1114:              /*$PAGE*/
1115:              /*
1116:              *********************************************************************************************************
1117:              *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
1118:              *
1119:              * Description: This function is called by other uC/OS-II services to suspend a task because an event has
1120:              *              not occurred.
1121:              *
1122:              * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
1123:              *
1124:              * Returns    : none
1125:              *
1126:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1127:              *********************************************************************************************************
1128:              */
1129:              #if (OS_EVENT_EN)
1130:              void  OS_EventTaskWait (OS_EVENT *pevent)
1131:              {
000F98  FA0004     LNK #0x4
000F9A  980710     MOV W0, [W14+2]
1132:                  INT8U  y;
1133:              
1134:              
1135:                  OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000F9C  8043B0     MOV OSTCBCur, W0
000F9E  90009E     MOV [W14+2], W1
000FA0  980811     MOV W1, [W0+18]
1136:              
1137:                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000FA2  8043B0     MOV OSTCBCur, W0
000FA4  906040     MOV.B [W0+36], W0
000FA6  FB8000     ZE W0, W0
000FA8  8043B1     MOV OSTCBCur, W1
000FAA  9060C1     MOV.B [W1+36], W1
000FAC  FB8081     ZE W1, W1
000FAE  90011E     MOV [W14+2], W2
000FB0  4080E6     ADD W1, #0x6, W1
000FB2  410081     ADD W2, W1, W1
000FB4  904111     MOV.B [W1+1], W2
000FB6  8043B1     MOV OSTCBCur, W1
000FB8  9060D1     MOV.B [W1+37], W1
000FBA  714081     IOR.B W2, W1, W1
000FBC  90011E     MOV [W14+2], W2
000FBE  410000     ADD W2, W0, W0
000FC0  984071     MOV.B W1, [W0+7]
1138:                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000FC2  90001E     MOV [W14+2], W0
000FC4  9040E0     MOV.B [W0+6], W1
000FC6  8043B0     MOV OSTCBCur, W0
000FC8  906060     MOV.B [W0+38], W0
000FCA  70C080     IOR.B W1, W0, W1
000FCC  90001E     MOV [W14+2], W0
000FCE  984061     MOV.B W1, [W0+6]
1139:              
1140:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000FD0  8043B0     MOV OSTCBCur, W0
000FD2  9060C0     MOV.B [W0+36], W1
000FD4  784F01     MOV.B W1, [W14]
1141:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000FD6  FB801E     ZE [W14], W0
000FD8  FB809E     ZE [W14], W1
000FDA  209402     MOV #0x940, W2
000FDC  78C162     MOV.B [W2+W1], W2
000FDE  8043B1     MOV OSTCBCur, W1
000FE0  9060D1     MOV.B [W1+37], W1
000FE2  EAC081     COM.B W1, W1
000FE4  614101     AND.B W2, W1, W2
000FE6  209401     MOV #0x940, W1
000FE8  787082     MOV.B W2, [W1+W0]
1142:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000FEA  FB801E     ZE [W14], W0
000FEC  209401     MOV #0x940, W1
000FEE  784061     MOV.B [W1+W0], W0
000FF0  E00400     CP0.B W0
000FF2  3A0006     BRA NZ, 0x1000
1143:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000FF4  8043B0     MOV OSTCBCur, W0
000FF6  906060     MOV.B [W0+38], W0
000FF8  EAC080     COM.B W0, W1
000FFA  BFC86F     MOV.B OSRdyGrp, WREG
000FFC  60C000     AND.B W1, W0, W0
000FFE  B7E86F     MOV.B WREG, OSRdyGrp
1144:                  }
1145:              }
001000  FA8000     ULNK
001002  060000     RETURN
1146:              #endif
1147:              /*$PAGE*/
1148:              /*
1149:              *********************************************************************************************************
1150:              *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
1151:              *
1152:              * Description: This function is called by other uC/OS-II services to suspend a task because any one of
1153:              *              multiple events has not occurred.
1154:              *
1155:              * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
1156:              *                               which the task will be waiting for.
1157:              *
1158:              * Returns    : none.
1159:              *
1160:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1161:              *********************************************************************************************************
1162:              */
1163:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1164:              void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
1165:              {
001004  FA0008     LNK #0x8
001006  980730     MOV W0, [W14+6]
1166:                  OS_EVENT **pevents;
1167:                  OS_EVENT  *pevent;
1168:                  INT8U      y;
1169:              
1170:              
1171:                  OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
001008  8043B0     MOV OSTCBCur, W0
00100A  EB0080     CLR W1
00100C  980811     MOV W1, [W0+18]
1172:                  OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00100E  8043B0     MOV OSTCBCur, W0
001010  9000BE     MOV [W14+6], W1
001012  980821     MOV W1, [W0+20]
1173:              
1174:                  pevents =  pevents_wait;
001014  9000BE     MOV [W14+6], W1
001016  780F01     MOV W1, [W14]
1175:                  pevent  = *pevents;
001018  78001E     MOV [W14], W0
00101A  780090     MOV [W0], W1
00101C  980711     MOV W1, [W14+2]
1176:                  while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
00101E  37001B     BRA 0x1056
001056  90001E     MOV [W14+2], W0
001058  E00000     CP0 W0
00105A  3AFFE2     BRA NZ, 0x1020
1177:                      pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
001020  8043B0     MOV OSTCBCur, W0
001022  906040     MOV.B [W0+36], W0
001024  FB8000     ZE W0, W0
001026  8043B1     MOV OSTCBCur, W1
001028  9060C1     MOV.B [W1+36], W1
00102A  FB8081     ZE W1, W1
00102C  90011E     MOV [W14+2], W2
00102E  4080E6     ADD W1, #0x6, W1
001030  410081     ADD W2, W1, W1
001032  904111     MOV.B [W1+1], W2
001034  8043B1     MOV OSTCBCur, W1
001036  9060D1     MOV.B [W1+37], W1
001038  714081     IOR.B W2, W1, W1
00103A  90011E     MOV [W14+2], W2
00103C  410000     ADD W2, W0, W0
00103E  984071     MOV.B W1, [W0+7]
1178:                      pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
001040  90001E     MOV [W14+2], W0
001042  9040E0     MOV.B [W0+6], W1
001044  8043B0     MOV OSTCBCur, W0
001046  906060     MOV.B [W0+38], W0
001048  70C080     IOR.B W1, W0, W1
00104A  90001E     MOV [W14+2], W0
00104C  984061     MOV.B W1, [W0+6]
1179:                      pevents++;
00104E  E88F1E     INC2 [W14], [W14]
1180:                      pevent = *pevents;
001050  78001E     MOV [W14], W0
001052  780090     MOV [W0], W1
001054  980711     MOV W1, [W14+2]
1181:                  }
1182:              
1183:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00105C  8043B0     MOV OSTCBCur, W0
00105E  9060C0     MOV.B [W0+36], W1
001060  984741     MOV.B W1, [W14+4]
1184:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
001062  90404E     MOV.B [W14+4], W0
001064  FB8000     ZE W0, W0
001066  9040CE     MOV.B [W14+4], W1
001068  FB8081     ZE W1, W1
00106A  209402     MOV #0x940, W2
00106C  78C162     MOV.B [W2+W1], W2
00106E  8043B1     MOV OSTCBCur, W1
001070  9060D1     MOV.B [W1+37], W1
001072  EAC081     COM.B W1, W1
001074  614101     AND.B W2, W1, W2
001076  209401     MOV #0x940, W1
001078  787082     MOV.B W2, [W1+W0]
1185:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00107A  90404E     MOV.B [W14+4], W0
00107C  FB8000     ZE W0, W0
00107E  209401     MOV #0x940, W1
001080  784061     MOV.B [W1+W0], W0
001082  E00400     CP0.B W0
001084  3A0006     BRA NZ, 0x1092
1186:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
001086  8043B0     MOV OSTCBCur, W0
001088  906060     MOV.B [W0+38], W0
00108A  EAC080     COM.B W0, W1
00108C  BFC86F     MOV.B OSRdyGrp, WREG
00108E  60C000     AND.B W1, W0, W0
001090  B7E86F     MOV.B WREG, OSRdyGrp
1187:                  }
1188:              }
001092  FA8000     ULNK
001094  060000     RETURN
1189:              #endif
1190:              /*$PAGE*/
1191:              /*
1192:              *********************************************************************************************************
1193:              *                                  REMOVE TASK FROM EVENT WAIT LIST
1194:              *
1195:              * Description: Remove a task from an event's wait list.
1196:              *
1197:              * Arguments  : ptcb     is a pointer to the task to remove.
1198:              *
1199:              *              pevent   is a pointer to the event control block.
1200:              *
1201:              * Returns    : none
1202:              *
1203:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1204:              *********************************************************************************************************
1205:              */
1206:              #if (OS_EVENT_EN)
1207:              void  OS_EventTaskRemove (OS_TCB   *ptcb,
1208:                                        OS_EVENT *pevent)
1209:              {
001096  FA0006     LNK #0x6
001098  980710     MOV W0, [W14+2]
00109A  980721     MOV W1, [W14+4]
1210:                  INT8U  y;
1211:              
1212:              
1213:                  y                       =  ptcb->OSTCBY;
00109C  90001E     MOV [W14+2], W0
00109E  9060C0     MOV.B [W0+36], W1
0010A0  784F01     MOV.B W1, [W14]
1214:                  pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
0010A2  FB801E     ZE [W14], W0
0010A4  FB809E     ZE [W14], W1
0010A6  90012E     MOV [W14+4], W2
0010A8  4080E6     ADD W1, #0x6, W1
0010AA  410081     ADD W2, W1, W1
0010AC  904111     MOV.B [W1+1], W2
0010AE  90009E     MOV [W14+2], W1
0010B0  9060D1     MOV.B [W1+37], W1
0010B2  EAC081     COM.B W1, W1
0010B4  614081     AND.B W2, W1, W1
0010B6  90012E     MOV [W14+4], W2
0010B8  410000     ADD W2, W0, W0
0010BA  984071     MOV.B W1, [W0+7]
1215:                  if (pevent->OSEventTbl[y] == 0u) {
0010BC  FB801E     ZE [W14], W0
0010BE  9000AE     MOV [W14+4], W1
0010C0  400066     ADD W0, #0x6, W0
0010C2  408000     ADD W1, W0, W0
0010C4  904010     MOV.B [W0+1], W0
0010C6  E00400     CP0.B W0
0010C8  3A0008     BRA NZ, 0x10DA
1216:                      pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0010CA  90002E     MOV [W14+4], W0
0010CC  9040E0     MOV.B [W0+6], W1
0010CE  90001E     MOV [W14+2], W0
0010D0  906060     MOV.B [W0+38], W0
0010D2  EAC000     COM.B W0, W0
0010D4  60C080     AND.B W1, W0, W1
0010D6  90002E     MOV [W14+4], W0
0010D8  984061     MOV.B W1, [W0+6]
1217:                  }
1218:                  ptcb->OSTCBEventPtr     = (OS_EVENT  *)0;               /* Unlink OS_EVENT from OS_TCB             */
0010DA  90001E     MOV [W14+2], W0
0010DC  EB0080     CLR W1
0010DE  980811     MOV W1, [W0+18]
1219:              }
0010E0  FA8000     ULNK
0010E2  060000     RETURN
1220:              #endif
1221:              /*$PAGE*/
1222:              /*
1223:              *********************************************************************************************************
1224:              *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
1225:              *
1226:              * Description: Remove a task from multiple events' wait lists.
1227:              *
1228:              * Arguments  : ptcb             is a pointer to the task to remove.
1229:              *
1230:              *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
1231:              *
1232:              * Returns    : none
1233:              *
1234:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1235:              *********************************************************************************************************
1236:              */
1237:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1238:              void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
1239:                                             OS_EVENT **pevents_multi)
1240:              {
0010E4  FA000C     LNK #0xC
0010E6  980740     MOV W0, [W14+8]
0010E8  980751     MOV W1, [W14+10]
1241:                  OS_EVENT **pevents;
1242:                  OS_EVENT  *pevent;
1243:                  INT8U      y;
1244:                  OS_PRIO    bity;
1245:                  OS_PRIO    bitx;
1246:              
1247:              
1248:                  y       =  ptcb->OSTCBY;
0010EA  90004E     MOV [W14+8], W0
0010EC  9060C0     MOV.B [W0+36], W1
0010EE  984741     MOV.B W1, [W14+4]
1249:                  bity    =  ptcb->OSTCBBitY;
0010F0  90004E     MOV [W14+8], W0
0010F2  9060E0     MOV.B [W0+38], W1
0010F4  984751     MOV.B W1, [W14+5]
1250:                  bitx    =  ptcb->OSTCBBitX;
0010F6  90004E     MOV [W14+8], W0
0010F8  9060D0     MOV.B [W0+37], W1
0010FA  984761     MOV.B W1, [W14+6]
1251:                  pevents =  pevents_multi;
0010FC  9000DE     MOV [W14+10], W1
0010FE  780F01     MOV W1, [W14]
1252:                  pevent  = *pevents;
001100  78001E     MOV [W14], W0
001102  780090     MOV [W0], W1
001104  980711     MOV W1, [W14+2]
1253:                  while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
001106  370021     BRA 0x114A
00114A  90001E     MOV [W14+2], W0
00114C  E00000     CP0 W0
00114E  3AFFDC     BRA NZ, 0x1108
1254:                      pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
001108  90404E     MOV.B [W14+4], W0
00110A  FB8000     ZE W0, W0
00110C  9040CE     MOV.B [W14+4], W1
00110E  FB8081     ZE W1, W1
001110  90011E     MOV [W14+2], W2
001112  4080E6     ADD W1, #0x6, W1
001114  410081     ADD W2, W1, W1
001116  904111     MOV.B [W1+1], W2
001118  9040EE     MOV.B [W14+6], W1
00111A  EAC081     COM.B W1, W1
00111C  614081     AND.B W2, W1, W1
00111E  90011E     MOV [W14+2], W2
001120  410000     ADD W2, W0, W0
001122  984071     MOV.B W1, [W0+7]
1255:                      if (pevent->OSEventTbl[y] == 0u) {
001124  90404E     MOV.B [W14+4], W0
001126  FB8000     ZE W0, W0
001128  90009E     MOV [W14+2], W1
00112A  400066     ADD W0, #0x6, W0
00112C  408000     ADD W1, W0, W0
00112E  904010     MOV.B [W0+1], W0
001130  E00400     CP0.B W0
001132  3A0007     BRA NZ, 0x1142
1256:                          pevent->OSEventGrp &= (OS_PRIO)~bity;
001134  90001E     MOV [W14+2], W0
001136  9040E0     MOV.B [W0+6], W1
001138  90405E     MOV.B [W14+5], W0
00113A  EAC000     COM.B W0, W0
00113C  60C080     AND.B W1, W0, W1
00113E  90001E     MOV [W14+2], W0
001140  984061     MOV.B W1, [W0+6]
1257:                      }
1258:                      pevents++;
001142  E88F1E     INC2 [W14], [W14]
1259:                      pevent = *pevents;
001144  78001E     MOV [W14], W0
001146  780090     MOV [W0], W1
001148  980711     MOV W1, [W14+2]
1260:                  }
1261:              }
001150  FA8000     ULNK
001152  060000     RETURN
1262:              #endif
1263:              /*$PAGE*/
1264:              /*
1265:              *********************************************************************************************************
1266:              *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
1267:              *
1268:              * Description: This function is called by other uC/OS-II services to initialize the event wait list.
1269:              *
1270:              * Arguments  : pevent    is a pointer to the event control block allocated to the event.
1271:              *
1272:              * Returns    : none
1273:              *
1274:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1275:              *********************************************************************************************************
1276:              */
1277:              #if (OS_EVENT_EN)
1278:              void  OS_EventWaitListInit (OS_EVENT *pevent)
1279:              {
001154  FA0004     LNK #0x4
001156  980710     MOV W0, [W14+2]
1280:                  INT8U  i;
1281:              
1282:              
1283:                  pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
001158  90001E     MOV [W14+2], W0
00115A  EB4080     CLR.B W1
00115C  984061     MOV.B W1, [W0+6]
1284:                  for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00115E  EB4000     CLR.B W0
001160  784F00     MOV.B W0, [W14]
001162  370006     BRA 0x1170
00116E  E84F1E     INC.B [W14], [W14]
001170  78401E     MOV.B [W14], W0
001172  504FE1     SUB.B W0, #0x1, [W15]
001174  36FFF7     BRA LEU, 0x1164
1285:                      pevent->OSEventTbl[i] = 0u;
001164  FB801E     ZE [W14], W0
001166  90009E     MOV [W14+2], W1
001168  408000     ADD W1, W0, W0
00116A  EB4080     CLR.B W1
00116C  984071     MOV.B W1, [W0+7]
1286:                  }
1287:              }
001176  FA8000     ULNK
001178  060000     RETURN
1288:              #endif
1289:              /*$PAGE*/
1290:              /*
1291:              *********************************************************************************************************
1292:              *                                             INITIALIZATION
1293:              *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
1294:              *
1295:              * Description: This function is called by OSInit() to initialize the free list of event control blocks.
1296:              *
1297:              * Arguments  : none
1298:              *
1299:              * Returns    : none
1300:              *********************************************************************************************************
1301:              */
1302:              
1303:              static  void  OS_InitEventList (void)
1304:              {
00117A  FA0008     LNK #0x8
1305:              #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
1306:              #if (OS_MAX_EVENTS > 1u)
1307:                  INT16U     ix;
1308:                  INT16U     ix_next;
1309:                  OS_EVENT  *pevent1;
1310:                  OS_EVENT  *pevent2;
1311:              
1312:              
1313:                  OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00117C  208900     MOV #0x890, W0
00117E  200301     MOV #0x30, W1
001180  0700B2     RCALL OS_MemClr
1314:                  for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
001182  EB0000     CLR W0
001184  780F00     MOV W0, [W14]
001186  370018     BRA 0x11B8
0011B6  E80F1E     INC [W14], [W14]
0011B8  78001E     MOV [W14], W0
0011BA  500FE2     SUB W0, #0x2, [W15]
0011BC  36FFE5     BRA LEU, 0x1188
1315:                      ix_next = ix + 1u;
001188  E8001E     INC [W14], W0
00118A  980710     MOV W0, [W14+2]
1316:                      pevent1 = &OSEventTbl[ix];
00118C  78001E     MOV [W14], W0
00118E  B9006C     MUL.SU W0, #12, W0
001190  780080     MOV W0, W1
001192  208900     MOV #0x890, W0
001194  408000     ADD W1, W0, W0
001196  980720     MOV W0, [W14+4]
1317:                      pevent2 = &OSEventTbl[ix_next];
001198  90001E     MOV [W14+2], W0
00119A  B9006C     MUL.SU W0, #12, W0
00119C  780080     MOV W0, W1
00119E  208900     MOV #0x890, W0
0011A0  408000     ADD W1, W0, W0
0011A2  980730     MOV W0, [W14+6]
1318:                      pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0011A4  90002E     MOV [W14+4], W0
0011A6  EB4080     CLR.B W1
0011A8  784801     MOV.B W1, [W0]
1319:                      pevent1->OSEventPtr     = pevent2;
0011AA  90002E     MOV [W14+4], W0
0011AC  9000BE     MOV [W14+6], W1
0011AE  980011     MOV W1, [W0+2]
1320:              #if OS_EVENT_NAME_EN > 0u
1321:                      pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
0011B0  285461     MOV #0x8546, W1
0011B2  90002E     MOV [W14+4], W0
0011B4  980051     MOV W1, [W0+10]
1322:              #endif
1323:                  }
1324:                  pevent1                         = &OSEventTbl[ix];
0011BE  78001E     MOV [W14], W0
0011C0  B9006C     MUL.SU W0, #12, W0
0011C2  780080     MOV W0, W1
0011C4  208900     MOV #0x890, W0
0011C6  408000     ADD W1, W0, W0
0011C8  980720     MOV W0, [W14+4]
1325:                  pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
0011CA  90002E     MOV [W14+4], W0
0011CC  EB4080     CLR.B W1
0011CE  784801     MOV.B W1, [W0]
1326:                  pevent1->OSEventPtr             = (OS_EVENT *)0;
0011D0  90002E     MOV [W14+4], W0
0011D2  EB0080     CLR W1
0011D4  980011     MOV W1, [W0+2]
1327:              #if OS_EVENT_NAME_EN > 0u
1328:                  pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
0011D6  285461     MOV #0x8546, W1
0011D8  90002E     MOV [W14+4], W0
0011DA  980051     MOV W1, [W0+10]
1329:              #endif
1330:                  OSEventFreeList                 = &OSEventTbl[0];
0011DC  208900     MOV #0x890, W0
0011DE  8842A0     MOV W0, OSEventFreeList
1331:              #else
1332:                  OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
1333:                  OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
1334:                  OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
1335:              #if OS_EVENT_NAME_EN > 0u
1336:                  OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
1337:              #endif
1338:              #endif
1339:              #endif
1340:              }
0011E0  FA8000     ULNK
0011E2  060000     RETURN
1341:              /*$PAGE*/
1342:              /*
1343:              *********************************************************************************************************
1344:              *                                             INITIALIZATION
1345:              *                                    INITIALIZE MISCELLANEOUS VARIABLES
1346:              *
1347:              * Description: This function is called by OSInit() to initialize miscellaneous variables.
1348:              *
1349:              * Arguments  : none
1350:              *
1351:              * Returns    : none
1352:              *********************************************************************************************************
1353:              */
1354:              
1355:              static  void  OS_InitMisc (void)
1356:              {
0011E4  FA0000     LNK #0x0
1357:              #if OS_TIME_GET_SET_EN > 0u
1358:                  OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
1359:              #endif
1360:              
1361:                  OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
0011E6  EF686B     CLR.B OSIntNesting
1362:                  OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
0011E8  EF686C     CLR.B OSLockNesting
1363:              
1364:                  OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
0011EA  EF6871     CLR.B OSTaskCtr
1365:              
1366:                  OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
0011EC  EF6870     CLR.B OSRunning
1367:              
1368:                  OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
0011EE  EF2850     CLR OSCtxSwCtr
0011F0  EF2852     CLR 0x852
1369:                  OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
0011F2  EF2872     CLR OSIdleCtr
0011F4  EF2874     CLR 0x874
1370:              
1371:              #if OS_TASK_STAT_EN > 0u
1372:                  OSIdleCtrRun              = 0uL;
0011F6  EF2866     CLR OSIdleCtrRun
0011F8  EF2868     CLR 0x868
1373:                  OSIdleCtrMax              = 0uL;
0011FA  EF2862     CLR OSIdleCtrMax
0011FC  EF2864     CLR 0x864
1374:                  OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
0011FE  EF686A     CLR.B OSStatRdy
1375:              #endif
1376:              
1377:              #ifdef OS_SAFETY_CRITICAL_IEC61508
1378:                  OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
1379:              #endif
1380:              
1381:              #if OS_TASK_REG_TBL_SIZE > 0u
1382:                  OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
001200  EF6882     CLR.B OSTaskRegNextAvailID
1383:              #endif
1384:              }
001202  FA8000     ULNK
001204  060000     RETURN
1385:              /*$PAGE*/
1386:              /*
1387:              *********************************************************************************************************
1388:              *                                             INITIALIZATION
1389:              *                                       INITIALIZE THE READY LIST
1390:              *
1391:              * Description: This function is called by OSInit() to initialize the Ready List.
1392:              *
1393:              * Arguments  : none
1394:              *
1395:              * Returns    : none
1396:              *********************************************************************************************************
1397:              */
1398:              
1399:              static  void  OS_InitRdyList (void)
1400:              {
001206  FA0002     LNK #0x2
1401:                  INT8U  i;
1402:              
1403:              
1404:                  OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
001208  EF686F     CLR.B OSRdyGrp
1405:                  for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
00120A  EB4000     CLR.B W0
00120C  784F00     MOV.B W0, [W14]
00120E  370005     BRA 0x121A
001218  E84F1E     INC.B [W14], [W14]
00121A  78401E     MOV.B [W14], W0
00121C  504FE1     SUB.B W0, #0x1, [W15]
00121E  36FFF8     BRA LEU, 0x1210
1406:                      OSRdyTbl[i] = 0u;
001210  FB801E     ZE [W14], W0
001212  209401     MOV #0x940, W1
001214  EB4100     CLR.B W2
001216  787082     MOV.B W2, [W1+W0]
1407:                  }
1408:              
1409:                  OSPrioCur     = 0u;
001220  EF686D     CLR.B OSPrioCur
1410:                  OSPrioHighRdy = 0u;
001222  EF686E     CLR.B OSPrioHighRdy
1411:              
1412:                  OSTCBHighRdy  = (OS_TCB *)0;
001224  EF287A     CLR OSTCBHighRdy
1413:                  OSTCBCur      = (OS_TCB *)0;
001226  EF2876     CLR OSTCBCur
1414:              }
001228  FA8000     ULNK
00122A  060000     RETURN
1415:              
1416:              /*$PAGE*/
1417:              /*
1418:              *********************************************************************************************************
1419:              *                                             INITIALIZATION
1420:              *                                         CREATING THE IDLE TASK
1421:              *
1422:              * Description: This function creates the Idle Task.
1423:              *
1424:              * Arguments  : none
1425:              *
1426:              * Returns    : none
1427:              *********************************************************************************************************
1428:              */
1429:              
1430:              static  void  OS_InitTaskIdle (void)
1431:              {
00122C  FA0002     LNK #0x2
1432:              #if OS_TASK_NAME_EN > 0u
1433:                  INT8U  err;
1434:              #endif
1435:              
1436:              
1437:              #if OS_TASK_CREATE_EXT_EN > 0u
1438:                  #if OS_STK_GROWTH == 1u
1439:                  (void)OSTaskCreateExt(OS_TaskIdle,
1440:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1441:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
1442:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1443:                                        OS_TASK_IDLE_ID,
1444:                                        &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
1445:                                        OS_TASK_IDLE_STK_SIZE,
1446:                                        (void *)0,                                 /* No TCB extension                     */
1447:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1448:                  #else
1449:                  (void)OSTaskCreateExt(OS_TaskIdle,
00122E  200030     MOV #0x3, W0
001230  781F80     MOV W0, [W15++]
001232  EB0000     CLR W0
001234  781F80     MOV W0, [W15++]
001236  200406     MOV #0x40, W6
001238  200007     MOV #0x0, W7
00123A  209C05     MOV #0x9C0, W5
00123C  EB8200     SETM W4
00123E  B3C0C3     MOV.B #0xC, W3
001240  209422     MOV #0x942, W2
001242  EB0080     CLR W1
001244  213DA0     MOV #0x13DA, W0
001246  07101F     RCALL OSTaskCreateExt
001248  5787E4     SUB W15, #0x4, W15
1450:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1451:                                        &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
1452:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1453:                                        OS_TASK_IDLE_ID,
1454:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
1455:                                        OS_TASK_IDLE_STK_SIZE,
1456:                                        (void *)0,                                 /* No TCB extension                     */
1457:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1458:                  #endif
1459:              #else
1460:                  #if OS_STK_GROWTH == 1u
1461:                  (void)OSTaskCreate(OS_TaskIdle,
1462:                                     (void *)0,
1463:                                     &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
1464:                                     OS_TASK_IDLE_PRIO);
1465:                  #else
1466:                  (void)OSTaskCreate(OS_TaskIdle,
1467:                                     (void *)0,
1468:                                     &OSTaskIdleStk[0],
1469:                                     OS_TASK_IDLE_PRIO);
1470:                  #endif
1471:              #endif
1472:              
1473:              #if OS_TASK_NAME_EN > 0u
1474:                  OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
00124A  285480     MOV #0x8548, W0
00124C  78010E     MOV W14, W2
00124E  780080     MOV W0, W1
001250  B3C0C0     MOV.B #0xC, W0
001252  0711D4     RCALL OSTaskNameSet
1475:              #endif
1476:              }
001254  FA8000     ULNK
001256  060000     RETURN
1477:              /*$PAGE*/
1478:              /*
1479:              *********************************************************************************************************
1480:              *                                             INITIALIZATION
1481:              *                                      CREATING THE STATISTIC TASK
1482:              *
1483:              * Description: This function creates the Statistic Task.
1484:              *
1485:              * Arguments  : none
1486:              *
1487:              * Returns    : none
1488:              *********************************************************************************************************
1489:              */
1490:              
1491:              #if OS_TASK_STAT_EN > 0u
1492:              static  void  OS_InitTaskStat (void)
1493:              {
001258  FA0002     LNK #0x2
1494:              #if OS_TASK_NAME_EN > 0u
1495:                  INT8U  err;
1496:              #endif
1497:              
1498:              
1499:              #if OS_TASK_CREATE_EXT_EN > 0u
1500:                  #if OS_STK_GROWTH == 1u
1501:                  (void)OSTaskCreateExt(OS_TaskStat,
1502:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1503:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
1504:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1505:                                        OS_TASK_STAT_ID,
1506:                                        &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
1507:                                        OS_TASK_STAT_STK_SIZE,
1508:                                        (void *)0,                                   /* No TCB extension               */
1509:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1510:                  #else
1511:                  (void)OSTaskCreateExt(OS_TaskStat,
00125A  200030     MOV #0x3, W0
00125C  781F80     MOV W0, [W15++]
00125E  EB0000     CLR W0
001260  781F80     MOV W0, [W15++]
001262  200406     MOV #0x40, W6
001264  200007     MOV #0x0, W7
001266  2093E5     MOV #0x93E, W5
001268  2FFFE4     MOV #0xFFFE, W4
00126A  B3C0B3     MOV.B #0xB, W3
00126C  208C02     MOV #0x8C0, W2
00126E  EB0080     CLR W1
001270  214020     MOV #0x1402, W0
001272  071009     RCALL OSTaskCreateExt
001274  5787E4     SUB W15, #0x4, W15
1512:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1513:                                        &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
1514:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1515:                                        OS_TASK_STAT_ID,
1516:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
1517:                                        OS_TASK_STAT_STK_SIZE,
1518:                                        (void *)0,                                   /* No TCB extension               */
1519:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1520:                  #endif
1521:              #else
1522:                  #if OS_STK_GROWTH == 1u
1523:                  (void)OSTaskCreate(OS_TaskStat,
1524:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1525:                                     &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
1526:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1527:                  #else
1528:                  (void)OSTaskCreate(OS_TaskStat,
1529:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1530:                                     &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
1531:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1532:                  #endif
1533:              #endif
1534:              
1535:              #if OS_TASK_NAME_EN > 0u
1536:                  OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
001276  285560     MOV #0x8556, W0
001278  78010E     MOV W14, W2
00127A  780080     MOV W0, W1
00127C  B3C0B0     MOV.B #0xB, W0
00127E  0711BE     RCALL OSTaskNameSet
1537:              #endif
1538:              }
001280  FA8000     ULNK
001282  060000     RETURN
1539:              #endif
1540:              /*$PAGE*/
1541:              /*
1542:              *********************************************************************************************************
1543:              *                                             INITIALIZATION
1544:              *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
1545:              *
1546:              * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
1547:              *
1548:              * Arguments  : none
1549:              *
1550:              * Returns    : none
1551:              *********************************************************************************************************
1552:              */
1553:              
1554:              static  void  OS_InitTCBList (void)
1555:              {
001284  FA0006     LNK #0x6
1556:                  INT8U    ix;
1557:                  INT8U    ix_next;
1558:                  OS_TCB  *ptcb1;
1559:                  OS_TCB  *ptcb2;
1560:              
1561:              
1562:                  OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
001286  209DC0     MOV #0x9DC, W0
001288  202C01     MOV #0x2C0, W1
00128A  07002D     RCALL OS_MemClr
1563:                  OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00128C  209C20     MOV #0x9C2, W0
00128E  2001A1     MOV #0x1A, W1
001290  07002A     RCALL OS_MemClr
1564:                  for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
001292  EB4000     CLR.B W0
001294  784F00     MOV.B W0, [W14]
001296  370014     BRA 0x12C0
0012BE  E84F1E     INC.B [W14], [W14]
0012C0  78401E     MOV.B [W14], W0
0012C2  504FE9     SUB.B W0, #0x9, [W15]
0012C4  36FFE9     BRA LEU, 0x1298
1565:                      ix_next =  ix + 1u;
001298  E8401E     INC.B [W14], W0
00129A  984710     MOV.B W0, [W14+1]
1566:                      ptcb1   = &OSTCBTbl[ix];
00129C  FB801E     ZE [W14], W0
00129E  DD00C6     SL W0, #6, W1
0012A0  209DC0     MOV #0x9DC, W0
0012A2  408000     ADD W1, W0, W0
0012A4  980710     MOV W0, [W14+2]
1567:                      ptcb2   = &OSTCBTbl[ix_next];
0012A6  90401E     MOV.B [W14+1], W0
0012A8  FB8000     ZE W0, W0
0012AA  DD00C6     SL W0, #6, W1
0012AC  209DC0     MOV #0x9DC, W0
0012AE  408000     ADD W1, W0, W0
0012B0  980720     MOV W0, [W14+4]
1568:                      ptcb1->OSTCBNext = ptcb2;
0012B2  90001E     MOV [W14+2], W0
0012B4  9000AE     MOV [W14+4], W1
0012B6  980071     MOV W1, [W0+14]
1569:              #if OS_TASK_NAME_EN > 0u
1570:                      ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
0012B8  285461     MOV #0x8546, W1
0012BA  90001E     MOV [W14+2], W0
0012BC  981851     MOV W1, [W0+58]
1571:              #endif
1572:                  }
1573:                  ptcb1                   = &OSTCBTbl[ix];
0012C6  FB801E     ZE [W14], W0
0012C8  DD00C6     SL W0, #6, W1
0012CA  209DC0     MOV #0x9DC, W0
0012CC  408000     ADD W1, W0, W0
0012CE  980710     MOV W0, [W14+2]
1574:                  ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
0012D0  90001E     MOV [W14+2], W0
0012D2  EB0080     CLR W1
0012D4  980071     MOV W1, [W0+14]
1575:              #if OS_TASK_NAME_EN > 0u
1576:                  ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
0012D6  285461     MOV #0x8546, W1
0012D8  90001E     MOV [W14+2], W0
0012DA  981851     MOV W1, [W0+58]
1577:              #endif
1578:                  OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
0012DC  EF287C     CLR OSTCBList
1579:                  OSTCBFreeList           = &OSTCBTbl[0];
0012DE  209DC0     MOV #0x9DC, W0
0012E0  8843C0     MOV W0, OSTCBFreeList
1580:              }
0012E2  FA8000     ULNK
0012E4  060000     RETURN
1581:              /*$PAGE*/
1582:              /*
1583:              *********************************************************************************************************
1584:              *                                      CLEAR A SECTION OF MEMORY
1585:              *
1586:              * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
1587:              *
1588:              * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
1589:              *
1590:              *              size     is the number of bytes to clear.
1591:              *
1592:              * Returns    : none
1593:              *
1594:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1595:              *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
1596:              *                 of the uses of this function gets close to this limit.
1597:              *              3) The clear is done one byte at a time since this will work on any processor irrespective
1598:              *                 of the alignment of the destination.
1599:              *********************************************************************************************************
1600:              */
1601:              
1602:              void  OS_MemClr (INT8U  *pdest,
1603:                               INT16U  size)
1604:              {
0012E6  FA0004     LNK #0x4
0012E8  780F00     MOV W0, [W14]
0012EA  980711     MOV W1, [W14+2]
1605:                  while (size > 0u) {
0012EC  370007     BRA 0x12FC
0012FC  90001E     MOV [W14+2], W0
0012FE  E00000     CP0 W0
001300  3AFFF6     BRA NZ, 0x12EE
1606:                      *pdest++ = (INT8U)0;
0012EE  78001E     MOV [W14], W0
0012F0  EB4080     CLR.B W1
0012F2  784801     MOV.B W1, [W0]
0012F4  E80F1E     INC [W14], [W14]
1607:                      size--;
0012F6  90001E     MOV [W14+2], W0
0012F8  E90000     DEC W0, W0
0012FA  980710     MOV W0, [W14+2]
1608:                  }
1609:              }
001302  FA8000     ULNK
001304  060000     RETURN
1610:              /*$PAGE*/
1611:              /*
1612:              *********************************************************************************************************
1613:              *                                       COPY A BLOCK OF MEMORY
1614:              *
1615:              * Description: This function is called by other uC/OS-II services to copy a block of memory from one
1616:              *              location to another.
1617:              *
1618:              * Arguments  : pdest    is a pointer to the 'destination' memory block
1619:              *
1620:              *              psrc     is a pointer to the 'source'      memory block
1621:              *
1622:              *              size     is the number of bytes to copy.
1623:              *
1624:              * Returns    : none
1625:              *
1626:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
1627:              *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
1628:              *                 is not a situation that will happen.
1629:              *              2) Note that we can only copy up to 64K bytes of RAM
1630:              *              3) The copy is done one byte at a time since this will work on any processor irrespective
1631:              *                 of the alignment of the source and destination.
1632:              *********************************************************************************************************
1633:              */
1634:              
1635:              void  OS_MemCopy (INT8U  *pdest,
1636:                                INT8U  *psrc,
1637:                                INT16U  size)
1638:              {
001306  FA0006     LNK #0x6
001308  780F00     MOV W0, [W14]
00130A  980711     MOV W1, [W14+2]
00130C  980722     MOV W2, [W14+4]
1639:                  while (size > 0u) {
00130E  37000B     BRA 0x1326
001326  90002E     MOV [W14+4], W0
001328  E00000     CP0 W0
00132A  3AFFF2     BRA NZ, 0x1310
1640:                      *pdest++ = *psrc++;
001310  90001E     MOV [W14+2], W0
001312  784090     MOV.B [W0], W1
001314  78001E     MOV [W14], W0
001316  784801     MOV.B W1, [W0]
001318  E80F1E     INC [W14], [W14]
00131A  90001E     MOV [W14+2], W0
00131C  E80000     INC W0, W0
00131E  980710     MOV W0, [W14+2]
1641:                      size--;
001320  90002E     MOV [W14+4], W0
001322  E90000     DEC W0, W0
001324  980720     MOV W0, [W14+4]
1642:                  }
1643:              }
00132C  FA8000     ULNK
00132E  060000     RETURN
1644:              /*$PAGE*/
1645:              /*
1646:              *********************************************************************************************************
1647:              *                                              SCHEDULER
1648:              *
1649:              * Description: This function is called by other uC/OS-II services to determine whether a new, high
1650:              *              priority task has been made ready to run.  This function is invoked by TASK level code
1651:              *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
1652:              *
1653:              * Arguments  : none
1654:              *
1655:              * Returns    : none
1656:              *
1657:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1658:              *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
1659:              *********************************************************************************************************
1660:              */
1661:              
1662:              void  OS_Sched (void)
1663:              {
001330  FA0002     LNK #0x2
1664:              #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
1665:                  OS_CPU_SR  cpu_sr = 0u;
001332  EB0000     CLR W0
001334  780F00     MOV W0, [W14]
1666:              #endif
1667:              
1668:              
1669:              
1670:                  OS_ENTER_CRITICAL();
001336  800211     MOV SR, W1
001338  780F01     MOV W1, [W14]
00133A  800211     MOV SR, W1
00133C  200E00     MOV #0xE0, W0
00133E  700001     IOR W0, W1, W0
001340  880210     MOV W0, SR
1671:                  if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
001342  BFC86B     MOV.B OSIntNesting, WREG
001344  E00400     CP0.B W0
001346  3A001E     BRA NZ, 0x1384
1672:                      if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
001348  BFC86C     MOV.B OSLockNesting, WREG
00134A  E00400     CP0.B W0
00134C  3A001B     BRA NZ, 0x1384
1673:                          OS_SchedNew();
00134E  07001E     RCALL _OS_SchedNew
1674:                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
001350  BFC86E     MOV.B OSPrioHighRdy, WREG
001352  FB8000     ZE W0, W0
001354  400080     ADD W0, W0, W1
001356  209C20     MOV #0x9C2, W0
001358  408000     ADD W1, W0, W0
00135A  780010     MOV [W0], W0
00135C  8843D0     MOV W0, OSTCBHighRdy
1675:                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00135E  2086E1     MOV #0x86E, W1
001360  784091     MOV.B [W1], W1
001362  BFC86D     MOV.B OSPrioCur, WREG
001364  50CF80     SUB.B W1, W0, [W15]
001366  32000E     BRA Z, 0x1384
1676:              #if OS_TASK_PROFILE_EN > 0u
1677:                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
001368  8043D2     MOV OSTCBHighRdy, W2
00136A  901042     MOV [W2+40], W0
00136C  9010D2     MOV [W2+42], W1
00136E  400061     ADD W0, #0x1, W0
001370  4880E0     ADDC W1, #0x0, W1
001372  981140     MOV W0, [W2+40]
001374  981151     MOV W1, [W2+42]
1678:              #endif
1679:                              OSCtxSwCtr++;                          /* Increment context switch counter             */
001376  804280     MOV OSCtxSwCtr, W0
001378  804291     MOV 0x852, W1
00137A  400061     ADD W0, #0x1, W0
00137C  4880E0     ADDC W1, #0x0, W1
00137E  884280     MOV W0, OSCtxSwCtr
001380  884291     MOV W1, 0x852
1680:              
1681:              #if OS_TASK_CREATE_EXT_EN > 0u
1682:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1683:                              OS_TLS_TaskSw();
1684:              #endif
1685:              #endif
1686:              
1687:                              OS_TASK_SW();                          /* Perform a context switch                     */
001382  072F10     RCALL 0x71A4
1688:                          }
1689:                      }
1690:                  }
1691:                  OS_EXIT_CRITICAL();
001384  78009E     MOV [W14], W1
001386  880211     MOV W1, SR
1692:              }
001388  FA8000     ULNK
00138A  060000     RETURN
1693:              
1694:              
1695:              /*
1696:              *********************************************************************************************************
1697:              *                               FIND HIGHEST PRIORITY TASK READY TO RUN
1698:              *
1699:              * Description: This function is called by other uC/OS-II services to determine the highest priority task
1700:              *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
1701:              *
1702:              * Arguments  : none
1703:              *
1704:              * Returns    : none
1705:              *
1706:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1707:              *              2) Interrupts are assumed to be disabled when this function is called.
1708:              *********************************************************************************************************
1709:              */
1710:              
1711:              static  void  OS_SchedNew (void)
1712:              {
00138C  FA0002     LNK #0x2
1713:              #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
1714:                  INT8U   y;
1715:              
1716:              
1717:                  y             = OSUnMapTbl[OSRdyGrp];
00138E  BFC86F     MOV.B OSRdyGrp, WREG
001390  FB8000     ZE W0, W0
001392  284461     MOV #0x8446, W1
001394  784F61     MOV.B [W1+W0], [W14]
1718:                  OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
001396  78409E     MOV.B [W14], W1
001398  200030     MOV #0x3, W0
00139A  DD0880     SL W1, W0, W1
00139C  FB801E     ZE [W14], W0
00139E  209402     MOV #0x940, W2
0013A0  784062     MOV.B [W2+W0], W0
0013A2  FB8000     ZE W0, W0
0013A4  284462     MOV #0x8446, W2
0013A6  784062     MOV.B [W2+W0], W0
0013A8  40C000     ADD.B W1, W0, W0
0013AA  B7E86E     MOV.B WREG, OSPrioHighRdy
1719:              #else                                            /* We support up to 256 tasks                         */
1720:                  INT8U     y;
1721:                  OS_PRIO  *ptbl;
1722:              
1723:              
1724:                  if ((OSRdyGrp & 0xFFu) != 0u) {
1725:                      y = OSUnMapTbl[OSRdyGrp & 0xFFu];
1726:                  } else {
1727:                      y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
1728:                  }
1729:                  ptbl = &OSRdyTbl[y];
1730:                  if ((*ptbl & 0xFFu) != 0u) {
1731:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
1732:                  } else {
1733:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
1734:                  }
1735:              #endif
1736:              }
0013AC  FA8000     ULNK
0013AE  060000     RETURN
1737:              
1738:              /*$PAGE*/
1739:              /*
1740:              *********************************************************************************************************
1741:              *                               DETERMINE THE LENGTH OF AN ASCII STRING
1742:              *
1743:              * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
1744:              *              (excluding the NUL character).
1745:              *
1746:              * Arguments  : psrc     is a pointer to the string for which we need to know the size.
1747:              *
1748:              * Returns    : The size of the string (excluding the NUL terminating character)
1749:              *
1750:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1751:              *              2) The string to check must be less than 255 characters long.
1752:              *********************************************************************************************************
1753:              */
1754:              
1755:              #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
1756:              INT8U  OS_StrLen (INT8U *psrc)
1757:              {
0013B0  FA0004     LNK #0x4
0013B2  980710     MOV W0, [W14+2]
1758:                  INT8U  len;
1759:              
1760:              
1761:              #if OS_ARG_CHK_EN > 0u
1762:                  if (psrc == (INT8U *)0) {
0013B4  90001E     MOV [W14+2], W0
0013B6  E00000     CP0 W0
0013B8  3A0002     BRA NZ, 0x13BE
1763:                      return (0u);
0013BA  EB4000     CLR.B W0
0013BC  37000C     BRA 0x13D6
1764:                  }
1765:              #endif
1766:              
1767:                  len = 0u;
0013BE  EB4000     CLR.B W0
0013C0  784F00     MOV.B W0, [W14]
1768:                  while (*psrc != OS_ASCII_NUL) {
0013C2  370004     BRA 0x13CC
0013CC  90001E     MOV [W14+2], W0
0013CE  784010     MOV.B [W0], W0
0013D0  E00400     CP0.B W0
0013D2  3AFFF8     BRA NZ, 0x13C4
1769:                      psrc++;
0013C4  90001E     MOV [W14+2], W0
0013C6  E80000     INC W0, W0
0013C8  980710     MOV W0, [W14+2]
1770:                      len++;
0013CA  E84F1E     INC.B [W14], [W14]
1771:                  }
1772:                  return (len);
0013D4  78401E     MOV.B [W14], W0
1773:              }
0013D6  FA8000     ULNK
0013D8  060000     RETURN
1774:              #endif
1775:              /*$PAGE*/
1776:              /*
1777:              *********************************************************************************************************
1778:              *                                              IDLE TASK
1779:              *
1780:              * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
1781:              *              executes because they are ALL waiting for event(s) to occur.
1782:              *
1783:              * Arguments  : none
1784:              *
1785:              * Returns    : none
1786:              *
1787:              * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
1788:              *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
1789:              *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
1790:              *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
1791:              *                 interrupts.
1792:              *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
1793:              *                 power.
1794:              *********************************************************************************************************
1795:              */
1796:              
1797:              void  OS_TaskIdle (void *p_arg)
1798:              {
0013DA  FA0004     LNK #0x4
0013DC  980710     MOV W0, [W14+2]
1799:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1800:                  OS_CPU_SR  cpu_sr = 0u;
0013DE  EB0000     CLR W0
0013E0  780F00     MOV W0, [W14]
1801:              #endif
1802:              
1803:              
1804:              
1805:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1806:                  for (;;) {
1807:                      OS_ENTER_CRITICAL();
0013E2  800211     MOV SR, W1
0013E4  780F01     MOV W1, [W14]
0013E6  800211     MOV SR, W1
0013E8  200E00     MOV #0xE0, W0
0013EA  700001     IOR W0, W1, W0
0013EC  880210     MOV W0, SR
1808:                      OSIdleCtr++;
0013EE  804390     MOV OSIdleCtr, W0
0013F0  8043A1     MOV 0x874, W1
0013F2  400061     ADD W0, #0x1, W0
0013F4  4880E0     ADDC W1, #0x0, W1
0013F6  884390     MOV W0, OSIdleCtr
0013F8  8843A1     MOV W1, 0x874
1809:                      OS_EXIT_CRITICAL();
0013FA  78009E     MOV [W14], W1
0013FC  880211     MOV W1, SR
1810:                      OSTaskIdleHook();                        /* Call user definable HOOK                           */
0013FE  072B57     RCALL OSTaskIdleHook
1811:                  }
001400  37FFF0     BRA 0x13E2
1812:              }
1813:              /*$PAGE*/
1814:              /*
1815:              *********************************************************************************************************
1816:              *                                           STATISTICS TASK
1817:              *
1818:              * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
1819:              *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
1820:              *              CPU usage is determined by:
1821:              *
1822:              *                                          OSIdleCtr
1823:              *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
1824:              *                                         OSIdleCtrMax
1825:              *
1826:              * Arguments  : parg     this pointer is not used at this time.
1827:              *
1828:              * Returns    : none
1829:              *
1830:              * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
1831:              *                 next higher priority, OS_TASK_IDLE_PRIO-1.
1832:              *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
1833:              *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
1834:              *                 maximum value for the idle counter.
1835:              *********************************************************************************************************
1836:              */
1837:              
1838:              #if OS_TASK_STAT_EN > 0u
1839:              void  OS_TaskStat (void *p_arg)
1840:              {
001402  FA0004     LNK #0x4
001404  980710     MOV W0, [W14+2]
1841:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1842:                  OS_CPU_SR  cpu_sr = 0u;
001406  EB0000     CLR W0
001408  780F00     MOV W0, [W14]
1843:              #endif
1844:              
1845:              
1846:              
1847:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1848:                  while (OSStatRdy == OS_FALSE) {
00140A  370003     BRA 0x1412
001412  BFC86A     MOV.B OSStatRdy, WREG
001414  E00400     CP0.B W0
001416  32FFFA     BRA Z, 0x140C
1849:                      OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
00140C  200C80     MOV #0xC8, W0
00140E  200001     MOV #0x0, W1
001410  072C07     RCALL OSTimeDly
1850:                  }
1851:                  OSIdleCtrMax /= 100uL;
001418  804310     MOV OSIdleCtrMax, W0
00141A  804321     MOV 0x864, W1
00141C  200642     MOV #0x64, W2
00141E  200003     MOV #0x0, W3
001420  07F7FF     RCALL 0x420
001422  884310     MOV W0, OSIdleCtrMax
001424  884321     MOV W1, 0x864
1852:                  if (OSIdleCtrMax == 0uL) {
001426  804310     MOV OSIdleCtrMax, W0
001428  804321     MOV 0x864, W1
00142A  500FE0     SUB W0, #0x0, [W15]
00142C  588FE0     SUBB W1, #0x0, [W15]
00142E  3A0003     BRA NZ, 0x1436
1853:                      OSCPUUsage = 0u;
001430  EF6860     CLR.B OSCPUUsage
1854:              #if OS_TASK_SUSPEND_EN > 0u
1855:                      (void)OSTaskSuspend(OS_PRIO_SELF);
001432  EBC000     SETM.B W0
001434  071203     RCALL OSTaskSuspend
1856:              #else
1857:                      for (;;) {
1858:                          OSTimeDly(OS_TICKS_PER_SEC);
1859:                      }
1860:              #endif
1861:                  }
1862:                  OS_ENTER_CRITICAL();
001436  800211     MOV SR, W1
001438  780F01     MOV W1, [W14]
00143A  800211     MOV SR, W1
00143C  200E00     MOV #0xE0, W0
00143E  700001     IOR W0, W1, W0
001440  880210     MOV W0, SR
1863:                  OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
001442  804310     MOV OSIdleCtrMax, W0
001444  804321     MOV 0x864, W1
001446  200642     MOV #0x64, W2
001448  B98902     MUL.SS W1, W2, W2
00144A  780102     MOV W2, W2
00144C  B90260     MUL.SU W0, #0, W4
00144E  780184     MOV W4, W3
001450  410103     ADD W2, W3, W2
001452  200643     MOV #0x64, W3
001454  B80003     MUL.UU W0, W3, W0
001456  410101     ADD W2, W1, W2
001458  780082     MOV W2, W1
00145A  884390     MOV W0, OSIdleCtr
00145C  8843A1     MOV W1, 0x874
1864:                  OS_EXIT_CRITICAL();
00145E  78009E     MOV [W14], W1
001460  880211     MOV W1, SR
1865:                  for (;;) {
1866:                      OS_ENTER_CRITICAL();
001462  800211     MOV SR, W1
001464  780F01     MOV W1, [W14]
001466  800211     MOV SR, W1
001468  200E00     MOV #0xE0, W0
00146A  700001     IOR W0, W1, W0
00146C  880210     MOV W0, SR
1867:                      OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00146E  804390     MOV OSIdleCtr, W0
001470  8043A1     MOV 0x874, W1
001472  884330     MOV W0, OSIdleCtrRun
001474  884341     MOV W1, 0x868
1868:                      OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
001476  EF2872     CLR OSIdleCtr
001478  EF2874     CLR 0x874
1869:                      OS_EXIT_CRITICAL();
00147A  78009E     MOV [W14], W1
00147C  880211     MOV W1, SR
1870:                      OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
00147E  804334     MOV OSIdleCtrRun, W4
001480  804345     MOV 0x868, W5
001482  804310     MOV OSIdleCtrMax, W0
001484  804321     MOV 0x864, W1
001486  BE0100     MOV.D W0, W2
001488  BE0004     MOV.D W4, W0
00148A  07F7CA     RCALL 0x420
00148C  784000     MOV.B W0, W0
00148E  B3C641     MOV.B #0x64, W1
001490  50C000     SUB.B W1, W0, W0
001492  B7E860     MOV.B WREG, OSCPUUsage
1871:                      OSTaskStatHook();                        /* Invoke user definable hook                         */
001494  072B13     RCALL OSTaskStatHook
1872:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1873:                      OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
001496  070004     RCALL OS_TaskStatStkChk
1874:              #endif
1875:                      OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
001498  200640     MOV #0x64, W0
00149A  200001     MOV #0x0, W1
00149C  072BC1     RCALL OSTimeDly
1876:                  }
00149E  37FFE1     BRA 0x1462
1877:              }
1878:              #endif
1879:              /*$PAGE*/
1880:              /*
1881:              *********************************************************************************************************
1882:              *                                        CHECK ALL TASK STACKS
1883:              *
1884:              * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
1885:              *
1886:              * Arguments  : none
1887:              *
1888:              * Returns    : none
1889:              *********************************************************************************************************
1890:              */
1891:              
1892:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1893:              void  OS_TaskStatStkChk (void)
1894:              {
0014A0  FA000C     LNK #0xC
1895:                  OS_TCB      *ptcb;
1896:                  OS_STK_DATA  stk_data;
1897:                  INT8U        err;
1898:                  INT8U        prio;
1899:              
1900:              
1901:                  for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
0014A2  EB4000     CLR.B W0
0014A4  784F00     MOV.B W0, [W14]
0014A6  370025     BRA 0x14F2
0014F0  E84F1E     INC.B [W14], [W14]
0014F2  78401E     MOV.B [W14], W0
0014F4  504FEC     SUB.B W0, #0xC, [W15]
0014F6  36FFD8     BRA LEU, 0x14A8
1902:                      err = OSTaskStkChk(prio, &stk_data);
0014A8  470064     ADD W14, #0x4, W0
0014AA  780080     MOV W0, W1
0014AC  78401E     MOV.B [W14], W0
0014AE  071155     RCALL OSTaskStkChk
0014B0  984710     MOV.B W0, [W14+1]
1903:                      if (err == OS_ERR_NONE) {
0014B2  90401E     MOV.B [W14+1], W0
0014B4  E00400     CP0.B W0
0014B6  3A001C     BRA NZ, 0x14F0
1904:                          ptcb = OSTCBPrioTbl[prio];
0014B8  FB801E     ZE [W14], W0
0014BA  400080     ADD W0, W0, W1
0014BC  209C20     MOV #0x9C2, W0
0014BE  408000     ADD W1, W0, W0
0014C0  780090     MOV [W0], W1
0014C2  980711     MOV W1, [W14+2]
1905:                          if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
0014C4  90001E     MOV [W14+2], W0
0014C6  E00000     CP0 W0
0014C8  320013     BRA Z, 0x14F0
1906:                              if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
0014CA  90001E     MOV [W14+2], W0
0014CC  500FE1     SUB W0, #0x1, [W15]
0014CE  320010     BRA Z, 0x14F0
1907:              #if OS_TASK_PROFILE_EN > 0u
1908:                                  #if OS_STK_GROWTH == 1u
1909:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
1910:                                  #else
1911:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
0014D0  90001E     MOV [W14+2], W0
0014D2  900120     MOV [W0+4], W2
0014D4  90001E     MOV [W14+2], W0
0014D6  9000C0     MOV [W0+8], W1
0014D8  900030     MOV [W0+6], W0
0014DA  780000     MOV W0, W0
0014DC  400000     ADD W0, W0, W0
0014DE  EA0000     NEG W0, W0
0014E0  410080     ADD W2, W0, W1
0014E2  90001E     MOV [W14+2], W0
0014E4  981821     MOV W1, [W0+52]
1912:                                  #endif
1913:                                  ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
0014E6  90004E     MOV [W14+8], W0
0014E8  9000DE     MOV [W14+10], W1
0014EA  90011E     MOV [W14+2], W2
0014EC  981930     MOV W0, [W2+54]
0014EE  981941     MOV W1, [W2+56]
1914:              #endif
1915:                              }
1916:                          }
1917:                      }
1918:                  }
1919:              }
0014F8  FA8000     ULNK
0014FA  060000     RETURN
1920:              #endif
1921:              /*$PAGE*/
1922:              /*
1923:              *********************************************************************************************************
1924:              *                                           INITIALIZE TCB
1925:              *
1926:              * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
1927:              *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
1928:              *
1929:              * Arguments  : prio          is the priority of the task being created
1930:              *
1931:              *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
1932:              *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
1933:              *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
1934:              *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
1935:              *                            specific.
1936:              *
1937:              *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
1938:              *                            'OSTaskCreate()'.
1939:              *
1940:              *              id            is the task's ID (0..65535)
1941:              *
1942:              *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
1943:              *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
1944:              *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
1945:              *                            units are established by the #define constant OS_STK which is CPU
1946:              *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
1947:              *
1948:              *              pext          is a pointer to a user supplied memory area that is used to extend the task
1949:              *                            control block.  This allows you to store the contents of floating-point
1950:              *                            registers, MMU registers or anything else you could find useful during a
1951:              *                            context switch.  You can even assign a name to each task and store this name
1952:              *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
1953:              *
1954:              *              opt           options as passed to 'OSTaskCreateExt()' or,
1955:              *                            0 if called from 'OSTaskCreate()'.
1956:              *
1957:              * Returns    : OS_ERR_NONE              if the call was successful
1958:              *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task
1959:              *                                       cannot be created.
1960:              *
1961:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1962:              *********************************************************************************************************
1963:              */
1964:              
1965:              INT8U  OS_TCBInit (INT8U    prio,
1966:                                 OS_STK  *ptos,
1967:                                 OS_STK  *pbos,
1968:                                 INT16U   id,
1969:                                 INT32U   stk_size,
1970:                                 void    *pext,
1971:                                 INT16U   opt)
1972:              {
0014FC  FA0016     LNK #0x16
0014FE  984760     MOV.B W0, [W14+6]
001500  980741     MOV W1, [W14+8]
001502  980752     MOV W2, [W14+10]
001504  980763     MOV W3, [W14+12]
001506  980774     MOV W4, [W14+14]
001508  980F05     MOV W5, [W14+16]
00150A  980F16     MOV W6, [W14+18]
00150C  980F27     MOV W7, [W14+20]
1973:                  OS_TCB    *ptcb;
1974:              #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
1975:                  OS_CPU_SR  cpu_sr = 0u;
00150E  EB0000     CLR W0
001510  980710     MOV W0, [W14+2]
1976:              #endif
1977:              #if OS_TASK_REG_TBL_SIZE > 0u
1978:                  INT8U      i;
1979:              #endif
1980:              #if OS_TASK_CREATE_EXT_EN > 0u
1981:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1982:                  INT8U      j;
1983:              #endif
1984:              #endif
1985:              
1986:              
1987:                  OS_ENTER_CRITICAL();
001512  800211     MOV SR, W1
001514  980711     MOV W1, [W14+2]
001516  800211     MOV SR, W1
001518  200E00     MOV #0xE0, W0
00151A  700001     IOR W0, W1, W0
00151C  880210     MOV W0, SR
1988:                  ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00151E  8043C2     MOV OSTCBFreeList, W2
001520  980722     MOV W2, [W14+4]
1989:                  if (ptcb != (OS_TCB *)0) {
001522  90002E     MOV [W14+4], W0
001524  E00000     CP0 W0
001526  3200BF     BRA Z, 0x16A6
1990:                      OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
001528  90002E     MOV [W14+4], W0
00152A  900070     MOV [W0+14], W0
00152C  8843C0     MOV W0, OSTCBFreeList
1991:                      OS_EXIT_CRITICAL();
00152E  90019E     MOV [W14+2], W3
001530  880213     MOV W3, SR
1992:                      ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
001532  90002E     MOV [W14+4], W0
001534  9000CE     MOV [W14+8], W1
001536  780801     MOV W1, [W0]
1993:                      ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
001538  90002E     MOV [W14+4], W0
00153A  90416E     MOV.B [W14+6], W2
00153C  986022     MOV.B W2, [W0+34]
1994:                      ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00153E  90002E     MOV [W14+4], W0
001540  EB4080     CLR.B W1
001542  986001     MOV.B W1, [W0+32]
1995:                      ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
001544  90002E     MOV [W14+4], W0
001546  EB4080     CLR.B W1
001548  986011     MOV.B W1, [W0+33]
1996:                      ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00154A  90012E     MOV [W14+4], W2
00154C  B80060     MUL.UU W0, #0, W0
00154E  980960     MOV W0, [W2+28]
001550  980971     MOV W1, [W2+30]
1997:              
1998:              #if OS_TASK_CREATE_EXT_EN > 0u
1999:                      ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
001552  90002E     MOV [W14+4], W0
001554  90099E     MOV [W14+18], W3
001556  980013     MOV W3, [W0+2]
2000:                      ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
001558  90002E     MOV [W14+4], W0
00155A  90017E     MOV [W14+14], W2
00155C  90098E     MOV [W14+16], W3
00155E  980032     MOV W2, [W0+6]
001560  980043     MOV W3, [W0+8]
2001:                      ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
001562  90002E     MOV [W14+4], W0
001564  9001DE     MOV [W14+10], W3
001566  980023     MOV W3, [W0+4]
2002:                      ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
001568  90002E     MOV [W14+4], W0
00156A  9008AE     MOV [W14+20], W1
00156C  980051     MOV W1, [W0+10]
2003:                      ptcb->OSTCBId            = id;                     /* Store task ID                            */
00156E  90002E     MOV [W14+4], W0
001570  90016E     MOV [W14+12], W2
001572  980062     MOV W2, [W0+12]
2004:              #else
2005:                      pext                     = pext;                   /* Prevent compiler warning if not used     */
2006:                      stk_size                 = stk_size;
2007:                      pbos                     = pbos;
2008:                      opt                      = opt;
2009:                      id                       = id;
2010:              #endif
2011:              
2012:              #if OS_TASK_DEL_EN > 0u
2013:                      ptcb->OSTCBDelReq        = OS_ERR_NONE;
001574  90002E     MOV [W14+4], W0
001576  EB4080     CLR.B W1
001578  986071     MOV.B W1, [W0+39]
2014:              #endif
2015:              
2016:              #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
2017:                      ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00157A  90406E     MOV.B [W14+6], W0
00157C  FB8000     ZE W0, W0
00157E  DE0043     LSR W0, #3, W0
001580  784080     MOV.B W0, W1
001582  90002E     MOV [W14+4], W0
001584  986041     MOV.B W1, [W0+36]
2018:                      ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
001586  90406E     MOV.B [W14+6], W0
001588  6040E7     AND.B W0, #0x7, W1
00158A  90002E     MOV [W14+4], W0
00158C  986031     MOV.B W1, [W0+35]
2019:              #else                                                             /* Pre-compute X, Y                  */
2020:                      ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
2021:                      ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
2022:              #endif
2023:                                                                                /* Pre-compute BitX and BitY         */
2024:                      ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
00158E  90002E     MOV [W14+4], W0
001590  906040     MOV.B [W0+36], W0
001592  FB8100     ZE W0, W2
001594  200010     MOV #0x1, W0
001596  200001     MOV #0x0, W1
001598  780182     MOV W2, W3
00159A  E90183     DEC W3, W3
00159C  330003     BRA N, 0x15A4
00159E  400000     ADD W0, W0, W0
0015A0  488081     ADDC W1, W1, W1
0015A2  37FFFB     BRA 0x159A
0015A4  784080     MOV.B W0, W1
0015A6  90002E     MOV [W14+4], W0
0015A8  986061     MOV.B W1, [W0+38]
2025:                      ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
0015AA  90002E     MOV [W14+4], W0
0015AC  906030     MOV.B [W0+35], W0
0015AE  FB8100     ZE W0, W2
0015B0  200010     MOV #0x1, W0
0015B2  200001     MOV #0x0, W1
0015B4  780182     MOV W2, W3
0015B6  E90183     DEC W3, W3
0015B8  330003     BRA N, 0x15C0
0015BA  400000     ADD W0, W0, W0
0015BC  488081     ADDC W1, W1, W1
0015BE  37FFFB     BRA 0x15B6
0015C0  784080     MOV.B W0, W1
0015C2  90002E     MOV [W14+4], W0
0015C4  986051     MOV.B W1, [W0+37]
2026:              
2027:              #if (OS_EVENT_EN)
2028:                      ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
0015C6  90002E     MOV [W14+4], W0
0015C8  EB0080     CLR W1
0015CA  980811     MOV W1, [W0+18]
2029:              #if (OS_EVENT_MULTI_EN > 0u)
2030:                      ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
0015CC  90002E     MOV [W14+4], W0
0015CE  EB0080     CLR W1
0015D0  980821     MOV W1, [W0+20]
2031:              #endif
2032:              #endif
2033:              
2034:              #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
2035:                      ptcb->OSTCBFlagNode      = (OS_FLAG_NODE *)0;      /* Task is not pending on an event flag     */
0015D2  90002E     MOV [W14+4], W0
0015D4  EB0080     CLR W1
0015D6  980841     MOV W1, [W0+24]
2036:              #endif
2037:              
2038:              #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
2039:                      ptcb->OSTCBMsg           = (void *)0;              /* No message received                      */
0015D8  90002E     MOV [W14+4], W0
0015DA  EB0080     CLR W1
0015DC  980831     MOV W1, [W0+22]
2040:              #endif
2041:              
2042:              #if OS_TASK_PROFILE_EN > 0u
2043:                      ptcb->OSTCBCtxSwCtr      = 0uL;                    /* Initialize profiling variables           */
0015DE  90012E     MOV [W14+4], W2
0015E0  B80060     MUL.UU W0, #0, W0
0015E2  981140     MOV W0, [W2+40]
0015E4  981151     MOV W1, [W2+42]
2044:                      ptcb->OSTCBCyclesStart   = 0uL;
0015E6  90012E     MOV [W14+4], W2
0015E8  B80060     MUL.UU W0, #0, W0
0015EA  981900     MOV W0, [W2+48]
0015EC  981911     MOV W1, [W2+50]
2045:                      ptcb->OSTCBCyclesTot     = 0uL;
0015EE  90012E     MOV [W14+4], W2
0015F0  B80060     MUL.UU W0, #0, W0
0015F2  981160     MOV W0, [W2+44]
0015F4  981171     MOV W1, [W2+46]
2046:                      ptcb->OSTCBStkBase       = (OS_STK *)0;
0015F6  90002E     MOV [W14+4], W0
0015F8  EB0080     CLR W1
0015FA  981821     MOV W1, [W0+52]
2047:                      ptcb->OSTCBStkUsed       = 0uL;
0015FC  90012E     MOV [W14+4], W2
0015FE  B80060     MUL.UU W0, #0, W0
001600  981930     MOV W0, [W2+54]
001602  981941     MOV W1, [W2+56]
2048:              #endif
2049:              
2050:              #if OS_TASK_NAME_EN > 0u
2051:                      ptcb->OSTCBTaskName      = (INT8U *)(void *)"?";
001604  285461     MOV #0x8546, W1
001606  90002E     MOV [W14+4], W0
001608  981851     MOV W1, [W0+58]
2052:              #endif
2053:              
2054:              #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
2055:                      for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00160A  EB4000     CLR.B W0
00160C  784F00     MOV.B W0, [W14]
00160E  370008     BRA 0x1620
00161E  E84F1E     INC.B [W14], [W14]
001620  78401E     MOV.B [W14], W0
001622  E00400     CP0.B W0
001624  32FFF5     BRA Z, 0x1610
2056:                          ptcb->OSTCBRegTbl[i] = 0u;
001610  FB801E     ZE [W14], W0
001612  9000AE     MOV [W14+4], W1
001614  40006F     ADD W0, #0xF, W0
001616  DD0042     SL W0, #2, W0
001618  408100     ADD W1, W0, W2
00161A  B80060     MUL.UU W0, #0, W0
00161C  BE8900     MOV.D W0, [W2]
2057:                      }
2058:              #endif
2059:              
2060:                      OSTCBInitHook(ptcb);
001626  90002E     MOV [W14+4], W0
001628  072A4F     RCALL OSTCBInitHook
2061:              
2062:                      OS_ENTER_CRITICAL();
00162A  800211     MOV SR, W1
00162C  980711     MOV W1, [W14+2]
00162E  800211     MOV SR, W1
001630  200E00     MOV #0xE0, W0
001632  700001     IOR W0, W1, W0
001634  880210     MOV W0, SR
2063:                      OSTCBPrioTbl[prio] = ptcb;
001636  90406E     MOV.B [W14+6], W0
001638  FB8000     ZE W0, W0
00163A  400080     ADD W0, W0, W1
00163C  209C20     MOV #0x9C2, W0
00163E  408000     ADD W1, W0, W0
001640  90012E     MOV [W14+4], W2
001642  780802     MOV W2, [W0]
2064:                      OS_EXIT_CRITICAL();
001644  90019E     MOV [W14+2], W3
001646  880213     MOV W3, SR
2065:              
2066:                      OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
001648  90002E     MOV [W14+4], W0
00164A  072A29     RCALL OSTaskCreateHook
2067:              
2068:              #if OS_TASK_CREATE_EXT_EN > 0u
2069:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
2070:                      for (j = 0u; j < OS_TLS_TBL_SIZE; j++) {
2071:                          ptcb->OSTCBTLSTbl[j] = (OS_TLS)0;
2072:                      }
2073:                      OS_TLS_TaskCreate(ptcb);                           /* Call TLS hook                            */
2074:              #endif
2075:              #endif
2076:              
2077:                      OS_ENTER_CRITICAL();
00164C  800211     MOV SR, W1
00164E  980711     MOV W1, [W14+2]
001650  800211     MOV SR, W1
001652  200E00     MOV #0xE0, W0
001654  700001     IOR W0, W1, W0
001656  880210     MOV W0, SR
2078:                      ptcb->OSTCBNext = OSTCBList;                       /* Link into TCB chain                      */
001658  8043E1     MOV OSTCBList, W1
00165A  90002E     MOV [W14+4], W0
00165C  980071     MOV W1, [W0+14]
2079:                      ptcb->OSTCBPrev = (OS_TCB *)0;         
00165E  90002E     MOV [W14+4], W0
001660  EB0080     CLR W1
001662  980801     MOV W1, [W0+16]
2080:                      if (OSTCBList != (OS_TCB *)0) {
001664  8043E0     MOV OSTCBList, W0
001666  E00000     CP0 W0
001668  320003     BRA Z, 0x1670
2081:                          OSTCBList->OSTCBPrev = ptcb;
00166A  8043E0     MOV OSTCBList, W0
00166C  90012E     MOV [W14+4], W2
00166E  980802     MOV W2, [W0+16]
2082:                      }
2083:                      OSTCBList               = ptcb;
001670  9001AE     MOV [W14+4], W3
001672  8843E3     MOV W3, OSTCBList
2084:                      OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
001674  90002E     MOV [W14+4], W0
001676  9060E0     MOV.B [W0+38], W1
001678  BFC86F     MOV.B OSRdyGrp, WREG
00167A  70C000     IOR.B W1, W0, W0
00167C  B7E86F     MOV.B WREG, OSRdyGrp
2085:                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00167E  90002E     MOV [W14+4], W0
001680  906040     MOV.B [W0+36], W0
001682  FB8000     ZE W0, W0
001684  9000AE     MOV [W14+4], W1
001686  9060C1     MOV.B [W1+36], W1
001688  FB8081     ZE W1, W1
00168A  209402     MOV #0x940, W2
00168C  78C162     MOV.B [W2+W1], W2
00168E  9000AE     MOV [W14+4], W1
001690  9060D1     MOV.B [W1+37], W1
001692  714101     IOR.B W2, W1, W2
001694  209401     MOV #0x940, W1
001696  787082     MOV.B W2, [W1+W0]
2086:                      OSTaskCtr++;                                       /* Increment the #tasks counter             */
001698  BFC871     MOV.B OSTaskCtr, WREG
00169A  E84000     INC.B W0, W0
00169C  B7E871     MOV.B WREG, OSTaskCtr
2087:                      OS_EXIT_CRITICAL();
00169E  90009E     MOV [W14+2], W1
0016A0  880211     MOV W1, SR
2088:                      return (OS_ERR_NONE);
0016A2  EB4000     CLR.B W0
0016A4  370003     BRA 0x16AC
2089:                  }
2090:                  OS_EXIT_CRITICAL();
0016A6  90011E     MOV [W14+2], W2
0016A8  880212     MOV W2, SR
2091:                  return (OS_ERR_TASK_NO_MORE_TCB);
0016AA  B3C420     MOV.B #0x42, W0
2092:              }
0016AC  FA8000     ULNK
2093:              
2094:              
2095:              
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Ports/os_cpu_c.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                               uC/OS-II
4:                 *                                         The Real-Time Kernel
5:                 *
6:                 *                               (c) Copyright 2006, Micrium, Weston, FL
7:                 *                                          All Rights Reserved
8:                 *
9:                 *
10:                *                                          dsPIC33/PIC24 MPLab Port
11:                *
12:                *
13:                * File         : OS_CPU_C.C
14:                * By           : Eric Shufro
15:                * Port Version : V2.81 (and higher)
16:                *********************************************************************************************************
17:                */
18:                
19:                #include  "uCOS_II.H"
20:                
21:                /*
22:                *********************************************************************************************************
23:                *                                             LOCALS
24:                *********************************************************************************************************
25:                */
26:                
27:                #if OS_TMR_EN > 0
28:                static  INT16U  OSTmrCtr;
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                       OS INITIALIZATION HOOK
34:                *                                            (BEGINNING)
35:                *
36:                * Description: This function is called by OSInit() at the beginning of OSInit().
37:                *
38:                * Arguments  : none
39:                *
40:                * Note(s)    : 1) Interrupts should be disabled during this call.
41:                *********************************************************************************************************
42:                */
43:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
44:                void  OSInitHookBegin (void)
45:                {
006A8E  FA0000     LNK #0x0
46:                #if OS_TMR_EN > 0
47:                    OSTmrCtr =      0;
48:                #endif
49:                
50:                    SPLIM    = 0xFFFE;                                                  /* Initialize the stack pointer limit register to a maximum */
006A90  2FFFE0     MOV #0xFFFE, W0
006A92  880100     MOV W0, SPLIM
51:                }                                                                       /* address thus effectively disabling stack checking        */
006A94  FA8000     ULNK
006A96  060000     RETURN
52:                #endif
53:                
54:                /*
55:                *********************************************************************************************************
56:                *                                       OS INITIALIZATION HOOK
57:                *                                               (END)
58:                *
59:                * Description: This function is called by OSInit() at the end of OSInit().
60:                *
61:                * Arguments  : none
62:                *
63:                * Note(s)    : 1) Interrupts should be disabled during this call.
64:                *********************************************************************************************************
65:                */
66:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
67:                void  OSInitHookEnd (void)
68:                {
006A98  FA0000     LNK #0x0
69:                #if OS_CPU_INT_DIS_MEAS_EN > 0
70:                    OS_CPU_IntDisMeasInit();
71:                #endif
72:                }
006A9A  FA8000     ULNK
006A9C  060000     RETURN
73:                #endif
74:                
75:                /*$PAGE*/
76:                /*
77:                *********************************************************************************************************
78:                *                                          TASK CREATION HOOK
79:                *
80:                * Description: This function is called when a task is created.
81:                *
82:                * Arguments  : ptcb   is a pointer to the task control block of the task being created.
83:                *
84:                * Note(s)    : 1) Interrupts are disabled during this call.
85:                *********************************************************************************************************
86:                */
87:                #if OS_CPU_HOOKS_EN > 0
88:                void  OSTaskCreateHook (OS_TCB *ptcb)
89:                {
006A9E  FA0002     LNK #0x2
006AA0  780F00     MOV W0, [W14]
90:                #if OS_APP_HOOKS_EN > 0
91:                    App_TaskCreateHook(ptcb);
92:                #else
93:                    (void)ptcb;                                                         /* Prevent compiler warning                                 */
94:                #endif
95:                }
006AA2  FA8000     ULNK
006AA4  060000     RETURN
96:                #endif
97:                
98:                /*
99:                *********************************************************************************************************
100:               *                                           TASK DELETION HOOK
101:               *
102:               * Description: This function is called when a task is deleted.
103:               *
104:               * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
105:               *
106:               * Note(s)    : 1) Interrupts are disabled during this call.
107:               *********************************************************************************************************
108:               */
109:               #if OS_CPU_HOOKS_EN > 0
110:               void  OSTaskDelHook (OS_TCB *ptcb)
111:               {
006AA6  FA0002     LNK #0x2
006AA8  780F00     MOV W0, [W14]
112:               #if OS_APP_HOOKS_EN > 0
113:                   App_TaskDelHook(ptcb);
114:               #else
115:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
116:               #endif
117:               }
006AAA  FA8000     ULNK
006AAC  060000     RETURN
118:               #endif
119:               
120:               /*
121:               *********************************************************************************************************
122:               *                                             IDLE TASK HOOK
123:               *
124:               * Description: This function is called by the idle task.  This hook has been added to allow you to do
125:               *              such things as STOP the CPU to conserve power.
126:               *
127:               * Arguments  : none
128:               *
129:               * Note(s)    : 1) Interrupts are enabled during this call.
130:               *********************************************************************************************************
131:               */
132:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
133:               void  OSTaskIdleHook (void)
134:               {
006AAE  FA0000     LNK #0x0
135:               #if OS_APP_HOOKS_EN > 0
136:                   App_TaskIdleHook();
137:               #endif
138:               }
006AB0  FA8000     ULNK
006AB2  060000     RETURN
139:               #endif
140:               
141:               /*
142:               *********************************************************************************************************
143:               *                                            TASK RETURN HOOK
144:               *
145:               * Description: This function is called if a task accidentally returns.  In other words, a task should
146:               *              either be an infinite loop or delete itself when done.
147:               *
148:               * Arguments  : ptcb      is a pointer to the task control block of the task that is returning.
149:               *
150:               * Note(s)    : none
151:               *********************************************************************************************************
152:               */
153:               
154:               #if OS_CPU_HOOKS_EN > 0u
155:               void  OSTaskReturnHook (OS_TCB  *ptcb)
156:               {
006AB4  FA0002     LNK #0x2
006AB6  780F00     MOV W0, [W14]
157:               #if OS_APP_HOOKS_EN > 0u
158:                   App_TaskReturnHook(ptcb);
159:               #else
160:                   (void)ptcb;
161:               #endif
162:               }
006AB8  FA8000     ULNK
006ABA  060000     RETURN
163:               #endif
164:               /*
165:               *********************************************************************************************************
166:               *                                           STATISTIC TASK HOOK
167:               *
168:               * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
169:               *              application to add functionality to the statistics task.
170:               *
171:               * Arguments  : none
172:               *********************************************************************************************************
173:               */
174:               
175:               #if OS_CPU_HOOKS_EN > 0
176:               void  OSTaskStatHook (void)
177:               {
006ABC  FA0000     LNK #0x0
178:               #if OS_APP_HOOKS_EN > 0
179:                   App_TaskStatHook();
180:               #endif
181:               }
006ABE  FA8000     ULNK
006AC0  060000     RETURN
182:               #endif
183:               
184:               /*$PAGE*/
185:               /*
186:               *********************************************************************************************************
187:               *                                           TASK SWITCH HOOK
188:               *
189:               * Description: This function is called when a task switch is performed.  This allows you to perform other
190:               *              operations during a context switch.
191:               *
192:               * Arguments  : none
193:               *
194:               * Note(s)    : 1) Interrupts are disabled during this call.
195:               *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
196:               *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
197:               *                 task being switched out (i.e. the preempted task).
198:               *********************************************************************************************************
199:               */
200:               #if OS_CPU_HOOKS_EN > 0
201:               void  OSTaskSwHook (void)
202:               {
006AC2  FA0000     LNK #0x0
203:               #if OS_APP_HOOKS_EN > 0
204:                   App_TaskSwHook();
205:               #endif
206:               }
006AC4  FA8000     ULNK
006AC6  060000     RETURN
207:               #endif
208:               
209:               /*
210:               *********************************************************************************************************
211:               *                                           OSTCBInit() HOOK
212:               *
213:               * Description: This function is called by OS_TCBInit() after setting up most of the TCB.
214:               *
215:               * Arguments  : ptcb    is a pointer to the TCB of the task being created.
216:               *
217:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
218:               *********************************************************************************************************
219:               */
220:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
221:               void  OSTCBInitHook (OS_TCB *ptcb)
222:               {
006AC8  FA0002     LNK #0x2
006ACA  780F00     MOV W0, [W14]
223:               #if OS_APP_HOOKS_EN > 0
224:                   App_TCBInitHook(ptcb);
225:               #else
226:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
227:               #endif
228:               }
006ACC  FA8000     ULNK
006ACE  060000     RETURN
229:               #endif
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                               TICK HOOK
234:               *
235:               * Description: This function is called every tick.
236:               *
237:               * Arguments  : none
238:               *
239:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
240:               *********************************************************************************************************
241:               */
242:               #if (OS_CPU_HOOKS_EN > 0) && (OS_TIME_TICK_HOOK_EN > 0)
243:               void  OSTimeTickHook (void)
244:               {
245:               #if OS_APP_HOOKS_EN > 0
246:                   App_TimeTickHook();
247:               #endif
248:               
249:               #if OS_TMR_EN > 0
250:                   OSTmrCtr++;
251:                   if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
252:                       OSTmrCtr = 0;
253:                       OSTmrSignal();
254:                   }
255:               #endif
256:               }
257:               #endif
258:               
259:               /*
260:               *********************************************************************************************************
261:               *                             INTERRUPT DISABLE TIME MEASUREMENT, START
262:               *********************************************************************************************************
263:               */
264:               
265:               #if OS_CPU_INT_DIS_MEAS_EN > 0u
266:               void  OS_CPU_IntDisMeasInit (void)
267:               {
268:                   OS_CPU_IntDisMeasNestingCtr = 0u;
269:                   OS_CPU_IntDisMeasCntsEnter  = 0u;
270:                   OS_CPU_IntDisMeasCntsExit   = 0u;
271:                   OS_CPU_IntDisMeasCntsMax    = 0u;
272:                   OS_CPU_IntDisMeasCntsDelta  = 0u;
273:                   OS_CPU_IntDisMeasCntsOvrhd  = 0u;
274:                   OS_CPU_IntDisMeasStart();                              /* Measure the overhead of the functions    */
275:                   OS_CPU_IntDisMeasStop();
276:                   OS_CPU_IntDisMeasCntsOvrhd  = OS_CPU_IntDisMeasCntsDelta;
277:               }
278:               
279:               
280:               void  OS_CPU_IntDisMeasStart (void)
281:               {
282:                   OS_CPU_IntDisMeasNestingCtr++;
283:                   if (OS_CPU_IntDisMeasNestingCtr == 1u) {               /* Only measure at the first nested level   */
284:                       OS_CPU_IntDisMeasCntsEnter = OS_CPU_IntDisMeasTmrRd();
285:                   }
286:               }
287:               
288:               
289:               void  OS_CPU_IntDisMeasStop (void)
290:               {
291:                   OS_CPU_IntDisMeasNestingCtr--;                                      /* Decrement nesting ctr       */
292:                   if (OS_CPU_IntDisMeasNestingCtr == 0u) {
293:                       OS_CPU_IntDisMeasCntsExit  = OS_CPU_IntDisMeasTmrRd();
294:                       OS_CPU_IntDisMeasCntsDelta = OS_CPU_IntDisMeasCntsExit - OS_CPU_IntDisMeasCntsEnter;
295:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsOvrhd) {  /* Ensure overhead < delta     */
296:                           OS_CPU_IntDisMeasCntsDelta -= OS_CPU_IntDisMeasCntsOvrhd;
297:                       } else {
298:                           OS_CPU_IntDisMeasCntsDelta  = OS_CPU_IntDisMeasCntsOvrhd;
299:                       }
300:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsMax) {    /* Track MAXIMUM               */
301:                           OS_CPU_IntDisMeasCntsMax = OS_CPU_IntDisMeasCntsDelta;
302:                       }
303:                   }
304:               }
305:               #endif
306:               /*$PAGE*/
307:               /*
308:               *********************************************************************************************************
309:               *                                        INITIALIZE A TASK'S STACK
310:               *
311:               * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
312:               *              stack frame of the task being created.  This function is highly processor specific.
313:               *
314:               * Arguments  : task          is a pointer to the task code
315:               *
316:               *              p_arg         is a pointer to a user supplied data area that will be passed to the task
317:               *                            when the task first executes.
318:               *
319:               *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
320:               *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
321:               *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
322:               *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
323:               *                            of the stack.
324:               *
325:               *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
326:               *                            (see uCOS_II.H for OS_TASK_OPT_???).
327:               *
328:               * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
329:               *              been placed on the stack in the proper order.
330:               *
331:               * Note(s)    : 1) You may pass a task creation parameters through the opt variable. You MUST only use the
332:               *                 upper 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make
333:               *                 changes to the code below, you will need to ensure that it doesn't affect the behaviour
334:               *                 of OSTaskIdle() and OSTaskStat().
335:               *              2) Registers are initialized to make them easy to differentiate with a debugger.
336:               *
337:               *              3) Setup the stack frame of the task:
338:               *
339:               *                        ptos -  0  ->
340:               *                        ptos -  2  ->  CORCON
341:               *                        ptos -  4  ->  SR (initialized to 0)
342:               *                        ptos -  6  ->  DOENDH
343:               *                        ptos -  8  ->  DOENDL
344:               *                        ptos - 10  ->  DOSTARTH
345:               *                        ptos - 12  ->  DOSTARTL
346:               *                        ptos - 14  ->  DCOUNT
347:               *                        ptos - 16  ->  RCOUNT
348:               *                        ptos - 18  ->  PSVPAG
349:               *                        ptos - 20  ->  TBLPAG
350:               *                        ptos - 22  ->  ACCBU
351:               *                        ptos - 24  ->  ACCBH
352:               *                        ptos - 26  ->  ACCBL
353:               *                        ptos - 28  ->  ACCAU
354:               *                        ptos - 30  ->  ACCAH
355:               *                        ptos - 32  ->  ACCAL
356:               *                        ptos - 34  ->  W14
357:               *                        ptos - 36  ->  W13
358:               *                        ptos - 38  ->  W12
359:               *                        ptos - 40  ->  W11
360:               *                        ptos - 42  ->  W10
361:               *                        ptos - 44  ->  W9
362:               *                        ptos - 46  ->  W8
363:               *                        ptos - 48  ->  W7
364:               *                        ptos - 50  ->  W6
365:               *                        ptos - 52  ->  W5
366:               *                        ptos - 54  ->  W4
367:               *                        ptos - 56  ->  W3
368:               *                        ptos - 58  ->  W2
369:               *                        ptos - 60  ->  W1
370:               *                        ptos - 62  ->  p_arg
371:               *                        ptos - 64  ->   0 (15..8) | CORCON.7 | PC (22..16)      Simulate ISR
372:               *                        ptos - 66  ->  PC (15..0)
373:               *                        ptos - 68  ->  PC (22..16)                              Simulate function call
374:               *                        ptos - 70  ->  PC (15..0)
375:               *********************************************************************************************************
376:               */
377:               
378:               OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
379:               {
006AD0  FA000C     LNK #0xC
006AD2  980720     MOV W0, [W14+4]
006AD4  980731     MOV W1, [W14+6]
006AD6  980742     MOV W2, [W14+8]
006AD8  980753     MOV W3, [W14+10]
380:                   INT16U  x;
381:                   INT16U   pc_high;
382:               
383:               
384:               	pc_high =   0;                                                      /* Upper byte of PC always 0. Pointers are 16 bit unsigned  */
006ADA  EB0000     CLR W0
006ADC  980710     MOV W0, [W14+2]
385:               
386:                  *ptos++  =  (OS_STK)task;                                            /* Simulate a call to the task by putting 32 bits of data   */
006ADE  9000AE     MOV [W14+4], W1
006AE0  90004E     MOV [W14+8], W0
006AE2  780801     MOV W1, [W0]
006AE4  90004E     MOV [W14+8], W0
006AE6  E88000     INC2 W0, W0
006AE8  980740     MOV W0, [W14+8]
387:                  *ptos++  =  (OS_STK)pc_high;                                         /* data on the stack.                                       */
006AEA  90004E     MOV [W14+8], W0
006AEC  90009E     MOV [W14+2], W1
006AEE  780801     MOV W1, [W0]
006AF0  90004E     MOV [W14+8], W0
006AF2  E88000     INC2 W0, W0
006AF4  980740     MOV W0, [W14+8]
388:               
389:                                                                                       /* Simulate an interrupt                                    */
390:                  *ptos++  =  (OS_STK)task;                                            /* Put the address of this task on the stack (PC)           */
006AF6  9000AE     MOV [W14+4], W1
006AF8  90004E     MOV [W14+8], W0
006AFA  780801     MOV W1, [W0]
006AFC  90004E     MOV [W14+8], W0
006AFE  E88000     INC2 W0, W0
006B00  980740     MOV W0, [W14+8]
391:               
392:                   x       =  0;                                                       /* Set the SR to enable ALL interrupts                      */
006B02  EB0000     CLR W0
006B04  780F00     MOV W0, [W14]
393:                   if (CORCONbits.IPL3) {                                              /* Check the CPU's current interrupt level 3 bit            */
006B06  800220     MOV CORCON, W0
006B08  600068     AND W0, #0x8, W0
006B0A  E00000     CP0 W0
006B0C  320001     BRA Z, 0x6B10
394:                       x  |= 0x0080;                                                   /* If set, then save the priority level bit in x bit [7]    */
006B0E  A0701E     BSET [W14], #7
395:                   }
396:                  *ptos++  = (OS_STK)(x | (INT16U)pc_high);                            /* Push the SR Low, CORCON IPL3 and PC (22..16)             */
006B10  90001E     MOV [W14+2], W0
006B12  70009E     IOR W0, [W14], W1
006B14  90004E     MOV [W14+8], W0
006B16  780801     MOV W1, [W0]
006B18  90004E     MOV [W14+8], W0
006B1A  E88000     INC2 W0, W0
006B1C  980740     MOV W0, [W14+8]
397:               
398:                                                                                       /* Push all of the registers to stack                       */
399:                  *ptos++  = (OS_STK)p_arg;                                            /* Register W0 holds data passed to the task when started   */
006B1E  9000BE     MOV [W14+6], W1
006B20  90004E     MOV [W14+8], W0
006B22  780801     MOV W1, [W0]
006B24  90004E     MOV [W14+8], W0
006B26  E88000     INC2 W0, W0
006B28  980740     MOV W0, [W14+8]
400:                  *ptos++  = 0x1111;                                                   /* Initialize register W1                                   */
006B2A  90004E     MOV [W14+8], W0
006B2C  211111     MOV #0x1111, W1
006B2E  780801     MOV W1, [W0]
006B30  90004E     MOV [W14+8], W0
006B32  E88000     INC2 W0, W0
006B34  980740     MOV W0, [W14+8]
401:                  *ptos++  = 0x2222;                                                   /* Initialize register W2                                   */
006B36  90004E     MOV [W14+8], W0
006B38  222221     MOV #0x2222, W1
006B3A  780801     MOV W1, [W0]
006B3C  90004E     MOV [W14+8], W0
006B3E  E88000     INC2 W0, W0
006B40  980740     MOV W0, [W14+8]
402:                  *ptos++  = 0x3333;                                                   /* Initialize register W3                                   */
006B42  90004E     MOV [W14+8], W0
006B44  233331     MOV #0x3333, W1
006B46  780801     MOV W1, [W0]
006B48  90004E     MOV [W14+8], W0
006B4A  E88000     INC2 W0, W0
006B4C  980740     MOV W0, [W14+8]
403:                  *ptos++  = 0x4444;                                                   /* Initialize register W4                                   */
006B4E  90004E     MOV [W14+8], W0
006B50  244441     MOV #0x4444, W1
006B52  780801     MOV W1, [W0]
006B54  90004E     MOV [W14+8], W0
006B56  E88000     INC2 W0, W0
006B58  980740     MOV W0, [W14+8]
404:                  *ptos++  = 0x5555;                                                   /* Initialize register W5                                   */
006B5A  90004E     MOV [W14+8], W0
006B5C  255551     MOV #0x5555, W1
006B5E  780801     MOV W1, [W0]
006B60  90004E     MOV [W14+8], W0
006B62  E88000     INC2 W0, W0
006B64  980740     MOV W0, [W14+8]
405:                  *ptos++  = 0x6666;                                                   /* Initialize register W6                                   */
006B66  90004E     MOV [W14+8], W0
006B68  266661     MOV #0x6666, W1
006B6A  780801     MOV W1, [W0]
006B6C  90004E     MOV [W14+8], W0
006B6E  E88000     INC2 W0, W0
006B70  980740     MOV W0, [W14+8]
406:                  *ptos++  = 0x7777;                                                   /* Initialize register W7                                   */
006B72  90004E     MOV [W14+8], W0
006B74  277771     MOV #0x7777, W1
006B76  780801     MOV W1, [W0]
006B78  90004E     MOV [W14+8], W0
006B7A  E88000     INC2 W0, W0
006B7C  980740     MOV W0, [W14+8]
407:                  *ptos++  = 0x8888;                                                   /* Initialize register W8                                   */
006B7E  90004E     MOV [W14+8], W0
006B80  288881     MOV #0x8888, W1
006B82  780801     MOV W1, [W0]
006B84  90004E     MOV [W14+8], W0
006B86  E88000     INC2 W0, W0
006B88  980740     MOV W0, [W14+8]
408:                  *ptos++  = 0x9999;                                                   /* Initialize register W9                                   */
006B8A  90004E     MOV [W14+8], W0
006B8C  299991     MOV #0x9999, W1
006B8E  780801     MOV W1, [W0]
006B90  90004E     MOV [W14+8], W0
006B92  E88000     INC2 W0, W0
006B94  980740     MOV W0, [W14+8]
409:                  *ptos++  = 0xAAAA;                                                   /* Initialize register W10                                  */
006B96  90004E     MOV [W14+8], W0
006B98  2AAAA1     MOV #0xAAAA, W1
006B9A  780801     MOV W1, [W0]
006B9C  90004E     MOV [W14+8], W0
006B9E  E88000     INC2 W0, W0
006BA0  980740     MOV W0, [W14+8]
410:                  *ptos++  = 0xBBBB;                                                   /* Initialize register W11                                  */
006BA2  90004E     MOV [W14+8], W0
006BA4  2BBBB1     MOV #0xBBBB, W1
006BA6  780801     MOV W1, [W0]
006BA8  90004E     MOV [W14+8], W0
006BAA  E88000     INC2 W0, W0
006BAC  980740     MOV W0, [W14+8]
411:                  *ptos++  = 0xCCCC;                                                   /* Initialize register W12                                  */
006BAE  90004E     MOV [W14+8], W0
006BB0  2CCCC1     MOV #0xCCCC, W1
006BB2  780801     MOV W1, [W0]
006BB4  90004E     MOV [W14+8], W0
006BB6  E88000     INC2 W0, W0
006BB8  980740     MOV W0, [W14+8]
412:                  *ptos++  = 0xDDDD;                                                   /* Initialize register W13                                  */
006BBA  90004E     MOV [W14+8], W0
006BBC  2DDDD1     MOV #0xDDDD, W1
006BBE  780801     MOV W1, [W0]
006BC0  90004E     MOV [W14+8], W0
006BC2  E88000     INC2 W0, W0
006BC4  980740     MOV W0, [W14+8]
413:                  *ptos++  = 0xEEEE;                                                   /* Initialize register W14                                  */
006BC6  90004E     MOV [W14+8], W0
006BC8  2EEEE1     MOV #0xEEEE, W1
006BCA  780801     MOV W1, [W0]
006BCC  90004E     MOV [W14+8], W0
006BCE  E88000     INC2 W0, W0
006BD0  980740     MOV W0, [W14+8]
414:               
415:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
416:                  *ptos++  = ACCAL;                                                    /* Push Accumulator A onto the stack                        */
417:                  *ptos++  = ACCAH;                                                    /* Push Accumulator A onto the stack                        */
418:                  *ptos++  = ACCAU;                                                    /* Push Accumulator A onto the stack                        */
419:                  *ptos++  = ACCBL;                                                    /* Push Accumulator B onto the stack                        */
420:                  *ptos++  = ACCBH;                                                    /* Push Accumulator B onto the stack                        */
421:                  *ptos++  = ACCBU;                                                    /* Push Accumulator B onto the stack                        */
422:               #endif
423:                  *ptos++  = TBLPAG;                                                   /* Push the Data Table Page Address onto the stack          */
006BD2  8002A1     MOV TBLPAG, W1
006BD4  90004E     MOV [W14+8], W0
006BD6  780801     MOV W1, [W0]
006BD8  90004E     MOV [W14+8], W0
006BDA  E88000     INC2 W0, W0
006BDC  980740     MOV W0, [W14+8]
424:               #if defined(__dsPIC33E__)
425:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
426:                  *ptos++  = DSWPAG;
427:               #elif defined (__dsPIC33F__) || defined(__PIC24F__)
428:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
006BDE  800191     MOV DSRPAG, W1
006BE0  90004E     MOV [W14+8], W0
006BE2  780801     MOV W1, [W0]
006BE4  90004E     MOV [W14+8], W0
006BE6  E88000     INC2 W0, W0
006BE8  980740     MOV W0, [W14+8]
429:                  *ptos++  = DSWPAG;
006BEA  8001A1     MOV DSWPAG, W1
006BEC  90004E     MOV [W14+8], W0
006BEE  780801     MOV W1, [W0]
006BF0  90004E     MOV [W14+8], W0
006BF2  E88000     INC2 W0, W0
006BF4  980740     MOV W0, [W14+8]
430:               //   *ptos++  = PSVPAG;
431:               #endif
432:                  *ptos++  = RCOUNT;                                                   /* Push the Repeat Loop Counter Register onto the stack     */
006BF6  8001B1     MOV RCOUNT, W1
006BF8  90004E     MOV [W14+8], W0
006BFA  780801     MOV W1, [W0]
006BFC  90004E     MOV [W14+8], W0
006BFE  E88000     INC2 W0, W0
006C00  980740     MOV W0, [W14+8]
433:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
434:                  *ptos++  = DCOUNT;                                                   /* Push the Do Loop     Counter Register onto the stack     */
435:                  *ptos++  = DOSTARTL;                                                 /* Push the Do Loop Start Address Register onto the stack   */
436:                  *ptos++  = DOSTARTH;                                                 /* Push the Do Loop Start Address Register onto the stack   */
437:                  *ptos++  = DOENDL;                                                   /* Push the Do Loop End   Address Register onto the stack   */
438:                  *ptos++  = DOENDH;                                                   /* Push the Do Loop End   Address Register onto the stack   */
439:               #endif
440:                  *ptos++  = 0;                                                        /* Force the SR to enable all interrupt, clear flags        */
006C02  90004E     MOV [W14+8], W0
006C04  EB0080     CLR W1
006C06  780801     MOV W1, [W0]
006C08  90004E     MOV [W14+8], W0
006C0A  E88000     INC2 W0, W0
006C0C  980740     MOV W0, [W14+8]
441:                  *ptos++  = CORCON;                                                   /* Push the Core Control Register on to the stack           */
006C0E  800221     MOV CORCON, W1
006C10  90004E     MOV [W14+8], W0
006C12  780801     MOV W1, [W0]
006C14  90004E     MOV [W14+8], W0
006C16  E88000     INC2 W0, W0
006C18  980740     MOV W0, [W14+8]
442:               
443:                   return (ptos);                                                      /* Return the stack pointer to the new tasks stack          */
006C1A  90004E     MOV [W14+8], W0
444:               }
006C1C  FA8000     ULNK
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uCOS-II/Ports/os_cpu_a.s  ------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                                (c) Copyright 2006, Micrium, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                          dsPIC33/PIC24 MPLab Port
                                                  11:    ;                                                 
                                                  12:    ;
                                                  13:    ; File         : os_cpu_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ; Port Version : V2.81 (and higher)
                                                  16:    ;********************************************************************************************************
                                                  17:    ;
                                                  18:    
                                                  19:    ;
                                                  20:    ;********************************************************************************************************
                                                  21:    ;                                                CONSTANTS
                                                  22:    ;********************************************************************************************************
                                                  23:    ;
                                                  24:     
                                                  25:    ;
                                                  26:    ;********************************************************************************************************
                                                  27:    ;                                                INCLUDES
                                                  28:    ;********************************************************************************************************
                                                  29:    ;
                                                  30:    
                                                  31:    .include "xc.inc"
                                                  32:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  33:    
                                                  34:    ;
                                                  35:    ;********************************************************************************************************
                                                  36:    ;                                             LINKER SPECIFICS
                                                  37:    ;********************************************************************************************************
                                                  38:    ;
                                                  39:    
                                                  40:        .text                                         ; Locate this file in the text region of the build
                                                  41:    
                                                  42:    ;
                                                  43:    ;********************************************************************************************************
                                                  44:    ;                                                 GLOBALS
                                                  45:    ;********************************************************************************************************
                                                  46:    ;
                                                  47:    
                                                  48:        .global  _OSStartHighRdy
                                                  49:        .global  _OSCtxSw
                                                  50:        .global  _OSIntCtxSw
                                                  51:    
                                                  52:    ;
                                                  53:    ;********************************************************************************************************
                                                  54:    ;                                            OSStartHighRdy
                                                  55:    ;
                                                  56:    ; Description : This function determines the highest priority task that is ready to run after
                                                  57:    ;               OSInit() is called.
                                                  58:    ;********************************************************************************************************
                                                  59:    ;
                                                  60:    
                                                  61:    _OSStartHighRdy:
007178  026AC2     CALL 0x6AC2                    62:        call   _OSTaskSwHook                          ; Call user defined task switch hook
                                                  63:    
00717C  200010     MOV #0x1, W0                   64:        mov    #0x0001, w0                            ; Set OSRunning to TRUE
00717E  208701     MOV #0x870, W1                 65:        mov    #_OSRunning, w1
007180  784880     MOV.B W0, [W1]                 66:        mov.b  w0, [w1]                               ; Set OSRunning to TRUE
                                                  67:    
                                                  68:                                                      ; Get stack pointer of the task to resume
007182  8043D0     MOV 0x87A, W0                  69:        mov    _OSTCBHighRdy, w0                      ; Get the pointer to the stack to resume
007184  780790     MOV [W0], W15                  70:        mov    [w0], w15                              ; Dereference the pointer and store the data (the new stack address) W15, the stack pointer register
                                                  71:    
007186  F90044     POP CORCON                     72:        OS_REGS_RESTORE                               ; Restore all of this tasks registers from the stack
                                                  73:        
0071A2  064000     RETFIE                         74:        retfie                                        ; Return from the interrupt, the task is now ready to run
                                                  75:    
                                                  76:    ;
                                                  77:    ;********************************************************************************************************
                                                  78:    ;                                            OSCtxSw
                                                  79:    ;
                                                  80:    ; Description : TThe code to perform a 'task level' context switch.  OSCtxSw() is called 
                                                  81:    ;               when a higher priority task is made ready to run by another task or, 
                                                  82:    ;               when the current task can no longer execute (e.g. it calls OSTimeDly(), 
                                                  83:    ;               OSSemPend() and the semaphore is not available, etc.). 
                                                  84:    ;********************************************************************************************************
                                                  85:    ;
                                                  86:        
                                                  87:    _OSCtxSw:
                                                  88:                                                      ; TRAP (interrupt) should bring us here, not 'call'.
                                                  89:                                                      ; Since dsPIC has no TRAP, it is necessary to correct the stack to simulate an interrupt
                                                  90:                                                      ; In other words, this function must also save SR and IPL3 to the stack, not just the PC.
                                                  91:    
0071A4  BFC042     MOV.B SR, WREG                 92:        mov.b  SRL, wreg                              ; Load SRL
0071A6  DD0048     SL W0, #8, W0                  93:        sl w0, #8, w0                                 ; Shift left by 8
0071A8  AF6044     BTSC CORCON, #3                94:        btsc   CORCON, #IPL3                          ; Test IPL3 bit, skip if clear
0071AA  A07000     BSET W0, #7                    95:        bset   w0, #7;                                ; Copy IPL3 to bit7 of w0
                                                  96:        
0071AC  70004F     IOR W0, [--W15], W0            97:        ior    w0, [--w15], w0                        ; Merge bits
0071AE  781F80     MOV W0, [W15++]                98:        mov    w0, [w15++]                            ; Write back
                                                  99:    
0071B0  BE9F80     MOV.D W0, [W15++]              100:       OS_REGS_SAVE                                  ; Save processor registers
                                                  101:   
                                                  102:                                                     ; Save current task's stack pointer into the currect tasks TCB
0071CC  8043B0     MOV 0x876, W0                  103:       mov    _OSTCBCur, w0                          ; Get the address of the location in this tasks TCB to store the stack pointer
0071CE  78080F     MOV W15, [W0]                  104:       mov    w15, [w0]                              ; Store the stack pointer in this tasks TCB        
                                                  105:   
0071D0  026AC2     CALL 0x6AC2                    106:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  107:   
0071D4  8043D1     MOV 0x87A, W1                  108:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
0071D6  8843B1     MOV W1, 0x876                  109:       mov    w1, _OSTCBCur
0071D8  2086E0     MOV #0x86E, W0                 110:       mov    #_OSPrioHighRdy, w0
0071DA  2086D2     MOV #0x86D, W2                 111:       mov    #_OSPrioCur, w2
0071DC  784910     MOV.B [W0], [W2]               112:       mov.b  [w0], [w2]
                                                  113:           
0071DE  780791     MOV [W1], W15                  114:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  115:   
0071E0  F90044     POP CORCON                     116:       OS_REGS_RESTORE                               ; Restore registers
                                                  117:       
0071FC  064000     RETFIE                         118:       retfie                                        ; Return from interrupt
                                                  119:   
                                                  120:   ;
                                                  121:   ;********************************************************************************************************
                                                  122:   ;                                            OSIntCtxSw
                                                  123:   ;
                                                  124:   ; Description : When an ISR (Interrupt Service Routine) completes, OSIntExit() is called to 
                                                  125:   ;               determine whether a more important task than the interrupted task needs to 
                                                  126:   ;               execute.  If that's the case, OSIntExit() determines which task to run next 
                                                  127:   ;               and calls OSIntCtxSw() to perform the actual context switch to that task.  
                                                  128:   ;********************************************************************************************************
                                                  129:   ;
                                                  130:   
                                                  131:   _OSIntCtxSw:
0071FE  026AC2     CALL 0x6AC2                    132:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  133:   
007202  8043D1     MOV 0x87A, W1                  134:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
007204  8843B1     MOV W1, 0x876                  135:       mov    w1, _OSTCBCur
007206  2086E0     MOV #0x86E, W0                 136:       mov    #_OSPrioHighRdy, w0
007208  2086D2     MOV #0x86D, W2                 137:       mov    #_OSPrioCur, w2
00720A  784910     MOV.B [W0], [W2]               138:       mov.b  [w0], [w2]
                                                  139:           
00720C  780791     MOV [W1], W15                  140:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  141:   
00720E  F90044     POP CORCON                     142:       OS_REGS_RESTORE                               ; Restore registers
                                                  143:       
00722A  064000     RETFIE                         144:       retfie                                        ; Return from interrupt
                                                  145:   
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uC-LIB/lib_str.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                       ASCII STRING MANAGEMENT
29:                *
30:                * Filename      : lib_str.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 BAN
34:                *                 JDH
35:                *********************************************************************************************************
36:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
37:                *
38:                *                     (a) ALL standard library functions are implemented in the custom library modules :
39:                *
40:                *                         (1) \<Custom Library Directory>\lib_*.*
41:                *
42:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
43:                *
44:                *                               where
45:                *                                       <Custom Library Directory>      directory path for custom library software
46:                *                                       <cpu>                           directory name for specific processor (CPU)
47:                *                                       <compiler>                      directory name for specific compiler
48:                *
49:                *                     (b) Product-specific library functions are implemented in individual products.
50:                *
51:                *********************************************************************************************************
52:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
53:                *                     us permission to reprint portions of their documentation.  Portions of this text are
54:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
55:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
56:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
57:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
58:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
59:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
60:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
61:                *********************************************************************************************************
62:                */
63:                
64:                
65:                /*
66:                *********************************************************************************************************
67:                *                                            INCLUDE FILES
68:                *********************************************************************************************************
69:                */
70:                
71:                #define    MICRIUM_SOURCE
72:                #define    LIB_STR_MODULE
73:                #include  <lib_str.h>
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                            LOCAL DEFINES
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                           LOCAL CONSTANTS
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                          LOCAL DATA TYPES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                            LOCAL TABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
104:                  (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
105:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
106:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
107:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
108:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
109:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
110:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
111:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
112:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
113:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
114:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
115:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
116:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
117:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
118:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
119:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
120:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
121:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
122:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
123:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
124:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
125:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
126:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
127:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
128:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
129:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
130:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
131:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
132:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
133:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
134:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
135:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
136:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
137:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
138:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
139:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
140:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
141:               };
142:               
143:               
144:               /*
145:               *********************************************************************************************************
146:               *                                       LOCAL GLOBAL VARIABLES
147:               *********************************************************************************************************
148:               */
149:               
150:               
151:               /*
152:               *********************************************************************************************************
153:               *                                      LOCAL FUNCTION PROTOTYPES
154:               *********************************************************************************************************
155:               */
156:               
157:               static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
158:                                                              CPU_INT08U     nbr_dig,
159:                                                              CPU_INT08U     nbr_base,
160:                                                              CPU_BOOLEAN    nbr_neg,
161:                                                              CPU_CHAR       lead_char,
162:                                                              CPU_BOOLEAN    lower_case,
163:                                                              CPU_BOOLEAN    nul,
164:                                                              CPU_CHAR      *pstr);
165:               
166:               static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
167:                                                              CPU_CHAR     **pstr_next,
168:                                                              CPU_INT08U     nbr_base,
169:                                                              CPU_BOOLEAN    nbr_signed,
170:                                                              CPU_BOOLEAN   *pnbr_neg);
171:               
172:               
173:               /*
174:               *********************************************************************************************************
175:               *                                     LOCAL CONFIGURATION ERRORS
176:               *********************************************************************************************************
177:               */
178:               
179:               
180:               /*
181:               *********************************************************************************************************
182:               *                                              Str_Len()
183:               *
184:               * Description : Calculate length of a string.
185:               *
186:               * Argument(s) : pstr        Pointer to string (see Note #1).
187:               *
188:               * Return(s)   : Length of string; number of characters in string before terminating NULL character
189:               *                   (see Note #2b1).
190:               *
191:               * Caller(s)   : Application.
192:               *
193:               * Note(s)     : (1) String buffer NOT modified.
194:               *
195:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
196:               *
197:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
198:               *                            which 's' ('pstr') points," ...
199:               *                       (2) "not including the terminating null byte."
200:               *
201:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
202:               *
203:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
204:               *                       (2) "no return value shall be reserved to indicate an error."
205:               *
206:               *               (3) String length calculation terminates when :
207:               *
208:               *                   (a) String pointer points to NULL.
209:               *                       (1) String buffer overlaps with NULL address.
210:               *                       (2) String length calculated for string up to but NOT beyond or including
211:               *                           the NULL address.
212:               *
213:               *                   (b) Terminating NULL character found.
214:               *                       (1) String length calculated for string up to but NOT           including
215:               *                           the NULL character (see Note #2a2).
216:               *********************************************************************************************************
217:               */
218:               
219:               CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
220:               {
00235E  FA0004     LNK #0x4
002360  980710     MOV W0, [W14+2]
221:                   CPU_SIZE_T  len;
222:               
223:               
224:                   len = Str_Len_N(pstr,
002362  EB8080     SETM W1
002364  90001E     MOV [W14+2], W0
002366  070004     RCALL Str_Len_N
002368  780F00     MOV W0, [W14]
225:                                   DEF_INT_CPU_U_MAX_VAL);
226:               
227:                   return (len);
00236A  78001E     MOV [W14], W0
228:               }
00236C  FA8000     ULNK
00236E  060000     RETURN
229:               
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                             Str_Len_N()
234:               *
235:               * Description : Calculate length of a string, up to a maximum number of characters.
236:               *
237:               * Argument(s) : pstr        Pointer to string (see Note #1).
238:               *
239:               *               len_max     Maximum number of characters to search (see Note #3c).
240:               *
241:               * Return(s)   : Length of string; number of characters in string before terminating NULL character,
242:               *                   if terminating NULL character     found (see Note #2b1).
243:               *
244:               *               Requested maximum number of characters to search,
245:               *                   if terminating NULL character NOT found (see Note #3c).
246:               *
247:               * Caller(s)   : Application.
248:               *
249:               * Note(s)     : (1) String buffer NOT modified.
250:               *
251:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
252:               *
253:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
254:               *                            which 's' ('pstr') points," ...
255:               *                       (2) "not including the terminating null byte."
256:               *
257:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
258:               *
259:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
260:               *                       (2) "no return value shall be reserved to indicate an error."
261:               *
262:               *               (3) String length calculation terminates when :
263:               *
264:               *                   (a) String pointer points to NULL.
265:               *                       (1) String buffer overlaps with NULL address.
266:               *                       (2) String length calculated for string up to but NOT beyond or including
267:               *                           the NULL address.
268:               *
269:               *                   (b) Terminating NULL character found.
270:               *                       (1) String length calculated for string up to but NOT           including
271:               *                           the NULL character (see Note #2a2).
272:               *
273:               *                   (c) 'len_max' number of characters searched.
274:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
275:               *********************************************************************************************************
276:               */
277:               
278:               CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
279:                                             CPU_SIZE_T   len_max)
280:               {
002370  FA0008     LNK #0x8
002372  980720     MOV W0, [W14+4]
002374  980731     MOV W1, [W14+6]
281:                   const  CPU_CHAR    *pstr_len;
282:                          CPU_SIZE_T   len;
283:               
284:               
285:                   pstr_len = pstr;
002376  9000AE     MOV [W14+4], W1
002378  780F01     MOV W1, [W14]
286:                   len      = 0u;
00237A  EB0000     CLR W0
00237C  980710     MOV W0, [W14+2]
287:                   while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
00237E  370004     BRA 0x2388
002388  78001E     MOV [W14], W0
00238A  E00000     CP0 W0
00238C  320008     BRA Z, 0x239E
002392  E00400     CP0.B W0
002394  320004     BRA Z, 0x239E
288:                          (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
00238E  78001E     MOV [W14], W0
002390  784010     MOV.B [W0], W0
002396  90009E     MOV [W14+2], W1
002398  90003E     MOV [W14+6], W0
00239A  508F80     SUB W1, W0, [W15]
00239C  39FFF1     BRA NC, 0x2380
289:                          ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
290:                       pstr_len++;
002380  E80F1E     INC [W14], [W14]
291:                       len++;
002382  90001E     MOV [W14+2], W0
002384  E80000     INC W0, W0
002386  980710     MOV W0, [W14+2]
292:                   }
293:               
294:                   return (len);                                               /* Rtn str len (see Note #3b1).                         */
00239E  90001E     MOV [W14+2], W0
295:               }
0023A0  FA8000     ULNK
0023A2  060000     RETURN
296:               
297:               
298:               /*
299:               *********************************************************************************************************
300:               *                                             Str_Copy()
301:               *
302:               * Description : Copy source string to destination string buffer.
303:               *
304:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
305:               *
306:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
307:               *
308:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
309:               *
310:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
311:               *
312:               * Caller(s)   : Application.
313:               *
314:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
315:               *
316:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
317:               *                           string size including the terminating NULL character.
318:               *
319:               *                   (b) Source buffer NOT modified.
320:               *
321:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
322:               *
323:               *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src')
324:               *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
325:               *                       (2) "(including the terminating null byte)."
326:               *
327:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
328:               *
329:               *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
330:               *                       (2) "no return value is reserved to indicate an error."
331:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
332:               *                               NULL for any error(s).
333:               *
334:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
335:               *                       copying takes place between objects that overlap, the behavior is undefined".
336:               *
337:               *               (3) String copy terminates when :
338:               *
339:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
340:               *                       (1) No string copy performed; NULL pointer returned.
341:               *
342:               *                   (b) Destination/Source string pointer(s) point to NULL.
343:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
344:               *
345:               *                   (c) Source string's terminating NULL character found.
346:               *                       (1) Entire source string copied into destination string buffer (see Note #2a).
347:               *********************************************************************************************************
348:               */
349:               
350:               CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
351:                                    const  CPU_CHAR  *pstr_src)
352:               {
0023A4  FA0006     LNK #0x6
0023A6  980710     MOV W0, [W14+2]
0023A8  980721     MOV W1, [W14+4]
353:                   CPU_CHAR  *pstr_rtn;
354:               
355:               
356:                   pstr_rtn = Str_Copy_N(pstr_dest,
0023AA  EB8100     SETM W2
0023AC  9000AE     MOV [W14+4], W1
0023AE  90001E     MOV [W14+2], W0
0023B0  070004     RCALL Str_Copy_N
0023B2  780F00     MOV W0, [W14]
357:                                         pstr_src,
358:                                         DEF_INT_CPU_U_MAX_VAL);
359:               
360:                   return (pstr_rtn);
0023B4  78001E     MOV [W14], W0
361:               }
0023B6  FA8000     ULNK
0023B8  060000     RETURN
362:               
363:               
364:               /*
365:               *********************************************************************************************************
366:               *                                            Str_Copy_N()
367:               *
368:               * Description : Copy source string to destination string buffer, up to a maximum number of characters.
369:               *
370:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
371:               *
372:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
373:               *
374:               *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
375:               *
376:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
377:               *
378:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
379:               *
380:               * Caller(s)   : Application.
381:               *
382:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
383:               *
384:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
385:               *                           string size including the terminating NULL character.
386:               *
387:               *                   (b) Source string buffer NOT modified.
388:               *
389:               *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
390:               *
391:               *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2'
392:               *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
393:               *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
394:               *                           (C)  &   "(bytes that follow a null byte are not copied)".
395:               *
396:               *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that
397:               *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter
398:               *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in
399:               *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes
400:               *                               in all are written."
401:               *
402:               *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy
403:               *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters,
404:               *                                   this requirement is intentionally NOT implemented to avoid appending
405:               *                                   a potentially large number of unnecessary terminating NULL characters.
406:               *
407:               *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also
408:               *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of
409:               *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
410:               *
411:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
412:               *
413:               *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
414:               *                       (2) "no return value is reserved to indicate an error."
415:               *                           (A) #### This requirement is intentionally ignored in order to return NULL
416:               *                               for any error(s).
417:               *
418:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
419:               *                       copying takes place between objects that overlap, the behavior is undefined".
420:               *
421:               *               (3) String copy terminates when :
422:               *
423:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
424:               *                       (1) No string copy performed; NULL pointer returned.
425:               *
426:               *                   (b) Destination/Source string pointer(s) point to NULL.
427:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
428:               *
429:               *                   (c) Source string's terminating NULL character found.
430:               *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
431:               *
432:               *                   (d) 'len_max' number of characters copied.
433:               *                       (1) 'len_max' number of characters MAY include the terminating NULL character
434:               *                           (see Note #2a1C).
435:               *                       (2) Null copies allowed (i.e. zero-length copies).
436:               *                           (A) No string copy performed; destination string returned  (see Note #2b1).
437:               *********************************************************************************************************
438:               */
439:               
440:               CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
441:                                      const  CPU_CHAR    *pstr_src,
442:                                             CPU_SIZE_T   len_max)
443:               {
0023BA  FA000C     LNK #0xC
0023BC  980730     MOV W0, [W14+6]
0023BE  980741     MOV W1, [W14+8]
0023C0  980752     MOV W2, [W14+10]
444:                          CPU_CHAR    *pstr_copy_dest;
445:                   const  CPU_CHAR    *pstr_copy_src;
446:                          CPU_SIZE_T   len_copy;
447:               
448:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
449:                   if (pstr_dest == (CPU_CHAR *)0) {
0023C2  90003E     MOV [W14+6], W0
0023C4  E00000     CP0 W0
0023C6  3A0002     BRA NZ, 0x23CC
450:                       return ((CPU_CHAR *)0);
0023C8  EB0000     CLR W0
0023CA  370035     BRA 0x2436
451:                   }
452:                   if (pstr_src  == (const CPU_CHAR *)0) {
0023CC  90004E     MOV [W14+8], W0
0023CE  E00000     CP0 W0
0023D0  3A0002     BRA NZ, 0x23D6
453:                       return ((CPU_CHAR *)0);
0023D2  EB0000     CLR W0
0023D4  370030     BRA 0x2436
454:                   }
455:               
456:               
457:                   pstr_copy_dest = pstr_dest;
0023D6  9000BE     MOV [W14+6], W1
0023D8  780F01     MOV W1, [W14]
458:                   pstr_copy_src  = pstr_src;
0023DA  9000CE     MOV [W14+8], W1
0023DC  980711     MOV W1, [W14+2]
459:                   len_copy       = 0u;
0023DE  EB0000     CLR W0
0023E0  980720     MOV W0, [W14+4]
460:               
461:                   while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
0023E2  37000B     BRA 0x23FA
0023FA  78001E     MOV [W14], W0
0023FC  E00000     CP0 W0
0023FE  32000B     BRA Z, 0x2416
002400  90001E     MOV [W14+2], W0
002402  E00000     CP0 W0
002404  320008     BRA Z, 0x2416
462:                          ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
00240A  E00400     CP0.B W0
00240C  320004     BRA Z, 0x2416
463:                          (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
002406  90001E     MOV [W14+2], W0
002408  784010     MOV.B [W0], W0
00240E  9000AE     MOV [W14+4], W1
002410  90005E     MOV [W14+10], W0
002412  508F80     SUB W1, W0, [W15]
002414  39FFE7     BRA NC, 0x23E4
464:                          ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
465:                      *pstr_copy_dest = *pstr_copy_src;
0023E4  90001E     MOV [W14+2], W0
0023E6  784090     MOV.B [W0], W1
0023E8  78001E     MOV [W14], W0
0023EA  784801     MOV.B W1, [W0]
466:                       pstr_copy_dest++;
0023EC  E80F1E     INC [W14], [W14]
467:                       pstr_copy_src++;
0023EE  90001E     MOV [W14+2], W0
0023F0  E80000     INC W0, W0
0023F2  980710     MOV W0, [W14+2]
468:                       len_copy++;
0023F4  90002E     MOV [W14+4], W0
0023F6  E80000     INC W0, W0
0023F8  980720     MOV W0, [W14+4]
469:                   }
470:                                                                               /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
471:                   if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
002416  78001E     MOV [W14], W0
002418  E00000     CP0 W0
00241A  320003     BRA Z, 0x2422
00241C  90001E     MOV [W14+2], W0
00241E  E00000     CP0 W0
002420  3A0002     BRA NZ, 0x2426
472:                       (pstr_copy_src  == (const CPU_CHAR *)0)) {
473:                        return ((CPU_CHAR *)0);
002422  EB0000     CLR W0
002424  370008     BRA 0x2436
474:                   }
475:               
476:                   if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
002426  9000AE     MOV [W14+4], W1
002428  90005E     MOV [W14+10], W0
00242A  508F80     SUB W1, W0, [W15]
00242C  310003     BRA C, 0x2434
477:                      *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
00242E  78001E     MOV [W14], W0
002430  EB4080     CLR.B W1
002432  784801     MOV.B W1, [W0]
478:                   }
479:               
480:               
481:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
002434  90003E     MOV [W14+6], W0
482:               }
002436  FA8000     ULNK
002438  060000     RETURN
483:               
484:               
485:               /*
486:               *********************************************************************************************************
487:               *                                              Str_Cat()
488:               *
489:               * Description : Append concatenation string to destination string.
490:               *
491:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
492:               *
493:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
494:               *
495:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
496:               *
497:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
498:               *
499:               * Caller(s)   : Application.
500:               *
501:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
502:               *
503:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
504:               *                           concatenated string size including the terminating NULL character.
505:               *
506:               *                   (b) Concatenation string buffer NOT modified.
507:               *
508:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
509:               *
510:               *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2'
511:               *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
512:               *
513:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
514:               *                                end of 's1' ('pstr_dest')."
515:               *                           (B)  A "terminating null byte" is appended at the end of the concatenated
516:               *                                destination strings.
517:               *
518:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
519:               *
520:               *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
521:               *                       (2) "no return value shall be reserved to indicate an error."
522:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
523:               *                               NULL for any error(s).
524:               *
525:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
526:               *                       copying takes place between objects that overlap, the behavior is undefined."
527:               *
528:               *               (3) String concatenation terminates when :
529:               *
530:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
531:               *                       (1) No string concatenation performed; NULL pointer returned.
532:               *
533:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
534:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
535:               *
536:               *                   (c) Concatenation string's terminating NULL character found.
537:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
538:               *********************************************************************************************************
539:               */
540:               
541:               CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
542:                                   const  CPU_CHAR  *pstr_cat)
543:               {
00243A  FA0006     LNK #0x6
00243C  980710     MOV W0, [W14+2]
00243E  980721     MOV W1, [W14+4]
544:                   CPU_CHAR  *pstr_rtn;
545:               
546:               
547:                   pstr_rtn = Str_Cat_N(pstr_dest,
002440  EB8100     SETM W2
002442  9000AE     MOV [W14+4], W1
002444  90001E     MOV [W14+2], W0
002446  070004     RCALL Str_Cat_N
002448  780F00     MOV W0, [W14]
548:                                        pstr_cat,
549:                                        DEF_INT_CPU_U_MAX_VAL);
550:               
551:                   return (pstr_rtn);
00244A  78001E     MOV [W14], W0
552:               }
00244C  FA8000     ULNK
00244E  060000     RETURN
553:               
554:               
555:               /*
556:               *********************************************************************************************************
557:               *                                             Str_Cat_N()
558:               *
559:               * Description : Append concatenation string to destination string, up to a maximum number of characters.
560:               *
561:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
562:               *
563:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
564:               *
565:               *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
566:               *
567:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
568:               *
569:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
570:               *
571:               * Caller(s)   : Application.
572:               *
573:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
574:               *
575:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
576:               *                           concatenated string size including the terminating NULL character.
577:               *
578:               *                   (b) Concatenation string buffer NOT modified.
579:               *
580:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
581:               *
582:               *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2'
583:               *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
584:               *                           (B)  but "not more than 'n' ('len_max') bytes".
585:               *
586:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
587:               *                                end of 's1' ('pstr_dest')."
588:               *                           (B) "(a null byte and bytes that follow it are not appended)."
589:               *                           (C) "A terminating null byte is always appended to the result."
590:               *
591:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
592:               *
593:               *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
594:               *                       (2) "no return value shall be reserved to indicate an error."
595:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
596:               *                               NULL for any error(s).
597:               *
598:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
599:               *                       copying takes place between objects that overlap, the behavior is undefined."
600:               *
601:               *               (3) String concatenation terminates when :
602:               *
603:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
604:               *                       (1) No string concatenation performed; NULL pointer returned.
605:               *
606:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
607:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
608:               *
609:               *                   (c) Concatenation string's terminating NULL character found.
610:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
611:               *
612:               *                   (d) 'len_max' number of characters concatenated.
613:               *
614:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character
615:               *                           (see Note #2a2).
616:               *
617:               *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
618:               *                           (A) No string concatenation performed; destination string returned
619:               *                               (see Note #2b1).
620:               *********************************************************************************************************
621:               */
622:               
623:               CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
624:                                     const  CPU_CHAR    *pstr_cat,
625:                                            CPU_SIZE_T   len_max)
626:               {
002450  FA000C     LNK #0xC
002452  980730     MOV W0, [W14+6]
002454  980741     MOV W1, [W14+8]
002456  980752     MOV W2, [W14+10]
627:                          CPU_CHAR    *pstr_cat_dest;
628:                   const  CPU_CHAR    *pstr_cat_src;
629:                          CPU_SIZE_T   len_cat;
630:               
631:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
632:                   if (pstr_dest == (CPU_CHAR *)0) {
002458  90003E     MOV [W14+6], W0
00245A  E00000     CP0 W0
00245C  3A0002     BRA NZ, 0x2462
633:                       return ((CPU_CHAR *)0);
00245E  EB0000     CLR W0
002460  370044     BRA 0x24EA
634:                   }
635:                   if (pstr_cat  == (const CPU_CHAR *)0) {
002462  90004E     MOV [W14+8], W0
002464  E00000     CP0 W0
002466  3A0002     BRA NZ, 0x246C
636:                       return ((CPU_CHAR *)0);
002468  EB0000     CLR W0
00246A  37003F     BRA 0x24EA
637:                   }
638:               
639:                   if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
00246C  90005E     MOV [W14+10], W0
00246E  E00000     CP0 W0
002470  3A0002     BRA NZ, 0x2476
640:                       return ((CPU_CHAR *)pstr_dest);
002472  90003E     MOV [W14+6], W0
002474  37003A     BRA 0x24EA
641:                   }
642:               
643:               
644:                   pstr_cat_dest = pstr_dest;
002476  9000BE     MOV [W14+6], W1
002478  780F01     MOV W1, [W14]
645:                   while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
00247A  370001     BRA 0x247E
00247E  78001E     MOV [W14], W0
002480  E00000     CP0 W0
002482  320004     BRA Z, 0x248C
002488  E00400     CP0.B W0
00248A  3AFFF8     BRA NZ, 0x247C
646:                          (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
002484  78001E     MOV [W14], W0
002486  784010     MOV.B [W0], W0
647:                       pstr_cat_dest++;
00247C  E80F1E     INC [W14], [W14]
648:                   }
649:                   if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
00248C  78001E     MOV [W14], W0
00248E  E00000     CP0 W0
002490  3A0002     BRA NZ, 0x2496
650:                       return ((CPU_CHAR *)0);
002492  EB0000     CLR W0
002494  37002A     BRA 0x24EA
651:                   }
652:               
653:                   pstr_cat_src = pstr_cat;
002496  9000CE     MOV [W14+8], W1
002498  980711     MOV W1, [W14+2]
654:                   len_cat      = 0u;
00249A  EB0000     CLR W0
00249C  980720     MOV W0, [W14+4]
655:               
656:                   while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
00249E  37000B     BRA 0x24B6
0024B6  78001E     MOV [W14], W0
0024B8  E00000     CP0 W0
0024BA  32000B     BRA Z, 0x24D2
0024BC  90001E     MOV [W14+2], W0
0024BE  E00000     CP0 W0
0024C0  320008     BRA Z, 0x24D2
657:                          ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
0024C6  E00400     CP0.B W0
0024C8  320004     BRA Z, 0x24D2
658:                          (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
0024C2  90001E     MOV [W14+2], W0
0024C4  784010     MOV.B [W0], W0
0024CA  9000AE     MOV [W14+4], W1
0024CC  90005E     MOV [W14+10], W0
0024CE  508F80     SUB W1, W0, [W15]
0024D0  39FFE7     BRA NC, 0x24A0
659:                          ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
660:                      *pstr_cat_dest = *pstr_cat_src;
0024A0  90001E     MOV [W14+2], W0
0024A2  784090     MOV.B [W0], W1
0024A4  78001E     MOV [W14], W0
0024A6  784801     MOV.B W1, [W0]
661:                       pstr_cat_dest++;
0024A8  E80F1E     INC [W14], [W14]
662:                       pstr_cat_src++;
0024AA  90001E     MOV [W14+2], W0
0024AC  E80000     INC W0, W0
0024AE  980710     MOV W0, [W14+2]
663:                       len_cat++;
0024B0  90002E     MOV [W14+4], W0
0024B2  E80000     INC W0, W0
0024B4  980720     MOV W0, [W14+4]
664:                   }
665:                                                                               /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
666:                   if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
0024D2  78001E     MOV [W14], W0
0024D4  E00000     CP0 W0
0024D6  320003     BRA Z, 0x24DE
0024D8  90001E     MOV [W14+2], W0
0024DA  E00000     CP0 W0
0024DC  3A0002     BRA NZ, 0x24E2
667:                       (pstr_cat_src  == (const CPU_CHAR *)0)) {
668:                        return ((CPU_CHAR *)0);
0024DE  EB0000     CLR W0
0024E0  370004     BRA 0x24EA
669:                   }
670:               
671:                  *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
0024E2  78001E     MOV [W14], W0
0024E4  EB4080     CLR.B W1
0024E6  784801     MOV.B W1, [W0]
672:               
673:               
674:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
0024E8  90003E     MOV [W14+6], W0
675:               }
0024EA  FA8000     ULNK
0024EC  060000     RETURN
676:               
677:               
678:               /*
679:               *********************************************************************************************************
680:               *                                              Str_Cmp()
681:               *
682:               * Description : Determine if two strings are identical.
683:               *
684:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
685:               *
686:               *               p2_str      Pointer to second string (see Note #1).
687:               *
688:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
689:               *
690:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
691:               *
692:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
693:               *
694:               *               See also Note #2b.
695:               *
696:               * Caller(s)   : Application.
697:               *
698:               * Note(s)     : (1) String buffers NOT modified.
699:               *
700:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
701:               *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
702:               *                       string pointed to by 's2' ('p2_str)".
703:               *
704:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
705:               *                          "upon successful completion, strcmp() shall return an integer greater than,
706:               *                           equal to, or less than 0".
707:               *
708:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
709:               *                           sign of a non-zero return value shall be determined by the sign of the difference
710:               *                           between the values of the first pair of bytes ... that differ in the strings
711:               *                           being compared".
712:               *
713:               *               (3) String comparison terminates when :
714:               *
715:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
716:               *                               (1) NULL strings identical; 0 returned.
717:               *
718:               *                           (B) (1) 'p1_str' passed a NULL pointer.
719:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
720:               *
721:               *                               (2) 'p2_str' passed a NULL pointer.
722:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
723:               *
724:               *                       (2) (A) BOTH strings point to NULL.
725:               *                               (1) Strings overlap with NULL address.
726:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
727:               *                                   0 returned.
728:               *
729:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
730:               *                                   (a) 'p1_str' overlaps with NULL address.
731:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
732:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
733:               *
734:               *                               (2) 'p2_str_cmp_next' points to NULL.
735:               *                                   (a) 'p2_str' overlaps with NULL address.
736:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
737:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
738:               *
739:               *                   (b) Terminating NULL character found in both strings.
740:               *                       (1) Strings identical; 0 returned.
741:               *                       (2) Only one NULL character test required in conditional since previous condition
742:               *                           tested character equality.
743:               *
744:               *                   (c) Non-matching characters found.
745:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
746:               *                           from the character pointed to by 'p1_str'.
747:               *
748:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
749:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
750:               *********************************************************************************************************
751:               */
752:               
753:               CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
754:                                    const  CPU_CHAR  *p2_str)
755:               {
0024EE  FA0006     LNK #0x6
0024F0  980710     MOV W0, [W14+2]
0024F2  980721     MOV W1, [W14+4]
756:                   CPU_INT16S  cmp_val;
757:               
758:               
759:                   cmp_val = Str_Cmp_N(p1_str,
0024F4  EB8100     SETM W2
0024F6  9000AE     MOV [W14+4], W1
0024F8  90001E     MOV [W14+2], W0
0024FA  070004     RCALL Str_Cmp_N
0024FC  780F00     MOV W0, [W14]
760:                                       p2_str,
761:                                       DEF_INT_CPU_U_MAX_VAL);
762:               
763:                   return (cmp_val);
0024FE  78001E     MOV [W14], W0
764:               }
002500  FA8000     ULNK
002502  060000     RETURN
765:               
766:               
767:               /*
768:               *********************************************************************************************************
769:               *                                             Str_Cmp_N()
770:               *
771:               * Description : Determine if two strings are identical for up to a maximum number of characters.
772:               *
773:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
774:               *
775:               *               p2_str      Pointer to second string (see Note #1).
776:               *
777:               *               len_max     Maximum number of characters to compare  (see Note  #3d).
778:               *
779:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
780:               *
781:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
782:               *
783:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
784:               *
785:               *               See also Note #2b.
786:               *
787:               * Caller(s)   : Application.
788:               *
789:               * Note(s)     : (1) String buffers NOT modified.
790:               *
791:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
792:               *
793:               *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str')
794:               *                            to the array pointed to by 's2' ('p2_str)" ...
795:               *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
796:               *
797:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
798:               *                          "upon successful completion, strncmp() shall return an integer greater than,
799:               *                           equal to, or less than 0".
800:               *
801:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
802:               *                          "the sign of a non-zero return value is determined by the sign of the difference
803:               *                           between the values of the first pair of bytes ... that differ in the strings
804:               *                           being compared".
805:               *
806:               *               (3) String comparison terminates when :
807:               *
808:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
809:               *                               (1) NULL strings identical; 0 returned.
810:               *
811:               *                           (B) (1) 'p1_str' passed a NULL pointer.
812:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
813:               *
814:               *                               (2) 'p2_str' passed a NULL pointer.
815:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
816:               *
817:               *                       (2) (A) BOTH strings point to NULL.
818:               *                               (1) Strings overlap with NULL address.
819:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
820:               *                                   0 returned.
821:               *
822:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
823:               *                                   (a) 'p1_str' overlaps with NULL address.
824:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
825:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
826:               *
827:               *                               (2) 'p2_str_cmp_next' points to NULL.
828:               *                                   (a) 'p2_str' overlaps with NULL address.
829:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
830:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
831:               *
832:               *                   (b) Terminating NULL character found in both strings.
833:               *                       (1) Strings identical; 0 returned.
834:               *                       (2) Only one NULL character test required in conditional since previous condition
835:               *                           tested character equality.
836:               *
837:               *                   (c) Non-matching characters found.
838:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
839:               *                           from the character pointed to by 'p1_str'.
840:               *
841:               *                   (d) (1) 'len_max' passed a zero length.
842:               *                           (A) Zero-length strings identical; 0 returned.
843:               *
844:               *                       (2) First 'len_max' number of characters identical.
845:               *                           (A) Strings identical; 0 returned.
846:               *
847:               *                       See also Note #2a2.
848:               *
849:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
850:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
851:               *********************************************************************************************************
852:               */
853:               
854:               CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
855:                                      const  CPU_CHAR    *p2_str,
856:                                             CPU_SIZE_T   len_max)
857:               {
002504  FA0012     LNK #0x12
002506  980760     MOV W0, [W14+12]
002508  980771     MOV W1, [W14+14]
00250A  980F02     MOV W2, [W14+16]
858:                   const  CPU_CHAR    *p1_str_cmp;
859:                   const  CPU_CHAR    *p2_str_cmp;
860:                   const  CPU_CHAR    *p1_str_cmp_next;
861:                   const  CPU_CHAR    *p2_str_cmp_next;
862:                          CPU_INT16S   cmp_val;
863:                          CPU_SIZE_T   cmp_len;
864:               
865:               
866:                   if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
00250C  90080E     MOV [W14+16], W0
00250E  E00000     CP0 W0
002510  3A0002     BRA NZ, 0x2516
867:                       return (0);
002512  EB0000     CLR W0
002514  37007A     BRA 0x260A
868:                   }
869:               
870:                   if (p1_str == (const CPU_CHAR *)0) {
002516  90006E     MOV [W14+12], W0
002518  E00000     CP0 W0
00251A  3A000C     BRA NZ, 0x2534
871:                       if (p2_str == (const CPU_CHAR *)0) {
00251C  90007E     MOV [W14+14], W0
00251E  E00000     CP0 W0
002520  3A0002     BRA NZ, 0x2526
872:                           return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
002522  EB0000     CLR W0
002524  370072     BRA 0x260A
873:                       }
874:                       cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
002526  90007E     MOV [W14+14], W0
002528  784010     MOV.B [W0], W0
00252A  FB8000     ZE W0, W0
00252C  EA0000     NEG W0, W0
00252E  980740     MOV W0, [W14+8]
875:                       return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
002530  90004E     MOV [W14+8], W0
002532  37006B     BRA 0x260A
876:                   }
877:                   if (p2_str == (const CPU_CHAR *)0) {
002534  90007E     MOV [W14+14], W0
002536  E00000     CP0 W0
002538  3A0006     BRA NZ, 0x2546
878:                       cmp_val = (CPU_INT16S)(*p1_str);
00253A  90006E     MOV [W14+12], W0
00253C  784010     MOV.B [W0], W0
00253E  FB8000     ZE W0, W0
002540  980740     MOV W0, [W14+8]
879:                       return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
002542  90004E     MOV [W14+8], W0
002544  370062     BRA 0x260A
880:                   }
881:               
882:               
883:                   p1_str_cmp      = p1_str;
002546  9000EE     MOV [W14+12], W1
002548  780F01     MOV W1, [W14]
884:                   p2_str_cmp      = p2_str;
00254A  9000FE     MOV [W14+14], W1
00254C  980711     MOV W1, [W14+2]
885:                   p1_str_cmp_next = p1_str_cmp;
00254E  78009E     MOV [W14], W1
002550  980721     MOV W1, [W14+4]
886:                   p2_str_cmp_next = p2_str_cmp;
002552  90009E     MOV [W14+2], W1
002554  980731     MOV W1, [W14+6]
887:                   p1_str_cmp_next++;
002556  90002E     MOV [W14+4], W0
002558  E80000     INC W0, W0
00255A  980720     MOV W0, [W14+4]
888:                   p2_str_cmp_next++;
00255C  90003E     MOV [W14+6], W0
00255E  E80000     INC W0, W0
002560  980730     MOV W0, [W14+6]
889:                   cmp_len         = 0u;
002562  EB0000     CLR W0
002564  980750     MOV W0, [W14+10]
890:               
891:                   while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
002566  37000D     BRA 0x2582
002582  78001E     MOV [W14], W0
002584  784090     MOV.B [W0], W1
002586  90001E     MOV [W14+2], W0
002588  784010     MOV.B [W0], W0
00258A  50CF80     SUB.B W1, W0, [W15]
00258C  3A000E     BRA NZ, 0x25AA
002592  E00400     CP0.B W0
002594  32000A     BRA Z, 0x25AA
892:                          (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
00258E  78001E     MOV [W14], W0
002590  784010     MOV.B [W0], W0
002596  90002E     MOV [W14+4], W0
002598  E00000     CP0 W0
00259A  320007     BRA Z, 0x25AA
893:                          ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
00259C  90003E     MOV [W14+6], W0
00259E  E00000     CP0 W0
0025A0  320004     BRA Z, 0x25AA
894:                          ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
0025A2  9000DE     MOV [W14+10], W1
0025A4  90080E     MOV [W14+16], W0
0025A6  508F80     SUB W1, W0, [W15]
0025A8  39FFDF     BRA NC, 0x2568
895:                          ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
896:                       p1_str_cmp++;
002568  E80F1E     INC [W14], [W14]
897:                       p2_str_cmp++;
00256A  90001E     MOV [W14+2], W0
00256C  E80000     INC W0, W0
00256E  980710     MOV W0, [W14+2]
898:                       p1_str_cmp_next++;
002570  90002E     MOV [W14+4], W0
002572  E80000     INC W0, W0
002574  980720     MOV W0, [W14+4]
899:                       p2_str_cmp_next++;
002576  90003E     MOV [W14+6], W0
002578  E80000     INC W0, W0
00257A  980730     MOV W0, [W14+6]
900:                       cmp_len++;
00257C  90005E     MOV [W14+10], W0
00257E  E80000     INC W0, W0
002580  980750     MOV W0, [W14+10]
901:                   }
902:               
903:               
904:                   if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
0025AA  9000DE     MOV [W14+10], W1
0025AC  90080E     MOV [W14+16], W0
0025AE  508F80     SUB W1, W0, [W15]
0025B0  3A0002     BRA NZ, 0x25B6
905:                       return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
0025B2  EB0000     CLR W0
0025B4  37002A     BRA 0x260A
906:                   }
907:               
908:                   if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
0025B6  78001E     MOV [W14], W0
0025B8  784090     MOV.B [W0], W1
0025BA  90001E     MOV [W14+2], W0
0025BC  784010     MOV.B [W0], W0
0025BE  50CF80     SUB.B W1, W0, [W15]
0025C0  320009     BRA Z, 0x25D4
909:                                                                               /* ... calc & rtn char diff  (see Note #3c1).           */
910:                        cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
0025C2  78001E     MOV [W14], W0
0025C4  784010     MOV.B [W0], W0
0025C6  FB8080     ZE W0, W1
0025C8  90001E     MOV [W14+2], W0
0025CA  784010     MOV.B [W0], W0
0025CC  FB8000     ZE W0, W0
0025CE  508000     SUB W1, W0, W0
0025D0  980740     MOV W0, [W14+8]
0025D2  37001A     BRA 0x2608
911:               
912:                   } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
0025D4  78001E     MOV [W14], W0
0025D6  784010     MOV.B [W0], W0
0025D8  E00400     CP0.B W0
0025DA  3A0003     BRA NZ, 0x25E2
913:                        cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
0025DC  EB0000     CLR W0
0025DE  980740     MOV W0, [W14+8]
0025E0  370013     BRA 0x2608
914:               
915:                   } else {
916:                       if (p1_str_cmp_next == (const CPU_CHAR *)0) {
0025E2  90002E     MOV [W14+4], W0
0025E4  E00000     CP0 W0
0025E6  3A000C     BRA NZ, 0x2600
917:                           if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
0025E8  90003E     MOV [W14+6], W0
0025EA  E00000     CP0 W0
0025EC  3A0003     BRA NZ, 0x25F4
918:                               cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
0025EE  EB0000     CLR W0
0025F0  980740     MOV W0, [W14+8]
0025F2  37000A     BRA 0x2608
919:                           } else {                                            /* If p1_str_cmp_next NULL, ...                         */
920:                                                                               /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
921:                               cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
0025F4  90003E     MOV [W14+6], W0
0025F6  784010     MOV.B [W0], W0
0025F8  FB8000     ZE W0, W0
0025FA  EA0000     NEG W0, W0
0025FC  980740     MOV W0, [W14+8]
0025FE  370004     BRA 0x2608
922:                           }
923:                       } else {                                                /* If p2_str_cmp_next NULL, ...                         */
924:                           cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
002600  90002E     MOV [W14+4], W0
002602  784010     MOV.B [W0], W0
002604  FB8000     ZE W0, W0
002606  980740     MOV W0, [W14+8]
925:                       }
926:                   }
927:               
928:               
929:                   return (cmp_val);
002608  90004E     MOV [W14+8], W0
930:               }
00260A  FA8000     ULNK
00260C  060000     RETURN
931:               
932:               
933:               /*
934:               *********************************************************************************************************
935:               *                                         Str_CmpIgnoreCase()
936:               *
937:               * Description : Determine if two strings are identical, ignoring case.
938:               *
939:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
940:               *
941:               *               p2_str      Pointer to second string (see Note #1).
942:               *
943:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
944:               *
945:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
946:               *
947:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
948:               *
949:               *               See also Note #2b.
950:               *
951:               * Caller(s)   : Application.
952:               *
953:               * Note(s)     : (1) String buffers NOT modified.
954:               *
955:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
956:               *
957:               *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1'
958:               *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
959:               *                           (B) "ignoring differences in case".
960:               *
961:               *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
962:               *                            and then a byte comparison performed."
963:               *
964:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
965:               *                          "upon successful completion, strcasecmp() shall return an integer greater than,
966:               *                           equal to, or less than 0".
967:               *
968:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
969:               *                           sign of a non-zero return value shall be determined by the sign of the difference
970:               *                           between the values of the first pair of bytes ... that differ in the strings
971:               *                           being compared".
972:               *
973:               *               (3) String comparison terminates when :
974:               *
975:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
976:               *                               (1) NULL strings identical; 0 returned.
977:               *
978:               *                           (B) (1) 'p1_str' passed a NULL pointer.
979:               *                                   (a) Return negative value of character pointed to by 'p2_str', converted
980:               *                                       to lower case (see Note #2a2).
981:               *
982:               *                               (2) 'p2_str' passed a NULL pointer.
983:               *                                   (a) Return positive value of character pointed to by 'p1_str', converted
984:               *                                       to lower case (see Note #2a2).
985:               *
986:               *                       (2) (A) BOTH strings point to NULL.
987:               *                               (1) Strings overlap with NULL address.
988:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
989:               *                                   0 returned.
990:               *
991:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
992:               *                                   (a) 'p1_str' overlaps with NULL address.
993:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
994:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
995:               *                                       converted to lower case (see Note #2a2).
996:               *
997:               *                               (2) 'p2_str_cmp_next' points to NULL.
998:               *                                   (a) 'p2_str' overlaps with NULL address.
999:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1000:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1001:              *                                       converted to lower case (see Note #2a2).
1002:              *
1003:              *                   (b) Terminating NULL character found in both strings.
1004:              *                       (1) Strings identical; 0 returned.
1005:              *                       (2) Only one NULL character test required in conditional since previous condition
1006:              *                           tested character equality.
1007:              *
1008:              *                   (c) Non-matching characters found.
1009:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1010:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1011:              *                           to lower case.
1012:              *
1013:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1014:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1015:              *********************************************************************************************************
1016:              */
1017:              
1018:              CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
1019:                                             const  CPU_CHAR  *p2_str)
1020:              {
00260E  FA0006     LNK #0x6
002610  980710     MOV W0, [W14+2]
002612  980721     MOV W1, [W14+4]
1021:                  CPU_INT16S  cmp_val;
1022:              
1023:              
1024:                  cmp_val = Str_CmpIgnoreCase_N(p1_str,
002614  EB8100     SETM W2
002616  9000AE     MOV [W14+4], W1
002618  90001E     MOV [W14+2], W0
00261A  070004     RCALL Str_CmpIgnoreCase_N
00261C  780F00     MOV W0, [W14]
1025:                                                p2_str,
1026:                                                DEF_INT_CPU_U_MAX_VAL);
1027:              
1028:                  return (cmp_val);
00261E  78001E     MOV [W14], W0
1029:              }
002620  FA8000     ULNK
002622  060000     RETURN
1030:              
1031:              
1032:              /*
1033:              *********************************************************************************************************
1034:              *                                        Str_CmpIgnoreCase_N()
1035:              *
1036:              * Description : Determine if two strings are identical for up to a maximum number of characters,
1037:              *                   ignoring case.
1038:              *
1039:              * Argument(s) : p1_str      Pointer to first  string (see Note #1).
1040:              *
1041:              *               p2_str      Pointer to second string (see Note #1).
1042:              *
1043:              *               len_max     Maximum number of characters to compare  (see Note  #3d).
1044:              *
1045:              * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
1046:              *
1047:              *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
1048:              *
1049:              *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
1050:              *
1051:              *               See also Note #2b.
1052:              *
1053:              * Caller(s)   : Application.
1054:              *
1055:              * Note(s)     : (1) String buffers NOT modified.
1056:              *
1057:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
1058:              *
1059:              *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1'
1060:              *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
1061:              *                           (B) "ignoring differences in case"                           ...
1062:              *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
1063:              *
1064:              *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
1065:              *                            and then a byte comparison performed."
1066:              *
1067:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
1068:              *                          "upon successful completion, strncasecmp() shall return an integer greater than,
1069:              *                           equal to, or less than 0".
1070:              *
1071:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
1072:              *                           sign of a non-zero return value shall be determined by the sign of the difference
1073:              *                           between the values of the first pair of bytes ... that differ in the strings
1074:              *                           being compared".
1075:              *
1076:              *               (3) String comparison terminates when :
1077:              *
1078:              *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
1079:              *                               (1) NULL strings identical; 0 returned.
1080:              *
1081:              *                           (B) (1) 'p1_str' passed a NULL pointer.
1082:              *                                   (a) Return negative value of character pointed to by 'p2_str', converted
1083:              *                                       to lower case (see Note #2a2).
1084:              *
1085:              *                               (2) 'p2_str' passed a NULL pointer.
1086:              *                                   (a) Return positive value of character pointed to by 'p1_str', converted
1087:              *                                       to lower case (see Note #2a2).
1088:              *
1089:              *                       (2) (A) BOTH strings point to NULL.
1090:              *                               (1) Strings overlap with NULL address.
1091:              *                               (2) Strings identical up to but NOT beyond or including the NULL address;
1092:              *                                   0 returned.
1093:              *
1094:              *                           (B) (1) 'p1_str_cmp_next' points to NULL.
1095:              *                                   (a) 'p1_str' overlaps with NULL address.
1096:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1097:              *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
1098:              *                                       converted to lower case (see Note #2a2).
1099:              *
1100:              *                               (2) 'p2_str_cmp_next' points to NULL.
1101:              *                                   (a) 'p2_str' overlaps with NULL address.
1102:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1103:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1104:              *                                       converted to lower case (see Note #2a2).
1105:              *
1106:              *                   (b) Terminating NULL character found in both strings.
1107:              *                       (1) Strings identical; 0 returned.
1108:              *                       (2) Only one NULL character test required in conditional since previous condition
1109:              *                           tested character equality.
1110:              *
1111:              *                   (c) Non-matching characters found.
1112:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1113:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1114:              *                           to lower case.
1115:              *
1116:              *                   (d) (1) 'len_max' passed a zero length.
1117:              *                           (A) Zero-length strings identical; 0 returned.
1118:              *
1119:              *                       (2) First 'len_max' number of characters identical.
1120:              *                           (A) Strings identical; 0 returned.
1121:              *
1122:              *                       See also Note #2a1C.
1123:              *$PAGE*
1124:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1125:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1126:              *********************************************************************************************************
1127:              */
1128:              
1129:              CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
1130:                                               const  CPU_CHAR    *p2_str,
1131:                                                      CPU_SIZE_T   len_max)
1132:              {
002624  FA0014     LNK #0x14
002626  980770     MOV W0, [W14+14]
002628  980F01     MOV W1, [W14+16]
00262A  980F12     MOV W2, [W14+18]
1133:                  const  CPU_CHAR    *p1_str_cmp;
1134:                  const  CPU_CHAR    *p2_str_cmp;
1135:                  const  CPU_CHAR    *p1_str_cmp_next;
1136:                  const  CPU_CHAR    *p2_str_cmp_next;
1137:                         CPU_CHAR     char_1;
1138:                         CPU_CHAR     char_2;
1139:                         CPU_INT16S   cmp_val;
1140:                         CPU_SIZE_T   cmp_len;
1141:              
1142:              
1143:                  if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
00262C  90081E     MOV [W14+18], W0
00262E  E00000     CP0 W0
002630  3A0002     BRA NZ, 0x2636
1144:                      return (0);
002632  EB0000     CLR W0
002634  37008F     BRA 0x2754
1145:                  }
1146:              
1147:                  if (p1_str == (const CPU_CHAR *)0) {
002636  90007E     MOV [W14+14], W0
002638  E00000     CP0 W0
00263A  3A000F     BRA NZ, 0x265A
1148:                      if (p2_str == (const CPU_CHAR *)0) {
00263C  90080E     MOV [W14+16], W0
00263E  E00000     CP0 W0
002640  3A0002     BRA NZ, 0x2646
1149:                          return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
002642  EB0000     CLR W0
002644  370087     BRA 0x2754
1150:                      }
1151:                      char_2  =  ASCII_ToLower(*p2_str);
002646  90080E     MOV [W14+16], W0
002648  784010     MOV.B [W0], W0
00264A  071F0E     RCALL ASCII_ToLower
00264C  984F10     MOV.B W0, [W14+9]
1152:                      cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
00264E  90481E     MOV.B [W14+9], W0
002650  FB8000     ZE W0, W0
002652  EA0000     NEG W0, W0
002654  980750     MOV W0, [W14+10]
1153:                      return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
002656  90005E     MOV [W14+10], W0
002658  37007D     BRA 0x2754
1154:                  }
1155:                  if (p2_str == (const CPU_CHAR *)0) {
00265A  90080E     MOV [W14+16], W0
00265C  E00000     CP0 W0
00265E  3A0009     BRA NZ, 0x2672
1156:                      char_1  =  ASCII_ToLower(*p1_str);
002660  90007E     MOV [W14+14], W0
002662  784010     MOV.B [W0], W0
002664  071F01     RCALL ASCII_ToLower
002666  984F00     MOV.B W0, [W14+8]
1157:                      cmp_val = (CPU_INT16S)char_1;
002668  90480E     MOV.B [W14+8], W0
00266A  FB8000     ZE W0, W0
00266C  980750     MOV W0, [W14+10]
1158:                      return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
00266E  90005E     MOV [W14+10], W0
002670  370071     BRA 0x2754
1159:                  }
1160:              
1161:              
1162:                  p1_str_cmp      = p1_str;
002672  9000FE     MOV [W14+14], W1
002674  780F01     MOV W1, [W14]
1163:                  p2_str_cmp      = p2_str;
002676  90088E     MOV [W14+16], W1
002678  980711     MOV W1, [W14+2]
1164:                  p1_str_cmp_next = p1_str_cmp;
00267A  78009E     MOV [W14], W1
00267C  980721     MOV W1, [W14+4]
1165:                  p2_str_cmp_next = p2_str_cmp;
00267E  90009E     MOV [W14+2], W1
002680  980731     MOV W1, [W14+6]
1166:                  p1_str_cmp_next++;
002682  90002E     MOV [W14+4], W0
002684  E80000     INC W0, W0
002686  980720     MOV W0, [W14+4]
1167:                  p2_str_cmp_next++;
002688  90003E     MOV [W14+6], W0
00268A  E80000     INC W0, W0
00268C  980730     MOV W0, [W14+6]
1168:                  char_1          = ASCII_ToLower(*p1_str_cmp);
00268E  78001E     MOV [W14], W0
002690  784010     MOV.B [W0], W0
002692  071EEA     RCALL ASCII_ToLower
002694  984F00     MOV.B W0, [W14+8]
1169:                  char_2          = ASCII_ToLower(*p2_str_cmp);
002696  90001E     MOV [W14+2], W0
002698  784010     MOV.B [W0], W0
00269A  071EE6     RCALL ASCII_ToLower
00269C  984F10     MOV.B W0, [W14+9]
1170:                  cmp_len         = 0u;
00269E  EB0000     CLR W0
0026A0  980760     MOV W0, [W14+12]
1171:              
1172:                  while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
0026A2  370015     BRA 0x26CE
0026CE  90488E     MOV.B [W14+8], W1
0026D0  90481E     MOV.B [W14+9], W0
0026D2  50CF80     SUB.B W1, W0, [W15]
0026D4  3A000E     BRA NZ, 0x26F2
0026DA  E00400     CP0.B W0
0026DC  32000A     BRA Z, 0x26F2
1173:                         (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
0026D6  78001E     MOV [W14], W0
0026D8  784010     MOV.B [W0], W0
0026DE  90002E     MOV [W14+4], W0
0026E0  E00000     CP0 W0
0026E2  320007     BRA Z, 0x26F2
1174:                         ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
0026E4  90003E     MOV [W14+6], W0
0026E6  E00000     CP0 W0
0026E8  320004     BRA Z, 0x26F2
1175:                         ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
0026EA  9000EE     MOV [W14+12], W1
0026EC  90081E     MOV [W14+18], W0
0026EE  508F80     SUB W1, W0, [W15]
0026F0  39FFD9     BRA NC, 0x26A4
1176:                         ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
1177:                      p1_str_cmp++;
0026A4  E80F1E     INC [W14], [W14]
1178:                      p2_str_cmp++;
0026A6  90001E     MOV [W14+2], W0
0026A8  E80000     INC W0, W0
0026AA  980710     MOV W0, [W14+2]
1179:                      p1_str_cmp_next++;
0026AC  90002E     MOV [W14+4], W0
0026AE  E80000     INC W0, W0
0026B0  980720     MOV W0, [W14+4]
1180:                      p2_str_cmp_next++;
0026B2  90003E     MOV [W14+6], W0
0026B4  E80000     INC W0, W0
0026B6  980730     MOV W0, [W14+6]
1181:                      cmp_len++;
0026B8  90006E     MOV [W14+12], W0
0026BA  E80000     INC W0, W0
0026BC  980760     MOV W0, [W14+12]
1182:                      char_1 = ASCII_ToLower(*p1_str_cmp);
0026BE  78001E     MOV [W14], W0
0026C0  784010     MOV.B [W0], W0
0026C2  071ED2     RCALL ASCII_ToLower
0026C4  984F00     MOV.B W0, [W14+8]
1183:                      char_2 = ASCII_ToLower(*p2_str_cmp);
0026C6  90001E     MOV [W14+2], W0
0026C8  784010     MOV.B [W0], W0
0026CA  071ECE     RCALL ASCII_ToLower
0026CC  984F10     MOV.B W0, [W14+9]
1184:                  }
1185:              
1186:              
1187:                  if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
0026F2  9000EE     MOV [W14+12], W1
0026F4  90081E     MOV [W14+18], W0
0026F6  508F80     SUB W1, W0, [W15]
0026F8  3A0002     BRA NZ, 0x26FE
1188:                      return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
0026FA  EB0000     CLR W0
0026FC  37002B     BRA 0x2754
1189:                  }
1190:              
1191:                  if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
0026FE  90488E     MOV.B [W14+8], W1
002700  90481E     MOV.B [W14+9], W0
002702  50CF80     SUB.B W1, W0, [W15]
002704  320007     BRA Z, 0x2714
1192:                                                                              /* ... calc & rtn char diff  (see Note #3c1).           */
1193:                       cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
002706  90480E     MOV.B [W14+8], W0
002708  FB8080     ZE W0, W1
00270A  90481E     MOV.B [W14+9], W0
00270C  FB8000     ZE W0, W0
00270E  508000     SUB W1, W0, W0
002710  980750     MOV W0, [W14+10]
002712  37001F     BRA 0x2752
1194:              
1195:                  } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
002714  90480E     MOV.B [W14+8], W0
002716  E00400     CP0.B W0
002718  3A0003     BRA NZ, 0x2720
1196:                       cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
00271A  EB0000     CLR W0
00271C  980750     MOV W0, [W14+10]
00271E  370019     BRA 0x2752
1197:              
1198:                  } else {
1199:                      if (p1_str_cmp_next == (const CPU_CHAR *)0) {
002720  90002E     MOV [W14+4], W0
002722  E00000     CP0 W0
002724  3A000F     BRA NZ, 0x2744
1200:                          if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
002726  90003E     MOV [W14+6], W0
002728  E00000     CP0 W0
00272A  3A0003     BRA NZ, 0x2732
1201:                              cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
00272C  EB0000     CLR W0
00272E  980750     MOV W0, [W14+10]
002730  370010     BRA 0x2752
1202:                          } else {                                            /* If p1_str_cmp_next NULL, ...                         */
1203:                              char_2  =  ASCII_ToLower(*p2_str_cmp_next);
002732  90003E     MOV [W14+6], W0
002734  784010     MOV.B [W0], W0
002736  071E98     RCALL ASCII_ToLower
002738  984F10     MOV.B W0, [W14+9]
1204:                                                                              /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
1205:                              cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
00273A  90481E     MOV.B [W14+9], W0
00273C  FB8000     ZE W0, W0
00273E  EA0000     NEG W0, W0
002740  980750     MOV W0, [W14+10]
002742  370007     BRA 0x2752
1206:                          }
1207:                      } else {                                                /* If p2_str_cmp_next NULL, ...                         */
1208:                          char_1  =  ASCII_ToLower(*p1_str_cmp_next);
002744  90002E     MOV [W14+4], W0
002746  784010     MOV.B [W0], W0
002748  071E8F     RCALL ASCII_ToLower
00274A  984F00     MOV.B W0, [W14+8]
1209:                          cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
00274C  90480E     MOV.B [W14+8], W0
00274E  FB8000     ZE W0, W0
002750  980750     MOV W0, [W14+10]
1210:                      }
1211:                  }
1212:              
1213:              
1214:                  return (cmp_val);
002752  90005E     MOV [W14+10], W0
1215:              }
002754  FA8000     ULNK
002756  060000     RETURN
1216:              
1217:              
1218:              /*
1219:              *********************************************************************************************************
1220:              *                                             Str_Char()
1221:              *
1222:              * Description : Search string for first occurrence of specific character.
1223:              *
1224:              * Argument(s) : pstr            Pointer to string (see Note #1).
1225:              *
1226:              *               srch_char       Search character.
1227:              *
1228:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1229:              *
1230:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1231:              *
1232:              * Caller(s)   : Application.
1233:              *
1234:              * Note(s)     : (1) String buffer NOT modified.
1235:              *
1236:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1237:              *
1238:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1239:              *                            ... in the string pointed to by 's' ('pstr')."
1240:              *                       (2) "The terminating null byte is considered to be part of the string."
1241:              *
1242:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1243:              *                       "upon completion, strchr() shall return" :
1244:              *
1245:              *                       (1) "a pointer to the byte," ...
1246:              *                       (2) "or a null pointer if the byte was not found."
1247:              *                           (A) #### Although NO strchr() specification states to return NULL for
1248:              *                               any other reason(s), NULL is also returned for any error(s).
1249:              *
1250:              *               (3) String search terminates when :
1251:              *
1252:              *                   (a) String pointer passed a NULL pointer.
1253:              *                       (1) No string search performed; NULL pointer returned.
1254:              *
1255:              *                   (b) String pointer points to NULL.
1256:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1257:              *
1258:              *                   (c) String's terminating NULL character found.
1259:              *                       (1) Search character NOT found in search string; NULL pointer returned
1260:              *                           (see Note #2b2).
1261:              *                       (2) Applicable even if search character is the terminating NULL character
1262:              *                           (see Note #2a2).
1263:              *
1264:              *                   (d) Search character found.
1265:              *                       (1) Return pointer to first occurrence of search character in search string
1266:              *                           (see Note #2a1).
1267:              *********************************************************************************************************
1268:              */
1269:              
1270:              CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
1271:                                          CPU_CHAR   srch_char)
1272:              {
002758  FA0006     LNK #0x6
00275A  980710     MOV W0, [W14+2]
00275C  984741     MOV.B W1, [W14+4]
1273:                  CPU_CHAR  *pstr_rtn;
1274:              
1275:              
1276:                  pstr_rtn = Str_Char_N(pstr,
00275E  90414E     MOV.B [W14+4], W2
002760  EB8080     SETM W1
002762  90001E     MOV [W14+2], W0
002764  070004     RCALL Str_Char_N
002766  780F00     MOV W0, [W14]
1277:                                        DEF_INT_CPU_U_MAX_VAL,
1278:                                        srch_char);
1279:              
1280:                  return (pstr_rtn);
002768  78001E     MOV [W14], W0
1281:              }
00276A  FA8000     ULNK
00276C  060000     RETURN
1282:              
1283:              
1284:              /*
1285:              *********************************************************************************************************
1286:              *                                            Str_Char_N()
1287:              *
1288:              * Description : Search string for first occurrence of specific character, up to a maximum number
1289:              *                   of characters.
1290:              *
1291:              * Argument(s) : pstr            Pointer to string (see Note #1).
1292:              *
1293:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1294:              *
1295:              *               srch_char       Search character.
1296:              *
1297:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1298:              *
1299:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1300:              *
1301:              * Caller(s)   : Application.
1302:              *
1303:              * Note(s)     : (1) String buffer NOT modified.
1304:              *
1305:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1306:              *
1307:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1308:              *                            ... in the string pointed to by 's' ('pstr')."
1309:              *                       (2) "The terminating null byte is considered to be part of the string."
1310:              *
1311:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1312:              *                       "upon completion, strchr() shall return" :
1313:              *
1314:              *                       (1) "a pointer to the byte," ...
1315:              *                       (2) "or a null pointer if the byte was not found."
1316:              *                           (A) #### Although NO strchr() specification states to return NULL for
1317:              *                               any other reason(s), NULL is also returned for any error(s).
1318:              *
1319:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1320:              *                       argument list for consistency with all other custom string library functions.
1321:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1322:              *                       to comply with most standard library's strnchr() argument list.
1323:              *
1324:              *               (3) String search terminates when :
1325:              *
1326:              *                   (a) String pointer passed a NULL pointer.
1327:              *                       (1) No string search performed; NULL pointer returned.
1328:              *
1329:              *                   (b) String pointer points to NULL.
1330:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1331:              *
1332:              *                   (c) String's terminating NULL character found.
1333:              *                       (1) Search character NOT found in search string; NULL pointer returned
1334:              *                           (see Note #2b2).
1335:              *                       (2) Applicable even if search character is the terminating NULL character
1336:              *                           (see Note #2a2).
1337:              *
1338:              *                   (d) Search character found.
1339:              *                       (1) Return pointer to first occurrence of search character in search string
1340:              *                           (see Note #2a1).
1341:              *
1342:              *                   (e) 'len_max' number of characters searched.
1343:              *                       (1) Search character NOT found in search string within first 'len_max' number
1344:              *                           of characters; NULL pointer returned.
1345:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1346:              *                           (see Note #2a2).
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
1351:                                            CPU_SIZE_T   len_max,
1352:                                            CPU_CHAR     srch_char)
1353:              {
00276E  FA000A     LNK #0xA
002770  980720     MOV W0, [W14+4]
002772  980731     MOV W1, [W14+6]
002774  984F02     MOV.B W2, [W14+8]
1354:                  const  CPU_CHAR    *pstr_char;
1355:                         CPU_SIZE_T   len_srch;
1356:              
1357:              
1358:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
002776  90002E     MOV [W14+4], W0
002778  E00000     CP0 W0
00277A  3A0002     BRA NZ, 0x2780
1359:                      return ((CPU_CHAR *)0);
00277C  EB0000     CLR W0
00277E  370031     BRA 0x27E2
1360:                  }
1361:              
1362:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
002780  90003E     MOV [W14+6], W0
002782  E00000     CP0 W0
002784  3A0002     BRA NZ, 0x278A
1363:                      return ((CPU_CHAR *)0);
002786  EB0000     CLR W0
002788  37002C     BRA 0x27E2
1364:                  }
1365:              
1366:              
1367:                  pstr_char = pstr;
00278A  9000AE     MOV [W14+4], W1
00278C  780F01     MOV W1, [W14]
1368:                  len_srch  = 0u;
00278E  EB0000     CLR W0
002790  980710     MOV W0, [W14+2]
1369:              
1370:                  while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
002792  370004     BRA 0x279C
00279C  78001E     MOV [W14], W0
00279E  E00000     CP0 W0
0027A0  32000D     BRA Z, 0x27BC
0027A6  E00400     CP0.B W0
0027A8  320009     BRA Z, 0x27BC
1371:                         (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
0027A2  78001E     MOV [W14], W0
0027A4  784010     MOV.B [W0], W0
0027AE  90480E     MOV.B [W14+8], W0
0027B0  50CF80     SUB.B W1, W0, [W15]
0027B2  320004     BRA Z, 0x27BC
1372:                         (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
0027AA  78001E     MOV [W14], W0
0027AC  784090     MOV.B [W0], W1
0027B4  90009E     MOV [W14+2], W1
0027B6  90003E     MOV [W14+6], W0
0027B8  508F80     SUB W1, W0, [W15]
0027BA  39FFEC     BRA NC, 0x2794
1373:                         ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
1374:                      pstr_char++;
002794  E80F1E     INC [W14], [W14]
1375:                      len_srch++;
002796  90001E     MOV [W14+2], W0
002798  E80000     INC W0, W0
00279A  980710     MOV W0, [W14+2]
1376:                  }
1377:              
1378:              
1379:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
0027BC  78001E     MOV [W14], W0
0027BE  E00000     CP0 W0
0027C0  3A0002     BRA NZ, 0x27C6
1380:                      return ((CPU_CHAR *)0);
0027C2  EB0000     CLR W0
0027C4  37000E     BRA 0x27E2
1381:                  }
1382:              
1383:                  if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
0027C6  90009E     MOV [W14+2], W1
0027C8  90003E     MOV [W14+6], W0
0027CA  508F80     SUB W1, W0, [W15]
0027CC  390002     BRA NC, 0x27D2
1384:                      return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
0027CE  EB0000     CLR W0
0027D0  370008     BRA 0x27E2
1385:                  }
1386:              
1387:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
0027D2  78001E     MOV [W14], W0
0027D4  784090     MOV.B [W0], W1
0027D6  90480E     MOV.B [W14+8], W0
0027D8  50CF80     SUB.B W1, W0, [W15]
0027DA  320002     BRA Z, 0x27E0
1388:                       return ((CPU_CHAR *)0);
0027DC  EB0000     CLR W0
0027DE  370001     BRA 0x27E2
1389:                  }
1390:              
1391:              
1392:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
0027E0  78001E     MOV [W14], W0
1393:              }
0027E2  FA8000     ULNK
0027E4  060000     RETURN
1394:              
1395:              
1396:              /*
1397:              *********************************************************************************************************
1398:              *                                           Str_Char_Last()
1399:              *
1400:              * Description : Search string for last occurrence of specific character.
1401:              *
1402:              * Argument(s) : pstr            Pointer to string (see Note #1).
1403:              *
1404:              *               srch_char       Search character.
1405:              *
1406:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1407:              *
1408:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1409:              *
1410:              * Caller(s)   : Application.
1411:              *
1412:              * Note(s)     : (1) String buffer NOT modified.
1413:              *
1414:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1415:              *
1416:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1417:              *                            ... in the string pointed to by 's' ('pstr')."
1418:              *                       (2) "The terminating null byte is considered to be part of the string."
1419:              *
1420:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1421:              *                       "upon successful completion, strrchr() shall return" :
1422:              *
1423:              *                       (1) "a pointer to the byte" ...
1424:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1425:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1426:              *                               any other reason(s), NULL is also returned for any error(s).
1427:              *
1428:              *               (3) String search terminates when :
1429:              *
1430:              *                   (a) String pointer passed a NULL pointer.
1431:              *                       (1) No string search performed; NULL pointer returned.
1432:              *
1433:              *                   (b) String pointer points to NULL.
1434:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1435:              *
1436:              *                   (c) String searched from end to beginning.
1437:              *                       (1) Search character NOT found in search string; NULL pointer returned.
1438:              *                       (2) Applicable even if search character is the terminating NULL character
1439:              *                           (see Note #2a2).
1440:              *
1441:              *                   (d) Search character found.
1442:              *                       (1) Return pointer to last occurrence of search character in search string
1443:              *                           (see Note #2a1).
1444:              *********************************************************************************************************
1445:              */
1446:              
1447:              CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
1448:                                               CPU_CHAR   srch_char)
1449:              {
0027E6  FA0006     LNK #0x6
0027E8  980710     MOV W0, [W14+2]
0027EA  984741     MOV.B W1, [W14+4]
1450:                  CPU_CHAR  *pstr_rtn;
1451:              
1452:              
1453:                  pstr_rtn = Str_Char_Last_N(pstr,
0027EC  90414E     MOV.B [W14+4], W2
0027EE  EB8080     SETM W1
0027F0  90001E     MOV [W14+2], W0
0027F2  070004     RCALL Str_Char_Last_N
0027F4  780F00     MOV W0, [W14]
1454:                                             DEF_INT_CPU_U_MAX_VAL,
1455:                                             srch_char);
1456:              
1457:                  return (pstr_rtn);
0027F6  78001E     MOV [W14], W0
1458:              }
0027F8  FA8000     ULNK
0027FA  060000     RETURN
1459:              
1460:              
1461:              /*
1462:              *********************************************************************************************************
1463:              *                                          Str_Char_Last_N()
1464:              *
1465:              * Description : Search string for last occurrence of specific character, up to a maximum number
1466:              *                   of characters.
1467:              *
1468:              * Argument(s) : pstr            Pointer to string (see Note #1).
1469:              *
1470:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1471:              *
1472:              *               srch_char       Search character.
1473:              *
1474:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1475:              *
1476:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1477:              *
1478:              * Caller(s)   : Application.
1479:              *
1480:              * Note(s)     : (1) String buffer NOT modified.
1481:              *
1482:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1483:              *
1484:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1485:              *                            ... in the string pointed to by 's' ('pstr')."
1486:              *                       (2) "The terminating null byte is considered to be part of the string."
1487:              *
1488:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1489:              *                       "upon successful completion, strrchr() shall return" :
1490:              *
1491:              *                       (1) "a pointer to the byte" ...
1492:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1493:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1494:              *                               any other reason(s), NULL is also returned for any error(s).
1495:              *
1496:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1497:              *                       argument list for consistency with all other custom string library functions.
1498:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1499:              *                       to comply with most standard library's strnrchr() argument list.
1500:              *
1501:              *                       See also 'Str_Char_N()  Note #2c'.
1502:              *
1503:              *               (3) String search terminates when :
1504:              *
1505:              *                   (a) String pointer passed a NULL pointer.
1506:              *                       (1) No string search performed; NULL pointer returned.
1507:              *
1508:              *                   (b) String pointer points to NULL.
1509:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1510:              *
1511:              *                   (c) String searched from end to beginning.
1512:              *                       (1) Search character NOT found in search string; NULL pointer returned
1513:              *                           (see Note #2b2).
1514:              *                       (2) Applicable even if search character is the terminating NULL character
1515:              *                           (see Note #2a2).
1516:              *
1517:              *                   (d) Search character found.
1518:              *                       (1) Return pointer to last occurrence of search character in search string
1519:              *                           (see Note #2a1).
1520:              *
1521:              *                   (e) 'len_max' number of characters searched.
1522:              *                       (1) Search character NOT found in search string within last 'len_max' number
1523:              *                           of characters; NULL pointer returned.
1524:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1525:              *                           (see Note #2a2).
1526:              *********************************************************************************************************
1527:              */
1528:              
1529:              CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
1530:                                                 CPU_SIZE_T   len_max,
1531:                                                 CPU_CHAR     srch_char)
1532:              {
0027FC  FA000C     LNK #0xC
0027FE  980730     MOV W0, [W14+6]
002800  980741     MOV W1, [W14+8]
002802  984F22     MOV.B W2, [W14+10]
1533:                  const  CPU_CHAR    *pstr_char;
1534:                         CPU_SIZE_T   str_len_max;
1535:                         CPU_SIZE_T   str_len;
1536:              
1537:              
1538:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
002804  90003E     MOV [W14+6], W0
002806  E00000     CP0 W0
002808  3A0002     BRA NZ, 0x280E
1539:                      return ((CPU_CHAR *)0);
00280A  EB0000     CLR W0
00280C  370027     BRA 0x285C
1540:                  }
1541:              
1542:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
00280E  90004E     MOV [W14+8], W0
002810  E00000     CP0 W0
002812  3A0002     BRA NZ, 0x2818
1543:                      return ((CPU_CHAR *)0);
002814  EB0000     CLR W0
002816  370022     BRA 0x285C
1544:                  }
1545:              
1546:              
1547:                  pstr_char    = pstr;
002818  9000BE     MOV [W14+6], W1
00281A  780F01     MOV W1, [W14]
1548:                   str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
00281C  90004E     MOV [W14+8], W0
00281E  E90000     DEC W0, W0
002820  980710     MOV W0, [W14+2]
1549:                   str_len     = Str_Len_N(pstr_char, str_len_max);
002822  90009E     MOV [W14+2], W1
002824  78001E     MOV [W14], W0
002826  07FDA4     RCALL Str_Len_N
002828  980720     MOV W0, [W14+4]
1550:                  pstr_char   += str_len;
00282A  90002E     MOV [W14+4], W0
00282C  400F1E     ADD W0, [W14], [W14]
1551:              
1552:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
00282E  78001E     MOV [W14], W0
002830  E00000     CP0 W0
002832  3A0003     BRA NZ, 0x283A
1553:                      return ((CPU_CHAR *)0);
002834  EB0000     CLR W0
002836  370012     BRA 0x285C
1554:                  }
1555:              
1556:                  while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
00283A  90003E     MOV [W14+6], W0
00283C  78009E     MOV [W14], W1
00283E  508F80     SUB W1, W0, [W15]
002840  320005     BRA Z, 0x284C
002846  90482E     MOV.B [W14+10], W0
002848  50CF80     SUB.B W1, W0, [W15]
00284A  3AFFF6     BRA NZ, 0x2838
1557:                         (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
002842  78001E     MOV [W14], W0
002844  784090     MOV.B [W0], W1
1558:                      pstr_char--;
002838  E90F1E     DEC [W14], [W14]
1559:                  }
1560:              
1561:              
1562:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
00284C  78001E     MOV [W14], W0
00284E  784090     MOV.B [W0], W1
002850  90482E     MOV.B [W14+10], W0
002852  50CF80     SUB.B W1, W0, [W15]
002854  320002     BRA Z, 0x285A
1563:                       return ((CPU_CHAR *)0);
002856  EB0000     CLR W0
002858  370001     BRA 0x285C
1564:                  }
1565:              
1566:              
1567:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
00285A  78001E     MOV [W14], W0
1568:              }
00285C  FA8000     ULNK
00285E  060000     RETURN
1569:              
1570:              
1571:              /*
1572:              *********************************************************************************************************
1573:              *                                         Str_Char_Replace()
1574:              *
1575:              * Description : Search string for specific character and replace it by another specific character.
1576:              *
1577:              * Argument(s) : pstr            Pointer to string (see Note #1).
1578:              *
1579:              *               char_srch       Search character.
1580:              *
1581:              *               char_replace    Replace character.
1582:              *
1583:              * Return(s)   : Pointer to string, if NO error(s).
1584:              *
1585:              *               Pointer to NULL,   otherwise.
1586:              *
1587:              * Caller(s)   : Application.
1588:              *
1589:              * Note(s)     : (1) String buffer modified.
1590:              *
1591:              *               (2) String search terminates when :
1592:              *
1593:              *                   (a) String pointer passed a NULL pointer.
1594:              *                       (1) No string search performed; NULL pointer returned.
1595:              *
1596:              *                   (b) String pointer points to NULL.
1597:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1598:              *
1599:              *                   (c) String's terminating NULL character found.
1600:              *                       (1) Search character NOT found in search string; NULL pointer returned
1601:              *                       (2) Applicable even if search character is the terminating NULL character
1602:              *
1603:              *                   (d) Search character found.
1604:              *                       (1) Replace character found by the specified character.
1605:              *********************************************************************************************************
1606:              */
1607:              
1608:              CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
1609:                                           CPU_CHAR   char_srch,
1610:                                           CPU_CHAR   char_replace)
1611:              {
002860  FA0006     LNK #0x6
002862  980710     MOV W0, [W14+2]
002864  984741     MOV.B W1, [W14+4]
002866  984752     MOV.B W2, [W14+5]
1612:                  CPU_CHAR  *pstr_rtn;
1613:              
1614:              
1615:                  pstr_rtn = Str_Char_Replace_N(pstr,
002868  EB8180     SETM W3
00286A  90415E     MOV.B [W14+5], W2
00286C  9040CE     MOV.B [W14+4], W1
00286E  90001E     MOV [W14+2], W0
002870  070004     RCALL Str_Char_Replace_N
002872  780F00     MOV W0, [W14]
1616:                                                char_srch,
1617:                                                char_replace,
1618:                                                DEF_INT_CPU_U_MAX_VAL);
1619:              
1620:                  return (pstr_rtn);
002874  78001E     MOV [W14], W0
1621:              }
002876  FA8000     ULNK
002878  060000     RETURN
1622:              
1623:              
1624:              /*
1625:              *********************************************************************************************************
1626:              *                                        Str_Char_Replace_N()
1627:              *
1628:              * Description : Search string for specific character and replace it by another specific character, up to
1629:              *               a maximum number of characters.
1630:              *
1631:              * Argument(s) : pstr            Pointer to string (see Note #1).
1632:              *
1633:              *               char_srch       Search character.
1634:              *
1635:              *               char_replace    Replace character.
1636:              *
1637:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1638:              *
1639:              * Return(s)   : Pointer to string, if NO error(s).
1640:              *
1641:              *               Pointer to NULL,   otherwise.
1642:              *
1643:              * Caller(s)   : Application.
1644:              *
1645:              * Note(s)     : (1) String buffer modified.
1646:              *
1647:              *               (2) String search terminates when :
1648:              *
1649:              *                   (a) String pointer passed a NULL pointer.
1650:              *                       (1) No string search performed; NULL pointer returned.
1651:              *
1652:              *                   (b) String pointer points to NULL.
1653:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1654:              *
1655:              *                   (c) String's terminating NULL character found.
1656:              *                       (1) Search character NOT found in search string; NULL pointer returned
1657:              *                       (2) Applicable even if search character is the terminating NULL character
1658:              *
1659:              *                   (d) Search character found.
1660:              *                       (1) Replace character found by the specified character.
1661:              *
1662:              *                   (e) 'len_max' number of characters searched.
1663:              *                       (1) Search character NOT found in search string within first 'len_max' number
1664:              *                           of characters; NULL pointer returned.
1665:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1666:              *                           (see Note #2a2).
1667:              *********************************************************************************************************
1668:              */
1669:              
1670:              CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
1671:                                             CPU_CHAR     char_srch,
1672:                                             CPU_CHAR     char_replace,
1673:                                             CPU_SIZE_T   len_max)
1674:              {
00287A  FA000A     LNK #0xA
00287C  980720     MOV W0, [W14+4]
00287E  984761     MOV.B W1, [W14+6]
002880  984772     MOV.B W2, [W14+7]
002882  980743     MOV W3, [W14+8]
1675:                  CPU_CHAR    *pstr_char;
1676:                  CPU_SIZE_T   len;
1677:              
1678:              
1679:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
002884  90002E     MOV [W14+4], W0
002886  E00000     CP0 W0
002888  3A0002     BRA NZ, 0x288E
1680:                      return ((CPU_CHAR *)0);
00288A  EB0000     CLR W0
00288C  370021     BRA 0x28D0
1681:                  }
1682:              
1683:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
00288E  90004E     MOV [W14+8], W0
002890  E00000     CP0 W0
002892  3A0002     BRA NZ, 0x2898
1684:                      return ((CPU_CHAR *)0);
002894  EB0000     CLR W0
002896  37001C     BRA 0x28D0
1685:                  }
1686:              
1687:                  pstr_char = pstr;
002898  9000AE     MOV [W14+4], W1
00289A  780F01     MOV W1, [W14]
1688:                  len       = len_max;
00289C  9000CE     MOV [W14+8], W1
00289E  980711     MOV W1, [W14+2]
1689:              
1690:                  while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
0028A0  37000C     BRA 0x28BA
0028BA  78001E     MOV [W14], W0
0028BC  E00000     CP0 W0
0028BE  320007     BRA Z, 0x28CE
0028C4  E00400     CP0.B W0
0028C6  320003     BRA Z, 0x28CE
1691:                         (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
0028C0  78001E     MOV [W14], W0
0028C2  784010     MOV.B [W0], W0
0028C8  90001E     MOV [W14+2], W0
0028CA  E00000     CP0 W0
0028CC  3AFFEA     BRA NZ, 0x28A2
1692:                         ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
1693:              
1694:                      if (*pstr_char == char_srch) {
0028A2  78001E     MOV [W14], W0
0028A4  784090     MOV.B [W0], W1
0028A6  90406E     MOV.B [W14+6], W0
0028A8  50CF80     SUB.B W1, W0, [W15]
0028AA  3A0003     BRA NZ, 0x28B2
1695:                          *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
0028AC  78001E     MOV [W14], W0
0028AE  9040FE     MOV.B [W14+7], W1
0028B0  784801     MOV.B W1, [W0]
1696:                      }
1697:              
1698:                      pstr_char++;
0028B2  E80F1E     INC [W14], [W14]
1699:                      len--;
0028B4  90001E     MOV [W14+2], W0
0028B6  E90000     DEC W0, W0
0028B8  980710     MOV W0, [W14+2]
1700:                  }
1701:              
1702:                  return (pstr);
0028CE  90002E     MOV [W14+4], W0
1703:              }
0028D0  FA8000     ULNK
0028D2  060000     RETURN
1704:              
1705:              
1706:              /*
1707:              *********************************************************************************************************
1708:              *                                              Str_Str()
1709:              *
1710:              * Description : Search string for first occurence of a specific search string.
1711:              *
1712:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1713:              *
1714:              *               pstr_srch       Pointer to search string (see Note #1).
1715:              *
1716:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1717:              *
1718:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1719:              *
1720:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1721:              *
1722:              * Caller(s)   : Application.
1723:              *
1724:              * Note(s)     : (1) String buffers NOT modified.
1725:              *
1726:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1727:              *
1728:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1729:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1730:              *                            pointed to by 's2' ('pstr_srch')" ...
1731:              *                       (2) "(excluding the terminating null byte)."
1732:              *
1733:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1734:              *
1735:              *                       (1) "Upon successful completion, strstr() shall return" :
1736:              *                           (A) "a pointer to the located string" ...
1737:              *                           (B) "or a null pointer if the string is not found."
1738:              *                               (1) #### Although NO strstr() specification states to return NULL for
1739:              *                                   any other reason(s), NULL is also returned for any error(s).
1740:              *
1741:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1742:              *                            shall return 's1' ('pstr')."
1743:              *
1744:              *               (3) String search terminates when :
1745:              *
1746:              *                   (a) String pointer(s) are passed NULL pointers.
1747:              *                       (1) No string search performed; NULL pointer returned.
1748:              *
1749:              *                   (b) String pointer(s) point to NULL.
1750:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1751:              *
1752:              *                   (c) Search string length equal to zero.
1753:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1754:              *
1755:              *                   (d) Search string length greater than string length.
1756:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1757:              *
1758:              *                   (e) Entire string has been searched.
1759:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1760:              *
1761:              *                   (f) Search string found.
1762:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1763:              *********************************************************************************************************
1764:              */
1765:              
1766:              CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
1767:                                  const  CPU_CHAR  *pstr_srch)
1768:              {
0028D4  FA0006     LNK #0x6
0028D6  980710     MOV W0, [W14+2]
0028D8  980721     MOV W1, [W14+4]
1769:                  CPU_CHAR  *pstr_rtn;
1770:              
1771:              
1772:                  pstr_rtn = Str_Str_N(pstr,
0028DA  EB8100     SETM W2
0028DC  9000AE     MOV [W14+4], W1
0028DE  90001E     MOV [W14+2], W0
0028E0  070004     RCALL Str_Str_N
0028E2  780F00     MOV W0, [W14]
1773:                                       pstr_srch,
1774:                                       DEF_INT_CPU_U_MAX_VAL);
1775:              
1776:                  return (pstr_rtn);
0028E4  78001E     MOV [W14], W0
1777:              }
0028E6  FA8000     ULNK
0028E8  060000     RETURN
1778:              
1779:              
1780:              /*
1781:              *********************************************************************************************************
1782:              *                                             Str_Str_N()
1783:              *
1784:              * Description : Search string for first occurence of a specific search string, up to a maximum number
1785:              *                   of characters.
1786:              *
1787:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1788:              *
1789:              *               pstr_srch       Pointer to search string (see Note #1).
1790:              *
1791:              *               len_max         Maximum number of characters to search (see Note #3g).
1792:              *
1793:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1794:              *
1795:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1796:              *
1797:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1798:              *
1799:              * Caller(s)   : Application.
1800:              *
1801:              * Note(s)     : (1) String buffers NOT modified.
1802:              *
1803:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1804:              *
1805:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1806:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1807:              *                            pointed to by 's2' ('pstr_srch')" ...
1808:              *                       (2) "(excluding the terminating null byte)."
1809:              *
1810:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1811:              *
1812:              *                       (1) "Upon successful completion, strstr() shall return" :
1813:              *                           (A) "a pointer to the located string" ...
1814:              *                           (B) "or a null pointer if the string is not found."
1815:              *                               (1) #### Although NO strstr() specification states to return NULL for
1816:              *                                   any other reason(s), NULL is also returned for any error(s).
1817:              *
1818:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1819:              *                            shall return 's1' ('pstr')."
1820:              *
1821:              *               (3) String search terminates when :
1822:              *
1823:              *                   (a) String pointer(s) are passed NULL pointers.
1824:              *                       (1) No string search performed; NULL pointer returned.
1825:              *
1826:              *                   (b) String pointer(s) point to NULL.
1827:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1828:              *
1829:              *                   (c) Search string length equal to zero.
1830:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1831:              *
1832:              *                   (d) Search string length greater than string length.
1833:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1834:              *
1835:              *                   (e) Entire string has been searched.
1836:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1837:              *                       (2) Maximum size of the search is defined as the subtraction of the
1838:              *                           search string length from the string length.
1839:              *
1840:              *                   (f) Search string found.
1841:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1842:              *                       (2) Search string found via Str_Cmp_N().
1843:              *
1844:              *                   (g) 'len_max' number of characters searched.
1845:              *                       (1) 'len_max' number of characters does NOT include terminating NULL character
1846:              *                           (see Note #2a2).
1847:              *********************************************************************************************************
1848:              */
1849:              
1850:              CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
1851:                                    const  CPU_CHAR    *pstr_srch,
1852:                                           CPU_SIZE_T   len_max)
1853:              {
0028EA  FA0018     LNK #0x18
0028EC  980F10     MOV W0, [W14+18]
0028EE  980F21     MOV W1, [W14+20]
0028F0  980F32     MOV W2, [W14+22]
1854:                         CPU_SIZE_T    str_len;
1855:                         CPU_SIZE_T    str_len_srch;
1856:                         CPU_SIZE_T    len_max_srch;
1857:                         CPU_SIZE_T    srch_len;
1858:                         CPU_SIZE_T    srch_ix;
1859:                         CPU_BOOLEAN   srch_done;
1860:                         CPU_INT16S    srch_cmp;
1861:                  const  CPU_CHAR     *pstr_str;
1862:                  const  CPU_CHAR     *pstr_srch_ix;
1863:              
1864:                                                                              /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
1865:                  if (pstr == (const CPU_CHAR *)0) {
0028F2  90081E     MOV [W14+18], W0
0028F4  E00000     CP0 W0
0028F6  3A0002     BRA NZ, 0x28FC
1866:                      return ((CPU_CHAR *)0);
0028F8  EB0000     CLR W0
0028FA  37005C     BRA 0x29B4
1867:                  }
1868:                  if (pstr_srch == (const CPU_CHAR *)0) {
0028FC  90082E     MOV [W14+20], W0
0028FE  E00000     CP0 W0
002900  3A0002     BRA NZ, 0x2906
1869:                      return ((CPU_CHAR *)0);
002902  EB0000     CLR W0
002904  370057     BRA 0x29B4
1870:                  }
1871:              
1872:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
002906  90083E     MOV [W14+22], W0
002908  E00000     CP0 W0
00290A  3A0002     BRA NZ, 0x2910
1873:                      return ((CPU_CHAR *)0);
00290C  EB0000     CLR W0
00290E  370052     BRA 0x29B4
1874:                  }
1875:              
1876:                                                                              /* Lim max srch str len (to chk > str len).             */
1877:                  len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
00291E  980710     MOV W0, [W14+2]
1878:                               ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
002910  90083E     MOV [W14+22], W0
002912  400FE1     ADD W0, #0x1, [W15]
002914  320003     BRA Z, 0x291C
002916  90083E     MOV [W14+22], W0
002918  E80000     INC W0, W0
00291A  370001     BRA 0x291E
00291C  EB8000     SETM W0
1879:              
1880:                  str_len      = Str_Len_N(pstr,      len_max);
002920  9008BE     MOV [W14+22], W1
002922  90081E     MOV [W14+18], W0
002924  07FD25     RCALL Str_Len_N
002926  980720     MOV W0, [W14+4]
1881:                  str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
002928  90009E     MOV [W14+2], W1
00292A  90082E     MOV [W14+20], W0
00292C  07FD21     RCALL Str_Len_N
00292E  980730     MOV W0, [W14+6]
1882:                  if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
002930  90003E     MOV [W14+6], W0
002932  E00000     CP0 W0
002934  3A0002     BRA NZ, 0x293A
1883:                      return ((CPU_CHAR *)pstr);
002936  90081E     MOV [W14+18], W0
002938  37003D     BRA 0x29B4
1884:                  }
1885:                  if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
00293A  9000BE     MOV [W14+6], W1
00293C  90002E     MOV [W14+4], W0
00293E  508F80     SUB W1, W0, [W15]
002940  360002     BRA LEU, 0x2946
1886:                      return ((CPU_CHAR *)0);
002942  EB0000     CLR W0
002944  370037     BRA 0x29B4
1887:                  }
1888:                                                                              /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
1889:                  pstr_str = pstr      + str_len;
002946  90089E     MOV [W14+18], W1
002948  90002E     MOV [W14+4], W0
00294A  408000     ADD W1, W0, W0
00294C  980740     MOV W0, [W14+8]
1890:                  if (pstr_str == (const CPU_CHAR *)0) {
00294E  90004E     MOV [W14+8], W0
002950  E00000     CP0 W0
002952  3A0002     BRA NZ, 0x2958
1891:                      return ((CPU_CHAR *)0);
002954  EB0000     CLR W0
002956  37002E     BRA 0x29B4
1892:                  }
1893:                  pstr_str = pstr_srch + str_len_srch;
002958  9008AE     MOV [W14+20], W1
00295A  90003E     MOV [W14+6], W0
00295C  408000     ADD W1, W0, W0
00295E  980740     MOV W0, [W14+8]
1894:                  if (pstr_str == (const CPU_CHAR *)0) {
002960  90004E     MOV [W14+8], W0
002962  E00000     CP0 W0
002964  3A0002     BRA NZ, 0x296A
1895:                      return ((CPU_CHAR *)0);
002966  EB0000     CLR W0
002968  370025     BRA 0x29B4
1896:                  }
1897:              
1898:              
1899:                  srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
00296A  9000AE     MOV [W14+4], W1
00296C  90003E     MOV [W14+6], W0
00296E  508000     SUB W1, W0, W0
002970  980750     MOV W0, [W14+10]
1900:                  srch_ix   = 0u;
002972  EB0000     CLR W0
002974  780F00     MOV W0, [W14]
1901:                  srch_done = DEF_NO;
002976  EB4000     CLR.B W0
002978  984F40     MOV.B W0, [W14+12]
1902:              
1903:                  do {
1904:                      pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
00297A  90081E     MOV [W14+18], W0
00297C  40001E     ADD W0, [W14], W0
00297E  980770     MOV W0, [W14+14]
1905:                      srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
002980  90013E     MOV [W14+6], W2
002982  9008AE     MOV [W14+20], W1
002984  90007E     MOV [W14+14], W0
002986  07FDBE     RCALL Str_Cmp_N
002988  980F00     MOV W0, [W14+16]
1906:                      srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
00298A  90080E     MOV [W14+16], W0
00298C  E00000     CP0 W0
00298E  3A0002     BRA NZ, 0x2994
002990  B3C010     MOV.B #0x1, W0
002992  370001     BRA 0x2996
002994  EB4000     CLR.B W0
002996  984F40     MOV.B W0, [W14+12]
1907:                      srch_ix++;
002998  E80F1E     INC [W14], [W14]
1908:                  } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
00299A  90484E     MOV.B [W14+12], W0
00299C  E00400     CP0.B W0
00299E  3A0004     BRA NZ, 0x29A8
0029A0  90005E     MOV [W14+10], W0
0029A2  78009E     MOV [W14], W1
0029A4  508F80     SUB W1, W0, [W15]
0029A6  36FFE9     BRA LEU, 0x297A
1909:              
1910:              
1911:                  if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
0029A8  90080E     MOV [W14+16], W0
0029AA  E00000     CP0 W0
0029AC  320002     BRA Z, 0x29B2
1912:                      return ((CPU_CHAR *)0);
0029AE  EB0000     CLR W0
0029B0  370001     BRA 0x29B4
1913:                  }
1914:              
1915:                  return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
0029B2  90007E     MOV [W14+14], W0
1916:              }
0029B4  FA8000     ULNK
0029B6  060000     RETURN
1917:              
1918:              
1919:              /*
1920:              *********************************************************************************************************
1921:              *                                         Str_FmtNbr_Int32U()
1922:              *
1923:              * Description : Format 32-bit unsigned integer into a multi-digit character string.
1924:              *
1925:              * Argument(s) : nbr             Number           to format.
1926:              *
1927:              *               nbr_dig         Number of digits to format (see Note #1).
1928:              *
1929:              *                               The following may be used to specify the number of digits to format :
1930:              *
1931:              *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
1932:              *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
1933:              *
1934:              *               nbr_base        Base   of number to format (see Note #2).
1935:              *
1936:              *                               The following may be used to specify the number base :
1937:              *
1938:              *                                   DEF_NBR_BASE_BIN            Base  2
1939:              *                                   DEF_NBR_BASE_OCT            Base  8
1940:              *                                   DEF_NBR_BASE_DEC            Base 10
1941:              *                                   DEF_NBR_BASE_HEX            Base 16
1942:              *
1943:              *               lead_char       Prepend leading character  (see Note #3) :
1944:              *
1945:              *                                   '\0'                    Do NOT prepend leading character to string.
1946:              *                                     Printable character          Prepend leading character to string.
1947:              *                                   Unprintable character   Format invalid string (see Note #6).
1948:              *
1949:              *               lower_case      Format alphabetic characters (if any) in lower case :
1950:              *
1951:              *                                   DEF_NO          Format alphabetic characters in upper case.
1952:              *                                   DEF_YES         Format alphabetic characters in lower case.
1953:              *
1954:              *               nul             Append terminating NULL-character (see Note #4) :
1955:              *
1956:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
1957:              *                                   DEF_YES                Append terminating NULL-character to string.
1958:              *
1959:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
1960:              *
1961:              * Return(s)   : Pointer to formatted string, if NO error(s).
1962:              *
1963:              *               Pointer to NULL,             otherwise.
1964:              *
1965:              * Caller(s)   : Application.
1966:              *
1967:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
1968:              *                       is performed except possible NULL-termination of the string (see Note #4).
1969:              *
1970:              *                           Example :
1971:              *
1972:              *                               nbr      = 23456
1973:              *                               nbr_dig  = 0
1974:              *                               nbr_base = 10
1975:              *
1976:              *                               pstr     = ""                   See Note #6a
1977:              *
1978:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
1979:              *                       significant integer digits of the number to format ('nbr'); then an invalid
1980:              *                       string is formatted instead of truncating any significant integer digits.
1981:              *
1982:              *                           Example :
1983:              *
1984:              *                               nbr      = 23456
1985:              *                               nbr_dig  = 3
1986:              *                               nbr_base = 10
1987:              *
1988:              *                               pstr     = "???"                See Note #6b
1989:              *
1990:              *               (2) The number's base MUST be between 2 & 36, inclusive.
1991:              *$PAGE*
1992:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
1993:              *
1994:              *                   (a) (1) Leading character MUST be a printable ASCII character.
1995:              *
1996:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
1997:              *                           (B) with the exception of '0'.
1998:              *
1999:              *                   (b) The number of leading characters is such that the total number of significant
2000:              *                       integer digits plus the number of leading characters is equal to the requested
2001:              *                       number of integer digits to format ('nbr_dig').
2002:              *
2003:              *                           Example :
2004:              *
2005:              *                               nbr       = 23456
2006:              *                               nbr_dig   = 7
2007:              *                               nbr_base  = 10
2008:              *                               lead_char = ' '
2009:              *
2010:              *                               pstr      = "  23456"
2011:              *
2012:              *                   (c) (1) If the value of the number to format is     zero  ...
2013:              *                       (2) ... & the number of digits to format is non-zero, ...
2014:              *                       (3) ... but NO leading character available;           ...
2015:              *                       (4) ... then one digit of '0' value is formatted.
2016:              *
2017:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2018:              *
2019:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2020:              *                       array formatting.
2021:              *
2022:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2023:              *                       terminate option DISABLED will cause character string run-on.
2024:              *
2025:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2026:              *
2027:              *                   (b) To prevent character buffer overrun :
2028:              *
2029:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2030:              *                                                               1 'NUL' terminator)  characters
2031:              *
2032:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2033:              *                   ('?') will be formatted, where the number of question marks is determined by the
2034:              *                   number of digits to format ('nbr_dig') :
2035:              *
2036:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2037:              *                          number of     =  {
2038:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2039:              *
2040:              *********************************************************************************************************
2041:              */
2042:              
2043:              CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
2044:                                            CPU_INT08U    nbr_dig,
2045:                                            CPU_INT08U    nbr_base,
2046:                                            CPU_CHAR      lead_char,
2047:                                            CPU_BOOLEAN   lower_case,
2048:                                            CPU_BOOLEAN   nul,
2049:                                            CPU_CHAR     *pstr)
2050:              {
0029B8  FA000E     LNK #0xE
0029BA  980710     MOV W0, [W14+2]
0029BC  980721     MOV W1, [W14+4]
0029BE  984762     MOV.B W2, [W14+6]
0029C0  984773     MOV.B W3, [W14+7]
0029C2  984F04     MOV.B W4, [W14+8]
0029C4  984F15     MOV.B W5, [W14+9]
0029C6  984F26     MOV.B W6, [W14+10]
0029C8  980767     MOV W7, [W14+12]
2051:                  CPU_CHAR  *pstr_fmt;
2052:              
2053:              
2054:                  pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
0029CA  9000EE     MOV [W14+12], W1
0029CC  781F81     MOV W1, [W15++]
0029CE  904BAE     MOV.B [W14+10], W7
0029D0  904B1E     MOV.B [W14+9], W6
0029D2  904A8E     MOV.B [W14+8], W5
0029D4  EB4200     CLR.B W4
0029D6  9041FE     MOV.B [W14+7], W3
0029D8  90416E     MOV.B [W14+6], W2
0029DA  90001E     MOV [W14+2], W0
0029DC  9000AE     MOV [W14+4], W1
0029DE  070069     RCALL _Str_FmtNbr_Int32
0029E0  E9878F     DEC2 W15, W15
0029E2  780F00     MOV W0, [W14]
2055:                                              nbr_dig,
2056:                                              nbr_base,
2057:                                              DEF_NO,
2058:                                              lead_char,
2059:                                              lower_case,
2060:                                              nul,
2061:                                              pstr);
2062:              
2063:                  return (pstr_fmt);
0029E4  78001E     MOV [W14], W0
2064:              }
0029E6  FA8000     ULNK
0029E8  060000     RETURN
2065:              
2066:              
2067:              /*
2068:              *********************************************************************************************************
2069:              *                                         Str_FmtNbr_Int32S()
2070:              *
2071:              * Description : Format 32-bit signed integer into a multi-digit character string.
2072:              *
2073:              * Argument(s) : nbr             Number           to format.
2074:              *
2075:              *               nbr_dig         Number of digits to format (see Note #1).
2076:              *
2077:              *                               The following may be used to specify the number of digits to format :
2078:              *
2079:              *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
2080:              *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
2081:              *                                                                   (plus 1 digit for possible negative sign)
2082:              *
2083:              *               nbr_base        Base   of number to format (see Note #2).
2084:              *
2085:              *                               The following may be used to specify the number base :
2086:              *
2087:              *                                   DEF_NBR_BASE_BIN            Base  2
2088:              *                                   DEF_NBR_BASE_OCT            Base  8
2089:              *                                   DEF_NBR_BASE_DEC            Base 10
2090:              *                                   DEF_NBR_BASE_HEX            Base 16
2091:              *
2092:              *               lead_char       Prepend leading character  (see Note #3) :
2093:              *
2094:              *                                   '\0'                    Do NOT prepend leading character to string.
2095:              *                                     Printable character          Prepend leading character to string.
2096:              *                                   Unprintable character   Format invalid string (see Note #6).
2097:              *
2098:              *               lower_case      Format alphabetic characters (if any) in lower case :
2099:              *
2100:              *                                   DEF_NO          Format alphabetic characters in upper case.
2101:              *                                   DEF_YES         Format alphabetic characters in lower case.
2102:              *
2103:              *               nul             Append terminating NULL-character (see Note #4) :
2104:              *
2105:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2106:              *                                   DEF_YES                Append terminating NULL-character to string.
2107:              *
2108:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2109:              *
2110:              * Return(s)   : Pointer to formatted string, if NO error(s).
2111:              *
2112:              *               Pointer to NULL,             otherwise.
2113:              *
2114:              * Caller(s)   : Application.
2115:              *
2116:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
2117:              *                       is performed except possible NULL-termination of the string (see Note #4).
2118:              *
2119:              *                           Example :
2120:              *
2121:              *                               nbr      = -23456
2122:              *                               nbr_dig  =  0
2123:              *                               nbr_base = 10
2124:              *
2125:              *                               pstr     = ""                   See Note #6a
2126:              *
2127:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
2128:              *                       significant integer digits of the number to format ('nbr'); then an invalid
2129:              *                       string is formatted instead of truncating any significant integer digits.
2130:              *
2131:              *                           Example :
2132:              *
2133:              *                               nbr      = 23456
2134:              *                               nbr_dig  = 3
2135:              *                               nbr_base = 10
2136:              *
2137:              *                               pstr     = "???"                See Note #6b
2138:              *
2139:              *                   (c) If the number to format ('nbr') is negative but the number of digits to format
2140:              *                       ('nbr_dig') is equal to the number of significant integer digits of the number
2141:              *                       to format ('nbr'); then an invalid string is formatted instead of truncating
2142:              *                       the negative sign.
2143:              *
2144:              *                           Example :
2145:              *
2146:              *                               nbr      = -23456
2147:              *                               nbr_dig  =  5
2148:              *                               nbr_base = 10
2149:              *
2150:              *                               pstr     = "?????"              See Note #6b
2151:              *
2152:              *               (2) The number's base MUST be between 2 & 36, inclusive.
2153:              *$PAGE*
2154:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2155:              *
2156:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2157:              *
2158:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
2159:              *                           (B) with the exception of '0'.
2160:              *
2161:              *                   (b) (1) The number of leading characters is such that the total number of significant
2162:              *                           integer digits plus the number of leading characters plus possible negative
2163:              *                           sign character is equal to the requested number of integer digits to format
2164:              *                           ('nbr_dig').
2165:              *
2166:              *                               Examples :
2167:              *
2168:              *                                   nbr       = 23456
2169:              *                                   nbr_dig   = 7
2170:              *                                   nbr_base  = 10
2171:              *                                   lead_char = ' '
2172:              *
2173:              *                                   pstr      = "  23456"
2174:              *
2175:              *
2176:              *                                   nbr       = -23456
2177:              *                                   nbr_dig   =  7
2178:              *                                   nbr_base  = 10
2179:              *                                   lead_char = ' '
2180:              *
2181:              *                                   pstr      = " -23456"
2182:              *
2183:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2184:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2185:              *                               prefixes all leading characters prior to the formatted number.
2186:              *
2187:              *                                   Examples :
2188:              *
2189:              *                                       nbr        = -23456
2190:              *                                       nbr_dig    =  8
2191:              *                                       nbr_base   = 10
2192:              *                                       lead_char  = '0'
2193:              *
2194:              *                                       pstr       = "-0023456"
2195:              *
2196:              *
2197:              *                                       nbr        = -43981
2198:              *                                       nbr_dig    =  8
2199:              *                                       nbr_base   = 16
2200:              *                                       lead_char  = '0'
2201:              *                                       lower_case = DEF_NO
2202:              *
2203:              *                                       pstr       = "-000ABCD"
2204:              *
2205:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2206:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2207:              *                               immediately prefixes the most significant digit of the formatted number.
2208:              *
2209:              *                                   Examples :
2210:              *
2211:              *                                       nbr        = -23456
2212:              *                                       nbr_dig    =  8
2213:              *                                       nbr_base   = 10
2214:              *                                       lead_char  = '#'
2215:              *
2216:              *                                       pstr       = "##-23456"
2217:              *
2218:              *
2219:              *                                       nbr        = -43981
2220:              *                                       nbr_dig    =  8
2221:              *                                       nbr_base   = 16
2222:              *                                       lead_char  = '#'
2223:              *                                       lower_case = DEF_YES
2224:              *
2225:              *                                       pstr       = "###-abcd"
2226:              *
2227:              *                   (c) (1) If the value of the number to format is     zero  ...
2228:              *                       (2) ... & the number of digits to format is non-zero, ...
2229:              *                       (3) ... but NO leading character available;           ...
2230:              *                       (4) ... then one digit of '0' value is formatted.
2231:              *
2232:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2233:              *$PAGE*
2234:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2235:              *                       array formatting.
2236:              *
2237:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2238:              *                       terminate option DISABLED will cause character string run-on.
2239:              *
2240:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2241:              *
2242:              *                   (b) To prevent character buffer overrun :
2243:              *
2244:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2245:              *                                                               1 negative sign   +
2246:              *                                                               1 'NUL' terminator)  characters
2247:              *
2248:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2249:              *                   ('?') will be formatted, where the number of question marks is determined by the
2250:              *                   number of digits to format ('nbr_dig') :
2251:              *
2252:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2253:              *                          number of     =  {
2254:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2255:              *
2256:              *********************************************************************************************************
2257:              */
2258:              
2259:              CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
2260:                                            CPU_INT08U    nbr_dig,
2261:                                            CPU_INT08U    nbr_base,
2262:                                            CPU_CHAR      lead_char,
2263:                                            CPU_BOOLEAN   lower_case,
2264:                                            CPU_BOOLEAN   nul,
2265:                                            CPU_CHAR     *pstr)
2266:              {
0029EA  FA0014     LNK #0x14
0029EC  980740     MOV W0, [W14+8]
0029EE  980751     MOV W1, [W14+10]
0029F0  984F42     MOV.B W2, [W14+12]
0029F2  984F53     MOV.B W3, [W14+13]
0029F4  984F64     MOV.B W4, [W14+14]
0029F6  984F75     MOV.B W5, [W14+15]
0029F8  985706     MOV.B W6, [W14+16]
0029FA  980F17     MOV W7, [W14+18]
2267:                  CPU_CHAR     *pstr_fmt;
2268:                  CPU_INT32S    nbr_fmt;
2269:                  CPU_BOOLEAN   nbr_neg;
2270:              
2271:              
2272:                  if (nbr < 0) {                                              /* If nbr neg, ...                                      */
0029FC  90004E     MOV [W14+8], W0
0029FE  9000DE     MOV [W14+10], W1
002A00  500FE0     SUB W0, #0x0, [W15]
002A02  588FE0     SUBB W1, #0x0, [W15]
002A04  3D0008     BRA GE, 0x2A16
2273:                      nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
002A06  90004E     MOV [W14+8], W0
002A08  9000DE     MOV [W14+10], W1
002A0A  100060     SUBR W0, #0x0, W0
002A0C  1880E0     SUBBR W1, #0x0, W1
002A0E  BE8F00     MOV.D W0, [W14]
2274:                      nbr_neg =  DEF_YES;
002A10  B3C010     MOV.B #0x1, W0
002A12  984740     MOV.B W0, [W14+4]
002A14  370005     BRA 0x2A20
2275:                  } else {
2276:                      nbr_fmt =  nbr;
002A16  90014E     MOV [W14+8], W2
002A18  9001DE     MOV [W14+10], W3
002A1A  BE8F02     MOV.D W2, [W14]
2277:                      nbr_neg =  DEF_NO;
002A1C  EB4000     CLR.B W0
002A1E  984740     MOV.B W0, [W14+4]
2278:                  }
2279:              
2280:                  pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
002A20  BE001E     MOV.D [W14], W0
002A22  90099E     MOV [W14+18], W3
002A24  781F83     MOV W3, [W15++]
002A26  90538E     MOV.B [W14+16], W7
002A28  904B7E     MOV.B [W14+15], W6
002A2A  904AEE     MOV.B [W14+14], W5
002A2C  90424E     MOV.B [W14+4], W4
002A2E  9049DE     MOV.B [W14+13], W3
002A30  90494E     MOV.B [W14+12], W2
002A32  07003F     RCALL _Str_FmtNbr_Int32
002A34  E9878F     DEC2 W15, W15
002A36  980730     MOV W0, [W14+6]
2281:                                                          nbr_dig,
2282:                                                          nbr_base,
2283:                                                          nbr_neg,
2284:                                                          lead_char,
2285:                                                          lower_case,
2286:                                                          nul,
2287:                                                          pstr);
2288:              
2289:                  return (pstr_fmt);
002A38  90003E     MOV [W14+6], W0
2290:              }
002A3A  FA8000     ULNK
002A3C  060000     RETURN
2291:              
2292:              
2293:              /*
2294:              *********************************************************************************************************
2295:              *                                           Str_FmtNbr_32()
2296:              *
2297:              * Description : Format number into a multi-digit character string.
2298:              *
2299:              * Argument(s) : nbr             Number                         to format (see Note #1).
2300:              *
2301:              *               nbr_dig         Number of decimal       digits to format (see Note #2).
2302:              *
2303:              *               nbr_dp          Number of decimal point digits to format.
2304:              *
2305:              *               lead_char       Prepend leading character (see Note #3) :
2306:              *
2307:              *                                   '\0'                    Do NOT prepend leading character to string.
2308:              *                                     Printable character          Prepend leading character to string.
2309:              *                                   Unprintable character   Format invalid string (see Note #6d).
2310:              *
2311:              *               nul             Append terminating NULL-character (see Note #4) :
2312:              *
2313:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2314:              *                                   DEF_YES                Append terminating NULL-character to string.
2315:              *
2316:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2317:              *
2318:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
2319:              *
2320:              *               Pointer to NULL,             otherwise.
2321:              *
2322:              * Caller(s)   : Application.
2323:              *
2324:              * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
2325:              *
2326:              *
2327:              *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
2328:              *                           32-bit Floating-point Number  =  -----------------------------------------------------
2329:              *                                                                             log [External-Base]
2330:              *
2331:              *                                                             log [2 ^ 24]
2332:              *                                                         =  --------------
2333:              *                                                               log [10]
2334:              *
2335:              *                                                         <  7.225  Base-10 Digits
2336:              *
2337:              *                               where
2338:              *                                       Internal-Base                   Internal number base of floating-
2339:              *                                                                           point numbers (i.e.  2)
2340:              *                                       External-Base                   External number base of floating-
2341:              *                                                                           point numbers (i.e. 10)
2342:              *                                       Number-Internal-Base-Digits     Number of internal number base
2343:              *                                                                           significant digits (i.e. 24)
2344:              *
2345:              *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
2346:              *                       maximum accuracy.
2347:              *$PAGE*
2348:              *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
2349:              *                       formatting is performed except possible NULL-termination of the string (see Note #4).
2350:              *
2351:              *                           Example :
2352:              *
2353:              *                               nbr     = -23456.789
2354:              *                               nbr_dig =  0
2355:              *                               nbr_dp  =  0
2356:              *
2357:              *                               pstr    = ""                        See Note #7a
2358:              *
2359:              *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
2360:              *                           significant integer digits of the number to format ('nbr'); then an invalid
2361:              *                           string is formatted instead of truncating any significant integer digits.
2362:              *
2363:              *                               Example :
2364:              *
2365:              *                                   nbr     = 23456.789
2366:              *                                   nbr_dig = 3
2367:              *                                   nbr_dp  = 2
2368:              *
2369:              *                                   pstr    = "??????"              See Note #7d
2370:              *
2371:              *                       (2) If the number to format ('nbr') is negative but the number of digits to format
2372:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
2373:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
2374:              *                           the negative sign.
2375:              *
2376:              *                               Example :
2377:              *
2378:              *                                   nbr     = -23456.789
2379:              *                                   nbr_dig =  5
2380:              *                                   nbr_dp  =  2
2381:              *
2382:              *                                   pstr    = "????????"            See Note #7d
2383:              *
2384:              *                       (3) If the number to format ('nbr') is negative but the number of significant
2385:              *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one
2386:              *                           but the number of decimal point digits to format ('nbr_dp') is zero; then
2387:              *                           an invalid string is formatted instead of truncating the negative sign.
2388:              *
2389:              *                               Example :
2390:              *
2391:              *                                   nbr     = -0.7895
2392:              *                                   nbr_dig =  1
2393:              *                                   nbr_dp  =  0
2394:              *
2395:              *                                   pstr    = "?"                   See Note #7d
2396:              *
2397:              *                       (4) (A) If the number to format ('nbr') is negative but the number of significant
2398:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2399:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2400:              *                               zero; then the negative sign immediately prefixes the decimal point --
2401:              *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
2402:              *
2403:              *                                   Example :
2404:              *
2405:              *                                       nbr     = -0.7895
2406:              *                                       nbr_dig =  0
2407:              *                                       nbr_dp  =  2
2408:              *
2409:              *                                       pstr    = "-.78"
2410:              *
2411:              *                           (B) If the number to format ('nbr') is positive but the number of significant
2412:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2413:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2414:              *                               zero; then a single decimal digit of '0' prefixes the decimal point.
2415:              *
2416:              *                               This '0' digit is used whenever a negative sign is not formatted (see
2417:              *                               Note #2b4A) so that the formatted string's decimal point is not floating,
2418:              *                               but fixed in the string as the 2nd character.
2419:              *
2420:              *                                   Example :
2421:              *
2422:              *                                       nbr     =  0.7895
2423:              *                                       nbr_dig =  0
2424:              *                                       nbr_dp  =  2
2425:              *
2426:              *                                       pstr    = "0.78"
2427:              *$PAGE*
2428:              *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
2429:              *
2430:              *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point
2431:              *                               numbers, digits following all significantly-accurate digits of the number to
2432:              *                               format ('nbr') will be inaccurate; ...
2433:              *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all
2434:              *                               digits or decimal places following all significantly-accurate digits of the
2435:              *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
2436:              *
2437:              *                                   Example :
2438:              *
2439:              *                                       nbr                            = 123456789.012345
2440:              *                                       nbr_dig                        = 9
2441:              *                                       nbr_dp                         = 6
2442:              *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
2443:              *
2444:              *                                       pstr                           = "123456700.000000"
2445:              *
2446:              *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr')
2447:              *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
2448:              *                           &/or compiler's floating-point implementation.
2449:              *
2450:              *                       See also Note #1.
2451:              *
2452:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2453:              *
2454:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2455:              *
2456:              *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
2457:              *                           (B) with the exception of '0'.
2458:              *
2459:              *                   (b) (1) The number of leading characters is such that the total number of significant
2460:              *                           integer digits plus the number of leading characters plus possible negative
2461:              *                           sign character is equal to the requested number of integer digits to format
2462:              *                           ('nbr_dig').
2463:              *
2464:              *                               Examples :
2465:              *
2466:              *                                   nbr       = 23456.789
2467:              *                                   nbr_dig   = 7
2468:              *                                   nbr_dp    = 2
2469:              *                                   lead_char = ' '
2470:              *
2471:              *                                   pstr      = "  23456.78"
2472:              *
2473:              *
2474:              *                                   nbr       = -23456.789
2475:              *                                   nbr_dig   =  7
2476:              *                                   nbr_dp    =  2
2477:              *                                   lead_char = ' '
2478:              *
2479:              *                                   pstr      = " -23456.78"
2480:              *
2481:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2482:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2483:              *                               prefixes all leading characters prior to the formatted number.
2484:              *
2485:              *                                   Example :
2486:              *
2487:              *                                       nbr       = -23456.789
2488:              *                                       nbr_dig   =  8
2489:              *                                       nbr_dp    =  2
2490:              *                                       lead_char = '0'
2491:              *
2492:              *                                       pstr      = "-0023456.78"
2493:              *
2494:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2495:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2496:              *                               immediately prefixes the most significant digit of the formatted number.
2497:              *
2498:              *                                   Examples :
2499:              *
2500:              *                                       nbr       = -23456.789
2501:              *                                       nbr_dig   =  8
2502:              *                                       nbr_dp    =  2
2503:              *                                       lead_char = '#'
2504:              *
2505:              *                                       pstr      = "##-23456.78"
2506:              *
2507:              *                   (c) (1) If the integer value of the number to format is zero & ...
2508:              *                       (2) ... the number of digits to format is greater than one ...
2509:              *                       (3) ... OR  the number is NOT negative,                    ...
2510:              *                       (4) ... but NO leading character available;                ...
2511:              *                       (5) ... then one digit of '0' value is formatted.
2512:              *
2513:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2514:              *
2515:              *                       See also Note #2b4B.
2516:              *$PAGE*
2517:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2518:              *                       array formatting.
2519:              *
2520:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2521:              *                       terminate option DISABLED will cause character string run-on.
2522:              *
2523:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2524:              *
2525:              *                   (b) To prevent character buffer overrun :
2526:              *
2527:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2528:              *                                                              'nbr_dp'           +
2529:              *                                                               1 negative sign   +
2530:              *                                                               1 decimal point   +
2531:              *                                                               1 'NUL' terminator)  characters
2532:              *
2533:              *               (6) String format terminates when :
2534:              *
2535:              *                   (a) Format string pointer is passed a NULL pointer.
2536:              *                       (1) No      string formatted;                NULL pointer returned.
2537:              *
2538:              *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
2539:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
2540:              *
2541:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
2542:              *                           integer digits of the number to format ('nbr'), including possible
2543:              *                           negative sign.
2544:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2545:              *
2546:              *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
2547:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2548:              *
2549:              *                   (e) Number successfully formatted into character string array.
2550:              *
2551:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
2552:              *                   ('?') will be formatted, where the number of question marks is determined by the
2553:              *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
2554:              *
2555:              *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
2556:              *                                           {                                        'nbr_dp'  = 0
2557:              *                                           {
2558:              *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
2559:              *                                           {                                        'nbr_dp'  = 0
2560:              *                      Invalid string's     {
2561:              *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
2562:              *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
2563:              *                                           {         1 (for negative sign) ]
2564:              *                                           {
2565:              *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
2566:              *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
2567:              *                                           {         1 (for decimal point) ]
2568:              *
2569:              *********************************************************************************************************
2570:              */
2571:              
2572:              #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
2573:              CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
2574:                                        CPU_INT08U    nbr_dig,
2575:                                        CPU_INT08U    nbr_dp,
2576:                                        CPU_CHAR      lead_char,
2577:                                        CPU_BOOLEAN   nul,
2578:                                        CPU_CHAR     *pstr)
2579:              {
2580:                  CPU_CHAR     *pstr_fmt;
2581:                  CPU_DATA      i;
2582:                  CPU_FP32      nbr_fmt;
2583:                  CPU_FP32      nbr_log;
2584:                  CPU_INT32U    nbr_shiftd;
2585:                  CPU_INT16U    nbr_dig_max;
2586:                  CPU_INT16U    nbr_dig_sig;
2587:                  CPU_INT08U    nbr_neg_sign;
2588:                  CPU_INT08U    dig_val;
2589:                  CPU_FP32      dig_exp;
2590:                  CPU_FP32      dp_exp;
2591:                  CPU_BOOLEAN   lead_char_dig;
2592:                  CPU_BOOLEAN   lead_char_fmtd;
2593:                  CPU_BOOLEAN   lead_char_0;
2594:                  CPU_BOOLEAN   fmt_invalid;
2595:                  CPU_BOOLEAN   print_char;
2596:                  CPU_BOOLEAN   nbr_neg;
2597:                  CPU_BOOLEAN   nbr_neg_fmtd;
2598:              
2599:              
2600:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
2601:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
2602:                      return ((CPU_CHAR *)0);
2603:                  }
2604:              
2605:                  dig_exp     =  1.0f;
2606:                  fmt_invalid =  DEF_NO;
2607:                  lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;        /* Chk if lead char a '0' dig (see Note #3b2).          */
2608:                  nbr_fmt     =  0.0f;
2609:                  nbr_neg     =  DEF_NO;
2610:              
2611:                  if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
2612:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
2613:                  }
2614:              
2615:                  if (lead_char != (CPU_CHAR)'\0') {
2616:                      print_char =  ASCII_IsPrint(lead_char);
2617:                      if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
2618:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
2619:              
2620:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
2621:                          lead_char_dig = ASCII_IsDig(lead_char);
2622:                          if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
2623:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
2624:                          }
2625:                      }
2626:                  }
2627:              
2628:              
2629:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
2630:                  pstr_fmt = pstr;
2631:              
2632:                  if (fmt_invalid == DEF_NO) {
2633:                      if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
2634:                          nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
2635:                          nbr_neg_sign =  1u;
2636:                          nbr_neg      =  DEF_YES;
2637:                      } else {
2638:                          nbr_fmt      =  nbr;
2639:                          nbr_neg_sign =  0u;
2640:                          nbr_neg      =  DEF_NO;
2641:                      }
2642:              
2643:                      nbr_log     = nbr_fmt;
2644:                      nbr_dig_max = 0u;
2645:                      while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
2646:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
2647:                          nbr_log /= 10.0f;
2648:                      }
2649:              
2650:                      if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
2651:                           (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
2652:                          ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
2653:                           (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
2654:                           (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
2655:                                                                              /* .. prepare nbr digs to fmt.                          */
2656:                          for (i = 1u; i < nbr_dig; i++) {
2657:                              dig_exp *= 10.0f;
2658:                          }
2659:              
2660:                          nbr_neg_fmtd   =  DEF_NO;
2661:                          nbr_dig_sig    =  0u;
2662:                          lead_char_fmtd =  DEF_NO;
2663:                      } else {                                                /* Else if nbr trunc'd, ...                             */
2664:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
2665:                      }
2666:                  }
2667:              
2668:              
2669:                                                                              /* ------------------- FMT NBR STR -------------------- */
2670:                  for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
2671:                      if (fmt_invalid == DEF_NO) {
2672:                          if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
2673:                              nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
2674:                              if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
2675:                                  (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
2676:                                                                              /* ... calc & fmt dig val;                     ...      */
2677:                                  if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
2678:                                      (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
2679:              
2680:                                      if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
2681:                                          pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
2682:                                      }
2683:                                     *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
2684:                                      nbr_neg_fmtd = DEF_YES;
2685:                                  }
2686:              
2687:                                  if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
2688:                                      dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
2689:                                     *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
2690:              
2691:                                      nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
2692:              
2693:                                  } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
2694:                                             (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
2695:                                     *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
2696:                                  }
2697:              
2698:                              } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
2699:                                         (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
2700:                                         (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
2701:              
2702:                                 *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
2703:                                  nbr_neg_fmtd = DEF_YES;
2704:              
2705:                              } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
2706:                                 *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
2707:                                  lead_char_fmtd = DEF_YES;
2708:                              }
2709:              
2710:                              dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
2711:              
2712:                          } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
2713:                             *pstr_fmt++ = '0';
2714:                          }
2715:              
2716:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2717:                         *pstr_fmt++ = '?';
2718:                      }
2719:                  }
2720:              
2721:              
2722:                  if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
2723:                      if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
2724:                          if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
2725:                              if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
2726:                                  (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
2727:                                  *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
2728:                              } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
2729:                                  *pstr_fmt++ = '0';
2730:                              }
2731:                          } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
2732:                              *pstr_fmt++ = '?';
2733:                          }
2734:                      }
2735:              
2736:                      if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
2737:                         *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
2738:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2739:                         *pstr_fmt++ = '?';
2740:                      }
2741:              
2742:                      dp_exp = 10.0f;
2743:                      for (i = 0u; i < nbr_dp; i++) {
2744:                          if (fmt_invalid == DEF_NO) {
2745:                                                                              /* If nbr sig digs < max, fmt str dps;    ...           */
2746:                              if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
2747:                                  nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
2748:                                  dig_val     = (CPU_INT08U)(nbr_shiftd % 10u);
2749:                                 *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
2750:                                  dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
2751:              
2752:                                  if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
2753:                                      (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
2754:                                       nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
2755:                                  }
2756:              
2757:                              } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
2758:                                 *pstr_fmt++ = '0';
2759:                              }
2760:              
2761:                          } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
2762:                             *pstr_fmt++ = '?';
2763:                          }
2764:                      }
2765:                  }
2766:              
2767:              
2768:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
2769:                     *pstr_fmt = (CPU_CHAR)'\0';
2770:                  }
2771:              
2772:              
2773:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
2774:                      return ((CPU_CHAR *)0);
2775:                  }
2776:              
2777:              
2778:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
2779:              }
2780:              #endif
2781:              
2782:              
2783:              /*
2784:              *********************************************************************************************************
2785:              *                                        Str_ParseNbr_Int32U()
2786:              *
2787:              * Description : Parse 32-bit unsigned integer from string.
2788:              *
2789:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
2790:              *
2791:              *               pstr_next   Optional pointer to a variable to ... :
2792:              *
2793:              *                               (a) Return a pointer to first character following the integer string,
2794:              *                                       if NO error(s) [see Note #2a2B2];
2795:              *                               (b) Return a pointer to 'pstr',
2796:              *                                       otherwise      (see Note #2a2A2).
2797:              *
2798:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
2799:              *
2800:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
2801:              *
2802:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
2803:              *
2804:              *               0,                   otherwise                            (see Note #2a3B).
2805:              *
2806:              * Caller(s)   : Application.
2807:              *
2808:              * Note(s)     : (1) String buffer NOT modified.
2809:              *
2810:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
2811:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
2812:              *                       to a type unsigned long ... representation" :
2813:              *
2814:              *                       (1) "First, they decompose the input string into three parts" :
2815:              *
2816:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
2817:              *                                by isspace()]."
2818:              *
2819:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
2820:              *                                    input string, starting with the first non-white-space character that is of
2821:              *                                    the expected form.  The subject sequence shall contain no characters if the
2822:              *                                    input string is empty or consists entirely of white-space characters."
2823:              *
2824:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
2825:              *                                    determined by the value of 'base' ('nbr_base')" :
2826:              *
2827:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
2828:              *                                        subject sequence is that of a decimal constant, octal constant, or
2829:              *                                        hexadecimal constant" :
2830:              *
2831:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
2832:              *                                            sequence of decimal digits."
2833:              *
2834:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
2835:              *                                            a sequence of the digits '0' to '7' only."
2836:              *
2837:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
2838:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
2839:              *                                            (or 'F') with values 10 to 15 respectively."
2840:              *
2841:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
2842:              *                                        of the subject sequence is a sequence of letters and digits representing
2843:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
2844:              *
2845:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
2846:              *                                                ascribed the values 10 to 35"; ...
2847:              *                                           (B) "only letters whose ascribed values are less than that of base
2848:              *                                                are permitted."
2849:              *
2850:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
2851:              *                                                '0X' may optionally precede the sequence of letters and digits."
2852:              *
2853:              *                                           (B) Although NO specification states that "if the value of 'base'
2854:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
2855:              *                                               the sequence of letters and digits"; it seems reasonable to
2856:              *                                               allow the '0' character to be optionally parsed.
2857:              *
2858:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
2859:              *
2860:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
2861:              *                                       integer string into an unsigned integer.
2862:              *
2863:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
2864:              *                                   (b) "including the terminating null byte of the input string" ...
2865:              *                               (2) "other than a sign or a permissible letter or digit."
2866:              *$PAGE*
2867:              *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
2868:              *
2869:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
2870:              *
2871:              *                               (1) "no conversion [is] performed"; ...
2872:              *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr'
2873:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
2874:              *
2875:              *                           (B) "If the subject sequence has the expected form" :
2876:              *
2877:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
2878:              *                                        starting with the first digit shall be interpreted as an integer constant."
2879:              *
2880:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
2881:              *                                        used as the base for conversion, ascribing to each letter its value as
2882:              *                                        given above" (see Note #2a1B1b1A).
2883:              *
2884:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
2885:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
2886:              *                                   pointer."
2887:              *
2888:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
2889:              *
2890:              *                           (A) "Upon successful completion, these functions shall return the converted value."
2891:              *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
2892:              *                                    ... shall be returned."
2893:              *
2894:              *                           (B) "If no conversion could be performed, 0 shall be returned."
2895:              *
2896:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2897:              *                           shall fail if" :
2898:              *
2899:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
2900:              *
2901:              *                           (B) "[ERANGE] - The value to be returned is not representable."
2902:              *
2903:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2904:              *                           may fail if" :
2905:              *
2906:              *                           (A) "[EINVAL] - No conversion could be performed."
2907:              *
2908:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
2909:              *
2910:              *                   (a) Valid parse string integer :
2911:              *
2912:              *                           pstr      = "     ABCDE xyz"
2913:              *                           nbr_base  = 16
2914:              *
2915:              *                           nbr       = 703710
2916:              *                           pstr_next = " xyz"
2917:              *
2918:              *
2919:              *                   (b) Invalid parse string integer :
2920:              *
2921:              *                           pstr      = "     ABCDE"
2922:              *                           nbr_base  = 10
2923:              *
2924:              *                           nbr       =  0
2925:              *                           pstr_next = pstr = "     ABCDE"
2926:              *
2927:              *
2928:              *                   (c) Valid hexadecimal parse string integer :
2929:              *
2930:              *                           pstr      = "     0xGABCDE"
2931:              *                           nbr_base  = 16
2932:              *
2933:              *                           nbr       =  0
2934:              *                           pstr_next = "xGABCDE"
2935:              *
2936:              *
2937:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
2938:              *                               following invalid hexadecimal characters) :
2939:              *
2940:              *                           pstr      = "     0xGABCDE"
2941:              *                           nbr_base  =  0
2942:              *
2943:              *                           nbr       =  0
2944:              *                           pstr_next = "xGABCDE"
2945:              *
2946:              *
2947:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
2948:              *                               following invalid octal       characters) :
2949:              *
2950:              *                           pstr      = "     0GABCDE"
2951:              *                           nbr_base  =  0
2952:              *
2953:              *                           nbr       =  0
2954:              *                           pstr_next = "GABCDE"
2955:              *
2956:              *$PAGE*
2957:              *                   (f) Parse string integer overflow :
2958:              *
2959:              *                           pstr      = "   12345678901234567890*123456"
2960:              *                           nbr_base  = 10
2961:              *
2962:              *                           nbr       = DEF_INT_32U_MAX_VAL
2963:              *                           pstr_next = "*123456"
2964:              *
2965:              *
2966:              *                   (g) Invalid negative unsigned parse string :
2967:              *
2968:              *                           pstr      = "  -12345678901234567890*123456"
2969:              *                           nbr_base  = 10
2970:              *
2971:              *                           nbr       = 0
2972:              *                           pstr_next = pstr = "  -12345678901234567890*123456"
2973:              *
2974:              *********************************************************************************************************
2975:              */
2976:              
2977:              CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
2978:                                                      CPU_CHAR    **pstr_next,
2979:                                                      CPU_INT08U    nbr_base)
2980:              {
002A3E  FA000A     LNK #0xA
002A40  980720     MOV W0, [W14+4]
002A42  980731     MOV W1, [W14+6]
002A44  984F02     MOV.B W2, [W14+8]
2981:                  CPU_INT32U  nbr;
2982:              
2983:              
2984:                  nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
002A46  EB0200     CLR W4
002A48  EB4180     CLR.B W3
002A4A  90490E     MOV.B [W14+8], W2
002A4C  9000BE     MOV [W14+6], W1
002A4E  90002E     MOV [W14+4], W0
002A50  07016C     RCALL _Str_ParseNbr_Int32
002A52  BE8F00     MOV.D W0, [W14]
2985:                                                          pstr_next,
2986:                                                          nbr_base,
2987:                                                          DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
2988:                                           (CPU_BOOLEAN *)0);
2989:              
2990:                  return (nbr);
002A54  BE001E     MOV.D [W14], W0
2991:              }
002A56  FA8000     ULNK
002A58  060000     RETURN
2992:              
2993:              
2994:              /*
2995:              *********************************************************************************************************
2996:              *                                        Str_ParseNbr_Int32S()
2997:              *
2998:              * Description : Parse 32-bit signed integer from string.
2999:              *
3000:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
3001:              *
3002:              *               pstr_next   Optional pointer to a variable to ... :
3003:              *
3004:              *                               (a) Return a pointer to first character following the integer string,
3005:              *                                       if NO error(s) [see Note #2a2B2];
3006:              *                               (b) Return a pointer to 'pstr',
3007:              *                                       otherwise      (see Note #2a2A2).
3008:              *
3009:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
3010:              *
3011:              * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
3012:              *
3013:              *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
3014:              *
3015:              *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
3016:              *
3017:              *               0,                   otherwise                                    (see Note #2a3B).
3018:              *
3019:              * Caller(s)   : Application.
3020:              *
3021:              * Note(s)     : (1) String buffer NOT modified.
3022:              *
3023:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3024:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3025:              *                       to a type long ... representation" :
3026:              *
3027:              *                       (1) "First, they decompose the input string into three parts" :
3028:              *
3029:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3030:              *                                by isspace()]."
3031:              *
3032:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3033:              *                                    input string, starting with the first non-white-space character that is of
3034:              *                                    the expected form.  The subject sequence shall contain no characters if the
3035:              *                                    input string is empty or consists entirely of white-space characters."
3036:              *
3037:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3038:              *                                    determined by the value of 'base' ('nbr_base')" :
3039:              *
3040:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3041:              *                                        subject sequence is that of a decimal constant, octal constant, or
3042:              *                                        hexadecimal constant" :
3043:              *
3044:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3045:              *                                            sequence of decimal digits."
3046:              *
3047:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3048:              *                                            a sequence of the digits '0' to '7' only."
3049:              *
3050:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3051:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3052:              *                                            (or 'F') with values 10 to 15 respectively."
3053:              *
3054:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3055:              *                                        of the subject sequence is a sequence of letters and digits representing
3056:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3057:              *
3058:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3059:              *                                                ascribed the values 10 to 35"; ...
3060:              *                                           (B) "only letters whose ascribed values are less than that of base
3061:              *                                                are permitted."
3062:              *
3063:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3064:              *                                                '0X' may optionally precede the sequence of letters and digits."
3065:              *
3066:              *                                           (B) Although NO specification states that "if the value of 'base'
3067:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3068:              *                                               the sequence of letters and digits"; it seems reasonable to
3069:              *                                               allow the '0' character to be optionally parsed.
3070:              *
3071:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3072:              *
3073:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
3074:              *                                       integer string into an unsigned integer.
3075:              *
3076:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3077:              *                                   (b) "including the terminating null byte of the input string" ...
3078:              *                               (2) "other than a sign or a permissible letter or digit."
3079:              *$PAGE*
3080:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3081:              *
3082:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3083:              *
3084:              *                               (1) "no conversion is performed"; ...
3085:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3086:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3087:              *
3088:              *                           (B) "If the subject sequence has the expected form" :
3089:              *
3090:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3091:              *                                        starting with the first digit shall be interpreted as an integer constant."
3092:              *
3093:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3094:              *                                        used as the base for conversion, ascribing to each letter its value as
3095:              *                                        given above" (see Note #2a1B1b1A).
3096:              *
3097:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3098:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3099:              *                                   pointer."
3100:              *
3101:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3102:              *
3103:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3104:              *
3105:              *                               (1) "If the correct value is outside the range of representable values", either
3106:              *                                    of the following "shall be returned" :
3107:              *                                   (a) "{LONG_MIN}" or ...
3108:              *                                   (b) "{LONG_MAX}"
3109:              *
3110:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3111:              *
3112:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3113:              *                           shall fail if" :
3114:              *
3115:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3116:              *
3117:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3118:              *
3119:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3120:              *                           may fail if" :
3121:              *
3122:              *                           (A) "[EINVAL] - No conversion could be performed."
3123:              *
3124:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3125:              *
3126:              *                   (a) Valid parse string integer :
3127:              *
3128:              *                           pstr      = "     ABCDE xyz"
3129:              *                           nbr_base  = 16
3130:              *
3131:              *                           nbr       = 703710
3132:              *                           pstr_next = " xyz"
3133:              *
3134:              *
3135:              *                   (b) Invalid parse string integer :
3136:              *
3137:              *                           pstr      = "     ABCDE"
3138:              *                           nbr_base  = 10
3139:              *
3140:              *                           nbr       =  0
3141:              *                           pstr_next = pstr = "     ABCDE"
3142:              *
3143:              *
3144:              *                   (c) Valid hexadecimal parse string integer :
3145:              *
3146:              *                           pstr      = "     0xGABCDE"
3147:              *                           nbr_base  = 16
3148:              *
3149:              *                           nbr       =  0
3150:              *                           pstr_next = "xGABCDE"
3151:              *
3152:              *
3153:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3154:              *                               following invalid hexadecimal characters) :
3155:              *
3156:              *                           pstr      = "     0xGABCDE"
3157:              *                           nbr_base  =  0
3158:              *
3159:              *                           nbr       =  0
3160:              *                           pstr_next = "xGABCDE"
3161:              *
3162:              *
3163:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3164:              *                               following invalid octal       characters) :
3165:              *
3166:              *                           pstr      = "     0GABCDE"
3167:              *                           nbr_base  =  0
3168:              *
3169:              *                           nbr       =  0
3170:              *                           pstr_next = "GABCDE"
3171:              *
3172:              *$PAGE*
3173:              *                   (f) Parse string integer overflow :
3174:              *
3175:              *                           pstr      = "   12345678901234567890*123456"
3176:              *                           nbr_base  = 10
3177:              *
3178:              *                           nbr       = DEF_INT_32S_MAX_VAL
3179:              *                           pstr_next = "*123456"
3180:              *
3181:              *
3182:              *                   (g) Parse string integer underflow :
3183:              *
3184:              *                           pstr      = "  -12345678901234567890*123456"
3185:              *                           nbr_base  = 10
3186:              *
3187:              *                           nbr       = DEF_INT_32S_MIN_VAL
3188:              *                           pstr_next = "*123456"
3189:              *
3190:              *********************************************************************************************************
3191:              */
3192:              
3193:              CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
3194:                                                      CPU_CHAR    **pstr_next,
3195:                                                      CPU_INT08U    nbr_base)
3196:              {
002A5A  FA0010     LNK #0x10
002A5C  980750     MOV W0, [W14+10]
002A5E  980761     MOV W1, [W14+12]
002A60  984F62     MOV.B W2, [W14+14]
3197:                  CPU_INT32S   nbr;
3198:                  CPU_INT32U   nbr_abs;
3199:                  CPU_BOOLEAN  nbr_neg;
3200:              
3201:              
3202:                  nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
002A62  470068     ADD W14, #0x8, W0
002A64  780200     MOV W0, W4
002A66  B3C013     MOV.B #0x1, W3
002A68  90496E     MOV.B [W14+14], W2
002A6A  9000EE     MOV [W14+12], W1
002A6C  90005E     MOV [W14+10], W0
002A6E  07015D     RCALL _Str_ParseNbr_Int32
002A70  980720     MOV W0, [W14+4]
002A72  980731     MOV W1, [W14+6]
3203:                                               pstr_next,
3204:                                               nbr_base,
3205:                                               DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
3206:                                              &nbr_neg);
3207:              
3208:                  if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
002A74  90480E     MOV.B [W14+8], W0
002A76  E00400     CP0.B W0
002A78  3A000C     BRA NZ, 0x2A92
3209:                      nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
002A7A  90002E     MOV [W14+4], W0
002A7C  9000BE     MOV [W14+6], W1
002A8E  BE8F00     MOV.D W0, [W14]
002A90  37000D     BRA 0x2AAC
3210:                                                                                  :  (CPU_INT32S)nbr_abs;
002A7E  500FE0     SUB W0, #0x0, [W15]
002A80  588FE0     SUBB W1, #0x0, [W15]
002A82  350003     BRA LT, 0x2A8A
002A84  90002E     MOV [W14+4], W0
002A86  9000BE     MOV [W14+6], W1
002A88  370002     BRA 0x2A8E
002A8A  2FFFF0     MOV #0xFFFF, W0
002A8C  27FFF1     MOV #0x7FFF, W1
3211:                  } else {
3212:                      nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
002A92  90002E     MOV [W14+4], W0
002A94  9000BE     MOV [W14+6], W1
002AAA  BE8F00     MOV.D W0, [W14]
3213:                                                                                  : -(CPU_INT32S)nbr_abs;
002A96  500FE0     SUB W0, #0x0, [W15]
002A98  588FE0     SUBB W1, #0x0, [W15]
002A9A  350005     BRA LT, 0x2AA6
002A9C  90002E     MOV [W14+4], W0
002A9E  9000BE     MOV [W14+6], W1
002AA0  100060     SUBR W0, #0x0, W0
002AA2  1880E0     SUBBR W1, #0x0, W1
002AA4  370002     BRA 0x2AAA
002AA6  200000     MOV #0x0, W0
002AA8  280001     MOV #0x8000, W1
3214:                  }
3215:              
3216:                  return (nbr);
002AAC  BE001E     MOV.D [W14], W0
3217:              }
002AAE  FA8000     ULNK
002AB0  060000     RETURN
3218:              
3219:              
3220:              /*
3221:              *********************************************************************************************************
3222:              *********************************************************************************************************
3223:              *                                           LOCAL FUNCTIONS
3224:              *********************************************************************************************************
3225:              *********************************************************************************************************
3226:              */
3227:              
3228:              /*
3229:              *********************************************************************************************************
3230:              *                                         Str_FmtNbr_Int32()
3231:              *
3232:              * Description : Format 32-bit integer into a multi-digit character string.
3233:              *
3234:              * Argument(s) : nbr             Number           to format.
3235:              *
3236:              *               nbr_dig         Number of digits to format (see Note #1).
3237:              *
3238:              *               nbr_base        Base   of number to format (see Note #2).
3239:              *
3240:              *               nbr_neg         Indicates whether number to format is negative :
3241:              *               -------
3242:              *                                   DEF_NO          Number is non-negative.
3243:              *                                   DEF_YES         Number is     negative.
3244:              *
3245:              *                               Argument validated in Str_FmtNbr_Int32U(),
3246:              *                                                     Str_FmtNbr_Int32S().
3247:              *
3248:              *               lead_char       Prepend leading character  (see Note #3) :
3249:              *
3250:              *                                   '\0'                    Do NOT prepend leading character to string.
3251:              *                                     Printable character          Prepend leading character to string.
3252:              *                                   Unprintable character   Format invalid string (see Note #6e).
3253:              *
3254:              *               lower_case      Format alphabetic characters (if any) in lower case :
3255:              *
3256:              *                                   DEF_NO          Format alphabetic characters in upper case.
3257:              *                                   DEF_YES         Format alphabetic characters in lower case.
3258:              *
3259:              *               nul             Append terminating NULL-character (see Note #4) :
3260:              *
3261:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
3262:              *                                   DEF_YES                Append terminating NULL-character to string.
3263:              *
3264:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
3265:              *
3266:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
3267:              *
3268:              *               Pointer to NULL,             otherwise.
3269:              *
3270:              * Caller(s)   : Str_FmtNbr_Int32U(),
3271:              *               Str_FmtNbr_Int32S().
3272:              *$PAGE*
3273:              * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
3274:              *
3275:              *
3276:              *                               Maximum Number of             [  log (Number)      ]
3277:              *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
3278:              *                                   to Format                 [   log (Base)       ]
3279:              *
3280:              *                               where
3281:              *                                       Number                  Number to format
3282:              *                                       Base            Base of number to format
3283:              *
3284:              *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting
3285:              *                           is performed except possible NULL-termination of the string (see Note #4).
3286:              *
3287:              *                               Example :
3288:              *
3289:              *                                   nbr      = -23456
3290:              *                                   nbr_dig  =  0
3291:              *                                   nbr_base = 10
3292:              *
3293:              *                                   pstr     = ""                   See Note #7a
3294:              *
3295:              *                       (2) If the number of digits to format ('nbr_dig') is less than the number of
3296:              *                           significant integer digits of the number to format ('nbr'); then an invalid
3297:              *                           string is formatted instead of truncating any significant integer digits.
3298:              *
3299:              *                               Example :
3300:              *
3301:              *                                   nbr      = 23456
3302:              *                                   nbr_dig  = 3
3303:              *                                   nbr_base = 10
3304:              *
3305:              *                                   pstr     = "???"                See Note #7b
3306:              *
3307:              *                       (3) If the number to format ('nbr') is negative but the number of digits to format
3308:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
3309:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
3310:              *                           the negative sign.
3311:              *
3312:              *                               Example :
3313:              *
3314:              *                                   nbr      = -23456
3315:              *                                   nbr_dig  =  5
3316:              *                                   nbr_base = 10
3317:              *
3318:              *                                   pstr     = "?????"              See Note #7b
3319:              *
3320:              *               (2) The number's base MUST be between 2 & 36, inclusive.
3321:              *$PAGE*
3322:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
3323:              *
3324:              *                   (a) (1) Leading character MUST be a printable ASCII character.
3325:              *
3326:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
3327:              *                           (B) with the exception of '0'.
3328:              *
3329:              *                   (b) (1) The number of leading characters is such that the total number of significant
3330:              *                           integer digits plus the number of leading characters plus possible negative
3331:              *                           sign character is equal to the requested number of integer digits to format
3332:              *                           ('nbr_dig').
3333:              *
3334:              *                               Examples :
3335:              *
3336:              *                                   nbr       = 23456
3337:              *                                   nbr_dig   = 7
3338:              *                                   nbr_base  = 10
3339:              *                                   lead_char = ' '
3340:              *
3341:              *                                   pstr      = "  23456"
3342:              *
3343:              *
3344:              *                                   nbr       = -23456
3345:              *                                   nbr_dig   = 7
3346:              *                                   nbr_base  = 10
3347:              *                                   lead_char = ' '
3348:              *
3349:              *                                   pstr      = " -23456"
3350:              *
3351:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
3352:              *                               ('lead_char') is     a '0' digit; then the negative sign character
3353:              *                               prefixes all leading characters prior to the formatted number.
3354:              *
3355:              *                                   Examples :
3356:              *
3357:              *                                       nbr        = -23456
3358:              *                                       nbr_dig    =  8
3359:              *                                       nbr_base   = 10
3360:              *                                       lead_char  = '0'
3361:              *
3362:              *                                       pstr       = "-0023456"
3363:              *
3364:              *
3365:              *                                       nbr        = -43981
3366:              *                                       nbr_dig    =  8
3367:              *                                       nbr_base   = 16
3368:              *                                       lead_char  = '0'
3369:              *                                       lower_case = DEF_NO
3370:              *
3371:              *                                       pstr       = "-000ABCD"
3372:              *
3373:              *                           (B) If the number to format ('nbr') is negative AND the leading character
3374:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
3375:              *                               immediately prefixes the most significant digit of the formatted number.
3376:              *
3377:              *                                   Examples :
3378:              *
3379:              *                                       nbr        = -23456
3380:              *                                       nbr_dig    =  8
3381:              *                                       nbr_base   = 10
3382:              *                                       lead_char  = '#'
3383:              *
3384:              *                                       pstr       = "##-23456"
3385:              *
3386:              *
3387:              *                                       nbr        = -43981
3388:              *                                       nbr_dig    =  8
3389:              *                                       nbr_base   = 16
3390:              *                                       lead_char  = '#'
3391:              *                                       lower_case = DEF_YES
3392:              *
3393:              *                                       pstr       = "###-abcd"
3394:              *
3395:              *                   (c) (1) If the value of the number to format is     zero  ...
3396:              *                       (2) ... & the number of digits to format is non-zero, ...
3397:              *                       (3) ... but NO leading character available;           ...
3398:              *                       (4) ... then one digit of '0' value is formatted.
3399:              *
3400:              *                           This is NOT a leading character; but a single integer digit of '0' value.
3401:              *$PAGE*
3402:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
3403:              *                       array formatting.
3404:              *
3405:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
3406:              *                       terminate option DISABLED will cause character string run-on.
3407:              *
3408:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
3409:              *
3410:              *                   (b) To prevent character buffer overrun :
3411:              *
3412:              *                           Character array size MUST be  >=  ('nbr_dig'          +
3413:              *                                                               1 negative sign   +
3414:              *                                                               1 'NUL' terminator)  characters
3415:              *
3416:              *               (6) String format terminates when :
3417:              *
3418:              *                   (a) Format string pointer is passed a NULL pointer.
3419:              *                       (1) No      string formatted;                NULL pointer returned.
3420:              *
3421:              *                   (b) Number of digits to format ('nbr_dig') is zero.
3422:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
3423:              *
3424:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
3425:              *                           integer digits of the number to format ('nbr'), including possible
3426:              *                           negative sign.
3427:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3428:              *
3429:              *                   (d) Base is passed an invalid base (see Note #2).
3430:              *                       (1) Invalid string format performed; NULL pointer returned.
3431:              *
3432:              *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
3433:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3434:              *
3435:              *                   (f) Number successfully formatted into character string array.
3436:              *
3437:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
3438:              *                   ('?') will be formatted, where the number of question marks is determined by the
3439:              *                   number of digits to format ('nbr_dig') :
3440:              *
3441:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
3442:              *                          number of     =  {
3443:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
3444:              *
3445:              *********************************************************************************************************
3446:              */
3447:              
3448:              static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
3449:                                                   CPU_INT08U    nbr_dig,
3450:                                                   CPU_INT08U    nbr_base,
3451:                                                   CPU_BOOLEAN   nbr_neg,
3452:                                                   CPU_CHAR      lead_char,
3453:                                                   CPU_BOOLEAN   lower_case,
3454:                                                   CPU_BOOLEAN   nul,
3455:                                                   CPU_CHAR     *pstr)
3456:              {
002AB2  FA0024     LNK #0x24
002AB4  980F50     MOV W0, [W14+26]
002AB6  980F61     MOV W1, [W14+28]
002AB8  985F62     MOV.B W2, [W14+30]
002ABA  985F73     MOV.B W3, [W14+31]
002ABC  986704     MOV.B W4, [W14+32]
002ABE  986715     MOV.B W5, [W14+33]
002AC0  986726     MOV.B W6, [W14+34]
002AC2  986737     MOV.B W7, [W14+35]
3457:                  CPU_CHAR     *pstr_fmt;
3458:                  CPU_DATA      i;
3459:                  CPU_INT32U    nbr_fmt;
3460:                  CPU_INT32U    nbr_log;
3461:                  CPU_INT08U    nbr_dig_max;
3462:                  CPU_INT08U    nbr_dig_min;
3463:                  CPU_INT08U    nbr_dig_fmtd;
3464:                  CPU_INT08U    nbr_neg_sign;
3465:                  CPU_INT08U    nbr_lead_char;
3466:                  CPU_INT08U    dig_val;
3467:                  CPU_INT08U    lead_char_delta_0;
3468:                  CPU_INT08U    lead_char_delta_a;
3469:                  CPU_BOOLEAN   lead_char_dig;
3470:                  CPU_BOOLEAN   lead_char_0;
3471:                  CPU_BOOLEAN   fmt_invalid;
3472:                  CPU_BOOLEAN   print_char;
3473:                  CPU_BOOLEAN   nbr_neg_fmtd;
3474:              
3475:              
3476:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
3477:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
002AC4  97B84E     MOV [W14-8], W0
002AC6  E00000     CP0 W0
002AC8  3A0002     BRA NZ, 0x2ACE
3478:                      return ((CPU_CHAR *)0);
002ACA  EB0000     CLR W0
002ACC  37012C     BRA 0x2D26
3479:                  }
3480:              
3481:                  fmt_invalid = DEF_NO;
002ACE  EB4000     CLR.B W0
002AD0  985710     MOV.B W0, [W14+17]
3482:                  lead_char_0 = DEF_NO;
002AD2  EB4000     CLR.B W0
002AD4  985700     MOV.B W0, [W14+16]
3483:              
3484:                  if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
002AD6  90586E     MOV.B [W14+30], W0
002AD8  E00400     CP0.B W0
002ADA  3A0002     BRA NZ, 0x2AE0
3485:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
002ADC  B3C010     MOV.B #0x1, W0
002ADE  985710     MOV.B W0, [W14+17]
3486:                  }
3487:                                                                              /* If invalid base, ...                                 */
3488:                  if ((nbr_base <  2u) ||
002AE0  90587E     MOV.B [W14+31], W0
002AE2  504FE1     SUB.B W0, #0x1, [W15]
002AE4  360004     BRA LEU, 0x2AEE
002AE6  9058FE     MOV.B [W14+31], W1
002AE8  B3C240     MOV.B #0x24, W0
002AEA  50CF80     SUB.B W1, W0, [W15]
002AEC  360002     BRA LEU, 0x2AF2
3489:                      (nbr_base > 36u)) {
3490:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
002AEE  B3C010     MOV.B #0x1, W0
002AF0  985710     MOV.B W0, [W14+17]
3491:                  }
3492:              
3493:                  if (lead_char != (CPU_CHAR)'\0') {
002AF2  90601E     MOV.B [W14+33], W0
002AF4  E00400     CP0.B W0
002AF6  32003A     BRA Z, 0x2B6C
3494:                      print_char =  ASCII_IsPrint(lead_char);
002AF8  90601E     MOV.B [W14+33], W0
002AFA  071C47     RCALL ASCII_IsPrint
002AFC  985730     MOV.B W0, [W14+19]
3495:                      if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
002AFE  90503E     MOV.B [W14+19], W0
002B00  504FE1     SUB.B W0, #0x1, [W15]
002B02  320003     BRA Z, 0x2B0A
3496:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
002B04  B3C010     MOV.B #0x1, W0
002B06  985710     MOV.B W0, [W14+17]
002B08  370031     BRA 0x2B6C
3497:              
3498:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
002B0A  90609E     MOV.B [W14+33], W1
002B0C  B3C300     MOV.B #0x30, W0
002B0E  50CF80     SUB.B W1, W0, [W15]
002B10  32002D     BRA Z, 0x2B6C
3499:                          lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
002B12  90609E     MOV.B [W14+33], W1
002B14  B3CD00     MOV.B #0xD0, W0
002B16  40C000     ADD.B W1, W0, W0
002B18  985740     MOV.B W0, [W14+20]
3500:                          if (lower_case != DEF_YES) {
002B1A  90602E     MOV.B [W14+34], W0
002B1C  504FE1     SUB.B W0, #0x1, [W15]
002B1E  320005     BRA Z, 0x2B2A
3501:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
002B20  90609E     MOV.B [W14+33], W1
002B22  B3CBF0     MOV.B #0xBF, W0
002B24  40C000     ADD.B W1, W0, W0
002B26  984F70     MOV.B W0, [W14+15]
002B28  370004     BRA 0x2B32
3502:                          } else {
3503:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
002B2A  90609E     MOV.B [W14+33], W1
002B2C  B3C9F0     MOV.B #0x9F, W0
002B2E  40C000     ADD.B W1, W0, W0
002B30  984F70     MOV.B W0, [W14+15]
3504:                          }
3505:              
3506:                          lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
002B32  90587E     MOV.B [W14+31], W0
002B34  504FEA     SUB.B W0, #0xA, [W15]
002B36  3E0004     BRA GTU, 0x2B40
002B38  9050CE     MOV.B [W14+20], W1
002B3A  90587E     MOV.B [W14+31], W0
002B3C  50CF80     SUB.B W1, W0, [W15]
002B3E  39000D     BRA NC, 0x2B5A
002B40  90587E     MOV.B [W14+31], W0
002B42  504FEA     SUB.B W0, #0xA, [W15]
002B44  36000C     BRA LEU, 0x2B5E
002B5A  B3C010     MOV.B #0x1, W0
002B5C  370001     BRA 0x2B60
002B5E  EB4000     CLR.B W0
002B60  985750     MOV.B W0, [W14+21]
3507:                                           ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
002B46  90504E     MOV.B [W14+20], W0
002B48  504FE9     SUB.B W0, #0x9, [W15]
002B4A  360007     BRA LEU, 0x2B5A
002B56  508F80     SUB W1, W0, [W15]
002B58  310002     BRA C, 0x2B5E
3508:                                                                  (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
002B4C  90487E     MOV.B [W14+15], W0
002B4E  FB8080     ZE W0, W1
002B50  90587E     MOV.B [W14+31], W0
002B52  FB8000     ZE W0, W0
002B54  50006A     SUB W0, #0xA, W0
3509:              
3510:                          if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
002B62  90505E     MOV.B [W14+21], W0
002B64  504FE1     SUB.B W0, #0x1, [W15]
002B66  3A0002     BRA NZ, 0x2B6C
3511:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
002B68  B3C010     MOV.B #0x1, W0
002B6A  985710     MOV.B W0, [W14+17]
3512:                          }
3513:                      }
3514:                  }
3515:              
3516:              
3517:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
3518:                  pstr_fmt    = pstr;
002B6C  97B8CE     MOV [W14-8], W1
002B6E  780F01     MOV W1, [W14]
3519:                  lead_char_0 = DEF_NO;
002B70  EB4000     CLR.B W0
002B72  985700     MOV.B W0, [W14+16]
3520:              
3521:                  if (fmt_invalid == DEF_NO) {
002B74  90501E     MOV.B [W14+17], W0
002B76  E00400     CP0.B W0
002B78  3A0057     BRA NZ, 0x2C28
3522:                      nbr_fmt     = nbr;
002B7A  90095E     MOV [W14+26], W2
002B7C  9009EE     MOV [W14+28], W3
002B7E  980722     MOV W2, [W14+4]
002B80  980733     MOV W3, [W14+6]
3523:                      nbr_log     = nbr;
002B82  90095E     MOV [W14+26], W2
002B84  9009EE     MOV [W14+28], W3
002B86  980742     MOV W2, [W14+8]
002B88  980753     MOV W3, [W14+10]
3524:                      nbr_dig_max = 1u;
002B8A  B3C010     MOV.B #0x1, W0
002B8C  984F40     MOV.B W0, [W14+12]
3525:                      while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
002B8E  37000C     BRA 0x2BA8
002BA8  90587E     MOV.B [W14+31], W0
002BAA  FB8100     ZE W0, W2
002BAC  EB0180     CLR W3
002BAE  90004E     MOV [W14+8], W0
002BB0  9000DE     MOV [W14+10], W1
002BB2  510F80     SUB W2, W0, [W15]
002BB4  598F81     SUBB W3, W1, [W15]
002BB6  36FFEC     BRA LEU, 0x2B90
3526:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
002B90  90484E     MOV.B [W14+12], W0
002B92  E84000     INC.B W0, W0
002B94  984F40     MOV.B W0, [W14+12]
3527:                          nbr_log /= nbr_base;
002B96  90587E     MOV.B [W14+31], W0
002B98  FB8000     ZE W0, W0
002B9A  EB0080     CLR W1
002B9C  BE0100     MOV.D W0, W2
002B9E  90004E     MOV [W14+8], W0
002BA0  9000DE     MOV [W14+10], W1
002BA2  07EC3E     RCALL 0x420
002BA4  980740     MOV W0, [W14+8]
002BA6  980751     MOV W1, [W14+10]
3528:                      }
3529:              
3530:                      nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
002BB8  90600E     MOV.B [W14+32], W0
002BBA  504FE1     SUB.B W0, #0x1, [W15]
002BBC  3A0002     BRA NZ, 0x2BC2
002BBE  B3C010     MOV.B #0x1, W0
002BC0  370001     BRA 0x2BC4
002BC2  EB4000     CLR.B W0
002BC4  985760     MOV.B W0, [W14+22]
3531:                      if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
002BC6  90586E     MOV.B [W14+30], W0
002BC8  FB8080     ZE W0, W1
002BCA  90484E     MOV.B [W14+12], W0
002BCC  FB8100     ZE W0, W2
002BCE  90506E     MOV.B [W14+22], W0
002BD0  FB8000     ZE W0, W0
002BD2  410000     ADD W2, W0, W0
002BD4  508F80     SUB W1, W0, [W15]
002BD6  350026     BRA LT, 0x2C24
3532:                          nbr_neg_fmtd = DEF_NO;
002BD8  EB4000     CLR.B W0
002BDA  985720     MOV.B W0, [W14+18]
3533:                          nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
002BDC  9048CE     MOV.B [W14+12], W1
002BDE  90586E     MOV.B [W14+30], W0
002BE0  504F81     SUB.B W0, W1, [W15]
002BE2  360001     BRA LEU, 0x2BE6
002BE4  784001     MOV.B W1, W0
002BE6  985770     MOV.B W0, [W14+23]
3534:                                                                              /* ... calc nbr digs to fmt & nbr lead chars.           */
3535:                          if (lead_char != (CPU_CHAR)'\0') {
002BE8  90601E     MOV.B [W14+33], W0
002BEA  E00400     CP0.B W0
002BEC  320009     BRA Z, 0x2C00
3536:                              nbr_dig_fmtd  = nbr_dig;
002BEE  9059EE     MOV.B [W14+30], W3
002BF0  984F53     MOV.B W3, [W14+13]
3537:                              nbr_lead_char = nbr_dig     -
002BF2  9058EE     MOV.B [W14+30], W1
002BF4  90507E     MOV.B [W14+23], W0
002BF6  50C080     SUB.B W1, W0, W1
002BF8  90506E     MOV.B [W14+22], W0
002BFA  50C000     SUB.B W1, W0, W0
002BFC  984F60     MOV.B W0, [W14+14]
002BFE  370006     BRA 0x2C0C
3538:                                              nbr_dig_min - nbr_neg_sign;
3539:                          } else {
3540:                              nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
002C00  9050FE     MOV.B [W14+23], W1
002C02  90506E     MOV.B [W14+22], W0
002C04  40C000     ADD.B W1, W0, W0
002C06  984F50     MOV.B W0, [W14+13]
3541:                              nbr_lead_char = 0u;
002C08  EB4000     CLR.B W0
002C0A  984F60     MOV.B W0, [W14+14]
3542:                          }
3543:              
3544:                          if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
002C0C  90486E     MOV.B [W14+14], W0
002C0E  E00400     CP0.B W0
002C10  32000B     BRA Z, 0x2C28
3545:                              lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
002C12  90609E     MOV.B [W14+33], W1
002C14  B3C300     MOV.B #0x30, W0
002C16  50CF80     SUB.B W1, W0, [W15]
002C18  3A0002     BRA NZ, 0x2C1E
002C1A  B3C010     MOV.B #0x1, W0
002C1C  370001     BRA 0x2C20
002C1E  EB4000     CLR.B W0
002C20  985700     MOV.B W0, [W14+16]
002C22  370002     BRA 0x2C28
3546:                                          ?  DEF_YES : DEF_NO;
3547:                          }
3548:              
3549:                      } else {                                                /* Else if nbr trunc'd, ...                             */
3550:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
002C24  B3C010     MOV.B #0x1, W0
002C26  985710     MOV.B W0, [W14+17]
3551:                      }
3552:                  }
3553:              
3554:                  if (fmt_invalid != DEF_NO) {
002C28  90501E     MOV.B [W14+17], W0
002C2A  E00400     CP0.B W0
002C2C  320002     BRA Z, 0x2C32
3555:                      nbr_dig_fmtd = nbr_dig;
002C2E  9058EE     MOV.B [W14+30], W1
002C30  984F51     MOV.B W1, [W14+13]
3556:                  }
3557:              
3558:              
3559:                                                                              /* ------------------- FMT NBR STR -------------------- */
3560:                  pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
002C32  90485E     MOV.B [W14+13], W0
002C34  FB8000     ZE W0, W0
002C36  400F1E     ADD W0, [W14], [W14]
3561:              
3562:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
002C38  90603E     MOV.B [W14+35], W0
002C3A  E00400     CP0.B W0
002C3C  320003     BRA Z, 0x2C44
3563:                     *pstr_fmt = (CPU_CHAR)'\0';
002C3E  78001E     MOV [W14], W0
002C40  EB4080     CLR.B W1
002C42  784801     MOV.B W1, [W0]
3564:                  }
3565:                  pstr_fmt--;
002C44  E90F1E     DEC [W14], [W14]
3566:              
3567:              
3568:                  for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
002C46  EB0000     CLR W0
002C48  980710     MOV W0, [W14+2]
002C4A  370062     BRA 0x2D10
002D0A  90001E     MOV [W14+2], W0
002D0C  E80000     INC W0, W0
002D0E  980710     MOV W0, [W14+2]
002D10  90485E     MOV.B [W14+13], W0
002D12  FB8080     ZE W0, W1
002D14  90001E     MOV [W14+2], W0
002D16  508F80     SUB W1, W0, [W15]
002D18  3EFF99     BRA GTU, 0x2C4C
3569:                      if (fmt_invalid == DEF_NO) {
002C4C  90501E     MOV.B [W14+17], W0
002C4E  E00400     CP0.B W0
002C50  3A0056     BRA NZ, 0x2CFE
3570:                          if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
002C52  90002E     MOV [W14+4], W0
002C54  9000BE     MOV [W14+6], W1
002C56  500FE0     SUB W0, #0x0, [W15]
002C58  588FE0     SUBB W1, #0x0, [W15]
002C5A  3A0003     BRA NZ, 0x2C62
002C5C  90001E     MOV [W14+2], W0
002C5E  E00000     CP0 W0
002C60  3A002D     BRA NZ, 0x2CBC
3571:                              (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
3572:                                                                              /* ... calc & fmt dig val;                      ...     */
3573:                              dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
002C62  90587E     MOV.B [W14+31], W0
002C64  FB8000     ZE W0, W0
002C66  EB0080     CLR W1
002C68  90022E     MOV [W14+4], W4
002C6A  9002BE     MOV [W14+6], W5
002C6C  BE0100     MOV.D W0, W2
002C6E  BE0004     MOV.D W4, W0
002C70  07EBE7     RCALL 0x440
002C72  985F00     MOV.B W0, [W14+24]
3574:                              if (dig_val < 10u) {
002C74  90580E     MOV.B [W14+24], W0
002C76  504FE9     SUB.B W0, #0x9, [W15]
002C78  3E0007     BRA GTU, 0x2C88
3575:                                 *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
002C7A  90580E     MOV.B [W14+24], W0
002C7C  B3C302     MOV.B #0x30, W2
002C7E  404082     ADD.B W0, W2, W1
002C80  78001E     MOV [W14], W0
002C82  784801     MOV.B W1, [W0]
002C84  E90F1E     DEC [W14], [W14]
002C86  370010     BRA 0x2CA8
3576:                              } else {
3577:                                  if (lower_case !=  DEF_YES) {
002C88  90602E     MOV.B [W14+34], W0
002C8A  504FE1     SUB.B W0, #0x1, [W15]
002C8C  320007     BRA Z, 0x2C9C
3578:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
002C8E  90580E     MOV.B [W14+24], W0
002C90  B3C373     MOV.B #0x37, W3
002C92  404083     ADD.B W0, W3, W1
002C94  78001E     MOV [W14], W0
002C96  784801     MOV.B W1, [W0]
002C98  E90F1E     DEC [W14], [W14]
002C9A  370006     BRA 0x2CA8
3579:                                  } else {
3580:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
002C9C  90580E     MOV.B [W14+24], W0
002C9E  B3C572     MOV.B #0x57, W2
002CA0  404082     ADD.B W0, W2, W1
002CA2  78001E     MOV [W14], W0
002CA4  784801     MOV.B W1, [W0]
002CA6  E90F1E     DEC [W14], [W14]
3581:                                  }
3582:                              }
3583:              
3584:                              nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
002CA8  90587E     MOV.B [W14+31], W0
002CAA  FB8000     ZE W0, W0
002CAC  EB0080     CLR W1
002CAE  BE0100     MOV.D W0, W2
002CB0  90002E     MOV [W14+4], W0
002CB2  9000BE     MOV [W14+6], W1
002CB4  07EBB5     RCALL 0x420
002CB6  980720     MOV W0, [W14+4]
002CB8  980731     MOV W1, [W14+6]
002CBA  370027     BRA 0x2D0A
3585:              
3586:                          } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
002CBC  90600E     MOV.B [W14+32], W0
002CBE  504FE1     SUB.B W0, #0x1, [W15]
002CC0  3A0016     BRA NZ, 0x2CEE
002CC2  90500E     MOV.B [W14+16], W0
002CC4  E00400     CP0.B W0
002CC6  3A0003     BRA NZ, 0x2CCE
3587:                                   (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
002CC8  90502E     MOV.B [W14+18], W0
002CCA  E00400     CP0.B W0
002CCC  320009     BRA Z, 0x2CE0
3588:                                     (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
002CCE  90500E     MOV.B [W14+16], W0
002CD0  E00400     CP0.B W0
002CD2  32000D     BRA Z, 0x2CEE
3589:                                    ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
002CDA  90001E     MOV [W14+2], W0
002CDC  508F80     SUB W1, W0, [W15]
002CDE  3A0007     BRA NZ, 0x2CEE
3590:                                     (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
002CD4  90485E     MOV.B [W14+13], W0
002CD6  FB8000     ZE W0, W0
002CD8  E90080     DEC W0, W1
3591:              
3592:                             *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
002CE0  78001E     MOV [W14], W0
002CE2  B3C2D1     MOV.B #0x2D, W1
002CE4  784801     MOV.B W1, [W0]
002CE6  E90F1E     DEC [W14], [W14]
3593:                              nbr_neg_fmtd = DEF_YES;
002CE8  B3C010     MOV.B #0x1, W0
002CEA  985720     MOV.B W0, [W14+18]
002CEC  37000E     BRA 0x2D0A
3594:              
3595:                          } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
002CEE  90601E     MOV.B [W14+33], W0
002CF0  E00400     CP0.B W0
002CF2  32000A     BRA Z, 0x2D08
3596:                             *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
002CF4  78001E     MOV [W14], W0
002CF6  90619E     MOV.B [W14+33], W3
002CF8  784803     MOV.B W3, [W0]
002CFA  E90F1E     DEC [W14], [W14]
002CFC  370006     BRA 0x2D0A
002D08  000000     NOP
3597:                          }
3598:              
3599:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
3600:                         *pstr_fmt-- = '?';
002CFE  78001E     MOV [W14], W0
002D00  B3C3F1     MOV.B #0x3F, W1
002D02  784801     MOV.B W1, [W0]
002D04  E90F1E     DEC [W14], [W14]
002D06  370001     BRA 0x2D0A
3601:                      }
3602:                  }
3603:              
3604:              
3605:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
002D1A  90501E     MOV.B [W14+17], W0
002D1C  E00400     CP0.B W0
002D1E  320002     BRA Z, 0x2D24
3606:                      return ((CPU_CHAR *)0);
002D20  EB0000     CLR W0
002D22  370001     BRA 0x2D26
3607:                  }
3608:              
3609:              
3610:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
002D24  97B84E     MOV [W14-8], W0
3611:              }
002D26  FA8000     ULNK
002D28  060000     RETURN
3612:              
3613:              
3614:              /*
3615:              *********************************************************************************************************
3616:              *                                        Str_ParseNbr_Int32()
3617:              *
3618:              * Description : Parse 32-bit integer from string.
3619:              *
3620:              * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
3621:              *
3622:              *               pstr_next       Optional pointer to a variable to ... :
3623:              *
3624:              *                                   (a) Return a pointer to first character following the integer string,
3625:              *                                           if NO error(s) [see Note #2a2B2];
3626:              *                                   (b) Return a pointer to 'pstr',
3627:              *                                           otherwise      (see Note #2a2A2).
3628:              *
3629:              *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
3630:              *
3631:              *               nbr_signed      Indicates whether number to parse is signed :
3632:              *
3633:              *                                   DEF_NO                  Number is unsigned.
3634:              *                                   DEF_YES                 Number is   signed.
3635:              *
3636:              *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
3637:              *
3638:              *                                   DEF_NO                  Number is non-negative.
3639:              *                                   DEF_YES                 Number is     negative.
3640:              *
3641:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
3642:              *
3643:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
3644:              *
3645:              *               0,                   otherwise                            (see Note #2a3B).
3646:              *
3647:              * Caller(s)   : Str_ParseNbr_Int32U(),
3648:              *               Str_ParseNbr_Int32S().
3649:              *
3650:              * Note(s)     : (1) String buffer NOT modified.
3651:              *
3652:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3653:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3654:              *                       to a type long ... representation" :
3655:              *
3656:              *                       (1) "First, they decompose the input string into three parts" :
3657:              *
3658:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3659:              *                                by isspace()]."
3660:              *
3661:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3662:              *                                    input string, starting with the first non-white-space character that is of
3663:              *                                    the expected form.  The subject sequence shall contain no characters if the
3664:              *                                    input string is empty or consists entirely of white-space characters."
3665:              *
3666:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3667:              *                                    determined by the value of 'base' ('nbr_base')" :
3668:              *
3669:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3670:              *                                        subject sequence is that of a decimal constant, octal constant, or
3671:              *                                        hexadecimal constant" :
3672:              *
3673:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3674:              *                                            sequence of decimal digits."
3675:              *
3676:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3677:              *                                            a sequence of the digits '0' to '7' only."
3678:              *
3679:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3680:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3681:              *                                            (or 'F') with values 10 to 15 respectively."
3682:              *
3683:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3684:              *                                        of the subject sequence is a sequence of letters and digits representing
3685:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3686:              *
3687:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3688:              *                                                ascribed the values 10 to 35"; ...
3689:              *                                           (B) "only letters whose ascribed values are less than that of base
3690:              *                                                are permitted."
3691:              *
3692:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3693:              *                                               '0X' may optionally precede the sequence of letters and digits."
3694:              *
3695:              *                                           (B) Although NO specification states that "if the value of 'base'
3696:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3697:              *                                               the sequence of letters and digits"; it seems reasonable to
3698:              *                                               allow the '0' character to be optionally parsed.
3699:              *$PAGE*
3700:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3701:              *
3702:              *                                   (a) It does NOT seem reasonable to parse & convert a negative number
3703:              *                                       integer string into an unsigned integer.  However, a negative sign
3704:              *                                       for an unsigned integer will automatically be parsed as an invalid
3705:              *                                       character (see Note #2aC1).
3706:              *
3707:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3708:              *                                   (b) "including the terminating null byte of the input string" ...
3709:              *                               (2) "other than a sign or a permissible letter or digit."
3710:              *
3711:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3712:              *
3713:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3714:              *
3715:              *                               (1) "no conversion is performed"; ...
3716:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3717:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3718:              *
3719:              *                           (B) "If the subject sequence has the expected form" :
3720:              *
3721:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3722:              *                                        starting with the first digit shall be interpreted as an integer constant."
3723:              *
3724:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3725:              *                                        used as the base for conversion, ascribing to each letter its value as
3726:              *                                        given above" (see Note #2a1B1b1A).
3727:              *
3728:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3729:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3730:              *                                   pointer."
3731:              *
3732:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3733:              *
3734:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3735:              *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
3736:              *                                    [or] {LONG_MAX} ... shall be returned."
3737:              *
3738:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3739:              *
3740:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3741:              *                           shall fail if" :
3742:              *
3743:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3744:              *
3745:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3746:              *
3747:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3748:              *                           may fail if" :
3749:              *
3750:              *                           (A) "[EINVAL] - No conversion could be performed."
3751:              *$PAGE*
3752:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3753:              *
3754:              *                   (a) Valid parse string integer :
3755:              *
3756:              *                           pstr      = "     ABCDE xyz"
3757:              *                           nbr_base  = 16
3758:              *
3759:              *                           nbr       = 703710
3760:              *                           pstr_next = " xyz"
3761:              *
3762:              *
3763:              *                   (b) Invalid parse string integer :
3764:              *
3765:              *                           pstr      = "     ABCDE"
3766:              *                           nbr_base  = 10
3767:              *
3768:              *                           nbr       =  0
3769:              *                           pstr_next = pstr = "     ABCDE"
3770:              *
3771:              *
3772:              *                   (c) Valid hexadecimal parse string integer :
3773:              *
3774:              *                           pstr      = "     0xGABCDE"
3775:              *                           nbr_base  = 16
3776:              *
3777:              *                           nbr       =  0
3778:              *                           pstr_next = "xGABCDE"
3779:              *
3780:              *
3781:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3782:              *                               following invalid hexadecimal characters) :
3783:              *
3784:              *                           pstr      = "     0xGABCDE"
3785:              *                           nbr_base  =  0
3786:              *
3787:              *                           nbr       =  0
3788:              *                           pstr_next = "xGABCDE"
3789:              *
3790:              *
3791:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3792:              *                               following invalid octal       characters) :
3793:              *
3794:              *                           pstr      = "     0GABCDE"
3795:              *                           nbr_base  =  0
3796:              *
3797:              *                           nbr       =  0
3798:              *                           pstr_next = "GABCDE"
3799:              *
3800:              *
3801:              *                   (f) Parse string integer overflow :
3802:              *
3803:              *                           pstr      = "   12345678901234567890*123456"
3804:              *                           nbr_base  = 10
3805:              *
3806:              *                           nbr       = DEF_INT_32U_MAX_VAL
3807:              *                           pstr_next = "*123456"
3808:              *
3809:              *
3810:              *                   (g) Parse string integer underflow :
3811:              *
3812:              *                           pstr      = "  -12345678901234567890*123456"
3813:              *                           nbr_base  = 10
3814:              *
3815:              *                           nbr       = DEF_INT_32S_MIN_VAL
3816:              *                           pstr_next = "*123456"
3817:              *
3818:              *
3819:              *               (4) String parse terminates when :
3820:              *
3821:              *                   (a) Base passed an invalid base (see Note #2a1B1b).
3822:              *                       (1) No conversion performed; 0 returned.
3823:              *
3824:              *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
3825:              *                           (A) No conversion performed; 0 returned.
3826:              *
3827:              *                       (2) Invalid parse string character found (see Note #2a1C).
3828:              *                           (A) Parsed integer returned.
3829:              *                           (B) 'pstr_next' points to invalid character.
3830:              *
3831:              *                       (3) Entire  parse string converted (see Note #2a2B).
3832:              *                           (A) Parsed integer returned.
3833:              *                           (B) 'pstr_next' points to terminating NULL character.
3834:              *
3835:              *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
3836:              *                   validation or function handling in case of any error(s).
3837:              *********************************************************************************************************
3838:              */
3839:              
3840:              static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
3841:                                                             CPU_CHAR     **pstr_next,
3842:                                                             CPU_INT08U     nbr_base,
3843:                                                             CPU_BOOLEAN    nbr_signed,
3844:                                                             CPU_BOOLEAN   *pnbr_neg)
3845:              {
002D2A  FA0020     LNK #0x20
002D2C  980F40     MOV W0, [W14+24]
002D2E  980F51     MOV W1, [W14+26]
002D30  985F42     MOV.B W2, [W14+28]
002D32  985F53     MOV.B W3, [W14+29]
002D34  980F74     MOV W4, [W14+30]
3846:                  const  CPU_CHAR     *pstr_parse;
3847:                  const  CPU_CHAR     *pstr_parse_nbr;
3848:                         CPU_CHAR     *pstr_parse_unused;
3849:                         CPU_CHAR      parse_char;
3850:                         CPU_INT08U    parse_dig;
3851:                         CPU_INT32U    nbr;
3852:                         CPU_BOOLEAN   nbr_neg_unused;
3853:                         CPU_BOOLEAN   nbr_dig;
3854:                         CPU_BOOLEAN   nbr_alpha;
3855:                         CPU_BOOLEAN   nbr_hex;
3856:                         CPU_BOOLEAN   nbr_hex_lower;
3857:                         CPU_BOOLEAN   whitespace;
3858:                         CPU_BOOLEAN   neg;
3859:                         CPU_BOOLEAN   ovf;
3860:                         CPU_BOOLEAN   done;
3861:              
3862:                                                                              /* --------------- VALIDATE PARSE ARGS ---------------- */
3863:                  if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
002D36  90085E     MOV [W14+26], W0
002D38  E00000     CP0 W0
002D3A  3A0002     BRA NZ, 0x2D40
3864:                      pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
002D3C  470074     ADD W14, #0x14, W0
002D3E  980F50     MOV W0, [W14+26]
3865:                     (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
3866:                  }
3867:                 *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
002D40  90085E     MOV [W14+26], W0
002D42  9008CE     MOV [W14+24], W1
002D44  780801     MOV W1, [W0]
3868:              
3869:                  if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
002D46  90087E     MOV [W14+30], W0
002D48  E00000     CP0 W0
002D4A  3A0002     BRA NZ, 0x2D50
3870:                      pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
002D4C  470076     ADD W14, #0x16, W0
002D4E  980F70     MOV W0, [W14+30]
3871:                     (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
3872:                  }
3873:                 *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
002D50  90087E     MOV [W14+30], W0
002D52  EB4080     CLR.B W1
002D54  784801     MOV.B W1, [W0]
3874:              
3875:              
3876:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
002D56  90084E     MOV [W14+24], W0
002D58  E00000     CP0 W0
002D5A  3A0002     BRA NZ, 0x2D60
3877:                      return (0u);
002D5C  B80060     MUL.UU W0, #0, W0
002D5E  37010A     BRA 0x2F74
3878:                  }
3879:                                                                              /* Rtn zero if invalid base (see Note #4a).             */
3880:                  if ((nbr_base == 1u) ||
002D60  90584E     MOV.B [W14+28], W0
002D62  504FE1     SUB.B W0, #0x1, [W15]
002D64  320004     BRA Z, 0x2D6E
002D66  9058CE     MOV.B [W14+28], W1
002D68  B3C240     MOV.B #0x24, W0
002D6A  50CF80     SUB.B W1, W0, [W15]
002D6C  360002     BRA LEU, 0x2D72
3881:                      (nbr_base > 36u)) {
3882:                      return (0u);
002D6E  B80060     MUL.UU W0, #0, W0
002D70  370101     BRA 0x2F74
3883:                  }
3884:              
3885:              
3886:                                                                              /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
3887:                  pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
002D72  9008CE     MOV [W14+24], W1
002D74  780F01     MOV W1, [W14]
3888:              
3889:                  whitespace = ASCII_IsSpace(*pstr_parse);
002D76  78001E     MOV [W14], W0
002D78  784010     MOV.B [W0], W0
002D7A  071AEB     RCALL ASCII_IsSpace
002D7C  984F00     MOV.B W0, [W14+8]
3890:                  while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
002D7E  370005     BRA 0x2D8A
002D8A  90480E     MOV.B [W14+8], W0
002D8C  504FE1     SUB.B W0, #0x1, [W15]
002D8E  32FFF8     BRA Z, 0x2D80
3891:                      pstr_parse++;
002D80  E80F1E     INC [W14], [W14]
3892:                      whitespace = ASCII_IsSpace(*pstr_parse);
002D82  78001E     MOV [W14], W0
002D84  784010     MOV.B [W0], W0
002D86  071AE5     RCALL ASCII_IsSpace
002D88  984F00     MOV.B W0, [W14+8]
3893:                  }
3894:              
3895:                  switch (*pstr_parse) {
002D90  78001E     MOV [W14], W0
002D92  784010     MOV.B [W0], W0
002D94  FB8000     ZE W0, W0
002D96  2002B1     MOV #0x2B, W1
002D98  500F81     SUB W0, W1, [W15]
002D9A  320004     BRA Z, 0x2DA4
002D9C  2002D1     MOV #0x2D, W1
002D9E  500F81     SUB W0, W1, [W15]
002DA0  320005     BRA Z, 0x2DAC
002DA2  37000B     BRA 0x2DBA
3896:                      case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
3897:                           pstr_parse++;
002DA4  E80F1E     INC [W14], [W14]
3898:                           neg = DEF_NO;
002DA6  EB4000     CLR.B W0
002DA8  984F10     MOV.B W0, [W14+9]
3899:                           break;
002DAA  37000A     BRA 0x2DC0
3900:              
3901:              
3902:                      case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
3903:                           if (nbr_signed == DEF_YES) {
002DAC  90585E     MOV.B [W14+29], W0
002DAE  504FE1     SUB.B W0, #0x1, [W15]
002DB0  3A0001     BRA NZ, 0x2DB4
3904:                               pstr_parse++;
002DB2  E80F1E     INC [W14], [W14]
3905:                           }
3906:                           neg = DEF_YES;
002DB4  B3C010     MOV.B #0x1, W0
002DB6  984F10     MOV.B W0, [W14+9]
3907:                           break;
002DB8  370003     BRA 0x2DC0
3908:              
3909:              
3910:                      default:
3911:                           neg = DEF_NO;
002DBA  EB4000     CLR.B W0
002DBC  984F10     MOV.B W0, [W14+9]
3912:                           break;
002DBE  000000     NOP
3913:                  }
3914:              
3915:              
3916:                                                                              /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
3917:                  pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
002DC0  78009E     MOV [W14], W1
002DC2  980761     MOV W1, [W14+12]
3918:              
3919:                  switch (nbr_base) {
002DC4  90584E     MOV.B [W14+28], W0
002DC6  FB8000     ZE W0, W0
002DC8  500FE8     SUB W0, #0x8, [W15]
002DCA  320027     BRA Z, 0x2E1A
002DCC  500FF0     SUB W0, #0x10, [W15]
002DCE  32002C     BRA Z, 0x2E28
002DD0  E00000     CP0 W0
002DD2  3A0046     BRA NZ, 0x2E60
3920:                      case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
3921:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
002DD4  78001E     MOV [W14], W0
002DD6  784090     MOV.B [W0], W1
002DD8  B3C300     MOV.B #0x30, W0
002DDA  50CF80     SUB.B W1, W0, [W15]
002DDC  3A001B     BRA NZ, 0x2E14
3922:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
002DDE  E80F1E     INC [W14], [W14]
3923:                                switch (*pstr_parse) {
002DE0  78001E     MOV [W14], W0
002DE2  784010     MOV.B [W0], W0
002DE4  FB8000     ZE W0, W0
002DE6  200581     MOV #0x58, W1
002DE8  500F81     SUB W0, W1, [W15]
002DEA  320003     BRA Z, 0x2DF2
002DEC  200781     MOV #0x78, W1
002DEE  500F81     SUB W0, W1, [W15]
002DF0  3A000D     BRA NZ, 0x2E0C
3924:                                    case 'x':                                 /* For '0x' prefix, ...                                 */
3925:                                    case 'X':
3926:                                         nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
002DF2  B3C100     MOV.B #0x10, W0
002DF4  985F40     MOV.B W0, [W14+28]
3927:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
002DF6  E8001E     INC [W14], W0
002DF8  784090     MOV.B [W0], W1
002DFA  984F61     MOV.B W1, [W14+14]
3928:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
002DFC  90486E     MOV.B [W14+14], W0
002DFE  071A78     RCALL ASCII_IsDigHex
002E00  984F70     MOV.B W0, [W14+15]
3929:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
002E02  90487E     MOV.B [W14+15], W0
002E04  504FE1     SUB.B W0, #0x1, [W15]
002E06  3A0001     BRA NZ, 0x2E0A
3930:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
002E08  E80F1E     INC [W14], [W14]
3931:                                         }
3932:                                         break;
002E0A  370003     BRA 0x2E12
3933:              
3934:              
3935:                                    default:                                  /* For '0'  prefix, ...                                 */
3936:                                         nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
002E0C  B3C080     MOV.B #0x8, W0
002E0E  985F40     MOV.B W0, [W14+28]
3937:                                         break;
002E10  000000     NOP
3938:                                }
3939:              
3940:                           } else {                                           /* For non-'0' prefix, ...                              */
3941:                               nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
002E14  B3C0A0     MOV.B #0xA, W0
002E16  985F40     MOV.B W0, [W14+28]
3942:                           }
3943:                           break;
002E12  37002B     BRA 0x2E6A
002E18  370028     BRA 0x2E6A
3944:              
3945:              
3946:                      case  8u:                                               /* See Note #2a1B1a2.                                   */
3947:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
002E1A  78001E     MOV [W14], W0
002E1C  784090     MOV.B [W0], W1
002E1E  B3C300     MOV.B #0x30, W0
002E20  50CF80     SUB.B W1, W0, [W15]
002E22  3A0020     BRA NZ, 0x2E64
3948:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
002E24  E80F1E     INC [W14], [W14]
3949:                           }
3950:                           break;
002E26  370021     BRA 0x2E6A
002E64  000000     NOP
002E66  370001     BRA 0x2E6A
3951:              
3952:              
3953:                      case 16u:                                               /* See Note #2a1B1a3.                                   */
3954:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
002E28  78001E     MOV [W14], W0
002E2A  784090     MOV.B [W0], W1
002E2C  B3C300     MOV.B #0x30, W0
002E2E  50CF80     SUB.B W1, W0, [W15]
002E30  3A001B     BRA NZ, 0x2E68
3955:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
002E32  E80F1E     INC [W14], [W14]
3956:                                switch (*pstr_parse) {
002E34  78001E     MOV [W14], W0
002E36  784010     MOV.B [W0], W0
002E38  FB8000     ZE W0, W0
002E3A  200581     MOV #0x58, W1
002E3C  500F81     SUB W0, W1, [W15]
002E3E  320004     BRA Z, 0x2E48
002E40  200781     MOV #0x78, W1
002E42  500F81     SUB W0, W1, [W15]
002E44  320001     BRA Z, 0x2E48
3957:                                    case 'x':
3958:                                    case 'X':
3959:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
002E48  E8001E     INC [W14], W0
002E4A  784090     MOV.B [W0], W1
002E4C  984F61     MOV.B W1, [W14+14]
3960:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
002E4E  90486E     MOV.B [W14+14], W0
002E50  071A4F     RCALL ASCII_IsDigHex
002E52  984F70     MOV.B W0, [W14+15]
3961:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
002E54  90487E     MOV.B [W14+15], W0
002E56  504FE1     SUB.B W0, #0x1, [W15]
002E58  3A0001     BRA NZ, 0x2E5C
3962:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
002E5A  E80F1E     INC [W14], [W14]
3963:                                         }
3964:                                         break;
002E5C  000000     NOP
3965:              
3966:              
3967:                                    default:
3968:                                         break;
002E46  37000B     BRA 0x2E5E
3969:                                }
3970:                           }
3971:                           break;
002E5E  370005     BRA 0x2E6A
002E68  000000     NOP
3972:              
3973:              
3974:                      default:                                                /* See Note #2a1B1b.                                    */
3975:                           break;
002E60  000000     NOP
002E62  370003     BRA 0x2E6A
3976:                  }
3977:              
3978:              
3979:                                                                              /* ------------------ PARSE INT STR ------------------- */
3980:                  nbr  = 0u;
002E6A  B80060     MUL.UU W0, #0, W0
002E6C  980720     MOV W0, [W14+4]
002E6E  980731     MOV W1, [W14+6]
3981:                  ovf  = DEF_NO;
002E70  EB4000     CLR.B W0
002E72  984F20     MOV.B W0, [W14+10]
3982:                  done = DEF_NO;
002E74  EB4000     CLR.B W0
002E76  984F30     MOV.B W0, [W14+11]
3983:              
3984:                  while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
002E78  370064     BRA 0x2F42
002F42  90483E     MOV.B [W14+11], W0
002F44  E00400     CP0.B W0
002F46  32FF99     BRA Z, 0x2E7A
3985:                      parse_char = (CPU_CHAR)*pstr_parse;
002E7A  78001E     MOV [W14], W0
002E7C  784090     MOV.B [W0], W1
002E7E  984F61     MOV.B W1, [W14+14]
3986:                      nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
002E80  90486E     MOV.B [W14+14], W0
002E82  0719D1     RCALL ASCII_IsAlphaNum
002E84  985700     MOV.B W0, [W14+16]
3987:                      if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
002E86  90500E     MOV.B [W14+16], W0
002E88  504FE1     SUB.B W0, #0x1, [W15]
002E8A  3A0059     BRA NZ, 0x2F3E
3988:                                                                              /* ... convert parse char into nbr dig.                 */
3989:                          nbr_dig = ASCII_IsDig(parse_char);
002E8C  90486E     MOV.B [W14+14], W0
002E8E  071A0E     RCALL ASCII_IsDig
002E90  985710     MOV.B W0, [W14+17]
3990:                          if (nbr_dig == DEF_YES) {
002E92  90501E     MOV.B [W14+17], W0
002E94  504FE1     SUB.B W0, #0x1, [W15]
002E96  3A0005     BRA NZ, 0x2EA2
3991:                              parse_dig = (CPU_INT08U)(parse_char - '0');
002E98  9048EE     MOV.B [W14+14], W1
002E9A  B3CD00     MOV.B #0xD0, W0
002E9C  40C000     ADD.B W1, W0, W0
002E9E  984720     MOV.B W0, [W14+2]
002EA0  37000F     BRA 0x2EC0
3992:                          } else {
3993:                              nbr_hex_lower = ASCII_IsLower(parse_char);
002EA2  90486E     MOV.B [W14+14], W0
002EA4  0719E1     RCALL ASCII_IsLower
002EA6  985720     MOV.B W0, [W14+18]
3994:                              if (nbr_hex_lower == DEF_YES) {
002EA8  90502E     MOV.B [W14+18], W0
002EAA  504FE1     SUB.B W0, #0x1, [W15]
002EAC  3A0005     BRA NZ, 0x2EB8
3995:                                  parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
002EAE  9048EE     MOV.B [W14+14], W1
002EB0  B3CA90     MOV.B #0xA9, W0
002EB2  40C000     ADD.B W1, W0, W0
002EB4  984720     MOV.B W0, [W14+2]
002EB6  370004     BRA 0x2EC0
3996:                              } else {
3997:                                  parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
002EB8  9048EE     MOV.B [W14+14], W1
002EBA  B3CC90     MOV.B #0xC9, W0
002EBC  40C000     ADD.B W1, W0, W0
002EBE  984720     MOV.B W0, [W14+2]
3998:                              }
3999:                          }
4000:              
4001:                          if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
002EC0  9040AE     MOV.B [W14+2], W1
002EC2  90584E     MOV.B [W14+28], W0
002EC4  50CF80     SUB.B W1, W0, [W15]
002EC6  310038     BRA C, 0x2F38
4002:                              if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
002EC8  90482E     MOV.B [W14+10], W0
002ECA  E00400     CP0.B W0
002ECC  3A0033     BRA NZ, 0x2F34
4003:                                  if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
002ECE  90584E     MOV.B [W14+28], W0
002ED0  FB8000     ZE W0, W0
002ED2  DD00C2     SL W0, #2, W1
002ED4  2876E0     MOV #0x876E, W0
002ED6  408000     ADD W1, W0, W0
002ED8  BE0110     MOV.D [W0], W2
002EDA  90002E     MOV [W14+4], W0
002EDC  9000BE     MOV [W14+6], W1
002EDE  510F80     SUB W2, W0, [W15]
002EE0  598F81     SUBB W3, W1, [W15]
002EE2  390026     BRA NC, 0x2F30
4004:                                                                              /* ... merge parse char dig into nbr.                   */
4005:                                      nbr *= nbr_base;
002EE4  90584E     MOV.B [W14+28], W0
002EE6  FB8000     ZE W0, W0
002EE8  EB0080     CLR W1
002EEA  90013E     MOV [W14+6], W2
002EEC  B99100     MUL.SS W2, W0, W2
002EEE  780102     MOV W2, W2
002EF0  9001AE     MOV [W14+4], W3
002EF2  B99A01     MUL.SS W3, W1, W4
002EF4  780184     MOV W4, W3
002EF6  410103     ADD W2, W3, W2
002EF8  9001AE     MOV [W14+4], W3
002EFA  B81800     MUL.UU W3, W0, W0
002EFC  410101     ADD W2, W1, W2
002EFE  780082     MOV W2, W1
002F00  980720     MOV W0, [W14+4]
002F02  980731     MOV W1, [W14+6]
002F04  980720     MOV W0, [W14+4]
002F06  980731     MOV W1, [W14+6]
4006:                                      nbr += parse_dig;
002F08  90402E     MOV.B [W14+2], W0
002F0A  FB8000     ZE W0, W0
002F0C  EB0080     CLR W1
002F0E  90012E     MOV [W14+4], W2
002F10  9001BE     MOV [W14+6], W3
002F12  400002     ADD W0, W2, W0
002F14  488083     ADDC W1, W3, W1
002F16  980720     MOV W0, [W14+4]
002F18  980731     MOV W1, [W14+6]
4007:                                      if (nbr < parse_dig) {
002F1A  90402E     MOV.B [W14+2], W0
002F1C  FB8100     ZE W0, W2
002F1E  EB0180     CLR W3
002F20  90002E     MOV [W14+4], W0
002F22  9000BE     MOV [W14+6], W1
002F24  510F80     SUB W2, W0, [W15]
002F26  598F81     SUBB W3, W1, [W15]
002F28  360005     BRA LEU, 0x2F34
4008:                                          ovf = DEF_YES;
002F2A  B3C010     MOV.B #0x1, W0
002F2C  984F20     MOV.B W0, [W14+10]
002F2E  370002     BRA 0x2F34
4009:                                      }
4010:                                  } else {
4011:                                      ovf = DEF_YES;
002F30  B3C010     MOV.B #0x1, W0
002F32  984F20     MOV.B W0, [W14+10]
4012:                                  }
4013:                              }
4014:                              pstr_parse++;
002F34  E80F1E     INC [W14], [W14]
002F36  370005     BRA 0x2F42
4015:              
4016:                          } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
4017:                              done = DEF_YES;
002F38  B3C010     MOV.B #0x1, W0
002F3A  984F30     MOV.B W0, [W14+11]
002F3C  370002     BRA 0x2F42
4018:                          }
4019:              
4020:                      } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
4021:                          done = DEF_YES;
002F3E  B3C010     MOV.B #0x1, W0
002F40  984F30     MOV.B W0, [W14+11]
4022:                      }
4023:                  }
4024:              
4025:                  if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
002F48  90482E     MOV.B [W14+10], W0
002F4A  504FE1     SUB.B W0, #0x1, [W15]
002F4C  3A0004     BRA NZ, 0x2F56
4026:                      nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
002F4E  EB8000     SETM W0
002F50  EB8080     SETM W1
002F52  980720     MOV W0, [W14+4]
002F54  980731     MOV W1, [W14+6]
4027:                  }
4028:              
4029:              
4030:                  if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
002F56  90006E     MOV [W14+12], W0
002F58  78009E     MOV [W14], W1
002F5A  508F80     SUB W1, W0, [W15]
002F5C  320003     BRA Z, 0x2F64
4031:                     *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
002F5E  90085E     MOV [W14+26], W0
002F60  78081E     MOV [W14], [W0]
002F62  370003     BRA 0x2F6A
4032:                  } else {
4033:                     *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
002F64  90085E     MOV [W14+26], W0
002F66  9008CE     MOV [W14+24], W1
002F68  780801     MOV W1, [W0]
4034:                  }
4035:              
4036:                 *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
002F6A  90087E     MOV [W14+30], W0
002F6C  90489E     MOV.B [W14+9], W1
002F6E  784801     MOV.B W1, [W0]
4037:              
4038:              
4039:                  return (nbr);
002F70  90002E     MOV [W14+4], W0
002F72  9000BE     MOV [W14+6], W1
4040:              }
002F74  FA8000     ULNK
4041:              
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uC-LIB/lib_mem.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     STANDARD MEMORY OPERATIONS
29:                *
30:                * Filename      : lib_mem.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 FGK
34:                *                 JFD
35:                *                 FBJ
36:                *                 EJ
37:                *********************************************************************************************************
38:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
39:                *
40:                *                     (a) ALL standard library functions are implemented in the custom library modules :
41:                *
42:                *                         (1) \<Custom Library Directory>\lib_*.*
43:                *
44:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
45:                *
46:                *                               where
47:                *                                       <Custom Library Directory>      directory path for custom library software
48:                *                                       <cpu>                           directory name for specific processor (CPU)
49:                *                                       <compiler>                      directory name for specific compiler
50:                *
51:                *                     (b) Product-specific library functions are implemented in individual products.
52:                *********************************************************************************************************
53:                */
54:                
55:                
56:                /*
57:                *********************************************************************************************************
58:                *                                            INCLUDE FILES
59:                *********************************************************************************************************
60:                */
61:                
62:                #define    MICRIUM_SOURCE
63:                #define    LIB_MEM_MODULE
64:                #include  "lib_mem.h"
65:                #include  "lib_math.h"
66:                #include  "lib_str.h"
67:                
68:                
69:                /*
70:                *********************************************************************************************************
71:                *                                            LOCAL DEFINES
72:                *********************************************************************************************************
73:                */
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                           LOCAL CONSTANTS
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                          LOCAL DATA TYPES
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                            LOCAL TABLES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                       LOCAL GLOBAL VARIABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               
104:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
105:               #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
106:               CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
107:               #endif
108:               
109:               MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
110:               #endif
111:               
112:               MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
113:               
114:               
115:               /*
116:               *********************************************************************************************************
117:               *                                      LOCAL FUNCTION PROTOTYPES
118:               *********************************************************************************************************
119:               */
120:               
121:               static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
122:                                                                      MEM_SEG       *p_seg,
123:                                                                      CPU_ADDR       seg_base_addr,
124:                                                                      CPU_SIZE_T     padding_align,
125:                                                                      CPU_SIZE_T     size);
126:               
127:               static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
128:                                                                      CPU_SIZE_T     size,
129:                                                                      LIB_ERR       *p_err);
130:               
131:               static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
132:                                                                      MEM_SEG       *p_seg,
133:                                                                      CPU_SIZE_T     size,
134:                                                                      CPU_SIZE_T     align,
135:                                                                      CPU_SIZE_T     padding_align,
136:                                                                      CPU_SIZE_T    *p_bytes_reqd,
137:                                                                      LIB_ERR       *p_err);
138:               
139:               static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
140:                                                                      CPU_SIZE_T     size,
141:                                                                      CPU_SIZE_T     align,
142:                                                                      CPU_SIZE_T     padding_align,
143:                                                                      CPU_SIZE_T    *p_bytes_reqd,
144:                                                                      LIB_ERR       *p_err);
145:               
146:               static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
147:                                                                      MEM_DYN_POOL  *p_pool,
148:                                                                      MEM_SEG       *p_seg,
149:                                                                      CPU_SIZE_T     blk_size,
150:                                                                      CPU_SIZE_T     blk_align,
151:                                                                      CPU_SIZE_T     blk_padding_align,
152:                                                                      CPU_SIZE_T     blk_qty_init,
153:                                                                      CPU_SIZE_T     blk_qty_max,
154:                                                                      LIB_ERR       *p_err);
155:               
156:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
157:               static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
158:                                                                      MEM_SEG       *p_seg,
159:                                                                      CPU_SIZE_T     size,
160:                                                                      LIB_ERR       *p_err);
161:               #endif
162:               
163:               #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
164:                    (LIB_MEM_CFG_HEAP_SIZE      >  0u))
165:               static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
166:                                                                      void          *p_mem);
167:               #endif
168:               
169:               
170:               /*
171:               *********************************************************************************************************
172:               *                                     LOCAL CONFIGURATION ERRORS
173:               *********************************************************************************************************
174:               */
175:               
176:               /*
177:               *********************************************************************************************************
178:               *********************************************************************************************************
179:               *                                            GLOBAL FUNCTIONS
180:               *********************************************************************************************************
181:               *********************************************************************************************************
182:               */
183:               
184:               /*
185:               *********************************************************************************************************
186:               *                                             Mem_Init()
187:               *
188:               * Description : (1) Initializes Memory Management Module :
189:               *
190:               *                   (a) Initialize heap memory pool
191:               *                   (b) Initialize      memory pool table
192:               *
193:               *
194:               * Argument(s) : none.
195:               *
196:               * Return(s)   : none.
197:               *
198:               * Caller(s)   : Application.
199:               *
200:               * Note(s)     : (2) Mem_Init() MUST be called ... :
201:               *
202:               *                   (a) ONLY ONCE from a product's application; ...
203:               *                   (b) BEFORE product's application calls any memory library module function(s)
204:               *********************************************************************************************************
205:               */
206:               
207:               void  Mem_Init (void)
208:               {
0016B0  FA0004     LNK #0x4
209:               
210:                                                                               /* ------------------ INIT SEG LIST ------------------- */
211:                   Mem_SegHeadPtr = DEF_NULL;
0016B2  EF2828     CLR Mem_SegHeadPtr
212:               
213:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
214:                   {
215:                       LIB_ERR   err;
216:                       CPU_ADDR  heap_base_addr;
217:               
218:               
219:                                                                               /* ------------------ INIT HEAP SEG ------------------- */
220:               #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
221:                       heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
222:               #else
223:                       heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
0016B4  20CB80     MOV #0xCB8, W0
0016B6  780F00     MOV W0, [W14]
224:               #endif
225:               
226:                       Mem_SegCreate("Heap",
0016B8  288020     MOV #0x8802, W0
0016BA  E8808E     INC2 W14, W1
0016BC  780281     MOV W1, W5
0016BE  200014     MOV #0x1, W4
0016C0  204003     MOV #0x400, W3
0016C2  78011E     MOV [W14], W2
0016C4  210B81     MOV #0x10B8, W1
0016C6  070204     RCALL Mem_SegCreate
227:                                     &Mem_SegHeap,                             /* Create heap seg.                                     */
228:                                      heap_base_addr,
229:                                      LIB_MEM_CFG_HEAP_SIZE,
230:                                      LIB_MEM_PADDING_ALIGN_NONE,
231:                                     &err);
232:                       if (err != LIB_MEM_ERR_NONE) {
0016C8  90009E     MOV [W14+2], W1
0016CA  227100     MOV #0x2710, W0
0016CC  508F80     SUB W1, W0, [W15]
0016CE  320001     BRA Z, 0x16D2
233:                           CPU_SW_EXCEPTION(;);
0016D0  0723BC     RCALL CPU_SW_Exception
234:                       }
235:                   }
236:               #endif
237:               }
0016D2  FA8000     ULNK
0016D4  060000     RETURN
238:               
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                              Mem_Clr()
243:               *
244:               * Description : Clears data buffer (see Note #2).
245:               *
246:               * Argument(s) : pmem        Pointer to memory buffer to clear.
247:               *
248:               *               size        Number of data buffer octets to clear (see Note #1).
249:               *
250:               * Return(s)   : none.
251:               *
252:               * Caller(s)   : Application.
253:               *
254:               * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
255:               *
256:               *                   See also 'Mem_Set()  Note #1'.
257:               *
258:               *               (2) Clear data by setting each data octet to 0.
259:               *********************************************************************************************************
260:               */
261:               
262:               void  Mem_Clr (void        *pmem,
263:                              CPU_SIZE_T   size)
264:               {
0016D6  FA0004     LNK #0x4
0016D8  780F00     MOV W0, [W14]
0016DA  980711     MOV W1, [W14+2]
265:                   Mem_Set(pmem,
0016DC  90011E     MOV [W14+2], W2
0016DE  EB4080     CLR.B W1
0016E0  78001E     MOV [W14], W0
0016E2  070002     RCALL Mem_Set
266:                           0u,                                                 /* See Note #2.                                         */
267:                           size);
268:               }
0016E4  FA8000     ULNK
0016E6  060000     RETURN
269:               
270:               
271:               /*
272:               *********************************************************************************************************
273:               *                                              Mem_Set()
274:               *
275:               * Description : Fills data buffer with specified data octet.
276:               *
277:               * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
278:               *
279:               *               data_val    Data fill octet value.
280:               *
281:               *               size        Number of data buffer octets to fill (see Note #1).
282:               *
283:               * Return(s)   : none.
284:               *
285:               * Caller(s)   : Application.
286:               *
287:               * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
288:               *
289:               *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
290:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
291:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
292:               *                   addresses.
293:               *
294:               *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
295:               *                   address boundary.
296:               *
297:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
298:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
299:               *                  'mem_align_mod' arithmetic operation.
300:               *********************************************************************************************************
301:               */
302:               
303:               void  Mem_Set (void        *pmem,
304:                              CPU_INT08U   data_val,
305:                              CPU_SIZE_T   size)
306:               {
0016E8  FA0012     LNK #0x12
0016EA  980760     MOV W0, [W14+12]
0016EC  984F61     MOV.B W1, [W14+14]
0016EE  980F02     MOV W2, [W14+16]
307:                   CPU_SIZE_T   size_rem;
308:                   CPU_ALIGN    data_align;
309:                   CPU_ALIGN   *pmem_align;
310:                   CPU_INT08U  *pmem_08;
311:                   CPU_DATA     mem_align_mod;
312:                   CPU_DATA     i;
313:               
314:               
315:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
316:                   if (size < 1) {                                             /* See Note #1.                                         */
317:                       return;
318:                   }
319:                   if (pmem == (void *)0) {
320:                       return;
321:                   }
322:               #endif
323:               
324:               
325:                   data_align = 0u;
0016F0  EB0000     CLR W0
0016F2  980710     MOV W0, [W14+2]
326:                   for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
0016F4  EB0000     CLR W0
0016F6  980740     MOV W0, [W14+8]
0016F8  37000B     BRA 0x1710
00170A  90004E     MOV [W14+8], W0
00170C  E80000     INC W0, W0
00170E  980740     MOV W0, [W14+8]
001710  90004E     MOV [W14+8], W0
001712  500FE1     SUB W0, #0x1, [W15]
001714  36FFF2     BRA LEU, 0x16FA
327:                       data_align <<=  DEF_OCTET_NBR_BITS;
0016FA  90001E     MOV [W14+2], W0
0016FC  DD0048     SL W0, #8, W0
0016FE  980710     MOV W0, [W14+2]
328:                       data_align  |= (CPU_ALIGN)data_val;
001700  90486E     MOV.B [W14+14], W0
001702  FB8000     ZE W0, W0
001704  90009E     MOV [W14+2], W1
001706  700001     IOR W0, W1, W0
001708  980710     MOV W0, [W14+2]
329:                   }
330:               
331:                   size_rem      =  size;
001716  90088E     MOV [W14+16], W1
001718  780F01     MOV W1, [W14]
332:                   mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
00171A  90006E     MOV [W14+12], W0
00171C  784000     MOV.B W0, W0
00171E  FB8000     ZE W0, W0
001720  600061     AND W0, #0x1, W0
001722  980750     MOV W0, [W14+10]
333:               
334:                   pmem_08 = (CPU_INT08U *)pmem;
001724  9000EE     MOV [W14+12], W1
001726  980731     MOV W1, [W14+6]
335:                   if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
001728  90005E     MOV [W14+10], W0
00172A  E00000     CP0 W0
00172C  320013     BRA Z, 0x1754
336:                       i = mem_align_mod;
00172E  9000DE     MOV [W14+10], W1
001730  980741     MOV W1, [W14+8]
337:                       while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
001732  37000A     BRA 0x1748
001748  78001E     MOV [W14], W0
00174A  E00000     CP0 W0
00174C  320003     BRA Z, 0x1754
00174E  90004E     MOV [W14+8], W0
001750  500FE1     SUB W0, #0x1, [W15]
001752  36FFF0     BRA LEU, 0x1734
338:                              (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
339:                          *pmem_08++ = data_val;
001734  90003E     MOV [W14+6], W0
001736  9048EE     MOV.B [W14+14], W1
001738  784801     MOV.B W1, [W0]
00173A  90003E     MOV [W14+6], W0
00173C  E80000     INC W0, W0
00173E  980730     MOV W0, [W14+6]
340:                           size_rem -= sizeof(CPU_INT08U);
001740  E90F1E     DEC [W14], [W14]
341:                           i++;
001742  90004E     MOV [W14+8], W0
001744  E80000     INC W0, W0
001746  980740     MOV W0, [W14+8]
342:                       }
343:                   }
344:               
345:                   pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
001754  9000BE     MOV [W14+6], W1
001756  980721     MOV W1, [W14+4]
346:                   while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
001758  370007     BRA 0x1768
001768  78001E     MOV [W14], W0
00176A  500FE1     SUB W0, #0x1, [W15]
00176C  3EFFF6     BRA GTU, 0x175A
347:                      *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
00175A  90002E     MOV [W14+4], W0
00175C  90009E     MOV [W14+2], W1
00175E  780801     MOV W1, [W0]
001760  90002E     MOV [W14+4], W0
001762  E88000     INC2 W0, W0
001764  980720     MOV W0, [W14+4]
348:                       size_rem    -= sizeof(CPU_ALIGN);
001766  E98F1E     DEC2 [W14], [W14]
349:                   }
350:               
351:                   pmem_08 = (CPU_INT08U *)pmem_align;
00176E  9000AE     MOV [W14+4], W1
001770  980731     MOV W1, [W14+6]
352:                   while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
001772  370007     BRA 0x1782
001782  78001E     MOV [W14], W0
001784  E00000     CP0 W0
001786  3AFFF6     BRA NZ, 0x1774
353:                      *pmem_08++   = data_val;
001774  90003E     MOV [W14+6], W0
001776  9048EE     MOV.B [W14+14], W1
001778  784801     MOV.B W1, [W0]
00177A  90003E     MOV [W14+6], W0
00177C  E80000     INC W0, W0
00177E  980730     MOV W0, [W14+6]
354:                       size_rem   -= sizeof(CPU_INT08U);
001780  E90F1E     DEC [W14], [W14]
355:                   }
356:               }
001788  FA8000     ULNK
00178A  060000     RETURN
357:               
358:               
359:               /*
360:               *********************************************************************************************************
361:               *                                             Mem_Copy()
362:               *
363:               * Description : Copies data octets from one memory buffer to another memory buffer.
364:               *
365:               * Argument(s) : pdest       Pointer to destination memory buffer.
366:               *
367:               *               psrc        Pointer to source      memory buffer.
368:               *
369:               *               size        Number of octets to copy (see Note #1).
370:               *
371:               * Return(s)   : none.
372:               *
373:               * Caller(s)   : Application.
374:               *
375:               * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
376:               *
377:               *               (2) Memory buffers NOT checked for overlapping.
378:               *
379:               *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
380:               *                       copying takes place between objects that overlap, the behavior is undefined".
381:               *
382:               *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
383:               *                       successfully copy to a destination memory buffer at a lower  address value even
384:               *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
385:               *                       word copy overlaps.
386:               *
387:               *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
388:               *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
389:               *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
390:               *                       ever overlap.
391:               *
392:               *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
393:               *                       buffers as long as the source memory buffer is at a higher address value than the
394:               *                       destination memory buffer.
395:               *
396:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
397:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
398:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
399:               *                   addresses.
400:               *
401:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
402:               *                   address boundary.
403:               *
404:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
405:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
406:               *                  'mem_align_mod' arithmetic operation.
407:               *********************************************************************************************************
408:               */
409:               
410:               #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
411:               void  Mem_Copy (       void        *pdest,
412:                               const  void        *psrc,
413:                                      CPU_SIZE_T   size)
414:               {
00178C  FA001A     LNK #0x1A
00178E  980F20     MOV W0, [W14+20]
001790  980F31     MOV W1, [W14+22]
001792  980F42     MOV W2, [W14+24]
415:                          CPU_SIZE_T    size_rem;
416:                          CPU_SIZE_T    mem_gap_octets;
417:                          CPU_ALIGN    *pmem_align_dest;
418:                   const  CPU_ALIGN    *pmem_align_src;
419:                          CPU_INT08U   *pmem_08_dest;
420:                   const  CPU_INT08U   *pmem_08_src;
421:                          CPU_DATA      i;
422:                          CPU_DATA      mem_align_mod_dest;
423:                          CPU_DATA      mem_align_mod_src;
424:                          CPU_BOOLEAN   mem_aligned;
425:               
426:               
427:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
428:                   if (size < 1) {                                             /* See Note #1.                                         */
429:                       return;
430:                   }
431:                   if (pdest == (void *)0) {
432:                       return;
433:                   }
434:                   if (psrc  == (void *)0) {
435:                       return;
436:                   }
437:               #endif
438:               
439:               
440:                   size_rem           =  size;
001794  9008CE     MOV [W14+24], W1
001796  780F01     MOV W1, [W14]
441:               
442:                   pmem_08_dest       = (      CPU_INT08U *)pdest;
001798  9008AE     MOV [W14+20], W1
00179A  980731     MOV W1, [W14+6]
443:                   pmem_08_src        = (const CPU_INT08U *)psrc;
00179C  9008BE     MOV [W14+22], W1
00179E  980741     MOV W1, [W14+8]
444:               
445:                   mem_gap_octets     = pmem_08_src - pmem_08_dest;
0017A0  9000CE     MOV [W14+8], W1
0017A2  90003E     MOV [W14+6], W0
0017A4  508000     SUB W1, W0, W0
0017A6  980760     MOV W0, [W14+12]
446:               
447:               
448:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
0017A8  90006E     MOV [W14+12], W0
0017AA  500FE1     SUB W0, #0x1, [W15]
0017AC  360052     BRA LEU, 0x1852
449:                                                                               /* See Note #4.                                         */
450:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
0017AE  90003E     MOV [W14+6], W0
0017B0  784000     MOV.B W0, W0
0017B2  FB8000     ZE W0, W0
0017B4  600061     AND W0, #0x1, W0
0017B6  980770     MOV W0, [W14+14]
451:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
0017B8  90004E     MOV [W14+8], W0
0017BA  784000     MOV.B W0, W0
0017BC  FB8000     ZE W0, W0
0017BE  600061     AND W0, #0x1, W0
0017C0  980F00     MOV W0, [W14+16]
452:               
453:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
0017C2  9000FE     MOV [W14+14], W1
0017C4  90080E     MOV [W14+16], W0
0017C6  508F80     SUB W1, W0, [W15]
0017C8  3A0002     BRA NZ, 0x17CE
0017CA  B3C010     MOV.B #0x1, W0
0017CC  370001     BRA 0x17D0
0017CE  EB4000     CLR.B W0
0017D0  985720     MOV.B W0, [W14+18]
454:               
455:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
0017D2  90502E     MOV.B [W14+18], W0
0017D4  504FE1     SUB.B W0, #0x1, [W15]
0017D6  3A003D     BRA NZ, 0x1852
456:                                                                               /* ... optimize copy for mem buf alignment.             */
457:                           if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
0017D8  90007E     MOV [W14+14], W0
0017DA  E00000     CP0 W0
0017DC  320017     BRA Z, 0x180C
458:                               i = mem_align_mod_dest;
0017DE  9000FE     MOV [W14+14], W1
0017E0  980751     MOV W1, [W14+10]
459:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
0017E2  37000E     BRA 0x1800
001800  78001E     MOV [W14], W0
001802  E00000     CP0 W0
001804  320003     BRA Z, 0x180C
001806  90005E     MOV [W14+10], W0
001808  500FE1     SUB W0, #0x1, [W15]
00180A  36FFEC     BRA LEU, 0x17E4
460:                                      (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
461:                                  *pmem_08_dest++ = *pmem_08_src++;
0017E4  90004E     MOV [W14+8], W0
0017E6  784090     MOV.B [W0], W1
0017E8  90003E     MOV [W14+6], W0
0017EA  784801     MOV.B W1, [W0]
0017EC  90003E     MOV [W14+6], W0
0017EE  E80000     INC W0, W0
0017F0  980730     MOV W0, [W14+6]
0017F2  90004E     MOV [W14+8], W0
0017F4  E80000     INC W0, W0
0017F6  980740     MOV W0, [W14+8]
462:                                   size_rem      -=  sizeof(CPU_INT08U);
0017F8  E90F1E     DEC [W14], [W14]
463:                                   i++;
0017FA  90005E     MOV [W14+10], W0
0017FC  E80000     INC W0, W0
0017FE  980750     MOV W0, [W14+10]
464:                               }
465:                           }
466:               
467:                           pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
00180C  9000BE     MOV [W14+6], W1
00180E  980711     MOV W1, [W14+2]
468:                           pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
001810  9000CE     MOV [W14+8], W1
001812  980721     MOV W1, [W14+4]
469:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
001814  37000B     BRA 0x182C
00182C  78001E     MOV [W14], W0
00182E  500FE1     SUB W0, #0x1, [W15]
001830  3EFFF2     BRA GTU, 0x1816
470:                              *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
001816  90002E     MOV [W14+4], W0
001818  780090     MOV [W0], W1
00181A  90001E     MOV [W14+2], W0
00181C  780801     MOV W1, [W0]
00181E  90001E     MOV [W14+2], W0
001820  E88000     INC2 W0, W0
001822  980710     MOV W0, [W14+2]
001824  90002E     MOV [W14+4], W0
001826  E88000     INC2 W0, W0
001828  980720     MOV W0, [W14+4]
471:                               size_rem         -=  sizeof(CPU_ALIGN);
00182A  E98F1E     DEC2 [W14], [W14]
472:                           }
473:               
474:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
001832  90009E     MOV [W14+2], W1
001834  980731     MOV W1, [W14+6]
475:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
001836  9000AE     MOV [W14+4], W1
001838  980741     MOV W1, [W14+8]
476:                       }
477:                   }
478:               
479:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
00183A  37000B     BRA 0x1852
001852  78001E     MOV [W14], W0
001854  E00000     CP0 W0
001856  3AFFF2     BRA NZ, 0x183C
480:                      *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
00183C  90004E     MOV [W14+8], W0
00183E  784090     MOV.B [W0], W1
001840  90003E     MOV [W14+6], W0
001842  784801     MOV.B W1, [W0]
001844  90003E     MOV [W14+6], W0
001846  E80000     INC W0, W0
001848  980730     MOV W0, [W14+6]
00184A  90004E     MOV [W14+8], W0
00184C  E80000     INC W0, W0
00184E  980740     MOV W0, [W14+8]
481:                       size_rem      -=  sizeof(CPU_INT08U);
001850  E90F1E     DEC [W14], [W14]
482:                   }
483:               }
001858  FA8000     ULNK
00185A  060000     RETURN
484:               #endif
485:               
486:               
487:               /*
488:               *********************************************************************************************************
489:               *                                             Mem_Move()
490:               *
491:               * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
492:               *               memory buffer. Overlapping is correctly handled for all move operations.
493:               *
494:               * Argument(s) : pdest       Pointer to destination memory buffer.
495:               *
496:               *               psrc        Pointer to source      memory buffer.
497:               *
498:               *               size        Number of octets to move (see Note #1).
499:               *
500:               * Return(s)   : none.
501:               *
502:               * Caller(s)   : Application.
503:               *
504:               * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
505:               *
506:               *               (2) Memory buffers checked for overlapping.
507:               *
508:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
509:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
510:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
511:               *                   addresses.
512:               *
513:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
514:               *                   address boundary.
515:               *
516:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
517:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
518:               *                  'mem_align_mod' arithmetic operation.
519:               *********************************************************************************************************
520:               */
521:               
522:               void  Mem_Move (       void        *pdest,
523:                               const  void        *psrc,
524:                                      CPU_SIZE_T   size)
525:               {
00185C  FA001A     LNK #0x1A
00185E  980F20     MOV W0, [W14+20]
001860  980F31     MOV W1, [W14+22]
001862  980F42     MOV W2, [W14+24]
526:                          CPU_SIZE_T    size_rem;
527:                          CPU_SIZE_T    mem_gap_octets;
528:                          CPU_ALIGN    *pmem_align_dest;
529:                   const  CPU_ALIGN    *pmem_align_src;
530:                          CPU_INT08U   *pmem_08_dest;
531:                   const  CPU_INT08U   *pmem_08_src;
532:                          CPU_INT08S    i;
533:                          CPU_DATA      mem_align_mod_dest;
534:                          CPU_DATA      mem_align_mod_src;
535:                          CPU_BOOLEAN   mem_aligned;
536:               
537:               
538:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
539:                   if (size < 1) {
540:                       return;
541:                   }
542:                   if (pdest == (void *)0) {
543:                       return;
544:                   }
545:                   if (psrc  == (void *)0) {
546:                       return;
547:                   }
548:               #endif
549:               
550:                   pmem_08_src  = (const CPU_INT08U *)psrc;
001864  9008BE     MOV [W14+22], W1
001866  980741     MOV W1, [W14+8]
551:                   pmem_08_dest = (      CPU_INT08U *)pdest;
001868  9008AE     MOV [W14+20], W1
00186A  980731     MOV W1, [W14+6]
552:                   if (pmem_08_src > pmem_08_dest) {
00186C  9000CE     MOV [W14+8], W1
00186E  90003E     MOV [W14+6], W0
001870  508F80     SUB W1, W0, [W15]
001872  360005     BRA LEU, 0x187E
553:                       Mem_Copy(pdest, psrc, size);
001874  90094E     MOV [W14+24], W2
001876  9008BE     MOV [W14+22], W1
001878  90082E     MOV [W14+20], W0
00187A  07FF88     RCALL Mem_Copy
554:                       return;
00187C  37006C     BRA 0x1956
555:                   }
556:               
557:                   size_rem           =  size;
00187E  9008CE     MOV [W14+24], W1
001880  780F01     MOV W1, [W14]
558:               
559:                   pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
001882  9008AE     MOV [W14+20], W1
001884  90084E     MOV [W14+24], W0
001886  E90000     DEC W0, W0
001888  408000     ADD W1, W0, W0
00188A  980730     MOV W0, [W14+6]
560:                   pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
00188C  9008BE     MOV [W14+22], W1
00188E  90084E     MOV [W14+24], W0
001890  E90000     DEC W0, W0
001892  408000     ADD W1, W0, W0
001894  980740     MOV W0, [W14+8]
561:               
562:                   mem_gap_octets     = pmem_08_dest - pmem_08_src;
001896  9000BE     MOV [W14+6], W1
001898  90004E     MOV [W14+8], W0
00189A  508000     SUB W1, W0, W0
00189C  980760     MOV W0, [W14+12]
563:               
564:               
565:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
00189E  90006E     MOV [W14+12], W0
0018A0  500FE1     SUB W0, #0x1, [W15]
0018A2  360056     BRA LEU, 0x1950
566:               
567:                                                                               /* See Note #4.                                         */
568:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
0018A4  90003E     MOV [W14+6], W0
0018A6  784000     MOV.B W0, W0
0018A8  FB8000     ZE W0, W0
0018AA  600061     AND W0, #0x1, W0
0018AC  980770     MOV W0, [W14+14]
569:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
0018AE  90004E     MOV [W14+8], W0
0018B0  784000     MOV.B W0, W0
0018B2  FB8000     ZE W0, W0
0018B4  600061     AND W0, #0x1, W0
0018B6  980F00     MOV W0, [W14+16]
570:               
571:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
0018B8  9000FE     MOV [W14+14], W1
0018BA  90080E     MOV [W14+16], W0
0018BC  508F80     SUB W1, W0, [W15]
0018BE  3A0002     BRA NZ, 0x18C4
0018C0  B3C010     MOV.B #0x1, W0
0018C2  370001     BRA 0x18C6
0018C4  EB4000     CLR.B W0
0018C6  985720     MOV.B W0, [W14+18]
572:               
573:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
0018C8  90502E     MOV.B [W14+18], W0
0018CA  504FE1     SUB.B W0, #0x1, [W15]
0018CC  3A0041     BRA NZ, 0x1950
574:                                                                               /* ... optimize copy for mem buf alignment.             */
575:                           if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
0018CE  90007E     MOV [W14+14], W0
0018D0  500FE1     SUB W0, #0x1, [W15]
0018D2  320017     BRA Z, 0x1902
576:                               i = mem_align_mod_dest;
0018D4  90007E     MOV [W14+14], W0
0018D6  984F20     MOV.B W0, [W14+10]
577:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
0018D8  37000E     BRA 0x18F6
0018F6  78001E     MOV [W14], W0
0018F8  E00000     CP0 W0
0018FA  320003     BRA Z, 0x1902
0018FC  90482E     MOV.B [W14+10], W0
0018FE  E00400     CP0.B W0
001900  3DFFEC     BRA GE, 0x18DA
578:                                      (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
579:                                  *pmem_08_dest-- = *pmem_08_src--;
0018DA  90004E     MOV [W14+8], W0
0018DC  784090     MOV.B [W0], W1
0018DE  90003E     MOV [W14+6], W0
0018E0  784801     MOV.B W1, [W0]
0018E2  90003E     MOV [W14+6], W0
0018E4  E90000     DEC W0, W0
0018E6  980730     MOV W0, [W14+6]
0018E8  90004E     MOV [W14+8], W0
0018EA  E90000     DEC W0, W0
0018EC  980740     MOV W0, [W14+8]
580:                                   size_rem      -=  sizeof(CPU_INT08U);
0018EE  E90F1E     DEC [W14], [W14]
581:                                   i--;
0018F0  90482E     MOV.B [W14+10], W0
0018F2  E94000     DEC.B W0, W0
0018F4  984F20     MOV.B W0, [W14+10]
582:                               }
583:                           }
584:               
585:                                                                               /* See Note #3.                                         */
586:                           pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
001902  90003E     MOV [W14+6], W0
001904  E90000     DEC W0, W0
001906  980710     MOV W0, [W14+2]
587:                           pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
001908  90004E     MOV [W14+8], W0
00190A  E90000     DEC W0, W0
00190C  980720     MOV W0, [W14+4]
588:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
00190E  37000B     BRA 0x1926
001926  78001E     MOV [W14], W0
001928  500FE1     SUB W0, #0x1, [W15]
00192A  3EFFF2     BRA GTU, 0x1910
589:                              *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
001910  90002E     MOV [W14+4], W0
001912  780090     MOV [W0], W1
001914  90001E     MOV [W14+2], W0
001916  780801     MOV W1, [W0]
001918  90001E     MOV [W14+2], W0
00191A  E98000     DEC2 W0, W0
00191C  980710     MOV W0, [W14+2]
00191E  90002E     MOV [W14+4], W0
001920  E98000     DEC2 W0, W0
001922  980720     MOV W0, [W14+4]
590:                               size_rem         -=  sizeof(CPU_ALIGN);
001924  E98F1E     DEC2 [W14], [W14]
591:                           }
592:               
593:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
00192C  90001E     MOV [W14+2], W0
00192E  E80000     INC W0, W0
001930  980730     MOV W0, [W14+6]
594:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
001932  90002E     MOV [W14+4], W0
001934  E80000     INC W0, W0
001936  980740     MOV W0, [W14+8]
595:               
596:                       }
597:                   }
598:               
599:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
001938  37000B     BRA 0x1950
001950  78001E     MOV [W14], W0
001952  E00000     CP0 W0
001954  3AFFF2     BRA NZ, 0x193A
600:                      *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
00193A  90004E     MOV [W14+8], W0
00193C  784090     MOV.B [W0], W1
00193E  90003E     MOV [W14+6], W0
001940  784801     MOV.B W1, [W0]
001942  90003E     MOV [W14+6], W0
001944  E90000     DEC W0, W0
001946  980730     MOV W0, [W14+6]
001948  90004E     MOV [W14+8], W0
00194A  E90000     DEC W0, W0
00194C  980740     MOV W0, [W14+8]
601:                       size_rem      -=  sizeof(CPU_INT08U);
00194E  E90F1E     DEC [W14], [W14]
602:                   }
603:               }
001956  FA8000     ULNK
001958  060000     RETURN
604:               
605:               
606:               /*
607:               *********************************************************************************************************
608:               *                                              Mem_Cmp()
609:               *
610:               * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
611:               *
612:               * Argument(s) : p1_mem      Pointer to first  memory buffer.
613:               *
614:               *               p2_mem      Pointer to second memory buffer.
615:               *
616:               *               size        Number of data buffer octets to compare (see Note #1).
617:               *
618:               * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
619:               *
620:               *               DEF_NO,  otherwise.
621:               *
622:               * Caller(s)   : Application.
623:               *
624:               * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
625:               *                   identical null compare.
626:               *
627:               *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
628:               *                   network address buffers.  Consequently, memory buffer comparison is more efficient
629:               *                   if the comparison starts from the end of the memory buffers which will abort sooner
630:               *                   on dissimilar memory buffers that vary only in the least significant octets.
631:               *
632:               *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
633:               *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
634:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
635:               *                   addresses.
636:               *
637:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
638:               *                   address boundary.
639:               *
640:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
641:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
642:               *                  'mem_align_mod' arithmetic operation.
643:               *********************************************************************************************************
644:               */
645:               
646:               CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
647:                                     const  void        *p2_mem,
648:                                            CPU_SIZE_T   size)
649:               {
00195A  FA001A     LNK #0x1A
00195C  980F20     MOV W0, [W14+20]
00195E  980F31     MOV W1, [W14+22]
001960  980F42     MOV W2, [W14+24]
650:                          CPU_SIZE_T    size_rem;
651:                          CPU_ALIGN    *p1_mem_align;
652:                          CPU_ALIGN    *p2_mem_align;
653:                   const  CPU_INT08U   *p1_mem_08;
654:                   const  CPU_INT08U   *p2_mem_08;
655:                          CPU_DATA      i;
656:                          CPU_DATA      mem_align_mod_1;
657:                          CPU_DATA      mem_align_mod_2;
658:                          CPU_BOOLEAN   mem_aligned;
659:                          CPU_BOOLEAN   mem_cmp;
660:               
661:               
662:                   if (size < 1) {                                             /* See Note #1.                                         */
001962  90084E     MOV [W14+24], W0
001964  E00000     CP0 W0
001966  3A0002     BRA NZ, 0x196C
663:                       return (DEF_YES);
001968  B3C010     MOV.B #0x1, W0
00196A  370084     BRA 0x1A74
664:                   }
665:                   if (p1_mem == (void *)0) {
00196C  90082E     MOV [W14+20], W0
00196E  E00000     CP0 W0
001970  3A0002     BRA NZ, 0x1976
666:                       return (DEF_NO);
001972  EB4000     CLR.B W0
001974  37007F     BRA 0x1A74
667:                   }
668:                   if (p2_mem == (void *)0) {
001976  90083E     MOV [W14+22], W0
001978  E00000     CP0 W0
00197A  3A0002     BRA NZ, 0x1980
669:                       return (DEF_NO);
00197C  EB4000     CLR.B W0
00197E  37007A     BRA 0x1A74
670:                   }
671:               
672:               
673:                   mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
001980  B3C010     MOV.B #0x1, W0
001982  984F40     MOV.B W0, [W14+12]
674:                   size_rem        =  size;
001984  9008CE     MOV [W14+24], W1
001986  780F01     MOV W1, [W14]
675:                                                                               /* Start @ end of mem bufs (see Note #2).               */
676:                   p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
001988  9008AE     MOV [W14+20], W1
00198A  90084E     MOV [W14+24], W0
00198C  408000     ADD W1, W0, W0
00198E  980730     MOV W0, [W14+6]
677:                   p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
001990  9008BE     MOV [W14+22], W1
001992  90084E     MOV [W14+24], W0
001994  408000     ADD W1, W0, W0
001996  980740     MOV W0, [W14+8]
678:                                                                               /* See Note #4.                                         */
679:                   mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
001998  90003E     MOV [W14+6], W0
00199A  784000     MOV.B W0, W0
00199C  FB8000     ZE W0, W0
00199E  600061     AND W0, #0x1, W0
0019A0  980770     MOV W0, [W14+14]
680:                   mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
0019A2  90004E     MOV [W14+8], W0
0019A4  784000     MOV.B W0, W0
0019A6  FB8000     ZE W0, W0
0019A8  600061     AND W0, #0x1, W0
0019AA  980F00     MOV W0, [W14+16]
681:               
682:                   mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
0019AC  9000FE     MOV [W14+14], W1
0019AE  90080E     MOV [W14+16], W0
0019B0  508F80     SUB W1, W0, [W15]
0019B2  3A0002     BRA NZ, 0x19B8
0019B4  B3C010     MOV.B #0x1, W0
0019B6  370001     BRA 0x19BA
0019B8  EB4000     CLR.B W0
0019BA  985720     MOV.B W0, [W14+18]
683:               
684:                   if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
0019BC  90502E     MOV.B [W14+18], W0
0019BE  504FE1     SUB.B W0, #0x1, [W15]
0019C0  3A0052     BRA NZ, 0x1A66
685:                                                                               /* ... optimize cmp for mem buf alignment.              */
686:                       if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
0019C2  90007E     MOV [W14+14], W0
0019C4  E00000     CP0 W0
0019C6  32001E     BRA Z, 0x1A04
687:                           i = mem_align_mod_1;
0019C8  9000FE     MOV [W14+14], W1
0019CA  980751     MOV W1, [W14+10]
688:                           while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
0019CC  370012     BRA 0x19F2
0019F2  90484E     MOV.B [W14+12], W0
0019F4  504FE1     SUB.B W0, #0x1, [W15]
0019F6  3A0006     BRA NZ, 0x1A04
0019F8  78001E     MOV [W14], W0
0019FA  E00000     CP0 W0
0019FC  320003     BRA Z, 0x1A04
689:                                  (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
0019FE  90005E     MOV [W14+10], W0
001A00  E00000     CP0 W0
001A02  3AFFE5     BRA NZ, 0x19CE
690:                                  (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
691:                               p1_mem_08--;
0019CE  90003E     MOV [W14+6], W0
0019D0  E90000     DEC W0, W0
0019D2  980730     MOV W0, [W14+6]
692:                               p2_mem_08--;
0019D4  90004E     MOV [W14+8], W0
0019D6  E90000     DEC W0, W0
0019D8  980740     MOV W0, [W14+8]
693:                               if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
0019DA  90003E     MOV [W14+6], W0
0019DC  784090     MOV.B [W0], W1
0019DE  90004E     MOV [W14+8], W0
0019E0  784010     MOV.B [W0], W0
0019E2  50CF80     SUB.B W1, W0, [W15]
0019E4  320002     BRA Z, 0x19EA
694:                                    mem_cmp = DEF_NO;
0019E6  EB4000     CLR.B W0
0019E8  984F40     MOV.B W0, [W14+12]
695:                               }
696:                               size_rem -= sizeof(CPU_INT08U);
0019EA  E90F1E     DEC [W14], [W14]
697:                               i--;
0019EC  90005E     MOV [W14+10], W0
0019EE  E90000     DEC W0, W0
0019F0  980750     MOV W0, [W14+10]
698:                           }
699:                       }
700:               
701:                       if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
001A04  90484E     MOV.B [W14+12], W0
001A06  504FE1     SUB.B W0, #0x1, [W15]
001A08  3A002E     BRA NZ, 0x1A66
702:                           p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
001A0A  9000BE     MOV [W14+6], W1
001A0C  980711     MOV W1, [W14+2]
703:                           p2_mem_align = (CPU_ALIGN *)p2_mem_08;
001A0E  9000CE     MOV [W14+8], W1
001A10  980721     MOV W1, [W14+4]
704:               
705:                           while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
001A12  37000F     BRA 0x1A32
001A32  90484E     MOV.B [W14+12], W0
001A34  504FE1     SUB.B W0, #0x1, [W15]
001A36  3A0003     BRA NZ, 0x1A3E
001A38  78001E     MOV [W14], W0
001A3A  500FE1     SUB W0, #0x1, [W15]
001A3C  3EFFEB     BRA GTU, 0x1A14
706:                                  (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
707:                               p1_mem_align--;
001A14  90001E     MOV [W14+2], W0
001A16  E98000     DEC2 W0, W0
001A18  980710     MOV W0, [W14+2]
708:                               p2_mem_align--;
001A1A  90002E     MOV [W14+4], W0
001A1C  E98000     DEC2 W0, W0
001A1E  980720     MOV W0, [W14+4]
709:                               if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
001A20  90001E     MOV [W14+2], W0
001A22  780090     MOV [W0], W1
001A24  90002E     MOV [W14+4], W0
001A26  780010     MOV [W0], W0
001A28  508F80     SUB W1, W0, [W15]
001A2A  320002     BRA Z, 0x1A30
710:                                    mem_cmp = DEF_NO;
001A2C  EB4000     CLR.B W0
001A2E  984F40     MOV.B W0, [W14+12]
711:                               }
712:                               size_rem -= sizeof(CPU_ALIGN);
001A30  E98F1E     DEC2 [W14], [W14]
713:                           }
714:               
715:                           p1_mem_08 = (CPU_INT08U *)p1_mem_align;
001A3E  90009E     MOV [W14+2], W1
001A40  980731     MOV W1, [W14+6]
716:                           p2_mem_08 = (CPU_INT08U *)p2_mem_align;
001A42  9000AE     MOV [W14+4], W1
001A44  980741     MOV W1, [W14+8]
717:                       }
718:                   }
719:               
720:                   while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
001A46  37000F     BRA 0x1A66
001A66  90484E     MOV.B [W14+12], W0
001A68  504FE1     SUB.B W0, #0x1, [W15]
001A6A  3A0003     BRA NZ, 0x1A72
001A6C  78001E     MOV [W14], W0
001A6E  E00000     CP0 W0
001A70  3AFFEB     BRA NZ, 0x1A48
721:                          (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
722:                       p1_mem_08--;
001A48  90003E     MOV [W14+6], W0
001A4A  E90000     DEC W0, W0
001A4C  980730     MOV W0, [W14+6]
723:                       p2_mem_08--;
001A4E  90004E     MOV [W14+8], W0
001A50  E90000     DEC W0, W0
001A52  980740     MOV W0, [W14+8]
724:                       if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
001A54  90003E     MOV [W14+6], W0
001A56  784090     MOV.B [W0], W1
001A58  90004E     MOV [W14+8], W0
001A5A  784010     MOV.B [W0], W0
001A5C  50CF80     SUB.B W1, W0, [W15]
001A5E  320002     BRA Z, 0x1A64
725:                            mem_cmp = DEF_NO;
001A60  EB4000     CLR.B W0
001A62  984F40     MOV.B W0, [W14+12]
726:                       }
727:                       size_rem -= sizeof(CPU_INT08U);
001A64  E90F1E     DEC [W14], [W14]
728:                   }
729:               
730:                   return (mem_cmp);
001A72  90484E     MOV.B [W14+12], W0
731:               }
001A74  FA8000     ULNK
001A76  060000     RETURN
732:               
733:               
734:               /*
735:               *********************************************************************************************************
736:               *                                           Mem_HeapAlloc()
737:               *
738:               * Description : Allocates a memory block from the heap memory segment.
739:               *
740:               * Argument(s) : size            Size      of memory block to allocate (in bytes).
741:               *
742:               *               align           Alignment of memory block to specific word boundary (in bytes).
743:               *
744:               *               p_bytes_reqd    Optional pointer to a variable to ... :
745:               *
746:               *                                   (a) Return the number of bytes required to successfully
747:               *                                           allocate the memory block, if any error(s);
748:               *                                   (b) Return 0, otherwise.
749:               *
750:               *               p_err           Pointer to variable that will receive the return error code from this function :
751:               *
752:               *                                   LIB_MEM_ERR_NONE                Operation was successful.
753:               *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
754:               *
755:               *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
756:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
757:               *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
758:               *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
759:               *
760:               * Return(s)   : Pointer to memory block, if NO error(s).
761:               *
762:               *               Pointer to NULL,         otherwise.
763:               *
764:               * Caller(s)   : Application.
765:               *
766:               * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
767:               *                   validation or function handling in case of any error(s).
768:               *
769:               *               (2) This function is DEPRECATED and will be removed in a future version of this product.
770:               *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
771:               *********************************************************************************************************
772:               */
773:               
774:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
775:               void  *Mem_HeapAlloc (CPU_SIZE_T   size,
776:                                     CPU_SIZE_T   align,
777:                                     CPU_SIZE_T  *p_bytes_reqd,
778:                                     LIB_ERR     *p_err)
779:               {
001A78  FA000A     LNK #0xA
001A7A  980710     MOV W0, [W14+2]
001A7C  980721     MOV W1, [W14+4]
001A7E  980732     MOV W2, [W14+6]
001A80  980743     MOV W3, [W14+8]
780:                   void  *p_mem;
781:               
782:               
783:                   p_mem = Mem_SegAllocInternal(DEF_NULL,
001A82  90034E     MOV [W14+8], W6
001A84  9002BE     MOV [W14+6], W5
001A86  200014     MOV #0x1, W4
001A88  9001AE     MOV [W14+4], W3
001A8A  90011E     MOV [W14+2], W2
001A8C  210B81     MOV #0x10B8, W1
001A8E  EB0000     CLR W0
001A90  070370     RCALL _Mem_SegAllocInternal
001A92  780F00     MOV W0, [W14]
784:                                               &Mem_SegHeap,
785:                                                size,
786:                                                align,
787:                                                LIB_MEM_CFG_HEAP_PADDING_ALIGN,
788:                                                p_bytes_reqd,
789:                                                p_err);
790:                   if (*p_err == LIB_MEM_ERR_SEG_OVF) {
001A94  90004E     MOV [W14+8], W0
001A96  780090     MOV [W0], W1
001A98  227D90     MOV #0x27D9, W0
001A9A  508F80     SUB W1, W0, [W15]
001A9C  3A0003     BRA NZ, 0x1AA4
791:                      *p_err = LIB_MEM_ERR_HEAP_OVF;
001A9E  90004E     MOV [W14+8], W0
001AA0  227E31     MOV #0x27E3, W1
001AA2  780801     MOV W1, [W0]
792:                   }
793:               
794:                   return (p_mem);
001AA4  78001E     MOV [W14], W0
795:               }
001AA6  FA8000     ULNK
001AA8  060000     RETURN
796:               #endif
797:               
798:               
799:               /*
800:               *********************************************************************************************************
801:               *                                        Mem_HeapGetSizeRem()
802:               *
803:               * Description : Gets remaining heap memory size available to allocate.
804:               *
805:               * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
806:               *
807:               *               p_err       Pointer to variable that will receive the return error code from this function
808:               *
809:               *                               LIB_MEM_ERR_NONE                Operation was successful.
810:               *
811:               *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
812:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
813:               *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
814:               *
815:               * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
816:               *
817:               *               0,                                     otherwise.
818:               *
819:               * Caller(s)   : Application.
820:               *
821:               * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
822:               *                   Mem_SegRemSizeGet() should be used instead.
823:               *********************************************************************************************************
824:               */
825:               
826:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
827:               CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
828:                                               LIB_ERR     *p_err)
829:               {
001AAA  FA0006     LNK #0x6
001AAC  980710     MOV W0, [W14+2]
001AAE  980721     MOV W1, [W14+4]
830:                   CPU_SIZE_T  rem_size;
831:               
832:               
833:                   rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
001AB0  9001AE     MOV [W14+4], W3
001AB2  EB0100     CLR W2
001AB4  90009E     MOV [W14+2], W1
001AB6  210B80     MOV #0x10B8, W0
001AB8  07003D     RCALL Mem_SegRemSizeGet
001ABA  780F00     MOV W0, [W14]
834:                                                 align,
835:                                                 DEF_NULL,
836:                                                 p_err);
837:                   if (*p_err != LIB_MEM_ERR_NONE) {
001ABC  90002E     MOV [W14+4], W0
001ABE  780090     MOV [W0], W1
001AC0  227100     MOV #0x2710, W0
001AC2  508F80     SUB W1, W0, [W15]
001AC4  320002     BRA Z, 0x1ACA
838:                       return (0u);
001AC6  EB0000     CLR W0
001AC8  370001     BRA 0x1ACC
839:                   }
840:               
841:                   return (rem_size);
001ACA  78001E     MOV [W14], W0
842:               }
001ACC  FA8000     ULNK
001ACE  060000     RETURN
843:               #endif
844:               
845:               
846:               /*
847:               *********************************************************************************************************
848:               *                                            Mem_SegCreate()
849:               *
850:               * Description : Creates a new memory segment to be used for runtime memory allocation.
851:               *
852:               * Argument(s) : p_name          Pointer to segment name.
853:               *
854:               *               p_seg           Pointer to segment data. Must be allocated by caller.
855:               *
856:               *               seg_base_addr   Address of segment's first byte.
857:               *
858:               *               size            Total size of segment, in bytes.
859:               *
860:               *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
861:               *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
862:               *                               means no padding.
863:               *
864:               *               p_err           Pointer to variable that will receive the return error code from this function :
865:               *
866:               *                                   LIB_MEM_ERR_NONE                    Operation was successful.
867:               *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
868:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
869:               *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
870:               *
871:               *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
872:               *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
873:               *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
874:               *
875:               * Return(s)   : None.
876:               *
877:               * Caller(s)   : Application.
878:               *
879:               * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
880:               *                   to be maintained during the whole list search and add procedure to prevent a reentrant
881:               *                   call from creating another segment overlapping with the one being added.
882:               *********************************************************************************************************
883:               */
884:               
885:               void  Mem_SegCreate (const  CPU_CHAR    *p_name,
886:                                           MEM_SEG     *p_seg,
887:                                           CPU_ADDR     seg_base_addr,
888:                                           CPU_SIZE_T   size,
889:                                           CPU_SIZE_T   padding_align,
890:                                           LIB_ERR     *p_err)
891:               {
001AD0  FA000E     LNK #0xE
001AD2  980710     MOV W0, [W14+2]
001AD4  980721     MOV W1, [W14+4]
001AD6  980732     MOV W2, [W14+6]
001AD8  980743     MOV W3, [W14+8]
001ADA  980754     MOV W4, [W14+10]
001ADC  980765     MOV W5, [W14+12]
892:                   CPU_SR_ALLOC();
001ADE  EB0000     CLR W0
001AE0  780F00     MOV W0, [W14]
893:               
894:               
895:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
896:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
897:                       CPU_SW_EXCEPTION(;);
898:                   }
899:               
900:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
901:                      *p_err = LIB_MEM_ERR_NULL_PTR;
902:                       return;
903:                   }
904:               
905:                   if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
906:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
907:                       return;
908:                   }
909:                                                                               /* Chk for addr space ovf.                              */
910:                   if (seg_base_addr + (size - 1u) < seg_base_addr) {
911:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
912:                       return;
913:                   }
914:               
915:                   if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
916:                       (MATH_IS_PWR2(padding_align) != DEF_YES)) {
917:                      *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
918:                       return;
919:                   }
920:               #endif
921:               
922:                   CPU_CRITICAL_ENTER();
001AE2  800211     MOV SR, W1
001AE4  780F01     MOV W1, [W14]
001AE6  800211     MOV SR, W1
001AE8  200E00     MOV #0xE0, W0
001AEA  700001     IOR W0, W1, W0
001AEC  880210     MOV W0, SR
923:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
924:                   (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
925:                                                   size,
926:                                                   p_err);
927:                   if (*p_err != LIB_MEM_ERR_NONE) {
928:                       CPU_CRITICAL_EXIT();
929:                       return;
930:                   }
931:               #endif
932:               
933:                   Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
001AEE  90024E     MOV [W14+8], W4
001AF0  9001DE     MOV [W14+10], W3
001AF2  90013E     MOV [W14+6], W2
001AF4  9000AE     MOV [W14+4], W1
001AF6  90001E     MOV [W14+2], W0
001AF8  0702E0     RCALL _Mem_SegCreateCritical
934:                                         p_seg,
935:                                         seg_base_addr,
936:                                         padding_align,
937:                                         size);
938:                   CPU_CRITICAL_EXIT();
001AFA  78009E     MOV [W14], W1
001AFC  880211     MOV W1, SR
939:               
940:                  *p_err = LIB_MEM_ERR_NONE;
001AFE  90006E     MOV [W14+12], W0
001B00  227101     MOV #0x2710, W1
001B02  780801     MOV W1, [W0]
941:               }
001B04  FA8000     ULNK
001B06  060000     RETURN
942:               
943:               
944:               /*
945:               *********************************************************************************************************
946:               *                                            Mem_SegClr()
947:               *
948:               * Description : Clears a memory segment.
949:               *
950:               * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
951:               *
952:               *               p_err           Pointer to variable that will receive the return error code from this function :
953:               *
954:               *                               LIB_MEM_ERR_NONE                Operation was successful.
955:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
956:               *
957:               * Return(s)   : None.
958:               *
959:               * Caller(s)   : Application.
960:               *
961:               * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
962:               *                   segments that are no longer used.
963:               *
964:               *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
965:               *********************************************************************************************************
966:               */
967:               
968:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)
969:               void  Mem_SegClr (MEM_SEG  *p_seg,
970:                                 LIB_ERR  *p_err)
971:               {
001B08  FA0006     LNK #0x6
001B0A  980710     MOV W0, [W14+2]
001B0C  980721     MOV W1, [W14+4]
972:                   CPU_SR_ALLOC();
001B0E  EB0000     CLR W0
001B10  780F00     MOV W0, [W14]
973:               
974:               
975:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
976:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
977:                       CPU_SW_EXCEPTION(;);
978:                   }
979:               
980:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
981:                      *p_err = LIB_MEM_ERR_NULL_PTR;
982:                       return;
983:                   }
984:               #endif
985:               
986:                   CPU_CRITICAL_ENTER();
001B12  800211     MOV SR, W1
001B14  780F01     MOV W1, [W14]
001B16  800211     MOV SR, W1
001B18  200E00     MOV #0xE0, W0
001B1A  700001     IOR W0, W1, W0
001B1C  880210     MOV W0, SR
987:                   p_seg->AddrNext = p_seg->AddrBase;
001B1E  90001E     MOV [W14+2], W0
001B20  780090     MOV [W0], W1
001B22  90001E     MOV [W14+2], W0
001B24  980021     MOV W1, [W0+4]
988:                   CPU_CRITICAL_EXIT();
001B26  78009E     MOV [W14], W1
001B28  880211     MOV W1, SR
989:               
990:                  *p_err = LIB_MEM_ERR_NONE;
001B2A  90002E     MOV [W14+4], W0
001B2C  227101     MOV #0x2710, W1
001B2E  780801     MOV W1, [W0]
991:               }
001B30  FA8000     ULNK
001B32  060000     RETURN
992:               #endif
993:               
994:               
995:               /*
996:               *********************************************************************************************************
997:               *                                         Mem_SegRemSizeGet()
998:               *
999:               * Description : Gets free space of memory segment.
1000:              *
1001:              * Argument(s) : p_seg       Pointer to segment data.
1002:              *
1003:              *               align       Alignment in bytes to assume for calculation of free space.
1004:              *
1005:              *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
1006:              *                           total size, base address and next allocation address).
1007:              *
1008:              *               p_err       Pointer to variable that will receive the return error code from this function :
1009:              *
1010:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1011:              *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
1012:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
1013:              *
1014:              * Return(s)   : Memory segment remaining size in bytes,     if successful.
1015:              *               0,                                          otherwise or if memory segment empty.
1016:              *
1017:              * Caller(s)   : Application,
1018:              *               Mem_HeapGetSizeRem(),
1019:              *               Mem_OutputUsage().
1020:              *
1021:              * Note(s)     : None.
1022:              *********************************************************************************************************
1023:              */
1024:              
1025:              CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
1026:                                             CPU_SIZE_T     align,
1027:                                             MEM_SEG_INFO  *p_seg_info,
1028:                                             LIB_ERR       *p_err)
1029:              {
001B34  FA0012     LNK #0x12
001B36  980750     MOV W0, [W14+10]
001B38  980761     MOV W1, [W14+12]
001B3A  980772     MOV W2, [W14+14]
001B3C  980F03     MOV W3, [W14+16]
1030:                  CPU_SIZE_T  rem_size;
1031:                  CPU_SIZE_T  total_size;
1032:                  CPU_SIZE_T  used_size;
1033:                  CPU_ADDR    next_addr_align;
1034:                  CPU_SR_ALLOC();
001B3E  EB0000     CLR W0
001B40  780F00     MOV W0, [W14]
1035:              
1036:              
1037:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1038:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
1039:                      CPU_SW_EXCEPTION(seg_info);
1040:                  }
1041:              
1042:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
1043:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
1044:                      return (0u);
1045:                  }
1046:              #endif
1047:              
1048:                  if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
001B42  90005E     MOV [W14+10], W0
001B44  E00000     CP0 W0
001B46  3A0002     BRA NZ, 0x1B4C
1049:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1050:                      p_seg = &Mem_SegHeap;
001B48  210B80     MOV #0x10B8, W0
001B4A  980750     MOV W0, [W14+10]
1051:              #else
1052:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1053:                      return (0u);
1054:              #endif
1055:                  }
1056:              
1057:                  CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
001B4C  800211     MOV SR, W1
001B4E  780F01     MOV W1, [W14]
001B50  800211     MOV SR, W1
001B52  200E00     MOV #0xE0, W0
001B54  700001     IOR W0, W1, W0
001B56  880210     MOV W0, SR
1058:                  next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
001B58  90005E     MOV [W14+10], W0
001B5A  9000A0     MOV [W0+4], W1
001B5C  90006E     MOV [W14+12], W0
001B5E  EA0000     NEG W0, W0
001B60  608080     AND W1, W0, W1
001B62  90005E     MOV [W14+10], W0
001B64  900120     MOV [W0+4], W2
001B66  90006E     MOV [W14+12], W0
001B68  E90000     DEC W0, W0
001B6A  610000     AND W2, W0, W0
001B6C  E00000     CP0 W0
001B6E  320002     BRA Z, 0x1B74
001B70  90006E     MOV [W14+12], W0
001B72  370001     BRA 0x1B76
001B74  EB0000     CLR W0
001B76  408000     ADD W1, W0, W0
001B78  980710     MOV W0, [W14+2]
1059:                  CPU_CRITICAL_EXIT();
001B7A  78009E     MOV [W14], W1
001B7C  880211     MOV W1, SR
1060:              
1061:                  total_size = p_seg->AddrEnd  - p_seg->AddrBase + 1u;
001B7E  90005E     MOV [W14+10], W0
001B80  900090     MOV [W0+2], W1
001B82  90005E     MOV [W14+10], W0
001B84  780010     MOV [W0], W0
001B86  508000     SUB W1, W0, W0
001B88  E80000     INC W0, W0
001B8A  980720     MOV W0, [W14+4]
1062:                  used_size  = next_addr_align - p_seg->AddrBase;
001B8C  90005E     MOV [W14+10], W0
001B8E  780010     MOV [W0], W0
001B90  90009E     MOV [W14+2], W1
001B92  508000     SUB W1, W0, W0
001B94  980730     MOV W0, [W14+6]
1063:                  rem_size   = total_size      - used_size;
001B96  9000AE     MOV [W14+4], W1
001B98  90003E     MOV [W14+6], W0
001B9A  508000     SUB W1, W0, W0
001B9C  980740     MOV W0, [W14+8]
1064:              
1065:                  if (p_seg_info != DEF_NULL) {
001B9E  90007E     MOV [W14+14], W0
001BA0  E00000     CP0 W0
001BA2  32000D     BRA Z, 0x1BBE
1066:                      p_seg_info->TotalSize     = total_size;
001BA4  90007E     MOV [W14+14], W0
001BA6  9000AE     MOV [W14+4], W1
001BA8  980011     MOV W1, [W0+2]
1067:                      p_seg_info->UsedSize      = used_size;
001BAA  90007E     MOV [W14+14], W0
001BAC  9000BE     MOV [W14+6], W1
001BAE  780801     MOV W1, [W0]
1068:                      p_seg_info->AddrBase      = p_seg->AddrBase;
001BB0  90005E     MOV [W14+10], W0
001BB2  780090     MOV [W0], W1
001BB4  90007E     MOV [W14+14], W0
001BB6  980021     MOV W1, [W0+4]
1069:                      p_seg_info->AddrNextAlloc = next_addr_align;
001BB8  90007E     MOV [W14+14], W0
001BBA  90009E     MOV [W14+2], W1
001BBC  980031     MOV W1, [W0+6]
1070:                  }
1071:              
1072:                 *p_err = LIB_MEM_ERR_NONE;
001BBE  90080E     MOV [W14+16], W0
001BC0  227101     MOV #0x2710, W1
001BC2  780801     MOV W1, [W0]
1073:              
1074:                  return (rem_size);
001BC4  90004E     MOV [W14+8], W0
1075:              }
001BC6  FA8000     ULNK
001BC8  060000     RETURN
1076:              
1077:              
1078:              /*
1079:              *********************************************************************************************************
1080:              *                                            Mem_SegAlloc()
1081:              *
1082:              * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
1083:              *               word boundary.
1084:              *
1085:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1086:              *
1087:              *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
1088:              *                       general-purpose heap if null.
1089:              *
1090:              *               size    Size of memory block to allocate, in bytes.
1091:              *
1092:              *               p_err   Pointer to variable that will receive the return error code from this function :
1093:              *
1094:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1095:              *
1096:              *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1097:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1098:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1099:              *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1100:              *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1101:              *
1102:              * Return(s)   : Pointer to allocated memory block, if successful.
1103:              *
1104:              *               DEF_NULL, otherwise.
1105:              *
1106:              * Caller(s)   : Application.
1107:              *
1108:              * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
1109:              *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
1110:              *                   Mem_SegAllocHW().
1111:              *********************************************************************************************************
1112:              */
1113:              
1114:              void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
1115:                                          MEM_SEG     *p_seg,
1116:                                          CPU_SIZE_T   size,
1117:                                          LIB_ERR     *p_err)
1118:              {
001BCA  FA000A     LNK #0xA
001BCC  980710     MOV W0, [W14+2]
001BCE  980721     MOV W1, [W14+4]
001BD0  980732     MOV W2, [W14+6]
001BD2  980743     MOV W3, [W14+8]
1119:                  void  *p_blk;
1120:              
1121:              
1122:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
001BD4  90002E     MOV [W14+4], W0
001BD6  E00000     CP0 W0
001BD8  3A0002     BRA NZ, 0x1BDE
1123:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1124:                      p_seg = &Mem_SegHeap;
001BDA  210B80     MOV #0x10B8, W0
001BDC  980720     MOV W0, [W14+4]
1125:              #else
1126:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1127:                      return (DEF_NULL);
1128:              #endif
1129:                  }
1130:              
1131:                  p_blk = Mem_SegAllocInternal(p_name,
001BDE  90034E     MOV [W14+8], W6
001BE0  EB0280     CLR W5
001BE2  200014     MOV #0x1, W4
001BE4  200023     MOV #0x2, W3
001BE6  90013E     MOV [W14+6], W2
001BE8  9000AE     MOV [W14+4], W1
001BEA  90001E     MOV [W14+2], W0
001BEC  0702C2     RCALL _Mem_SegAllocInternal
001BEE  780F00     MOV W0, [W14]
1132:                                               p_seg,
1133:                                               size,
1134:                                               sizeof(CPU_ALIGN),
1135:                                               LIB_MEM_PADDING_ALIGN_NONE,
1136:                                               DEF_NULL,
1137:                                               p_err);
1138:              
1139:                  return (p_blk);
001BF0  78001E     MOV [W14], W0
1140:              }
001BF2  FA8000     ULNK
001BF4  060000     RETURN
1141:              
1142:              
1143:              /*
1144:              *********************************************************************************************************
1145:              *                                           Mem_SegAllocExt()
1146:              *
1147:              * Description : Allocates memory from specified memory segment.
1148:              *
1149:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1150:              *
1151:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1152:              *                               general-purpose heap if null.
1153:              *
1154:              *               size            Size of memory block to allocate, in bytes.
1155:              *
1156:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1157:              *
1158:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1159:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1160:              *
1161:              *               p_err           Pointer to variable that will receive the return error code from this function :
1162:              *
1163:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1164:              *
1165:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1166:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1167:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1168:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1169:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1170:              *
1171:              * Return(s)   : Pointer to allocated memory block, if successful.
1172:              *
1173:              *               DEF_NULL, otherwise.
1174:              *
1175:              * Caller(s)   : Application.
1176:              *
1177:              * Note(s)     : none.
1178:              *********************************************************************************************************
1179:              */
1180:              
1181:              void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
1182:                                             MEM_SEG     *p_seg,
1183:                                             CPU_SIZE_T   size,
1184:                                             CPU_SIZE_T   align,
1185:                                             CPU_SIZE_T  *p_bytes_reqd,
1186:                                             LIB_ERR     *p_err)
1187:              {
001BF6  FA000E     LNK #0xE
001BF8  980710     MOV W0, [W14+2]
001BFA  980721     MOV W1, [W14+4]
001BFC  980732     MOV W2, [W14+6]
001BFE  980743     MOV W3, [W14+8]
001C00  980754     MOV W4, [W14+10]
001C02  980765     MOV W5, [W14+12]
1188:                  void  *p_blk;
1189:              
1190:              
1191:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
001C04  90002E     MOV [W14+4], W0
001C06  E00000     CP0 W0
001C08  3A0002     BRA NZ, 0x1C0E
1192:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1193:                      p_seg = &Mem_SegHeap;
001C0A  210B80     MOV #0x10B8, W0
001C0C  980720     MOV W0, [W14+4]
1194:              #else
1195:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1196:                      return (DEF_NULL);
1197:              #endif
1198:                  }
1199:              
1200:                  p_blk = Mem_SegAllocInternal(p_name,
001C0E  90036E     MOV [W14+12], W6
001C10  9002DE     MOV [W14+10], W5
001C12  200014     MOV #0x1, W4
001C14  9001CE     MOV [W14+8], W3
001C16  90013E     MOV [W14+6], W2
001C18  9000AE     MOV [W14+4], W1
001C1A  90001E     MOV [W14+2], W0
001C1C  0702AA     RCALL _Mem_SegAllocInternal
001C1E  780F00     MOV W0, [W14]
1201:                                               p_seg,
1202:                                               size,
1203:                                               align,
1204:                                               LIB_MEM_PADDING_ALIGN_NONE,
1205:                                               p_bytes_reqd,
1206:                                               p_err);
1207:              
1208:                  return (p_blk);
001C20  78001E     MOV [W14], W0
1209:              }
001C22  FA8000     ULNK
001C24  060000     RETURN
1210:              
1211:              
1212:              /*
1213:              *********************************************************************************************************
1214:              *                                          Mem_SegAllocHW()
1215:              *
1216:              * Description : Allocates memory from specified segment. The returned buffer will be padded in function
1217:              *               of memory segment's properties.
1218:              *
1219:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1220:              *
1221:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1222:              *                               general-purpose heap if null.
1223:              *
1224:              *               size            Size of memory block to allocate, in bytes.
1225:              *
1226:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1227:              *
1228:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1229:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1230:              *
1231:              *               p_err           Pointer to variable that will receive the return error code from this function :
1232:              *
1233:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1234:              *
1235:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1236:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1237:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1238:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1239:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1240:              *
1241:              * Return(s)   : Pointer to allocated memory block, if successful.
1242:              *
1243:              *               DEF_NULL, otherwise.
1244:              *
1245:              * Caller(s)   : Application.
1246:              *
1247:              * Note(s)     : none.
1248:              *********************************************************************************************************
1249:              */
1250:              
1251:              void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
1252:                                            MEM_SEG     *p_seg,
1253:                                            CPU_SIZE_T   size,
1254:                                            CPU_SIZE_T   align,
1255:                                            CPU_SIZE_T  *p_bytes_reqd,
1256:                                            LIB_ERR     *p_err)
1257:              {
001C26  FA000E     LNK #0xE
001C28  980710     MOV W0, [W14+2]
001C2A  980721     MOV W1, [W14+4]
001C2C  980732     MOV W2, [W14+6]
001C2E  980743     MOV W3, [W14+8]
001C30  980754     MOV W4, [W14+10]
001C32  980765     MOV W5, [W14+12]
1258:                  void  *p_blk;
1259:              
1260:              
1261:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
001C34  90002E     MOV [W14+4], W0
001C36  E00000     CP0 W0
001C38  3A0002     BRA NZ, 0x1C3E
1262:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1263:                      p_seg = &Mem_SegHeap;
001C3A  210B80     MOV #0x10B8, W0
001C3C  980720     MOV W0, [W14+4]
1264:              #else
1265:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1266:                      return (DEF_NULL);
1267:              #endif
1268:                  }
1269:              
1270:                  p_blk = Mem_SegAllocInternal(p_name,
001C40  900040     MOV [W0+8], W0
001C42  90036E     MOV [W14+12], W6
001C44  9002DE     MOV [W14+10], W5
001C46  780200     MOV W0, W4
001C48  9001CE     MOV [W14+8], W3
001C4A  90013E     MOV [W14+6], W2
001C4C  9000AE     MOV [W14+4], W1
001C4E  90001E     MOV [W14+2], W0
001C50  070290     RCALL _Mem_SegAllocInternal
001C52  780F00     MOV W0, [W14]
1271:                                               p_seg,
1272:                                               size,
1273:                                               align,
1274:                                               p_seg->PaddingAlign,
001C3E  90002E     MOV [W14+4], W0
1275:                                               p_bytes_reqd,
1276:                                               p_err);
1277:              
1278:                  return (p_blk);
001C54  78001E     MOV [W14], W0
1279:              }
001C56  FA8000     ULNK
001C58  060000     RETURN
1280:              
1281:              
1282:              /*
1283:              *********************************************************************************************************
1284:              *                                          Mem_PoolCreate()
1285:              *
1286:              * Description : (1) Creates a memory pool :
1287:              *
1288:              *                   (a) Create    memory pool from heap or dedicated memory
1289:              *                   (b) Allocate  memory pool memory blocks
1290:              *                   (c) Configure memory pool
1291:              *
1292:              *
1293:              * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
1294:              *
1295:              *               p_mem_base      Memory pool segment base address :
1296:              *
1297:              *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
1298:              *                                       (b) Non-null address    Memory pool allocated from dedicated memory
1299:              *                                                                   specified by its base address.
1300:              *
1301:              *               mem_size        Size      of memory pool segment          (in bytes).
1302:              *
1303:              *               blk_nbr         Number    of memory pool blocks to create.
1304:              *
1305:              *               blk_size        Size      of memory pool blocks to create (in bytes).
1306:              *
1307:              *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
1308:              *
1309:              *               p_bytes_reqd    Optional pointer to a variable to ... :
1310:              *
1311:              *                                   (a) Return the number of bytes required to successfully
1312:              *                                               allocate the memory pool, if any error(s);
1313:              *                                       (b) Return 0, otherwise.
1314:              *
1315:              *               p_err           Pointer to variable that will receive the return error code from this function :
1316:              *
1317:              *                                   LIB_MEM_ERR_NONE                    Operation was successful.
1318:              *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
1319:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
1320:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
1321:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
1322:              *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
1323:              *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
1324:              *
1325:              *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
1326:              *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
1327:              *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
1328:              *
1329:              *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
1330:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1331:              *
1332:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1333:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1334:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1335:              *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1336:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1337:              *
1338:              *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
1339:              *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
1340:              *
1341:              * Return(s)   : none.
1342:              *
1343:              * Caller(s)   : Application.
1344:              *
1345:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1346:              *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1351:              void  Mem_PoolCreate (MEM_POOL          *p_pool,
1352:                                    void              *p_mem_base,
1353:                                    CPU_SIZE_T         mem_size,
1354:                                    MEM_POOL_BLK_QTY   blk_nbr,
1355:                                    CPU_SIZE_T         blk_size,
1356:                                    CPU_SIZE_T         blk_align,
1357:                                    CPU_SIZE_T        *p_bytes_reqd,
1358:                                    LIB_ERR           *p_err)
1359:              {
001C5A  FA0020     LNK #0x20
001C5C  980F00     MOV W0, [W14+16]
001C5E  980F11     MOV W1, [W14+18]
001C60  980F22     MOV W2, [W14+20]
001C62  980F33     MOV W3, [W14+22]
001C64  980F44     MOV W4, [W14+24]
001C66  980F55     MOV W5, [W14+26]
001C68  980F66     MOV W6, [W14+28]
001C6A  980F77     MOV W7, [W14+30]
1360:                  MEM_SEG           *p_seg;
1361:                  void              *p_pool_mem;
1362:                  CPU_SIZE_T         pool_size;
1363:                  CPU_SIZE_T         blk_size_align;
1364:                  CPU_ADDR           pool_addr_end;
1365:                  MEM_POOL_BLK_QTY   blk_ix;
1366:                  CPU_INT08U        *p_blk;
1367:                  CPU_SR_ALLOC();
001C6C  EB0000     CLR W0
001C6E  980730     MOV W0, [W14+6]
1368:              
1369:              
1370:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
1371:                  if (p_err == DEF_NULL) {
1372:                      CPU_SW_EXCEPTION(;);
1373:                  }
1374:              
1375:                                                                              /* ------------- VALIDATE MEM POOL CREATE ------------- */
1376:                  if (p_pool == DEF_NULL) {
1377:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1378:                      return;
1379:                  }
1380:              
1381:                  if (p_mem_base != DEF_NULL) {
1382:                      if (mem_size < 1u) {
1383:                         *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
1384:                          return;
1385:                      }
1386:                  }
1387:              
1388:                  if (blk_nbr < 1u) {
1389:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
1390:                      return;
1391:                  }
1392:              
1393:                  if (blk_size < 1u) {
1394:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1395:                      return;
1396:                  }
1397:              
1398:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
1399:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
1400:                      return;
1401:                  }
1402:              #endif
1403:              
1404:                  Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
001C70  9008FE     MOV [W14+30], W1
001C72  90080E     MOV [W14+16], W0
001C74  0700A5     RCALL Mem_PoolClr
1405:                  if (*p_err != LIB_MEM_ERR_NONE) {
001C76  90087E     MOV [W14+30], W0
001C78  780090     MOV [W0], W1
001C7A  227100     MOV #0x2710, W0
001C7C  508F80     SUB W1, W0, [W15]
001C7E  3A0099     BRA NZ, 0x1DB2
1406:                       return;
001DB2  000000     NOP
001DB4  370003     BRA 0x1DBC
1407:                  }
1408:              
1409:                                                                              /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
1410:                  if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
001C80  90081E     MOV [W14+18], W0
001C82  E00000     CP0 W0
001C84  3A0003     BRA NZ, 0x1C8C
1411:                      p_seg = &Mem_SegHeap;
001C86  210B80     MOV #0x10B8, W0
001C88  780F00     MOV W0, [W14]
001C8A  370032     BRA 0x1CF0
1412:                  } else {                                                    /* Use other seg.                                       */
1413:                      CPU_CRITICAL_ENTER();
001C8C  800211     MOV SR, W1
001C8E  980731     MOV W1, [W14+6]
001C90  800211     MOV SR, W1
001C92  200E00     MOV #0xE0, W0
001C94  700001     IOR W0, W1, W0
001C96  880210     MOV W0, SR
1414:                      p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
001C98  90081E     MOV [W14+18], W0
001C9A  90097E     MOV [W14+30], W2
001C9C  9008AE     MOV [W14+20], W1
001C9E  070229     RCALL _Mem_SegOverlapChkCritical
001CA0  780F00     MOV W0, [W14]
1415:                                                                  mem_size,
1416:                                                                  p_err);
1417:                      switch (*p_err) {
001CA2  90087E     MOV [W14+30], W0
001CA4  780010     MOV [W0], W0
001CA6  227101     MOV #0x2710, W1
001CA8  500F81     SUB W0, W1, [W15]
001CAA  320004     BRA Z, 0x1CB4
001CAC  227801     MOV #0x2780, W1
001CAE  500F81     SUB W0, W1, [W15]
001CB0  32001C     BRA Z, 0x1CEA
001CB2  370018     BRA 0x1CE4
1418:                          case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
1419:                               break;
001CEA  000000     NOP
1420:              
1421:                          case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
1422:                               p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
001CB4  900AFE     MOV [W14+30], W5
001CB6  900A6E     MOV [W14+28], W4
001CB8  200013     MOV #0x1, W3
001CBA  200022     MOV #0x2, W2
001CBC  2000A1     MOV #0xA, W1
001CBE  210B80     MOV #0x10B8, W0
001CC0  07027E     RCALL _Mem_SegAllocExtCritical
001CC2  780F00     MOV W0, [W14]
1423:                                                                           sizeof(MEM_SEG),
1424:                                                                           sizeof(CPU_ALIGN),
1425:                                                                           LIB_MEM_PADDING_ALIGN_NONE,
1426:                                                                           p_bytes_reqd,
1427:                                                                           p_err);
1428:                               if (*p_err != LIB_MEM_ERR_NONE) {
001CC4  90087E     MOV [W14+30], W0
001CC6  780090     MOV [W0], W1
001CC8  227100     MOV #0x2710, W0
001CCA  508F80     SUB W1, W0, [W15]
001CCC  320003     BRA Z, 0x1CD4
1429:                                   CPU_CRITICAL_EXIT();
001CCE  9000BE     MOV [W14+6], W1
001CD0  880211     MOV W1, SR
1430:                                   return;
001CD2  370074     BRA 0x1DBC
1431:                               }
1432:              
1433:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
1434:                               Mem_SegAllocTrackCritical("Unknown segment data",
1435:                                                         &Mem_SegHeap,
1436:                                                          sizeof(MEM_SEG),
1437:                                                          p_err);
1438:                               if (*p_err != LIB_MEM_ERR_NONE) {
1439:                                   CPU_CRITICAL_EXIT();
1440:                                   return;
1441:                               }
1442:              #endif
1443:              
1444:                               Mem_SegCreateCritical(          DEF_NULL,
001CD4  90081E     MOV [W14+18], W0
001CD6  900A2E     MOV [W14+20], W4
001CD8  200013     MOV #0x1, W3
001CDA  780100     MOV W0, W2
001CDC  78009E     MOV [W14], W1
001CDE  EB0000     CLR W0
001CE0  0701EC     RCALL _Mem_SegCreateCritical
1445:                                                               p_seg,
1446:                                                     (CPU_ADDR)p_mem_base,
1447:                                                               LIB_MEM_PADDING_ALIGN_NONE,
1448:                                                               mem_size);
1449:                               break;
001CE2  370004     BRA 0x1CEC
1450:              
1451:              
1452:                          case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
1453:                          default:
1454:                               CPU_CRITICAL_EXIT();
001CE4  9000BE     MOV [W14+6], W1
001CE6  880211     MOV W1, SR
1455:                               return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
001CE8  370069     BRA 0x1DBC
1456:                      }
1457:              
1458:                      CPU_CRITICAL_EXIT();
001CEC  9000BE     MOV [W14+6], W1
001CEE  880211     MOV W1, SR
1459:                  }
1460:              
1461:              
1462:                                                                              /* ---------------- ALLOC MEM FOR POOL ---------------- */
1463:                                                                              /* Calc blk size with align.                            */
1464:                  blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
001CF0  90085E     MOV [W14+26], W0
001CF2  EA0080     NEG W0, W1
001CF4  90084E     MOV [W14+24], W0
001CF6  608080     AND W1, W0, W1
001CF8  90085E     MOV [W14+26], W0
001CFA  E90100     DEC W0, W2
001CFC  90084E     MOV [W14+24], W0
001CFE  610000     AND W2, W0, W0
001D00  E00000     CP0 W0
001D02  320002     BRA Z, 0x1D08
001D04  90085E     MOV [W14+26], W0
001D06  370001     BRA 0x1D0A
001D08  EB0000     CLR W0
001D0A  408000     ADD W1, W0, W0
001D0C  980740     MOV W0, [W14+8]
1465:                  pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
001D0E  9000CE     MOV [W14+8], W1
001D10  90083E     MOV [W14+22], W0
001D12  B98800     MUL.SS W1, W0, W0
001D14  780000     MOV W0, W0
001D16  980750     MOV W0, [W14+10]
1466:              
1467:                                                                              /* Alloc mem for pool.                                  */
1468:                  p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
001D18  288070     MOV #0x8807, W0
001D1A  900B7E     MOV [W14+30], W6
001D1C  900AEE     MOV [W14+28], W5
001D1E  200014     MOV #0x1, W4
001D20  9009DE     MOV [W14+26], W3
001D22  90015E     MOV [W14+10], W2
001D24  78009E     MOV [W14], W1
001D26  070225     RCALL _Mem_SegAllocInternal
001D28  980760     MOV W0, [W14+12]
1469:                                                             p_seg,
1470:                                                             pool_size,
1471:                                                             blk_align,
1472:                                                             LIB_MEM_PADDING_ALIGN_NONE,
1473:                                                             p_bytes_reqd,
1474:                                                             p_err);
1475:                  if (*p_err != LIB_MEM_ERR_NONE) {
001D2A  90087E     MOV [W14+30], W0
001D2C  780090     MOV [W0], W1
001D2E  227100     MOV #0x2710, W0
001D30  508F80     SUB W1, W0, [W15]
001D32  3A0041     BRA NZ, 0x1DB6
1476:                      return;
001DB6  000000     NOP
001DB8  370001     BRA 0x1DBC
1477:                  }
1478:              
1479:                                                                              /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
1480:                  p_pool->BlkFreeTbl = (void *)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
001D34  90083E     MOV [W14+22], W0
001D36  400000     ADD W0, W0, W0
001D38  780080     MOV W0, W1
001D3A  2881B0     MOV #0x881B, W0
001D3C  900B7E     MOV [W14+30], W6
001D3E  900AEE     MOV [W14+28], W5
001D40  200014     MOV #0x1, W4
001D42  200023     MOV #0x2, W3
001D44  780101     MOV W1, W2
001D46  210B81     MOV #0x10B8, W1
001D48  070214     RCALL _Mem_SegAllocInternal
001D4A  780080     MOV W0, W1
001D4C  90080E     MOV [W14+16], W0
001D4E  980041     MOV W1, [W0+8]
1481:                                                                    &Mem_SegHeap,
1482:                                                                     blk_nbr * sizeof(void *),
1483:                                                                     sizeof(CPU_ALIGN),
1484:                                                                     LIB_MEM_PADDING_ALIGN_NONE,
1485:                                                                     p_bytes_reqd,
1486:                                                                     p_err);
1487:                  if (*p_err != LIB_MEM_ERR_NONE) {
001D50  90087E     MOV [W14+30], W0
001D52  780090     MOV [W0], W1
001D54  227100     MOV #0x2710, W0
001D56  508F80     SUB W1, W0, [W15]
001D58  3A0030     BRA NZ, 0x1DBA
1488:                      return;
001DBA  000000     NOP
1489:                  }
1490:              
1491:                                                                              /* ------------------ INIT BLK LIST ------------------- */
1492:                  p_blk = (CPU_INT08U *)p_pool_mem;
001D5A  9000EE     MOV [W14+12], W1
001D5C  980721     MOV W1, [W14+4]
1493:                  for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
001D5E  EB0000     CLR W0
001D60  980710     MOV W0, [W14+2]
001D62  37000E     BRA 0x1D80
001D7A  90001E     MOV [W14+2], W0
001D7C  E80000     INC W0, W0
001D7E  980710     MOV W0, [W14+2]
001D80  90009E     MOV [W14+2], W1
001D82  90083E     MOV [W14+22], W0
001D84  508F80     SUB W1, W0, [W15]
001D86  39FFEE     BRA NC, 0x1D64
1494:                      p_pool->BlkFreeTbl[blk_ix]  = p_blk;
001D64  90080E     MOV [W14+16], W0
001D66  9000C0     MOV [W0+8], W1
001D68  90001E     MOV [W14+2], W0
001D6A  400000     ADD W0, W0, W0
001D6C  408000     ADD W1, W0, W0
001D6E  9000AE     MOV [W14+4], W1
001D70  780801     MOV W1, [W0]
1495:                      p_blk                      += blk_size_align;
001D72  9000AE     MOV [W14+4], W1
001D74  90004E     MOV [W14+8], W0
001D76  408000     ADD W1, W0, W0
001D78  980720     MOV W0, [W14+4]
1496:                  }
1497:              
1498:              
1499:                                                                              /* ------------------ INIT POOL DATA ------------------ */
1500:                  pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
001D88  9000EE     MOV [W14+12], W1
001D8A  90005E     MOV [W14+10], W0
001D8C  408000     ADD W1, W0, W0
001D8E  E90000     DEC W0, W0
001D90  980770     MOV W0, [W14+14]
1501:                  p_pool->PoolAddrStart =  p_pool_mem;
001D92  90080E     MOV [W14+16], W0
001D94  9000EE     MOV [W14+12], W1
001D96  780801     MOV W1, [W0]
1502:                  p_pool->PoolAddrEnd   = (void *)pool_addr_end;
001D98  9000FE     MOV [W14+14], W1
001D9A  90080E     MOV [W14+16], W0
001D9C  980011     MOV W1, [W0+2]
1503:                  p_pool->BlkNbr        =  blk_nbr;
001D9E  90080E     MOV [W14+16], W0
001DA0  9008BE     MOV [W14+22], W1
001DA2  980021     MOV W1, [W0+4]
1504:                  p_pool->BlkSize       =  blk_size_align;
001DA4  90080E     MOV [W14+16], W0
001DA6  9000CE     MOV [W14+8], W1
001DA8  980031     MOV W1, [W0+6]
1505:                  p_pool->BlkFreeTblIx  =  blk_nbr;
001DAA  90080E     MOV [W14+16], W0
001DAC  9008BE     MOV [W14+22], W1
001DAE  980051     MOV W1, [W0+10]
001DB0  370005     BRA 0x1DBC
1506:              }
001DBC  FA8000     ULNK
001DBE  060000     RETURN
1507:              #endif
1508:              
1509:              
1510:              /*
1511:              *********************************************************************************************************
1512:              *                                            Mem_PoolClr()
1513:              *
1514:              * Description : Clears a memory pool (see Note #1).
1515:              *
1516:              * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
1517:              *
1518:              *               p_err        Pointer to variable that will receive the return error code from this function :
1519:              *
1520:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1521:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1522:              *
1523:              * Return(s)   : none.
1524:              *
1525:              * Caller(s)   : Application,
1526:              *               Mem_PoolCreate().
1527:              *
1528:              * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
1529:              *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
1530:              *
1531:              *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
1532:              *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
1533:              *                       this will likely corrupt the memory pool management.
1534:              *
1535:              *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
1536:              *
1537:              *               (3) This function is DEPRECATED and will be removed in a future version of this product.
1538:              *********************************************************************************************************
1539:              */
1540:              
1541:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1542:              void  Mem_PoolClr (MEM_POOL  *p_pool,
1543:                                 LIB_ERR   *p_err)
1544:              {
001DC0  FA0004     LNK #0x4
001DC2  780F00     MOV W0, [W14]
001DC4  980711     MOV W1, [W14+2]
1545:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
1546:                  if (p_err == DEF_NULL) {
1547:                      CPU_SW_EXCEPTION(;);
1548:                  }
1549:              
1550:                                                                              /* -------------- VALIDATE MEM POOL PTR --------------- */
1551:                  if (p_pool == DEF_NULL) {
1552:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1553:                      return;
1554:                  }
1555:              #endif
1556:              
1557:                  p_pool->PoolAddrStart = DEF_NULL;
001DC6  78001E     MOV [W14], W0
001DC8  EB0080     CLR W1
001DCA  780801     MOV W1, [W0]
1558:                  p_pool->PoolAddrEnd   = DEF_NULL;
001DCC  78001E     MOV [W14], W0
001DCE  EB0080     CLR W1
001DD0  980011     MOV W1, [W0+2]
1559:                  p_pool->BlkSize       = 0u;
001DD2  78001E     MOV [W14], W0
001DD4  EB0080     CLR W1
001DD6  980031     MOV W1, [W0+6]
1560:                  p_pool->BlkNbr        = 0u;
001DD8  78001E     MOV [W14], W0
001DDA  EB0080     CLR W1
001DDC  980021     MOV W1, [W0+4]
1561:                  p_pool->BlkFreeTbl    = DEF_NULL;
001DDE  78001E     MOV [W14], W0
001DE0  EB0080     CLR W1
001DE2  980041     MOV W1, [W0+8]
1562:                  p_pool->BlkFreeTblIx  = 0u;
001DE4  78001E     MOV [W14], W0
001DE6  EB0080     CLR W1
001DE8  980051     MOV W1, [W0+10]
1563:              
1564:                 *p_err = LIB_MEM_ERR_NONE;
001DEA  90001E     MOV [W14+2], W0
001DEC  227101     MOV #0x2710, W1
001DEE  780801     MOV W1, [W0]
1565:              }
001DF0  FA8000     ULNK
001DF2  060000     RETURN
1566:              #endif
1567:              
1568:              
1569:              /*
1570:              *********************************************************************************************************
1571:              *                                          Mem_PoolBlkGet()
1572:              *
1573:              * Description : Gets a memory block from memory pool.
1574:              *
1575:              * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
1576:              *
1577:              *               size    Size of requested memory (in bytes).
1578:              *
1579:              *               p_err   Pointer to variable that will receive the return error code from this function :
1580:              *
1581:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1582:              *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
1583:              *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1584:              *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
1585:              *
1586:              * Return(s)   : Pointer to memory block, if NO error(s).
1587:              *
1588:              *               Pointer to NULL,         otherwise.
1589:              *
1590:              * Caller(s)   : Application.
1591:              *
1592:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1593:              *                   Mem_DynPoolBlkGet() should be used instead.
1594:              *********************************************************************************************************
1595:              */
1596:              
1597:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1598:              void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
1599:                                     CPU_SIZE_T   size,
1600:                                     LIB_ERR     *p_err)
1601:              {
001DF4  FA000A     LNK #0xA
001DF6  980720     MOV W0, [W14+4]
001DF8  980731     MOV W1, [W14+6]
001DFA  980742     MOV W2, [W14+8]
1602:                  CPU_INT08U  *p_blk;
1603:                  CPU_SR_ALLOC();
001DFC  EB0000     CLR W0
001DFE  980710     MOV W0, [W14+2]
1604:              
1605:              
1606:                 (void)&size;                                                 /* Prevent possible 'variable unused' warning.          */
1607:              
1608:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
1609:                  if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
1610:                      CPU_SW_EXCEPTION(DEF_NULL);
1611:                  }
1612:              
1613:                  if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
1614:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1615:                      return (DEF_NULL);
1616:                  }
1617:              
1618:                  if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
1619:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1620:                      return (DEF_NULL);
1621:                  }
1622:              
1623:                  if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
1624:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1625:                      return (DEF_NULL);
1626:                  }
1627:              #endif
1628:              
1629:              
1630:                                                                              /* -------------- GET MEM BLK FROM POOL --------------- */
1631:                  p_blk = DEF_NULL;
001E00  EB0000     CLR W0
001E02  780F00     MOV W0, [W14]
1632:                  CPU_CRITICAL_ENTER();
001E04  800211     MOV SR, W1
001E06  980711     MOV W1, [W14+2]
001E08  800211     MOV SR, W1
001E0A  200E00     MOV #0xE0, W0
001E0C  700001     IOR W0, W1, W0
001E0E  880210     MOV W0, SR
1633:                  if (p_pool->BlkFreeTblIx > 0u) {
001E10  90002E     MOV [W14+4], W0
001E12  900050     MOV [W0+10], W0
001E14  E00000     CP0 W0
001E16  320015     BRA Z, 0x1E42
1634:                      p_pool->BlkFreeTblIx                     -= 1u;
001E18  90002E     MOV [W14+4], W0
001E1A  900050     MOV [W0+10], W0
001E1C  E90080     DEC W0, W1
001E1E  90002E     MOV [W14+4], W0
001E20  980051     MOV W1, [W0+10]
1635:                      p_blk                                     = p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
001E22  90002E     MOV [W14+4], W0
001E24  9000C0     MOV [W0+8], W1
001E26  90002E     MOV [W14+4], W0
001E28  900050     MOV [W0+10], W0
001E2A  400000     ADD W0, W0, W0
001E2C  408000     ADD W1, W0, W0
001E2E  780010     MOV [W0], W0
001E30  780F00     MOV W0, [W14]
1636:                      p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = DEF_NULL;
001E32  90002E     MOV [W14+4], W0
001E34  9000C0     MOV [W0+8], W1
001E36  90002E     MOV [W14+4], W0
001E38  900050     MOV [W0+10], W0
001E3A  400000     ADD W0, W0, W0
001E3C  408000     ADD W1, W0, W0
001E3E  EB0080     CLR W1
001E40  780801     MOV W1, [W0]
1637:                  }
1638:                  CPU_CRITICAL_EXIT();
001E42  90009E     MOV [W14+2], W1
001E44  880211     MOV W1, SR
1639:              
1640:                  if (p_blk == DEF_NULL) {
001E46  78001E     MOV [W14], W0
001E48  E00000     CP0 W0
001E4A  3A0004     BRA NZ, 0x1E54
1641:                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
001E4C  90004E     MOV [W14+8], W0
001E4E  227DE1     MOV #0x27DE, W1
001E50  780801     MOV W1, [W0]
001E52  370003     BRA 0x1E5A
1642:                  } else {
1643:                     *p_err = LIB_MEM_ERR_NONE;
001E54  90004E     MOV [W14+8], W0
001E56  227101     MOV #0x2710, W1
001E58  780801     MOV W1, [W0]
1644:                  }
1645:              
1646:                  return (p_blk);
001E5A  78001E     MOV [W14], W0
1647:              }
001E5C  FA8000     ULNK
001E5E  060000     RETURN
1648:              #endif
1649:              
1650:              
1651:              /*
1652:              *********************************************************************************************************
1653:              *                                          Mem_PoolBlkFree()
1654:              *
1655:              * Description : Free a memory block to memory pool.
1656:              *
1657:              * Argument(s) : p_pool  Pointer to memory pool to free memory block.
1658:              *
1659:              *               p_blk   Pointer to memory block address to free.
1660:              *
1661:              *               p_err   Pointer to variable that will receive the return error code from this function :
1662:              *
1663:              *                           LIB_MEM_ERR_NONE                        Operation was successful.
1664:              *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
1665:              *                                                                       a NULL pointer.
1666:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
1667:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
1668:              *                                                                        in memory pool.
1669:              *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
1670:              *
1671:              * Return(s)   : none.
1672:              *
1673:              * Caller(s)   : Application.
1674:              *
1675:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1676:              *                   Mem_DynPoolBlkFree() should be used instead.
1677:              *********************************************************************************************************
1678:              */
1679:              
1680:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1681:              void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
1682:                                     void      *p_blk,
1683:                                     LIB_ERR   *p_err)
1684:              {
001E60  FA0008     LNK #0x8
001E62  980710     MOV W0, [W14+2]
001E64  980721     MOV W1, [W14+4]
001E66  980732     MOV W2, [W14+6]
1685:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1686:                  CPU_SIZE_T   tbl_ix;
1687:                  CPU_BOOLEAN  addr_valid;
1688:              #endif
1689:                  CPU_SR_ALLOC();
001E68  EB0000     CLR W0
001E6A  780F00     MOV W0, [W14]
1690:              
1691:              
1692:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
1693:                  if (p_err == DEF_NULL) {
1694:                      CPU_SW_EXCEPTION(;);
1695:                  }
1696:              
1697:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
1698:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1699:                      return;
1700:                  }
1701:              
1702:                  if (p_blk == DEF_NULL) {
1703:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1704:                      return;
1705:                  }
1706:              
1707:                  addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
1708:                  if (addr_valid != DEF_OK) {
1709:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
1710:                      return;
1711:                  }
1712:              
1713:                  CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
1714:                  for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
1715:                      if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
1716:                          CPU_CRITICAL_EXIT();
1717:                         *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
1718:                          return;
1719:                      }
1720:                  }
1721:              #else                                                           /* Double-free possibility if not in critical section.  */
1722:                  CPU_CRITICAL_ENTER();
001E6C  800211     MOV SR, W1
001E6E  780F01     MOV W1, [W14]
001E70  800211     MOV SR, W1
001E72  200E00     MOV #0xE0, W0
001E74  700001     IOR W0, W1, W0
001E76  880210     MOV W0, SR
1723:              #endif
1724:                                                                              /* --------------- FREE MEM BLK TO POOL --------------- */
1725:                  if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
001E78  90001E     MOV [W14+2], W0
001E7A  9000D0     MOV [W0+10], W1
001E7C  90001E     MOV [W14+2], W0
001E7E  900020     MOV [W0+4], W0
001E80  508F80     SUB W1, W0, [W15]
001E82  390006     BRA NC, 0x1E90
1726:                      CPU_CRITICAL_EXIT();
001E84  78009E     MOV [W14], W1
001E86  880211     MOV W1, SR
1727:                     *p_err = LIB_MEM_ERR_POOL_FULL;
001E88  90003E     MOV [W14+6], W0
001E8A  227DD1     MOV #0x27DD, W1
001E8C  780801     MOV W1, [W0]
1728:                      return;
001E8E  370012     BRA 0x1EB4
1729:                  }
1730:              
1731:                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
001E90  90001E     MOV [W14+2], W0
001E92  9000C0     MOV [W0+8], W1
001E94  90001E     MOV [W14+2], W0
001E96  900050     MOV [W0+10], W0
001E98  400000     ADD W0, W0, W0
001E9A  408000     ADD W1, W0, W0
001E9C  9000AE     MOV [W14+4], W1
001E9E  780801     MOV W1, [W0]
1732:                  p_pool->BlkFreeTblIx                     += 1u;
001EA0  90001E     MOV [W14+2], W0
001EA2  900050     MOV [W0+10], W0
001EA4  E80080     INC W0, W1
001EA6  90001E     MOV [W14+2], W0
001EA8  980051     MOV W1, [W0+10]
1733:                  CPU_CRITICAL_EXIT();
001EAA  78009E     MOV [W14], W1
001EAC  880211     MOV W1, SR
1734:              
1735:                 *p_err = LIB_MEM_ERR_NONE;
001EAE  90003E     MOV [W14+6], W0
001EB0  227101     MOV #0x2710, W1
001EB2  780801     MOV W1, [W0]
1736:              }
001EB4  FA8000     ULNK
001EB6  060000     RETURN
1737:              #endif
1738:              
1739:              
1740:              /*
1741:              *********************************************************************************************************
1742:              *                                      Mem_PoolBlkGetNbrAvail()
1743:              *
1744:              * Description : Get memory pool's remaining number of blocks available to allocate.
1745:              *
1746:              * Argument(s) : p_pool   Pointer to a memory pool structure.
1747:              *
1748:              *               p_err    Pointer to variable that will receive the return error code from this function :
1749:              *
1750:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1751:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1752:              *
1753:              * Return(s)   : Remaining memory pool blocks,   if NO error(s).
1754:              *
1755:              *               0,                              otherwise.
1756:              *
1757:              * Caller(s)   : Application.
1758:              *
1759:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1760:              *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
1761:              *********************************************************************************************************
1762:              */
1763:              
1764:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1765:              MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
1766:                                                        LIB_ERR   *p_err)
1767:              {
001EB8  FA0008     LNK #0x8
001EBA  980720     MOV W0, [W14+4]
001EBC  980731     MOV W1, [W14+6]
1768:                  CPU_SIZE_T  nbr_avail;
1769:                  CPU_SR_ALLOC();
001EBE  EB0000     CLR W0
001EC0  780F00     MOV W0, [W14]
1770:              
1771:              
1772:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1773:                                                                              /* --------------- VALIDATE RTN ERR PTR --------------- */
1774:                  if (p_err == DEF_NULL) {
1775:                      CPU_SW_EXCEPTION(0u);
1776:                  }
1777:                                                                              /* ---------------- VALIDATE MEM POOL ----------------- */
1778:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
1779:                     *p_err =  LIB_MEM_ERR_NULL_PTR;
1780:                      return (0u);
1781:                  }
1782:              #endif
1783:              
1784:                  CPU_CRITICAL_ENTER();
001EC2  800211     MOV SR, W1
001EC4  780F01     MOV W1, [W14]
001EC6  800211     MOV SR, W1
001EC8  200E00     MOV #0xE0, W0
001ECA  700001     IOR W0, W1, W0
001ECC  880210     MOV W0, SR
1785:                  nbr_avail = p_pool->BlkFreeTblIx;
001ECE  90002E     MOV [W14+4], W0
001ED0  9000D0     MOV [W0+10], W1
001ED2  980711     MOV W1, [W14+2]
1786:                  CPU_CRITICAL_EXIT();
001ED4  78009E     MOV [W14], W1
001ED6  880211     MOV W1, SR
1787:              
1788:                 *p_err = LIB_MEM_ERR_NONE;
001ED8  90003E     MOV [W14+6], W0
001EDA  227101     MOV #0x2710, W1
001EDC  780801     MOV W1, [W0]
1789:              
1790:                  return (nbr_avail);
001EDE  90001E     MOV [W14+2], W0
1791:              }
001EE0  FA8000     ULNK
001EE2  060000     RETURN
1792:              #endif
1793:              
1794:              
1795:              /*
1796:              *********************************************************************************************************
1797:              *                                          Mem_DynPoolCreate()
1798:              *
1799:              * Description : Creates a dynamic memory pool.
1800:              *
1801:              * Argument(s) : p_name          Pointer to pool name.
1802:              *
1803:              *               p_pool          Pointer to pool data.
1804:              *
1805:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1806:              *                               general-purpose heap if null.
1807:              *
1808:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1809:              *
1810:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1811:              *
1812:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1813:              *
1814:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1815:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1816:              *
1817:              *               p_err           Pointer to variable that will receive the return error code from this function :
1818:              *
1819:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1820:              *
1821:              *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1822:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
1823:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
1824:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
1825:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
1826:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1827:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1828:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1829:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1830:              *
1831:              * Return(s)   : None.
1832:              *
1833:              * Caller(s)   : Application.
1834:              *
1835:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1836:              *                   block is stored in the block itself (only when free/unused).
1837:              *********************************************************************************************************
1838:              */
1839:              
1840:              void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
1841:                                              MEM_DYN_POOL  *p_pool,
1842:                                              MEM_SEG       *p_seg,
1843:                                              CPU_SIZE_T     blk_size,
1844:                                              CPU_SIZE_T     blk_align,
1845:                                              CPU_SIZE_T     blk_qty_init,
1846:                                              CPU_SIZE_T     blk_qty_max,
1847:                                              LIB_ERR       *p_err)
1848:              {
001EE4  FA0010     LNK #0x10
001EE6  780F00     MOV W0, [W14]
001EE8  980711     MOV W1, [W14+2]
001EEA  980722     MOV W2, [W14+4]
001EEC  980733     MOV W3, [W14+6]
001EEE  980744     MOV W4, [W14+8]
001EF0  980755     MOV W5, [W14+10]
001EF2  980766     MOV W6, [W14+12]
001EF4  980777     MOV W7, [W14+14]
1849:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
001EF6  90002E     MOV [W14+4], W0
001EF8  E00000     CP0 W0
001EFA  3A0002     BRA NZ, 0x1F00
1850:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1851:                      p_seg = &Mem_SegHeap;
001EFC  210B80     MOV #0x10B8, W0
001EFE  980720     MOV W0, [W14+4]
1852:              #else
1853:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1854:                      return (DEF_NULL);
1855:              #endif
1856:                  }
1857:              
1858:                  Mem_DynPoolCreateInternal(p_name,
001F00  9000FE     MOV [W14+14], W1
001F02  781F81     MOV W1, [W15++]
001F04  9003EE     MOV [W14+12], W7
001F06  90035E     MOV [W14+10], W6
001F08  200015     MOV #0x1, W5
001F0A  90024E     MOV [W14+8], W4
001F0C  9001BE     MOV [W14+6], W3
001F0E  90012E     MOV [W14+4], W2
001F10  90009E     MOV [W14+2], W1
001F12  78001E     MOV [W14], W0
001F14  0701A9     RCALL _Mem_DynPoolCreateInternal
001F16  E9878F     DEC2 W15, W15
1859:                                            p_pool,
1860:                                            p_seg,
1861:                                            blk_size,
1862:                                            blk_align,
1863:                                            LIB_MEM_PADDING_ALIGN_NONE,
1864:                                            blk_qty_init,
1865:                                            blk_qty_max,
1866:                                            p_err);
1867:              }
001F18  FA8000     ULNK
001F1A  060000     RETURN
1868:              
1869:              
1870:              /*
1871:              *********************************************************************************************************
1872:              *                                        Mem_DynPoolCreateHW()
1873:              *
1874:              * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
1875:              *               properties.
1876:              *
1877:              * Argument(s) : p_name          Pointer to pool name.
1878:              *
1879:              *               p_pool          Pointer to pool data.
1880:              *
1881:              *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
1882:              *                               general-purpose heap if null.
1883:              *
1884:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1885:              *
1886:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1887:              *
1888:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1889:              *
1890:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1891:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1892:              *
1893:              *               p_err           Pointer to variable that will receive the return error code from this function :
1894:              *
1895:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1896:              *
1897:              *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1898:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1899:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1900:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1901:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1902:              *
1903:              * Return(s)   : None.
1904:              *
1905:              * Caller(s)   : Application.
1906:              *
1907:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1908:              *                   block is stored in the block itself (only when free/unused).
1909:              *********************************************************************************************************
1910:              */
1911:              
1912:              void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
1913:                                                MEM_DYN_POOL  *p_pool,
1914:                                                MEM_SEG       *p_seg,
1915:                                                CPU_SIZE_T     blk_size,
1916:                                                CPU_SIZE_T     blk_align,
1917:                                                CPU_SIZE_T     blk_qty_init,
1918:                                                CPU_SIZE_T     blk_qty_max,
1919:                                                LIB_ERR       *p_err)
1920:              {
001F1C  FA0010     LNK #0x10
001F1E  780F00     MOV W0, [W14]
001F20  980711     MOV W1, [W14+2]
001F22  980722     MOV W2, [W14+4]
001F24  980733     MOV W3, [W14+6]
001F26  980744     MOV W4, [W14+8]
001F28  980755     MOV W5, [W14+10]
001F2A  980766     MOV W6, [W14+12]
001F2C  980777     MOV W7, [W14+14]
1921:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
001F2E  90002E     MOV [W14+4], W0
001F30  E00000     CP0 W0
001F32  3A0002     BRA NZ, 0x1F38
1922:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1923:                      p_seg = &Mem_SegHeap;
001F34  210B80     MOV #0x10B8, W0
001F36  980720     MOV W0, [W14+4]
1924:              #else
1925:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1926:                      return (DEF_NULL);
1927:              #endif
1928:                  }
1929:              
1930:                  Mem_DynPoolCreateInternal(p_name,
001F3A  900040     MOV [W0+8], W0
001F3C  9000FE     MOV [W14+14], W1
001F3E  781F81     MOV W1, [W15++]
001F40  9003EE     MOV [W14+12], W7
001F42  90035E     MOV [W14+10], W6
001F44  780280     MOV W0, W5
001F46  90024E     MOV [W14+8], W4
001F48  9001BE     MOV [W14+6], W3
001F4A  90012E     MOV [W14+4], W2
001F4C  90009E     MOV [W14+2], W1
001F4E  78001E     MOV [W14], W0
001F50  07018B     RCALL _Mem_DynPoolCreateInternal
001F52  E9878F     DEC2 W15, W15
1931:                                            p_pool,
1932:                                            p_seg,
1933:                                            blk_size,
1934:                                            blk_align,
1935:                                            p_seg->PaddingAlign,
001F38  90002E     MOV [W14+4], W0
1936:                                            blk_qty_init,
1937:                                            blk_qty_max,
1938:                                            p_err);
1939:              }
001F54  FA8000     ULNK
001F56  060000     RETURN
1940:              
1941:              
1942:              /*
1943:              *********************************************************************************************************
1944:              *                                          Mem_DynPoolBlkGet()
1945:              *
1946:              * Description : Gets a memory block from specified pool, growing it if needed.
1947:              *
1948:              * Argument(s) : p_pool  Pointer to pool data.
1949:              *
1950:              *               p_err   Pointer to variable that will receive the return error code from this function :
1951:              *
1952:              *                           LIB_MEM_ERR_NONE                    Operation was successful.
1953:              *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
1954:              *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
1955:              *
1956:              *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
1957:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1958:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1959:              *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1960:              *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1961:              *
1962:              * Return(s)   : Pointer to memory block, if successful.
1963:              *
1964:              *               DEF_NULL, otherwise.
1965:              *
1966:              * Caller(s)   : Application.
1967:              *
1968:              * Note(s)     : none.
1969:              *********************************************************************************************************
1970:              */
1971:              
1972:              void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
1973:                                        LIB_ERR       *p_err)
1974:              {
001F58  FA000A     LNK #0xA
001F5A  980730     MOV W0, [W14+6]
001F5C  980741     MOV W1, [W14+8]
1975:                         void      *p_blk;
1976:                  const  CPU_CHAR  *p_pool_name;
1977:                  CPU_SR_ALLOC();
001F5E  EB0000     CLR W0
001F60  780F00     MOV W0, [W14]
1978:              
1979:              
1980:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1981:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
1982:                      CPU_SW_EXCEPTION(DEF_NULL);
1983:                  }
1984:              
1985:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
1986:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1987:                      return (DEF_NULL);
1988:                  }
1989:              #endif
1990:              
1991:                                                                              /* Ensure pool is not empty if qty is limited.          */
1992:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
001F62  90003E     MOV [W14+6], W0
001F64  900050     MOV [W0+10], W0
001F66  E00000     CP0 W0
001F68  32001A     BRA Z, 0x1F9E
1993:                      CPU_CRITICAL_ENTER();
001F6A  800211     MOV SR, W1
001F6C  780F01     MOV W1, [W14]
001F6E  800211     MOV SR, W1
001F70  200E00     MOV #0xE0, W0
001F72  700001     IOR W0, W1, W0
001F74  880210     MOV W0, SR
1994:                      if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
001F76  90003E     MOV [W14+6], W0
001F78  9000E0     MOV [W0+12], W1
001F7A  90003E     MOV [W14+6], W0
001F7C  900050     MOV [W0+10], W0
001F7E  508F80     SUB W1, W0, [W15]
001F80  390007     BRA NC, 0x1F90
1995:                          CPU_CRITICAL_EXIT();
001F82  78009E     MOV [W14], W1
001F84  880211     MOV W1, SR
1996:              
1997:                         *p_err = LIB_MEM_ERR_POOL_EMPTY;
001F86  90004E     MOV [W14+8], W0
001F88  227DE1     MOV #0x27DE, W1
001F8A  780801     MOV W1, [W0]
1998:                          return (DEF_NULL);
001F8C  EB0000     CLR W0
001F8E  37003C     BRA 0x2008
1999:                      }
2000:              
2001:                      p_pool->BlkAllocCnt++;
001F90  90003E     MOV [W14+6], W0
001F92  900060     MOV [W0+12], W0
001F94  E80080     INC W0, W1
001F96  90003E     MOV [W14+6], W0
001F98  980061     MOV W1, [W0+12]
2002:                      CPU_CRITICAL_EXIT();
001F9A  78009E     MOV [W14], W1
001F9C  880211     MOV W1, SR
2003:                  }
2004:              
2005:                                                                              /* --------------- ALLOC FROM FREE LIST --------------- */
2006:                  CPU_CRITICAL_ENTER();
001F9E  800211     MOV SR, W1
001FA0  780F01     MOV W1, [W14]
001FA2  800211     MOV SR, W1
001FA4  200E00     MOV #0xE0, W0
001FA6  700001     IOR W0, W1, W0
001FA8  880210     MOV W0, SR
2007:                  if (p_pool->BlkFreePtr != DEF_NULL) {
001FAA  90003E     MOV [W14+6], W0
001FAC  900040     MOV [W0+8], W0
001FAE  E00000     CP0 W0
001FB0  32000E     BRA Z, 0x1FCE
2008:                      p_blk              = p_pool->BlkFreePtr;
001FB2  90003E     MOV [W14+6], W0
001FB4  9000C0     MOV [W0+8], W1
001FB6  980711     MOV W1, [W14+2]
2009:                      p_pool->BlkFreePtr = *((void **)p_blk);
001FB8  90001E     MOV [W14+2], W0
001FBA  780090     MOV [W0], W1
001FBC  90003E     MOV [W14+6], W0
001FBE  980041     MOV W1, [W0+8]
2010:                      CPU_CRITICAL_EXIT();
001FC0  78009E     MOV [W14], W1
001FC2  880211     MOV W1, SR
2011:              
2012:                     *p_err = LIB_MEM_ERR_NONE;
001FC4  90004E     MOV [W14+8], W0
001FC6  227101     MOV #0x2710, W1
001FC8  780801     MOV W1, [W0]
2013:              
2014:                      return (p_blk);
001FCA  90001E     MOV [W14+2], W0
001FCC  37001D     BRA 0x2008
2015:                  }
2016:                  CPU_CRITICAL_EXIT();
001FCE  78009E     MOV [W14], W1
001FD0  880211     MOV W1, SR
2017:              
2018:                                                                              /* ------------------ ALLOC NEW BLK ------------------- */
2019:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2020:                  p_pool_name = p_pool->NamePtr;
2021:              #else
2022:                  p_pool_name = DEF_NULL;
001FD2  EB0000     CLR W0
001FD4  980720     MOV W0, [W14+4]
2023:              #endif
2024:                  p_blk = Mem_SegAllocInternal(p_pool_name,
001FD8  9001B0     MOV [W0+6], W3
001FDC  900120     MOV [W0+4], W2
001FE0  900090     MOV [W0+2], W1
001FE4  780010     MOV [W0], W0
001FE6  90034E     MOV [W14+8], W6
001FE8  EB0280     CLR W5
001FEA  780203     MOV W3, W4
001FEC  780182     MOV W2, W3
001FEE  780101     MOV W1, W2
001FF0  780080     MOV W0, W1
001FF2  90002E     MOV [W14+4], W0
001FF4  0700BE     RCALL _Mem_SegAllocInternal
001FF6  980710     MOV W0, [W14+2]
2025:                                               p_pool->PoolSegPtr,
001FE2  90003E     MOV [W14+6], W0
2026:                                               p_pool->BlkSize,
001FDE  90003E     MOV [W14+6], W0
2027:                                               p_pool->BlkAlign,
001FDA  90003E     MOV [W14+6], W0
2028:                                               p_pool->BlkPaddingAlign,
001FD6  90003E     MOV [W14+6], W0
2029:                                               DEF_NULL,
2030:                                               p_err);
2031:                  if (*p_err != LIB_MEM_ERR_NONE) {
001FF8  90004E     MOV [W14+8], W0
001FFA  780090     MOV [W0], W1
001FFC  227100     MOV #0x2710, W0
001FFE  508F80     SUB W1, W0, [W15]
002000  320002     BRA Z, 0x2006
2032:                      return (DEF_NULL);
002002  EB0000     CLR W0
002004  370001     BRA 0x2008
2033:                  }
2034:              
2035:                  return (p_blk);
002006  90001E     MOV [W14+2], W0
2036:              }
002008  FA8000     ULNK
00200A  060000     RETURN
2037:              
2038:              
2039:              /*
2040:              *********************************************************************************************************
2041:              *                                         Mem_DynPoolBlkFree()
2042:              *
2043:              * Description : Frees memory block, making it available for future use.
2044:              *
2045:              * Argument(s) : p_pool  Pointer to pool data.
2046:              *
2047:              *               p_blk   Pointer to first byte of memory block.
2048:              *
2049:              *               p_err   Pointer to variable that will receive the return error code from this function :
2050:              *
2051:              *                           LIB_MEM_ERR_NONE        Operation was successful.
2052:              *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
2053:              *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
2054:              *
2055:              * Return(s)   : none.
2056:              *
2057:              * Caller(s)   : Application.
2058:              *
2059:              * Note(s)     : none.
2060:              *********************************************************************************************************
2061:              */
2062:              
2063:              void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
2064:                                        void          *p_blk,
2065:                                        LIB_ERR       *p_err)
2066:              {
00200C  FA0008     LNK #0x8
00200E  980710     MOV W0, [W14+2]
002010  980721     MOV W1, [W14+4]
002012  980732     MOV W2, [W14+6]
2067:                  CPU_SR_ALLOC();
002014  EB0000     CLR W0
002016  780F00     MOV W0, [W14]
2068:              
2069:              
2070:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2071:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2072:                      CPU_SW_EXCEPTION(;);
2073:                  }
2074:              
2075:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2076:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2077:                      return;
2078:                  }
2079:              
2080:                  if (p_blk == DEF_NULL) {
2081:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2082:                      return;
2083:                  }
2084:              #endif
2085:              
2086:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
002018  90001E     MOV [W14+2], W0
00201A  900050     MOV [W0+10], W0
00201C  E00000     CP0 W0
00201E  320017     BRA Z, 0x204E
2087:                      CPU_CRITICAL_ENTER();
002020  800211     MOV SR, W1
002022  780F01     MOV W1, [W14]
002024  800211     MOV SR, W1
002026  200E00     MOV #0xE0, W0
002028  700001     IOR W0, W1, W0
00202A  880210     MOV W0, SR
2088:                      if (p_pool->BlkAllocCnt == 0u) {
00202C  90001E     MOV [W14+2], W0
00202E  900060     MOV [W0+12], W0
002030  E00000     CP0 W0
002032  3A0006     BRA NZ, 0x2040
2089:                          CPU_CRITICAL_EXIT();
002034  78009E     MOV [W14], W1
002036  880211     MOV W1, SR
2090:              
2091:                         *p_err = LIB_MEM_ERR_POOL_FULL;
002038  90003E     MOV [W14+6], W0
00203A  227DD1     MOV #0x27DD, W1
00203C  780801     MOV W1, [W0]
2092:                          return;
00203E  370019     BRA 0x2072
2093:                      }
2094:              
2095:                      p_pool->BlkAllocCnt--;
002040  90001E     MOV [W14+2], W0
002042  900060     MOV [W0+12], W0
002044  E90080     DEC W0, W1
002046  90001E     MOV [W14+2], W0
002048  980061     MOV W1, [W0+12]
2096:                      CPU_CRITICAL_EXIT();
00204A  78009E     MOV [W14], W1
00204C  880211     MOV W1, SR
2097:                  }
2098:              
2099:                  CPU_CRITICAL_ENTER();
00204E  800211     MOV SR, W1
002050  780F01     MOV W1, [W14]
002052  800211     MOV SR, W1
002054  200E00     MOV #0xE0, W0
002056  700001     IOR W0, W1, W0
002058  880210     MOV W0, SR
2100:                 *((void **)p_blk)   = p_pool->BlkFreePtr;
00205A  90002E     MOV [W14+4], W0
00205C  90009E     MOV [W14+2], W1
00205E  9000C1     MOV [W1+8], W1
002060  780801     MOV W1, [W0]
2101:                  p_pool->BlkFreePtr = p_blk;
002062  90001E     MOV [W14+2], W0
002064  9000AE     MOV [W14+4], W1
002066  980041     MOV W1, [W0+8]
2102:                  CPU_CRITICAL_EXIT();
002068  78009E     MOV [W14], W1
00206A  880211     MOV W1, SR
2103:              
2104:                 *p_err = LIB_MEM_ERR_NONE;
00206C  90003E     MOV [W14+6], W0
00206E  227101     MOV #0x2710, W1
002070  780801     MOV W1, [W0]
2105:              }
002072  FA8000     ULNK
002074  060000     RETURN
2106:              
2107:              
2108:              /*
2109:              *********************************************************************************************************
2110:              *                                     Mem_DynPoolBlkNbrAvailGet()
2111:              *
2112:              * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
2113:              *               dynamic memory pool for which no limit was set at creation.
2114:              *
2115:              * Argument(s) : p_pool  Pointer to pool data.
2116:              *
2117:              *               p_err   Pointer to variable that will receive the return error code from this function :
2118:              *
2119:              *                           LIB_MEM_ERR_NONE                Operation was successful.
2120:              *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
2121:              *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
2122:              *
2123:              * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
2124:              *
2125:              *               0, if pool is empty or if an error occurred.
2126:              *
2127:              * Caller(s)   : Application.
2128:              *
2129:              * Note(s)     : None.
2130:              *********************************************************************************************************
2131:              */
2132:              
2133:              CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
2134:                                                     LIB_ERR       *p_err)
2135:              {
002076  FA0008     LNK #0x8
002078  980720     MOV W0, [W14+4]
00207A  980731     MOV W1, [W14+6]
2136:                  CPU_SIZE_T  blk_nbr_avail;
2137:                  CPU_SR_ALLOC();
00207C  EB0000     CLR W0
00207E  980710     MOV W0, [W14+2]
2138:              
2139:              
2140:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2141:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2142:                      CPU_SW_EXCEPTION(;);
2143:                  }
2144:              
2145:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2146:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2147:                      return (0u);
2148:                  }
2149:              #endif
2150:              
2151:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
002080  90002E     MOV [W14+4], W0
002082  900050     MOV [W0+10], W0
002084  E00000     CP0 W0
002086  320011     BRA Z, 0x20AA
2152:                      CPU_CRITICAL_ENTER();
002088  800211     MOV SR, W1
00208A  980711     MOV W1, [W14+2]
00208C  800211     MOV SR, W1
00208E  200E00     MOV #0xE0, W0
002090  700001     IOR W0, W1, W0
002092  880210     MOV W0, SR
2153:                      blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
002094  90002E     MOV [W14+4], W0
002096  9000D0     MOV [W0+10], W1
002098  90002E     MOV [W14+4], W0
00209A  900060     MOV [W0+12], W0
00209C  508F00     SUB W1, W0, [W14]
2154:                      CPU_CRITICAL_EXIT();
00209E  90009E     MOV [W14+2], W1
0020A0  880211     MOV W1, SR
2155:              
2156:                     *p_err = LIB_MEM_ERR_NONE;
0020A2  90003E     MOV [W14+6], W0
0020A4  227101     MOV #0x2710, W1
0020A6  780801     MOV W1, [W0]
0020A8  370005     BRA 0x20B4
2157:                  } else {
2158:                      blk_nbr_avail = 0u;
0020AA  EB0000     CLR W0
0020AC  780F00     MOV W0, [W14]
2159:                     *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
0020AE  90003E     MOV [W14+6], W0
0020B0  227DF1     MOV #0x27DF, W1
0020B2  780801     MOV W1, [W0]
2160:                  }
2161:              
2162:                  return (blk_nbr_avail);
0020B4  78001E     MOV [W14], W0
2163:              }
0020B6  FA8000     ULNK
0020B8  060000     RETURN
2164:              
2165:              
2166:              /*
2167:              *********************************************************************************************************
2168:              *                                           Mem_OutputUsage()
2169:              *
2170:              * Description : Outputs memory usage report through 'out_fnct'.
2171:              *
2172:              * Argument(s) : out_fnct        Pointer to output function.
2173:              *
2174:              *               print_details   DEF_YES, if the size of each allocation should be printed.
2175:              *                               DEF_NO,  otherwise.
2176:              *
2177:              *               p_err           Pointer to variable that will receive the return error code from this function :
2178:              *
2179:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
2180:              *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
2181:              *
2182:              *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
2183:              *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
2184:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
2185:              *
2186:              * Return(s)   : None.
2187:              *
2188:              * Caller(s)   : Application.
2189:              *
2190:              * Note(s)     : none.
2191:              *********************************************************************************************************
2192:              */
2193:              
2194:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2195:              void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
2196:                                    LIB_ERR   *p_err)
2197:              {
2198:                  CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
2199:                  MEM_SEG   *p_seg;
2200:                  CPU_SR_ALLOC();
2201:              
2202:              
2203:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2204:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2205:                      CPU_SW_EXCEPTION(;);
2206:                  }
2207:              
2208:                  if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
2209:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2210:                      return;
2211:                  }
2212:              #endif
2213:              
2214:                  out_fnct("---------------- Memory allocation info ----------------\r\n");
2215:                  out_fnct("| Type    | Size       | Free size  | Name\r\n");
2216:                  out_fnct("|---------|------------|------------|-------------------\r\n");
2217:              
2218:                  CPU_CRITICAL_ENTER();
2219:                  p_seg = Mem_SegHeadPtr;
2220:                  while (p_seg != DEF_NULL) {
2221:                      CPU_SIZE_T       rem_size;
2222:                      MEM_SEG_INFO     seg_info;
2223:                      MEM_ALLOC_INFO  *p_alloc;
2224:              
2225:              
2226:                      rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
2227:                      if (*p_err != LIB_MEM_ERR_NONE) {
2228:                          return;
2229:                      }
2230:              
2231:                      out_fnct("| Section | ");
2232:              
2233:                      (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
2234:                                              10u,
2235:                                              DEF_NBR_BASE_DEC,
2236:                                              ' ',
2237:                                              DEF_NO,
2238:                                              DEF_YES,
2239:                                             &str[0u]);
2240:              
2241:                      out_fnct(str);
2242:                      out_fnct(" | ");
2243:              
2244:                      (void)Str_FmtNbr_Int32U(rem_size,
2245:                                              10u,
2246:                                              DEF_NBR_BASE_DEC,
2247:                                              ' ',
2248:                                              DEF_NO,
2249:                                              DEF_YES,
2250:                                             &str[0u]);
2251:              
2252:                      out_fnct(str);
2253:                      out_fnct(" | ");
2254:                      out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
2255:                      out_fnct("\r\n");
2256:              
2257:                      p_alloc = p_seg->AllocInfoHeadPtr;
2258:                      while (p_alloc != DEF_NULL) {
2259:                          out_fnct("| -> Obj  | ");
2260:              
2261:                          (void)Str_FmtNbr_Int32U(p_alloc->Size,
2262:                                                  10u,
2263:                                                  DEF_NBR_BASE_DEC,
2264:                                                  ' ',
2265:                                                  DEF_NO,
2266:                                                  DEF_YES,
2267:                                                 &str[0u]);
2268:              
2269:                          out_fnct(str);
2270:                          out_fnct(" |            | ");
2271:              
2272:                          out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
2273:                          out_fnct("\r\n");
2274:              
2275:                          p_alloc = p_alloc->NextPtr;
2276:                      }
2277:              
2278:                      p_seg = p_seg->NextPtr;
2279:                  }
2280:                  CPU_CRITICAL_EXIT();
2281:              
2282:                 *p_err = LIB_MEM_ERR_NONE;
2283:              }
2284:              #endif
2285:              
2286:              
2287:              /*
2288:              *********************************************************************************************************
2289:              *********************************************************************************************************
2290:              *                                           LOCAL FUNCTIONS
2291:              *********************************************************************************************************
2292:              *********************************************************************************************************
2293:              */
2294:              
2295:              /*
2296:              *********************************************************************************************************
2297:              *                                       Mem_SegCreateCritical()
2298:              *
2299:              * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
2300:              *
2301:              * Argument(s) : p_name          Pointer to segment name.
2302:              *
2303:              *               p_seg           Pointer to segment data. Must be allocated by caller.
2304:              *               -----           Argument validated by caller.
2305:              *
2306:              *               seg_base_addr   Segment's first byte address.
2307:              *
2308:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
2309:              *                               from this memory segment. MUST be a power of 2.
2310:              *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
2311:              *               -------------   Argument validated by caller.
2312:              *
2313:              *               size            Total size of segment, in bytes.
2314:              *               ----            Argument validated by caller.
2315:              *
2316:              * Return(s)   : Pointer to segment data, if successful.
2317:              *
2318:              *               DEF_NULL, otherwise.
2319:              *
2320:              * Caller(s)   : Mem_PoolCreate(),
2321:              *               Mem_SegCreate().
2322:              *
2323:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2324:              *********************************************************************************************************
2325:              */
2326:              
2327:              static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
2328:                                                         MEM_SEG     *p_seg,
2329:                                                         CPU_ADDR     seg_base_addr,
2330:                                                         CPU_SIZE_T   padding_align,
2331:                                                         CPU_SIZE_T   size)
2332:              {
0020BA  FA000A     LNK #0xA
0020BC  780F00     MOV W0, [W14]
0020BE  980711     MOV W1, [W14+2]
0020C0  980722     MOV W2, [W14+4]
0020C2  980733     MOV W3, [W14+6]
0020C4  980744     MOV W4, [W14+8]
2333:                  p_seg->AddrBase         =  seg_base_addr;
0020C6  90001E     MOV [W14+2], W0
0020C8  9000AE     MOV [W14+4], W1
0020CA  780801     MOV W1, [W0]
2334:                  p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
0020CC  9000CE     MOV [W14+8], W1
0020CE  90002E     MOV [W14+4], W0
0020D0  408000     ADD W1, W0, W0
0020D2  E90080     DEC W0, W1
0020D4  90001E     MOV [W14+2], W0
0020D6  980011     MOV W1, [W0+2]
2335:                  p_seg->AddrNext         =  seg_base_addr;
0020D8  90001E     MOV [W14+2], W0
0020DA  9000AE     MOV [W14+4], W1
0020DC  980021     MOV W1, [W0+4]
2336:                  p_seg->NextPtr          =  Mem_SegHeadPtr;
0020DE  804141     MOV Mem_SegHeadPtr, W1
0020E0  90001E     MOV [W14+2], W0
0020E2  980031     MOV W1, [W0+6]
2337:                  p_seg->PaddingAlign     =  padding_align;
0020E4  90001E     MOV [W14+2], W0
0020E6  9000BE     MOV [W14+6], W1
0020E8  980041     MOV W1, [W0+8]
2338:              
2339:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2340:                  p_seg->NamePtr          = p_name;
2341:                  p_seg->AllocInfoHeadPtr = DEF_NULL;
2342:              #else
2343:                  (void)&p_name;
2344:              #endif
2345:              
2346:                  Mem_SegHeadPtr = p_seg;
0020EA  90009E     MOV [W14+2], W1
0020EC  884141     MOV W1, Mem_SegHeadPtr
2347:              }
0020EE  FA8000     ULNK
0020F0  060000     RETURN
2348:              
2349:              
2350:              /*
2351:              *********************************************************************************************************
2352:              *                                      Mem_SegOverlapChkCritical()
2353:              *
2354:              * Description : Checks if existing memory segment exists or overlaps with specified memory area.
2355:              *
2356:              * Argument(s) : seg_base_addr   Address of first byte of memory area.
2357:              *
2358:              *               size            Size of memory area, in bytes.
2359:              *
2360:              *               p_err       Pointer to variable that will receive the return error code from this function :
2361:              *
2362:              *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
2363:              *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
2364:              *
2365:              * Return(s)   : Pointer to memory segment that overlaps.
2366:              *
2367:              *               DEF_NULL, otherwise.
2368:              *
2369:              * Caller(s)   : Mem_PoolCreate(),
2370:              *               Mem_SegCreate().
2371:              *
2372:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2373:              *********************************************************************************************************
2374:              */
2375:              
2376:              static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
2377:                                                           CPU_SIZE_T   size,
2378:                                                           LIB_ERR     *p_err)
2379:              {
0020F2  FA000E     LNK #0xE
0020F4  980740     MOV W0, [W14+8]
0020F6  980751     MOV W1, [W14+10]
0020F8  980762     MOV W2, [W14+12]
2380:                  MEM_SEG   *p_seg_chk;
2381:                  CPU_ADDR   seg_new_end;
2382:                  CPU_ADDR   seg_chk_start;
2383:                  CPU_ADDR   seg_chk_end;
2384:              
2385:              
2386:                  seg_new_end = seg_base_addr + (size - 1u);
0020FA  9000DE     MOV [W14+10], W1
0020FC  90004E     MOV [W14+8], W0
0020FE  408000     ADD W1, W0, W0
002100  E90000     DEC W0, W0
002102  980710     MOV W0, [W14+2]
2387:                  p_seg_chk   = Mem_SegHeadPtr;
002104  804141     MOV Mem_SegHeadPtr, W1
002106  780F01     MOV W1, [W14]
2388:              
2389:                  while (p_seg_chk != DEF_NULL) {
002108  37002B     BRA 0x2160
002160  78001E     MOV [W14], W0
002162  E00000     CP0 W0
002164  3AFFD2     BRA NZ, 0x210A
2390:                      seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
00210A  78001E     MOV [W14], W0
00210C  780090     MOV [W0], W1
00210E  980721     MOV W1, [W14+4]
2391:                      seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
002110  78001E     MOV [W14], W0
002112  900090     MOV [W0+2], W1
002114  980731     MOV W1, [W14+6]
2392:              
2393:                      if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
002116  9000CE     MOV [W14+8], W1
002118  90002E     MOV [W14+4], W0
00211A  508F80     SUB W1, W0, [W15]
00211C  3A0009     BRA NZ, 0x2130
00211E  90009E     MOV [W14+2], W1
002120  90003E     MOV [W14+6], W0
002122  508F80     SUB W1, W0, [W15]
002124  3A0005     BRA NZ, 0x2130
2394:                         *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
002126  90006E     MOV [W14+12], W0
002128  227801     MOV #0x2780, W1
00212A  780801     MOV W1, [W0]
2395:                          return (p_seg_chk);
00212C  78001E     MOV [W14], W0
00212E  37001F     BRA 0x216E
2396:                      } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
002130  9000CE     MOV [W14+8], W1
002132  90002E     MOV [W14+4], W0
002134  508F80     SUB W1, W0, [W15]
002136  390004     BRA NC, 0x2140
002138  9000CE     MOV [W14+8], W1
00213A  90003E     MOV [W14+6], W0
00213C  508F80     SUB W1, W0, [W15]
00213E  360008     BRA LEU, 0x2150
002140  9000CE     MOV [W14+8], W1
002142  90002E     MOV [W14+4], W0
002144  508F80     SUB W1, W0, [W15]
002146  3E0009     BRA GTU, 0x215A
2397:                                 ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
002148  90009E     MOV [W14+2], W1
00214A  90002E     MOV [W14+4], W0
00214C  508F80     SUB W1, W0, [W15]
00214E  390005     BRA NC, 0x215A
2398:                         *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
002150  90006E     MOV [W14+12], W0
002152  2277F1     MOV #0x277F, W1
002154  780801     MOV W1, [W0]
2399:                          return (p_seg_chk);
002156  78001E     MOV [W14], W0
002158  37000A     BRA 0x216E
2400:                      }
2401:              
2402:                      p_seg_chk = p_seg_chk->NextPtr;
00215A  78001E     MOV [W14], W0
00215C  9000B0     MOV [W0+6], W1
00215E  780F01     MOV W1, [W14]
2403:                  }
2404:              
2405:                 *p_err = LIB_MEM_ERR_NONE;
002166  90006E     MOV [W14+12], W0
002168  227101     MOV #0x2710, W1
00216A  780801     MOV W1, [W0]
2406:              
2407:                  return (DEF_NULL);
00216C  EB0000     CLR W0
2408:              }
00216E  FA8000     ULNK
002170  060000     RETURN
2409:              
2410:              
2411:              /*
2412:              *********************************************************************************************************
2413:              *                                       Mem_SegAllocInternal()
2414:              *
2415:              * Description : Allocates memory from specified segment.
2416:              *
2417:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
2418:              *
2419:              *               p_seg           Pointer to segment from which to allocate memory.
2420:              *               -----           Argument validated by caller.
2421:              *
2422:              *               size            Size of memory block to allocate, in bytes.
2423:              *
2424:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2425:              *
2426:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2427:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2428:              *                               means no padding.
2429:              *
2430:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2431:              *                                the allocation to succeed. Set to DEF_NULL to skip calculation.
2432:              *
2433:              *               p_err           Pointer to variable that will receive the return error code from this function :
2434:              *
2435:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2436:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2437:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2438:              *
2439:              *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
2440:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2441:              *
2442:              * Return(s)   : Pointer to allocated memory block, if successful.
2443:              *
2444:              *               DEF_NULL, otherwise.
2445:              *
2446:              * Caller(s)   : Mem_DynPoolBlkGet(),
2447:              *               Mem_DynPoolCreateInternal(),
2448:              *               Mem_HeapAlloc(),
2449:              *               Mem_PoolCreate(),
2450:              *               Mem_SegAlloc(),
2451:              *               Mem_SegAllocExt(),
2452:              *               Mem_SegAllocHW().
2453:              *
2454:              * Note(s)     : none.
2455:              *********************************************************************************************************
2456:              */
2457:              
2458:              static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
2459:                                                          MEM_SEG     *p_seg,
2460:                                                          CPU_SIZE_T   size,
2461:                                                          CPU_SIZE_T   align,
2462:                                                          CPU_SIZE_T   padding_align,
2463:                                                          CPU_SIZE_T  *p_bytes_reqd,
2464:                                                          LIB_ERR     *p_err)
2465:              {
002172  FA0012     LNK #0x12
002174  980720     MOV W0, [W14+4]
002176  980731     MOV W1, [W14+6]
002178  980742     MOV W2, [W14+8]
00217A  980753     MOV W3, [W14+10]
00217C  980764     MOV W4, [W14+12]
00217E  980775     MOV W5, [W14+14]
002180  980F06     MOV W6, [W14+16]
2466:                  void  *p_blk;
2467:                  CPU_SR_ALLOC();
002182  EB0000     CLR W0
002184  780F00     MOV W0, [W14]
2468:              
2469:              
2470:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2471:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
2472:                      CPU_SW_EXCEPTION(DEF_NULL);
2473:                  }
2474:              
2475:                  if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
2476:                     *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
2477:                      return (DEF_NULL);
2478:                  }
2479:              
2480:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
2481:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
2482:                      return (DEF_NULL);
2483:                  }
2484:              #endif
2485:              
2486:                  CPU_CRITICAL_ENTER();
002186  800211     MOV SR, W1
002188  780F01     MOV W1, [W14]
00218A  800211     MOV SR, W1
00218C  200E00     MOV #0xE0, W0
00218E  700001     IOR W0, W1, W0
002190  880210     MOV W0, SR
2487:                  p_blk = Mem_SegAllocExtCritical(p_seg,
002192  900A8E     MOV [W14+16], W5
002194  90027E     MOV [W14+14], W4
002196  9001EE     MOV [W14+12], W3
002198  90015E     MOV [W14+10], W2
00219A  9000CE     MOV [W14+8], W1
00219C  90003E     MOV [W14+6], W0
00219E  07000F     RCALL _Mem_SegAllocExtCritical
0021A0  980710     MOV W0, [W14+2]
2488:                                                  size,
2489:                                                  align,
2490:                                                  padding_align,
2491:                                                  p_bytes_reqd,
2492:                                                  p_err);
2493:                  if (*p_err != LIB_MEM_ERR_NONE) {
0021A2  90080E     MOV [W14+16], W0
0021A4  780090     MOV [W0], W1
0021A6  227100     MOV #0x2710, W0
0021A8  508F80     SUB W1, W0, [W15]
0021AA  320004     BRA Z, 0x21B4
2494:                      CPU_CRITICAL_EXIT();
0021AC  78009E     MOV [W14], W1
0021AE  880211     MOV W1, SR
2495:                      return (DEF_NULL);
0021B0  EB0000     CLR W0
0021B2  370003     BRA 0x21BA
2496:                  }
2497:              
2498:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
2499:                  Mem_SegAllocTrackCritical(p_name,
2500:                                            p_seg,
2501:                                            size,
2502:                                            p_err);
2503:                  if (*p_err != LIB_MEM_ERR_NONE) {
2504:                      CPU_CRITICAL_EXIT();
2505:                      return (DEF_NULL);
2506:                  }
2507:              #else
2508:                  (void)&p_name;
2509:              #endif
2510:                  CPU_CRITICAL_EXIT();
0021B4  78009E     MOV [W14], W1
0021B6  880211     MOV W1, SR
2511:              
2512:                  return (p_blk);
0021B8  90001E     MOV [W14+2], W0
2513:              }
0021BA  FA8000     ULNK
0021BC  060000     RETURN
2514:              
2515:              
2516:              /*
2517:              *********************************************************************************************************
2518:              *                                      Mem_SegAllocExtCritical()
2519:              *
2520:              * Description : Allocates memory from specified segment.
2521:              *
2522:              * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
2523:              *
2524:              *               size            Size of memory block to allocate, in bytes.
2525:              *
2526:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2527:              *
2528:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2529:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2530:              *                               means no padding.
2531:              *
2532:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2533:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
2534:              *
2535:              *               p_err           Pointer to variable that will receive the return error code from this function :
2536:              *
2537:              *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
2538:              *
2539:              * Return(s)   : Pointer to allocated memory block, if successful.
2540:              *
2541:              *               DEF_NULL, otherwise.
2542:              *
2543:              * Caller(s)   : Mem_PoolCreate(),
2544:              *               Mem_SegAllocInternal(),
2545:              *               Mem_SegAllocTrackCritical().
2546:              *
2547:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2548:              *********************************************************************************************************
2549:              */
2550:              
2551:              static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
2552:                                                      CPU_SIZE_T   size,
2553:                                                      CPU_SIZE_T   align,
2554:                                                      CPU_SIZE_T   padding_align,
2555:                                                      CPU_SIZE_T  *p_bytes_reqd,
2556:                                                      LIB_ERR     *p_err)
2557:              {
0021BE  FA0016     LNK #0x16
0021C0  980750     MOV W0, [W14+10]
0021C2  980761     MOV W1, [W14+12]
0021C4  980772     MOV W2, [W14+14]
0021C6  980F03     MOV W3, [W14+16]
0021C8  980F14     MOV W4, [W14+18]
0021CA  980F25     MOV W5, [W14+20]
2558:                  CPU_ADDR    blk_addr;
2559:                  CPU_ADDR    addr_next;
2560:                  CPU_SIZE_T  size_rem_seg;
2561:                  CPU_SIZE_T  size_tot_blk;
2562:                  CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
0021CC  9000FE     MOV [W14+14], W1
0021CE  90080E     MOV [W14+16], W0
0021D0  500F81     SUB W0, W1, [W15]
0021D2  310001     BRA C, 0x21D6
0021D4  780001     MOV W1, W0
0021D6  780F00     MOV W0, [W14]
2563:              
2564:              
2565:                  blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
0021D8  90005E     MOV [W14+10], W0
0021DA  9000A0     MOV [W0+4], W1
0021DC  EA001E     NEG [W14], W0
0021DE  608080     AND W1, W0, W1
0021E0  90005E     MOV [W14+10], W0
0021E2  900120     MOV [W0+4], W2
0021E4  E9001E     DEC [W14], W0
0021E6  610000     AND W2, W0, W0
0021E8  E00000     CP0 W0
0021EA  320002     BRA Z, 0x21F0
0021EC  78001E     MOV [W14], W0
0021EE  370001     BRA 0x21F2
0021F0  EB0000     CLR W0
0021F2  408000     ADD W1, W0, W0
0021F4  980710     MOV W0, [W14+2]
2566:                                                        blk_align);
2567:                  addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
0021F6  90009E     MOV [W14+2], W1
0021F8  90006E     MOV [W14+12], W0
0021FA  408080     ADD W1, W0, W1
0021FC  90080E     MOV [W14+16], W0
0021FE  EA0000     NEG W0, W0
002200  608080     AND W1, W0, W1
002202  90011E     MOV [W14+2], W2
002204  90006E     MOV [W14+12], W0
002206  410100     ADD W2, W0, W2
002208  90080E     MOV [W14+16], W0
00220A  E90000     DEC W0, W0
00220C  610000     AND W2, W0, W0
00220E  E00000     CP0 W0
002210  320002     BRA Z, 0x2216
002212  90080E     MOV [W14+16], W0
002214  370001     BRA 0x2218
002216  EB0000     CLR W0
002218  408000     ADD W1, W0, W0
00221A  980720     MOV W0, [W14+4]
2568:                                                        padding_align);
2569:                  size_rem_seg = p_seg->AddrEnd - p_seg->AddrNext + 1u;
00221C  90005E     MOV [W14+10], W0
00221E  900090     MOV [W0+2], W1
002220  90005E     MOV [W14+10], W0
002222  900020     MOV [W0+4], W0
002224  508000     SUB W1, W0, W0
002226  E80000     INC W0, W0
002228  980730     MOV W0, [W14+6]
2570:                  size_tot_blk = addr_next - p_seg->AddrNext;                 /* Compute tot blk size including align and padding.    */
00222A  90005E     MOV [W14+10], W0
00222C  900020     MOV [W0+4], W0
00222E  9000AE     MOV [W14+4], W1
002230  508000     SUB W1, W0, W0
002232  980740     MOV W0, [W14+8]
2571:                  if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
002234  9000BE     MOV [W14+6], W1
002236  90004E     MOV [W14+8], W0
002238  508F80     SUB W1, W0, [W15]
00223A  31000D     BRA C, 0x2256
2572:                      if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
00223C  90081E     MOV [W14+18], W0
00223E  E00000     CP0 W0
002240  320005     BRA Z, 0x224C
2573:                         *p_bytes_reqd = size_tot_blk - size_rem_seg;
002242  9000CE     MOV [W14+8], W1
002244  90003E     MOV [W14+6], W0
002246  508080     SUB W1, W0, W1
002248  90081E     MOV [W14+18], W0
00224A  780801     MOV W1, [W0]
2574:                      }
2575:              
2576:                     *p_err = LIB_MEM_ERR_SEG_OVF;
00224C  90082E     MOV [W14+20], W0
00224E  227D91     MOV #0x27D9, W1
002250  780801     MOV W1, [W0]
2577:                      return (DEF_NULL);
002252  EB0000     CLR W0
002254  370007     BRA 0x2264
2578:                  }
2579:              
2580:                  p_seg->AddrNext = addr_next;
002256  90005E     MOV [W14+10], W0
002258  9000AE     MOV [W14+4], W1
00225A  980021     MOV W1, [W0+4]
2581:              
2582:                 *p_err = LIB_MEM_ERR_NONE;
00225C  90082E     MOV [W14+20], W0
00225E  227101     MOV #0x2710, W1
002260  780801     MOV W1, [W0]
2583:              
2584:                  return ((void *)blk_addr);
002262  90001E     MOV [W14+2], W0
2585:              }
002264  FA8000     ULNK
002266  060000     RETURN
2586:              
2587:              
2588:              /*
2589:              *********************************************************************************************************
2590:              *                                     Mem_SegAllocTrackCritical()
2591:              *
2592:              * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
2593:              *
2594:              * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
2595:              *                       remain accessible at all times.
2596:              *
2597:              *               p_seg   Pointer to segment data.
2598:              *
2599:              *               size    Allocation size, in bytes.
2600:              *
2601:              *               p_err   Pointer to variable that will receive the return error code from this function :
2602:              *
2603:              *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
2604:              *
2605:              *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
2606:              *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
2607:              *
2608:              * Return(s)   : none.
2609:              *
2610:              * Caller(s)   : Mem_PoolCreate(),
2611:              *               Mem_SegAllocInternal().
2612:              *
2613:              * Note(s)     : none.
2614:              *********************************************************************************************************
2615:              */
2616:              
2617:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2618:              static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
2619:                                                              MEM_SEG     *p_seg,
2620:                                                              CPU_SIZE_T   size,
2621:                                                              LIB_ERR     *p_err)
2622:              {
2623:                  MEM_ALLOC_INFO  *p_alloc;
2624:              
2625:              
2626:                                                                              /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
2627:                  p_alloc = p_seg->AllocInfoHeadPtr;
2628:                  while (p_alloc != DEF_NULL) {
2629:                      if (p_alloc->NamePtr == p_name) {
2630:                          p_alloc->Size += size;
2631:                         *p_err = LIB_MEM_ERR_NONE;
2632:                          return;
2633:                      }
2634:              
2635:                      p_alloc = p_alloc->NextPtr;
2636:                  }
2637:              
2638:                                                                              /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
2639:                  p_alloc = Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
2640:                                                     sizeof(MEM_ALLOC_INFO),
2641:                                                     sizeof(CPU_ALIGN),
2642:                                                     LIB_MEM_PADDING_ALIGN_NONE,
2643:                                                     DEF_NULL,
2644:                                                     p_err);
2645:                  if (*p_err != LIB_MEM_ERR_NONE) {
2646:                      return;
2647:                  }
2648:              
2649:                  p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
2650:                  p_alloc->Size    = size;
2651:              
2652:                  p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
2653:                  p_seg->AllocInfoHeadPtr = p_alloc;
2654:              }
2655:              #endif
2656:              
2657:              
2658:              /*
2659:              *********************************************************************************************************
2660:              *                                     Mem_DynPoolCreateInternal()
2661:              *
2662:              * Description : Creates a dynamic memory pool.
2663:              *
2664:              * Argument(s) : p_name              Pointer to pool name.
2665:              *
2666:              *               p_pool              Pointer to pool data.
2667:              *
2668:              *               p_seg               Pointer to segment from which to allocate memory.
2669:              *
2670:              *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
2671:              *
2672:              *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
2673:              *
2674:              *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
2675:              *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2676:              *                                   means no padding.
2677:              *
2678:              *               blk_qty_init        Initial number of elements to be allocated in pool.
2679:              *
2680:              *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
2681:              *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
2682:              *
2683:              *               p_err           Pointer to variable that will receive the return error code from this function :
2684:              *
2685:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
2686:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
2687:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
2688:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
2689:              *
2690:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
2691:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2692:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2693:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2694:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2695:              *
2696:              * Return(s)   : None.
2697:              *
2698:              * Caller(s)   : Mem_DynPoolCreate(),
2699:              *               Mem_DynPoolCreateHW().
2700:              *
2701:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
2702:              *                   block is stored in the block itself (only when free/unused).
2703:              *********************************************************************************************************
2704:              */
2705:              
2706:              static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
2707:                                                              MEM_DYN_POOL  *p_pool,
2708:                                                              MEM_SEG       *p_seg,
2709:                                                              CPU_SIZE_T     blk_size,
2710:                                                              CPU_SIZE_T     blk_align,
2711:                                                              CPU_SIZE_T     blk_padding_align,
2712:                                                              CPU_SIZE_T     blk_qty_init,
2713:                                                              CPU_SIZE_T     blk_qty_max,
2714:                                                              LIB_ERR       *p_err)
2715:              {
002268  FA0018     LNK #0x18
00226A  980740     MOV W0, [W14+8]
00226C  980751     MOV W1, [W14+10]
00226E  980762     MOV W2, [W14+12]
002270  980773     MOV W3, [W14+14]
002272  980F04     MOV W4, [W14+16]
002274  980F15     MOV W5, [W14+18]
002276  980F26     MOV W6, [W14+20]
002278  980F37     MOV W7, [W14+22]
2716:                  CPU_INT08U  *p_blks;
2717:                  CPU_SIZE_T   blk_size_align;
2718:                  CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
00227A  90088E     MOV [W14+16], W1
00227C  90081E     MOV [W14+18], W0
00227E  500F81     SUB W0, W1, [W15]
002280  310001     BRA C, 0x2284
002282  780001     MOV W1, W0
002284  980730     MOV W0, [W14+6]
2719:              
2720:              
2721:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2722:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2723:                      CPU_SW_EXCEPTION(DEF_NULL);
2724:                  }
2725:              
2726:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2727:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2728:                      return;
2729:                  }
2730:              
2731:                  if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
2732:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
2733:                      return;
2734:                  }
2735:              
2736:                  if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
2737:                      (blk_qty_init >  blk_qty_max)) {
2738:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
2739:                      return;
2740:                  }
2741:              
2742:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
2743:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
2744:                      return;
2745:                  }
2746:              #endif
2747:              
2748:                                                                              /* Calc blk size with align.                            */
2749:                  if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
002286  90007E     MOV [W14+14], W0
002288  500FE1     SUB W0, #0x1, [W15]
00228A  3E000E     BRA GTU, 0x22A8
2750:                                                                              /* ... inc size to ptr size.                            */
2751:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
00228C  90003E     MOV [W14+6], W0
00228E  EA0000     NEG W0, W0
002290  6000E2     AND W0, #0x2, W1
002292  90003E     MOV [W14+6], W0
002294  E90000     DEC W0, W0
002296  600062     AND W0, #0x2, W0
002298  E00000     CP0 W0
00229A  320002     BRA Z, 0x22A0
00229C  90003E     MOV [W14+6], W0
00229E  370001     BRA 0x22A2
0022A0  EB0000     CLR W0
0022A2  408000     ADD W1, W0, W0
0022A4  980710     MOV W0, [W14+2]
0022A6  37000F     BRA 0x22C6
2752:                  } else {
2753:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
0022A8  90003E     MOV [W14+6], W0
0022AA  EA0080     NEG W0, W1
0022AC  90007E     MOV [W14+14], W0
0022AE  608080     AND W1, W0, W1
0022B0  90003E     MOV [W14+6], W0
0022B2  E90100     DEC W0, W2
0022B4  90007E     MOV [W14+14], W0
0022B6  610000     AND W2, W0, W0
0022B8  E00000     CP0 W0
0022BA  320002     BRA Z, 0x22C0
0022BC  90003E     MOV [W14+6], W0
0022BE  370001     BRA 0x22C2
0022C0  EB0000     CLR W0
0022C2  408000     ADD W1, W0, W0
0022C4  980710     MOV W0, [W14+2]
2754:                  }
2755:              
2756:                  if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
0022C6  90082E     MOV [W14+20], W0
0022C8  E00000     CP0 W0
0022CA  320012     BRA Z, 0x22F0
2757:                      p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
0022CC  90009E     MOV [W14+2], W1
0022CE  90082E     MOV [W14+20], W0
0022D0  B98800     MUL.SS W1, W0, W0
0022D2  780000     MOV W0, W0
0022D4  97BB4E     MOV [W14-8], W6
0022D6  EB0280     CLR W5
0022D8  200014     MOV #0x1, W4
0022DA  9001BE     MOV [W14+6], W3
0022DC  780100     MOV W0, W2
0022DE  9000EE     MOV [W14+12], W1
0022E0  90004E     MOV [W14+8], W0
0022E2  07FF47     RCALL _Mem_SegAllocInternal
0022E4  780F00     MOV W0, [W14]
2758:                                                                  p_seg,
2759:                                                                  blk_size_align * blk_qty_init,
2760:                                                                  blk_align_worst,
2761:                                                                  LIB_MEM_PADDING_ALIGN_NONE,
2762:                                                                  DEF_NULL,
2763:                                                                  p_err);
2764:                      if (*p_err != LIB_MEM_ERR_NONE) {
0022E6  97B84E     MOV [W14-8], W0
0022E8  780090     MOV [W0], W1
0022EA  227100     MOV #0x2710, W0
0022EC  508F80     SUB W1, W0, [W15]
0022EE  3A0034     BRA NZ, 0x2358
2765:                          return;
002358  000000     NOP
2766:                      }
2767:                  }
2768:              
2769:              
2770:                                                                              /* ----------------- CREATE POOL DATA ----------------- */
2771:                  p_pool->PoolSegPtr      = p_seg;
0022F0  90005E     MOV [W14+10], W0
0022F2  9000EE     MOV [W14+12], W1
0022F4  780801     MOV W1, [W0]
2772:                  p_pool->BlkSize         = blk_size;
0022F6  90005E     MOV [W14+10], W0
0022F8  9000FE     MOV [W14+14], W1
0022FA  980011     MOV W1, [W0+2]
2773:                  p_pool->BlkAlign        = blk_align_worst;
0022FC  90005E     MOV [W14+10], W0
0022FE  9000BE     MOV [W14+6], W1
002300  980021     MOV W1, [W0+4]
2774:                  p_pool->BlkPaddingAlign = blk_padding_align;
002302  90005E     MOV [W14+10], W0
002304  90089E     MOV [W14+18], W1
002306  980031     MOV W1, [W0+6]
2775:                  p_pool->BlkQtyMax       = blk_qty_max;
002308  90005E     MOV [W14+10], W0
00230A  9008BE     MOV [W14+22], W1
00230C  980051     MOV W1, [W0+10]
2776:                  p_pool->BlkAllocCnt     = 0u;
00230E  90005E     MOV [W14+10], W0
002310  EB0080     CLR W1
002312  980061     MOV W1, [W0+12]
2777:              
2778:                  if (blk_qty_init != 0u) {                                   /* Init free list.                                      */
002314  90082E     MOV [W14+20], W0
002316  E00000     CP0 W0
002318  320018     BRA Z, 0x234A
2779:                      CPU_SIZE_T  i;
2780:              
2781:              
2782:                      p_pool->BlkFreePtr = (void *)p_blks;
00231A  90005E     MOV [W14+10], W0
00231C  78009E     MOV [W14], W1
00231E  980041     MOV W1, [W0+8]
2783:                      for (i = 0u; i < blk_qty_init - 1u; i++) {
002320  EB0000     CLR W0
002322  980720     MOV W0, [W14+4]
002324  370009     BRA 0x2338
002332  90002E     MOV [W14+4], W0
002334  E80000     INC W0, W0
002336  980720     MOV W0, [W14+4]
002338  90082E     MOV [W14+20], W0
00233A  E90080     DEC W0, W1
00233C  90002E     MOV [W14+4], W0
00233E  508F80     SUB W1, W0, [W15]
002340  3EFFF2     BRA GTU, 0x2326
2784:                         *((void **)p_blks)  = p_blks + blk_size_align;
002326  78001E     MOV [W14], W0
002328  90009E     MOV [W14+2], W1
00232A  40809E     ADD W1, [W14], W1
00232C  780801     MOV W1, [W0]
2785:                          p_blks            += blk_size_align;
00232E  90001E     MOV [W14+2], W0
002330  400F1E     ADD W0, [W14], [W14]
2786:                      }
2787:                     *((void **)p_blks) = DEF_NULL;
002342  78001E     MOV [W14], W0
002344  EB0080     CLR W1
002346  780801     MOV W1, [W0]
002348  370003     BRA 0x2350
2788:                  } else {
2789:                      p_pool->BlkFreePtr = DEF_NULL;
00234A  90005E     MOV [W14+10], W0
00234C  EB0080     CLR W1
00234E  980041     MOV W1, [W0+8]
2790:                  }
2791:              
2792:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2793:                  p_pool->NamePtr = p_name;
2794:              #endif
2795:              
2796:                 *p_err = LIB_MEM_ERR_NONE;
002350  97B84E     MOV [W14-8], W0
002352  227101     MOV #0x2710, W1
002354  780801     MOV W1, [W0]
002356  370001     BRA 0x235A
2797:              }
00235A  FA8000     ULNK
2798:              
2799:              
2800:              /*
2801:              *********************************************************************************************************
2802:              *                                      Mem_PoolBlkIsValidAddr()
2803:              *
2804:              * Description : Calculates if a given memory block address is valid for the memory pool.
2805:              *
2806:              * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
2807:              *               ------   Argument validated by caller.
2808:              *
2809:              *               p_mem    Pointer to memory block address to validate.
2810:              *               -----    Argument validated by caller.
2811:              *
2812:              * Return(s)   : DEF_YES, if valid memory pool block address.
2813:              *
2814:              *               DEF_NO,  otherwise.
2815:              *
2816:              * Caller(s)   : Mem_PoolBlkFree().
2817:              *
2818:              * Note(s)     : none.
2819:              *********************************************************************************************************
2820:              */
2821:              
2822:              #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
2823:                   (LIB_MEM_CFG_HEAP_SIZE      >  0u))
2824:              static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
2825:                                                           void      *p_mem)
2826:              {
2827:                  CPU_ADDR  pool_offset;
2828:              
2829:              
2830:                  if ((p_mem < p_pool->PoolAddrStart) ||
2831:                      (p_mem > p_pool->PoolAddrEnd)) {
2832:                      return (DEF_FALSE);
2833:                  }
2834:              
2835:                  pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
2836:                  if (pool_offset % p_pool->BlkSize != 0u) {
2837:                      return (DEF_FALSE);
2838:                  } else {
2839:                      return (DEF_TRUE);
2840:                  }
2841:              }
2842:              #endif
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uC-LIB/lib_math.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                        MATHEMATIC OPERATIONS
29:                *
30:                * Filename      : lib_math.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : SR
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *********************************************************************************************************
51:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
52:                *                     us permission to reprint portions of their documentation.  Portions of this text are
53:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
54:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
55:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
56:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
57:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
58:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
59:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
60:                *********************************************************************************************************
61:                */
62:                
63:                
64:                /*
65:                *********************************************************************************************************
66:                *                                            INCLUDE FILES
67:                *********************************************************************************************************
68:                */
69:                
70:                #define    MICRIUM_SOURCE
71:                #define    LIB_MATH_MODULE
72:                #include  <lib_math.h>
73:                
74:                
75:                /*
76:                *********************************************************************************************************
77:                *                                            LOCAL DEFINES
78:                *********************************************************************************************************
79:                */
80:                
81:                
82:                /*
83:                *********************************************************************************************************
84:                *                                           LOCAL CONSTANTS
85:                *********************************************************************************************************
86:                */
87:                
88:                
89:                /*
90:                *********************************************************************************************************
91:                *                                          LOCAL DATA TYPES
92:                *********************************************************************************************************
93:                */
94:                
95:                
96:                /*
97:                *********************************************************************************************************
98:                *                                            LOCAL TABLES
99:                *********************************************************************************************************
100:               */
101:               
102:               
103:               /*
104:               *********************************************************************************************************
105:               *                                       LOCAL GLOBAL VARIABLES
106:               *********************************************************************************************************
107:               */
108:               
109:               RAND_NBR  Math_RandSeedCur;                                     /* Cur rand nbr seed.                                   */
110:               
111:               
112:               /*
113:               *********************************************************************************************************
114:               *                                      LOCAL FUNCTION PROTOTYPES
115:               *********************************************************************************************************
116:               */
117:               
118:               
119:               /*
120:               *********************************************************************************************************
121:               *                                     LOCAL CONFIGURATION ERRORS
122:               *********************************************************************************************************
123:               */
124:               
125:               
126:               /*
127:               *********************************************************************************************************
128:               *                                             Math_Init()
129:               *
130:               * Description : (1) Initialize Mathematic Module :
131:               *
132:               *                   (a) Initialize random number seed value
133:               *
134:               *
135:               * Argument(s) : none.
136:               *
137:               * Return(s)   : none.
138:               *
139:               * Caller(s)   : Application.
140:               *
141:               * Note(s)     : (2) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "if rand()
142:               *                   is called before any calls to srand() are made, the same sequence shall be generated
143:               *                   as when srand() is first called with a seed value of 1".
144:               *********************************************************************************************************
145:               */
146:               
147:               void  Math_Init (void)
148:               {
0070C0  FA0000     LNK #0x0
149:                   Math_RandSetSeed((RAND_NBR)RAND_SEED_INIT_VAL);             /* See Note #2.                                         */
0070C2  200010     MOV #0x1, W0
0070C4  200001     MOV #0x0, W1
0070C6  070002     RCALL Math_RandSetSeed
150:               }
0070C8  FA8000     ULNK
0070CA  060000     RETURN
151:               
152:               
153:               /*
154:               *********************************************************************************************************
155:               *                                         Math_RandSetSeed()
156:               *
157:               * Description : Set the current pseudo-random number generator seed.
158:               *
159:               * Argument(s) : seed        Initial (or current) value to set for the pseudo-random number sequence.
160:               *
161:               * Return(s)   : none.
162:               *
163:               * Caller(s)   : Application.
164:               *
165:               * Note(s)     : (1) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "srand()
166:               *                   ... uses the argument as a seed for a new sequence of pseudo-random numbers to be
167:               *                   returned by subsequent calls to rand()".
168:               *
169:               *               (2) 'Math_RandSeedCur' MUST always be accessed exclusively in critical sections.
170:               *
171:               *                   See also 'Math_Rand()  Note #1b'.
172:               *********************************************************************************************************
173:               */
174:               
175:               void  Math_RandSetSeed (RAND_NBR  seed)
176:               {
0070CC  FA0006     LNK #0x6
0070CE  980710     MOV W0, [W14+2]
0070D0  980721     MOV W1, [W14+4]
177:                   CPU_SR_ALLOC();
0070D2  EB0000     CLR W0
0070D4  780F00     MOV W0, [W14]
178:               
179:               
180:                   CPU_CRITICAL_ENTER();
0070D6  800211     MOV SR, W1
0070D8  780F01     MOV W1, [W14]
0070DA  800211     MOV SR, W1
0070DC  200E00     MOV #0xE0, W0
0070DE  700001     IOR W0, W1, W0
0070E0  880210     MOV W0, SR
181:                   Math_RandSeedCur = seed;
0070E2  90011E     MOV [W14+2], W2
0070E4  9001AE     MOV [W14+4], W3
0070E6  884422     MOV W2, Math_RandSeedCur
0070E8  884433     MOV W3, 0x886
182:                   CPU_CRITICAL_EXIT();
0070EA  78019E     MOV [W14], W3
0070EC  880213     MOV W3, SR
183:               }
0070EE  FA8000     ULNK
0070F0  060000     RETURN
184:               
185:               
186:               /*
187:               *********************************************************************************************************
188:               *                                             Math_Rand()
189:               *
190:               * Description : Calculate the next pseudo-random number.
191:               *
192:               * Argument(s) : none.
193:               *
194:               * Return(s)   : Next pseudo-random number in the sequence after 'Math_RandSeedCur'.
195:               *
196:               * Caller(s)   : Application.
197:               *
198:               * Note(s)     : (1) (a) The pseudo-random number generator is implemented as a Linear Congruential
199:               *                       Generator (LCG).
200:               *
201:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
202:               *
203:               *                   See also 'Math_RandSeed()  Note #1'.
204:               *
205:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
206:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
207:               *
208:               *                   (b) However, in order to implement Math_Rand() as re-entrant; 'Math_RandSeedCur' MUST
209:               *                       always be accessed & updated exclusively in critical sections.
210:               *
211:               *                   See also 'Math_RandSeed()  Note #2'.
212:               *********************************************************************************************************
213:               */
214:               
215:               RAND_NBR  Math_Rand (void)
216:               {
0070F2  FA000A     LNK #0xA
217:                   RAND_NBR  seed;
218:                   RAND_NBR  rand_nbr;
219:                   CPU_SR_ALLOC();
0070F4  EB0000     CLR W0
0070F6  780F00     MOV W0, [W14]
220:               
221:               
222:                   CPU_CRITICAL_ENTER();
0070F8  800211     MOV SR, W1
0070FA  780F01     MOV W1, [W14]
0070FC  800211     MOV SR, W1
0070FE  200E00     MOV #0xE0, W0
007100  700001     IOR W0, W1, W0
007102  880210     MOV W0, SR
223:                   seed             = Math_RandSeedCur;
007104  804422     MOV Math_RandSeedCur, W2
007106  804433     MOV 0x886, W3
007108  980712     MOV W2, [W14+2]
00710A  980723     MOV W3, [W14+4]
224:                   rand_nbr         = Math_RandSeed(seed);
00710C  90001E     MOV [W14+2], W0
00710E  9000AE     MOV [W14+4], W1
007110  07000C     RCALL Math_RandSeed
007112  980730     MOV W0, [W14+6]
007114  980741     MOV W1, [W14+8]
225:                   Math_RandSeedCur = rand_nbr;
007116  90013E     MOV [W14+6], W2
007118  9001CE     MOV [W14+8], W3
00711A  884422     MOV W2, Math_RandSeedCur
00711C  884433     MOV W3, 0x886
226:                   CPU_CRITICAL_EXIT();
00711E  78019E     MOV [W14], W3
007120  880213     MOV W3, SR
227:               
228:                   return (rand_nbr);
007122  90003E     MOV [W14+6], W0
007124  9000CE     MOV [W14+8], W1
229:               }
007126  FA8000     ULNK
007128  060000     RETURN
230:               
231:               
232:               /*
233:               *********************************************************************************************************
234:               *                                           Math_RandSeed()
235:               *
236:               * Description : Calculate the next pseudo-random number.
237:               *
238:               * Argument(s) : seed        Initial (or current) value for the pseudo-random number sequence.
239:               *
240:               * Return(s)   : Next pseudo-random number in the sequence after 'seed'.
241:               *
242:               * Caller(s)   : Math_Rand(),
243:               *               Application.
244:               *
245:               * Note(s)     : (1) (a) BSD/ANSI-C implements rand() as a Linear Congruential Generator (LCG) :
246:               *
247:               *                       (A) random_number       =  [(a * random_number ) + b]  modulo m
248:               *                                        n + 1                        n
249:               *
250:               *                               where
251:               *                                       (1) (a) random_number           Next     random number to generate
252:               *                                                            n+1
253:               *                                           (b) random_number           Previous random number    generated
254:               *                                                            n
255:               *
256:               *                                       (2) a = RAND_LCG_PARAM_A        LCG multiplier
257:               *                                       (3) b = RAND_LCG_PARAM_B        LCG incrementor
258:               *                                       (4) m = RAND_LCG_PARAM_M + 1    LCG modulus
259:               *
260:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
261:               *
262:                                   See also 'lib_math.h  RANDOM NUMBER DEFINES  Note #1b'.
263:               *
264:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
265:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
266:               *
267:               *                   (b) However, Math_RandSeed() is re-entrant since it calculates the next random number
268:               *                       using ONLY local variables.
269:               *********************************************************************************************************
270:               */
271:               
272:               RAND_NBR  Math_RandSeed (RAND_NBR  seed)
273:               {
00712A  FA0008     LNK #0x8
00712C  980720     MOV W0, [W14+4]
00712E  980731     MOV W1, [W14+6]
274:                   RAND_NBR  rand_nbr;
275:               
276:               
277:                   rand_nbr = (((RAND_NBR)RAND_LCG_PARAM_A * seed) + (RAND_NBR)RAND_LCG_PARAM_B)  %  ((RAND_NBR)RAND_LCG_PARAM_M + 1u);
007130  9000BE     MOV [W14+6], W1
007132  24E6D0     MOV #0x4E6D, W0
007134  B98800     MUL.SS W1, W0, W0
007136  780100     MOV W0, W2
007138  9000AE     MOV [W14+4], W1
00713A  241C60     MOV #0x41C6, W0
00713C  B98800     MUL.SS W1, W0, W0
00713E  780000     MOV W0, W0
007140  410100     ADD W2, W0, W2
007142  9000AE     MOV [W14+4], W1
007144  24E6D0     MOV #0x4E6D, W0
007146  B80800     MUL.UU W1, W0, W0
007148  410101     ADD W2, W1, W2
00714A  780082     MOV W2, W1
00714C  230392     MOV #0x3039, W2
00714E  200003     MOV #0x0, W3
007150  410100     ADD W2, W0, W2
007152  498181     ADDC W3, W1, W3
007154  2FFFF0     MOV #0xFFFF, W0
007156  27FFF1     MOV #0x7FFF, W1
007158  780202     MOV W2, W4
00715A  780183     MOV W3, W3
00715C  780100     MOV W0, W2
00715E  780001     MOV W1, W0
007160  620102     AND W4, W2, W2
007162  618000     AND W3, W0, W0
007164  EB0080     CLR W1
007166  DD00C0     SL W0, #0, W1
007168  200000     MOV #0x0, W0
00716A  BE8F00     MOV.D W0, [W14]
00716C  B81061     MUL.UU W2, #1, W0
00716E  701F1E     IOR W0, [W14], [W14++]
007170  70971E     IOR W1, [W14], [W14--]
278:               
279:                   return (rand_nbr);
007172  BE001E     MOV.D [W14], W0
280:               }
007174  FA8000     ULNK
281:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uC-LIB/lib_ascii.c  ------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     ASCII CHARACTER OPERATIONS
29:                *
30:                * Filename      : lib_ascii.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : BAN
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *
51:                *                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
52:                *                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
53:                *
54:                *                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
55:                *                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
56:                *                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
57:                *                             All other characters are explicitly specified.
58:                *
59:                *                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
60:                *                             in the 7-bit character set.
61:                *
62:                *                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
63:                *                             standard in specified ways.
64:                *
65:                *                     (b) The character set represented in this file reproduces the Internation Reference
66:                *                         Version.  This is identical to the 7-bit character set which occupies Unicode
67:                *                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
68:                *                         Unicode specification, with certain abbreviations so that the resulting #define
69:                *                         names will not violate ANSI C naming restriction :
70:                *
71:                *                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
72:                *                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
73:                *********************************************************************************************************
74:                */
75:                
76:                
77:                /*
78:                *********************************************************************************************************
79:                *                                            INCLUDE FILES
80:                *********************************************************************************************************
81:                */
82:                
83:                #define    MICRIUM_SOURCE
84:                #define    LIB_ASCII_MODULE
85:                #include  <lib_ascii.h>
86:                
87:                
88:                /*
89:                *********************************************************************************************************
90:                *                                            LOCAL DEFINES
91:                *********************************************************************************************************
92:                */
93:                
94:                
95:                /*
96:                *********************************************************************************************************
97:                *                                           LOCAL CONSTANTS
98:                *********************************************************************************************************
99:                */
100:               
101:               
102:               /*
103:               *********************************************************************************************************
104:               *                                          LOCAL DATA TYPES
105:               *********************************************************************************************************
106:               */
107:               
108:               
109:               /*
110:               *********************************************************************************************************
111:               *                                            LOCAL TABLES
112:               *********************************************************************************************************
113:               */
114:               
115:               
116:               /*
117:               *********************************************************************************************************
118:               *                                       LOCAL GLOBAL VARIABLES
119:               *********************************************************************************************************
120:               */
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                      LOCAL FUNCTION PROTOTYPES
126:               *********************************************************************************************************
127:               */
128:               
129:               
130:               /*
131:               *********************************************************************************************************
132:               *                                     LOCAL CONFIGURATION ERRORS
133:               *********************************************************************************************************
134:               */
135:               
136:               
137:               /*
138:               *********************************************************************************************************
139:               *                                           ASCII_IsAlpha()
140:               *
141:               * Description : Determine whether a character is an alphabetic character.
142:               *
143:               * Argument(s) : c           Character to examine.
144:               *
145:               * Return(s)   : DEF_YES, if character is     an alphabetic character.
146:               *
147:               *               DEF_NO,     if character is NOT an alphabetic character.
148:               *
149:               * Caller(s)   : Application.
150:               *
151:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
152:               *                   characters for which isupper() or islower() is true".
153:               *********************************************************************************************************
154:               */
155:               
156:               CPU_BOOLEAN  ASCII_IsAlpha (CPU_CHAR  c)
157:               {
0061F4  FA0004     LNK #0x4
0061F6  984720     MOV.B W0, [W14+2]
158:                   CPU_BOOLEAN  alpha;
159:               
160:               
161:                   alpha = ASCII_IS_ALPHA(c);
0061F8  9040AE     MOV.B [W14+2], W1
0061FA  B3C400     MOV.B #0x40, W0
0061FC  50CF80     SUB.B W1, W0, [W15]
0061FE  360004     BRA LEU, 0x6208
006200  9040AE     MOV.B [W14+2], W1
006202  B3C5A0     MOV.B #0x5A, W0
006204  50CF80     SUB.B W1, W0, [W15]
006206  360008     BRA LEU, 0x6218
006208  9040AE     MOV.B [W14+2], W1
00620A  B3C600     MOV.B #0x60, W0
00620C  50CF80     SUB.B W1, W0, [W15]
00620E  360006     BRA LEU, 0x621C
006210  9040AE     MOV.B [W14+2], W1
006212  B3C7A0     MOV.B #0x7A, W0
006214  50CF80     SUB.B W1, W0, [W15]
006216  3E0002     BRA GTU, 0x621C
006218  B3C010     MOV.B #0x1, W0
00621A  370001     BRA 0x621E
00621C  EB4000     CLR.B W0
00621E  784F00     MOV.B W0, [W14]
162:               
163:                   return (alpha);
006220  78401E     MOV.B [W14], W0
164:               }
006222  FA8000     ULNK
006224  060000     RETURN
165:               
166:               
167:               /*
168:               *********************************************************************************************************
169:               *                                         ASCII_IsAlphaNum()
170:               *
171:               * Description : Determine whether a character is an alphanumeric character.
172:               *
173:               * Argument(s) : c           Character to examine.
174:               *
175:               * Return(s)   : DEF_YES, if character is     an alphanumeric character.
176:               *
177:               *               DEF_NO,     if character is NOT an alphanumeric character.
178:               *
179:               * Caller(s)   : Application.
180:               *
181:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
182:               *                   for which isalpha() or isdigit() is true".
183:               *********************************************************************************************************
184:               */
185:               
186:               CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
187:               {
006226  FA0004     LNK #0x4
006228  984720     MOV.B W0, [W14+2]
188:                   CPU_BOOLEAN  alpha_num;
189:               
190:               
191:                   alpha_num = ASCII_IS_ALPHA_NUM(c);
00622A  9040AE     MOV.B [W14+2], W1
00622C  B3C400     MOV.B #0x40, W0
00622E  50CF80     SUB.B W1, W0, [W15]
006230  360004     BRA LEU, 0x623A
006232  9040AE     MOV.B [W14+2], W1
006234  B3C5A0     MOV.B #0x5A, W0
006236  50CF80     SUB.B W1, W0, [W15]
006238  360010     BRA LEU, 0x625A
00623A  9040AE     MOV.B [W14+2], W1
00623C  B3C600     MOV.B #0x60, W0
00623E  50CF80     SUB.B W1, W0, [W15]
006240  360004     BRA LEU, 0x624A
006242  9040AE     MOV.B [W14+2], W1
006244  B3C7A0     MOV.B #0x7A, W0
006246  50CF80     SUB.B W1, W0, [W15]
006248  360008     BRA LEU, 0x625A
00624A  9040AE     MOV.B [W14+2], W1
00624C  B3C2F0     MOV.B #0x2F, W0
00624E  50CF80     SUB.B W1, W0, [W15]
006250  360006     BRA LEU, 0x625E
006252  9040AE     MOV.B [W14+2], W1
006254  B3C390     MOV.B #0x39, W0
006256  50CF80     SUB.B W1, W0, [W15]
006258  3E0002     BRA GTU, 0x625E
00625A  B3C010     MOV.B #0x1, W0
00625C  370001     BRA 0x6260
00625E  EB4000     CLR.B W0
006260  784F00     MOV.B W0, [W14]
192:               
193:                   return (alpha_num);
006262  78401E     MOV.B [W14], W0
194:               }
006264  FA8000     ULNK
006266  060000     RETURN
195:               
196:               
197:               /*
198:               *********************************************************************************************************
199:               *                                           ASCII_IsLower()
200:               *
201:               * Description : Determine whether a character is a lowercase alphabetic character.
202:               *
203:               * Argument(s) : c           Character to examine.
204:               *
205:               * Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
206:               *
207:               *               DEF_NO,     if character is NOT a lowercase alphabetic character.
208:               *
209:               * Caller(s)   : Application.
210:               *
211:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
212:               *                   the lowercase letters".
213:               *********************************************************************************************************
214:               */
215:               
216:               CPU_BOOLEAN  ASCII_IsLower (CPU_CHAR  c)
217:               {
006268  FA0004     LNK #0x4
00626A  984720     MOV.B W0, [W14+2]
218:                   CPU_BOOLEAN  lower;
219:               
220:               
221:                   lower = ASCII_IS_LOWER(c);
00626C  9040AE     MOV.B [W14+2], W1
00626E  B3C600     MOV.B #0x60, W0
006270  50CF80     SUB.B W1, W0, [W15]
006272  360006     BRA LEU, 0x6280
006274  9040AE     MOV.B [W14+2], W1
006276  B3C7A0     MOV.B #0x7A, W0
006278  50CF80     SUB.B W1, W0, [W15]
00627A  3E0002     BRA GTU, 0x6280
00627C  B3C010     MOV.B #0x1, W0
00627E  370001     BRA 0x6282
006280  EB4000     CLR.B W0
006282  784F00     MOV.B W0, [W14]
222:               
223:                   return (lower);
006284  78401E     MOV.B [W14], W0
224:               }
006286  FA8000     ULNK
006288  060000     RETURN
225:               
226:               
227:               /*
228:               *********************************************************************************************************
229:               *                                           ASCII_IsUpper()
230:               *
231:               * Description : Determine whether a character is an uppercase alphabetic character.
232:               *
233:               * Argument(s) : c           Character to examine.
234:               *
235:               * Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
236:               *
237:               *               DEF_NO,     if character is NOT an uppercase alphabetic character.
238:               *
239:               * Caller(s)   : Application.
240:               *
241:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
242:               *                   the uppercase letters".
243:               *********************************************************************************************************
244:               */
245:               
246:               CPU_BOOLEAN  ASCII_IsUpper (CPU_CHAR  c)
247:               {
00628A  FA0004     LNK #0x4
00628C  984720     MOV.B W0, [W14+2]
248:                   CPU_BOOLEAN  upper;
249:               
250:               
251:                   upper = ASCII_IS_UPPER(c);
00628E  9040AE     MOV.B [W14+2], W1
006290  B3C400     MOV.B #0x40, W0
006292  50CF80     SUB.B W1, W0, [W15]
006294  360006     BRA LEU, 0x62A2
006296  9040AE     MOV.B [W14+2], W1
006298  B3C5A0     MOV.B #0x5A, W0
00629A  50CF80     SUB.B W1, W0, [W15]
00629C  3E0002     BRA GTU, 0x62A2
00629E  B3C010     MOV.B #0x1, W0
0062A0  370001     BRA 0x62A4
0062A2  EB4000     CLR.B W0
0062A4  784F00     MOV.B W0, [W14]
252:               
253:                   return (upper);
0062A6  78401E     MOV.B [W14], W0
254:               }
0062A8  FA8000     ULNK
0062AA  060000     RETURN
255:               
256:               
257:               /*
258:               *********************************************************************************************************
259:               *                                            ASCII_IsDig()
260:               *
261:               * Description : Determine whether a character is a decimal-digit character.
262:               *
263:               * Argument(s) : c           Character to examine.
264:               *
265:               * Return(s)   : DEF_YES, if character is     a decimal-digit character.
266:               *
267:               *               DEF_NO,     if character is NOT a decimal-digit character.
268:               *
269:               * Caller(s)   : Application.
270:               *
271:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
272:               *                   decimal-digit character".
273:               *********************************************************************************************************
274:               */
275:               
276:               CPU_BOOLEAN  ASCII_IsDig (CPU_CHAR  c)
277:               {
0062AC  FA0004     LNK #0x4
0062AE  984720     MOV.B W0, [W14+2]
278:                   CPU_BOOLEAN  dig;
279:               
280:               
281:                   dig = ASCII_IS_DIG(c);
0062B0  9040AE     MOV.B [W14+2], W1
0062B2  B3C2F0     MOV.B #0x2F, W0
0062B4  50CF80     SUB.B W1, W0, [W15]
0062B6  360006     BRA LEU, 0x62C4
0062B8  9040AE     MOV.B [W14+2], W1
0062BA  B3C390     MOV.B #0x39, W0
0062BC  50CF80     SUB.B W1, W0, [W15]
0062BE  3E0002     BRA GTU, 0x62C4
0062C0  B3C010     MOV.B #0x1, W0
0062C2  370001     BRA 0x62C6
0062C4  EB4000     CLR.B W0
0062C6  784F00     MOV.B W0, [W14]
282:               
283:                   return (dig);
0062C8  78401E     MOV.B [W14], W0
284:               }
0062CA  FA8000     ULNK
0062CC  060000     RETURN
285:               
286:               
287:               /*
288:               *********************************************************************************************************
289:               *                                          ASCII_IsDigOct()
290:               *
291:               * Description : Determine whether a character is an octal-digit character.
292:               *
293:               * Argument(s) : c           Character to examine.
294:               *
295:               * Return(s)   : DEF_YES, if character is     an octal-digit character.
296:               *
297:               *               DEF_NO,     if character is NOT an octal-digit character.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               * Note(s)     : none.
302:               *********************************************************************************************************
303:               */
304:               
305:               CPU_BOOLEAN  ASCII_IsDigOct (CPU_CHAR  c)
306:               {
0062CE  FA0004     LNK #0x4
0062D0  984720     MOV.B W0, [W14+2]
307:                   CPU_BOOLEAN  dig_oct;
308:               
309:               
310:                   dig_oct = ASCII_IS_DIG_OCT(c);
0062D2  9040AE     MOV.B [W14+2], W1
0062D4  B3C2F0     MOV.B #0x2F, W0
0062D6  50CF80     SUB.B W1, W0, [W15]
0062D8  360006     BRA LEU, 0x62E6
0062DA  9040AE     MOV.B [W14+2], W1
0062DC  B3C370     MOV.B #0x37, W0
0062DE  50CF80     SUB.B W1, W0, [W15]
0062E0  3E0002     BRA GTU, 0x62E6
0062E2  B3C010     MOV.B #0x1, W0
0062E4  370001     BRA 0x62E8
0062E6  EB4000     CLR.B W0
0062E8  784F00     MOV.B W0, [W14]
311:               
312:                   return (dig_oct);
0062EA  78401E     MOV.B [W14], W0
313:               }
0062EC  FA8000     ULNK
0062EE  060000     RETURN
314:               
315:               
316:               /*
317:               *********************************************************************************************************
318:               *                                          ASCII_IsDigHex()
319:               *
320:               * Description : Determine whether a character is a hexadecimal-digit character.
321:               *
322:               * Argument(s) : c           Character to examine.
323:               *
324:               * Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
325:               *
326:               *               DEF_NO,     if character is NOT a hexadecimal-digit character.
327:               *
328:               * Caller(s)   : Application.
329:               *
330:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
331:               *                   hexadecimal-digit character".
332:               *********************************************************************************************************
333:               */
334:               
335:               CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
336:               {
0062F0  FA0004     LNK #0x4
0062F2  984720     MOV.B W0, [W14+2]
337:                   CPU_BOOLEAN  dig_hex;
338:               
339:               
340:                   dig_hex = ASCII_IS_DIG_HEX(c);
0062F4  9040AE     MOV.B [W14+2], W1
0062F6  B3C2F0     MOV.B #0x2F, W0
0062F8  50CF80     SUB.B W1, W0, [W15]
0062FA  360004     BRA LEU, 0x6304
0062FC  9040AE     MOV.B [W14+2], W1
0062FE  B3C390     MOV.B #0x39, W0
006300  50CF80     SUB.B W1, W0, [W15]
006302  360010     BRA LEU, 0x6324
006304  9040AE     MOV.B [W14+2], W1
006306  B3C400     MOV.B #0x40, W0
006308  50CF80     SUB.B W1, W0, [W15]
00630A  360004     BRA LEU, 0x6314
00630C  9040AE     MOV.B [W14+2], W1
00630E  B3C460     MOV.B #0x46, W0
006310  50CF80     SUB.B W1, W0, [W15]
006312  360008     BRA LEU, 0x6324
006314  9040AE     MOV.B [W14+2], W1
006316  B3C600     MOV.B #0x60, W0
006318  50CF80     SUB.B W1, W0, [W15]
00631A  360006     BRA LEU, 0x6328
00631C  9040AE     MOV.B [W14+2], W1
00631E  B3C660     MOV.B #0x66, W0
006320  50CF80     SUB.B W1, W0, [W15]
006322  3E0002     BRA GTU, 0x6328
006324  B3C010     MOV.B #0x1, W0
006326  370001     BRA 0x632A
006328  EB4000     CLR.B W0
00632A  784F00     MOV.B W0, [W14]
341:               
342:                   return (dig_hex);
00632C  78401E     MOV.B [W14], W0
343:               }
00632E  FA8000     ULNK
006330  060000     RETURN
344:               
345:               
346:               /*
347:               *********************************************************************************************************
348:               *                                           ASCII_IsBlank()
349:               *
350:               * Description : Determine whether a character is a standard blank character.
351:               *
352:               * Argument(s) : c           Character to examine.
353:               *
354:               * Return(s)   : DEF_YES, if character is     a standard blank character.
355:               *
356:               *               DEF_NO,     if character is NOT a standard blank character.
357:               *
358:               * Caller(s)   : Application.
359:               *
360:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
361:               *                       the standard blank characters".
362:               *
363:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
364:               *                       the "space (' '), and horizontal tab ('\t')".
365:               *********************************************************************************************************
366:               */
367:               
368:               CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
369:               {
006332  FA0004     LNK #0x4
006334  984720     MOV.B W0, [W14+2]
370:                   CPU_BOOLEAN  blank;
371:               
372:               
373:                   blank = ASCII_IS_BLANK(c);
006336  9040AE     MOV.B [W14+2], W1
006338  B3C200     MOV.B #0x20, W0
00633A  50CF80     SUB.B W1, W0, [W15]
00633C  320003     BRA Z, 0x6344
00633E  90402E     MOV.B [W14+2], W0
006340  504FE9     SUB.B W0, #0x9, [W15]
006342  3A0002     BRA NZ, 0x6348
006344  B3C010     MOV.B #0x1, W0
006346  370001     BRA 0x634A
006348  EB4000     CLR.B W0
00634A  784F00     MOV.B W0, [W14]
374:               
375:                   return (blank);
00634C  78401E     MOV.B [W14], W0
376:               }
00634E  FA8000     ULNK
006350  060000     RETURN
377:               
378:               
379:               /*
380:               *********************************************************************************************************
381:               *                                           ASCII_IsSpace()
382:               *
383:               * Description : Determine whether a character is a white-space character.
384:               *
385:               * Argument(s) : c           Character to examine.
386:               *
387:               * Return(s)   : DEF_YES, if character is     a white-space character.
388:               *
389:               *               DEF_NO,     if character is NOT a white-space character.
390:               *
391:               * Caller(s)   : Application.
392:               *
393:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
394:               *                       for the standard white-space characters".
395:               *
396:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
397:               *                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
398:               *                       horizontal tab ('\t'), and vertical tab ('\v')".
399:               *********************************************************************************************************
400:               */
401:               
402:               CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
403:               {
006352  FA0004     LNK #0x4
006354  984720     MOV.B W0, [W14+2]
404:                   CPU_BOOLEAN  space;
405:               
406:               
407:                   space = ASCII_IS_SPACE(c);
006356  9040AE     MOV.B [W14+2], W1
006358  B3C200     MOV.B #0x20, W0
00635A  50CF80     SUB.B W1, W0, [W15]
00635C  32000F     BRA Z, 0x637C
00635E  90402E     MOV.B [W14+2], W0
006360  504FED     SUB.B W0, #0xD, [W15]
006362  32000C     BRA Z, 0x637C
006364  90402E     MOV.B [W14+2], W0
006366  504FEA     SUB.B W0, #0xA, [W15]
006368  320009     BRA Z, 0x637C
00636A  90402E     MOV.B [W14+2], W0
00636C  504FEC     SUB.B W0, #0xC, [W15]
00636E  320006     BRA Z, 0x637C
006370  90402E     MOV.B [W14+2], W0
006372  504FE9     SUB.B W0, #0x9, [W15]
006374  320003     BRA Z, 0x637C
006376  90402E     MOV.B [W14+2], W0
006378  504FEB     SUB.B W0, #0xB, [W15]
00637A  3A0002     BRA NZ, 0x6380
00637C  B3C010     MOV.B #0x1, W0
00637E  370001     BRA 0x6382
006380  EB4000     CLR.B W0
006382  784F00     MOV.B W0, [W14]
408:               
409:                   return (space);
006384  78401E     MOV.B [W14], W0
410:               }
006386  FA8000     ULNK
006388  060000     RETURN
411:               
412:               
413:               /*
414:               *********************************************************************************************************
415:               *                                           ASCII_IsPrint()
416:               *
417:               * Description : Determine whether a character is a printing character.
418:               *
419:               * Argument(s) : c           Character to examine.
420:               *
421:               * Return(s)   : DEF_YES, if character is     a printing character.
422:               *
423:               *               DEF_NO,     if character is NOT a printing character.
424:               *
425:               * Caller(s)   : Application.
426:               *
427:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
428:               *                       printing character including space (' ')".
429:               *
430:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
431:               *                       ASCII character set, the printing characters are those whose values lie from
432:               *                       0x20 (space) through 0x7E (tilde)".
433:               *********************************************************************************************************
434:               */
435:               
436:               CPU_BOOLEAN  ASCII_IsPrint (CPU_CHAR  c)
437:               {
00638A  FA0004     LNK #0x4
00638C  984720     MOV.B W0, [W14+2]
438:                   CPU_BOOLEAN  print;
439:               
440:               
441:                   print = ASCII_IS_PRINT(c);
00638E  90402E     MOV.B [W14+2], W0
006390  504FFF     SUB.B W0, #0x1F, [W15]
006392  360006     BRA LEU, 0x63A0
006394  9040AE     MOV.B [W14+2], W1
006396  B3C7E0     MOV.B #0x7E, W0
006398  50CF80     SUB.B W1, W0, [W15]
00639A  3E0002     BRA GTU, 0x63A0
00639C  B3C010     MOV.B #0x1, W0
00639E  370001     BRA 0x63A2
0063A0  EB4000     CLR.B W0
0063A2  784F00     MOV.B W0, [W14]
442:               
443:                   return (print);
0063A4  78401E     MOV.B [W14], W0
444:               }
0063A6  FA8000     ULNK
0063A8  060000     RETURN
445:               
446:               
447:               /*
448:               *********************************************************************************************************
449:               *                                           ASCII_IsGraph()
450:               *
451:               * Description : Determine whether a character is any printing character except a space character.
452:               *
453:               * Argument(s) : c           Character to examine.
454:               *
455:               * Return(s)   : DEF_YES, if character is     a graphic character.
456:               *
457:               *               DEF_NO,     if character is NOT a graphic character.
458:               *
459:               * Caller(s)   : Application.
460:               *
461:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
462:               *                       printing character except space (' ')".
463:               *
464:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
465:               *                       ASCII character set, the printing characters are those whose values lie from
466:               *                       0x20 (space) through 0x7E (tilde)".
467:               *********************************************************************************************************
468:               */
469:               
470:               CPU_BOOLEAN  ASCII_IsGraph (CPU_CHAR  c)
471:               {
0063AA  FA0004     LNK #0x4
0063AC  984720     MOV.B W0, [W14+2]
472:                   CPU_BOOLEAN  graph;
473:               
474:               
475:                   graph = ASCII_IS_GRAPH(c);
0063AE  9040AE     MOV.B [W14+2], W1
0063B0  B3C200     MOV.B #0x20, W0
0063B2  50CF80     SUB.B W1, W0, [W15]
0063B4  360006     BRA LEU, 0x63C2
0063B6  9040AE     MOV.B [W14+2], W1
0063B8  B3C7E0     MOV.B #0x7E, W0
0063BA  50CF80     SUB.B W1, W0, [W15]
0063BC  3E0002     BRA GTU, 0x63C2
0063BE  B3C010     MOV.B #0x1, W0
0063C0  370001     BRA 0x63C4
0063C2  EB4000     CLR.B W0
0063C4  784F00     MOV.B W0, [W14]
476:               
477:                   return (graph);
0063C6  78401E     MOV.B [W14], W0
478:               }
0063C8  FA8000     ULNK
0063CA  060000     RETURN
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           ASCII_IsPunct()
484:               *
485:               * Description : Determine whether a character is a punctuation character.
486:               *
487:               * Argument(s) : c           Character to examine.
488:               *
489:               * Return(s)   : DEF_YES, if character is     a punctuation character.
490:               *
491:               *               DEF_NO,     if character is NOT a punctuation character.
492:               *
493:               * Caller(s)   : Application.
494:               *
495:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
496:               *                   printing character for which neither isspace() nor isalnum() is true".
497:               *********************************************************************************************************
498:               */
499:               
500:               CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
501:               {
0063CC  FA0004     LNK #0x4
0063CE  984720     MOV.B W0, [W14+2]
502:                   CPU_BOOLEAN  punct;
503:               
504:               
505:                   punct = ASCII_IS_PUNCT(c);
0063D0  90402E     MOV.B [W14+2], W0
0063D2  504FFF     SUB.B W0, #0x1F, [W15]
0063D4  360031     BRA LEU, 0x6438
0063D6  9040AE     MOV.B [W14+2], W1
0063D8  B3C7E0     MOV.B #0x7E, W0
0063DA  50CF80     SUB.B W1, W0, [W15]
0063DC  3E002D     BRA GTU, 0x6438
0063DE  9040AE     MOV.B [W14+2], W1
0063E0  B3C200     MOV.B #0x20, W0
0063E2  50CF80     SUB.B W1, W0, [W15]
0063E4  320029     BRA Z, 0x6438
0063E6  90402E     MOV.B [W14+2], W0
0063E8  504FED     SUB.B W0, #0xD, [W15]
0063EA  320026     BRA Z, 0x6438
0063EC  90402E     MOV.B [W14+2], W0
0063EE  504FEA     SUB.B W0, #0xA, [W15]
0063F0  320023     BRA Z, 0x6438
0063F2  90402E     MOV.B [W14+2], W0
0063F4  504FEC     SUB.B W0, #0xC, [W15]
0063F6  320020     BRA Z, 0x6438
0063F8  90402E     MOV.B [W14+2], W0
0063FA  504FE9     SUB.B W0, #0x9, [W15]
0063FC  32001D     BRA Z, 0x6438
0063FE  90402E     MOV.B [W14+2], W0
006400  504FEB     SUB.B W0, #0xB, [W15]
006402  32001A     BRA Z, 0x6438
006404  9040AE     MOV.B [W14+2], W1
006406  B3C400     MOV.B #0x40, W0
006408  50CF80     SUB.B W1, W0, [W15]
00640A  360004     BRA LEU, 0x6414
00640C  9040AE     MOV.B [W14+2], W1
00640E  B3C5A0     MOV.B #0x5A, W0
006410  50CF80     SUB.B W1, W0, [W15]
006412  360012     BRA LEU, 0x6438
006414  9040AE     MOV.B [W14+2], W1
006416  B3C600     MOV.B #0x60, W0
006418  50CF80     SUB.B W1, W0, [W15]
00641A  360004     BRA LEU, 0x6424
00641C  9040AE     MOV.B [W14+2], W1
00641E  B3C7A0     MOV.B #0x7A, W0
006420  50CF80     SUB.B W1, W0, [W15]
006422  36000A     BRA LEU, 0x6438
006424  9040AE     MOV.B [W14+2], W1
006426  B3C2F0     MOV.B #0x2F, W0
006428  50CF80     SUB.B W1, W0, [W15]
00642A  360004     BRA LEU, 0x6434
00642C  9040AE     MOV.B [W14+2], W1
00642E  B3C390     MOV.B #0x39, W0
006430  50CF80     SUB.B W1, W0, [W15]
006432  360002     BRA LEU, 0x6438
006434  B3C010     MOV.B #0x1, W0
006436  370001     BRA 0x643A
006438  EB4000     CLR.B W0
00643A  784F00     MOV.B W0, [W14]
506:               
507:                   return (punct);
00643C  78401E     MOV.B [W14], W0
508:               }
00643E  FA8000     ULNK
006440  060000     RETURN
509:               
510:               
511:               /*
512:               *********************************************************************************************************
513:               *                                           ASCII_IsCtrl()
514:               *
515:               * Description : Determine whether a character is a control character.
516:               *
517:               * Argument(s) : c           Character to examine.
518:               *
519:               * Return(s)   : DEF_YES, if character is     a control character.
520:               *
521:               *               DEF_NO,     if character is NOT a control character.
522:               *
523:               * Caller(s)   : Application.
524:               *
525:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
526:               *                       control character".
527:               *
528:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
529:               *                       ASCII character set, ... the control characters are those whose values lie from
530:               *                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
531:               *********************************************************************************************************
532:               */
533:               
534:               CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
535:               {
006442  FA0004     LNK #0x4
006444  984720     MOV.B W0, [W14+2]
536:                   CPU_BOOLEAN  ctrl;
537:               
538:               
539:                   ctrl = ASCII_IS_CTRL(c);
006446  90402E     MOV.B [W14+2], W0
006448  E00400     CP0.B W0
00644A  350003     BRA LT, 0x6452
00644C  90402E     MOV.B [W14+2], W0
00644E  504FFF     SUB.B W0, #0x1F, [W15]
006450  360004     BRA LEU, 0x645A
006452  9040AE     MOV.B [W14+2], W1
006454  B3C7F0     MOV.B #0x7F, W0
006456  50CF80     SUB.B W1, W0, [W15]
006458  3A0002     BRA NZ, 0x645E
00645A  B3C010     MOV.B #0x1, W0
00645C  370001     BRA 0x6460
00645E  EB4000     CLR.B W0
006460  784F00     MOV.B W0, [W14]
540:               
541:                   return (ctrl);
006462  78401E     MOV.B [W14], W0
542:               }
006464  FA8000     ULNK
006466  060000     RETURN
543:               
544:               
545:               /*
546:               *********************************************************************************************************
547:               *                                           ASCII_ToLower()
548:               *
549:               * Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
550:               *
551:               * Argument(s) : c           Character to convert.
552:               *
553:               * Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
554:               *
555:               *               Character 'c',               otherwise                                  (see Note #1b2).
556:               *
557:               * Caller(s)   : Application.
558:               *
559:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
560:               *                       uppercase letter to a corresponding lowercase letter".
561:               *
562:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
563:               *
564:               *                       (1) (A) "if the argument is a character for which isupper() is true and there are
565:               *                                one or more corresponding characters ... for which islower() is true," ...
566:               *                           (B) "tolower() ... returns one of the corresponding characters;" ...
567:               *
568:               *                       (2) "otherwise, the argument is returned unchanged."
569:               *********************************************************************************************************
570:               */
571:               
572:               CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
573:               {
006468  FA0004     LNK #0x4
00646A  984720     MOV.B W0, [W14+2]
574:                   CPU_CHAR  lower;
575:               
576:               
577:                   lower = ASCII_TO_LOWER(c);
00646C  9040AE     MOV.B [W14+2], W1
00646E  B3C400     MOV.B #0x40, W0
006470  50CF80     SUB.B W1, W0, [W15]
006472  360007     BRA LEU, 0x6482
006474  9040AE     MOV.B [W14+2], W1
006476  B3C5A0     MOV.B #0x5A, W0
006478  50CF80     SUB.B W1, W0, [W15]
00647A  3E0003     BRA GTU, 0x6482
00647C  90402E     MOV.B [W14+2], W0
00647E  B04200     ADD.B #0x20, W0
006480  370001     BRA 0x6484
006482  90402E     MOV.B [W14+2], W0
006484  784F00     MOV.B W0, [W14]
578:               
579:                   return (lower);
006486  78401E     MOV.B [W14], W0
580:               }
006488  FA8000     ULNK
00648A  060000     RETURN
581:               
582:               
583:               /*
584:               *********************************************************************************************************
585:               *                                           ASCII_ToUpper()
586:               *
587:               * Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
588:               *
589:               * Argument(s) : c           Character to convert.
590:               *
591:               * Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
592:               *
593:               *               Character 'c',               otherwise                                 (see Note #1b2).
594:               *
595:               * Caller(s)   : Application.
596:               *
597:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
598:               *                       lowercase letter to a corresponding uppercase letter".
599:               *
600:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
601:               *
602:               *                       (1) (A) "if the argument is a character for which islower() is true and there are
603:               *                                one or more corresponding characters ... for which isupper() is true," ...
604:               *                           (B) "toupper() ... returns one of the corresponding characters;" ...
605:               *
606:               *                       (2) "otherwise, the argument is returned unchanged."
607:               *********************************************************************************************************
608:               */
609:               
610:               CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
611:               {
00648C  FA0004     LNK #0x4
00648E  984720     MOV.B W0, [W14+2]
612:                   CPU_CHAR  upper;
613:               
614:               
615:                   upper = ASCII_TO_UPPER(c);
006490  9040AE     MOV.B [W14+2], W1
006492  B3C600     MOV.B #0x60, W0
006494  50CF80     SUB.B W1, W0, [W15]
006496  360008     BRA LEU, 0x64A8
006498  9040AE     MOV.B [W14+2], W1
00649A  B3C7A0     MOV.B #0x7A, W0
00649C  50CF80     SUB.B W1, W0, [W15]
00649E  3E0004     BRA GTU, 0x64A8
0064A0  9040AE     MOV.B [W14+2], W1
0064A2  B3CE00     MOV.B #0xE0, W0
0064A4  40C000     ADD.B W1, W0, W0
0064A6  370001     BRA 0x64AA
0064A8  90402E     MOV.B [W14+2], W0
0064AA  784F00     MOV.B W0, [W14]
616:               
617:                   return (upper);
0064AC  78401E     MOV.B [W14], W0
618:               }
0064AE  FA8000     ULNK
0064B0  060000     RETURN
619:               
620:               
621:               /*
622:               *********************************************************************************************************
623:               *                                             ASCII_Cmp()
624:               *
625:               * Description : Determine if two characters are identical (case-insensitive).
626:               *
627:               * Argument(s) : c1          First  character.
628:               *
629:               *               c2          Second character.
630:               *
631:               * Return(s)   : DEF_YES, if the characters are     identical.
632:               *
633:               *               DEF_NO,  if the characters are NOT identical.
634:               *
635:               * Caller(s)   : Application.
636:               *
637:               * Note(s)     : none.
638:               *********************************************************************************************************
639:               */
640:               
641:               CPU_BOOLEAN  ASCII_Cmp (CPU_CHAR  c1,
642:                                       CPU_CHAR  c2)
643:               {
0064B2  FA0006     LNK #0x6
0064B4  984740     MOV.B W0, [W14+4]
0064B6  984751     MOV.B W1, [W14+5]
644:                   CPU_CHAR     c1_upper;
645:                   CPU_CHAR     c2_upper;
646:                   CPU_BOOLEAN  cmp;
647:               
648:               
649:                   c1_upper =  ASCII_ToUpper(c1);
0064B8  90404E     MOV.B [W14+4], W0
0064BA  07FFE8     RCALL ASCII_ToUpper
0064BC  784F00     MOV.B W0, [W14]
650:                   c2_upper =  ASCII_ToUpper(c2);
0064BE  90405E     MOV.B [W14+5], W0
0064C0  07FFE5     RCALL ASCII_ToUpper
0064C2  984710     MOV.B W0, [W14+1]
651:                   cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);
0064C4  90401E     MOV.B [W14+1], W0
0064C6  78409E     MOV.B [W14], W1
0064C8  50CF80     SUB.B W1, W0, [W15]
0064CA  3A0002     BRA NZ, 0x64D0
0064CC  B3C010     MOV.B #0x1, W0
0064CE  370001     BRA 0x64D2
0064D0  EB4000     CLR.B W0
0064D2  984720     MOV.B W0, [W14+2]
652:               
653:                   return (cmp);
0064D4  90402E     MOV.B [W14+2], W0
654:               }
0064D6  FA8000     ULNK
655:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/uC-CPU/cpu_core.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/CPU
4:                 *                                    CPU CONFIGURATION & PORT LAYER
5:                 *
6:                 *                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
7:                 *
8:                 *               All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *               uC/CPU is provided in source form to registered licensees ONLY.  It is
11:                *               illegal to distribute this source code to any third party unless you receive
12:                *               written permission by an authorized Micrium representative.  Knowledge of
13:                *               the source code may NOT be used to develop a similar product.
14:                *
15:                *               Please help us continue to provide the Embedded community with the finest
16:                *               software available.  Your honesty is greatly appreciated.
17:                *
18:                *               You can find our product's user manual, API reference, release notes and
19:                *               more information at https://doc.micrium.com.
20:                *               You can contact us at www.micrium.com.
21:                *********************************************************************************************************
22:                */
23:                
24:                /*
25:                *********************************************************************************************************
26:                *
27:                *                                           CORE CPU MODULE
28:                *
29:                * Filename      : cpu_core.c
30:                * Version       : V1.30.01
31:                * Programmer(s) : SR
32:                *                 ITJ
33:                *********************************************************************************************************
34:                */
35:                
36:                
37:                /*
38:                *********************************************************************************************************
39:                *                                            INCLUDE FILES
40:                *********************************************************************************************************
41:                */
42:                
43:                #define    MICRIUM_SOURCE
44:                #define    CPU_CORE_MODULE
45:                #include  "cpu_core.h"
46:                
47:                #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
48:                #include  "cpu_cache.h"
49:                #endif
50:                
51:                
52:                /*
53:                *********************************************************************************************************
54:                *                                            LOCAL DEFINES
55:                *********************************************************************************************************
56:                */
57:                
58:                
59:                /*
60:                *********************************************************************************************************
61:                *                                           LOCAL CONSTANTS
62:                *********************************************************************************************************
63:                */
64:                
65:                
66:                /*
67:                *********************************************************************************************************
68:                *                                          LOCAL DATA TYPES
69:                *********************************************************************************************************
70:                */
71:                
72:                
73:                /*
74:                *********************************************************************************************************
75:                *                                            LOCAL TABLES
76:                *********************************************************************************************************
77:                */
78:                
79:                /*
80:                *********************************************************************************************************
81:                *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
82:                *
83:                * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
84:                *
85:                *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
86:                *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
87:                *                          1    x    x    x    x    x    x    x            0
88:                *                          0    1    x    x    x    x    x    x            1
89:                *                          0    0    1    x    x    x    x    x            2
90:                *                          0    0    0    1    x    x    x    x            3
91:                *                          0    0    0    0    1    x    x    x            4
92:                *                          0    0    0    0    0    1    x    x            5
93:                *                          0    0    0    0    0    0    1    x            6
94:                *                          0    0    0    0    0    0    0    1            7
95:                *                          0    0    0    0    0    0    0    0            8
96:                *********************************************************************************************************
97:                */
98:                
99:                #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
100:                     (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))
101:               static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
102:               /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
103:                   8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
104:                   3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
105:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
106:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
107:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
108:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
109:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
110:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
111:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
112:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
113:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
114:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
115:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
116:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
117:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
118:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
119:               };
120:               #endif
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                       LOCAL GLOBAL VARIABLES
126:               *********************************************************************************************************
127:               */
128:               
129:               CPU_INT32U  const  CPU_EndiannessTest = 0x12345678LU;               /* Variable to test CPU endianness.                 */
130:               
131:               
132:               /*
133:               *********************************************************************************************************
134:               *                                      LOCAL FUNCTION PROTOTYPES
135:               *********************************************************************************************************
136:               */
137:               
138:               #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
139:               static  void        CPU_NameInit         (void);
140:               #endif
141:               
142:               
143:                                                                                   /* ----------------- CPU TS FNCTS ----------------- */
144:               #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
145:                      (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
146:               static  void        CPU_TS_Init          (void);
147:               #endif
148:               
149:               
150:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
151:               static  void        CPU_IntDisMeasInit   (void);
152:               
153:               static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
154:               #endif
155:               
156:               
157:               /*
158:               *********************************************************************************************************
159:               *                                     LOCAL CONFIGURATION ERRORS
160:               *********************************************************************************************************
161:               */
162:               
163:               
164:               /*
165:               *********************************************************************************************************
166:               *                                             CPU_Init()
167:               *
168:               * Description : (1) Initialize CPU module :
169:               *
170:               *                   (a) Initialize CPU timestamps
171:               *                   (b) Initialize CPU interrupts disabled time measurements
172:               *                   (c) Initialize CPU host name
173:               *
174:               *
175:               * Argument(s) : none.
176:               *
177:               * Return(s)   : none.
178:               *
179:               * Caller(s)   : Your Product's Application.
180:               *
181:               *               This function is a CPU initialization function & MAY be called by application/
182:               *               initialization function(s).
183:               *
184:               * Note(s)     : (2) CPU_Init() MUST be called ... :
185:               *
186:               *                   (a) ONLY ONCE from a product's application; ...
187:               *                   (b) BEFORE product's application calls any core CPU module function(s)
188:               *
189:               *               (3) The following initialization functions MUST be sequenced as follows :
190:               *
191:               *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
192:               *
193:               *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
194:               *                                                   & other CPU interrupts disabled time measurement functions
195:               *********************************************************************************************************
196:               */
197:               
198:               void  CPU_Init (void)
199:               {
005E44  FA0000     LNK #0x0
200:                                                                               /* --------------------- INIT TS ---------------------- */
201:               #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
202:                    (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
203:                   CPU_TS_Init();                                              /* See Note #3a.                                        */
204:               #endif
205:                                                                               /* -------------- INIT INT DIS TIME MEAS -------------- */
206:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
207:                   CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
208:               #endif
209:               
210:                                                                               /* ------------------ INIT CPU NAME ------------------- */
211:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
212:                    CPU_NameInit();
213:               #endif
214:               
215:               #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
216:                    CPU_Cache_Init();
217:               #endif
218:               }
005E46  FA8000     ULNK
005E48  060000     RETURN
219:               
220:               
221:               /*
222:               *********************************************************************************************************
223:               *                                         CPU_SW_Exception()
224:               *
225:               * Description : Trap unrecoverable software exception.
226:               *
227:               * Argument(s) : none.
228:               *
229:               * Return(s)   : none.
230:               *
231:               * Caller(s)   : various.
232:               *
233:               * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
234:               *                   -processed/-threaded or single-threaded -- when the current code execution cannot 
235:               *                   gracefully recover or report a fault or exception condition.
236:               *
237:               *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
238:               *********************************************************************************************************
239:               */
240:               
241:               void  CPU_SW_Exception (void)
242:               {
005E4A  FA0000     LNK #0x0
243:                   while (DEF_ON) {
244:                       ;
245:                   }
005E4C  37FFFF     BRA 0x5E4C
246:               }
247:               
248:               
249:               /*
250:               *********************************************************************************************************
251:               *                                            CPU_NameClr()
252:               *
253:               * Description : Clear CPU Name.
254:               *
255:               * Argument(s) : none.
256:               *
257:               * Return(s)   : none.
258:               *
259:               * Caller(s)   : CPU_NameInit(),
260:               *               Application.
261:               *
262:               *               This function is a CPU module application programming interface (API) function & MAY be 
263:               *               called by application function(s).
264:               *
265:               * Note(s)     : none.
266:               *********************************************************************************************************
267:               */
268:               
269:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
270:               void  CPU_NameClr (void)
271:               {
272:                   CPU_SR_ALLOC();
273:               
274:               
275:                   CPU_CRITICAL_ENTER();
276:                   Mem_Clr((void     *)&CPU_Name[0],
277:                           (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
278:                   CPU_CRITICAL_EXIT();
279:               }
280:               #endif
281:               
282:               
283:               /*
284:               *********************************************************************************************************
285:               *                                            CPU_NameGet()
286:               *
287:               * Description : Get CPU host name.
288:               *
289:               * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
290:               *                               name ASCII string from this function (see Note #1).
291:               *
292:               *               p_err       Pointer to variable that will receive the return error code from this function :
293:               *
294:               *                               CPU_ERR_NONE                    CPU host name successfully returned.
295:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
296:               *
297:               * Return(s)   : none.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               *               This function is a CPU module application programming interface (API) function & MAY 
302:               *               be called by application function(s).
303:               *
304:               * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
305:               *                   ASCII string :
306:               *
307:               *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
308:               *                           size including the terminating NULL character;
309:               *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
310:               *********************************************************************************************************
311:               */
312:               
313:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
314:               void  CPU_NameGet (CPU_CHAR  *p_name,
315:                                  CPU_ERR   *p_err)
316:               {
317:                   CPU_SR_ALLOC();
318:               
319:               
320:                   if (p_err == (CPU_ERR *)0) {
321:                       CPU_SW_EXCEPTION(;);
322:                   }
323:               
324:                   if (p_name == (CPU_CHAR *)0) {
325:                      *p_err = CPU_ERR_NULL_PTR;
326:                       return;
327:                   }
328:               
329:                   CPU_CRITICAL_ENTER();
330:                  (void)Str_Copy_N(p_name,
331:                                  &CPU_Name[0],
332:                                   CPU_CFG_NAME_SIZE);
333:                   CPU_CRITICAL_EXIT();
334:               
335:                  *p_err = CPU_ERR_NONE;
336:               }
337:               #endif
338:               
339:               
340:               /*
341:               *********************************************************************************************************
342:               *                                            CPU_NameSet()
343:               *
344:               * Description : Set CPU host name.
345:               *
346:               * Argument(s) : p_name      Pointer to CPU host name to set.
347:               *
348:               *               p_err       Pointer to variable that will receive the return error code from this function :
349:               *
350:               *                               CPU_ERR_NONE                    CPU host name successfully set.
351:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
352:               *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
353:               *
354:               * Return(s)   : none.
355:               *
356:               * Caller(s)   : Application.
357:               *
358:               *               This function is a CPU module application programming interface (API) function & MAY be 
359:               *               called by application function(s).
360:               *
361:               * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
362:               *                    than or equal to CPU_CFG_NAME_SIZE.
363:               *********************************************************************************************************
364:               */
365:               
366:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
367:               void  CPU_NameSet (const  CPU_CHAR  *p_name,
368:                                         CPU_ERR   *p_err)
369:               {
370:                   CPU_SIZE_T  len;
371:                   CPU_SR_ALLOC();
372:               
373:               
374:                   if (p_err == (CPU_ERR *)0) {
375:                       CPU_SW_EXCEPTION(;);
376:                   }
377:               
378:                   if (p_name == (const CPU_CHAR *)0) {
379:                      *p_err = CPU_ERR_NULL_PTR;
380:                       return;
381:                   }
382:               
383:                   len = Str_Len_N(p_name,
384:                                   CPU_CFG_NAME_SIZE);
385:                   if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
386:                       CPU_CRITICAL_ENTER();
387:                      (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
388:                                        p_name,
389:                                        CPU_CFG_NAME_SIZE);
390:                       CPU_CRITICAL_EXIT();
391:                      *p_err = CPU_ERR_NONE;
392:               
393:                   } else {
394:                      *p_err = CPU_ERR_NAME_SIZE;
395:                   }
396:               }
397:               #endif
398:               
399:               
400:               /*
401:               *********************************************************************************************************
402:               *                                           CPU_TS_Get32()
403:               *
404:               * Description : Get current 32-bit CPU timestamp.
405:               *
406:               * Argument(s) : none.
407:               *
408:               * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
409:               *
410:               * Caller(s)   : Application.
411:               *
412:               *               This function is a CPU module application programming interface (API) function & MAY 
413:               *               be called by application function(s).
414:               *
415:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
416:               *                   either of the following equations :
417:               *
418:               *                       (a) Time measured  =  Number timer counts  *  Timer period
419:               *
420:               *                               where
421:               *
422:               *                                   Number timer counts     Number of timer counts measured
423:               *                                   Timer period            Timer's period in some units of
424:               *                                                               (fractional) seconds
425:               *                                   Time measured           Amount of time measured, in same
426:               *                                                               units of (fractional) seconds
427:               *                                                               as the Timer period
428:               *
429:               *                                              Number timer counts
430:               *                       (b) Time measured  =  ---------------------
431:               *                                                Timer frequency
432:               *
433:               *                               where
434:               *
435:               *                                   Number timer counts     Number of timer counts measured
436:               *                                   Timer frequency         Timer's frequency in some units
437:               *                                                               of counts per second
438:               *                                   Time measured           Amount of time measured, in seconds
439:               *
440:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
441:               *
442:               *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
443:               *                   its precision is extended via periodic updates by accumulating the deltas of the
444:               *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
445:               *
446:               *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
447:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
448:               *                   with critical sections.
449:               *********************************************************************************************************
450:               */
451:               
452:               #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
453:               CPU_TS32  CPU_TS_Get32 (void)
454:               {
455:                   CPU_TS32    ts;
456:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
457:                   CPU_TS_TMR  tmr_cur;
458:                   CPU_TS_TMR  tmr_delta;
459:                   CPU_SR_ALLOC();
460:               #endif
461:               
462:               
463:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
464:                   ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
465:               
466:               #else
467:                   CPU_INT_DIS();
468:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
469:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
470:                   CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
471:                   CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
472:                   ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
473:                   CPU_INT_EN();
474:               #endif
475:               
476:                   return (ts);
477:               }
478:               #endif
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           CPU_TS_Get64()
484:               *
485:               * Description : Get current 64-bit CPU timestamp.
486:               *
487:               * Argument(s) : none.
488:               *
489:               * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
490:               *
491:               * Caller(s)   : Application.
492:               *
493:               *               This function is a CPU module application programming interface (API) function & MAY 
494:               *               be called by application function(s).
495:               *
496:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
497:               *                   either of the following equations :
498:               *
499:               *                       (a) Time measured  =  Number timer counts  *  Timer period
500:               *
501:               *                               where
502:               *
503:               *                                   Number timer counts     Number of timer counts measured
504:               *                                   Timer period            Timer's period in some units of
505:               *                                                               (fractional) seconds
506:               *                                   Time measured           Amount of time measured, in same
507:               *                                                               units of (fractional) seconds
508:               *                                                               as the Timer period
509:               *
510:               *                                              Number timer counts
511:               *                       (b) Time measured  =  ---------------------
512:               *                                                Timer frequency
513:               *
514:               *                               where
515:               *
516:               *                                   Number timer counts     Number of timer counts measured
517:               *                                   Timer frequency         Timer's frequency in some units
518:               *                                                               of counts per second
519:               *                                   Time measured           Amount of time measured, in seconds
520:               *
521:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
522:               *
523:               *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
524:               *                   its precision is extended via periodic updates by accumulating the deltas of the
525:               *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
526:               *
527:               *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
528:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
529:               *                   with critical sections.
530:               *********************************************************************************************************
531:               */
532:               
533:               #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
534:               CPU_TS64  CPU_TS_Get64 (void)
535:               {
536:                   CPU_TS64    ts;
537:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
538:                   CPU_TS_TMR  tmr_cur;
539:                   CPU_TS_TMR  tmr_delta;
540:                   CPU_SR_ALLOC();
541:               #endif
542:               
543:               
544:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
545:                   ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
546:               
547:               #else
548:                   CPU_INT_DIS();
549:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
550:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
551:                   CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
552:                   CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
553:                   ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
554:                   CPU_INT_EN();
555:               #endif
556:               
557:                   return (ts);
558:               }
559:               #endif
560:               
561:               
562:               /*
563:               *********************************************************************************************************
564:               *                                           CPU_TS_Update()
565:               *
566:               * Description : Update current CPU timestamp(s).
567:               *
568:               * Argument(s) : none.
569:               *
570:               * Return(s)   : none.
571:               *
572:               * Caller(s)   : Application/BSP periodic time handler (see Note #1).
573:               *
574:               *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
575:               *               application/BSP function(s).
576:               *
577:               * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
578:               *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
579:               *
580:               *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
581:               *                       overflows; otherwise, CPU timestamp(s) will lose time.
582:               *
583:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
584:               *********************************************************************************************************
585:               */
586:               
587:               #if (CPU_CFG_TS_EN == DEF_ENABLED)
588:               void  CPU_TS_Update (void)
589:               {
590:               #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
591:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
592:                  (void)CPU_TS_Get32();
593:               #endif
594:               
595:               #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
596:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
597:                  (void)CPU_TS_Get64();
598:               #endif
599:               }
600:               #endif
601:               
602:               
603:               /*
604:               *********************************************************************************************************
605:               *                                         CPU_TS_TmrFreqGet()
606:               *
607:               * Description : Get CPU timestamp's timer frequency.
608:               *
609:               * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
610:               *
611:               *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
612:               *                                                                   returned.
613:               *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
614:               *                                                                   NOT yet configured.
615:               *
616:               * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
617:               *
618:               *               0,                                          otherwise.
619:               *
620:               * Caller(s)   : Application.
621:               *
622:               *               This function is a CPU module application programming interface (API) function & MAY be 
623:               *               called by application function(s).
624:               *
625:               * Note(s)     : none.
626:               *********************************************************************************************************
627:               */
628:               
629:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
630:               CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
631:               {
632:                   CPU_TS_TMR_FREQ  freq_hz;
633:               
634:               
635:                   if (p_err == (CPU_ERR *)0) {
636:                       CPU_SW_EXCEPTION(;);
637:                   }
638:               
639:                   freq_hz =  CPU_TS_TmrFreq_Hz;
640:                  *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
641:               
642:                   return (freq_hz);
643:               }
644:               #endif
645:               
646:               
647:               /*
648:               *********************************************************************************************************
649:               *                                         CPU_TS_TmrFreqSet()
650:               *
651:               * Description : Set CPU timestamp's timer frequency.
652:               *
653:               * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
654:               *
655:               * Return(s)   : none.
656:               *
657:               * Caller(s)   : CPU_TS_TmrInit(),
658:               *               Application/BSP initialization function(s).
659:               *
660:               *               This function is a CPU module BSP function & SHOULD be called only by appropriate
661:               *               application/BSP function(s) [see Note #1].
662:               *
663:               * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
664:               *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
665:               *                           application/BSP initialization functions.
666:               *
667:               *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
668:               *                           to convert CPU timestamps from timer counts into microseconds.
669:               *
670:               *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
671:               *
672:               *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
673:               *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
674:               *                       measure desired times.
675:               *
676:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
677:               *********************************************************************************************************
678:               */
679:               
680:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
681:               void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
682:               {
683:                   CPU_TS_TmrFreq_Hz = freq_hz;
684:               }
685:               #endif
686:               
687:               
688:               /*
689:               *********************************************************************************************************
690:               *                                     CPU_IntDisMeasMaxCurReset()
691:               *
692:               * Description : Reset current maximum interrupts disabled time.
693:               *
694:               * Argument(s) : none.
695:               *
696:               * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
697:               *
698:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
699:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
700:               *
701:               * Caller(s)   : Application.
702:               *
703:               *               This function is a CPU module application programming interface (API) function 
704:               *               & MAY be called by application function(s).
705:               *
706:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
707:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
708:               *********************************************************************************************************
709:               */
710:               
711:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
712:               CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
713:               {
714:                   CPU_TS_TMR  time_max_cnts;
715:                   CPU_SR_ALLOC();
716:               
717:               
718:                   time_max_cnts             = CPU_IntDisMeasMaxCurGet();
719:                   CPU_INT_DIS();
720:                   CPU_IntDisMeasMaxCur_cnts = 0u;
721:                   CPU_INT_EN();
722:               
723:                   return (time_max_cnts);
724:               }
725:               #endif
726:               
727:               
728:               /*
729:               *********************************************************************************************************
730:               *                                      CPU_IntDisMeasMaxCurGet()
731:               *
732:               * Description : Get current maximum interrupts disabled time.
733:               *
734:               * Argument(s) : none.
735:               *
736:               * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
737:               *
738:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
739:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
740:               *
741:               * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
742:               *               Application.
743:               *
744:               *               This function is a CPU module application programming interface (API) function 
745:               *               & MAY be called by application function(s).
746:               *
747:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
748:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
749:               *********************************************************************************************************
750:               */
751:               
752:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
753:               CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
754:               {
755:                   CPU_TS_TMR  time_tot_cnts;
756:                   CPU_TS_TMR  time_max_cnts;
757:                   CPU_SR_ALLOC();
758:               
759:               
760:                   CPU_INT_DIS();
761:                   time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
762:                   CPU_INT_EN();
763:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
764:               
765:                   return (time_max_cnts);
766:               }
767:               #endif
768:               
769:               
770:               /*
771:               *********************************************************************************************************
772:               *                                       CPU_IntDisMeasMaxGet()
773:               *
774:               * Description : Get (non-resetable) maximum interrupts disabled time.
775:               *
776:               * Argument(s) : none.
777:               *
778:               * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
779:               *
780:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
781:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
782:               *
783:               * Caller(s)   : CPU_IntDisMeasInit(),
784:               *               Application.
785:               *
786:               *               This function is a CPU module application programming interface (API) function 
787:               *               & MAY be called by application function(s).
788:               *
789:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
790:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
791:               *********************************************************************************************************
792:               */
793:               
794:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
795:               CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
796:               {
797:                   CPU_TS_TMR  time_tot_cnts;
798:                   CPU_TS_TMR  time_max_cnts;
799:                   CPU_SR_ALLOC();
800:               
801:               
802:                   CPU_INT_DIS();
803:                   time_tot_cnts = CPU_IntDisMeasMax_cnts;
804:                   CPU_INT_EN();
805:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
806:               
807:                   return (time_max_cnts);
808:               }
809:               #endif
810:               
811:               
812:               /*
813:               *********************************************************************************************************
814:               *                                        CPU_IntDisMeasStart()
815:               *
816:               * Description : Start interrupts disabled time measurement.
817:               *
818:               * Argument(s) : none.
819:               *
820:               * Return(s)   : none.
821:               *
822:               * Caller(s)   : CPU_CRITICAL_ENTER().
823:               *
824:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
825:               *               function(s).
826:               *
827:               * Note(s)     : none.
828:               *********************************************************************************************************
829:               */
830:               
831:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
832:               void  CPU_IntDisMeasStart (void)
833:               {
834:                   CPU_IntDisMeasCtr++;
835:                   if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
836:                       CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
837:                   }
838:                   CPU_IntDisNestCtr++;
839:               }
840:               #endif
841:               
842:               
843:               /*
844:               *********************************************************************************************************
845:               *                                        CPU_IntDisMeasStop()
846:               *
847:               * Description : Stop interrupts disabled time measurement.
848:               *
849:               * Argument(s) : none.
850:               *
851:               * Return(s)   : none.
852:               *
853:               * Caller(s)   : CPU_CRITICAL_EXIT().
854:               *
855:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
856:               *               function(s).
857:               *
858:               * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
859:               *                       during critical sections is calculated by the following equations :
860:               *
861:               *                       (1) When interrupts disabled time measurements are disabled :
862:               *
863:               *
864:               *                               |   CRITICAL  |                           |   CRITICAL  |
865:               *                               |<- SECTION ->|                           |<- SECTION ->|
866:               *                               |    ENTER    |                           |    EXIT     |
867:               *
868:               *                            Disable                                    Enable
869:               *                           Interrupts                                Interrupts
870:               *
871:               *                               ||           ||                           ||           ||
872:               *                               ||           ||                           ||           ||
873:               *                               ||       |   ||<------------------------->||       |   ||
874:               *                               ||       |<->||             |             ||<----->|   ||
875:               *                               ||       | | ||             |             ||   |   |   ||
876:               *                                        | |                |                  |   |
877:               *                                   interrupts            time                 interrupts
878:               *                                    disabled                 interrupts       |enabled
879:               *                                          |                   disabled        |
880:               *                                          |              (via application)    |
881:               *                                       time                                 time
882:               *                                           interrupts                           interrupts
883:               *                                         disabled ovrhd                        enabled ovrhd
884:               *
885:               *
886:               *                           (A) time            =  [ time            -  time           ]  -  time
887:               *                                   interrupts     [     interrupts         interrupts ]         total
888:               *                                    disabled      [      enabled            disabled  ]         ovrhd
889:               *                               (via application)
890:               *
891:               *
892:               *                           (B) time       =  time              +  time
893:               *                                   total         interrupts           interrupts
894:               *                                   ovrhd        enabled ovrhd       disabled ovrhd
895:               *
896:               *
897:               *                                   where
898:               *
899:               *                                           time                    time interrupts are disabled between
900:               *                                               interrupts              first critical section enter &
901:               *                                                disabled               last  critical section exit (i.e.
902:               *                                           (via application)           minus total overhead time)
903:               *
904:               *                                           time                    time when interrupts are disabled
905:               *                                               interrupts
906:               *                                                disabled
907:               *
908:               *                                           time                    time when interrupts are  enabled
909:               *                                               interrupts
910:               *                                                enabled
911:               *
912:               *
913:               *                                           time                    total overhead time to disable/enable
914:               *                                               total                   interrupts during critical section
915:               *                                               ovrhd                   enter & exit
916:               *
917:               *                                           time                    total overhead time to disable interrupts
918:               *                                               interrupts              during critical section enter
919:               *                                             disabled ovrhd
920:               *
921:               *                                           time                    total overhead time to enable  interrupts
922:               *                                               interrupts              during critical section exit
923:               *                                              enabled ovrhd
924:               *
925:               *
926:               *                       (2) When interrupts disabled time measurements are enabled :
927:               *
928:               *
929:               *        |                                    |                           |                                       |
930:               *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
931:               *        |                                    |                           |                                       |
932:               *
933:               *                   Time                                                 Time
934:               *     Disable    Measurement                                          Measurement                  Enable
935:               *    Interrupts     Start                                                Stop                    Interrupts
936:               *
937:               *        ||           |                      ||                           ||                         |           ||
938:               *        ||           |                      ||                           ||                         |           ||
939:               *        ||           |        |             ||<------------------------->||               |         |           ||
940:               *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
941:               *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
942:               *                 |            |      |                     |                      |       |                 |
943:               *            interrupts       get     |                   time                     |      get            interrupts
944:               *             disabled    start time  |                       interrupts           |   stop time          enabled
945:               *                            meas     |                        disabled            |     meas
946:               *                                   time                  (via application)      time
947:               *                                       start meas                                   stop meas
948:               *                                         ovrhd                                        ovrhd
949:               *
950:               *
951:               *                           (A) time            =  [ time       -  time      ]  -  time
952:               *                                   interrupts     [      stop         start ]         total meas
953:               *                                    disabled      [      meas         meas  ]           ovrhd
954:               *                               (via application)
955:               *
956:               *
957:               *                           (B) time            =  time            +  time
958:               *                                   total meas         start meas         stop meas
959:               *                                     ovrhd              ovrhd              ovrhd
960:               *
961:               *
962:               *                                   where
963:               *
964:               *                                           time                    time interrupts are disabled between first
965:               *                                               interrupts              critical section enter & last critical
966:               *                                                disabled               section exit (i.e. minus measurement
967:               *                                           (via application)           overhead time; however, this does NOT
968:               *                                                                       include any overhead time to disable
969:               *                                                                       or enable interrupts during critical
970:               *                                                                       section enter & exit)
971:               *
972:               *                                           time                    time of disable interrupts start time
973:               *                                               start                   measurement (in timer counts)
974:               *                                               meas
975:               *
976:               *                                           time                    time of disable interrupts stop  time
977:               *                                               stop                    measurement (in timer counts)
978:               *                                               meas
979:               *
980:               *
981:               *                                           time                    total overhead time to start/stop disabled
982:               *                                               total meas              interrupts time measurements (in timer
983:               *                                                 ovrhd                 counts)
984:               *
985:               *                                           time                    total overhead time after getting start
986:               *                                               start meas              time until end of start measurement
987:               *                                                 ovrhd                 function  (in timer counts)
988:               *
989:               *                                           time                    total overhead time from beginning of stop
990:               *                                               stop meas               measurement function until after getting
991:               *                                                 ovrhd                 stop time (in timer counts)
992:               *
993:               *
994:               *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times 
995:               *                               from stop times, CPU timestamp timer count values MUST be returned via 
996:               *                               word-size-configurable 'CPU_TS_TMR' data type.
997:               *
998:               *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
999:               *
1000:              *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
1001:              *                               values, timestamp timer count values MUST increase with each time count.
1002:              *
1003:              *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
1004:              *
1005:              *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
1006:              *                               subtraction of start times from stop times is performed.
1007:              *
1008:              *                           (B) The final calculations to subtract the interrupts disabled time measurement
1009:              *                               overhead is performed asynchronously in appropriate API functions.
1010:              *
1011:              *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
1012:              *********************************************************************************************************
1013:              */
1014:              
1015:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
1016:              void  CPU_IntDisMeasStop (void)
1017:              {
1018:                  CPU_TS_TMR  time_ints_disd_cnts;
1019:              
1020:              
1021:                  CPU_IntDisNestCtr--;
1022:                  if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
1023:                      CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
1024:                                                                                  /* ... calc ints dis'd tot  time (see Note #1b2A).  */
1025:                      time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
1026:                                                CPU_IntDisMeasStart_cnts;
1027:                                                                                  /* Calc max ints dis'd times.                       */
1028:                      if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
1029:                          CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
1030:                      }
1031:                      if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
1032:                          CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
1033:                      }
1034:                  }
1035:              }
1036:              #endif
1037:              
1038:              
1039:              /*
1040:              *********************************************************************************************************
1041:              *                                         CPU_CntLeadZeros()
1042:              *
1043:              * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
1044:              *
1045:              * Argument(s) : val         Data value to count leading zero bits.
1046:              *
1047:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
1048:              *
1049:              *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
1050:              *
1051:              * Caller(s)   : CPU_CntTrailZeros(),
1052:              *               Application.
1053:              *
1054:              *               This function is a CPU module application programming interface (API) function & MAY 
1055:              *               be called by application function(s).
1056:              *
1057:              * Note(s)     : (1) (a) Supports the following data value sizes :
1058:              *
1059:              *                       (1)  8-bits
1060:              *                       (2) 16-bits
1061:              *                       (3) 32-bits
1062:              *                       (4) 64-bits
1063:              *
1064:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1065:              *
1066:              *                   (b) (1) For  8-bit values :
1067:              *
1068:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1069:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1070:              *                                   1    x    x    x    x    x    x    x            0
1071:              *                                   0    1    x    x    x    x    x    x            1
1072:              *                                   0    0    1    x    x    x    x    x            2
1073:              *                                   0    0    0    1    x    x    x    x            3
1074:              *                                   0    0    0    0    1    x    x    x            4
1075:              *                                   0    0    0    0    0    1    x    x            5
1076:              *                                   0    0    0    0    0    0    1    x            6
1077:              *                                   0    0    0    0    0    0    0    1            7
1078:              *                                   0    0    0    0    0    0    0    0            8
1079:              *
1080:              *
1081:              *                       (2) For 16-bit values :
1082:              *
1083:              *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1084:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1085:              *                              1    x    x         x    x    x    x    x            0
1086:              *                              0    1    x         x    x    x    x    x            1
1087:              *                              0    0    1         x    x    x    x    x            2
1088:              *                              :    :    :         :    :    :    :    :            :
1089:              *                              :    :    :         :    :    :    :    :            :
1090:              *                              0    0    0         1    x    x    x    x           11
1091:              *                              0    0    0         0    1    x    x    x           12
1092:              *                              0    0    0         0    0    1    x    x           13
1093:              *                              0    0    0         0    0    0    1    x           14
1094:              *                              0    0    0         0    0    0    0    1           15
1095:              *                              0    0    0         0    0    0    0    0           16
1096:              *
1097:              *                       (3) For 32-bit values :
1098:              *
1099:              *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1100:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1101:              *                              1    x    x         x    x    x    x    x            0
1102:              *                              0    1    x         x    x    x    x    x            1
1103:              *                              0    0    1         x    x    x    x    x            2
1104:              *                              :    :    :         :    :    :    :    :            :
1105:              *                              :    :    :         :    :    :    :    :            :
1106:              *                              0    0    0         1    x    x    x    x           27
1107:              *                              0    0    0         0    1    x    x    x           28
1108:              *                              0    0    0         0    0    1    x    x           29
1109:              *                              0    0    0         0    0    0    1    x           30
1110:              *                              0    0    0         0    0    0    0    1           31
1111:              *                              0    0    0         0    0    0    0    0           32
1112:              *
1113:              *
1114:              *                       (4) For 64-bit values :
1115:              *
1116:              *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1117:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1118:              *                              1    x    x         x    x    x    x    x            0
1119:              *                              0    1    x         x    x    x    x    x            1
1120:              *                              0    0    1         x    x    x    x    x            2
1121:              *                              :    :    :         :    :    :    :    :            :
1122:              *                              :    :    :         :    :    :    :    :            :
1123:              *                              0    0    0         1    x    x    x    x           59
1124:              *                              0    0    0         0    1    x    x    x           60
1125:              *                              0    0    0         0    0    1    x    x           61
1126:              *                              0    0    0         0    0    0    1    x           62
1127:              *                              0    0    0         0    0    0    0    1           63
1128:              *                              0    0    0         0    0    0    0    0           64
1129:              *
1130:              *
1131:              *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1132:              *********************************************************************************************************
1133:              */
1134:              
1135:              #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
1136:              CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
1137:              {
005E4E  FA0004     LNK #0x4
005E50  980710     MOV W0, [W14+2]
1138:                  CPU_DATA  nbr_lead_zeros;
1139:              
1140:              
1141:              #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
1142:                  nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
1143:              
1144:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
1145:                  nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
005E52  90001E     MOV [W14+2], W0
005E54  070011     RCALL CPU_CntLeadZeros16
005E56  780F00     MOV W0, [W14]
1146:              
1147:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
1148:                  nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
1149:              
1150:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
1151:                  nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
1152:              
1153:              #else                                                           /* See Note #1a.                                        */
1154:                  nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
1155:              #endif
1156:              
1157:              
1158:                  return (nbr_lead_zeros);
005E58  78001E     MOV [W14], W0
1159:              }
005E5A  FA8000     ULNK
005E5C  060000     RETURN
1160:              #endif
1161:              
1162:              
1163:              /*
1164:              *********************************************************************************************************
1165:              *                                        CPU_CntLeadZeros08()
1166:              *
1167:              * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
1168:              *
1169:              * Argument(s) : val         Data value to count leading zero bits.
1170:              *
1171:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1172:              *
1173:              * Caller(s)   : CPU_CntLeadZeros(),
1174:              *               CPU_CntTrailZeros08(),
1175:              *               Application.
1176:              *
1177:              *               This function is a CPU module application programming interface (API) function & MAY be 
1178:              *               called by application function(s).
1179:              *
1180:              * Note(s)     : (1) Supports  8-bit values :
1181:              *
1182:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1183:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1184:              *                                1    x    x    x    x    x    x    x            0
1185:              *                                0    1    x    x    x    x    x    x            1
1186:              *                                0    0    1    x    x    x    x    x            2
1187:              *                                0    0    0    1    x    x    x    x            3
1188:              *                                0    0    0    0    1    x    x    x            4
1189:              *                                0    0    0    0    0    1    x    x            5
1190:              *                                0    0    0    0    0    0    1    x            6
1191:              *                                0    0    0    0    0    0    0    1            7
1192:              *                                0    0    0    0    0    0    0    0            8
1193:              *
1194:              *
1195:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1196:              *********************************************************************************************************
1197:              */
1198:              
1199:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1200:              CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
1201:              {
005E5E  FA0006     LNK #0x6
005E60  984740     MOV.B W0, [W14+4]
1202:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1203:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1204:                  CPU_DATA  ix;
1205:              #endif
1206:                  CPU_DATA  nbr_lead_zeros;
1207:              
1208:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1209:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1210:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1211:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1212:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1213:              
1214:              
1215:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1216:                                                                                              /* Chk bits [07:00] :                   */
1217:                                                                                              /* .. Nbr lead zeros =               .. */
1218:                  ix              = (CPU_DATA)(val);                                          /* .. lookup tbl ix  = 'val' >>  0 bits */
005E62  90404E     MOV.B [W14+4], W0
005E64  FB8000     ZE W0, W0
005E66  780F00     MOV W0, [W14]
1219:                  nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                      /* .. plus nbr msb lead zeros =  0 bits.*/
005E68  2866A0     MOV #0x866A, W0
005E6A  40001E     ADD W0, [W14], W0
005E6C  784010     MOV.B [W0], W0
005E6E  FB8000     ZE W0, W0
005E70  980710     MOV W0, [W14+2]
1220:              #endif
1221:              
1222:              
1223:                  return (nbr_lead_zeros);
005E72  90001E     MOV [W14+2], W0
1224:              }
005E74  FA8000     ULNK
005E76  060000     RETURN
1225:              #endif
1226:              
1227:              
1228:              /*
1229:              *********************************************************************************************************
1230:              *                                        CPU_CntLeadZeros16()
1231:              *
1232:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
1233:              *
1234:              * Argument(s) : val         Data value to count leading zero bits.
1235:              *
1236:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1237:              *
1238:              * Caller(s)   : CPU_CntLeadZeros(),
1239:              *               CPU_CntTrailZeros16(),
1240:              *               Application.
1241:              *
1242:              *               This function is a CPU module application programming interface (API) function & MAY be 
1243:              *               called by application function(s).
1244:              *
1245:              * Note(s)     : (1) Supports 16-bit values :
1246:              *
1247:              *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1248:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1249:              *                           1    x    x         x    x    x    x    x            0
1250:              *                           0    1    x         x    x    x    x    x            1
1251:              *                           0    0    1         x    x    x    x    x            2
1252:              *                           :    :    :         :    :    :    :    :            :
1253:              *                           :    :    :         :    :    :    :    :            :
1254:              *                           0    0    0         1    x    x    x    x           11
1255:              *                           0    0    0         0    1    x    x    x           12
1256:              *                           0    0    0         0    0    1    x    x           13
1257:              *                           0    0    0         0    0    0    1    x           14
1258:              *                           0    0    0         0    0    0    0    1           15
1259:              *                           0    0    0         0    0    0    0    0           16
1260:              *
1261:              *
1262:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1263:              *********************************************************************************************************
1264:              */
1265:              
1266:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1267:              CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
1268:              {
005E78  FA0006     LNK #0x6
005E7A  980720     MOV W0, [W14+4]
1269:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1270:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1271:                  CPU_DATA  ix;
1272:              #endif
1273:                  CPU_DATA  nbr_lead_zeros;
1274:              
1275:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1276:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1277:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1278:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1279:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1280:              
1281:              
1282:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1283:                  if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
005E7C  9000AE     MOV [W14+4], W1
005E7E  200FF0     MOV #0xFF, W0
005E80  508F80     SUB W1, W0, [W15]
005E82  36000A     BRA LEU, 0x5E98
1284:                                                                                              /* .. Nbr lead zeros =               .. */
1285:                      ix             = (CPU_DATA)((CPU_DATA)val >> 8u);                       /* .. lookup tbl ix  = 'val' >>  8 bits */
005E84  90002E     MOV [W14+4], W0
005E86  DE0048     LSR W0, #8, W0
005E88  980710     MOV W0, [W14+2]
1286:                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                   /* .. plus nbr msb lead zeros =  0 bits.*/
005E8A  2866A1     MOV #0x866A, W1
005E8C  90001E     MOV [W14+2], W0
005E8E  408000     ADD W1, W0, W0
005E90  784010     MOV.B [W0], W0
005E92  FB8000     ZE W0, W0
005E94  780F00     MOV W0, [W14]
005E96  370008     BRA 0x5EA8
1287:              
1288:                  } else {                                                                    /* Chk bits [07:00] :                   */
1289:                                                                                              /* .. Nbr lead zeros =               .. */
1290:                      ix             = (CPU_DATA)(val);                                       /* .. lookup tbl ix  = 'val' >>  0 bits */
005E98  9000AE     MOV [W14+4], W1
005E9A  980711     MOV W1, [W14+2]
1291:                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);   /* .. plus nbr msb lead zeros =  8 bits.*/
005E9C  2866A1     MOV #0x866A, W1
005E9E  90001E     MOV [W14+2], W0
005EA0  408000     ADD W1, W0, W0
005EA2  784010     MOV.B [W0], W0
005EA4  FB8000     ZE W0, W0
005EA6  400F68     ADD W0, #0x8, [W14]
1292:                  }
1293:              #endif
1294:              
1295:              
1296:                  return (nbr_lead_zeros);
005EA8  78001E     MOV [W14], W0
1297:              }
005EAA  FA8000     ULNK
005EAC  060000     RETURN
1298:              #endif
1299:              
1300:              
1301:              /*
1302:              *********************************************************************************************************
1303:              *                                        CPU_CntLeadZeros32()
1304:              *
1305:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
1306:              *
1307:              * Argument(s) : val         Data value to count leading zero bits.
1308:              *
1309:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1310:              *
1311:              * Caller(s)   : CPU_CntLeadZeros(),
1312:              *               CPU_CntTrailZeros32(),
1313:              *               Application.
1314:              *
1315:              *               This function is a CPU module application programming interface (API) function & MAY be 
1316:              *               called by application function(s).
1317:              *
1318:              * Note(s)     : (1) Supports 32-bit values :
1319:              *
1320:              *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1321:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1322:              *                           1    x    x         x    x    x    x    x            0
1323:              *                           0    1    x         x    x    x    x    x            1
1324:              *                           0    0    1         x    x    x    x    x            2
1325:              *                           :    :    :         :    :    :    :    :            :
1326:              *                           :    :    :         :    :    :    :    :            :
1327:              *                           0    0    0         1    x    x    x    x           27
1328:              *                           0    0    0         0    1    x    x    x           28
1329:              *                           0    0    0         0    0    1    x    x           29
1330:              *                           0    0    0         0    0    0    1    x           30
1331:              *                           0    0    0         0    0    0    0    1           31
1332:              *                           0    0    0         0    0    0    0    0           32
1333:              *
1334:              *
1335:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1336:              *********************************************************************************************************
1337:              */
1338:              
1339:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1340:              CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
1341:              {
005EAE  FA0008     LNK #0x8
005EB0  980720     MOV W0, [W14+4]
005EB2  980731     MOV W1, [W14+6]
1342:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1343:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1344:                  CPU_DATA  ix;
1345:              #endif
1346:                  CPU_DATA  nbr_lead_zeros;
1347:              
1348:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1349:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1350:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1351:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1352:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1353:              
1354:              
1355:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1356:                  if (val > 0x0000FFFFu) {
005EB4  90012E     MOV [W14+4], W2
005EB6  9001BE     MOV [W14+6], W3
005EB8  2FFFF0     MOV #0xFFFF, W0
005EBA  200001     MOV #0x0, W1
005EBC  510F80     SUB W2, W0, [W15]
005EBE  598F81     SUBB W3, W1, [W15]
005EC0  36001D     BRA LEU, 0x5EFC
1357:                      if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
005EC2  90012E     MOV [W14+4], W2
005EC4  9001BE     MOV [W14+6], W3
005EC6  2FFFF0     MOV #0xFFFF, W0
005EC8  200FF1     MOV #0xFF, W1
005ECA  510F80     SUB W2, W0, [W15]
005ECC  598F81     SUBB W3, W1, [W15]
005ECE  36000B     BRA LEU, 0x5EE6
1358:                                                                                              /* .. Nbr lead zeros =               .. */
1359:                          ix             = (CPU_DATA)(val >> 24u);                  /* .. lookup tbl ix  = 'val' >> 24 bits */
005ED0  90002E     MOV [W14+4], W0
005ED2  9000BE     MOV [W14+6], W1
005ED4  DE0848     LSR W1, #8, W0
005ED6  980710     MOV W0, [W14+2]
1360:                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);               /* .. plus nbr msb lead zeros =  0 bits.*/
005ED8  2866A1     MOV #0x866A, W1
005EDA  90001E     MOV [W14+2], W0
005EDC  408000     ADD W1, W0, W0
005EDE  784010     MOV.B [W0], W0
005EE0  FB8000     ZE W0, W0
005EE2  780F00     MOV W0, [W14]
005EE4  370024     BRA 0x5F2E
1361:              
1362:                      } else {                                                                /* Chk bits [23:16] :                   */
1363:                                                                                              /* .. Nbr lead zeros =               .. */
1364:                          ix             = (CPU_DATA)(val >> 16u);                  /* .. lookup tbl ix  = 'val' >> 16 bits */
005EE6  90002E     MOV [W14+4], W0
005EE8  9000BE     MOV [W14+6], W1
005EEA  DE0840     LSR W1, #0, W0
005EEC  980710     MOV W0, [W14+2]
1365:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
005EEE  2866A1     MOV #0x866A, W1
005EF0  90001E     MOV [W14+2], W0
005EF2  408000     ADD W1, W0, W0
005EF4  784010     MOV.B [W0], W0
005EF6  FB8000     ZE W0, W0
005EF8  400F68     ADD W0, #0x8, [W14]
005EFA  370019     BRA 0x5F2E
1366:                      }
1367:              
1368:                  } else {
1369:                      if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
005EFC  90012E     MOV [W14+4], W2
005EFE  9001BE     MOV [W14+6], W3
005F00  200FF0     MOV #0xFF, W0
005F02  200001     MOV #0x0, W1
005F04  510F80     SUB W2, W0, [W15]
005F06  598F81     SUBB W3, W1, [W15]
005F08  36000A     BRA LEU, 0x5F1E
1370:                                                                                              /* .. Nbr lead zeros =               .. */
1371:                          ix             = (CPU_DATA)((CPU_DATA)val >>  8u);                  /* .. lookup tbl ix  = 'val' >>  8 bits */
005F0A  90002E     MOV [W14+4], W0
005F0C  DE0048     LSR W0, #8, W0
005F0E  980710     MOV W0, [W14+2]
1372:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
005F10  2866A1     MOV #0x866A, W1
005F12  90001E     MOV [W14+2], W0
005F14  408000     ADD W1, W0, W0
005F16  784010     MOV.B [W0], W0
005F18  FB8000     ZE W0, W0
005F1A  400F70     ADD W0, #0x10, [W14]
005F1C  370008     BRA 0x5F2E
1373:              
1374:                      } else {                                                                /* Chk bits [07:00] :                   */
1375:                                                                                              /* .. Nbr lead zeros =               .. */
1376:                          ix             = (CPU_DATA)((CPU_DATA)val >>  0u);                  /* .. lookup tbl ix  = 'val' >>  0 bits */
005F1E  9000AE     MOV [W14+4], W1
005F20  980711     MOV W1, [W14+2]
1377:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
005F22  2866A1     MOV #0x866A, W1
005F24  90001E     MOV [W14+2], W0
005F26  408000     ADD W1, W0, W0
005F28  784010     MOV.B [W0], W0
005F2A  FB8000     ZE W0, W0
005F2C  400F78     ADD W0, #0x18, [W14]
1378:                      }
1379:                  }
1380:              #endif
1381:              
1382:              
1383:                  return (nbr_lead_zeros);
005F2E  78001E     MOV [W14], W0
1384:              }
005F30  FA8000     ULNK
005F32  060000     RETURN
1385:              #endif
1386:              
1387:              
1388:              /*
1389:              *********************************************************************************************************
1390:              *                                        CPU_CntLeadZeros64()
1391:              *
1392:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
1393:              *
1394:              * Argument(s) : val         Data value to count leading zero bits.
1395:              *
1396:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1397:              *
1398:              * Caller(s)   : CPU_CntLeadZeros(),
1399:              *               CPU_CntTrailZeros64(),
1400:              *               Application.
1401:              *
1402:              *               This function is a CPU module application programming interface (API) function & MAY be 
1403:              *               called by application function(s).
1404:              *
1405:              * Note(s)     : (1) Supports 64-bit values :
1406:              *
1407:              *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1408:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1409:              *                           1    x    x         x    x    x    x    x            0
1410:              *                           0    1    x         x    x    x    x    x            1
1411:              *                           0    0    1         x    x    x    x    x            2
1412:              *                           :    :    :         :    :    :    :    :            :
1413:              *                           :    :    :         :    :    :    :    :            :
1414:              *                           0    0    0         1    x    x    x    x           59
1415:              *                           0    0    0         0    1    x    x    x           60
1416:              *                           0    0    0         0    0    1    x    x           61
1417:              *                           0    0    0         0    0    0    1    x           62
1418:              *                           0    0    0         0    0    0    0    1           63
1419:              *                           0    0    0         0    0    0    0    0           64
1420:              *
1421:              *
1422:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1423:              *********************************************************************************************************
1424:              */
1425:              
1426:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
1427:              CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
1428:              {
005F34  FA000C     LNK #0xC
005F36  980720     MOV W0, [W14+4]
005F38  980731     MOV W1, [W14+6]
005F3A  980742     MOV W2, [W14+8]
005F3C  980753     MOV W3, [W14+10]
1429:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1430:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
1431:                  CPU_DATA  ix;
1432:              #endif
1433:                  CPU_DATA  nbr_lead_zeros;
1434:              
1435:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1436:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1437:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
1438:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1439:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1440:              
1441:              
1442:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1443:                  if (val > 0x00000000FFFFFFFFu) {
005F3E  90022E     MOV [W14+4], W4
005F40  9002BE     MOV [W14+6], W5
005F42  90034E     MOV [W14+8], W6
005F44  9003DE     MOV [W14+10], W7
005F46  2FFFF0     MOV #0xFFFF, W0
005F48  2FFFF1     MOV #0xFFFF, W1
005F4A  B81160     MUL.UU W2, #0, W2
005F4C  E12000     CP W4, W0
005F4E  E1A801     CPB W5, W1
005F50  E1B002     CPB W6, W2
005F52  E1B803     CPB W7, W3
005F54  36005D     BRA LEU, 0x6010
1444:                      if (val > 0x0000FFFFFFFFFFFFu) {
005F56  90022E     MOV [W14+4], W4
005F58  9002BE     MOV [W14+6], W5
005F5A  90034E     MOV [W14+8], W6
005F5C  9003DE     MOV [W14+10], W7
005F5E  2FFFF0     MOV #0xFFFF, W0
005F60  2FFFF1     MOV #0xFFFF, W1
005F62  2FFFF2     MOV #0xFFFF, W2
005F64  200003     MOV #0x0, W3
005F66  E12000     CP W4, W0
005F68  E1A801     CPB W5, W1
005F6A  E1B002     CPB W6, W2
005F6C  E1B803     CPB W7, W3
005F6E  360027     BRA LEU, 0x5FBE
1445:                          if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
005F70  90022E     MOV [W14+4], W4
005F72  9002BE     MOV [W14+6], W5
005F74  90034E     MOV [W14+8], W6
005F76  9003DE     MOV [W14+10], W7
005F78  2FFFF0     MOV #0xFFFF, W0
005F7A  2FFFF1     MOV #0xFFFF, W1
005F7C  2FFFF2     MOV #0xFFFF, W2
005F7E  200FF3     MOV #0xFF, W3
005F80  E12000     CP W4, W0
005F82  E1A801     CPB W5, W1
005F84  E1B002     CPB W6, W2
005F86  E1B803     CPB W7, W3
005F88  36000D     BRA LEU, 0x5FA4
1446:                                                                                              /* .. Nbr lead zeros =               .. */
1447:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 56u);            /* .. lookup tbl ix  = 'val' >> 56 bits */
005F8A  90002E     MOV [W14+4], W0
005F8C  9000BE     MOV [W14+6], W1
005F8E  90014E     MOV [W14+8], W2
005F90  9001DE     MOV [W14+10], W3
005F92  DE1848     LSR W3, #8, W0
005F94  980710     MOV W0, [W14+2]
1448:                              nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);           /* .. plus nbr msb lead zeros =  0 bits.*/
005F96  2866A1     MOV #0x866A, W1
005F98  90001E     MOV [W14+2], W0
005F9A  408000     ADD W1, W0, W0
005F9C  784010     MOV.B [W0], W0
005F9E  FB8000     ZE W0, W0
005FA0  780F00     MOV W0, [W14]
005FA2  370091     BRA 0x60C6
1449:              
1450:                          } else {                                                            /* Chk bits [55:48] :                   */
1451:                                                                                              /* .. Nbr lead zeros =               .. */
1452:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 48u);            /* .. lookup tbl ix  = 'val' >> 48 bits */
005FA4  90002E     MOV [W14+4], W0
005FA6  9000BE     MOV [W14+6], W1
005FA8  90014E     MOV [W14+8], W2
005FAA  9001DE     MOV [W14+10], W3
005FAC  780003     MOV W3, W0
005FAE  980710     MOV W0, [W14+2]
1453:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
005FB0  2866A1     MOV #0x866A, W1
005FB2  90001E     MOV [W14+2], W0
005FB4  408000     ADD W1, W0, W0
005FB6  784010     MOV.B [W0], W0
005FB8  FB8000     ZE W0, W0
005FBA  400F68     ADD W0, #0x8, [W14]
005FBC  370084     BRA 0x60C6
1454:                          }
1455:              
1456:                      } else {
1457:                          if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
005FBE  90022E     MOV [W14+4], W4
005FC0  9002BE     MOV [W14+6], W5
005FC2  90034E     MOV [W14+8], W6
005FC4  9003DE     MOV [W14+10], W7
005FC6  2FFFF0     MOV #0xFFFF, W0
005FC8  2FFFF1     MOV #0xFFFF, W1
005FCA  200FF2     MOV #0xFF, W2
005FCC  200003     MOV #0x0, W3
005FCE  E12000     CP W4, W0
005FD0  E1A801     CPB W5, W1
005FD2  E1B002     CPB W6, W2
005FD4  E1B803     CPB W7, W3
005FD6  36000F     BRA LEU, 0x5FF6
1458:                                                                                              /* .. Nbr lead zeros =               .. */
1459:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 40u);            /* .. lookup tbl ix  = 'val' >> 40 bits */
005FD8  90002E     MOV [W14+4], W0
005FDA  9000BE     MOV [W14+6], W1
005FDC  90014E     MOV [W14+8], W2
005FDE  9001DE     MOV [W14+10], W3
005FE0  DE1048     LSR W2, #8, W0
005FE2  DD1A48     SL W3, #8, W4
005FE4  720000     IOR W4, W0, W0
005FE6  980710     MOV W0, [W14+2]
1460:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
005FE8  2866A1     MOV #0x866A, W1
005FEA  90001E     MOV [W14+2], W0
005FEC  408000     ADD W1, W0, W0
005FEE  784010     MOV.B [W0], W0
005FF0  FB8000     ZE W0, W0
005FF2  400F70     ADD W0, #0x10, [W14]
005FF4  370068     BRA 0x60C6
1461:              
1462:                          } else {                                                            /* Chk bits [39:32] :                   */
1463:                                                                                              /* .. Nbr lead zeros =               .. */
1464:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 32u);            /* .. lookup tbl ix  = 'val' >> 32 bits */
005FF6  90002E     MOV [W14+4], W0
005FF8  9000BE     MOV [W14+6], W1
005FFA  90014E     MOV [W14+8], W2
005FFC  9001DE     MOV [W14+10], W3
005FFE  780002     MOV W2, W0
006000  980710     MOV W0, [W14+2]
1465:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
006002  2866A1     MOV #0x866A, W1
006004  90001E     MOV [W14+2], W0
006006  408000     ADD W1, W0, W0
006008  784010     MOV.B [W0], W0
00600A  FB8000     ZE W0, W0
00600C  400F78     ADD W0, #0x18, [W14]
00600E  37005B     BRA 0x60C6
1466:                          }
1467:                      }
1468:              
1469:                  } else {
1470:                      if (val > 0x000000000000FFFFu) {
006010  90022E     MOV [W14+4], W4
006012  9002BE     MOV [W14+6], W5
006014  90034E     MOV [W14+8], W6
006016  9003DE     MOV [W14+10], W7
006018  2FFFF0     MOV #0xFFFF, W0
00601A  200001     MOV #0x0, W1
00601C  B81160     MUL.UU W2, #0, W2
00601E  E12000     CP W4, W0
006020  E1A801     CPB W5, W1
006022  E1B002     CPB W6, W2
006024  E1B803     CPB W7, W3
006026  36002A     BRA LEU, 0x607C
1471:                          if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
006028  90022E     MOV [W14+4], W4
00602A  9002BE     MOV [W14+6], W5
00602C  90034E     MOV [W14+8], W6
00602E  9003DE     MOV [W14+10], W7
006030  2FFFF0     MOV #0xFFFF, W0
006032  200FF1     MOV #0xFF, W1
006034  B81160     MUL.UU W2, #0, W2
006036  E12000     CP W4, W0
006038  E1A801     CPB W5, W1
00603A  E1B002     CPB W6, W2
00603C  E1B803     CPB W7, W3
00603E  360010     BRA LEU, 0x6060
1472:                                                                                              /* .. Nbr lead zeros =               .. */
1473:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 24u);              /* .. lookup tbl ix  = 'val' >> 24 bits */
006040  90002E     MOV [W14+4], W0
006042  9000BE     MOV [W14+6], W1
006044  90014E     MOV [W14+8], W2
006046  9001DE     MOV [W14+10], W3
006048  DE0848     LSR W1, #8, W0
00604A  DD1248     SL W2, #8, W4
00604C  720000     IOR W4, W0, W0
00604E  980710     MOV W0, [W14+2]
1474:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);/* .. plus nbr msb lead zeros = 32 bits.*/
006050  2866A1     MOV #0x866A, W1
006052  90001E     MOV [W14+2], W0
006054  408000     ADD W1, W0, W0
006056  784010     MOV.B [W0], W0
006058  FB8000     ZE W0, W0
00605A  200201     MOV #0x20, W1
00605C  400F01     ADD W0, W1, [W14]
00605E  370033     BRA 0x60C6
1475:              
1476:                          } else {                                                            /* Chk bits [23:16] :                   */
1477:                                                                                              /* .. Nbr lead zeros =               .. */
1478:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 16u);            /* .. lookup tbl ix  = 'val' >> 16 bits */
006060  90002E     MOV [W14+4], W0
006062  9000BE     MOV [W14+6], W1
006064  90014E     MOV [W14+8], W2
006066  9001DE     MOV [W14+10], W3
006068  780001     MOV W1, W0
00606A  980710     MOV W0, [W14+2]
1479:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);/* .. plus nbr msb lead zeros = 40 bits.*/
00606C  2866A1     MOV #0x866A, W1
00606E  90001E     MOV [W14+2], W0
006070  408000     ADD W1, W0, W0
006072  784010     MOV.B [W0], W0
006074  FB8000     ZE W0, W0
006076  200281     MOV #0x28, W1
006078  400F01     ADD W0, W1, [W14]
00607A  370025     BRA 0x60C6
1480:                          }
1481:              
1482:                      } else {
1483:                          if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
00607C  90022E     MOV [W14+4], W4
00607E  9002BE     MOV [W14+6], W5
006080  90034E     MOV [W14+8], W6
006082  9003DE     MOV [W14+10], W7
006084  200FF0     MOV #0xFF, W0
006086  200001     MOV #0x0, W1
006088  B81160     MUL.UU W2, #0, W2
00608A  E12000     CP W4, W0
00608C  E1A801     CPB W5, W1
00608E  E1B002     CPB W6, W2
006090  E1B803     CPB W7, W3
006092  360010     BRA LEU, 0x60B4
1484:                                                                                              /* .. Nbr lead zeros =               .. */
1485:                              ix             = (CPU_DATA)((CPU_INT64U)val >>  8u);            /* .. lookup tbl ix  = 'val' >>  8 bits */
006094  90002E     MOV [W14+4], W0
006096  9000BE     MOV [W14+6], W1
006098  90014E     MOV [W14+8], W2
00609A  9001DE     MOV [W14+10], W3
00609C  DE0048     LSR W0, #8, W0
00609E  DD0A48     SL W1, #8, W4
0060A0  720000     IOR W4, W0, W0
0060A2  980710     MOV W0, [W14+2]
1486:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);/* .. plus nbr msb lead zeros = 48 bits.*/
0060A4  2866A1     MOV #0x866A, W1
0060A6  90001E     MOV [W14+2], W0
0060A8  408000     ADD W1, W0, W0
0060AA  784010     MOV.B [W0], W0
0060AC  FB8000     ZE W0, W0
0060AE  200301     MOV #0x30, W1
0060B0  400F01     ADD W0, W1, [W14]
0060B2  370009     BRA 0x60C6
1487:              
1488:                          } else {                                                            /* Chk bits [07:00] :                   */
1489:                                                                                              /* .. Nbr lead zeros =               .. */
1490:                              ix             = (CPU_DATA)(val);                               /* .. lookup tbl ix  = 'val' >>  0 bits */
0060B4  90022E     MOV [W14+4], W4
0060B6  980714     MOV W4, [W14+2]
1491:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);/* .. plus nbr msb lead zeros = 56 bits.*/
0060B8  2866A1     MOV #0x866A, W1
0060BA  90001E     MOV [W14+2], W0
0060BC  408000     ADD W1, W0, W0
0060BE  784010     MOV.B [W0], W0
0060C0  FB8000     ZE W0, W0
0060C2  200381     MOV #0x38, W1
0060C4  400F01     ADD W0, W1, [W14]
1492:                          }
1493:                      }
1494:                  }
1495:              #endif
1496:              
1497:              
1498:                  return (nbr_lead_zeros);
0060C6  78001E     MOV [W14], W0
1499:              }
0060C8  FA8000     ULNK
0060CA  060000     RETURN
1500:              #endif
1501:              
1502:              
1503:              /*
1504:              *********************************************************************************************************
1505:              *                                         CPU_CntTrailZeros()
1506:              *
1507:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
1508:              *
1509:              * Argument(s) : val         Data value to count trailing zero bits.
1510:              *
1511:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1512:              *
1513:              * Caller(s)   : Application.
1514:              *
1515:              *               This function is a CPU module application programming interface (API) function & MAY 
1516:              *               be called by application function(s).
1517:              *
1518:              * Note(s)     : (1) (a) Supports the following data value sizes :
1519:              *
1520:              *                       (1)  8-bits
1521:              *                       (2) 16-bits
1522:              *                       (3) 32-bits
1523:              *                       (4) 64-bits
1524:              *
1525:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1526:              *
1527:              *                   (b) (1) For  8-bit values :
1528:              *
1529:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1530:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1531:              *                                   x    x    x    x    x    x    x    1            0
1532:              *                                   x    x    x    x    x    x    1    0            1
1533:              *                                   x    x    x    x    x    1    0    0            2
1534:              *                                   x    x    x    x    1    0    0    0            3
1535:              *                                   x    x    x    1    0    0    0    0            4
1536:              *                                   x    x    1    0    0    0    0    0            5
1537:              *                                   x    1    0    0    0    0    0    0            6
1538:              *                                   1    0    0    0    0    0    0    0            7
1539:              *                                   0    0    0    0    0    0    0    0            8
1540:              *
1541:              *
1542:              *                       (2) For 16-bit values :
1543:              *
1544:              *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1545:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1546:              *                              x    x    x    x    x         x    x    1            0
1547:              *                              x    x    x    x    x         x    1    0            1
1548:              *                              x    x    x    x    x         1    0    0            2
1549:              *                              :    :    :    :    :         :    :    :            :
1550:              *                              :    :    :    :    :         :    :    :            :
1551:              *                              x    x    x    x    1         0    0    0           11
1552:              *                              x    x    x    1    0         0    0    0           12
1553:              *                              x    x    1    0    0         0    0    0           13
1554:              *                              x    1    0    0    0         0    0    0           14
1555:              *                              1    0    0    0    0         0    0    0           15
1556:              *                              0    0    0    0    0         0    0    0           16
1557:              *
1558:              *
1559:              *                       (3) For 32-bit values :
1560:              *
1561:              *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1562:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1563:              *                              x    x    x    x    x         x    x    1            0
1564:              *                              x    x    x    x    x         x    1    0            1
1565:              *                              x    x    x    x    x         1    0    0            2
1566:              *                              :    :    :    :    :         :    :    :            :
1567:              *                              :    :    :    :    :         :    :    :            :
1568:              *                              x    x    x    x    1         0    0    0           27
1569:              *                              x    x    x    1    0         0    0    0           28
1570:              *                              x    x    1    0    0         0    0    0           29
1571:              *                              x    1    0    0    0         0    0    0           30
1572:              *                              1    0    0    0    0         0    0    0           31
1573:              *                              0    0    0    0    0         0    0    0           32
1574:              *
1575:              *
1576:              *                       (4) For 64-bit values :
1577:              *
1578:              *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1579:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1580:              *                              x    x    x    x    x         x    x    1            0
1581:              *                              x    x    x    x    x         x    1    0            1
1582:              *                              x    x    x    x    x         1    0    0            2
1583:              *                              :    :    :    :    :         :    :    :            :
1584:              *                              :    :    :    :    :         :    :    :            :
1585:              *                              x    x    x    x    1         0    0    0           59
1586:              *                              x    x    x    1    0         0    0    0           60
1587:              *                              x    x    1    0    0         0    0    0           61
1588:              *                              x    1    0    0    0         0    0    0           62
1589:              *                              1    0    0    0    0         0    0    0           63
1590:              *                              0    0    0    0    0         0    0    0           64
1591:              *
1592:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1593:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1594:              *
1595:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1596:              *
1597:              *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of 
1598:              *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's 
1599:              *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
1600:              *
1601:              *                           if (val != 0u) {
1602:              *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1603:              *                           } else {
1604:              *                               nbr_trail_zeros = nbr_lead_zeros;
1605:              *                           }
1606:              *
1607:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1608:              *                       execute the final 'if' statement.
1609:              *********************************************************************************************************
1610:              */
1611:              
1612:              #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
1613:              CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
1614:              {
0060CC  FA0008     LNK #0x8
0060CE  980730     MOV W0, [W14+6]
1615:                  CPU_DATA  val_bit_mask;
1616:                  CPU_DATA  nbr_lead_zeros;
1617:                  CPU_DATA  nbr_trail_zeros;
1618:              
1619:              
1620:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0060D0  90003E     MOV [W14+6], W0
0060D2  E00000     CP0 W0
0060D4  3A0002     BRA NZ, 0x60DA
1621:                      return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
0060D6  200100     MOV #0x10, W0
0060D8  37000B     BRA 0x60F0
1622:                  }
1623:              
1624:              
1625:                  val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
0060DA  90003E     MOV [W14+6], W0
0060DC  EA0080     NEG W0, W1
0060DE  90003E     MOV [W14+6], W0
0060E0  608F00     AND W1, W0, [W14]
1626:                  nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
0060E2  78001E     MOV [W14], W0
0060E4  07FEB4     RCALL CPU_CntLeadZeros
0060E6  980710     MOV W0, [W14+2]
1627:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1628:                  nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0060E8  90001E     MOV [W14+2], W0
0060EA  10006F     SUBR W0, #0xF, W0
0060EC  980720     MOV W0, [W14+4]
1629:              
1630:              
1631:                  return (nbr_trail_zeros);
0060EE  90002E     MOV [W14+4], W0
1632:              }
0060F0  FA8000     ULNK
0060F2  060000     RETURN
1633:              #endif
1634:              
1635:              
1636:              /*
1637:              *********************************************************************************************************
1638:              *                                        CPU_CntTrailZeros08()
1639:              *
1640:              * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
1641:              *
1642:              * Argument(s) : val         Data value to count trailing zero bits.
1643:              *
1644:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1645:              *
1646:              * Caller(s)   : Application.
1647:              *
1648:              *               This function is a CPU module application programming interface (API) function & MAY be 
1649:              *               called by application function(s).
1650:              *
1651:              * Note(s)     : (1) Supports  8-bit values :
1652:              *
1653:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1654:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1655:              *                                x    x    x    x    x    x    x    1            0
1656:              *                                x    x    x    x    x    x    1    0            1
1657:              *                                x    x    x    x    x    1    0    0            2
1658:              *                                x    x    x    x    1    0    0    0            3
1659:              *                                x    x    x    1    0    0    0    0            4
1660:              *                                x    x    1    0    0    0    0    0            5
1661:              *                                x    1    0    0    0    0    0    0            6
1662:              *                                1    0    0    0    0    0    0    0            7
1663:              *                                0    0    0    0    0    0    0    0            8
1664:              *
1665:              *
1666:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1667:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1668:              *
1669:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1670:              *
1671:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1672:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1673:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return 
1674:              *                       data size, then the returned number of zeros must be offset by the difference 
1675:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
1676:              *
1677:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1678:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
1679:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1680:              *                           }
1681:              *
1682:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit 
1683:              *                       values would return a number of trailing zeros less than or equal to  8 bits.
1684:              *
1685:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1686:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1687:              *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
1688:              *
1689:              *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement 
1690:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s 
1691:              *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1692:              *                       initial 'val' is non-'0' :
1693:              *
1694:              *                           if (val != 0u) {
1695:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1696:              *                           } else {
1697:              *                               nbr_trail_zeros = nbr_lead_zeros;
1698:              *                           }
1699:              *
1700:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1701:              *                       execute the final 'if' statement.
1702:              *********************************************************************************************************
1703:              */
1704:              
1705:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1706:              CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
1707:              {
0060F4  FA0008     LNK #0x8
0060F6  984760     MOV.B W0, [W14+6]
1708:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1709:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1710:                  CPU_INT08U  val_bit_mask;
1711:                  CPU_DATA    nbr_lead_zeros;
1712:              #endif
1713:                  CPU_DATA    nbr_trail_zeros;
1714:              
1715:              
1716:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0060F8  90406E     MOV.B [W14+6], W0
0060FA  E00400     CP0.B W0
0060FC  3A0002     BRA NZ, 0x6102
1717:                      return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
0060FE  200080     MOV #0x8, W0
006100  37000B     BRA 0x6118
1718:                  }
1719:              
1720:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1721:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1722:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1723:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1724:              
1725:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1726:                  val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
006102  90406E     MOV.B [W14+6], W0
006104  EA4080     NEG.B W0, W1
006106  90406E     MOV.B [W14+6], W0
006108  60CF00     AND.B W1, W0, [W14]
1727:                  nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
00610A  78401E     MOV.B [W14], W0
00610C  07FEA8     RCALL CPU_CntLeadZeros08
00610E  980710     MOV W0, [W14+2]
1728:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1729:                  nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
006110  90001E     MOV [W14+2], W0
006112  100067     SUBR W0, #0x7, W0
006114  980720     MOV W0, [W14+4]
1730:              #endif
1731:              
1732:              
1733:                  return (nbr_trail_zeros);
006116  90002E     MOV [W14+4], W0
1734:              }
006118  FA8000     ULNK
00611A  060000     RETURN
1735:              #endif
1736:              
1737:              
1738:              /*
1739:              *********************************************************************************************************
1740:              *                                        CPU_CntTrailZeros16()
1741:              *
1742:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
1743:              *
1744:              * Argument(s) : val         Data value to count trailing zero bits.
1745:              *
1746:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1747:              *
1748:              * Caller(s)   : Application.
1749:              *
1750:              *               This function is a CPU module application programming interface (API) function & MAY be 
1751:              *               called by application function(s).
1752:              *
1753:              * Note(s)     : (1) Supports 16-bit values :
1754:              *
1755:              *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1756:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1757:              *                           x    x    x    x    x         x    x    1            0
1758:              *                           x    x    x    x    x         x    1    0            1
1759:              *                           x    x    x    x    x         1    0    0            2
1760:              *                           :    :    :    :    :         :    :    :            :
1761:              *                           :    :    :    :    :         :    :    :            :
1762:              *                           x    x    x    x    1         0    0    0           11
1763:              *                           x    x    x    1    0         0    0    0           12
1764:              *                           x    x    1    0    0         0    0    0           13
1765:              *                           x    1    0    0    0         0    0    0           14
1766:              *                           1    0    0    0    0         0    0    0           15
1767:              *                           0    0    0    0    0         0    0    0           16
1768:              *
1769:              *
1770:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1771:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1772:              *
1773:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1774:              *
1775:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1776:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1777:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return 
1778:              *                       data size, then the returned number of zeros must be offset by the difference 
1779:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
1780:              *
1781:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1782:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
1783:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1784:              *                           }
1785:              *
1786:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit 
1787:              *                       values would return a number of trailing zeros less than or equal to 16 bits.
1788:              *
1789:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1790:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1791:              *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
1792:              *
1793:              *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement 
1794:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s 
1795:              *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1796:              *                       initial 'val' is non-'0' :
1797:              *
1798:              *                           if (val != 0u) {
1799:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1800:              *                           } else {
1801:              *                               nbr_trail_zeros = nbr_lead_zeros;
1802:              *                           }
1803:              *
1804:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1805:              *                       execute the final 'if' statement.
1806:              *********************************************************************************************************
1807:              */
1808:              
1809:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1810:              CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
1811:              {
00611C  FA0008     LNK #0x8
00611E  980730     MOV W0, [W14+6]
1812:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1813:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1814:                  CPU_INT16U  val_bit_mask;
1815:                  CPU_DATA    nbr_lead_zeros;
1816:              #endif
1817:                  CPU_DATA    nbr_trail_zeros;
1818:              
1819:              
1820:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
006120  90003E     MOV [W14+6], W0
006122  E00000     CP0 W0
006124  3A0002     BRA NZ, 0x612A
1821:                      return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
006126  200100     MOV #0x10, W0
006128  37000B     BRA 0x6140
1822:                  }
1823:              
1824:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1825:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1826:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1827:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1828:              
1829:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1830:                  val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
00612A  90003E     MOV [W14+6], W0
00612C  EA0080     NEG W0, W1
00612E  90003E     MOV [W14+6], W0
006130  608F00     AND W1, W0, [W14]
1831:                  nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
006132  78001E     MOV [W14], W0
006134  07FEA1     RCALL CPU_CntLeadZeros16
006136  980710     MOV W0, [W14+2]
1832:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1833:                  nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
006138  90001E     MOV [W14+2], W0
00613A  10006F     SUBR W0, #0xF, W0
00613C  980720     MOV W0, [W14+4]
1834:              #endif
1835:              
1836:              
1837:                  return (nbr_trail_zeros);
00613E  90002E     MOV [W14+4], W0
1838:              }
006140  FA8000     ULNK
006142  060000     RETURN
1839:              #endif
1840:              
1841:              
1842:              /*
1843:              *********************************************************************************************************
1844:              *                                        CPU_CntTrailZeros32()
1845:              *
1846:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
1847:              *
1848:              * Argument(s) : val         Data value to count trailing zero bits.
1849:              *
1850:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1851:              *
1852:              * Caller(s)   : Application.
1853:              *
1854:              *               This function is a CPU module application programming interface (API) function & MAY be 
1855:              *               called by application function(s).
1856:              *
1857:              * Note(s)     : (1) Supports 32-bit values :
1858:              *
1859:              *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1860:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1861:              *                           x    x    x    x    x         x    x    1            0
1862:              *                           x    x    x    x    x         x    1    0            1
1863:              *                           x    x    x    x    x         1    0    0            2
1864:              *                           :    :    :    :    :         :    :    :            :
1865:              *                           :    :    :    :    :         :    :    :            :
1866:              *                           x    x    x    x    1         0    0    0           27
1867:              *                           x    x    x    1    0         0    0    0           28
1868:              *                           x    x    1    0    0         0    0    0           29
1869:              *                           x    1    0    0    0         0    0    0           30
1870:              *                           1    0    0    0    0         0    0    0           31
1871:              *                           0    0    0    0    0         0    0    0           32
1872:              *
1873:              *
1874:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1875:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1876:              *
1877:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1878:              *
1879:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1880:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1881:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return 
1882:              *                       data size, then the returned number of zeros must be offset by the difference 
1883:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
1884:              *
1885:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1886:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
1887:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1888:              *                           }
1889:              *
1890:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit 
1891:              *                       values would return a number of trailing zeros less than or equal to 32 bits.
1892:              *
1893:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1894:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1895:              *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
1896:              *
1897:              *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement 
1898:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s 
1899:              *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1900:              *                       initial 'val' is non-'0' :
1901:              *
1902:              *                           if (val != 0u) {
1903:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1904:              *                           } else {
1905:              *                               nbr_trail_zeros = nbr_lead_zeros;
1906:              *                           }
1907:              *
1908:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1909:              *                       execute the final 'if' statement.
1910:              *********************************************************************************************************
1911:              */
1912:              
1913:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1914:              CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
1915:              {
006144  FA000C     LNK #0xC
006146  980740     MOV W0, [W14+8]
006148  980751     MOV W1, [W14+10]
1916:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1917:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1918:                  CPU_INT32U  val_bit_mask;
1919:                  CPU_DATA    nbr_lead_zeros;
1920:              #endif
1921:                  CPU_DATA    nbr_trail_zeros;
1922:              
1923:              
1924:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
00614A  90004E     MOV [W14+8], W0
00614C  9000DE     MOV [W14+10], W1
00614E  500FE0     SUB W0, #0x0, [W15]
006150  588FE0     SUBB W1, #0x0, [W15]
006152  3A0002     BRA NZ, 0x6158
1925:                      return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
006154  200200     MOV #0x20, W0
006156  37001A     BRA 0x618C
1926:                  }
1927:              
1928:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1929:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1930:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1931:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1932:              
1933:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1934:                  val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
006158  90004E     MOV [W14+8], W0
00615A  9000DE     MOV [W14+10], W1
00615C  100160     SUBR W0, #0x0, W2
00615E  1881E0     SUBBR W1, #0x0, W3
006160  90004E     MOV [W14+8], W0
006162  9000DE     MOV [W14+10], W1
006164  780202     MOV W2, W4
006166  780183     MOV W3, W3
006168  780100     MOV W0, W2
00616A  780001     MOV W1, W0
00616C  620102     AND W4, W2, W2
00616E  618000     AND W3, W0, W0
006170  EB0080     CLR W1
006172  DD00C0     SL W0, #0, W1
006174  200000     MOV #0x0, W0
006176  BE8F00     MOV.D W0, [W14]
006178  B81061     MUL.UU W2, #1, W0
00617A  701F1E     IOR W0, [W14], [W14++]
00617C  70971E     IOR W1, [W14], [W14--]
1935:                  nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
00617E  BE001E     MOV.D [W14], W0
006180  07FE96     RCALL CPU_CntLeadZeros32
006182  980720     MOV W0, [W14+4]
1936:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1937:                  nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
006184  90002E     MOV [W14+4], W0
006186  10007F     SUBR W0, #0x1F, W0
006188  980730     MOV W0, [W14+6]
1938:              #endif
1939:              
1940:              
1941:                  return (nbr_trail_zeros);
00618A  90003E     MOV [W14+6], W0
1942:              }
00618C  FA8000     ULNK
00618E  060000     RETURN
1943:              #endif
1944:              
1945:              
1946:              /*
1947:              *********************************************************************************************************
1948:              *                                        CPU_CntTrailZeros64()
1949:              *
1950:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
1951:              *
1952:              * Argument(s) : val         Data value to count trailing zero bits.
1953:              *
1954:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1955:              *
1956:              * Caller(s)   : Application.
1957:              *
1958:              *               This function is a CPU module application programming interface (API) function & MAY be 
1959:              *               called by application function(s).
1960:              *
1961:              * Note(s)     : (1) Supports 64-bit values :
1962:              *
1963:              *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1964:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1965:              *                           x    x    x    x    x         x    x    1            0
1966:              *                           x    x    x    x    x         x    1    0            1
1967:              *                           x    x    x    x    x         1    0    0            2
1968:              *                           :    :    :    :    :         :    :    :            :
1969:              *                           :    :    :    :    :         :    :    :            :
1970:              *                           x    x    x    x    1         0    0    0           59
1971:              *                           x    x    x    1    0         0    0    0           60
1972:              *                           x    x    1    0    0         0    0    0           61
1973:              *                           x    1    0    0    0         0    0    0           62
1974:              *                           1    0    0    0    0         0    0    0           63
1975:              *                           0    0    0    0    0         0    0    0           64
1976:              *
1977:              *
1978:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1979:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1980:              *
1981:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1982:              *
1983:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1984:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1985:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return 
1986:              *                       data size, then the returned number of zeros must be offset by the difference 
1987:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
1988:              *
1989:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1990:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
1991:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1992:              *                           }
1993:              *
1994:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit 
1995:              *                       values would return a number of trailing zeros less than or equal to 64 bits.
1996:              *
1997:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1998:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1999:              *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
2000:              *
2001:              *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement 
2002:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s 
2003:              *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the 
2004:              *                       initial 'val' is non-'0' :
2005:              *
2006:              *                           if (val != 0u) {
2007:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
2008:              *                           } else {
2009:              *                               nbr_trail_zeros = nbr_lead_zeros;
2010:              *                           }
2011:              *
2012:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
2013:              *                       execute the final 'if' statement.
2014:              *********************************************************************************************************
2015:              */
2016:              
2017:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
2018:              CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
2019:              {
006190  FA0014     LNK #0x14
006192  BE9F88     MOV.D W8, [W15++]
006194  BE9F8A     MOV.D W10, [W15++]
006196  980760     MOV W0, [W14+12]
006198  980771     MOV W1, [W14+14]
00619A  980F02     MOV W2, [W14+16]
00619C  980F13     MOV W3, [W14+18]
2020:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2021:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
2022:                  CPU_INT64U  val_bit_mask;
2023:                  CPU_DATA    nbr_lead_zeros;
2024:              #endif
2025:                  CPU_DATA    nbr_trail_zeros;
2026:              
2027:              
2028:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
00619E  90006E     MOV [W14+12], W0
0061A0  9000FE     MOV [W14+14], W1
0061A2  90090E     MOV [W14+16], W2
0061A4  90099E     MOV [W14+18], W3
0061A6  500FE0     SUB W0, #0x0, [W15]
0061A8  588FE0     SUBB W1, #0x0, [W15]
0061AA  590FE0     SUBB W2, #0x0, [W15]
0061AC  598FE0     SUBB W3, #0x0, [W15]
0061AE  3A0002     BRA NZ, 0x61B4
2029:                      return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
0061B0  200400     MOV #0x40, W0
0061B2  37001C     BRA 0x61EC
2030:                  }
2031:              
2032:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
2033:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2034:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
2035:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
2036:              
2037:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
2038:                  val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0061B4  B84460     MUL.UU W8, #0, W8
0061B6  B85560     MUL.UU W10, #0, W10
0061B8  90006E     MOV [W14+12], W0
0061BA  9000FE     MOV [W14+14], W1
0061BC  90090E     MOV [W14+16], W2
0061BE  90099E     MOV [W14+18], W3
0061C0  540200     SUB W8, W0, W4
0061C2  5C8281     SUBB W9, W1, W5
0061C4  5D0302     SUBB W10, W2, W6
0061C6  5D8383     SUBB W11, W3, W7
0061C8  90006E     MOV [W14+12], W0
0061CA  9000FE     MOV [W14+14], W1
0061CC  90090E     MOV [W14+16], W2
0061CE  90099E     MOV [W14+18], W3
0061D0  621F00     AND W4, W0, [W14++]
0061D2  629F01     AND W5, W1, [W14++]
0061D4  631F02     AND W6, W2, [W14++]
0061D6  638F03     AND W7, W3, [W14]
0061D8  B1006E     SUB #0x6, W14
2039:                  nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0061DA  BE003E     MOV.D [W14++], W0
0061DC  BE012E     MOV.D [W14--], W2
0061DE  07FEAA     RCALL CPU_CntLeadZeros64
0061E0  980740     MOV W0, [W14+8]
2040:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
2041:                  nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0061E2  2003F1     MOV #0x3F, W1
0061E4  90004E     MOV [W14+8], W0
0061E6  508000     SUB W1, W0, W0
0061E8  980750     MOV W0, [W14+10]
2042:              #endif
2043:              
2044:              
2045:                  return (nbr_trail_zeros);
0061EA  90005E     MOV [W14+10], W0
2046:              }
0061EC  BE054F     MOV.D [--W15], W10
2047:              #endif
2048:              
2049:              
2050:              /*
2051:              *********************************************************************************************************
2052:              *********************************************************************************************************
2053:              *                                           LOCAL FUNCTIONS
2054:              *********************************************************************************************************
2055:              *********************************************************************************************************
2056:              */
2057:              
2058:              /*
2059:              *********************************************************************************************************
2060:              *                                           CPU_NameInit()
2061:              *
2062:              * Description : Initialize CPU Name.
2063:              *
2064:              * Argument(s) : none.
2065:              *
2066:              * Return(s)   : none.
2067:              *
2068:              * Caller(s)   : CPU_Init().
2069:              *
2070:              * Note(s)     : none.
2071:              *********************************************************************************************************
2072:              */
2073:              
2074:              #if (CPU_CFG_NAME_EN == DEF_ENABLED)
2075:              static  void  CPU_NameInit (void)
2076:              {
2077:                  CPU_NameClr();
2078:              }
2079:              #endif
2080:              
2081:              
2082:              /*
2083:              *********************************************************************************************************
2084:              *                                            CPU_TS_Init()
2085:              *
2086:              * Description : (1) Initialize CPU timestamp :
2087:              *
2088:              *                   (a) Initialize/start CPU timestamp timer                            See Note #1
2089:              *                   (b) Initialize       CPU timestamp controls
2090:              *
2091:              *
2092:              * Argument(s) : none.
2093:              *
2094:              * Return(s)   : none.
2095:              *
2096:              * Caller(s)   : CPU_Init().
2097:              *
2098:              * Note(s)     : (1) The following initialization MUST be sequenced as follows :
2099:              *
2100:              *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
2101:              *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
2102:              *                                                 otherwise, invalid time measurements may be calculated/
2103:              *                                                 returned.
2104:              *
2105:              *                   See also 'CPU_Init()  Note #3a'.
2106:              *********************************************************************************************************
2107:              */
2108:              
2109:              #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
2110:                   (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
2111:              static  void  CPU_TS_Init (void)
2112:              {
2113:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2114:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2115:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2116:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2117:                  CPU_TS_TMR  ts_tmr_cnts;
2118:              #endif
2119:              
2120:              
2121:                                                                              /* ----------------- INIT CPU TS TMR ------------------ */
2122:              #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
2123:                  CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
2124:                  CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
2125:              #endif
2126:              
2127:              
2128:                                                                              /* ------------------- INIT CPU TS -------------------- */
2129:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2130:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2131:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2132:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2133:                  ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
2134:              #endif
2135:              
2136:              #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
2137:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
2138:                  CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
2139:                  CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
2140:              #endif
2141:              
2142:              #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
2143:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
2144:                  CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
2145:                  CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
2146:              #endif
2147:              }
2148:              #endif
2149:              
2150:              
2151:              /*
2152:              *********************************************************************************************************
2153:              *                                        CPU_IntDisMeasInit()
2154:              *
2155:              * Description : (1) Initialize interrupts disabled time measurements feature :
2156:              *
2157:              *                   (a) Initialize interrupts disabled time measurement controls
2158:              *                   (b) Calculate  interrupts disabled time measurement overhead
2159:              *
2160:              *
2161:              * Argument(s) : none.
2162:              *
2163:              * Return(s)   : none.
2164:              *
2165:              * Caller(s)   : CPU_Init().
2166:              *
2167:              * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
2168:              *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
2169:              *                   disabled time measurements may be calculated/returned.
2170:              *
2171:              *                   See also 'CPU_Init()  Note #3b'.
2172:              *
2173:              *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
2174:              *                           a rounded average with better accuracy, hopefully of +/- one timer count.
2175:              *
2176:              *                       (2) However, a single overhead time measurement is recommended, even for instruction-
2177:              *                           cache-enabled CPUs, since critical sections are NOT typically called within
2178:              *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
2179:              *                           is a more realistic overhead for the majority of non-cached interrupts disabled
2180:              *                           time measurements.
2181:              *
2182:              *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
2183:              *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
2184:              *                       calculate an inflated overhead time which would then incorrectly calculate deflated
2185:              *                       interrupts disabled times.
2186:              *********************************************************************************************************
2187:              */
2188:              
2189:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2190:              static  void  CPU_IntDisMeasInit (void)
2191:              {
2192:                  CPU_TS_TMR  time_meas_tot_cnts;
2193:                  CPU_INT16U  i;
2194:                  CPU_SR_ALLOC();
2195:              
2196:                                                                              /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
2197:                  CPU_IntDisMeasCtr         = 0u;
2198:                  CPU_IntDisNestCtr         = 0u;
2199:                  CPU_IntDisMeasStart_cnts  = 0u;
2200:                  CPU_IntDisMeasStop_cnts   = 0u;
2201:                  CPU_IntDisMeasMaxCur_cnts = 0u;
2202:                  CPU_IntDisMeasMax_cnts    = 0u;
2203:                  CPU_IntDisMeasOvrhd_cnts  = 0u;
2204:              
2205:                                                                              /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
2206:                  time_meas_tot_cnts = 0u;
2207:                  CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
2208:                  for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
2209:                      CPU_IntDisMeasMaxCur_cnts = 0u;
2210:                      CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
2211:                      CPU_IntDisMeasStop();
2212:                      time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
2213:                  }
2214:                                                                              /* ... to calc avg time meas ovrhd (see Note #3a).      */
2215:                  CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
2216:                                                                  /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
2217:                  CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
2218:                  CPU_IntDisMeasMax_cnts    =  0u;
2219:                  CPU_INT_EN();
2220:              }
2221:              #endif
2222:              
2223:              
2224:              /*
2225:              *********************************************************************************************************
2226:              *                                       CPU_IntDisMeasMaxCalc()
2227:              *
2228:              * Description : Calculate maximum interrupts disabled time.
2229:              *
2230:              * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
2231:              *
2232:              * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
2233:              *
2234:              * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
2235:              *               CPU_IntDisMeasMaxGet().
2236:              *
2237:              * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
2238:              *                       during critical sections is calculated by the following equations :
2239:              *
2240:              *                       (1) time            =   [ time      -  time      ]  -  time
2241:              *                               interrupts      [     stop         start ]         total meas
2242:              *                                disabled       [     meas         meas  ]           ovrhd
2243:              *                           (via application)
2244:              *
2245:              *
2246:              *                       (2) time            =  time            +  time
2247:              *                               total meas         start meas         stop meas
2248:              *                                 ovrhd              ovrhd              ovrhd
2249:              *
2250:              *
2251:              *                               where
2252:              *
2253:              *                                       time                    time interrupts are disabled between
2254:              *                                           interrupts              first critical section enter &
2255:              *                                            disabled               last  critical section exit minus
2256:              *                                       (via application)           time measurement overhead
2257:              *
2258:              *                                       time                    time of disable interrupts start time
2259:              *                                           start                   measurement (in timer counts)
2260:              *                                           meas
2261:              *
2262:              *                                       time                    time of disable interrupts stop  time
2263:              *                                           stop                    measurement (in timer counts)
2264:              *                                           meas
2265:              *
2266:              *                                       time                    total overhead time to start/stop disabled
2267:              *                                           total meas              interrupts time measurements (in timer
2268:              *                                             ovrhd                 counts)
2269:              *
2270:              *                                       time                    total overhead time after getting start
2271:              *                                           start meas              time until end of start measurement
2272:              *                                             ovrhd                 function  (in timer counts)
2273:              *
2274:              *                                       time                    total overhead time from beginning of stop
2275:              *                                           stop meas               measurement function until after getting
2276:              *                                             ovrhd                 stop time (in timer counts)
2277:              *
2278:              *
2279:              *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final 
2280:              *                       calculations to subtract the interrupts disabled time measurement overhead is 
2281:              *                       performed asynchronously in API functions.
2282:              *
2283:              *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
2284:              *
2285:              *                   (c) The amount of time interrupts are disabled is calculated by either of the
2286:              *                       following equations :
2287:              *
2288:              *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
2289:              *
2290:              *                               where
2291:              *
2292:              *                                   Number timer counts             Number of timer counts measured
2293:              *                                   Timer period                    Timer's period in some units of
2294:              *                                                                       (fractional) seconds
2295:              *                                   Interrupts disabled time        Amount of time interrupts are
2296:              *                                                                       disabled, in same units of
2297:              *                                                                       (fractional) seconds as the
2298:              *                                                                       Timer period
2299:              *
2300:              *                                                         Number timer counts
2301:              *                       (2) Interrupts disabled time  =  ---------------------
2302:              *                                                           Timer frequency
2303:              *
2304:              *                               where
2305:              *
2306:              *                                   Number timer counts             Number of timer counts measured
2307:              *                                   Timer frequency                 Timer's frequency in some units
2308:              *                                                                       of counts per second
2309:              *                                   Interrupts disabled time        Amount of time interrupts are
2310:              *                                                                       disabled, in seconds
2311:              *
2312:              *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
2313:              *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
2314:              *
2315:              *               (2) Although it is not typical, it is possible for an interrupts disabled time
2316:              *                   measurement to be less than the interrupts disabled time measurement overhead;
2317:              *                   especially if the overhead was calculated with a single, non-cached measurement
2318:              *                   & critical sections are called within instruction-cached loops.
2319:              *********************************************************************************************************
2320:              */
2321:              
2322:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2323:              static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
2324:              {
2325:                  CPU_TS_TMR  time_max_cnts;
2326:              
2327:              
2328:                  time_max_cnts = time_tot_cnts;
2329:                  if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
2330:                      time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
2331:                  } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
2332:                      time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
2333:                  }
2334:              
2335:                  return (time_max_cnts);
2336:              }
2337:              #endif
2338:              
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                /*
25:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
26:                
27:                Microchip licenses to you the right to use, modify, copy and distribute
28:                Software only when embedded on a Microchip microcontroller or digital signal
29:                controller that is integrated into your product or third party product
30:                (pursuant to the sublicense terms in the accompanying license agreement).
31:                
32:                You should refer to the license agreement accompanying this Software for
33:                additional information regarding your rights and obligations.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                 */
46:                #include <includes.h>
47:                #include "Configbits.h"
48:                #include "HL6528.h"
49:                //#include "UART.h"
50:                //#include <xc.h>
51:                //#include "mcc_generated_files/mcc.h"
52:                //volatile uint8_t TMR1_CNT;
53:                
54:                OS_STK LEDStk[64];
55:                OS_STK HL6528Stk[128];
56:                OS_STK PCCopStk[32];
57:                OS_EVENT* sem1, *sem2;
58:                
59:                static void Task1Led(void* p_arg);
60:                //static void Task2CopGPRS(void* p_arg);
61:                
62:                /*
63:                                         Main application
64:                 */
65:                CPU_INT16S main(void) {
007300  FA0000     LNK #0x0
66:                    // initialize the device
67:                    //    SYSTEM_Initialize();
68:                    //    TMR1_Stop();
69:                    //    TMR1_Stop();
70:                    BSP_Init();
007302  07FD3F     RCALL BSP_Init
71:                    OSInit();
007304  07CCB0     RCALL OSInit
72:                    //    sem1 = OSSemCreate(0);
73:                    sem2 = OSSemCreate(0);
007306  EB0000     CLR W0
007308  07F37D     RCALL OSSemCreate
00730A  884470     MOV W0, sem2
74:                    OSTaskCreate(Task1Led, (void*) 0, (OS_STK *) & LEDStk[0], 3);
00730C  B3C033     MOV.B #0x3, W3
00730E  210C22     MOV #0x10C2, W2
007310  EB0080     CLR W1
007312  273280     MOV #0x7328, W0
007314  07DF61     RCALL OSTaskCreate
75:                    OSTaskCreate(HL6528_Dialing, (void*) 0, (OS_STK *) & HL6528Stk[0], 8);
007316  B3C083     MOV.B #0x8, W3
007318  211422     MOV #0x1142, W2
00731A  EB0080     CLR W1
00731C  269000     MOV #0x6900, W0
00731E  07DF5C     RCALL OSTaskCreate
76:                    //    OSTaskCreate(PCCopTask, (void*) 0, (OS_STK*) & PCCopStk[0], 7);
77:                    OSStart();
007320  07CD31     RCALL OSStart
78:                    return -1;
007322  EB8000     SETM W0
79:                
80:                }
007324  FA8000     ULNK
007326  060000     RETURN
81:                
82:                /**
83:                 End of File
84:                 */
85:                
86:                void Task1Led(void* p_arg) {
007328  FA0002     LNK #0x2
00732A  780F00     MOV W0, [W14]
87:                    //    INT8U err;
88:                    //    OS_EVENT sem1;
89:                    while (1) {
90:                        //        OSSemPend(sem1, 0, &err); //UART2
91:                        LED_Toggle();
00732C  07FD97     RCALL LED_Toggle
92:                        while (1)
93:                            RS485Send(0xaa);
00732E  B3CAA0     MOV.B #0xAA, W0
94:                        OSTimeDlyHMSM(0, 0, 1, 0); //1s
95:                    }
96:                }
97:                
98:                
99:                
100:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**************************************************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                static uint8_t bufferWptr_uart1 = 0;
11:                static uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                /*************************************
19:                Function: BufferWrite 
20:                Description: 
21:                Input: 12 
22:                Output: 
23:                 *************************************/
24:                void BufferWrite_UART1(void) {
006718  FA0002     LNK #0x2
25:                    uint8_t tmp;
26:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {// 
00671A  BFC888     MOV.B bufferWptr_uart1, WREG
00671C  FB8080     ZE W0, W1
00671E  BFC889     MOV.B bufferRptr_uart1, WREG
006720  FB8000     ZE W0, W0
006722  E90000     DEC W0, W0
006724  508F80     SUB W1, W0, [W15]
006726  3A0003     BRA NZ, 0x672E
27:                        tmp = U1RXREG; //
006728  801130     MOV U1RXREG, W0
00672A  784F00     MOV.B W0, [W14]
28:                        return;
00672C  37000C     BRA 0x6746
29:                    }
30:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
00672E  BFC888     MOV.B bufferWptr_uart1, WREG
006730  FB8000     ZE W0, W0
006732  801131     MOV U1RXREG, W1
006734  784101     MOV.B W1, W2
006736  212821     MOV #0x1282, W1
006738  787082     MOV.B W2, [W1+W0]
31:                    bufferWptr_uart1++;
00673A  BFC888     MOV.B bufferWptr_uart1, WREG
00673C  E84000     INC.B W0, W0
00673E  B7E888     MOV.B WREG, bufferWptr_uart1
32:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
006740  BFC888     MOV.B bufferWptr_uart1, WREG
006742  B243F0     AND.B #0x3F, W0
006744  B7E888     MOV.B WREG, bufferWptr_uart1
33:                }
006746  FA8000     ULNK
006748  060000     RETURN
34:                
35:                /*************************************
36:                Function: BufferWrite 
37:                Description: 
38:                Input: 12 
39:                Output: 
40:                 *************************************/
41:                void BufferWrite_UART2(void) {
00674A  FA0002     LNK #0x2
42:                    uint8_t tmp = 0;
00674C  EB4000     CLR.B W0
00674E  784F00     MOV.B W0, [W14]
43:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {// 
006750  BFC88A     MOV.B bufferWptr_uart2, WREG
006752  FB8080     ZE W0, W1
006754  BFC88B     MOV.B bufferRptr_uart2, WREG
006756  FB8000     ZE W0, W0
006758  E90000     DEC W0, W0
00675A  508F80     SUB W1, W0, [W15]
00675C  3A0003     BRA NZ, 0x6764
44:                        tmp = U2RXREG; //
00675E  8011B0     MOV U2RXREG, W0
006760  784F00     MOV.B W0, [W14]
45:                        return;
006762  37000C     BRA 0x677C
46:                    }
47:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
006764  BFC88A     MOV.B bufferWptr_uart2, WREG
006766  FB8000     ZE W0, W0
006768  8011B1     MOV U2RXREG, W1
00676A  784101     MOV.B W1, W2
00676C  212C21     MOV #0x12C2, W1
00676E  787082     MOV.B W2, [W1+W0]
48:                    bufferWptr_uart2++;
006770  BFC88A     MOV.B bufferWptr_uart2, WREG
006772  E84000     INC.B W0, W0
006774  B7E88A     MOV.B WREG, bufferWptr_uart2
49:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
006776  BFC88A     MOV.B bufferWptr_uart2, WREG
006778  B243F0     AND.B #0x3F, W0
00677A  B7E88A     MOV.B WREG, bufferWptr_uart2
50:                }
00677C  FA8000     ULNK
00677E  060000     RETURN
51:                
52:                /*************************************
53:                Function:  BufferRead
54:                Description: 
55:                Input:  
56:                Output: 10
57:                 *************************************/
58:                bool BufferRead_UART1(uint8_t *data) {
006780  FA0002     LNK #0x2
006782  780F00     MOV W0, [W14]
59:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
006784  208891     MOV #0x889, W1
006786  784091     MOV.B [W1], W1
006788  BFC888     MOV.B bufferWptr_uart1, WREG
00678A  50CF80     SUB.B W1, W0, [W15]
00678C  3A0002     BRA NZ, 0x6792
60:                        return 0;
00678E  EB4000     CLR.B W0
006790  37000D     BRA 0x67AC
61:                    }
62:                    *data = Buffer_uart1[bufferRptr_uart1];
006792  BFC889     MOV.B bufferRptr_uart1, WREG
006794  FB8000     ZE W0, W0
006796  212821     MOV #0x1282, W1
006798  7840E1     MOV.B [W1+W0], W1
00679A  78001E     MOV [W14], W0
00679C  784801     MOV.B W1, [W0]
63:                    bufferRptr_uart1++;
00679E  BFC889     MOV.B bufferRptr_uart1, WREG
0067A0  E84000     INC.B W0, W0
0067A2  B7E889     MOV.B WREG, bufferRptr_uart1
64:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
0067A4  BFC889     MOV.B bufferRptr_uart1, WREG
0067A6  B243F0     AND.B #0x3F, W0
0067A8  B7E889     MOV.B WREG, bufferRptr_uart1
65:                    return 1;
0067AA  B3C010     MOV.B #0x1, W0
66:                }
0067AC  FA8000     ULNK
0067AE  060000     RETURN
67:                
68:                /*************************************
69:                Function:  BufferRead
70:                Description: 
71:                Input:  
72:                Output: 10
73:                 *************************************/
74:                bool BufferRead_UART2(uint8_t *data) {
0067B0  FA0002     LNK #0x2
0067B2  780F00     MOV W0, [W14]
75:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
0067B4  2088B1     MOV #0x88B, W1
0067B6  784091     MOV.B [W1], W1
0067B8  BFC88A     MOV.B bufferWptr_uart2, WREG
0067BA  50CF80     SUB.B W1, W0, [W15]
0067BC  3A0007     BRA NZ, 0x67CC
76:                        if (U2STAbits.OERR)
0067BE  801190     MOV U2STA, W0
0067C0  600062     AND W0, #0x2, W0
0067C2  E00000     CP0 W0
0067C4  320001     BRA Z, 0x67C8
77:                            U2STAbits.OERR = 0; //FIFO
0067C6  A92232     BCLR U2STA, #1
78:                        return 0;
0067C8  EB4000     CLR.B W0
0067CA  37000D     BRA 0x67E6
79:                    }
80:                    *data = Buffer_uart2[bufferRptr_uart2];
0067CC  BFC88B     MOV.B bufferRptr_uart2, WREG
0067CE  FB8000     ZE W0, W0
0067D0  212C21     MOV #0x12C2, W1
0067D2  7840E1     MOV.B [W1+W0], W1
0067D4  78001E     MOV [W14], W0
0067D6  784801     MOV.B W1, [W0]
81:                    bufferRptr_uart2++;
0067D8  BFC88B     MOV.B bufferRptr_uart2, WREG
0067DA  E84000     INC.B W0, W0
0067DC  B7E88B     MOV.B WREG, bufferRptr_uart2
82:                    bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
0067DE  BFC88B     MOV.B bufferRptr_uart2, WREG
0067E0  B243F0     AND.B #0x3F, W0
0067E2  B7E88B     MOV.B WREG, bufferRptr_uart2
83:                    //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
84:                    return 1;
0067E4  B3C010     MOV.B #0x1, W0
85:                }
0067E6  FA8000     ULNK
0067E8  060000     RETURN
86:                
87:                /*************************************
88:                Function: UARTnDataIsGet  
89:                Description: deadlinebyteshead 
90:                 *  +CRC16
91:                Input: 
92:                Output: 
93:                Notice256    
94:                 *************************************/
95:                uint8_t UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {//'\0'
0067EA  FA000E     LNK #0xE
0067EC  980720     MOV W0, [W14+4]
0067EE  980731     MOV W1, [W14+6]
0067F0  984F02     MOV.B W2, [W14+8]
0067F2  980753     MOV W3, [W14+10]
0067F4  984F44     MOV.B W4, [W14+12]
96:                    bool IsFind = false; //
0067F6  EB4000     CLR.B W0
0067F8  784F00     MOV.B W0, [W14]
97:                    uint8_t cnt = 0, byte = 0;
0067FA  EB4000     CLR.B W0
0067FC  984710     MOV.B W0, [W14+1]
0067FE  EB4000     CLR.B W0
006800  984720     MOV.B W0, [W14+2]
98:                    uint8_t UART_Tmp = 0; //
006802  EB4000     CLR.B W0
006804  984730     MOV.B W0, [W14+3]
99:                    //    uint8_t UART_Tm[10];
100:               
101:                   while (f_uart(&UART_Tmp)) {//
006806  370023     BRA 0x684E
00684E  470063     ADD W14, #0x3, W0
006850  9000AE     MOV [W14+4], W1
006852  010001     CALL W1
006854  E00400     CP0.B W0
006856  3AFFD8     BRA NZ, 0x6808
006858  370001     BRA 0x685C
102:                       if (UART_Tmp == *head) {//==head
006808  90005E     MOV [W14+10], W0
00680A  784090     MOV.B [W0], W1
00680C  90403E     MOV.B [W14+3], W0
00680E  50CF80     SUB.B W1, W0, [W15]
006810  3A001B     BRA NZ, 0x6848
103:                           //            UART_Tm[0] = UART_Tmp;
104:                           for (cnt = 1; cnt < head_size; cnt++) {//
006812  B3C010     MOV.B #0x1, W0
006814  984710     MOV.B W0, [W14+1]
006816  370014     BRA 0x6840
006832  90401E     MOV.B [W14+1], W0
006834  E84000     INC.B W0, W0
006836  984710     MOV.B W0, [W14+1]
006838  370003     BRA 0x6840
006840  90409E     MOV.B [W14+1], W1
006842  90484E     MOV.B [W14+12], W0
006844  50CF80     SUB.B W1, W0, [W15]
006846  39FFE8     BRA NC, 0x6818
105:                               f_uart(&UART_Tmp);
006818  470063     ADD W14, #0x3, W0
00681A  9000AE     MOV [W14+4], W1
00681C  010001     CALL W1
106:                               if (UART_Tmp == *(head + cnt)) {//
00681E  90401E     MOV.B [W14+1], W0
006820  FB8000     ZE W0, W0
006822  9000DE     MOV [W14+10], W1
006824  408000     ADD W1, W0, W0
006826  784090     MOV.B [W0], W1
006828  90403E     MOV.B [W14+3], W0
00682A  50CF80     SUB.B W1, W0, [W15]
00682C  3A0006     BRA NZ, 0x683A
107:                                   IsFind = true;
00682E  B3C010     MOV.B #0x1, W0
006830  784F00     MOV.B W0, [W14]
108:                                   continue;
109:                               } else {
110:                                   IsFind = false;
00683A  EB4000     CLR.B W0
00683C  784F00     MOV.B W0, [W14]
111:                                   break;
00683E  370004     BRA 0x6848
112:                               }
113:                           }
114:                       }
115:                       if (IsFind) break; //
006848  78401E     MOV.B [W14], W0
00684A  E00400     CP0.B W0
00684C  3A0006     BRA NZ, 0x685A
00685A  000000     NOP
116:                   }
117:                   if (!get_size && IsFind)
00685C  90480E     MOV.B [W14+8], W0
00685E  E00400     CP0.B W0
006860  3A0005     BRA NZ, 0x686C
006862  78401E     MOV.B [W14], W0
006864  E00400     CP0.B W0
006866  320002     BRA Z, 0x686C
118:                       return 0xFF; //
006868  EBC000     SETM.B W0
00686A  370036     BRA 0x68D8
119:                   else if (IsFind) {//
00686C  78401E     MOV.B [W14], W0
00686E  E00400     CP0.B W0
006870  320032     BRA Z, 0x68D6
120:                       byte = (get_size < head_size) ? get_size : head_size; //
006872  90488E     MOV.B [W14+8], W1
006874  90484E     MOV.B [W14+12], W0
006876  504F81     SUB.B W0, W1, [W15]
006878  360001     BRA LEU, 0x687C
00687A  784001     MOV.B W1, W0
00687C  984720     MOV.B W0, [W14+2]
121:                       for (cnt = 0; cnt < byte; cnt++) //
00687E  EB4000     CLR.B W0
006880  984710     MOV.B W0, [W14+1]
006882  37000D     BRA 0x689E
006898  90401E     MOV.B [W14+1], W0
00689A  E84000     INC.B W0, W0
00689C  984710     MOV.B W0, [W14+1]
00689E  90409E     MOV.B [W14+1], W1
0068A0  90402E     MOV.B [W14+2], W0
0068A2  50CF80     SUB.B W1, W0, [W15]
0068A4  39FFEF     BRA NC, 0x6884
122:                           *(Get_Source + cnt) = *(head + cnt);
006884  90401E     MOV.B [W14+1], W0
006886  FB8000     ZE W0, W0
006888  9000BE     MOV [W14+6], W1
00688A  408000     ADD W1, W0, W0
00688C  90409E     MOV.B [W14+1], W1
00688E  FB8081     ZE W1, W1
006890  90015E     MOV [W14+10], W2
006892  410081     ADD W2, W1, W1
006894  784091     MOV.B [W1], W1
006896  784801     MOV.B W1, [W0]
123:                       for (cnt = head_size; cnt < get_size; cnt++) //
0068A6  9048CE     MOV.B [W14+12], W1
0068A8  984711     MOV.B W1, [W14+1]
0068AA  37000F     BRA 0x68CA
0068C4  90401E     MOV.B [W14+1], W0
0068C6  E84000     INC.B W0, W0
0068C8  984710     MOV.B W0, [W14+1]
0068CA  90409E     MOV.B [W14+1], W1
0068CC  90480E     MOV.B [W14+8], W0
0068CE  50CF80     SUB.B W1, W0, [W15]
0068D0  39FFED     BRA NC, 0x68AC
0068D2  370001     BRA 0x68D6
124:                           if (!f_uart(Get_Source + byte++))
0068AC  90402E     MOV.B [W14+2], W0
0068AE  FB8000     ZE W0, W0
0068B0  9000BE     MOV [W14+6], W1
0068B2  408000     ADD W1, W0, W0
0068B4  9040AE     MOV.B [W14+2], W1
0068B6  E84081     INC.B W1, W1
0068B8  984721     MOV.B W1, [W14+2]
0068BA  9000AE     MOV [W14+4], W1
0068BC  010001     CALL W1
0068BE  A20400     BTG.B W0, #0
0068C0  E00400     CP0.B W0
0068C2  3A0008     BRA NZ, 0x68D4
125:                               break;
0068D4  000000     NOP
126:                   }
127:                   return byte;
0068D6  90402E     MOV.B [W14+2], W0
128:               }
0068D8  FA8000     ULNK
0068DA  060000     RETURN
129:               
130:               void ClearBuffer2(void) {
0068DC  FA0002     LNK #0x2
131:                   uint8_t tmp;
132:                   while (BufferRead_UART2(&tmp));
0068DE  000000     NOP
0068E0  78000E     MOV W14, W0
0068E2  07FF66     RCALL BufferRead_UART2
0068E4  E00400     CP0.B W0
0068E6  3AFFFC     BRA NZ, 0x68E0
133:               }
0068E8  FA8000     ULNK
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/User/PC.c  ---------------------------------------
1:                 //#include "pc.h"
2:                 #include "includes.h"
3:                 
4:                 void PCCopTask(void*arg) {
007334  FA0002     LNK #0x2
007336  780F00     MOV W0, [W14]
5:                 
6:                     while (1) {
7:                         RS485Send(0x31);
007338  B3C310     MOV.B #0x31, W0
00733A  07FE76     RCALL RS485Send
8:                 //        RS485SendString("ErrCode:\r\n", 10);
9:                         OSTimeDlyHMSM(0, 0, 1, 0);
00733C  EB0180     CLR W3
00733E  B3C012     MOV.B #0x1, W2
007340  EB4080     CLR.B W1
007342  EB4000     CLR.B W0
007344  07FCAC     RCALL OSTimeDlyHMSM
10:                    }
007346  37FFF8     BRA 0x7338
11:                }
12:                
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/User/HL6528.c  -----------------------------------
1:                 //#include "HL6528.h"
2:                 #include "includes.h"
3:                 #include <stdbool.h>
4:                 //#include "cJSON.h"
5:                 
6:                 
7:                 extern OS_EVENT* sem1, *sem2; //
8:                 
9:                 //struct ATCommand {
10:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
11:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
12:                const uint8_t AT[] = {"AT\r\n"};
13:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
14:                const uint8_t OK[] = {"OK"};
15:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
16:                const uint8_t READY[] = {"+CPIN: READY"};
17:                const uint8_t CIMIp[] = {"AT+CIMI\r\n"};
18:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
19:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
20:                const uint8_t _5[] = {",5"};
21:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
22:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
23:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
24:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG"};
25:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};
26:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
27:                const uint8_t CONNECT[] = {"CONNECT"};
28:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
29:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
30:                //} ATCmd;
31:                
32:                //struct AT_Arg {
33:                //    //    uint8_t KCNXCFG[] = {"AT+KCNXCFG,\"GPRS\",\"CMNET\"\r\n"};
34:                //    uint8_t time; //
35:                //    uint8_t count; //
36:                //    uint8_t *sendstr; //
37:                //    uint8_t sendstrlen; //
38:                //    uint8_t *checkstr; //
39:                //    uint8_t checkstrlen; //
40:                //    uint8_t errcode; //
41:                //};
42:                
43:                //
44:                
45:                static bool HL6528SendCmd(const uint8_t *ss, uint8_t* rs, const uint8_t rsl, const uint8_t* cs, const uint8_t csl, const uint8_t second, const uint8_t cnt);
46:                static void HL6528Start(void);
47:                static void HL6528Close(void);
48:                
49:                void HL6528_Init(void) {
0068EC  FA0000     LNK #0x0
50:                    //
51:                    PWRON_TRIS = 0; //PWN_ON 6528
0068EE  A9C2D8     BCLR TRISD, #6
52:                    PWR_TRIS = 0; //6528
0068F0  A9E2D8     BCLR TRISD, #7
53:                    DSR_TRIS = 0; //    
0068F2  A922D8     BCLR TRISD, #1
54:                    DTR_TRIS = 0; //
0068F4  A902D8     BCLR TRISD, #0
55:                    RTS_TRIS = 0; //
0068F6  A982D8     BCLR TRISD, #4
56:                    CTS_TRIS = 0; //    	
0068F8  A9A2D8     BCLR TRISD, #5
57:                    UART2_Init();
0068FA  0702EC     RCALL UART2_Init
58:                }
0068FC  FA8000     ULNK
0068FE  060000     RETURN
59:                
60:                void HL6528_Dialing(void* arg) {
006900  FA0004     LNK #0x4
006902  980710     MOV W0, [W14+2]
61:                    INT8U err;
62:                    uint8_t errcode = 0; //, LastID;
006904  EB4000     CLR.B W0
006906  784F00     MOV.B W0, [W14]
63:                    //    bool ATIsCompete = false;
64:                    //    struct AT_Arg aarg;
65:                    HL6528Start();
006908  0700B0     RCALL _HL6528Start
66:                    while (1) {
67:                        OSSemPend(sem2, 0, &err);
00690A  804470     MOV sem2, W0
00690C  E8008E     INC W14, W1
00690E  B81160     MUL.UU W2, #0, W2
006910  07F92C     RCALL OSSemPend
68:                
69:                        if (HL6528SendCmd(D1, NULL, 0, OK, 2, 1, 3))
006912  B3C036     MOV.B #0x3, W6
006914  B3C015     MOV.B #0x1, W5
006916  B3C024     MOV.B #0x2, W4
006918  285853     MOV #0x8585, W3
00691A  EB4100     CLR.B W2
00691C  EB0080     CLR W1
00691E  2856C0     MOV #0x856C, W0
006920  070080     RCALL _HL6528SendCmd
006922  E00400     CP0.B W0
006924  320044     BRA Z, 0x69AE
70:                            if (HL6528SendCmd(CPIN, NULL, 0, READY, 8, 1, 3))
006926  B3C036     MOV.B #0x3, W6
006928  B3C015     MOV.B #0x1, W5
00692A  B3C084     MOV.B #0x8, W4
00692C  285933     MOV #0x8593, W3
00692E  EB4100     CLR.B W2
006930  EB0080     CLR W1
006932  285880     MOV #0x8588, W0
006934  070076     RCALL _HL6528SendCmd
006936  E00400     CP0.B W0
006938  320037     BRA Z, 0x69A8
71:                                if (HL6528SendCmd(CREG, NULL, 0, _5, 2, 1, 50))
00693A  B3C326     MOV.B #0x32, W6
00693C  B3C015     MOV.B #0x1, W5
00693E  B3C024     MOV.B #0x2, W4
006940  285C13     MOV #0x85C1, W3
006942  EB4100     CLR.B W2
006944  EB0080     CLR W1
006946  285AA0     MOV #0x85AA, W0
006948  07006C     RCALL _HL6528SendCmd
00694A  E00400     CP0.B W0
00694C  32002A     BRA Z, 0x69A2
72:                                    //
73:                                    if (HL6528SendCmd(KCNXCFG, NULL, 0, OK, 2, 1, 3))
00694E  B3C036     MOV.B #0x3, W6
006950  B3C015     MOV.B #0x1, W5
006952  B3C024     MOV.B #0x2, W4
006954  285853     MOV #0x8585, W3
006956  EB4100     CLR.B W2
006958  EB0080     CLR W1
00695A  285CE0     MOV #0x85CE, W0
00695C  070062     RCALL _HL6528SendCmd
00695E  E00400     CP0.B W0
006960  32001D     BRA Z, 0x699C
74:                                        if (HL6528SendCmd(KTCPCFG, NULL, 0, OK, 2, 1, 3))
006962  B3C036     MOV.B #0x3, W6
006964  B3C015     MOV.B #0x1, W5
006966  B3C024     MOV.B #0x2, W4
006968  285853     MOV #0x8585, W3
00696A  EB4100     CLR.B W2
00696C  EB0080     CLR W1
00696E  285EC0     MOV #0x85EC, W0
006970  070058     RCALL _HL6528SendCmd
006972  E00400     CP0.B W0
006974  320010     BRA Z, 0x6996
75:                                            if (HL6528SendCmd(KTCPSTART, NULL, 0, CONNECT, 7, 6, 2))
006976  B3C026     MOV.B #0x2, W6
006978  B3C065     MOV.B #0x6, W5
00697A  B3C074     MOV.B #0x7, W4
00697C  286233     MOV #0x8623, W3
00697E  EB4100     CLR.B W2
006980  EB0080     CLR W1
006982  286120     MOV #0x8612, W0
006984  07004E     RCALL _HL6528SendCmd
006986  E00400     CP0.B W0
006988  320003     BRA Z, 0x6990
76:                                                errcode = 0;
00698A  EB4000     CLR.B W0
00698C  784F00     MOV.B W0, [W14]
00698E  370011     BRA 0x69B2
77:                                            else
78:                                                errcode = 6; //TCP
006990  B3C060     MOV.B #0x6, W0
006992  784F00     MOV.B W0, [W14]
006994  37000E     BRA 0x69B2
79:                                        else
80:                                            errcode = 5; //TCP
006996  B3C050     MOV.B #0x5, W0
006998  784F00     MOV.B W0, [W14]
00699A  37000B     BRA 0x69B2
81:                                    else
82:                                        errcode = 4; //APN
00699C  B3C040     MOV.B #0x4, W0
00699E  784F00     MOV.B W0, [W14]
0069A0  370008     BRA 0x69B2
83:                                else
84:                                    errcode = 3; //
0069A2  B3C030     MOV.B #0x3, W0
0069A4  784F00     MOV.B W0, [W14]
0069A6  370005     BRA 0x69B2
85:                            else
86:                                errcode = 2; //
0069A8  B3C020     MOV.B #0x2, W0
0069AA  784F00     MOV.B W0, [W14]
0069AC  370002     BRA 0x69B2
87:                        else
88:                            errcode = 1; //
0069AE  B3C010     MOV.B #0x1, W0
0069B0  784F00     MOV.B W0, [W14]
89:                
90:                        if (!errcode) {
0069B2  78401E     MOV.B [W14], W0
0069B4  E00400     CP0.B W0
0069B6  3A002A     BRA NZ, 0x6A0C
91:                            //
92:                            UART2_SendString("hello world!!!");
0069B8  2864D0     MOV #0x864D, W0
0069BA  0702D7     RCALL UART2_SendString
93:                            UART2_SendString("hello world!!!");
0069BC  2864D0     MOV #0x864D, W0
0069BE  0702D5     RCALL UART2_SendString
94:                            UART2_SendString("hello world!!!");
0069C0  2864D0     MOV #0x864D, W0
0069C2  0702D3     RCALL UART2_SendString
95:                            OSTimeDlyHMSM(0, 0, 1, 0); //1
0069C4  EB0180     CLR W3
0069C6  B3C012     MOV.B #0x1, W2
0069C8  EB4080     CLR.B W1
0069CA  EB4000     CLR.B W0
0069CC  070168     RCALL OSTimeDlyHMSM
96:                            DSR = 1;
0069CE  A822DC     BSET LATD, #1
97:                            OSTimeDlyHMSM(0, 0, 1, 0); //1s
0069D0  EB0180     CLR W3
0069D2  B3C012     MOV.B #0x1, W2
0069D4  EB4080     CLR.B W1
0069D6  EB4000     CLR.B W0
0069D8  070162     RCALL OSTimeDlyHMSM
98:                            DSR = 0;
0069DA  A922DC     BCLR LATD, #1
99:                            OSTimeDlyHMSM(0, 0, 1, 0); //1s
0069DC  EB0180     CLR W3
0069DE  B3C012     MOV.B #0x1, W2
0069E0  EB4080     CLR.B W1
0069E2  EB4000     CLR.B W0
0069E4  07015C     RCALL OSTimeDlyHMSM
100:                           if (HL6528SendCmd(KTCPCLOSE, NULL, 0, OK, 2, 1, 3))//TCPID
0069E6  B3C036     MOV.B #0x3, W6
0069E8  B3C015     MOV.B #0x1, W5
0069EA  B3C024     MOV.B #0x2, W4
0069EC  285853     MOV #0x8585, W3
0069EE  EB4100     CLR.B W2
0069F0  EB0080     CLR W1
0069F2  2862B0     MOV #0x862B, W0
0069F4  070016     RCALL _HL6528SendCmd
0069F6  E00400     CP0.B W0
0069F8  320010     BRA Z, 0x6A1A
101:                               HL6528SendCmd(KTCPDEL, NULL, 0, OK, 2, 1, 3);
0069FA  B3C036     MOV.B #0x3, W6
0069FC  B3C015     MOV.B #0x1, W5
0069FE  B3C024     MOV.B #0x2, W4
006A00  285853     MOV #0x8585, W3
006A02  EB4100     CLR.B W2
006A04  EB0080     CLR W1
006A06  2863E0     MOV #0x863E, W0
006A08  07000C     RCALL _HL6528SendCmd
006A0A  370007     BRA 0x6A1A
102:                       } else {
103:                           UART2_SendString("ERRORCODE:");//485
006A0C  2865C0     MOV #0x865C, W0
006A0E  0702AD     RCALL UART2_SendString
104:                           UART2_SendChar(errcode + 0x30);
006A10  B3C301     MOV.B #0x30, W1
006A12  40C01E     ADD.B W1, [W14], W0
006A14  07029E     RCALL UART2_SendChar
105:                           UART2_SendString("\r\n");
006A16  286670     MOV #0x8667, W0
006A18  0702A8     RCALL UART2_SendString
106:                       }
107:                       HL6528Close();
006A1A  070030     RCALL _HL6528Close
108:                       OSSemPost(sem1);
006A1C  804460     MOV sem1, W0
006A1E  07F969     RCALL OSSemPost
109:                   }
006A20  37FF74     BRA 0x690A
110:               }
111:               
112:               /*ss**/
113:               static bool HL6528SendCmd(const uint8_t *ss, uint8_t* rs, const uint8_t rsl, const uint8_t* cs, const uint8_t csl, const uint8_t second, const uint8_t cnt) {
006A22  FA000E     LNK #0xE
006A24  980710     MOV W0, [W14+2]
006A26  980721     MOV W1, [W14+4]
006A28  984762     MOV.B W2, [W14+6]
006A2A  980743     MOV W3, [W14+8]
006A2C  984F24     MOV.B W4, [W14+10]
006A2E  984F35     MOV.B W5, [W14+11]
006A30  984F46     MOV.B W6, [W14+12]
114:                   uint8_t cnt_tmp = 0;
006A32  EB4000     CLR.B W0
006A34  784F00     MOV.B W0, [W14]
115:                   do {
116:                       cnt_tmp += 1;
006A36  E84F1E     INC.B [W14], [W14]
117:                       UART2_SendString(ss); //AT                               
006A38  90001E     MOV [W14+2], W0
006A3A  070297     RCALL UART2_SendString
118:                       OSTimeDlyHMSM(0, 0, second, 0); //1s
006A3C  EB0180     CLR W3
006A3E  90493E     MOV.B [W14+11], W2
006A40  EB4080     CLR.B W1
006A42  EB4000     CLR.B W0
006A44  07012C     RCALL OSTimeDlyHMSM
119:                       U2Rx4Byte();
006A46  0702B3     RCALL U2Rx4Byte
120:                       if (UARTIsGet(BufferRead_UART2, rs, rsl, cs, csl) > 0) {
006A48  904A2E     MOV.B [W14+10], W4
006A4A  9001CE     MOV [W14+8], W3
006A4C  90416E     MOV.B [W14+6], W2
006A4E  9000AE     MOV [W14+4], W1
006A50  267B00     MOV #0x67B0, W0
006A52  07FECB     RCALL UARTIsGet
006A54  E00400     CP0.B W0
006A56  320002     BRA Z, 0x6A5C
121:                           return true;
006A58  B3C010     MOV.B #0x1, W0
006A5A  370005     BRA 0x6A66
122:                           break;
123:                       }
124:                   } while (cnt > cnt_tmp);
006A5C  90484E     MOV.B [W14+12], W0
006A5E  504F9E     SUB.B W0, [W14], [W15]
006A60  3EFFEA     BRA GTU, 0x6A36
125:                   ClearBuffer2();
006A62  07FF3C     RCALL ClearBuffer2
126:                   return false;
006A64  EB4000     CLR.B W0
127:               }
006A66  FA8000     ULNK
006A68  060000     RETURN
128:               
129:               static void HL6528Start(void) {
006A6A  FA0000     LNK #0x0
130:                   PWR = 1;
006A6C  A8E2DC     BSET LATD, #7
131:                   PWRON = 1;
006A6E  A8C2DC     BSET LATD, #6
132:                   CTS = 0;
006A70  A9A2DC     BCLR LATD, #5
133:                   RTS = 0;
006A72  A982DC     BCLR LATD, #4
134:                   DSR = 0;
006A74  A922DC     BCLR LATD, #1
135:                   DTR = 0;
006A76  A902DC     BCLR LATD, #0
136:               }
006A78  FA8000     ULNK
006A7A  060000     RETURN
137:               
138:               static void HL6528Close(void) {
006A7C  FA0000     LNK #0x0
139:                   PWRON = 0;
006A7E  A9C2DC     BCLR LATD, #6
140:                   PWR = 0;
006A80  A9E2DC     BCLR LATD, #7
141:                   CTS = 1;
006A82  A8A2DC     BSET LATD, #5
142:                   RTS = 1;
006A84  A882DC     BSET LATD, #4
143:                   DSR = 1;
006A86  A822DC     BSET LATD, #1
144:                   DTR = 1;
006A88  A802DC     BSET LATD, #0
145:               }
006A8A  FA8000     ULNK
146:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: char
6:                 Input:  4  8  
7:                 Output: 
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
0064DA  FA0008     LNK #0x8
0064DC  980720     MOV W0, [W14+4]
0064DE  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
0064E0  9000AE     MOV [W14+4], W1
0064E2  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
0064E4  EB4000     CLR.B W0
0064E6  784F00     MOV.B W0, [W14]
0064E8  37000A     BRA 0x64FE
0064FC  E84F1E     INC.B [W14], [W14]
0064FE  78401E     MOV.B [W14], W0
006500  504FE3     SUB.B W0, #0x3, [W15]
006502  36FFF3     BRA LEU, 0x64EA
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
0064EA  FB801E     ZE [W14], W0
0064EC  9000BE     MOV [W14+6], W1
0064EE  408000     ADD W1, W0, W0
0064F0  90011E     MOV [W14+2], W2
0064F2  FB809E     ZE [W14], W1
0064F4  1080E3     SUBR W1, #0x3, W1
0064F6  410081     ADD W2, W1, W1
0064F8  784091     MOV.B [W1], W1
0064FA  784801     MOV.B W1, [W0]
16:                    }
17:                }
006504  FA8000     ULNK
006506  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char 
22:                Input:     4  8  
23:                Output: 
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
006508  FA0008     LNK #0x8
00650A  980720     MOV W0, [W14+4]
00650C  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
00650E  9000AE     MOV [W14+4], W1
006510  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
006512  EB4000     CLR.B W0
006514  784F00     MOV.B W0, [W14]
006516  37000A     BRA 0x652C
00652A  E84F1E     INC.B [W14], [W14]
00652C  78401E     MOV.B [W14], W0
00652E  504FE3     SUB.B W0, #0x3, [W15]
006530  36FFF3     BRA LEU, 0x6518
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
006518  90009E     MOV [W14+2], W1
00651A  FB801E     ZE [W14], W0
00651C  408000     ADD W1, W0, W0
00651E  FB809E     ZE [W14], W1
006520  1080E3     SUBR W1, #0x3, W1
006522  90013E     MOV [W14+6], W2
006524  410081     ADD W2, W1, W1
006526  784091     MOV.B [W1], W1
006528  784801     MOV.B W1, [W0]
32:                    }
33:                }
006532  FA8000     ULNK
006534  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: char
38:                Input:  4  8  
39:                Output: 
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
006536  FA0008     LNK #0x8
006538  980720     MOV W0, [W14+4]
00653A  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
00653C  9000AE     MOV [W14+4], W1
00653E  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
006540  EB4000     CLR.B W0
006542  784F00     MOV.B W0, [W14]
006544  37000A     BRA 0x655A
006558  E84F1E     INC.B [W14], [W14]
00655A  78401E     MOV.B [W14], W0
00655C  504FE7     SUB.B W0, #0x7, [W15]
00655E  36FFF3     BRA LEU, 0x6546
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
006546  FB801E     ZE [W14], W0
006548  9000BE     MOV [W14+6], W1
00654A  408000     ADD W1, W0, W0
00654C  90011E     MOV [W14+2], W2
00654E  FB809E     ZE [W14], W1
006550  1080E7     SUBR W1, #0x7, W1
006552  410081     ADD W2, W1, W1
006554  784091     MOV.B [W1], W1
006556  784801     MOV.B W1, [W0]
48:                    }
49:                }
006560  FA8000     ULNK
006562  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 1610
54:                Input: 
55:                Output: 
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
006564  FA0002     LNK #0x2
006566  784F00     MOV.B W0, [W14]
58:                    return ((dat >> 4)&0x0f)*10 + (dat & 0x0f);
006568  FB801E     ZE [W14], W0
00656A  DE0044     LSR W0, #4, W0
00656C  784000     MOV.B W0, W0
00656E  B9006A     MUL.SU W0, #10, W0
006570  780000     MOV W0, W0
006572  784080     MOV.B W0, W1
006574  78411E     MOV.B [W14], W2
006576  61406F     AND.B W2, #0xF, W0
006578  40C000     ADD.B W1, W0, W0
59:                }
00657A  FA8000     ULNK
00657C  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 1016
64:                Input: 
65:                Output: 
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
00657E  FA0004     LNK #0x4
006580  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
006582  FB809E     ZE [W14], W1
006584  2000A0     MOV #0xA, W0
006586  780100     MOV W0, W2
006588  090011     REPEAT #0x11
00658A  D88082     DIV.UW W1, W2
00658C  784000     MOV.B W0, W0
00658E  FB8000     ZE W0, W0
006590  DD0044     SL W0, #4, W0
006592  784000     MOV.B W0, W0
006594  984720     MOV.B W0, [W14+2]
006596  FB811E     ZE [W14], W2
006598  2000A0     MOV #0xA, W0
00659A  780180     MOV W0, W3
00659C  090011     REPEAT #0x11
00659E  D88103     DIV.UW W2, W3
0065A0  FD0080     EXCH W0, W1
0065A2  784000     MOV.B W0, W0
0065A4  60406F     AND.B W0, #0xF, W0
0065A6  9040AE     MOV.B [W14+2], W1
0065A8  70C000     IOR.B W1, W0, W0
69:                }
0065AA  FA8000     ULNK
0065AC  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x1117-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 
79:                Input: 
80:                Output: 
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
0065AE  FA0006     LNK #0x6
0065B0  780F00     MOV W0, [W14]
0065B2  980711     MOV W1, [W14+2]
0065B4  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
0065B6  90001E     MOV [W14+2], W0
0065B8  78009E     MOV [W14], W1
0065BA  508F80     SUB W1, W0, [W15]
0065BC  360002     BRA LEU, 0x65C2
0065BE  EB4000     CLR.B W0
0065C0  370007     BRA 0x65D0
84:                    else if (dat < min) return false;
0065C2  90002E     MOV [W14+4], W0
0065C4  78009E     MOV [W14], W1
0065C6  508F80     SUB W1, W0, [W15]
0065C8  310002     BRA C, 0x65CE
0065CA  EB4000     CLR.B W0
0065CC  370001     BRA 0x65D0
85:                    return true;
0065CE  B3C010     MOV.B #0x1, W0
86:                }
0065D0  FA8000     ULNK
0065D2  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 
91:                Input: 
92:                Output: 
93:                 *************************************/
94:                void SetVaildData(uint8_t * dat, const uint32_t max, const uint16_t min) {
0065D4  FA000A     LNK #0xA
0065D6  980710     MOV W0, [W14+2]
0065D8  980722     MOV W2, [W14+4]
0065DA  980733     MOV W3, [W14+6]
0065DC  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = (* dat << 8) + *(dat + 1);
0065DE  90001E     MOV [W14+2], W0
0065E0  784010     MOV.B [W0], W0
0065E2  FB8000     ZE W0, W0
0065E4  DD00C8     SL W0, #8, W1
0065E6  90001E     MOV [W14+2], W0
0065E8  E80000     INC W0, W0
0065EA  784010     MOV.B [W0], W0
0065EC  FB8000     ZE W0, W0
0065EE  408000     ADD W1, W0, W0
0065F0  780F00     MOV W0, [W14]
96:                
97:                    if (tmp > max) {
0065F2  78001E     MOV [W14], W0
0065F4  B80161     MUL.UU W0, #1, W2
0065F6  90002E     MOV [W14+4], W0
0065F8  9000BE     MOV [W14+6], W1
0065FA  510F80     SUB W2, W0, [W15]
0065FC  598F81     SUBB W3, W1, [W15]
0065FE  36000F     BRA LEU, 0x661E
98:                        *dat = max >> 8;
006600  90002E     MOV [W14+4], W0
006602  9000BE     MOV [W14+6], W1
006604  DD0948     SL W1, #8, W2
006606  DE0048     LSR W0, #8, W0
006608  710000     IOR W2, W0, W0
00660A  DE08C8     LSR W1, #8, W1
00660C  784080     MOV.B W0, W1
00660E  90001E     MOV [W14+2], W0
006610  784801     MOV.B W1, [W0]
99:                        *(dat + 1) = max & 0x00ff;
006612  90001E     MOV [W14+2], W0
006614  E80000     INC W0, W0
006616  9000AE     MOV [W14+4], W1
006618  784081     MOV.B W1, W1
00661A  784801     MOV.B W1, [W0]
00661C  37000E     BRA 0x663A
100:                   } else if (tmp < min) {
00661E  90004E     MOV [W14+8], W0
006620  78009E     MOV [W14], W1
006622  508F80     SUB W1, W0, [W15]
006624  31000A     BRA C, 0x663A
101:                       *dat = min >> 8;
006626  90004E     MOV [W14+8], W0
006628  DE0048     LSR W0, #8, W0
00662A  784080     MOV.B W0, W1
00662C  90001E     MOV [W14+2], W0
00662E  784801     MOV.B W1, [W0]
102:                       *(dat + 1) = min & 0x00ff;
006630  90001E     MOV [W14+2], W0
006632  E80000     INC W0, W0
006634  9000CE     MOV [W14+8], W1
006636  784081     MOV.B W1, W1
006638  784801     MOV.B W1, [W0]
103:                   }
104:               }
00663A  FA8000     ULNK
00663C  060000     RETURN
105:               //
106:               
107:               void DataReverse(uint8_t *dat, const uint8_t byte) {
00663E  FA0006     LNK #0x6
006640  980710     MOV W0, [W14+2]
006642  984741     MOV.B W1, [W14+4]
108:                   uint8_t tmp, cnt;
109:               
110:                   for (cnt = 0; cnt < byte / 2; cnt++) {
006644  EB4000     CLR.B W0
006646  784F00     MOV.B W0, [W14]
006648  37001B     BRA 0x6680
00667E  E84F1E     INC.B [W14], [W14]
006680  90404E     MOV.B [W14+4], W0
006682  FB8000     ZE W0, W0
006684  D10000     LSR W0, W0
006686  784000     MOV.B W0, W0
006688  504F9E     SUB.B W0, [W14], [W15]
00668A  3EFFDF     BRA GTU, 0x664A
111:                       tmp = dat[cnt];
00664A  FB801E     ZE [W14], W0
00664C  90009E     MOV [W14+2], W1
00664E  408000     ADD W1, W0, W0
006650  784090     MOV.B [W0], W1
006652  984711     MOV.B W1, [W14+1]
112:                       dat[cnt] = dat[byte - 1 - cnt];
006654  FB801E     ZE [W14], W0
006656  90009E     MOV [W14+2], W1
006658  408000     ADD W1, W0, W0
00665A  9040CE     MOV.B [W14+4], W1
00665C  FB8081     ZE W1, W1
00665E  E90101     DEC W1, W2
006660  FB809E     ZE [W14], W1
006662  510081     SUB W2, W1, W1
006664  90011E     MOV [W14+2], W2
006666  410081     ADD W2, W1, W1
006668  784091     MOV.B [W1], W1
00666A  784801     MOV.B W1, [W0]
113:                       dat[byte - 1 - cnt] = tmp;
00666C  90404E     MOV.B [W14+4], W0
00666E  FB8000     ZE W0, W0
006670  E90080     DEC W0, W1
006672  FB801E     ZE [W14], W0
006674  508000     SUB W1, W0, W0
006676  90009E     MOV [W14+2], W1
006678  408000     ADD W1, W0, W0
00667A  90409E     MOV.B [W14+1], W1
00667C  784801     MOV.B W1, [W0]
114:                   }
115:               }
00668C  FA8000     ULNK
00668E  060000     RETURN
116:               
117:               //8MHz-4Mhz
118:               
119:               //void Delay10ms(char time) {
120:               //    uint16_t i;
121:               //    while (time-- > 0)
122:               //        for (i = 0; i < 6700; i++)
123:               //            asm("Nop()");
124:               //}
125:               
126:               //void Delay100ms(char time) {
127:               //    uint16_t i;
128:               //    while (time-- > 0)
129:               //        for (i = 0; i < 65500; i++)
130:               //            asm("Nop()");
131:               //}
132:               //
133:               //void Delay1s(char time) {
134:               //    uint32_t i; //,j;
135:               //    while (time-- > 0)
136:               //        for (i = 0; i < 365000; i++)
137:               //            asm("Nop()");
138:               //}
139:               
140:               void CopyDat(uint8_t* output, uint8_t *input, const uint8_t bytes) {
006690  FA0008     LNK #0x8
006692  980710     MOV W0, [W14+2]
006694  980721     MOV W1, [W14+4]
006696  984762     MOV.B W2, [W14+6]
141:                   uint8_t num;
142:                   for (num = 0; num < bytes; num++)
006698  EB4000     CLR.B W0
00669A  784F00     MOV.B W0, [W14]
00669C  370009     BRA 0x66B0
0066AE  E84F1E     INC.B [W14], [W14]
0066B0  90406E     MOV.B [W14+6], W0
0066B2  78409E     MOV.B [W14], W1
0066B4  50CF80     SUB.B W1, W0, [W15]
0066B6  39FFF3     BRA NC, 0x669E
143:                       *(output + num) = *(input + num);
00669E  FB801E     ZE [W14], W0
0066A0  90009E     MOV [W14+2], W1
0066A2  408000     ADD W1, W0, W0
0066A4  FB809E     ZE [W14], W1
0066A6  90012E     MOV [W14+4], W2
0066A8  410081     ADD W2, W1, W1
0066AA  784091     MOV.B [W1], W1
0066AC  784801     MOV.B W1, [W0]
144:               }
0066B8  FA8000     ULNK
0066BA  060000     RETURN
145:               
146:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
0066BC  FA0006     LNK #0x6
0066BE  980710     MOV W0, [W14+2]
0066C0  984741     MOV.B W1, [W14+4]
0066C2  984752     MOV.B W2, [W14+5]
147:                   uint8_t num;
148:                   for (num = 0; num < bytes; num++)
0066C4  EB4000     CLR.B W0
0066C6  784F00     MOV.B W0, [W14]
0066C8  370006     BRA 0x66D6
0066D4  E84F1E     INC.B [W14], [W14]
0066D6  90405E     MOV.B [W14+5], W0
0066D8  78409E     MOV.B [W14], W1
0066DA  50CF80     SUB.B W1, W0, [W15]
0066DC  39FFF6     BRA NC, 0x66CA
149:                       *(output + num) = dat;
0066CA  FB801E     ZE [W14], W0
0066CC  90009E     MOV [W14+2], W1
0066CE  408000     ADD W1, W0, W0
0066D0  9040CE     MOV.B [W14+4], W1
0066D2  784801     MOV.B W1, [W0]
150:               }
0066DE  FA8000     ULNK
0066E0  060000     RETURN
151:               
152:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
0066E2  FA0008     LNK #0x8
0066E4  980710     MOV W0, [W14+2]
0066E6  980721     MOV W1, [W14+4]
0066E8  984762     MOV.B W2, [W14+6]
153:                   uint8_t cnt;
154:                   for (cnt = 0; cnt < bytes; cnt++)
0066EA  EB4000     CLR.B W0
0066EC  784F00     MOV.B W0, [W14]
0066EE  37000D     BRA 0x670A
006708  E84F1E     INC.B [W14], [W14]
00670A  90406E     MOV.B [W14+6], W0
00670C  78409E     MOV.B [W14], W1
00670E  50CF80     SUB.B W1, W0, [W15]
006710  39FFEF     BRA NC, 0x66F0
155:                       if (*(str1 + cnt) != *(str2 + cnt))
0066F0  FB801E     ZE [W14], W0
0066F2  90009E     MOV [W14+2], W1
0066F4  408000     ADD W1, W0, W0
0066F6  784090     MOV.B [W0], W1
0066F8  FB801E     ZE [W14], W0
0066FA  90012E     MOV [W14+4], W2
0066FC  410000     ADD W2, W0, W0
0066FE  784010     MOV.B [W0], W0
006700  50CF80     SUB.B W1, W0, [W15]
006702  320002     BRA Z, 0x6708
156:                           return false;
006704  EB4000     CLR.B W0
006706  370006     BRA 0x6714
157:                   return true;
006712  B3C010     MOV.B #0x1, W0
158:               }
006714  FA8000     ULNK
159:               
160:               
161:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/BSP/bsp_a.s  -------------------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                         (c) Copyright 2002, Jean J. Labrosse, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                  dsPIC33FJ Board Support Package
                                                  11:    ;
                                                  12:    ;
                                                  13:    ; File         : bsp_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ;********************************************************************************************************
                                                  16:    ;
                                                  17:    
                                                  18:    ;
                                                  19:    ;********************************************************************************************************
                                                  20:    ;                                                CONSTANTS
                                                  21:    ;********************************************************************************************************
                                                  22:    ;
                                                  23:    ;
                                                  24:    ;********************************************************************************************************
                                                  25:    ;                                                INCLUDES
                                                  26:    ;********************************************************************************************************
                                                  27:    ;
                                                  28:    
                                                  29:    .include "xc.inc"
                                                  30:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  31:    
                                                  32:    ;
                                                  33:    ;********************************************************************************************************
                                                  34:    ;                                             LINKER SPECIFICS
                                                  35:    ;********************************************************************************************************
                                                  36:    ;
                                                  37:    
                                                  38:        .text                                                               ; Locate this file in the text region of the build
                                                  39:    
                                                  40:    ;
                                                  41:    ;********************************************************************************************************
                                                  42:    ;                                                 GLOBALS
                                                  43:    ;********************************************************************************************************
                                                  44:    ;
                                                  45:    
                                                  46:        .global __T2Interrupt
                                                  47:        .global __T4Interrupt
                                                  48:    
                                                  49:    ;
                                                  50:    ;********************************************************************************************************
                                                  51:    ;                                            OS Time Tick ISR Handler
                                                  52:    ;
                                                  53:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #2
                                                  54:    ;
                                                  55:    ; Notes       : All user interrupts should be defined as follows.
                                                  56:    ;********************************************************************************************************
                                                  57:    ;
                                                  58:    
                                                  59:    __T2Interrupt:
00722C  BE9F80     MOV.D W0, [W15++]              60:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  61:    
007248  2086B1     MOV #0x86B, W1                 62:        mov   #_OSIntNesting, w1
00724A  E84891     INC.B [W1], [W1]               63:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  64:    
00724C  ED486B     DEC.B 0x86B, WREG              65:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
00724E  3A0002     BRA NZ, 0x7254                 66:        bra nz, T2_Cont
007250  8043B0     MOV 0x876, W0                  67:        mov _OSTCBCur, w0
007252  78080F     MOV W15, [W0]                  68:        mov w15, [w0]
                                                  69:    
                                                  70:    T2_Cont:
007254  026EBA     CALL 0x6EBA                    71:        call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
007258  020C98     CALL 0xC98                     72:        call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  73:    
00725C  F90044     POP CORCON                     74:        OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  75:    
007278  064000     RETFIE                         76:        retfie                                                              ; 7) Return from interrupt
                                                  77:    
                                                  78:    
                                                  79:    ;
                                                  80:    ;********************************************************************************************************
                                                  81:    ;                                            OS Time Tick ISR Handler
                                                  82:    ;
                                                  83:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #4
                                                  84:    ;
                                                  85:    ; Notes       : All user interrupts should be defined as follows.
                                                  86:    ;********************************************************************************************************
                                                  87:    ;
                                                  88:    
                                                  89:    __T4Interrupt:
00727A  BE9F80     MOV.D W0, [W15++]              90:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  91:    
007296  2086B1     MOV #0x86B, W1                 92:        mov   #_OSIntNesting, w1
007298  E84891     INC.B [W1], [W1]               93:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  94:    
00729A  ED486B     DEC.B 0x86B, WREG              95:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
00729C  3A0002     BRA NZ, 0x72A2                 96:        bra nz, T4_Cont
00729E  8043B0     MOV 0x876, W0                  97:        mov _OSTCBCur, w0
0072A0  78080F     MOV W15, [W0]                  98:        mov w15, [w0]
                                                  99:    
                                                  100:   T4_Cont:
0072A2  026EBA     CALL 0x6EBA                    101:       call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
0072A6  020C98     CALL 0xC98                     102:       call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  103:   
0072AA  F90044     POP CORCON                     104:       OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  105:   
0072C6  064000     RETFIE                         106:       retfie                                                              ; 7) Return from interrupt
                                                  107:   
                                                  108:   
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                #include "HL6528.h"
18:                //#include <p24F32KA302.h>
19:                //#include <p24FJ64GA306.h>
20:                
21:                /*
22:                 *********************************************************************************************************
23:                 *                                       MPLAB CONFIGURATION MACROS
24:                 *********************************************************************************************************
25:                 */
26:                //#if defined(__dsPIC33E__)
27:                //// FICD
28:                //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
29:                //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
30:                //
31:                //// FPOR
32:                //#pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
33:                //#pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
34:                //#pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)
35:                //
36:                //// FWDT
37:                //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
38:                //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
39:                //#pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
40:                //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
41:                //#pragma config FWDTEN = ON              // Watchdog Timer Enable bit (Watchdog timer always enabled)
42:                //
43:                //// FOSC
44:                //#pragma config POSCMD = NONE            // Primary Oscillator Mode Select bits (Primary Oscillator disabled)
45:                //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
46:                //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
47:                //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
48:                //
49:                //// FOSCSEL
50:                //#pragma config FNOSC = FRCDIVN          // Oscillator Source Selection (Internal Fast RC (FRC) Oscillator with postscaler)
51:                //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
52:                //
53:                //// FGS
54:                //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
55:                //#pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)
56:                //#elif defined (__PIC24F__)
57:                // CONFIG4
58:                
59:                // CONFIG4
60:                //#pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68719476736 (25.7 Days))
61:                //#pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select (DSWDT uses LPRC as reference clock)
62:                //#pragma config DSBOREN = OFF            // Deep Sleep BOR Enable bit (DSBOR Disabled)
63:                //#pragma config DSWDTEN = OFF            // Deep Sleep Watchdog Timer Enable (DSWDT Disabled)
64:                //#pragma config DSSWEN = OFF             // DSEN Bit Enable (Deep Sleep operation is always disabled)
65:                //
66:                //// CONFIG3
67:                //#pragma config WPFP = WPFP63            // Write Protection Flash Page Segment Boundary (Page 52 (0xFC00))
68:                //#pragma config VBTBOR = ON              // VBAT BOR enable bit (VBAT BOR enabled)
69:                //#pragma config SOSCSEL = OFF            // SOSC Selection bits (Digital (SCLKI) mode)
70:                //#pragma config WDTWIN = PS25_0          // Watch Dog Timer Window Width (Watch Dog Timer Window Width is 25 percent)
71:                //#pragma config BOREN = ON               // Brown-out Reset Enable (Brown-out Reset Enable)
72:                //#pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Disabled)
73:                //#pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Disabled)
74:                //#pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
75:                //
76:                //// CONFIG2
77:                //#pragma config POSCMD = NONE            // Primary Oscillator Select (Primary Oscillator Disabled)
78:                //#pragma config BOREN1 = EN              // BOR Override bit (BOR Enabled [When BOREN=1])
79:                //#pragma config IOL1WAY = ON             // IOLOCK One-Way Set Enable bit (Once set, the IOLOCK bit cannot be cleared)
80:                //#pragma config OSCIOFCN = ON            // OSCO Pin Configuration (OSCO/CLKO/RC15 functions as port I/O (RC15))
81:                //#pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor Configuration bits (Clock switching and Fail-Safe Clock Monitor are disabled)
82:                //#pragma config FNOSC = FRCPLL           // Initial Oscillator Select (Fast RC Oscillator with PLL module (FRCPLL))
83:                //#pragma config ALTVREF = ALT_AV_ALT_CV  // Alternate VREF/CVREF Pins Selection bit (Voltage reference input, ADC =RB0/RB1   Comparator =RB0/RB1)
84:                //#pragma config IESO = ON                // Internal External Switchover (Enabled)
85:                //
86:                //// CONFIG1
87:                //#pragma config WDTPS = PS32768          // Watchdog Timer Postscaler Select (1:32,768)
88:                //#pragma config FWPSA = PR128            // WDT Prescaler Ratio Select (1:128)
89:                //#pragma config FWDTEN = WDT_DIS         // Watchdog Timer Enable (WDT disabled in hardware; SWDTEN bit disabled)
90:                //#pragma config WINDIS = OFF             // Windowed WDT Disable (Standard Watchdog Timer)
91:                //#pragma config ICS = PGx2               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC2/PGED2)
92:                //#pragma config LPCFG = OFF              // Low power regulator control (Disabled)
93:                //#pragma config GWRP = OFF               // General Segment Write Protect (Disabled)
94:                //#pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
95:                //#pragma config JTAGEN = OFF             // JTAG Port Enable (Disabled)
96:                
97:                
98:                //#elif defined (__PIC24E__)
99:                //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
100:               //#pragma config GSS = OFF                // General Segment Code-Protect bit (General Segment Code protect is disabled)
101:               //#pragma config GSSK = OFF               // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
102:               //
103:               //// FOSCSEL
104:               //#pragma config FNOSC = FRC           // Initial Oscillator Source Selection bits (Primary Oscillator (XT, HS, EC) with PLL)
105:               //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
106:               //
107:               //// FOSC
108:               //#pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
109:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
110:               //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
111:               //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
112:               //
113:               //// FWDT
114:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
115:               //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
116:               //#pragma config PLLKEN = ON              // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
117:               //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
118:               //#pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
119:               //
120:               //// FPOR
121:               //#pragma config FPWRT = PWR128           // Power-on Reset Timer Value Select bits (128ms)
122:               //#pragma config BOREN = ON               // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
123:               //#pragma config ALTI2C1 = OFF            // Alternate I2C pins for I2C1 (SDA1/SCK1 pins are selected as the I/O pins for I2C1)
124:               //#pragma config ALTI2C2 = OFF            // Alternate I2C pins for I2C2 (SDA2/SCK2 pins are selected as the I/O pins for I2C2)
125:               //
126:               //// FICD
127:               //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
128:               //#pragma config RSTPRI = PF              // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
129:               //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
130:               //
131:               //// FAS
132:               //#pragma config AWRP = OFF               // Auxiliary Segment Write-protect bit (Aux Flash may be written)
133:               //#pragma config APL = OFF                // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
134:               //#pragma config APLK = OFF               // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
135:               //
136:               //#elif defined(__dsPIC33F__)
137:               //
138:               //// FBS
139:               //#pragma config BWRP = WRPROTECT_OFF     // Boot Segment Write Protect (Boot Segment may be written)
140:               //#pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
141:               //#pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)
142:               //
143:               //// FSS
144:               //#pragma config SWRP = WRPROTECT_OFF     // Secure Segment Program Write Protect (Secure Segment may be written)
145:               //#pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
146:               //#pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)
147:               //
148:               //// FGS
149:               //#pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
150:               //#pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)
151:               //
152:               //// FOSCSEL
153:               //#pragma config FNOSC = LPRCDIVN           // Oscillator Mode (Primary Oscillator (XT, HS, EC) w/ PLL)
154:               //#pragma config IESO = ON                // Two-speed Oscillator Start-Up Enable (Start up with FRC, then switch)
155:               //
156:               //// FOSC
157:               //#pragma config POSCMD = XT              // Primary Oscillator Source (XT Oscillator Mode)
158:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function (OSC2 pin has clock out function)
159:               //#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Both Clock Switching and Fail-Safe Clock Monitor are disabled)
160:               //
161:               //// FWDT
162:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler (1:32,768)
163:               //#pragma config WDTPRE = PR128           // WDT Prescaler (1:128)
164:               //#pragma config WINDIS = OFF             // Watchdog Timer Window (Watchdog Timer in Non-Window mode)
165:               //#pragma config FWDTEN = ON              // Watchdog Timer Enable (Watchdog timer always enabled)
166:               //
167:               //// FPOR
168:               //#pragma config FPWRT = PWR128           // POR Timer Value (128ms)
169:               //
170:               //// FICD
171:               //#pragma config ICS = PGD1               // Comm Channel Select (Communicate on PGC1/EMUC1 and PGD1/EMUD1)
172:               //#pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG is Disabled)
173:               //#endif
174:               /*********************************************************************************************************
175:                *                                              CONSTANTS
176:                *********************************************************************************************************
177:                */
178:               
179:               //#define  LED6   0x40                                                    /* Port A pin 6                                             */
180:               //#define  LED7   0x80                                                    /* Port A pin 7                                             */
181:               
182:               /*
183:                *********************************************************************************************************
184:                *                                              VARIABLES
185:                *********************************************************************************************************
186:                */
187:               
188:               /*
189:                *********************************************************************************************************
190:                *                                              PROTOTYPES
191:                *********************************************************************************************************
192:                */
193:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
194:               static void BSP_PLL_Init(void);
195:               #endif
196:               static void Tmr_TickInit(void);
197:               
198:               /*
199:                *********************************************************************************************************
200:                *                                         BSP INITIALIZATION
201:                *
202:                * Description : This function should be called by your application code before you make use of any of the
203:                *               functions found in this module.
204:                *
205:                * Arguments   : none
206:                *********************************************************************************************************
207:                */
208:               
209:               void BSP_Init(void) {
006D82  FA0000     LNK #0x0
210:                   RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
006D84  803A00     MOV RCON, W0
006D86  A15000     BCLR W0, #5
006D88  883A00     MOV W0, RCON
211:                   //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
212:                   //    BSP_PLL_Init(); /* Initialize the PLL                                       */
213:                   //#endif
214:                   OSCILLATOR_Initialize();
006D8A  07009E     RCALL OSCILLATOR_Initialize
215:                   LED_Init(); /* Initialize the I/Os for the LED controls                 */
006D8C  07005A     RCALL LED_Init
216:                   Tmr_TickInit(); /* Initialize the uC/OS-II tick interrupt                   */
006D8E  070074     RCALL _Tmr_TickInit
217:                   HL6528_Init(); /*Initialize the HL6528*/
006D90  07FDAD     RCALL HL6528_Init
218:                   RS485_Init(); //Initialize the 485
006D92  07011C     RCALL RS485_Init
219:                   //    Close6528Cop(); /*Close UART2 */
220:               }
006D94  FA8000     ULNK
006D96  060000     RETURN
221:               
222:               /*
223:                *********************************************************************************************************
224:                *                                      BSP_PLL_Init()
225:                *
226:                * Description : This function configures and enables the PLL with the external oscillator
227:                *               selected as the input clock to the PLL.
228:                *
229:                * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
230:                *               2) FIN is the PLL input clock frequency, defined in bsp.h as
231:                *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
232:                *                  oscillator on the Explorer 16 Evaluation Board.
233:                *               3) M is the desired PLL multiplier
234:                *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
235:                *               5) N2 is the PLL output divider (Post-Divider)
236:                *
237:                * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
238:                *                  The processor clock is (1/2) of the PLL output.
239:                *                  Performance = 40 MIPS.
240:                *********************************************************************************************************
241:                */
242:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
243:               
244:               static void BSP_PLL_Init(void) {
245:                   PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
246:                   CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
247:               }
248:               #endif
249:               
250:               /*
251:                *********************************************************************************************************
252:                *                                      BSP_CPU_ClkFrq()
253:               
254:                * Description : This function determines the CPU clock frequency (Fcy)
255:                * Returns     : The CPU frequency in (HZ)
256:                *********************************************************************************************************
257:                */
258:               
259:               CPU_INT32U BSP_CPU_ClkFrq(void) {
006D98  FA0008     LNK #0x8
260:                   CPU_INT08U Clk_Selected;
261:                   CPU_INT16U FRC_Div;
262:                   CPU_INT32U CPU_Clk_Frq;
263:               
264:               
265:               #if defined (__dsPIC33E__) || defined (__dsPIC33F__)
266:                   CPU_INT08U PLL_n1;
267:                   CPU_INT08U PLL_n2;
268:                   CPU_INT16U PLL_m;
269:                   PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
270:                   PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
271:                   PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
272:                   PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
273:               #endif
274:               
275:                   FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
006D9A  803A21     MOV CLKDIV, W1
006D9C  207000     MOV #0x700, W0
006D9E  608000     AND W1, W0, W0
006DA0  DE0048     LSR W0, #8, W0
006DA2  980720     MOV W0, [W14+4]
276:                   FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
006DA4  90002E     MOV [W14+4], W0
006DA6  200021     MOV #0x2, W1
006DA8  DD0800     SL W1, W0, W0
006DAA  980720     MOV W0, [W14+4]
277:               
278:                   Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
006DAC  803A11     MOV OSCCON, W1
006DAE  270000     MOV #0x7000, W0
006DB0  608000     AND W1, W0, W0
006DB2  DE004C     LSR W0, #12, W0
006DB4  984760     MOV.B W0, [W14+6]
279:               
280:                   switch (Clk_Selected) {
006DB6  90406E     MOV.B [W14+6], W0
006DB8  FB8000     ZE W0, W0
006DBA  500FE3     SUB W0, #0x3, [W15]
006DBC  32001E     BRA Z, 0x6DFA
006DBE  500FE3     SUB W0, #0x3, [W15]
006DC0  3C0007     BRA GT, 0x6DD0
006DC2  500FE1     SUB W0, #0x1, [W15]
006DC4  320012     BRA Z, 0x6DEA
006DC6  500FE1     SUB W0, #0x1, [W15]
006DC8  3C0014     BRA GT, 0x6DF2
006DCA  E00000     CP0 W0
006DCC  32000A     BRA Z, 0x6DE2
006DCE  37002C     BRA 0x6E28
006DD0  500FE5     SUB W0, #0x5, [W15]
006DD2  32001B     BRA Z, 0x6E0A
006DD4  500FE5     SUB W0, #0x5, [W15]
006DD6  350015     BRA LT, 0x6E02
006DD8  500FE6     SUB W0, #0x6, [W15]
006DDA  32001B     BRA Z, 0x6E12
006DDC  500FE7     SUB W0, #0x7, [W15]
006DDE  32001C     BRA Z, 0x6E18
006DE0  370023     BRA 0x6E28
281:                       case 0: /* Fast Oscillator (FRC) Selected                           */
282:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
006DE2  212000     MOV #0x1200, W0
006DE4  2007A1     MOV #0x7A, W1
006DE6  BE8F00     MOV.D W0, [W14]
283:                           break;
006DE8  370022     BRA 0x6E2E
284:               
285:                       case 1:
286:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
287:                           CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
288:                                   (FRC_Div * PLL_n1 * PLL_n2));
289:               #else
290:                           /* Fast Oscillator (FRC) with PLL Selected                  */
291:                           CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
006DEA  248000     MOV #0x4800, W0
006DEC  201E81     MOV #0x1E8, W1
006DEE  BE8F00     MOV.D W0, [W14]
292:               #endif
293:                           break;
006DF0  37001E     BRA 0x6E2E
294:               
295:                       case 2: /* Primary External Oscillator Selected                     */
296:                           CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
006DF2  212000     MOV #0x1200, W0
006DF4  2007A1     MOV #0x7A, W1
006DF6  BE8F00     MOV.D W0, [W14]
297:                           break;
006DF8  37001A     BRA 0x6E2E
298:               
299:                       case 3:
300:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
301:                           CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
302:                                   (PLL_n1 * PLL_n2));
303:               #else
304:                           /* Primary External Oscillator with PLL Selected            */
305:                           CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
006DFA  248000     MOV #0x4800, W0
006DFC  201E81     MOV #0x1E8, W1
006DFE  BE8F00     MOV.D W0, [W14]
306:               #endif
307:                           break;
006E00  370016     BRA 0x6E2E
308:               
309:                       case 4: /* Secondary Oscillator Selected (SOCS)                     */
310:                           CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
006E02  280000     MOV #0x8000, W0
006E04  200001     MOV #0x0, W1
006E06  BE8F00     MOV.D W0, [W14]
311:                           break;
006E08  370012     BRA 0x6E2E
312:               
313:                       case 5: /* Low Power Oscillator (LPOSC) Selected                    */
314:                           CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
006E0A  279180     MOV #0x7918, W0
006E0C  200001     MOV #0x0, W1
006E0E  BE8F00     MOV.D W0, [W14]
315:                           break;
006E10  37000E     BRA 0x6E2E
316:               
317:                       case 6:
318:                           CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
006E12  B80060     MUL.UU W0, #0, W0
006E14  BE8F00     MOV.D W0, [W14]
319:                           break;
006E16  37000B     BRA 0x6E2E
320:               
321:                       case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
322:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
006E18  90002E     MOV [W14+4], W0
006E1A  EB0080     CLR W1
006E1C  BE0100     MOV.D W0, W2
006E1E  212000     MOV #0x1200, W0
006E20  2007A1     MOV #0x7A, W1
006E22  07CAEF     RCALL 0x402
006E24  BE8F00     MOV.D W0, [W14]
323:                           break;
006E26  370003     BRA 0x6E2E
324:               
325:                       default:
326:                           CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
006E28  B80060     MUL.UU W0, #0, W0
006E2A  BE8F00     MOV.D W0, [W14]
327:                           break;
006E2C  000000     NOP
328:                   }
329:               
330:                   CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
006E2E  BE001E     MOV.D [W14], W0
006E30  D10081     LSR W1, W1
006E32  D38000     RRC W0, W0
006E34  BE8F00     MOV.D W0, [W14]
331:               
332:                   return (CPU_Clk_Frq); /* Return the operating frequency                           */
006E36  BE001E     MOV.D [W14], W0
333:               }
006E38  FA8000     ULNK
006E3A  060000     RETURN
334:               
335:               /*
336:                *********************************************************************************************************
337:                *                                     DISABLE ALL INTERRUPTS
338:                *
339:                * Description : This function disables all interrupts from the interrupt controller.
340:                *
341:                * Arguments   : none
342:                *********************************************************************************************************
343:                */
344:               
345:               void BSP_IntDisAll(void) {
006E3C  FA0000     LNK #0x0
346:               }
006E3E  FA8000     ULNK
006E40  060000     RETURN
347:               
348:               /*
349:                *********************************************************************************************************
350:                *                                         LED I/O INITIALIZATION
351:                *
352:                * Description : This function initializes the I/O Pins used by the onboard LEDs
353:                *
354:                * Arguments   : none
355:                *
356:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
357:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
358:                *********************************************************************************************************
359:                */
360:               
361:               void LED_Init(void) {
006E42  FA0000     LNK #0x0
362:                   TRISFbits.TRISF0 = 0;
006E44  A902E8     BCLR TRISF, #0
363:               
364:                   LED_On(); /* Shut off all LEDs                                        */
006E46  070002     RCALL LED_On
365:               }
006E48  FA8000     ULNK
006E4A  060000     RETURN
366:               
367:               /*
368:                *********************************************************************************************************
369:                *                                             LED ON
370:                *
371:                * Description : This function is used to control any or all the LEDs on the board.
372:                *
373:                * Arguments   : led    is the number of the LED to control
374:                *                      0    indicates that you want ALL the LEDs to be ON
375:                *                      1    turns ON LED1
376:                *                      2    turns ON LED2
377:                *                      ...
378:                *                      8    turns ON LED8
379:                *
380:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
381:                *********************************************************************************************************
382:                */
383:               
384:               void LED_On(void) {
006E4C  FA0000     LNK #0x0
385:                   PORTFbits.RF0 = 1;
006E4E  A802EA     BSET PORTF, #0
386:               }
006E50  FA8000     ULNK
006E52  060000     RETURN
387:               
388:               /*
389:                *********************************************************************************************************
390:                *                                             LED OFF
391:                *
392:                * Description : This function is used to control any or all the LEDs on the board.
393:                *
394:                * Arguments   : led    is the number of the LED to turn OFF
395:                *                      0    indicates that you want ALL the LEDs to be OFF
396:                *                      1    turns OFF LED1
397:                *                      2    turns OFF LED2
398:                *                      .
399:                *                      8    turns OFF LED8
400:                *
401:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
402:                *********************************************************************************************************
403:                */
404:               
405:               void LED_Off(void) {
006E54  FA0000     LNK #0x0
406:                   LATFbits.LATF0 = 0;
006E56  A902EC     BCLR LATF, #0
407:               }
006E58  FA8000     ULNK
006E5A  060000     RETURN
408:               
409:               /*
410:                *********************************************************************************************************
411:                *                                             LED TOGGLE
412:                *
413:                * Description : This function is used to toggle any or all the LEDs on the board.
414:                *
415:                * Arguments   : led    is the number of the LED to control
416:                *                      0    indicates that you want to toggle ALL the LEDs
417:                *                      1    toggles LED1
418:                *                      2    toggles LED2
419:                *                      .
420:                *                      8    toggles LED8
421:                *
422:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
423:                *********************************************************************************************************
424:                */
425:               
426:               void LED_Toggle(void) {
006E5C  FA0000     LNK #0x0
427:                   LATFbits.LATF0 ^= 1;
006E5E  801760     MOV LATF, W0
006E60  784000     MOV.B W0, W0
006E62  604061     AND.B W0, #0x1, W0
006E64  A20400     BTG.B W0, #0
006E66  604061     AND.B W0, #0x1, W0
006E68  FB8000     ZE W0, W0
006E6A  600061     AND W0, #0x1, W0
006E6C  801761     MOV LATF, W1
006E6E  A10001     BCLR W1, #0
006E70  700001     IOR W0, W1, W0
006E72  881760     MOV W0, LATF
428:               }
006E74  FA8000     ULNK
006E76  060000     RETURN
429:               
430:               /*
431:                *********************************************************************************************************
432:                *                                   OSProbe_TmrInit()
433:                *
434:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
435:                *               free running timer that is used to make time measurements.
436:                *
437:                * Arguments   : none
438:                *
439:                * Returns     : none
440:                *
441:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
442:                *                  from Tmr_TickInit().
443:                *********************************************************************************************************
444:                */
445:               
446:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
447:               
448:               void OSProbe_TmrInit(void) {
449:               #if OS_PROBE_TIMER_SEL == 3
450:                   T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
451:                   TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
452:                   PR3 = 0xFFFF; /* Set the period register to its maximum value             */
453:                   T3CON |= TON; /* Start the timer                                          */
454:               #endif
455:               
456:               #if OS_PROBE_TIMER_SEL == 5
457:                   T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
458:                   TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
459:                   PR5 = 0xFFFF; /* Set the period register to its maximum value             */
460:                   T5CON |= TON; /* Start the timer                                          */
461:               #endif
462:               }
463:               #endif
464:               
465:               /*
466:                *********************************************************************************************************
467:                *                                   OSProbe_TmrRd()
468:                *
469:                * Description : This function is called to read the current counts of a 16 bit free running timer.
470:                *
471:                * Arguments   : none
472:                *
473:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
474:                *********************************************************************************************************
475:                */
476:               
477:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
478:               
479:               CPU_INT32U OSProbe_TmrRd(void) {
480:               #if OS_PROBE_TIMER_SEL == 3
481:                   return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
482:               #endif
483:               
484:               #if OS_PROBE_TIMER_SEL == 5
485:                   return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
486:               #endif
487:               }
488:               #endif
489:               
490:               /*
491:                *********************************************************************************************************
492:                *                                       TICKER INITIALIZATION
493:                *
494:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
495:                *               interrupts every 1 to 100 mS).
496:                *
497:                * Arguments   : none
498:                *
499:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
500:                *               2) The timer resets to 0 after period register match interrupt is generated
501:                *********************************************************************************************************
502:                */
503:               
504:               static void Tmr_TickInit(void) {
006E78  FA0006     LNK #0x6
505:                   CPU_INT32U tmr_frq;
506:                   CPU_INT16U cnts;
507:               
508:               
509:                   tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
006E7A  07FF8E     RCALL BSP_CPU_ClkFrq
006E7C  BE8F00     MOV.D W0, [W14]
510:                   cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
006E7E  BE001E     MOV.D [W14], W0
006E80  203E82     MOV #0x3E8, W2
006E82  200003     MOV #0x0, W3
006E84  07CACD     RCALL 0x420
006E86  780000     MOV W0, W0
006E88  E90000     DEC W0, W0
006E8A  980720     MOV W0, [W14+4]
511:               
512:               #if BSP_OS_TMR_SEL == 2
513:                   T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
006E8C  EF2110     CLR T2CON
514:                   TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
006E8E  EF2106     CLR TMR2
515:                   PR2 = cnts; /* Set the period register                                  */
006E90  9000AE     MOV [W14+4], W1
006E92  880861     MOV W1, PR2
516:                   IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
006E94  800531     MOV IPC1, W1
006E96  28FFF0     MOV #0x8FFF, W0
006E98  608000     AND W1, W0, W0
006E9A  880530     MOV W0, IPC1
517:                   IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
006E9C  800530     MOV IPC1, W0
006E9E  A0E000     BSET W0, #14
006EA0  880530     MOV W0, IPC1
518:                   IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
006EA2  800420     MOV IFS0, W0
006EA4  A17000     BCLR W0, #7
006EA6  880420     MOV W0, IFS0
519:                   IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
006EA8  8004A0     MOV IEC0, W0
006EAA  A07000     BSET W0, #7
006EAC  8804A0     MOV W0, IEC0
520:                   T2CON |= TON; /* Start the timer                                          */
006EAE  800881     MOV T2CON, W1
006EB0  280000     MOV #0x8000, W0
006EB2  700001     IOR W0, W1, W0
006EB4  880880     MOV W0, T2CON
521:               #endif
522:               
523:               #if BSP_OS_TMR_SEL == 4
524:                   T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
525:                   TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
526:                   PR4 = cnts; /* Set the period register                                  */
527:                   IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
528:                   IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
529:                   IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
530:                   IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
531:                   T4CON |= TON; /* Start the timer                                          */
532:               #endif
533:               }
006EB6  FA8000     ULNK
006EB8  060000     RETURN
534:               
535:               /*
536:                *********************************************************************************************************
537:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
538:                *
539:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
540:                *********************************************************************************************************
541:                */
542:               
543:               void OS_Tick_ISR_Handler(void) {
006EBA  FA0000     LNK #0x0
544:               #if  BSP_OS_TMR_SEL == 2
545:                   IFS0 &= ~T2IF;
006EBC  800420     MOV IFS0, W0
006EBE  A17000     BCLR W0, #7
006EC0  880420     MOV W0, IFS0
546:               #endif
547:               
548:               #if  BSP_OS_TMR_SEL == 4
549:                   IFS1 &= ~T41F;
550:               #endif
551:               
552:                   OSTimeTick();
006EC2  07CF96     RCALL OSTimeTick
553:               }
006EC4  FA8000     ULNK
006EC6  060000     RETURN
554:               //
555:               
556:               void OSCILLATOR_Initialize(void) {
006EC8  FA0000     LNK #0x0
557:                   // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
558:                   CLKDIV = 0x3000;
006ECA  230000     MOV #0x3000, W0
006ECC  883A20     MOV W0, CLKDIV
559:                   // Set the secondary oscillator
560:                   OSCCONbits.SOSCEN = 0;
006ECE  A92742     BCLR OSCCON, #1
561:               }
006ED0  FA8000     ULNK
562:               
563:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/BSP/UART.c  --------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART.h"
3:                 
4:                 void UART2_Init(void) {
006ED4  FA0000     LNK #0x0
5:                     //
6:                     TRISDbits.TRISD2 = 1; //
006ED6  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //
006ED8  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //
9:                     //    TRISDbits.TRISD2 = 0; //
10:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
006EDA  803A11     MOV OSCCON, W1
006EDC  200BF0     MOV #0xBF, W0
006EDE  608100     AND W1, W0, W2
006EE0  200460     MOV #0x46, W0
006EE2  200571     MOV #0x57, W1
006EE4  207423     MOV #0x742, W3
006EE6  784980     MOV.B W0, [W3]
006EE8  784981     MOV.B W1, [W3]
006EEA  784982     MOV.B W2, [W3]
11:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
006EEC  8036B1     MOV RPOR11, W1
006EEE  2FFC00     MOV #0xFFC0, W0
006EF0  608000     AND W1, W0, W0
006EF2  B30050     IOR #0x5, W0
006EF4  8836B0     MOV W0, RPOR11
12:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX RPG23=>17
006EF6  803531     MOV RPINR19, W1
006EF8  2FFC00     MOV #0xFFC0, W0
006EFA  608000     AND W1, W0, W0
006EFC  B30170     IOR #0x17, W0
006EFE  883530     MOV W0, RPINR19
13:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
14:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
15:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
006F00  803A10     MOV OSCCON, W0
006F02  780100     MOV W0, W2
006F04  A06002     BSET W2, #6
006F06  200460     MOV #0x46, W0
006F08  200571     MOV #0x57, W1
006F0A  207423     MOV #0x742, W3
006F0C  784980     MOV.B W0, [W3]
006F0E  784981     MOV.B W1, [W3]
006F10  784982     MOV.B W2, [W3]
16:                    U2MODEbits.BRGH = 0; //1:16
006F12  A96230     BCLR U2MODE, #3
17:                    U2BRG = 51; //19200 103; //16000000/9600/16-1
006F14  200330     MOV #0x33, W0
006F16  8811C0     MOV W0, U2BRG
18:                    U2MODEbits.PDSEL = 00; //
006F18  801181     MOV U2MODE, W1
006F1A  2FFF90     MOV #0xFFF9, W0
006F1C  608000     AND W1, W0, W0
006F1E  881180     MOV W0, U2MODE
19:                    U2MODEbits.STSEL = 0; //1
006F20  A90230     BCLR U2MODE, #0
20:                
21:                    U2MODEbits.UARTEN = 1; //
006F22  A8E231     BSET 0x231, #7
22:                
23:                    U2STAbits.UTXEN = 1; //  
006F24  A84233     BSET 0x233, #2
24:                    U2STAbits.URXISEL = 3; // 4  1
006F26  801191     MOV U2STA, W1
006F28  200C00     MOV #0xC0, W0
006F2A  700001     IOR W0, W1, W0
006F2C  881190     MOV W0, U2STA
25:                    IEC1bits.U2RXIE = 1; //
006F2E  A8C097     BSET 0x97, #6
26:                    IFS1bits.U2RXIF = 0; //
006F30  A9C087     BCLR 0x87, #6
27:                    IEC4bits.U2ERIE = 1;
006F32  A8409C     BSET IEC4, #2
28:                    IFS4bits.U2ERIF = 0;
006F34  A9408C     BCLR IFS4, #2
29:                }
006F36  FA8000     ULNK
006F38  060000     RETURN
30:                
31:                void UART2_Open(void) {
006F3A  FA0000     LNK #0x0
32:                    U2MODEbits.UARTEN = 1; //
006F3C  A8E231     BSET 0x231, #7
33:                    U2STAbits.UTXEN = 1; //  
006F3E  A84233     BSET 0x233, #2
34:                    // IEC1bits.U2TXIE=1;
35:                    IEC1bits.U2RXIE = 1;
006F40  A8C097     BSET 0x97, #6
36:                }
006F42  FA8000     ULNK
006F44  060000     RETURN
37:                
38:                void UART2_Close(void) {
006F46  FA0000     LNK #0x0
39:                    // IEC1bits.U2TXIE=0;
40:                    IEC1bits.U2RXIE = 0;
006F48  A9C097     BCLR 0x97, #6
41:                    U2STAbits.UTXEN = 1; //  
006F4A  A84233     BSET 0x233, #2
42:                    U2MODEbits.UARTEN = 0; //    
006F4C  A9E231     BCLR 0x231, #7
43:                }
006F4E  FA8000     ULNK
006F50  060000     RETURN
44:                
45:                void UART2_SendChar(uint8_t ch) {
006F52  FA0002     LNK #0x2
006F54  784F00     MOV.B W0, [W14]
46:                    U2TXREG = ch;
006F56  FB801E     ZE [W14], W0
006F58  8811A0     MOV W0, U2TXREG
47:                    while (!U2STAbits.TRMT);
006F5A  000000     NOP
006F5C  801191     MOV U2STA, W1
006F5E  201000     MOV #0x100, W0
006F60  608000     AND W1, W0, W0
006F62  E00000     CP0 W0
006F64  32FFFB     BRA Z, 0x6F5C
48:                }
006F66  FA8000     ULNK
006F68  060000     RETURN
49:                
50:                uint8_t UART2_SendString(const uint8_t *str) {
006F6A  FA0004     LNK #0x4
006F6C  980710     MOV W0, [W14+2]
51:                    uint8_t bytes = 0;
006F6E  EB4000     CLR.B W0
006F70  784F00     MOV.B W0, [W14]
52:                    while (*str != '\0') {
006F72  370007     BRA 0x6F82
006F82  90001E     MOV [W14+2], W0
006F84  784010     MOV.B [W0], W0
006F86  E00400     CP0.B W0
006F88  3AFFF5     BRA NZ, 0x6F74
53:                        UART2_SendChar(*str++);
006F74  90001E     MOV [W14+2], W0
006F76  784010     MOV.B [W0], W0
006F78  90009E     MOV [W14+2], W1
006F7A  E80081     INC W1, W1
006F7C  980711     MOV W1, [W14+2]
006F7E  07FFE9     RCALL UART2_SendChar
54:                        bytes++;
006F80  E84F1E     INC.B [W14], [W14]
55:                    }
56:                    return bytes;
006F8A  78401E     MOV.B [W14], W0
57:                }
006F8C  FA8000     ULNK
006F8E  060000     RETURN
58:                
59:                bool UART2_ReceiveChar(uint8_t * ch) {
006F90  FA0002     LNK #0x2
006F92  780F00     MOV W0, [W14]
60:                    if (U2STAbits.URXDA) {
006F94  801190     MOV U2STA, W0
006F96  600061     AND W0, #0x1, W0
006F98  E00000     CP0 W0
006F9A  320006     BRA Z, 0x6FA8
61:                        *ch = U2RXREG;
006F9C  8011B0     MOV U2RXREG, W0
006F9E  784080     MOV.B W0, W1
006FA0  78001E     MOV [W14], W0
006FA2  784801     MOV.B W1, [W0]
62:                        return true;
006FA4  B3C010     MOV.B #0x1, W0
006FA6  370001     BRA 0x6FAA
63:                    } else
64:                        return false;
006FA8  EB4000     CLR.B W0
65:                }
006FAA  FA8000     ULNK
006FAC  060000     RETURN
66:                
67:                void U2Rx4Byte(void) {//4
006FAE  FA0002     LNK #0x2
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//
006FB0  EB4000     CLR.B W0
006FB2  784F00     MOV.B W0, [W14]
006FB4  370006     BRA 0x6FC2
006FC0  E84F1E     INC.B [W14], [W14]
006FC2  78401E     MOV.B [W14], W0
006FC4  504FE3     SUB.B W0, #0x3, [W15]
006FC6  36FFF7     BRA LEU, 0x6FB6
70:                        if (U2STAbits.URXDA) //
006FB6  801190     MOV U2STA, W0
006FB8  600061     AND W0, #0x1, W0
006FBA  E00000     CP0 W0
006FBC  320001     BRA Z, 0x6FC0
71:                            BufferWrite_UART2();
006FBE  07FBC5     RCALL BufferWrite_UART2
72:                }
006FC8  FA8000     ULNK
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485
13:                Input:  
14:                Output: 
15:                 *************************************/
16:                void RS485_Init(void) {
006FCC  FA0000     LNK #0x0
17:                    RS485_TRIS = 0; // 485_CON
006FCE  A942C9     BCLR 0x2C9, #2
18:                    RS485_IN_TRIS = 0; ///
006FD0  A902C9     BCLR 0x2C9, #0
19:                    RS485_OUT_TRIS = 1; //
006FD2  A822C9     BSET 0x2C9, #1
20:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
006FD4  803A11     MOV OSCCON, W1
006FD6  200BF0     MOV #0xBF, W0
006FD8  608100     AND W1, W0, W2
006FDA  200460     MOV #0x46, W0
006FDC  200571     MOV #0x57, W1
006FDE  207423     MOV #0x742, W3
006FE0  784980     MOV.B W0, [W3]
006FE2  784981     MOV.B W1, [W3]
006FE4  784982     MOV.B W2, [W3]
21:                    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
006FE6  803641     MOV RPOR4, W1
006FE8  2FFC00     MOV #0xFFC0, W0
006FEA  608000     AND W1, W0, W0
006FEC  B30030     IOR #0x3, W0
006FEE  883640     MOV W0, RPOR4
22:                    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
006FF0  803521     MOV RPINR18, W1
006FF2  2FFC00     MOV #0xFFC0, W0
006FF4  608000     AND W1, W0, W0
006FF6  B30090     IOR #0x9, W0
006FF8  883520     MOV W0, RPINR18
23:                    //    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
24:                    //    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
25:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
006FFA  803A10     MOV OSCCON, W0
006FFC  780100     MOV W0, W2
006FFE  A06002     BSET W2, #6
007000  200460     MOV #0x46, W0
007002  200571     MOV #0x57, W1
007004  207423     MOV #0x742, W3
007006  784980     MOV.B W0, [W3]
007008  784981     MOV.B W1, [W3]
00700A  784982     MOV.B W2, [W3]
26:                    ANSBbits.ANSB8 = 0; //
00700C  A904E3     BCLR 0x4E3, #0
27:                    ANSBbits.ANSB9 = 0;
00700E  A924E3     BCLR 0x4E3, #1
28:                    U1MODEbits.BRGH = 0; //16
007010  A96220     BCLR U1MODE, #3
29:                    U1BRG = 51; //16000000/9600/16-1
007012  200330     MOV #0x33, W0
007014  881140     MOV W0, U1BRG
30:                
31:                    U1MODEbits.PDSEL = 00; //
007016  801101     MOV U1MODE, W1
007018  2FFF90     MOV #0xFFF9, W0
00701A  608000     AND W1, W0, W0
00701C  881100     MOV W0, U1MODE
32:                    U1MODEbits.STSEL = 0; //1
00701E  A90220     BCLR U1MODE, #0
33:                
34:                    U1MODEbits.UARTEN = 1; //
007020  A8E221     BSET 0x221, #7
35:                
36:                    U1STAbits.UTXEN = 1; //  
007022  A84223     BSET 0x223, #2
37:                //    U1STAbits.URXISEL = 3; // 4  1
38:                //    IEC0bits.U1RXIE = 1; //
39:                //    IFS0bits.U1RXIF = 0; //
40:                //    IEC4bits.U1ERIE = 1; //
41:                //    IFS4bits.U1ERIF = 0; //
42:                }
007024  FA8000     ULNK
007026  060000     RETURN
43:                
44:                //void OpenAwake485(void) {//CN6
45:                //    RS485_RX_IN;
46:                //    CNEN1bits.CN6IE = 1; //RX1
47:                //}
48:                
49:                //void CloseAwake485(void) {
50:                //    CNEN1bits.CN6IE = 0;
51:                //}
52:                
53:                /*************************************
54:                Function: RS485_Send  
55:                Description: 485
56:                Input:  
57:                Output: 1:
58:                 *************************************/
59:                void RS485Send(const uint8_t dat) {
007028  FA0002     LNK #0x2
00702A  784F00     MOV.B W0, [W14]
60:                    RS485_CON = 1; //
00702C  A842CD     BSET 0x2CD, #2
61:                    OSTimeDlyHMSM(0, 0, 0, 10);
00702E  2000A3     MOV #0xA, W3
007030  EB0100     CLR W2
007032  EB0080     CLR W1
007034  EB0000     CLR W0
007036  07FE33     RCALL OSTimeDlyHMSM
62:                    U1TXREG = dat;
007038  FB801E     ZE [W14], W0
00703A  881120     MOV W0, U1TXREG
63:                    while (!U1STAbits.TRMT); //while (!U2STAbits.TRMT);
00703C  000000     NOP
00703E  801111     MOV U1STA, W1
007040  201000     MOV #0x100, W0
007042  608000     AND W1, W0, W0
007044  E00000     CP0 W0
007046  32FFFB     BRA Z, 0x703E
64:                    OSTimeDlyHMSM(0, 0, 0, 10);
007048  2000A3     MOV #0xA, W3
00704A  EB0100     CLR W2
00704C  EB0080     CLR W1
00704E  EB0000     CLR W0
007050  07FE26     RCALL OSTimeDlyHMSM
65:                    RS485_CON = 0; //
007052  A942CD     BCLR 0x2CD, #2
66:                    OSTimeDlyHMSM(0, 0, 0, 10);
007054  2000A3     MOV #0xA, W3
007056  EB0100     CLR W2
007058  EB0080     CLR W1
00705A  EB0000     CLR W0
00705C  07FE20     RCALL OSTimeDlyHMSM
67:                }
00705E  FA8000     ULNK
007060  060000     RETURN
68:                
69:                /*************************************
70:                Function: RS485_SendString 
71:                Description: 485
72:                Input:   
73:                Output: 
74:                 *************************************/
75:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
007062  FA0006     LNK #0x6
007064  980710     MOV W0, [W14+2]
007066  984741     MOV.B W1, [W14+4]
76:                    uint8_t count = 0;
007068  EB4000     CLR.B W0
00706A  784F00     MOV.B W0, [W14]
77:                
78:                    RS485_CON = 1; //
00706C  A842CD     BSET 0x2CD, #2
79:                    while (count < bytes) {
00706E  37000D     BRA 0x708A
00708A  90404E     MOV.B [W14+4], W0
00708C  78409E     MOV.B [W14], W1
00708E  50CF80     SUB.B W1, W0, [W15]
007090  39FFEF     BRA NC, 0x7070
80:                        U1TXREG = *(dat + count);
007070  FB801E     ZE [W14], W0
007072  90009E     MOV [W14+2], W1
007074  408000     ADD W1, W0, W0
007076  784010     MOV.B [W0], W0
007078  FB8000     ZE W0, W0
00707A  881120     MOV W0, U1TXREG
81:                        while (U1STAbits.UTXBF);
00707C  000000     NOP
00707E  801111     MOV U1STA, W1
007080  202000     MOV #0x200, W0
007082  608000     AND W1, W0, W0
007084  E00000     CP0 W0
007086  3AFFFB     BRA NZ, 0x707E
82:                        count++;
007088  E84F1E     INC.B [W14], [W14]
83:                    }
84:                    OSTimeDlyHMSM(0, 0, 0, 10);
007092  2000A3     MOV #0xA, W3
007094  EB0100     CLR W2
007096  EB0080     CLR W1
007098  EB0000     CLR W0
00709A  07FE01     RCALL OSTimeDlyHMSM
85:                    RS485_CON = 0; //
00709C  A942CD     BCLR 0x2CD, #2
86:                    OSTimeDlyHMSM(0, 0, 0, 10);
00709E  2000A3     MOV #0xA, W3
0070A0  EB0100     CLR W2
0070A2  EB0080     CLR W1
0070A4  EB0000     CLR W0
0070A6  07FDFB     RCALL OSTimeDlyHMSM
87:                }
0070A8  FA8000     ULNK
0070AA  060000     RETURN
88:                
89:                /*************************************
90:                Function: OpenRS485 
91:                Description: 485
92:                Input:   
93:                Output: 
94:                 *************************************/
95:                void OpenRS485(void) {
0070AC  FA0000     LNK #0x0
96:                    IEC0bits.U1RXIE = 1;
0070AE  A86095     BSET 0x95, #3
97:                    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled ??????????
0070B0  A84223     BSET 0x223, #2
98:                }
0070B2  FA8000     ULNK
0070B4  060000     RETURN
99:                
100:               /*************************************
101:               Function: RS485_SendString 
102:               Description: 485
103:               Input:   
104:               Output: 
105:                *************************************/
106:               void CloseRS485(void) {
0070B6  FA0000     LNK #0x0
107:                   IEC0bits.U1RXIE = 0;
0070B8  A96095     BCLR 0x95, #3
108:                   U1STAbits.UTXEN = 0; //UARTx transmitter is enabled ??????????
0070BA  A94223     BCLR 0x223, #2
109:               }
0070BC  FA8000     ULNK
110:               /*************************************
111:               Function: RS485_test 
112:               Description: 485
113:               Input:  
114:               Output: 
115:                *************************************/
116:               //void RS485test(void)
117:               //{
118:               //    uint8_t dat='6';
119:               
120:               //RS485Send('T');
121:               //    if(!RS485Receive(&dat))
122:               //    {
123:               //        RS485Send(dat);
124:               //        RS485Send('T');
125:               //    }
126:               //}
127:               
128:               /*************************************
129:               Function: RS485_Receive  
130:               Description: 485
131:               Input:  
132:               Output: 1
133:                ************************************
134:               bool RS485Receive(uint8_t* dat) {
135:               
136:                   bool b = true;
137:               //    uint8_t timeCount;
138:                   
139:               //    RS485_CON = 0; //
140:               
141:                   if (U1STAbits.OERR)
142:                       U1STAbits.OERR = 0;
143:                   
144:               //    gT23Count=0;
145:               //    T2CONbits.TON = 1;// 
146:                  
147:                   while (!U1STAbits.URXDA) //
148:                   {
149:               //        timeCount = gT23Count;
150:               //        if( T100msIsOver(timeCount,10) ) {//1s
151:               //            b = false;
152:               //            break;
153:               //        }
154:                   }
155:               //    T2CONbits.TON = 0;//
156:               //    gT23Count=0;           //
157:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
158:               //    TMR2 = 0x0000;
159:                   
160:               //    if(b)
161:               //        *dat = U1RXREG;
162:               
163:                   return b;
164:               }*/
165:               
166:               
167:               
---  C:/Users/Administrator/Desktop/V1_1_0WCGfor6528.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 201666, 8:48
6:                  */
7:                 #include "UART.h"
8:                 #include "SerialBuffer.h"
9:                 
10:                
11:                
12:                ///*************************************
13:                //Function:  
14:                //Description: 
15:                //Input:  
16:                //Output: 
17:                // *************************************/
18:                //void __attribute__((__interrupt__, __auto_psv__)) _RTCCInterrupt(void) {
19:                //    OSCChange(0x00);
20:                //    gTimeCount.timeAlarm++; //
21:                //    gTimeCount.timeGprs++;
22:                //    gTimeCount.timeMp++;
23:                //
24:                //    if ((gTimeCount.timeMp >= miotArgs.timemp - SettingSampleTime)&&(!FLagArgbits.PulseTimeFlag)) {//16
25:                //        FLagArgbits.T1CountFlag = 1;
26:                //        T1CONbits.TON = 1;
27:                //    }
28:                //
29:                //    if (gTimeCount.timeMp >= miotArgs.timemp) {//FRAM
30:                //        gTimeCount.timeMp = 0;
31:                //        FLagArgbits.PulseTimeFlag = 0;
32:                //        FLagArgbits.T1CountFlag = 0; //
33:                //        T1CONbits.TON = 0; //1
34:                //        StartTime4();
35:                //        IFS1bits.T4IF = 1; //T4CONbits.TON = 1;
36:                //    }
37:                //
38:                //    if (gTimeCount.timeGprs >= miotArgs.timegprs) {//GPRS
39:                //        gTimeCount.timeGprs = 0;
40:                //        FLagArgbits.tgprsFlag = 1;
41:                //    }
42:                //
43:                //    //    FLagArgbits.LowPowerFlag = !BAT_DEC; //
44:                //    if (gTimeCount.timeAlarm >= miotArgs.timealarm) {
45:                //        float getvoltage = 0;
46:                //        gTimeCount.timeAlarm = 0;
47:                //        GetVoltage(&getvoltage);
48:                //        if (miotArgs.AlarmVoltage > getvoltage) {
49:                //            FLagArgbits.LowPoweralarmFlag = 1; 
50:                //        }
51:                //    }
52:                //    if (FLagArgbits.tgprsFlag || FLagArgbits.LowPoweralarmFlag)
53:                //        FLagArgbits.SleepExitFlag = 1;
54:                //    else
55:                //        FLagArgbits.SleepExitFlag = 0;
56:                //    IFS3bits.RTCIF = 0; //clear RTC      
57:                //}
58:                
59:                /*************************************
60:                Function:  
61:                Description: GPRS
62:                Input:  
63:                Output: 
64:                 *************************************/
65:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
66:                //    gT3Count++;
67:                //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
68:                //}
69:                
70:                /*************************************
71:                Function:  
72:                Description: 485
73:                Input:  
74:                Output: 
75:                 *************************************/
76:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
77:                //    while (!U1STAbits.RIDLE);
78:                //    PC_Cop();
79:                //    T2CONbits.TON = 0;
80:                //    TMR2 = 0;
81:                //    FLagArgbits.TestFlag = 0; //
82:                //    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
83:                //}
84:                
85:                /*************************************
86:                Function:  
87:                Description: 
88:                Input:  
89:                Output: 
90:                 *************************************/
91:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
92:                //    gT1Count++;
93:                //    IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
94:                //}
95:                
96:                /*************************************
97:                Function: t4 
98:                Description: 
99:                Input:  
100:               Output: 
101:                *************************************/
102:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
103:               //    if (FLagArgbits.LowPowerGetDataFlag) {
104:               //        FLagArgbits.LowPowerGetDataFlag = 0;
105:               //        GetValueTask(LowPowerData); //
106:               //    } else if (FLagArgbits.TestGetDataFlag) {
107:               //        FLagArgbits.TestGetDataFlag = 0;
108:               //        GetValueTask(TestData); //
109:               //    } else
110:               //        GetValueTask(SampleData); //
111:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
112:               //
113:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
114:               //    CloseTime4();
115:               //}
116:               
117:               /*************************************
118:               Function:  
119:               Description: 
120:               Input:  
121:               Output: 
122:                *************************************/
123:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //
124:               //    if (S1) {//
125:               //        gPulseCount++; //+1
126:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//T1
127:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //ms
128:               //            if (gPulseTime < 2000)//2s
129:               //                gPulseTime = 0;
130:               //            else {
131:               //                FLagArgbits.PulseTimeFlag = 1; // 
132:               //                FLagArgbits.T1CountFlag = 0;
133:               //                T1CONbits.TON = 0;
134:               //            }
135:               //        }
136:               //        TMR1 = 0;
137:               //        gT1Count = 0;
138:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //FLagArgbits.T1CountLastFlag
139:               //    }
140:               //    IFS1bits.CNIF = 0;
141:               //}
142:               
143:               /*************************************
144:               Function: UART1
145:               Description: 485
146:               Input:  
147:               Output: 
148:                *************************************/
149:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
000318  F80036     PUSH RCOUNT
00031A  BE9F80     MOV.D W0, [W15++]
00031C  BE9F82     MOV.D W2, [W15++]
00031E  BE9F84     MOV.D W4, [W15++]
000320  BE9F86     MOV.D W6, [W15++]
000322  F80032     PUSH DSRPAG
000324  F80034     PUSH DSWPAG
000326  200010     MOV #0x1, W0
000328  8801A0     MOV W0, DSWPAG
00032A  202000     MOV #0x200, W0
00032C  880190     MOV W0, DSRPAG
00032E  FA0002     LNK #0x2
150:                   //    GPRS_ON;
151:                   //    OSCChange(0x00); //
152:                   //    GPRS_OFF;
153:                   uint8_t cnt = 0;
000330  EB4000     CLR.B W0
000332  784F00     MOV.B W0, [W14]
154:                   for (cnt = 0; cnt < 4; cnt++)
000334  EB4000     CLR.B W0
000336  784F00     MOV.B W0, [W14]
000338  370006     BRA 0x346
000344  E84F1E     INC.B [W14], [W14]
000346  78401E     MOV.B [W14], W0
000348  504FE3     SUB.B W0, #0x3, [W15]
00034A  36FFF7     BRA LEU, 0x33A
155:                       if (U1STAbits.URXDA == 1) //
00033A  801110     MOV U1STA, W0
00033C  600061     AND W0, #0x1, W0
00033E  E00000     CP0 W0
000340  320001     BRA Z, 0x344
156:                           BufferWrite_UART1();
000342  0731EA     RCALL BufferWrite_UART1
157:                   //    FLagArgbits.TestFlag = 1; //
158:                   //    FLagArgbits.SleepExitFlag = 1;
159:                   //    T2CONbits.TON = 1; //2
160:                   //    IEC0bits.T2IE = 1;T2CONbits.TON = 1;
161:                   IFS0bits.U1RXIF = 0;
00034C  A96085     BCLR 0x85, #3
162:               }
00034E  FA8000     ULNK
000350  F90034     POP DSWPAG
000352  F90032     POP DSRPAG
000354  BE034F     MOV.D [--W15], W6
000356  BE024F     MOV.D [--W15], W4
000358  BE014F     MOV.D [--W15], W2
00035A  BE004F     MOV.D [--W15], W0
00035C  F90036     POP RCOUNT
00035E  064000     RETFIE
163:               
164:               /*************************************
165:               Function: UART2
166:               Description: GPRS
167:               Input:  
168:               Output: 
169:                *************************************/
170:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
000360  F80036     PUSH RCOUNT
000362  BE9F80     MOV.D W0, [W15++]
000364  BE9F82     MOV.D W2, [W15++]
000366  BE9F84     MOV.D W4, [W15++]
000368  BE9F86     MOV.D W6, [W15++]
00036A  F80032     PUSH DSRPAG
00036C  F80034     PUSH DSWPAG
00036E  200010     MOV #0x1, W0
000370  8801A0     MOV W0, DSWPAG
000372  202000     MOV #0x200, W0
000374  880190     MOV W0, DSRPAG
000376  FA0002     LNK #0x2
171:                   uint8_t cnt = 0;
000378  EB4000     CLR.B W0
00037A  784F00     MOV.B W0, [W14]
172:                   for (cnt = 0; cnt < 4; cnt++)
00037C  EB4000     CLR.B W0
00037E  784F00     MOV.B W0, [W14]
000380  370006     BRA 0x38E
00038C  E84F1E     INC.B [W14], [W14]
00038E  78401E     MOV.B [W14], W0
000390  504FE3     SUB.B W0, #0x3, [W15]
000392  36FFF7     BRA LEU, 0x382
173:                       if (U2STAbits.URXDA == 1) //        
000382  801190     MOV U2STA, W0
000384  600061     AND W0, #0x1, W0
000386  E00000     CP0 W0
000388  320001     BRA Z, 0x38C
174:                           BufferWrite_UART2();
00038A  0731DF     RCALL BufferWrite_UART2
175:                   IFS1bits.U2RXIF = 0;
000394  A9C087     BCLR 0x87, #6
176:               }
000396  FA8000     ULNK
000398  F90034     POP DSWPAG
00039A  F90032     POP DSRPAG
00039C  BE034F     MOV.D [--W15], W6
00039E  BE024F     MOV.D [--W15], W4
0003A0  BE014F     MOV.D [--W15], W2
0003A2  BE004F     MOV.D [--W15], W0
0003A4  F90036     POP RCOUNT
0003A6  064000     RETFIE
177:               
178:               /*************************************
179:               Function: UART2
180:               Description: GPRS
181:               Input:  
182:               Output: 
183:                *************************************/
184:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
185:               //    u8 cnt = 0;
186:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
187:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //
188:               //
189:               //        while (!U2STAbits.TRMT);
190:               //        cnt++;
191:               //    }
192:               //    IFS1bits.U2TXIF = 0;
193:               //}
194:               
195:               /*************************************
196:               Function: UART1
197:               Description: 
198:               Input:  
199:               Output: 
200:                *************************************/
201:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
0003A8  781F80     MOV W0, [W15++]
0003AA  FA0000     LNK #0x0
202:                   if (U1STAbits.OERR == 1)
0003AC  801110     MOV U1STA, W0
0003AE  600062     AND W0, #0x2, W0
0003B0  E00000     CP0 W0
0003B2  320001     BRA Z, 0x3B6
203:                       U1STAbits.OERR = 0;
0003B4  A92222     BCLR U1STA, #1
204:                   IFS4bits.U1ERIF = 0;
0003B6  A9208C     BCLR IFS4, #1
205:               }
0003B8  FA8000     ULNK
0003BA  78004F     MOV [--W15], W0
0003BC  064000     RETFIE
206:               
207:               /*************************************
208:               Function: UART2
209:               Description: 
210:               Input:  
211:               Output: 
212:                *************************************/
213:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
0003BE  781F80     MOV W0, [W15++]
0003C0  FA0000     LNK #0x0
214:                   if (U2STAbits.OERR == 1)
0003C2  801190     MOV U2STA, W0
0003C4  600062     AND W0, #0x2, W0
0003C6  E00000     CP0 W0
0003C8  320001     BRA Z, 0x3CC
215:                       U2STAbits.OERR = 0;
0003CA  A92232     BCLR U2STA, #1
216:                   IFS4bits.U2ERIF = 0;
0003CC  A9408C     BCLR IFS4, #2
217:               }
0003CE  FA8000     ULNK
0003D0  78004F     MOV [--W15], W0
0003D2  064000     RETFIE
218:               
219:               /*************************************
220:               Function: 1
221:               Description: 
222:               Input:  
223:               Output: 
224:                *************************************/
225:               //void __attribute__((interrupt, no_auto_psv)) _INT1Interrupt(void) {
226:               //    u8 tmp[7] = {0, 0, 0, 0, 0, 0, 0};
227:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
228:               //    RTCReadTime(tmp); //
229:               //    FM25L64B_Write(RST_Time, tmp, 7); //
230:               //    IFS1bits.INT1IF = 0;
231:               //}
232:               
233:               /*************************************
234:               Function: 
235:               Description: 
236:               Input:  
237:               Output: 
238:                *************************************/
239:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
0003D4  781F80     MOV W0, [W15++]
0003D6  FA0000     LNK #0x0
240:                   //    u8 tmp[7] = {0, 0, 0, 0, 0, 0, 0};
241:                   //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
242:                   //    RTCReadTime(tmp); //
243:                   //    FM25L64B_Write(RST_Data, (u8*) & RCON, 2); //
244:                   //    FM25L64B_Write(RST_Data + 2, (u8*) & IFS0, 2); //
245:                   //    FM25L64B_Write(RST_Data + 4, (u8*) & IFS1, 2); //
246:                   //    FM25L64B_Write(RST_Data + 6, (u8*) & IFS2, 2); //
247:                   //    FM25L64B_Write(RST_Data + 8, (u8*) & IFS3, 2); //
248:                   //    FM25L64B_Write(RST_Data + 10, (u8*) & IFS4, 2); //
249:                   //    FM25L64B_Write(RST_Data + 12, (u8*) & IFS5, 2); //
250:                   //    FM25L64B_Write(RST_Data + 14, (u8*) & IPC0, 2); //
251:                   //    FM25L64B_Write(RST_Data + 16, (u8*) & IPC1, 2); //
252:                   //    FM25L64B_Write(RST_Data + 18, (u8*) & IPC2, 2); //
253:                   //    FM25L64B_Write(RST_Data + 20, (u8*) & IPC3, 2); //
254:                   //    FM25L64B_Write(RST_Data + 22, (u8*) & IPC4, 2); //
255:                   //    FM25L64B_Write(RST_Data + 24, (u8*) & IPC5, 2); //
256:                   //    FM25L64B_Write(RST_Data + 26, (u8*) & IPC6, 2); //
257:                   //    FM25L64B_Write(RST_Data + 28, (u8*) & IPC7, 2); //
258:                   //    FM25L64B_Write(RST_Data + 30, (u8*) & IPC8, 2); //
259:                   //    FM25L64B_Write(RST_Data + 32, (u8*) & IPC9, 2); //
260:                   //    FM25L64B_Write(RST_Data + 34, (u8*) & IPC12, 2); //
261:                   //    FM25L64B_Write(RST_Data + 36, (u8*) & IPC15, 2); //
262:                   //    FM25L64B_Write(RST_Data + 38, (u8*) & IPC16, 2); //
263:                   //    FM25L64B_Write(RST_Data + 40, (u8*) & IEC0, 2); //
264:                   //    FM25L64B_Write(RST_Data + 42, (u8*) & IEC1, 2); //
265:                   //    FM25L64B_Write(RST_Data + 44, (u8*) & IEC2, 2); //
266:                   //    FM25L64B_Write(RST_Data + 46, (u8*) & IEC3, 2); //
267:                   //    FM25L64B_Write(RST_Data + 48, (u8*) & IEC4, 2); //
268:                   //    FM25L64B_Write(RST_Data + 50, (u8*) & IEC5, 2); //
269:                   //    FM25L64B_Write(RST_Data+14, tmp, 2); //
270:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
0003D8  800400     MOV INTCON1, W0
0003DA  600064     AND W0, #0x4, W0
0003DC  E00000     CP0 W0
0003DE  320001     BRA Z, 0x3E2
0003E0  A94080     BCLR INTCON1, #2
271:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
0003E2  800400     MOV INTCON1, W0
0003E4  600068     AND W0, #0x8, W0
0003E6  E00000     CP0 W0
0003E8  320001     BRA Z, 0x3EC
0003EA  A96080     BCLR INTCON1, #3
272:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
0003EC  800400     MOV INTCON1, W0
0003EE  600070     AND W0, #0x10, W0
0003F0  E00000     CP0 W0
0003F2  320001     BRA Z, 0x3F6
0003F4  A98080     BCLR INTCON1, #4
273:                   asm("GOTO __reset");
0003F6  040200     GOTO 0x200
0003F8  000000     NOP
274:               }
0003FA  FA8000     ULNK
275:               
276:               
277:               
