#include "HL6528.h"
#include <string.h>
//#include <math.h>
//#include <stdlib.h>
//#include "includes.h"
//#include <stdbool.h>
//#include "cJSON.h"


//extern OS_EVENT* sem1, *sem2; //上线拨号任务标志

//struct ATCommand {
const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
const uint8_t AT[] = {"AT\r\n"};
const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
const uint8_t OK[] = {"OK"};
const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
const uint8_t READY[] = {"+CPIN: READY"};
const uint8_t CIMI[] = {"AT+CIMI\r\n"};
const uint8_t CREG[] = {"AT+CREG?\r\n"};
const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
const uint8_t _5[] = {",5"};
const uint8_t _1[] = {",1"};
const uint8_t CSCA[] = {"AT+CSCA\r\n"};
//const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
static uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
//const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
//const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//移动ONENET
const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
const uint8_t CONNECT[] = {"CONNECT"};
const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
//} ATCmd;

//struct AT_Arg {
//    //    uint8_t KCNXCFG[] = {"AT+KCNXCFG,\"GPRS\",\"CMNET\"\r\n"};
//    uint8_t time; //规定时间内
//    uint8_t count; //规定次数
//    uint8_t *sendstr; //发送字符串
//    uint8_t sendstrlen; //发送字符串长度
//    uint8_t *checkstr; //对比字符串
//    uint8_t checkstrlen; //对比字符串长度
//    uint8_t errcode; //错误码
//};

//函数声明

static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
//static void HL6528_IOStart(void);
//static void HL6528_IOClose(void);
static void HL6528_GetIP_Port(void);

void HL6528_Init(void) {
    //初始化端口
    PWRON_TRIS = 0; //PWN_ON 6528芯片电源控制
    PWR_TRIS = 0; //外部控制6528芯片电源
    DSR_TRIS = 0; //数据设备请求    
    DTR_TRIS = 0; //数据终端请求
    RTS_TRIS = 0; //请求发送数据
    CTS_TRIS = 0; //请求接受数据  
    PWR = 0;
    PWRON = 0;
    CTS = 0;
    RTS = 0;
    DSR = 0;
    DTR = 0;
    //    UART2_Init();
}

bool HL6528_DialingIsERR(void) {
    uint8_t sta; //, cnt, cnt1, IP_bytes, Port_bytes;
    //    uint8_t str_tmp[50]; //存储端口号 [4]='\0'
    //
    //    HL6528_GetIP_Port(str_tmp);
    PWR = 1;
    PWRON = 1;
    CTS = 0;
    RTS = 0;
    DSR = 0;
    DTR = 0;
    OSTimeDlyHMSM(0, 0, 1, 0);
    if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
        if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
            if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//设置网络模式
                if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
                    HL6528_GetIP_Port();//刷新IP地址和端口号
                    if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
                        if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 7, 5)) {
                            sta = 0;
                        } else
                            sta = 6; //未开启TCP，
                    } else
                        sta = 5; //设置TCP失败
                } else
                    sta = 4; //设置APN的问题
            } else
                sta = 3; //手机信号未找到
        } else
            sta = 2; //手机卡未插入
    } else
        sta = 1; //模块损坏
    return sta;
}

void HL6528_Close(void) {
    uint8_t tmp[20];
    StrCmp stcp;
    ClearBuffer(BufferRead_UART2);
    do {
        DSR = 1; //切换数据至AT命令
        OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
        DSR = 0; //请求发送数据
        stcp.SourceData = tmp;
        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //获取mark
        stcp.CheckData = (uint8_t*) OK;
        stcp.Check_len = 2;
        stcp.GetData = NULL;
        stcp.Get_len = 0;
        stcp.Real_len = 0;
    } while (UARTDataIsRight(&stcp)); //等待接受成功下线返回OK
    if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//关闭并删除TCP的ID通道
        HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
    OSTimeDlyHMSM(0, 0, 1, 0); //延时1s    
    PWR = 0; //电源控制
    PWRON = 0; //电源关闭
    CTS = 0; //请求接受
    RTS = 0; //请求发送
    DSR = 0; //设备
    DTR = 0; //终端
    UART2_Close();
}

/*输入变量：发送字符串地址ss、接受字符串、接受字符串长度、发送字符串长度、对比字符串地址、对比字符串长度、发送间隔时间、发送次数**/
static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
    uint8_t cnt_tmp = 0;
    bool b_sta = false;
    StrCmp stcp;
    uint8_t tmp[50];
    do {
        cnt_tmp += 1;
        UART2_SendString(ss); //发送AT指令                               
        OSTimeDlyHMSM(0, 0, 3, 0); //延时1s
        U2Rx4Byte();
        stcp.SourceData = tmp;
        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //获取mark
        stcp.CheckData = (uint8_t*) cs;
        stcp.Check_len = csl;
        stcp.GetData = NULL;
        stcp.Get_len = 0;
        stcp.Real_len = 0;

        if (UARTDataIsRight(&stcp)) {
            b_sta = true;
            break;
        }

        if (cs1 != NULL) {//如果第二个校验数据不是NULL，那么进行第二个数据头的处理，判断处理。
            stcp.CheckData = (uint8_t*) cs1;
            if (UARTDataIsRight(&stcp)) {
                b_sta = true;
                break;
            }
        }

    } while (cnt > cnt_tmp);
    ClearBuffer(BufferRead_UART2);
    return b_sta;
}

//static void HL6528_IOStart(void) {
//    PWR = 1;
//    PWRON = 1;
//    CTS = 0;
//    RTS = 0;
//    DSR = 0;
//    DTR = 0;
//}
//
//static void HL6528_IOClose(void) {
//    PWRON = 0;
//    PWR = 0;
//    CTS = 1;
//    RTS = 1;
//    DSR = 1;
//    DTR = 1;
//}

static void HL6528_GetIP_Port(void) {
    struct WGC_ARG arg_tmp;
    uint8_t str_tmp[5]; //存储端口号
    uint8_t IP_bytes, Port_bytes;
    //    uint8_t *ptr_tmp = dat;

    WGC_Get_Arg(&arg_tmp); //获取WGC参数
    IP_bytes = strlen(arg_tmp.Net_arg.IP_Addr); //计算WGC参数中网络参数IP地址的字节数
    Port_bytes = my_itoa(arg_tmp.Net_arg.Port, str_tmp); //将port口转化为字符串
    CopyDat(KTCPCFG1, KTCPCFG, 16);
    CopyDat(KTCPCFG1 + 16, (const uint8_t*) arg_tmp.Net_arg.IP_Addr, IP_bytes);
    *(KTCPCFG1 + IP_bytes + 16) = '\"';
    *(KTCPCFG1 + IP_bytes + 17) = ',';
    CopyDat(KTCPCFG1 + IP_bytes + 18, (const uint8_t*) str_tmp, Port_bytes);
    //    for (cnt = 0; cnt < IP_bytes; cnt++)
    //        *(dat + cnt) = *(arg_tmp.Net_arg.IP_Addr + cnt);
    //    for (cnt = 0; cnt < Port_bytes; cnt++)
    //        *(dat + cnt) = *(str_tmp + cnt);
    *(KTCPCFG1 + IP_bytes + Port_bytes + 18) = '\r';
    *(KTCPCFG1 + IP_bytes + Port_bytes + 19) = '\n';
    *(KTCPCFG1 + IP_bytes + Port_bytes + 20) = '\0';
    //                    *(ptr_tmp + cnt + 3) = '\0'; 
}






