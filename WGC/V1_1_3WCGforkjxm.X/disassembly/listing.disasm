Disassembly Listing for V1_1_2WCGfor6528
Generated From:
C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/dist/default/production/V1_1_2WCGfor6528.X.production.elf
2017-9-1 19:23:18

---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Source/os_time.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             TIME MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TIME.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*
31:                *********************************************************************************************************
32:                *                                        DELAY TASK 'n' TICKS
33:                *
34:                * Description: This function is called to delay execution of the currently running task until the
35:                *              specified number of system ticks expires.  This, of course, directly equates to delaying
36:                *              the current task for some time to expire.  No delay will result If the specified delay is
37:                *              0.  If the specified delay is greater than 0 then, a context switch will result.
38:                *
39:                * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
40:                *                        Note that by specifying 0, the task will not be delayed.
41:                *
42:                * Returns    : none
43:                *********************************************************************************************************
44:                */
45:                
46:                void  OSTimeDly (INT32U ticks)
47:                {
004B46  BE0100     MOV.D W0, W2
48:                    INT8U      y;
49:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
50:                    OS_CPU_SR  cpu_sr = 0u;
51:                #endif
52:                
53:                
54:                
55:                    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
004B48  E24811     CP0.B OSIntNesting
004B4A  3A0019     BRA NZ, 0x4B7E
56:                        return;
57:                    }
58:                    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
004B4C  E24812     CP0.B OSLockNesting
004B4E  3A0017     BRA NZ, 0x4B7E
59:                        return;
60:                    }
61:                    if (ticks > 0u) {                            /* 0 means no delay!                                  */
004B50  500FE0     SUB W0, #0x0, [W15]
004B52  588FE0     SUBB W1, #0x0, [W15]
004B54  320014     BRA Z, 0x4B7E
62:                        OS_ENTER_CRITICAL();
004B56  800216     MOV SR, W6
004B58  200E00     MOV #0xE0, W0
004B5A  B72042     IOR SR
63:                        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
004B5C  8040E1     MOV OSTCBCur, W1
64:                        OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
004B5E  905A61     MOV.B [W1+30], W4
004B60  FB8204     ZE W4, W4
004B62  2161C5     MOV #0x161C, W5
004B64  905871     MOV.B [W1+31], W0
004B66  EAC000     COM.B W0, W0
004B68  7A43E5     MOV.B [W5+W4], W7
004B6A  604007     AND.B W0, W7, W0
004B6C  7A7280     MOV.B W0, [W5+W4]
65:                        if (OSRdyTbl[y] == 0u) {
004B6E  3A0003     BRA NZ, 0x4B76
66:                            OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
004B70  906001     MOV.B [W1+32], W0
004B72  EAC000     COM.B W0, W0
004B74  B66815     AND.B OSRdyGrp
67:                        }
68:                        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
004B76  9808B2     MOV W2, [W1+22]
004B78  9808C3     MOV W3, [W1+24]
69:                        OS_EXIT_CRITICAL();
004B7A  880216     MOV W6, SR
70:                        OS_Sched();                              /* Find next task to run!                             */
004B7C  07EB86     RCALL OS_Sched
004B7E  060000     RETURN
71:                    }
72:                }
73:                /*$PAGE*/
74:                /*
75:                *********************************************************************************************************
76:                *                                    DELAY TASK FOR SPECIFIED TIME
77:                *
78:                * Description: This function is called to delay execution of the currently running task until some time
79:                *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
80:                *              MILLISECONDS instead of ticks.
81:                *
82:                * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
83:                *              minutes   specifies the number of minutes (max. 59)
84:                *              seconds   specifies the number of seconds (max. 59)
85:                *              ms        specifies the number of milliseconds (max. 999)
86:                *
87:                * Returns    : OS_ERR_NONE
88:                *              OS_ERR_TIME_INVALID_MINUTES
89:                *              OS_ERR_TIME_INVALID_SECONDS
90:                *              OS_ERR_TIME_INVALID_MS
91:                *              OS_ERR_TIME_ZERO_DLY
92:                *              OS_ERR_TIME_DLY_ISR
93:                *
94:                * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
95:                *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
96:                *              set to 0.  The actual delay is rounded to the nearest tick.
97:                *********************************************************************************************************
98:                */
99:                
100:               #if OS_TIME_DLY_HMSM_EN > 0u
101:               INT8U  OSTimeDlyHMSM (INT8U   hours,
102:                                     INT8U   minutes,
103:                                     INT8U   seconds,
104:                                     INT16U  ms)
105:               {
004B80  FA0004     LNK #0x4
004B82  BE9F88     MOV.D W8, [W15++]
004B84  781F8A     MOV W10, [W15++]
004B86  BE9F8C     MOV.D W12, [W15++]
004B88  784500     MOV.B W0, W10
004B8A  784481     MOV.B W1, W9
004B8C  784402     MOV.B W2, W8
106:                   INT32U ticks;
107:               
108:               
109:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
004B90  E24811     CP0.B OSIntNesting
004B92  3A0038     BRA NZ, 0x4C04
110:                       return (OS_ERR_TIME_DLY_ISR);
004B8E  B3C551     MOV.B #0x55, W1
111:                   }
112:                   if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
004B96  E24812     CP0.B OSLockNesting
004B98  3A0035     BRA NZ, 0x4C04
113:                       return (OS_ERR_SCHED_LOCKED);
004B94  B3C321     MOV.B #0x32, W1
114:                   }
115:               #if OS_ARG_CHK_EN > 0u
116:                   if (hours == 0u) {
004B9A  E0040A     CP0.B W10
004B9C  3A0008     BRA NZ, 0x4BAE
117:                       if (minutes == 0u) {
004B9E  E00409     CP0.B W9
004BA0  3A0006     BRA NZ, 0x4BAE
118:                           if (seconds == 0u) {
004BA2  E00408     CP0.B W8
004BA4  3A0008     BRA NZ, 0x4BB6
119:                               if (ms == 0u) {
004BA8  E00003     CP0 W3
004BAA  3A0009     BRA NZ, 0x4BBE
004BAC  37002B     BRA 0x4C04
120:                                   return (OS_ERR_TIME_ZERO_DLY);
004BA6  B3C541     MOV.B #0x54, W1
121:                               }
122:                           }
123:                       }
124:                   }
125:                   if (minutes > 59u) {
004BB0  B3C3B0     MOV.B #0x3B, W0
004BB2  54CF80     SUB.B W9, W0, [W15]
004BB4  3E0027     BRA GTU, 0x4C04
126:                       return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
004BAE  B3C511     MOV.B #0x51, W1
127:                   }
128:                   if (seconds > 59u) {
004BB8  B3C3B0     MOV.B #0x3B, W0
004BBA  544F80     SUB.B W8, W0, [W15]
004BBC  3E0023     BRA GTU, 0x4C04
129:                       return (OS_ERR_TIME_INVALID_SECONDS);
004BB6  B3C521     MOV.B #0x52, W1
130:                   }
131:                   if (ms > 999u) {
004BC0  203E70     MOV #0x3E7, W0
004BC2  518F80     SUB W3, W0, [W15]
004BC4  3E001F     BRA GTU, 0x4C04
132:                       return (OS_ERR_TIME_INVALID_MS);
004BBE  B3C531     MOV.B #0x53, W1
133:                   }
134:               #endif
135:                                                                /* Compute the total number of clock ticks required.. */
136:                                                                /* .. (rounded to the nearest tick)                   */
137:                   ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
004BD2  FB8209     ZE W9, W4
004BD4  2003C0     MOV #0x3C, W0
004BD6  B82200     MUL.UU W4, W0, W4
004BD8  FB800A     ZE W10, W0
004BDA  EB0080     CLR W1
004BDC  20E102     MOV #0xE10, W2
004BDE  200003     MOV #0x0, W3
004BE0  9FBF94     MOV W4, [W15-14]
004BE2  9FBFA5     MOV W5, [W15-12]
004BE4  07DD4E     RCALL 0x682
004BE6  97BA1F     MOV [W15-14], W4
004BE8  97BAAF     MOV [W15-12], W5
004BEA  400004     ADD W0, W4, W0
004BEC  488085     ADDC W1, W5, W1
004BEE  FB8408     ZE W8, W8
004BF0  EB0480     CLR W9
004BF2  440000     ADD W8, W0, W0
004BF4  4C8081     ADDC W9, W1, W1
004BF6  203E82     MOV #0x3E8, W2
004BF8  200003     MOV #0x0, W3
004BFA  07DD43     RCALL 0x682
004BFC  40000C     ADD W0, W12, W0
004BFE  48808D     ADDC W1, W13, W1
138:                         + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
004BC6  E80000     INC W0, W0
004BC8  B81800     MUL.UU W3, W0, W0
004BCA  203E82     MOV #0x3E8, W2
004BCC  200003     MOV #0x0, W3
004BCE  07DD46     RCALL 0x65C
004BD0  BE0600     MOV.D W0, W12
139:                   OSTimeDly(ticks);
004C00  07FFA2     RCALL OSTimeDly
140:                   return (OS_ERR_NONE);
004C02  EB4080     CLR.B W1
141:               }
004C04  784001     MOV.B W1, W0
142:               #endif
143:               /*$PAGE*/
144:               /*
145:               *********************************************************************************************************
146:               *                                        RESUME A DELAYED TASK
147:               *
148:               * Description: This function is used resume a task that has been delayed through a call to either
149:               *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
150:               *              task that is waiting for an event with timeout.  This would make the task look
151:               *              like a timeout occurred.
152:               *
153:               * Arguments  : prio                      specifies the priority of the task to resume
154:               *
155:               * Returns    : OS_ERR_NONE               Task has been resumed
156:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
157:               *                                        (i.e. >= OS_LOWEST_PRIO)
158:               *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
159:               *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
160:               *********************************************************************************************************
161:               */
162:               
163:               #if OS_TIME_DLY_RESUME_EN > 0u
164:               INT8U  OSTimeDlyResume (INT8U prio)
165:               {
166:                   OS_TCB    *ptcb;
167:               #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
168:                   OS_CPU_SR  cpu_sr = 0u;
169:               #endif
170:               
171:               
172:               
173:                   if (prio >= OS_LOWEST_PRIO) {
174:                       return (OS_ERR_PRIO_INVALID);
175:                   }
176:                   OS_ENTER_CRITICAL();
177:                   ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
178:                   if (ptcb == (OS_TCB *)0) {
179:                       OS_EXIT_CRITICAL();
180:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
181:                   }
182:                   if (ptcb == OS_TCB_RESERVED) {
183:                       OS_EXIT_CRITICAL();
184:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
185:                   }
186:                   if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
187:                       OS_EXIT_CRITICAL();
188:                       return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
189:                   }
190:               
191:                   ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
192:                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
193:                       ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
194:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
195:                   } else {
196:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
197:                   }
198:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
199:                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
200:                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
201:                       OS_EXIT_CRITICAL();
202:                       OS_Sched();                                            /* See if this is new highest priority  */
203:                   } else {
204:                       OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
205:                   }
206:                   return (OS_ERR_NONE);
207:               }
208:               #endif
209:               /*$PAGE*/
210:               /*
211:               *********************************************************************************************************
212:               *                                       GET CURRENT SYSTEM TIME
213:               *
214:               * Description: This function is used by your application to obtain the current value of the 32-bit
215:               *              counter which keeps track of the number of clock ticks.
216:               *
217:               * Arguments  : none
218:               *
219:               * Returns    : The current value of OSTime
220:               *********************************************************************************************************
221:               */
222:               
223:               #if OS_TIME_GET_SET_EN > 0u
224:               INT32U  OSTimeGet (void)
225:               {
226:                   INT32U     ticks;
227:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
228:                   OS_CPU_SR  cpu_sr = 0u;
229:               #endif
230:               
231:               
232:               
233:                   OS_ENTER_CRITICAL();
234:                   ticks = OSTime;
235:                   OS_EXIT_CRITICAL();
236:                   return (ticks);
237:               }
238:               #endif
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                          SET SYSTEM CLOCK
243:               *
244:               * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
245:               *
246:               * Arguments  : ticks      specifies the new value that OSTime needs to take.
247:               *
248:               * Returns    : none
249:               *********************************************************************************************************
250:               */
251:               
252:               #if OS_TIME_GET_SET_EN > 0u
253:               void  OSTimeSet (INT32U ticks)
254:               {
255:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
256:                   OS_CPU_SR  cpu_sr = 0u;
257:               #endif
258:               
259:               
260:               
261:                   OS_ENTER_CRITICAL();
262:                   OSTime = ticks;
263:                   OS_EXIT_CRITICAL();
264:               }
265:               #endif
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Source/os_task.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                            TASK MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TASK.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*$PAGE*/
31:                /*
32:                *********************************************************************************************************
33:                *                                      CHANGE PRIORITY OF A TASK
34:                *
35:                * Description: This function allows you to change the priority of a task dynamically.  Note that the new
36:                *              priority MUST be available.
37:                *
38:                * Arguments  : oldp     is the old priority
39:                *
40:                *              newp     is the new priority
41:                *
42:                * Returns    : OS_ERR_NONE            is the call was successful
43:                *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
44:                *                                     (i.e. >= OS_LOWEST_PRIO)
45:                *              OS_ERR_PRIO_EXIST      if the new priority already exist.
46:                *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
47:                *                                     not exist.
48:                *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
49:                *********************************************************************************************************
50:                */
51:                
52:                #if OS_TASK_CHANGE_PRIO_EN > 0u
53:                INT8U  OSTaskChangePrio (INT8U  oldprio,
54:                                         INT8U  newprio)
55:                {
0025DC  4787E8     ADD W15, #0x8, W15
0025DE  BE9F88     MOV.D W8, [W15++]
0025E0  BE9F8A     MOV.D W10, [W15++]
0025E2  BE9F8C     MOV.D W12, [W15++]
0025E4  781F8E     MOV W14, [W15++]
0025E6  784300     MOV.B W0, W6
56:                #if (OS_EVENT_EN)
57:                    OS_EVENT  *pevent;
58:                #if (OS_EVENT_MULTI_EN > 0u)
59:                    OS_EVENT **pevents;
60:                #endif
61:                #endif
62:                    OS_TCB    *ptcb;
63:                    INT8U      y_new;
64:                    INT8U      x_new;
65:                    INT8U      y_old;
66:                    OS_PRIO    bity_new;
67:                    OS_PRIO    bitx_new;
68:                    OS_PRIO    bity_old;
69:                    OS_PRIO    bitx_old;
70:                #if OS_CRITICAL_METHOD == 3u
71:                    OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
72:                #endif
73:                
74:                
75:                /*$PAGE*/
76:                #if OS_ARG_CHK_EN > 0u
77:                    if (oldprio >= OS_LOWEST_PRIO) {
0025E8  534FE9     SUB.B W6, #0x9, [W15]
0025EA  360003     BRA LEU, 0x25F2
78:                        if (oldprio != OS_PRIO_SELF) {
0025EE  434FE1     ADD.B W6, #0x1, [W15]
0025F0  3A0091     BRA NZ, 0x2714
79:                            return (OS_ERR_PRIO_INVALID);
0025EC  B3C2A2     MOV.B #0x2A, W2
80:                        }
81:                    }
82:                    if (newprio >= OS_LOWEST_PRIO) {
0025F4  50CFE9     SUB.B W1, #0x9, [W15]
0025F6  3E008E     BRA GTU, 0x2714
83:                        return (OS_ERR_PRIO_INVALID);
0025F2  B3C2A2     MOV.B #0x2A, W2
84:                    }
85:                #endif
86:                    OS_ENTER_CRITICAL();
0025F8  800215     MOV SR, W5
0025FA  200E00     MOV #0xE0, W0
0025FC  B72042     IOR SR
87:                    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
0025FE  FB8201     ZE W1, W4
002600  420104     ADD W4, W4, W2
002602  2169E3     MOV #0x169E, W3
002604  790163     MOV [W3+W2], W2
002606  E00002     CP0 W2
002608  320003     BRA Z, 0x2610
88:                        OS_EXIT_CRITICAL();
00260A  880215     MOV W5, SR
89:                        return (OS_ERR_PRIO_EXIST);
00260C  B3C282     MOV.B #0x28, W2
00260E  370082     BRA 0x2714
90:                    }
91:                    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
002610  434FE1     ADD.B W6, #0x1, [W15]
002612  3A0002     BRA NZ, 0x2618
92:                        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
002614  8040E0     MOV OSTCBCur, W0
002616  905B40     MOV.B [W0+28], W6
93:                    }
94:                    ptcb = OSTCBPrioTbl[oldprio];
002618  FB8006     ZE W6, W0
00261A  400000     ADD W0, W0, W0
00261C  2169E8     MOV #0x169E, W8
00261E  780168     MOV [W8+W0], W2
95:                    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
002620  E00002     CP0 W2
002622  3A0003     BRA NZ, 0x262A
96:                        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
002624  880215     MOV W5, SR
97:                        return (OS_ERR_PRIO);
002626  B3C292     MOV.B #0x29, W2
002628  370075     BRA 0x2714
98:                    }
99:                    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
00262A  510FE1     SUB W2, #0x1, [W15]
00262C  3A0003     BRA NZ, 0x2634
100:                       OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
00262E  880215     MOV W5, SR
101:                       return (OS_ERR_TASK_NOT_EXIST);
002630  B3C432     MOV.B #0x43, W2
002632  370070     BRA 0x2714
102:                   }
103:               #if OS_LOWEST_PRIO <= 63u
104:                   y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
002634  FB8601     ZE W1, W12
002636  DE6643     LSR W12, #3, W12
105:                   x_new                 = (INT8U)(newprio & 0x07u);
002638  60C1E7     AND.B W1, #0x7, W3
00263A  9FF783     MOV.B W3, [W15-16]
106:               #else
107:                   y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
108:                   x_new                 = (INT8U)(newprio & 0x0Fu);
109:               #endif
110:                   bity_new              = (OS_PRIO)(1uL << y_new);
00263C  FB818C     ZE W12, W3
00263E  200016     MOV #0x1, W6
002640  200007     MOV #0x0, W7
002642  780483     MOV W3, W9
002644  E90489     DEC W9, W9
002646  330003     BRA N, 0x264E
002648  430306     ADD W6, W6, W6
00264A  4B8387     ADDC W7, W7, W7
00264C  37FFFB     BRA 0x2644
00264E  784386     MOV.B W6, W7
111:                   bitx_new              = (OS_PRIO)(1uL << x_new);
002650  97F50F     MOV.B [W15-16], W10
002652  FB830A     ZE W10, W6
002654  20001A     MOV #0x1, W10
002656  20000B     MOV #0x0, W11
002658  E90306     DEC W6, W6
00265A  330003     BRA N, 0x2662
00265C  45050A     ADD W10, W10, W10
00265E  4D858B     ADDC W11, W11, W11
002660  37FFFB     BRA 0x2658
002662  9FB7EA     MOV W10, [W15-20]
002664  9FB7FB     MOV W11, [W15-18]
002666  78430A     MOV.B W10, W6
112:               
113:                   OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
002668  440000     ADD W8, W0, W0
00266A  EB0800     CLR [W0]
114:                   OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00266C  420204     ADD W4, W4, W4
00266E  7A3402     MOV W2, [W8+W4]
115:                   y_old                 =  ptcb->OSTCBY;
116:                   bity_old              =  ptcb->OSTCBBitY;
002670  906502     MOV.B [W2+32], W10
117:                   bitx_old              =  ptcb->OSTCBBitX;
002672  905C72     MOV.B [W2+31], W8
118:                   if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
002674  905A62     MOV.B [W2+30], W4
002676  FB8204     ZE W4, W4
002678  2161C9     MOV #0x161C, W9
00267A  7A4069     MOV.B [W9+W4], W0
00267C  604688     AND.B W0, W8, W13
00267E  32000C     BRA Z, 0x2698
119:                        OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
002680  EAC688     COM.B W8, W13
002682  60400D     AND.B W0, W13, W0
002684  7A7480     MOV.B W0, [W9+W4]
120:                        if (OSRdyTbl[y_old] == 0u) {
002686  3A0002     BRA NZ, 0x268C
121:                            OSRdyGrp &= (OS_PRIO)~bity_old;
002688  EAC00A     COM.B W10, W0
00268A  B66815     AND.B OSRdyGrp
122:                        }
123:                        OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
00268C  784007     MOV.B W7, W0
00268E  B76815     IOR.B OSRdyGrp
124:                        OSRdyTbl[y_new] |= bitx_new;
002690  2161C0     MOV #0x161C, W0
002692  79C4E0     MOV.B [W0+W3], W9
002694  734489     IOR.B W6, W9, W9
002696  79F009     MOV.B W9, [W0+W3]
125:                   }
126:               
127:               #if (OS_EVENT_EN)
128:                   pevent = ptcb->OSTCBEventPtr;
002698  900812     MOV [W2+18], W0
129:                   if (pevent != (OS_EVENT *)0) {
00269A  E00000     CP0 W0
00269C  320013     BRA Z, 0x26C4
130:                       pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
00269E  400484     ADD W0, W4, W9
0026A0  EAC688     COM.B W8, W13
0026A2  9044F9     MOV.B [W9+7], W9
0026A4  66C489     AND.B W13, W9, W9
0026A6  400684     ADD W0, W4, W13
0026A8  9846F9     MOV.B W9, [W13+7]
131:                       if (pevent->OSEventTbl[y_old] == 0u) {
0026AA  E00409     CP0.B W9
0026AC  3A0004     BRA NZ, 0x26B6
132:                           pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0026AE  EAC48A     COM.B W10, W9
0026B0  9046E0     MOV.B [W0+6], W13
0026B2  66C489     AND.B W13, W9, W9
0026B4  984069     MOV.B W9, [W0+6]
133:                       }
134:                       pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
0026B6  9044E0     MOV.B [W0+6], W9
0026B8  74C487     IOR.B W9, W7, W9
0026BA  984069     MOV.B W9, [W0+6]
135:                       pevent->OSEventTbl[y_new] |= bitx_new;
0026BC  400483     ADD W0, W3, W9
0026BE  904079     MOV.B [W9+7], W0
0026C0  734000     IOR.B W6, W0, W0
0026C2  9844F0     MOV.B W0, [W9+7]
136:                   }
137:               #if (OS_EVENT_MULTI_EN > 0u)
138:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
0026C4  900CA2     MOV [W2+20], W9
0026C6  E00009     CP0 W9
0026C8  320018     BRA Z, 0x26FA
139:                       pevents =  ptcb->OSTCBEventMultiPtr;
140:                       pevent  = *pevents;
0026CA  780019     MOV [W9], W0
141:                       while (pevent != (OS_EVENT *)0) {
0026CC  370014     BRA 0x26F6
0026F6  E00000     CP0 W0
0026F8  3AFFEA     BRA NZ, 0x26CE
142:                           pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
0026CE  400684     ADD W0, W4, W13
0026D0  EAC708     COM.B W8, W14
0026D2  9046FD     MOV.B [W13+7], W13
0026D4  67468D     AND.B W14, W13, W13
0026D6  400704     ADD W0, W4, W14
0026D8  98477D     MOV.B W13, [W14+7]
143:                           if (pevent->OSEventTbl[y_old] == 0u) {
0026DA  E0040D     CP0.B W13
0026DC  3A0004     BRA NZ, 0x26E6
144:                               pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0026DE  EAC68A     COM.B W10, W13
0026E0  904760     MOV.B [W0+6], W14
0026E2  67468D     AND.B W14, W13, W13
0026E4  98406D     MOV.B W13, [W0+6]
145:                           }
146:                           pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
0026E6  9046E0     MOV.B [W0+6], W13
0026E8  76C687     IOR.B W13, W7, W13
0026EA  98406D     MOV.B W13, [W0+6]
147:                           pevent->OSEventTbl[y_new] |= bitx_new;
0026EC  400683     ADD W0, W3, W13
0026EE  90407D     MOV.B [W13+7], W0
0026F0  734000     IOR.B W6, W0, W0
0026F2  9846F0     MOV.B W0, [W13+7]
148:                           pevents++;
149:                           pevent                     = *pevents;
0026F4  780059     MOV [++W9], W0
150:                       }
151:                   }
152:               #endif
153:               #endif
154:               
155:                   ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
0026FA  985941     MOV.B W1, [W2+28]
156:                   ptcb->OSTCBY    = y_new;
0026FC  98596C     MOV.B W12, [W2+30]
157:                   ptcb->OSTCBX    = x_new;
0026FE  97F18F     MOV.B [W15-16], W3
002700  985953     MOV.B W3, [W2+29]
158:                   ptcb->OSTCBBitY = bity_new;
002702  986107     MOV.B W7, [W2+32]
159:                   ptcb->OSTCBBitX = bitx_new;
002704  985976     MOV.B W6, [W2+31]
160:                   OS_EXIT_CRITICAL();
002706  880215     MOV W5, SR
161:                   if (OSRunning == OS_TRUE) {
00270A  BFC816     MOV.B OSRunning, WREG
00270C  504FE1     SUB.B W0, #0x1, [W15]
00270E  3A0002     BRA NZ, 0x2714
162:                       OS_Sched();                                         /* Find new highest priority task          */
002710  07FDBC     RCALL OS_Sched
163:                   }
164:                   return (OS_ERR_NONE);
002708  EB4100     CLR.B W2
002712  EB4100     CLR.B W2
165:               }
002714  784002     MOV.B W2, W0
002716  78074F     MOV [--W15], W14
002718  BE064F     MOV.D [--W15], W12
00271A  BE054F     MOV.D [--W15], W10
00271C  BE044F     MOV.D [--W15], W8
00271E  B1008F     SUB #0x8, W15
002720  060000     RETURN
166:               #endif
167:               /*$PAGE*/
168:               /*
169:               *********************************************************************************************************
170:               *                                            CREATE A TASK
171:               *
172:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
173:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
174:               *              created by an ISR.
175:               *
176:               * Arguments  : task     is a pointer to the task's code
177:               *
178:               *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
179:               *                       the task when the task first executes.  Where the task is concerned it thinks
180:               *                       it was invoked and passed the argument 'p_arg' as follows:
181:               *
182:               *                           void Task (void *p_arg)
183:               *                           {
184:               *                               for (;;) {
185:               *                                   Task code;
186:               *                               }
187:               *                           }
188:               *
189:               *              ptos     is a pointer to the task's top of stack.  If the configuration constant
190:               *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
191:               *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
192:               *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
193:               *                       lowest memory location of the stack and the stack will grow with increasing
194:               *                       memory locations.
195:               *
196:               *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
197:               *                       lower the number, the higher the priority.
198:               *
199:               * Returns    : OS_ERR_NONE                      if the function was successful.
200:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
201:               *                                               (each task MUST have a unique priority).
202:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
203:               *                                               allowed (i.e. >= OS_LOWEST_PRIO)
204:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
205:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
206:               *                                               operation started.
207:               *********************************************************************************************************
208:               */
209:               
210:               #if OS_TASK_CREATE_EN > 0u
211:               INT8U  OSTaskCreate (void   (*task)(void *p_arg),
212:                                    void    *p_arg,
213:                                    OS_STK  *ptos,
214:                                    INT8U    prio)
215:               {
002722  BE9F88     MOV.D W8, [W15++]
002724  781F8A     MOV W10, [W15++]
002726  780300     MOV W0, W6
002728  784403     MOV.B W3, W8
216:                   OS_STK     *psp;
217:                   INT8U       err;
218:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
219:                   OS_CPU_SR   cpu_sr = 0u;
220:               #endif
221:               
222:               
223:               
224:               #ifdef OS_SAFETY_CRITICAL_IEC61508
225:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
226:                       OS_SAFETY_CRITICAL_EXCEPTION();
227:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
228:                   }
229:               #endif
230:               
231:               #if OS_ARG_CHK_EN > 0u
232:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
00272C  544FEA     SUB.B W8, #0xA, [W15]
00272E  3E002B     BRA GTU, 0x2786
233:                       return (OS_ERR_PRIO_INVALID);
00272A  B3C2AA     MOV.B #0x2A, W10
234:                   }
235:               #endif
236:                   OS_ENTER_CRITICAL();
002730  800213     MOV SR, W3
002732  200E00     MOV #0xE0, W0
002734  B72042     IOR SR
237:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
002736  E24811     CP0.B OSIntNesting
002738  320003     BRA Z, 0x2740
238:                       OS_EXIT_CRITICAL();
00273A  880213     MOV W3, SR
239:                       return (OS_ERR_TASK_CREATE_ISR);
00273C  454572     ADD.B W10, #0x12, W10
00273E  370023     BRA 0x2786
240:                   }
241:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
002740  FB8488     ZE W8, W9
002742  448489     ADD W9, W9, W9
002744  2169E4     MOV #0x169E, W4
002746  7C82E4     MOV [W4+W9], W5
002748  E00005     CP0 W5
00274A  3A001B     BRA NZ, 0x2782
242:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
00274C  420489     ADD W4, W9, W9
00274E  200014     MOV #0x1, W4
002750  780C84     MOV W4, [W9]
243:                                                            /* ... the same thing until task is created.              */
244:                       OS_EXIT_CRITICAL();
002752  880213     MOV W3, SR
245:                       psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
002754  EB0180     CLR W3
002756  780006     MOV W6, W0
002758  071405     RCALL OSTaskStkInit
246:                       err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00275A  B83360     MUL.UU W6, #0, W6
00275C  B82260     MUL.UU W4, #0, W4
00275E  B81160     MUL.UU W2, #0, W2
002760  780080     MOV W0, W1
002762  784008     MOV.B W8, W0
002764  07FED3     RCALL OS_TCBInit
002766  784500     MOV.B W0, W10
247:                       if (err == OS_ERR_NONE) {
002768  E0040A     CP0.B W10
00276A  3A0005     BRA NZ, 0x2776
248:                           if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
00276C  BFC816     MOV.B OSRunning, WREG
00276E  504FE1     SUB.B W0, #0x1, [W15]
002770  3A000A     BRA NZ, 0x2786
249:                               OS_Sched();
002772  07FD8B     RCALL OS_Sched
002774  370008     BRA 0x2786
250:                           }
251:                       } else {
252:                           OS_ENTER_CRITICAL();
002776  800212     MOV SR, W2
002778  200E00     MOV #0xE0, W0
00277A  B72042     IOR SR
253:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00277C  EB0C80     CLR [W9]
254:                           OS_EXIT_CRITICAL();
00277E  880212     MOV W2, SR
002780  370002     BRA 0x2786
255:                       }
256:                       return (err);
257:                   }
258:                   OS_EXIT_CRITICAL();
002782  880213     MOV W3, SR
259:                   return (OS_ERR_PRIO_EXIST);
002784  B3C28A     MOV.B #0x28, W10
260:               }
002786  78400A     MOV.B W10, W0
002788  78054F     MOV [--W15], W10
00278A  BE044F     MOV.D [--W15], W8
00278C  060000     RETURN
261:               #endif
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                  CREATE A TASK (Extended Version)
266:               *
267:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
268:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
269:               *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
270:               *              additional information about a task to be specified.
271:               *
272:               * Arguments  : task      is a pointer to the task's code
273:               *
274:               *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
275:               *                        the task when the task first executes.  Where the task is concerned it thinks
276:               *                        it was invoked and passed the argument 'p_arg' as follows:
277:               *
278:               *                            void Task (void *p_arg)
279:               *                            {
280:               *                                for (;;) {
281:               *                                    Task code;
282:               *                                }
283:               *                            }
284:               *
285:               *              ptos      is a pointer to the task's top of stack.  If the configuration constant
286:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
287:               *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
288:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
289:               *                        lowest memory location of the stack and the stack will grow with increasing
290:               *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
291:               *
292:               *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
293:               *                        lower the number, the higher the priority.
294:               *
295:               *              id        is the task's ID (0..65535)
296:               *
297:               *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
298:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
299:               *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
300:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
301:               *                        HIGHEST memory location of the stack and the stack will grow with increasing
302:               *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
303:               *
304:               *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
305:               *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
306:               *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
307:               *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
308:               *                        available on the stack.
309:               *
310:               *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
311:               *                        For example, this user memory can hold the contents of floating-point registers
312:               *                        during a context switch, the time each task takes to execute, the number of times
313:               *                        the task has been switched-in, etc.
314:               *
315:               *              opt       contains additional information (or options) about the behavior of the task.  The
316:               *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
317:               *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
318:               *
319:               *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
320:               *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
321:               *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
322:               *                                                 during a context switch.
323:               *
324:               * Returns    : OS_ERR_NONE                      if the function was successful.
325:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
326:               *                                               (each task MUST have a unique priority).
327:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
328:               *                                               allowed (i.e. > OS_LOWEST_PRIO)
329:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
330:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
331:               *                                               operation started.
332:               *********************************************************************************************************
333:               */
334:               /*$PAGE*/
335:               #if OS_TASK_CREATE_EXT_EN > 0u
336:               INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
337:                                       void    *p_arg,
338:                                       OS_STK  *ptos,
339:                                       INT8U    prio,
340:                                       INT16U   id,
341:                                       OS_STK  *pbos,
342:                                       INT32U   stk_size,
343:                                       void    *pext,
344:                                       INT16U   opt)
345:               {
002BA0  4787EA     ADD W15, #0xA, W15
002BA2  BE9F88     MOV.D W8, [W15++]
002BA4  BE9F8A     MOV.D W10, [W15++]
002BA6  BE9F8C     MOV.D W12, [W15++]
002BA8  781F8E     MOV W14, [W15++]
002BAA  9FB7F0     MOV W0, [W15-18]
002BAC  9FB7E1     MOV W1, [W15-20]
002BAE  780702     MOV W2, W14
002BB0  784403     MOV.B W3, W8
002BB2  9FB7D4     MOV W4, [W15-22]
002BB4  780485     MOV W5, W9
002BB6  BE0506     MOV.D W6, W10
002BB8  97B68F     MOV [W15-32], W13
346:                   OS_STK     *psp;
347:                   INT8U       err;
348:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
349:                   OS_CPU_SR   cpu_sr = 0u;
350:               #endif
351:               
352:               
353:               
354:               #ifdef OS_SAFETY_CRITICAL_IEC61508
355:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
356:                       OS_SAFETY_CRITICAL_EXCEPTION();
357:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
358:                   }
359:               #endif
360:               
361:               #if OS_ARG_CHK_EN > 0u
362:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
002BBC  544FEA     SUB.B W8, #0xA, [W15]
002BBE  3E0036     BRA GTU, 0x2C2C
363:                       return (OS_ERR_PRIO_INVALID);
002BBA  B3C2A3     MOV.B #0x2A, W3
364:                   }
365:               #endif
366:                   OS_ENTER_CRITICAL();
002BC0  800213     MOV SR, W3
002BC2  200E00     MOV #0xE0, W0
002BC4  B72042     IOR SR
367:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
002BC6  E24811     CP0.B OSIntNesting
002BC8  320003     BRA Z, 0x2BD0
368:                       OS_EXIT_CRITICAL();
002BCA  880213     MOV W3, SR
369:                       return (OS_ERR_TASK_CREATE_ISR);
002BCC  B3C3C3     MOV.B #0x3C, W3
002BCE  37002E     BRA 0x2C2C
370:                   }
371:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
002BD0  FB8608     ZE W8, W12
002BD2  46060C     ADD W12, W12, W12
002BD4  2169E1     MOV #0x169E, W1
002BD6  7E0161     MOV [W1+W12], W2
002BD8  E00002     CP0 W2
002BDA  3A0026     BRA NZ, 0x2C28
372:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
002BDC  40860C     ADD W1, W12, W12
002BDE  200011     MOV #0x1, W1
002BE0  780E01     MOV W1, [W12]
373:                                                            /* ... the same thing until task is created.              */
374:                       OS_EXIT_CRITICAL();
002BE2  880213     MOV W3, SR
375:               
376:               #if (OS_TASK_STAT_STK_CHK_EN > 0u)
377:                       OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
002BE4  78008D     MOV W13, W1
002BE6  BE0106     MOV.D W6, W2
002BE8  780009     MOV W9, W0
002BEA  07FFCF     RCALL OS_TaskStkClr
378:               #endif
379:               
380:                       psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
002BEC  78018D     MOV W13, W3
002BEE  78010E     MOV W14, W2
002BF0  97B0EF     MOV [W15-20], W1
002BF2  97B07F     MOV [W15-18], W0
002BF4  0711B7     RCALL OSTaskStkInit
381:                       err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
002BF6  78038D     MOV W13, W7
002BF8  97B31F     MOV [W15-30], W6
002BFA  BE020A     MOV.D W10, W4
002BFC  97B1DF     MOV [W15-22], W3
002BFE  780109     MOV W9, W2
002C00  780080     MOV W0, W1
002C02  784008     MOV.B W8, W0
002C04  07FC83     RCALL OS_TCBInit
002C06  784180     MOV.B W0, W3
382:                       if (err == OS_ERR_NONE) {
002C08  E00403     CP0.B W3
002C0A  3A0008     BRA NZ, 0x2C1C
383:                           if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
002C0C  208161     MOV #0x816, W1
002C0E  784091     MOV.B [W1], W1
002C10  50CFE1     SUB.B W1, #0x1, [W15]
002C12  3A000C     BRA NZ, 0x2C2C
384:                               OS_Sched();
002C14  9FBF83     MOV W3, [W15-16]
002C16  07FB39     RCALL OS_Sched
002C18  97B98F     MOV [W15-16], W3
002C1A  370008     BRA 0x2C2C
385:                           }
386:                       } else {
387:                           OS_ENTER_CRITICAL();
002C1C  800211     MOV SR, W1
002C1E  200E00     MOV #0xE0, W0
002C20  B72042     IOR SR
388:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
002C22  EB0E00     CLR [W12]
389:                           OS_EXIT_CRITICAL();
002C24  880211     MOV W1, SR
002C26  370002     BRA 0x2C2C
390:                       }
391:                       return (err);
392:                   }
393:                   OS_EXIT_CRITICAL();
002C28  880213     MOV W3, SR
394:                   return (OS_ERR_PRIO_EXIST);
002C2A  B3C283     MOV.B #0x28, W3
395:               }
002C2C  784003     MOV.B W3, W0
396:               #endif
397:               /*$PAGE*/
398:               /*
399:               *********************************************************************************************************
400:               *                                            DELETE A TASK
401:               *
402:               * Description: This function allows you to delete a task.  The calling task can delete itself by
403:               *              its own priority number.  The deleted task is returned to the dormant state and can be
404:               *              re-activated by creating the deleted task again.
405:               *
406:               * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
407:               *                      the current task without knowing its priority level by setting 'prio' to
408:               *                      OS_PRIO_SELF.
409:               *
410:               * Returns    : OS_ERR_NONE             if the call is successful
411:               *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
412:               *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
413:               *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
414:               *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
415:               *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
416:               *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
417:               *
418:               * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
419:               *                    a) by making it not ready
420:               *                    b) by removing it from any wait lists
421:               *                    c) by preventing OSTimeTick() from making the task ready to run.
422:               *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
423:               *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
424:               *                 the next instruction following the enable interrupt instruction is ignored.
425:               *              3) An ISR cannot delete a task.
426:               *              4) The lock nesting counter is incremented because, for a brief instant, if the current
427:               *                 task is being deleted, the current task would not be able to be rescheduled because it
428:               *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
429:               *                 from being schedule.  This means that an ISR would return to the current task which is
430:               *                 being deleted.  The rest of the deletion would thus be able to be completed.
431:               *********************************************************************************************************
432:               */
433:               
434:               #if OS_TASK_DEL_EN > 0u
435:               INT8U  OSTaskDel (INT8U prio)
436:               {
00278E  BE9F88     MOV.D W8, [W15++]
002790  781F8A     MOV W10, [W15++]
002792  784480     MOV.B W0, W9
437:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
438:                   OS_FLAG_NODE *pnode;
439:               #endif
440:                   OS_TCB       *ptcb;
441:               #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
442:                   OS_CPU_SR     cpu_sr = 0u;
443:               #endif
444:               
445:               
446:               
447:                   if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
002796  E24811     CP0.B OSIntNesting
002798  3A0066     BRA NZ, 0x2866
448:                       return (OS_ERR_TASK_DEL_ISR);
002794  B3C400     MOV.B #0x40, W0
449:                   }
450:                   if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00279C  54CFEA     SUB.B W9, #0xA, [W15]
00279E  320063     BRA Z, 0x2866
451:                       return (OS_ERR_TASK_DEL_IDLE);
00279A  E9C000     DEC2.B W0, W0
452:                   }
453:               #if OS_ARG_CHK_EN > 0u
454:                   if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
0027A0  54CFE9     SUB.B W9, #0x9, [W15]
0027A2  360003     BRA LEU, 0x27AA
455:                       if (prio != OS_PRIO_SELF) {
0027A6  44CFE1     ADD.B W9, #0x1, [W15]
0027A8  3A005E     BRA NZ, 0x2866
456:                           return (OS_ERR_PRIO_INVALID);
0027A4  504074     SUB.B W0, #0x14, W0
457:                       }
458:                   }
459:               #endif
460:               
461:               /*$PAGE*/
462:                   OS_ENTER_CRITICAL();
0027AA  80021A     MOV SR, W10
0027AC  200E00     MOV #0xE0, W0
0027AE  B72042     IOR SR
463:                   if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
0027B0  44CFE1     ADD.B W9, #0x1, [W15]
0027B2  3A0002     BRA NZ, 0x27B8
464:                       prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
0027B4  8040E0     MOV OSTCBCur, W0
0027B6  905CC0     MOV.B [W0+28], W9
465:                   }
466:                   ptcb = OSTCBPrioTbl[prio];
0027B8  FB8489     ZE W9, W9
0027BA  448009     ADD W9, W9, W0
0027BC  2169E1     MOV #0x169E, W1
0027BE  780461     MOV [W1+W0], W8
467:                   if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
0027C0  E00008     CP0 W8
0027C2  3A0003     BRA NZ, 0x27CA
468:                       OS_EXIT_CRITICAL();
0027C4  88021A     MOV W10, SR
469:                       return (OS_ERR_TASK_NOT_EXIST);
0027C6  B3C430     MOV.B #0x43, W0
0027C8  37004E     BRA 0x2866
470:                   }
471:                   if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
0027CA  540FE1     SUB W8, #0x1, [W15]
0027CC  3A0003     BRA NZ, 0x27D4
472:                       OS_EXIT_CRITICAL();
0027CE  88021A     MOV W10, SR
473:                       return (OS_ERR_TASK_DEL);
0027D0  B3C3D0     MOV.B #0x3D, W0
0027D2  370049     BRA 0x2866
474:                   }
475:               
476:                   OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
0027D4  9058E8     MOV.B [W8+30], W1
0027D6  FB8081     ZE W1, W1
0027D8  2161C2     MOV #0x161C, W2
0027DA  905878     MOV.B [W8+31], W0
0027DC  EAC000     COM.B W0, W0
0027DE  78C1E2     MOV.B [W2+W1], W3
0027E0  604003     AND.B W0, W3, W0
0027E2  78F100     MOV.B W0, [W2+W1]
477:                   if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
0027E4  3A0003     BRA NZ, 0x27EC
478:                       OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
0027E6  906008     MOV.B [W8+32], W0
0027E8  EAC000     COM.B W0, W0
0027EA  B66815     AND.B OSRdyGrp
479:                   }
480:               
481:               #if (OS_EVENT_EN)
482:                   if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
0027EC  900898     MOV [W8+18], W1
0027EE  E00001     CP0 W1
0027F0  320002     BRA Z, 0x27F6
483:                       OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
0027F2  780008     MOV W8, W0
0027F4  07FCA2     RCALL OS_EventTaskRemove
484:                   }
485:               #if (OS_EVENT_MULTI_EN > 0u)
486:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
0027F6  9008A8     MOV [W8+20], W1
0027F8  E00001     CP0 W1
0027FA  320002     BRA Z, 0x2800
487:                       OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0027FC  780008     MOV W8, W0
0027FE  07FCB0     RCALL OS_EventTaskRemoveMulti
488:                   }
489:               #endif
490:               #endif
491:               
492:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
493:                   pnode = ptcb->OSTCBFlagNode;
494:                   if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
495:                       OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
496:                   }
497:               #endif
498:               
499:                   ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
002800  B80060     MUL.UU W0, #0, W0
002802  980C30     MOV W0, [W8+22]
002804  980C41     MOV W1, [W8+24]
500:                   ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
002806  EB4000     CLR.B W0
002808  985C20     MOV.B W0, [W8+26]
501:                   ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00280A  985C30     MOV.B W0, [W8+27]
502:                   if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
00280C  BFC812     MOV.B OSLockNesting, WREG
00280E  404FE1     ADD.B W0, #0x1, [W15]
002810  320002     BRA Z, 0x2816
503:                       OSLockNesting++;
002812  E84000     INC.B W0, W0
002814  B7E812     MOV.B WREG, OSLockNesting
504:                   }
505:                   OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
002816  88021A     MOV W10, SR
506:                   OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
002818  07FC56     RCALL OS_Dummy
507:                   OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00281A  80021A     MOV SR, W10
00281C  200E00     MOV #0xE0, W0
00281E  B72042     IOR SR
508:                   if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
002820  BFC812     MOV.B OSLockNesting, WREG
002822  320002     BRA Z, 0x2828
509:                       OSLockNesting--;
002824  E94000     DEC.B W0, W0
002826  B7E812     MOV.B WREG, OSLockNesting
510:                   }
511:                   OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
002828  780008     MOV W8, W0
00282A  071396     RCALL OSTaskDelHook
512:               
513:               #if OS_TASK_CREATE_EXT_EN > 0u
514:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
515:                   OS_TLS_TaskDel(ptcb);                               /* Call TLS hook                               */
516:               #endif
517:               #endif
518:               
519:                   OSTaskCtr--;                                        /* One less task being managed                 */
00282C  ED6817     DEC.B OSTaskCtr
520:                   OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
00282E  448489     ADD W9, W9, W9
002830  2169E0     MOV #0x169E, W0
002832  400489     ADD W0, W9, W9
002834  EB0C80     CLR [W9]
521:                   if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
002836  900808     MOV [W8+16], W0
002838  E00000     CP0 W0
00283A  3A0004     BRA NZ, 0x2844
522:                       ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
00283C  9000F8     MOV [W8+14], W1
00283E  980880     MOV W0, [W1+16]
523:                       OSTCBList                  = ptcb->OSTCBNext;
002840  884111     MOV W1, OSTCBList
002842  370004     BRA 0x284C
524:                   } else {
525:                       ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
002844  9000F8     MOV [W8+14], W1
002846  980071     MOV W1, [W0+14]
526:                       ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
002848  9000F8     MOV [W8+14], W1
00284A  980880     MOV W0, [W1+16]
527:                   }
528:                   ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
00284C  8040F0     MOV OSTCBFreeList, W0
00284E  980470     MOV W0, [W8+14]
529:                   OSTCBFreeList       = ptcb;
002850  8840F8     MOV W8, OSTCBFreeList
530:               #if OS_TASK_NAME_EN > 0u
531:                   ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
002852  29E800     MOV #0x9E80, W0
002854  981C20     MOV W0, [W8+52]
532:               #endif
533:                   OS_EXIT_CRITICAL();
002856  88021A     MOV W10, SR
534:                   if (OSRunning == OS_TRUE) {
00285A  208161     MOV #0x816, W1
00285C  784091     MOV.B [W1], W1
00285E  50CFE1     SUB.B W1, #0x1, [W15]
002860  3A0002     BRA NZ, 0x2866
535:                       OS_Sched();                                     /* Find new highest priority task              */
002862  07FD13     RCALL OS_Sched
536:                   }
537:                   return (OS_ERR_NONE);
002858  EB4000     CLR.B W0
002864  EB4000     CLR.B W0
538:               }
002866  78054F     MOV [--W15], W10
002868  BE044F     MOV.D [--W15], W8
00286A  060000     RETURN
539:               #endif
540:               /*$PAGE*/
541:               /*
542:               *********************************************************************************************************
543:               *                                  REQUEST THAT A TASK DELETE ITSELF
544:               *
545:               * Description: This function is used to:
546:               *                   a) notify a task to delete itself.
547:               *                   b) to see if a task requested that the current task delete itself.
548:               *              This function is a little tricky to understand.  Basically, you have a task that needs
549:               *              to be deleted however, this task has resources that it has allocated (memory buffers,
550:               *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
551:               *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
552:               *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
553:               *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
554:               *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
555:               *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
556:               *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
557:               *              this:
558:               *
559:               *                   void Task(void *p_arg)
560:               *                   {
561:               *                       .
562:               *                       .
563:               *                       while (1) {
564:               *                           OSTimeDly(1);
565:               *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
566:               *                               Release any owned resources;
567:               *                               De-allocate any dynamic memory;
568:               *                               OSTaskDel(OS_PRIO_SELF);
569:               *                           }
570:               *                       }
571:               *                   }
572:               *
573:               * Arguments  : prio    is the priority of the task to request the delete from
574:               *
575:               * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
576:               *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
577:               *                                     the request has been executed.
578:               *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
579:               *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
580:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
581:               *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
582:               *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
583:               *                                     deleted.
584:               *********************************************************************************************************
585:               */
586:               /*$PAGE*/
587:               #if OS_TASK_DEL_EN > 0u
588:               INT8U  OSTaskDelReq (INT8U prio)
589:               {
00286C  784080     MOV.B W0, W1
590:                   INT8U      stat;
591:                   OS_TCB    *ptcb;
592:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
593:                   OS_CPU_SR  cpu_sr = 0u;
594:               #endif
595:               
596:               
597:               
598:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
002870  50CFEA     SUB.B W1, #0xA, [W15]
002872  32001F     BRA Z, 0x28B2
599:                       return (OS_ERR_TASK_DEL_IDLE);
00286E  B3C3E0     MOV.B #0x3E, W0
600:                   }
601:               #if OS_ARG_CHK_EN > 0u
602:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
002874  50CFE9     SUB.B W1, #0x9, [W15]
002876  36000A     BRA LEU, 0x288C
603:                       if (prio != OS_PRIO_SELF) {
00287A  40CFE1     ADD.B W1, #0x1, [W15]
00287C  3A001A     BRA NZ, 0x28B2
604:                           return (OS_ERR_PRIO_INVALID);
002878  504074     SUB.B W0, #0x14, W0
605:                       }
606:                   }
607:               #endif
608:                   if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
609:                       OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00287E  800211     MOV SR, W1
002880  200E00     MOV #0xE0, W0
002882  B72042     IOR SR
610:                       stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
002884  8040E0     MOV OSTCBCur, W0
002886  906010     MOV.B [W0+33], W0
611:                       OS_EXIT_CRITICAL();
002888  880211     MOV W1, SR
612:                       return (stat);
00288A  060000     RETURN
613:                   }
614:                   OS_ENTER_CRITICAL();
00288C  800213     MOV SR, W3
00288E  200E00     MOV #0xE0, W0
002890  B72042     IOR SR
615:                   ptcb = OSTCBPrioTbl[prio];
002892  FB8081     ZE W1, W1
002894  408081     ADD W1, W1, W1
002896  2169E2     MOV #0x169E, W2
002898  7880E2     MOV [W2+W1], W1
616:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00289A  E00001     CP0 W1
00289C  3A0002     BRA NZ, 0x28A2
617:                       OS_EXIT_CRITICAL();
00289E  880213     MOV W3, SR
618:                       return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
0028A0  050430     RETLW #0x43, W0
619:                   }
620:                   if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
0028A2  508FE1     SUB W1, #0x1, [W15]
0028A4  3A0002     BRA NZ, 0x28AA
621:                       OS_EXIT_CRITICAL();
0028A6  880213     MOV W3, SR
622:                       return (OS_ERR_TASK_DEL);
0028A8  0503D0     RETLW #0x3D, W0
623:                   }
624:                   ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
0028AA  B3C3F2     MOV.B #0x3F, W2
0028AC  986092     MOV.B W2, [W1+33]
625:                   OS_EXIT_CRITICAL();
0028AE  880213     MOV W3, SR
626:                   return (OS_ERR_NONE);
0028B0  EB4000     CLR.B W0
627:               }
0028B2  060000     RETURN
628:               #endif
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                       GET THE NAME OF A TASK
633:               *
634:               * Description: This function is called to obtain the name of a task.
635:               *
636:               * Arguments  : prio      is the priority of the task that you want to obtain the name from.
637:               *
638:               *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
639:               *
640:               *              perr      is a pointer to an error code that can contain one of the following values:
641:               *
642:               *                        OS_ERR_NONE                if the requested task is resumed
643:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
644:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
645:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
646:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
647:               *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
648:               *
649:               *
650:               * Returns    : The length of the string or 0 if the task does not exist.
651:               *********************************************************************************************************
652:               */
653:               
654:               #if OS_TASK_NAME_EN > 0u
655:               INT8U  OSTaskNameGet (INT8U    prio,
656:                                     INT8U  **pname,
657:                                     INT8U   *perr)
658:               {
0028B4  BE9F88     MOV.D W8, [W15++]
0028B6  784180     MOV.B W0, W3
0028B8  780402     MOV W2, W8
659:                   OS_TCB    *ptcb;
660:                   INT8U      len;
661:               #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
662:                   OS_CPU_SR  cpu_sr = 0u;
663:               #endif
664:               
665:               
666:               
667:               #ifdef OS_SAFETY_CRITICAL
668:                   if (perr == (INT8U *)0) {
669:                       OS_SAFETY_CRITICAL_EXCEPTION();
670:                       return (0u);
671:                   }
672:               #endif
673:               
674:               #if OS_ARG_CHK_EN > 0u
675:                   if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
0028BA  51CFEA     SUB.B W3, #0xA, [W15]
0028BC  360003     BRA LEU, 0x28C4
676:                       if (prio != OS_PRIO_SELF) {
0028C0  41CFE1     ADD.B W3, #0x1, [W15]
0028C2  3A0003     BRA NZ, 0x28CA
677:                           *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
0028BE  B3C2A0     MOV.B #0x2A, W0
678:                           return (0u);
679:                       }
680:                   }
681:                   if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
0028C4  E00001     CP0 W1
0028C6  3A0004     BRA NZ, 0x28D0
682:                       *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
0028C8  B3C0C0     MOV.B #0xC, W0
0028CA  784C00     MOV.B W0, [W8]
683:                       return (0u);
0028CC  EB4000     CLR.B W0
0028CE  37001A     BRA 0x2904
684:                   }
685:               #endif
686:                   if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
0028D2  E24811     CP0.B OSIntNesting
0028D4  3AFFFA     BRA NZ, 0x28CA
687:                       *perr = OS_ERR_NAME_GET_ISR;
0028D0  B3C110     MOV.B #0x11, W0
688:                       return (0u);
689:                   }
690:                   OS_ENTER_CRITICAL();
0028D6  800219     MOV SR, W9
0028D8  200E00     MOV #0xE0, W0
0028DA  B72042     IOR SR
691:                   if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
0028DC  41CFE1     ADD.B W3, #0x1, [W15]
0028DE  3A0002     BRA NZ, 0x28E4
692:                       prio = OSTCBCur->OSTCBPrio;
0028E0  8040E0     MOV OSTCBCur, W0
0028E2  9059C0     MOV.B [W0+28], W3
693:                   }
694:                   ptcb = OSTCBPrioTbl[prio];
0028E4  FB8003     ZE W3, W0
0028E6  400000     ADD W0, W0, W0
0028E8  2169E2     MOV #0x169E, W2
0028EA  780062     MOV [W2+W0], W0
695:                   if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
0028EC  E00000     CP0 W0
0028EE  320002     BRA Z, 0x28F4
696:                       OS_EXIT_CRITICAL();                              /* No                                         */
697:                       *perr = OS_ERR_TASK_NOT_EXIST;
698:                       return (0u);
699:                   }
700:                   if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
0028F0  500FE1     SUB W0, #0x1, [W15]
0028F2  3A0003     BRA NZ, 0x28FA
701:                       OS_EXIT_CRITICAL();                              /* Yes                                        */
0028F4  880219     MOV W9, SR
702:                       *perr = OS_ERR_TASK_NOT_EXIST;
0028F6  B3C430     MOV.B #0x43, W0
0028F8  37FFE8     BRA 0x28CA
703:                       return (0u);
704:                   }
705:                   *pname = ptcb->OSTCBTaskName;
0028FA  901820     MOV [W0+52], W0
0028FC  780880     MOV W0, [W1]
706:                   len    = OS_StrLen(*pname);
0028FE  07FD8C     RCALL OS_StrLen
707:                   OS_EXIT_CRITICAL();
002900  880219     MOV W9, SR
708:                   *perr  = OS_ERR_NONE;
002902  EB4C00     CLR.B [W8]
709:                   return (len);
710:               }
002904  BE044F     MOV.D [--W15], W8
002906  060000     RETURN
711:               #endif
712:               
713:               /*$PAGE*/
714:               /*
715:               *********************************************************************************************************
716:               *                                       ASSIGN A NAME TO A TASK
717:               *
718:               * Description: This function is used to set the name of a task.
719:               *
720:               * Arguments  : prio      is the priority of the task that you want the assign a name to.
721:               *
722:               *              pname     is a pointer to an ASCII string that contains the name of the task.
723:               *
724:               *              perr       is a pointer to an error code that can contain one of the following values:
725:               *
726:               *                        OS_ERR_NONE                if the requested task is resumed
727:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
728:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
729:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
730:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
731:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
732:               *
733:               * Returns    : None
734:               *********************************************************************************************************
735:               */
736:               #if OS_TASK_NAME_EN > 0u
737:               void  OSTaskNameSet (INT8U   prio,
738:                                    INT8U  *pname,
739:                                    INT8U  *perr)
740:               {
002908  784280     MOV.B W0, W5
741:                   OS_TCB    *ptcb;
742:               #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
743:                   OS_CPU_SR  cpu_sr = 0u;
744:               #endif
745:               
746:               
747:               
748:               #ifdef OS_SAFETY_CRITICAL
749:                   if (perr == (INT8U *)0) {
750:                       OS_SAFETY_CRITICAL_EXCEPTION();
751:                       return;
752:                   }
753:               #endif
754:               
755:               #if OS_ARG_CHK_EN > 0u
756:                   if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
00290A  52CFEA     SUB.B W5, #0xA, [W15]
00290C  360003     BRA LEU, 0x2914
757:                       if (prio != OS_PRIO_SELF) {
002910  42CFE1     ADD.B W5, #0x1, [W15]
002912  3A0017     BRA NZ, 0x2942
758:                           *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
00290E  B3C2A0     MOV.B #0x2A, W0
759:                           return;
760:                       }
761:                   }
762:                   if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
002916  E00001     CP0 W1
002918  320014     BRA Z, 0x2942
763:                       *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
002914  B3C0C0     MOV.B #0xC, W0
764:                       return;
765:                   }
766:               #endif
767:                   if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00291C  E24811     CP0.B OSIntNesting
00291E  3A0011     BRA NZ, 0x2942
768:                       *perr = OS_ERR_NAME_SET_ISR;
00291A  B3C120     MOV.B #0x12, W0
769:                       return;
770:                   }
771:                   OS_ENTER_CRITICAL();
002920  800213     MOV SR, W3
002922  200E00     MOV #0xE0, W0
002924  B72042     IOR SR
772:                   if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
002926  42CFE1     ADD.B W5, #0x1, [W15]
002928  3A0002     BRA NZ, 0x292E
773:                       prio = OSTCBCur->OSTCBPrio;
00292A  8040E0     MOV OSTCBCur, W0
00292C  905AC0     MOV.B [W0+28], W5
774:                   }
775:                   ptcb = OSTCBPrioTbl[prio];
00292E  FB8005     ZE W5, W0
002930  400000     ADD W0, W0, W0
002932  2169E4     MOV #0x169E, W4
002934  780064     MOV [W4+W0], W0
776:                   if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
002936  E00000     CP0 W0
002938  320002     BRA Z, 0x293E
777:                       OS_EXIT_CRITICAL();                          /* No                                             */
778:                       *perr = OS_ERR_TASK_NOT_EXIST;
779:                       return;
780:                   }
781:                   if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
00293A  500FE1     SUB W0, #0x1, [W15]
00293C  3A0004     BRA NZ, 0x2946
782:                       OS_EXIT_CRITICAL();                          /* Yes                                            */
00293E  880213     MOV W3, SR
783:                       *perr = OS_ERR_TASK_NOT_EXIST;
002940  B3C430     MOV.B #0x43, W0
002942  784900     MOV.B W0, [W2]
784:                       return;
002944  060000     RETURN
785:                   }
786:                   ptcb->OSTCBTaskName = pname;
002946  981821     MOV W1, [W0+52]
787:                   OS_EXIT_CRITICAL();
002948  880213     MOV W3, SR
788:                   *perr               = OS_ERR_NONE;
00294A  EB4900     CLR.B [W2]
00294C  060000     RETURN
789:               }
790:               #endif
791:               
792:               /*$PAGE*/
793:               /*
794:               *********************************************************************************************************
795:               *                                       RESUME A SUSPENDED TASK
796:               *
797:               * Description: This function is called to resume a previously suspended task.  This is the only call that
798:               *              will remove an explicit task suspension.
799:               *
800:               * Arguments  : prio     is the priority of the task to resume.
801:               *
802:               * Returns    : OS_ERR_NONE                if the requested task is resumed
803:               *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
804:               *                                         (i.e. >= OS_LOWEST_PRIO)
805:               *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
806:               *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
807:               *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
808:               *********************************************************************************************************
809:               */
810:               
811:               #if OS_TASK_SUSPEND_EN > 0u
812:               INT8U  OSTaskResume (INT8U prio)
813:               {
00294E  784100     MOV.B W0, W2
814:                   OS_TCB    *ptcb;
815:               #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
816:                   OS_CPU_SR  cpu_sr = 0u;
817:               #endif
818:               
819:               
820:               
821:               #if OS_ARG_CHK_EN > 0u
822:                   if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
002952  514FE9     SUB.B W2, #0x9, [W15]
002954  3E0030     BRA GTU, 0x29B6
823:                       return (OS_ERR_PRIO_INVALID);
002950  B3C2A0     MOV.B #0x2A, W0
824:                   }
825:               #endif
826:                   OS_ENTER_CRITICAL();
002956  800211     MOV SR, W1
002958  200E00     MOV #0xE0, W0
00295A  B72042     IOR SR
827:                   ptcb = OSTCBPrioTbl[prio];
00295C  FB8002     ZE W2, W0
00295E  400000     ADD W0, W0, W0
002960  2169E2     MOV #0x169E, W2
002962  7802E2     MOV [W2+W0], W5
828:                   if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
002964  E00005     CP0 W5
002966  3A0002     BRA NZ, 0x296C
829:                       OS_EXIT_CRITICAL();
002968  880211     MOV W1, SR
830:                       return (OS_ERR_TASK_RESUME_PRIO);
00296A  050460     RETLW #0x46, W0
831:                   }
832:                   if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00296C  528FE1     SUB W5, #0x1, [W15]
00296E  3A0002     BRA NZ, 0x2974
833:                       OS_EXIT_CRITICAL();
002970  880211     MOV W1, SR
834:                       return (OS_ERR_TASK_NOT_EXIST);
002972  050430     RETLW #0x43, W0
835:                   }
836:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
002974  905925     MOV.B [W5+26], W2
002976  A33802     BTST.Z W2, #3
002978  32001C     BRA Z, 0x29B2
837:                       ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00297A  A13402     BCLR.B W2, #3
00297C  985AA2     MOV.B W2, [W5+26]
838:                       if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) == OS_STAT_RDY) { /* See if task is now ready         */
00297E  B20372     AND #0x37, W2
002980  3A0016     BRA NZ, 0x29AE
839:                           if (ptcb->OSTCBDly == 0u) {
002982  900935     MOV [W5+22], W2
002984  9009C5     MOV [W5+24], W3
002986  510FE0     SUB W2, #0x0, [W15]
002988  598FE0     SUBB W3, #0x0, [W15]
00298A  3A0011     BRA NZ, 0x29AE
840:                               OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00298C  906005     MOV.B [W5+32], W0
00298E  B76815     IOR.B OSRdyGrp
841:                               OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
002990  905965     MOV.B [W5+30], W2
002992  FB8102     ZE W2, W2
002994  2161C3     MOV #0x161C, W3
002996  794263     MOV.B [W3+W2], W4
002998  905875     MOV.B [W5+31], W0
00299A  724000     IOR.B W4, W0, W0
00299C  797180     MOV.B W0, [W3+W2]
842:                               OS_EXIT_CRITICAL();
00299E  880211     MOV W1, SR
843:                               if (OSRunning == OS_TRUE) {
0029A2  208161     MOV #0x816, W1
0029A4  784091     MOV.B [W1], W1
0029A6  50CFE1     SUB.B W1, #0x1, [W15]
0029A8  3A0006     BRA NZ, 0x29B6
844:                                   OS_Sched();                               /* Find new highest priority task        */
0029AA  07FC6F     RCALL OS_Sched
0029AC  370001     BRA 0x29B0
845:                               }
846:                           } else {
847:                               OS_EXIT_CRITICAL();
848:                           }
849:                       } else {                                              /* Must be pending on event              */
850:                           OS_EXIT_CRITICAL();
0029AE  880211     MOV W1, SR
851:                       }
852:                       return (OS_ERR_NONE);
0029A0  EB4000     CLR.B W0
0029B0  050000     RETLW #0x0, W0
853:                   }
854:                   OS_EXIT_CRITICAL();
0029B2  880211     MOV W1, SR
855:                   return (OS_ERR_TASK_NOT_SUSPENDED);
0029B4  B3C440     MOV.B #0x44, W0
856:               }
0029B6  060000     RETURN
857:               #endif
858:               /*$PAGE*/
859:               /*
860:               *********************************************************************************************************
861:               *                                           STACK CHECKING
862:               *
863:               * Description: This function is called to check the amount of free memory left on the specified task's
864:               *              stack.
865:               *
866:               * Arguments  : prio          is the task priority
867:               *
868:               *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
869:               *
870:               * Returns    : OS_ERR_NONE            upon success
871:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
872:               *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
873:               *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
874:               *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
875:               *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
876:               *********************************************************************************************************
877:               */
878:               #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
879:               INT8U  OSTaskStkChk (INT8U         prio,
880:                                    OS_STK_DATA  *p_stk_data)
881:               {
0029B8  784200     MOV.B W0, W4
882:                   OS_TCB    *ptcb;
883:                   OS_STK    *pchk;
884:                   INT32U     nfree;
885:                   INT32U     size;
886:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
887:                   OS_CPU_SR  cpu_sr = 0u;
888:               #endif
889:               
890:               
891:               
892:               #if OS_ARG_CHK_EN > 0u
893:                   if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
0029BA  524FEA     SUB.B W4, #0xA, [W15]
0029BC  360003     BRA LEU, 0x29C4
894:                       if (prio != OS_PRIO_SELF) {
0029C0  424FE1     ADD.B W4, #0x1, [W15]
0029C2  3A0030     BRA NZ, 0x2A24
895:                           return (OS_ERR_PRIO_INVALID);
0029BE  B3C2A2     MOV.B #0x2A, W2
896:                       }
897:                   }
898:                   if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
0029C6  E00001     CP0 W1
0029C8  32002D     BRA Z, 0x2A24
899:                       return (OS_ERR_PDATA_NULL);
0029C4  B3C092     MOV.B #0x9, W2
900:                   }
901:               #endif
902:                   p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
0029CA  EB0880     CLR [W1]
0029CC  7810B1     MOV [W1++], [W1--]
903:                   p_stk_data->OSUsed = 0u;
0029CE  B81160     MUL.UU W2, #0, W2
0029D0  9800A2     MOV W2, [W1+4]
0029D2  9800B3     MOV W3, [W1+6]
904:                   OS_ENTER_CRITICAL();
0029D4  800213     MOV SR, W3
0029D6  200E00     MOV #0xE0, W0
0029D8  B72042     IOR SR
905:                   if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
0029DA  424FE1     ADD.B W4, #0x1, [W15]
0029DC  3A0002     BRA NZ, 0x29E2
906:                       prio = OSTCBCur->OSTCBPrio;
0029DE  8040E0     MOV OSTCBCur, W0
0029E0  905A40     MOV.B [W0+28], W4
907:                   }
908:                   ptcb = OSTCBPrioTbl[prio];
0029E2  FB8004     ZE W4, W0
0029E4  400000     ADD W0, W0, W0
0029E6  2169E2     MOV #0x169E, W2
0029E8  780062     MOV [W2+W0], W0
909:                   if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
0029EA  E00000     CP0 W0
0029EC  320002     BRA Z, 0x29F2
910:                       OS_EXIT_CRITICAL();
911:                       return (OS_ERR_TASK_NOT_EXIST);
912:                   }
913:                   if (ptcb == OS_TCB_RESERVED) {
0029EE  500FE1     SUB W0, #0x1, [W15]
0029F0  3A0003     BRA NZ, 0x29F8
914:                       OS_EXIT_CRITICAL();
0029F2  880213     MOV W3, SR
915:                       return (OS_ERR_TASK_NOT_EXIST);
0029F4  B3C432     MOV.B #0x43, W2
0029F6  370016     BRA 0x2A24
916:                   }
917:                   if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
0029F8  900150     MOV [W0+10], W2
0029FA  A30802     BTST.Z W2, #0
0029FC  3A0003     BRA NZ, 0x2A04
918:                       OS_EXIT_CRITICAL();
0029FE  880213     MOV W3, SR
919:                       return (OS_ERR_TASK_OPT);
002A00  B3C452     MOV.B #0x45, W2
002A02  370010     BRA 0x2A24
920:                   }
921:                   nfree = 0u;
002A0C  B81160     MUL.UU W2, #0, W2
922:                   size  = ptcb->OSTCBStkSize;
002A04  900230     MOV [W0+6], W4
002A06  9002C0     MOV [W0+8], W5
923:                   pchk  = ptcb->OSTCBStkBottom;
002A08  900020     MOV [W0+4], W0
924:                   OS_EXIT_CRITICAL();
002A0A  880213     MOV W3, SR
925:               #if OS_STK_GROWTH == 1u
926:                   while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
927:                       nfree++;
928:                   }
929:               #else
930:                   while (*pchk-- == (OS_STK)0) {
002A0E  370002     BRA 0x2A14
002A14  E00020     CP0 [W0--]
002A16  32FFFC     BRA Z, 0x2A10
931:                       nfree++;
002A10  410161     ADD W2, #0x1, W2
002A12  4981E0     ADDC W3, #0x0, W3
932:                   }
933:               #endif
934:                   p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
002A18  BE8882     MOV.D W2, [W1]
935:                   p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
002A1A  520102     SUB W4, W2, W2
002A1C  5A8183     SUBB W5, W3, W3
002A1E  9800A2     MOV W2, [W1+4]
002A20  9800B3     MOV W3, [W1+6]
936:                   return (OS_ERR_NONE);
002A22  EB4100     CLR.B W2
937:               }
002A24  784002     MOV.B W2, W0
002A26  060000     RETURN
938:               #endif
939:               /*$PAGE*/
940:               /*
941:               *********************************************************************************************************
942:               *                                           SUSPEND A TASK
943:               *
944:               * Description: This function is called to suspend a task.  The task can be the calling task if the
945:               *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
946:               *
947:               * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
948:               *                       calling task will suspend itself and rescheduling will occur.
949:               *
950:               * Returns    : OS_ERR_NONE               if the requested task is suspended
951:               *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
952:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
953:               *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
954:               *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
955:               *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
956:               *
957:               * Note       : You should use this function with great care.  If you suspend a task that is waiting for
958:               *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
959:               *              running when the event arrives.
960:               *********************************************************************************************************
961:               */
962:               
963:               #if OS_TASK_SUSPEND_EN > 0u
964:               INT8U  OSTaskSuspend (INT8U prio)
965:               {
002A28  784200     MOV.B W0, W4
966:                   BOOLEAN    self;
967:                   OS_TCB    *ptcb;
968:                   INT8U      y;
969:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
970:                   OS_CPU_SR  cpu_sr = 0u;
971:               #endif
972:               
973:               
974:               
975:               #if OS_ARG_CHK_EN > 0u
976:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
002A2C  524FEA     SUB.B W4, #0xA, [W15]
002A2E  320036     BRA Z, 0x2A9C
977:                       return (OS_ERR_TASK_SUSPEND_IDLE);
002A2A  B3C471     MOV.B #0x47, W1
978:                   }
979:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
002A30  524FE9     SUB.B W4, #0x9, [W15]
002A32  360003     BRA LEU, 0x2A3A
980:                       if (prio != OS_PRIO_SELF) {
002A36  424FE1     ADD.B W4, #0x1, [W15]
002A38  3A0031     BRA NZ, 0x2A9C
981:                           return (OS_ERR_PRIO_INVALID);
002A34  50C0FD     SUB.B W1, #0x1D, W1
982:                       }
983:                   }
984:               #endif
985:                   OS_ENTER_CRITICAL();
002A3A  800211     MOV SR, W1
002A3C  200E00     MOV #0xE0, W0
002A3E  B72042     IOR SR
002A40  8040E2     MOV OSTCBCur, W2
986:                   if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
002A42  424FE1     ADD.B W4, #0x1, [W15]
002A44  3A0002     BRA NZ, 0x2A4A
987:                       prio = OSTCBCur->OSTCBPrio;
002A46  905A42     MOV.B [W2+28], W4
002A48  370004     BRA 0x2A52
988:                       self = OS_TRUE;
989:                   } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
002A4A  9059C2     MOV.B [W2+28], W3
002A4E  524F83     SUB.B W4, W3, [W15]
002A50  3A0001     BRA NZ, 0x2A54
990:                       self = OS_TRUE;
002A52  B3C012     MOV.B #0x1, W2
991:                   } else {
992:                       self = OS_FALSE;                                        /* No suspending another task          */
002A4C  EB4100     CLR.B W2
993:                   }
994:                   ptcb = OSTCBPrioTbl[prio];
002A54  FB8004     ZE W4, W0
002A56  400000     ADD W0, W0, W0
002A58  2169E3     MOV #0x169E, W3
002A5A  780063     MOV [W3+W0], W0
995:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
002A5C  E00000     CP0 W0
002A5E  3A0003     BRA NZ, 0x2A66
996:                       OS_EXIT_CRITICAL();
002A60  880211     MOV W1, SR
997:                       return (OS_ERR_TASK_SUSPEND_PRIO);
002A62  B3C481     MOV.B #0x48, W1
002A64  37001B     BRA 0x2A9C
998:                   }
999:                   if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
002A66  500FE1     SUB W0, #0x1, [W15]
002A68  3A0003     BRA NZ, 0x2A70
1000:                      OS_EXIT_CRITICAL();
002A6A  880211     MOV W1, SR
1001:                      return (OS_ERR_TASK_NOT_EXIST);
002A6C  B3C431     MOV.B #0x43, W1
002A6E  370016     BRA 0x2A9C
1002:                  }
1003:                  y            = ptcb->OSTCBY;
1004:                  OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
002A70  905A60     MOV.B [W0+30], W4
002A72  FB8204     ZE W4, W4
002A74  2161C5     MOV #0x161C, W5
002A76  9059F0     MOV.B [W0+31], W3
002A78  EAC183     COM.B W3, W3
002A7A  7A4365     MOV.B [W5+W4], W6
002A7C  61C186     AND.B W3, W6, W3
002A7E  7A7283     MOV.B W3, [W5+W4]
1005:                  if (OSRdyTbl[y] == 0u) {
002A80  3A0004     BRA NZ, 0x2A8A
1006:                      OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
002A82  906180     MOV.B [W0+32], W3
002A84  EAC183     COM.B W3, W3
002A86  208154     MOV #0x815, W4
002A88  61CA14     AND.B W3, [W4], [W4]
1007:                  }
1008:                  ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
002A8A  9059A0     MOV.B [W0+26], W3
002A8C  A03403     BSET.B W3, #3
002A8E  985823     MOV.B W3, [W0+26]
1009:                  OS_EXIT_CRITICAL();
002A90  880211     MOV W1, SR
1010:                  if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
002A94  514FE1     SUB.B W2, #0x1, [W15]
002A96  3A0002     BRA NZ, 0x2A9C
1011:                      OS_Sched();                                             /* Find new highest priority task      */
002A98  07FBF8     RCALL OS_Sched
1012:                  }
1013:                  return (OS_ERR_NONE);
002A92  EB4080     CLR.B W1
002A9A  EB4080     CLR.B W1
1014:              }
002A9C  784001     MOV.B W1, W0
002A9E  060000     RETURN
1015:              #endif
1016:              /*$PAGE*/
1017:              /*
1018:              *********************************************************************************************************
1019:              *                                            QUERY A TASK
1020:              *
1021:              * Description: This function is called to obtain a copy of the desired task's TCB.
1022:              *
1023:              * Arguments  : prio         is the priority of the task to obtain information from.
1024:              *
1025:              *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
1026:              *
1027:              * Returns    : OS_ERR_NONE            if the requested task is suspended
1028:              *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
1029:              *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
1030:              *              OS_ERR_PRIO            if the desired task has not been created
1031:              *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
1032:              *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
1033:              *********************************************************************************************************
1034:              */
1035:              
1036:              #if OS_TASK_QUERY_EN > 0u
1037:              INT8U  OSTaskQuery (INT8U    prio,
1038:                                  OS_TCB  *p_task_data)
1039:              {
002AA0  781F88     MOV W8, [W15++]
002AA2  784100     MOV.B W0, W2
002AA4  780181     MOV W1, W3
1040:                  OS_TCB    *ptcb;
1041:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1042:                  OS_CPU_SR  cpu_sr = 0u;
1043:              #endif
1044:              
1045:              
1046:              
1047:              #if OS_ARG_CHK_EN > 0u
1048:                  if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
002AA6  514FEA     SUB.B W2, #0xA, [W15]
002AA8  360003     BRA LEU, 0x2AB0
1049:                      if (prio != OS_PRIO_SELF) {
002AAC  414FE1     ADD.B W2, #0x1, [W15]
002AAE  3A001D     BRA NZ, 0x2AEA
1050:                          return (OS_ERR_PRIO_INVALID);
002AAA  B3C2A1     MOV.B #0x2A, W1
1051:                      }
1052:                  }
1053:                  if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
002AB2  E00003     CP0 W3
002AB4  32001A     BRA Z, 0x2AEA
1054:                      return (OS_ERR_PDATA_NULL);
002AB0  B3C091     MOV.B #0x9, W1
1055:                  }
1056:              #endif
1057:                  OS_ENTER_CRITICAL();
002AB6  800218     MOV SR, W8
002AB8  200E00     MOV #0xE0, W0
002ABA  B72042     IOR SR
1058:                  if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
002ABC  414FE1     ADD.B W2, #0x1, [W15]
002ABE  3A0002     BRA NZ, 0x2AC4
1059:                      prio = OSTCBCur->OSTCBPrio;
002AC0  8040E1     MOV OSTCBCur, W1
002AC2  905941     MOV.B [W1+28], W2
1060:                  }
1061:                  ptcb = OSTCBPrioTbl[prio];
002AC4  FB8102     ZE W2, W2
002AC6  410102     ADD W2, W2, W2
002AC8  2169E1     MOV #0x169E, W1
002ACA  7900E1     MOV [W1+W2], W1
1062:                  if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
002ACC  E00001     CP0 W1
002ACE  3A0003     BRA NZ, 0x2AD6
1063:                      OS_EXIT_CRITICAL();
002AD0  880218     MOV W8, SR
1064:                      return (OS_ERR_PRIO);
002AD2  B3C291     MOV.B #0x29, W1
002AD4  37000A     BRA 0x2AEA
1065:                  }
1066:                  if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
002AD6  508FE1     SUB W1, #0x1, [W15]
002AD8  3A0003     BRA NZ, 0x2AE0
1067:                      OS_EXIT_CRITICAL();
002ADA  880218     MOV W8, SR
1068:                      return (OS_ERR_TASK_NOT_EXIST);
002ADC  B3C431     MOV.B #0x43, W1
002ADE  370005     BRA 0x2AEA
1069:                  }
1070:                                                               /* Copy TCB into user storage area                    */
1071:                  OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
002AE0  2003A2     MOV #0x3A, W2
002AE2  780003     MOV W3, W0
002AE4  07FBCC     RCALL OS_MemCopy
1072:                  OS_EXIT_CRITICAL();
002AE6  880218     MOV W8, SR
1073:                  return (OS_ERR_NONE);
002AE8  EB4080     CLR.B W1
1074:              }
002AEA  784001     MOV.B W1, W0
002AEC  78044F     MOV [--W15], W8
002AEE  060000     RETURN
1075:              #endif
1076:              /*$PAGE*/
1077:              /*
1078:              *********************************************************************************************************
1079:              *                              GET THE CURRENT VALUE OF A TASK REGISTER
1080:              *
1081:              * Description: This function is called to obtain the current value of a task register.  Task registers
1082:              *              are application specific and can be used to store task specific values such as 'error
1083:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1084:              *
1085:              * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
1086:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1087:              *
1088:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1089:              *                        than OS_TASK_REG_TBL_SIZE
1090:              *
1091:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1092:              *
1093:              *                        OS_ERR_NONE            if the call was successful
1094:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1095:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1096:              *
1097:              * Returns    : The current value of the task's register or 0 if an error is detected.
1098:              *
1099:              * Note(s)    : The maximum number of task variables is 254
1100:              *********************************************************************************************************
1101:              */
1102:              
1103:              #if OS_TASK_REG_TBL_SIZE > 0u
1104:              INT32U  OSTaskRegGet (INT8U   prio,
1105:                                    INT8U   id,
1106:                                    INT8U  *perr)
1107:              {
002AF0  784200     MOV.B W0, W4
1108:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1109:                  OS_CPU_SR  cpu_sr = 0u;
1110:              #endif
1111:                  INT32U     value;
1112:                  OS_TCB    *ptcb;
1113:              
1114:              
1115:              
1116:              #ifdef OS_SAFETY_CRITICAL
1117:                  if (perr == (INT8U *)0) {
1118:                      OS_SAFETY_CRITICAL_EXCEPTION();
1119:                      return (0u);
1120:                  }
1121:              #endif
1122:              
1123:              #if OS_ARG_CHK_EN > 0u
1124:                  if (prio >= OS_LOWEST_PRIO) {
002AF2  524FE9     SUB.B W4, #0x9, [W15]
002AF4  360003     BRA LEU, 0x2AFC
1125:                      if (prio != OS_PRIO_SELF) {
002AF8  424FE1     ADD.B W4, #0x1, [W15]
002AFA  3A0003     BRA NZ, 0x2B02
1126:                          *perr = OS_ERR_PRIO_INVALID;
002AF6  B3C2A0     MOV.B #0x2A, W0
1127:                          return (0u);
1128:                      }
1129:                  }
1130:                  if (id >= OS_TASK_REG_TBL_SIZE) {
002AFC  E00401     CP0.B W1
002AFE  320004     BRA Z, 0x2B08
1131:                      *perr = OS_ERR_ID_INVALID;
002B00  B3C080     MOV.B #0x8, W0
002B02  784900     MOV.B W0, [W2]
1132:                      return (0u);
002B04  200001     MOV #0x0, W1
002B06  050000     RETLW #0x0, W0
1133:                  }
1134:              #endif
1135:                  OS_ENTER_CRITICAL();
002B08  800213     MOV SR, W3
002B0A  200E00     MOV #0xE0, W0
002B0C  B72042     IOR SR
1136:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
002B0E  424FE1     ADD.B W4, #0x1, [W15]
002B10  3A0002     BRA NZ, 0x2B16
1137:                      ptcb = OSTCBCur;
002B12  8040E0     MOV OSTCBCur, W0
002B14  370004     BRA 0x2B1E
1138:                  } else {
1139:                      ptcb = OSTCBPrioTbl[prio];
002B16  FB8004     ZE W4, W0
002B18  400000     ADD W0, W0, W0
002B1A  2169E1     MOV #0x169E, W1
002B1C  780061     MOV [W1+W0], W0
1140:                  }
1141:                  value = ptcb->OSTCBRegTbl[id];
002B1E  9018C0     MOV [W0+56], W1
002B20  901830     MOV [W0+54], W0
1142:                  OS_EXIT_CRITICAL();
002B22  880213     MOV W3, SR
1143:                  *perr = OS_ERR_NONE;
002B24  EB4900     CLR.B [W2]
1144:                  return (value);
1145:              }
002B26  060000     RETURN
1146:              #endif
1147:              
1148:              /*$PAGE*/
1149:              /*
1150:              ************************************************************************************************************************
1151:              *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
1152:              *
1153:              * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
1154:              *              allocated dynamically instead of statically.
1155:              *
1156:              * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
1157:              *
1158:              *                            OS_ERR_NONE               if the call was successful
1159:              *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
1160:              *                                                           have available through OS_TASK_REG_TBL_SIZE.
1161:              *
1162:              * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
1163:              ************************************************************************************************************************
1164:              */
1165:              
1166:              #if OS_TASK_REG_TBL_SIZE > 0u
1167:              INT8U  OSTaskRegGetID (INT8U  *perr)
1168:              {
002B28  780280     MOV W0, W5
1169:              #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
1170:                  OS_CPU_SR  cpu_sr = 0u;
1171:              #endif
1172:                  INT8U      id;
1173:              
1174:              
1175:              #ifdef OS_SAFETY_CRITICAL
1176:                  if (perr == (INT8U *)0) {
1177:                      OS_SAFETY_CRITICAL_EXCEPTION();
1178:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
1179:                  }
1180:              #endif
1181:              
1182:                  OS_ENTER_CRITICAL();
002B2A  800212     MOV SR, W2
002B2C  200E00     MOV #0xE0, W0
002B2E  B72042     IOR SR
1183:                  if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
002B30  208251     MOV #0x825, W1
002B32  784091     MOV.B [W1], W1
002B34  E00401     CP0.B W1
002B36  320004     BRA Z, 0x2B40
1184:                     *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
002B38  B3C961     MOV.B #0x96, W1
002B3A  784A81     MOV.B W1, [W5]
1185:                      OS_EXIT_CRITICAL();
002B3C  880212     MOV W2, SR
1186:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
002B3E  050010     RETLW #0x1, W0
1187:                  }
1188:                   
1189:                  id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
1190:                  OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
002B40  B3C013     MOV.B #0x1, W3
002B42  208254     MOV #0x825, W4
002B44  784A03     MOV.B W3, [W4]
1191:                  OS_EXIT_CRITICAL();
002B46  880212     MOV W2, SR
1192:                 *perr = OS_ERR_NONE;
002B48  784A81     MOV.B W1, [W5]
1193:                  return (id);
002B4A  050000     RETLW #0x0, W0
1194:              }
1195:              #endif
1196:              
1197:              /*$PAGE*/
1198:              /*
1199:              *********************************************************************************************************
1200:              *                              SET THE CURRENT VALUE OF A TASK VARIABLE
1201:              *
1202:              * Description: This function is called to change the current value of a task register.  Task registers
1203:              *              are application specific and can be used to store task specific values such as 'error
1204:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1205:              *
1206:              * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
1207:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1208:              *
1209:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1210:              *                        than OS_TASK_REG_TBL_SIZE
1211:              *
1212:              *              value     is the desired value for the task register.
1213:              *
1214:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1215:              *
1216:              *                        OS_ERR_NONE            if the call was successful
1217:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1218:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1219:              *
1220:              * Returns    : The current value of the task's variable or 0 if an error is detected.
1221:              *
1222:              * Note(s)    : The maximum number of task variables is 254
1223:              *********************************************************************************************************
1224:              */
1225:              
1226:              #if OS_TASK_REG_TBL_SIZE > 0u
1227:              void  OSTaskRegSet (INT8U    prio,
1228:                                  INT8U    id,
1229:                                  INT32U   value,
1230:                                  INT8U   *perr)
1231:              {
002B4C  784300     MOV.B W0, W6
1232:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1233:                  OS_CPU_SR  cpu_sr = 0u;
1234:              #endif
1235:                  OS_TCB    *ptcb;
1236:              
1237:              
1238:              #ifdef OS_SAFETY_CRITICAL
1239:                  if (perr == (INT8U *)0) {
1240:                      OS_SAFETY_CRITICAL_EXCEPTION();
1241:                      return;
1242:                  }
1243:              #endif
1244:              
1245:              #if OS_ARG_CHK_EN > 0u
1246:                  if (prio >= OS_LOWEST_PRIO) {
002B4E  534FE9     SUB.B W6, #0x9, [W15]
002B50  360003     BRA LEU, 0x2B58
1247:                      if (prio != OS_PRIO_SELF) {
002B54  434FE1     ADD.B W6, #0x1, [W15]
002B56  3A0003     BRA NZ, 0x2B5E
1248:                          *perr = OS_ERR_PRIO_INVALID;
002B52  B3C2A0     MOV.B #0x2A, W0
1249:                          return;
1250:                      }
1251:                  }
1252:                  if (id >= OS_TASK_REG_TBL_SIZE) {
002B58  E00401     CP0.B W1
002B5A  320003     BRA Z, 0x2B62
1253:                      *perr = OS_ERR_ID_INVALID;
002B5C  B3C080     MOV.B #0x8, W0
002B5E  784A00     MOV.B W0, [W4]
1254:                      return;
002B60  060000     RETURN
1255:                  }
1256:              #endif
1257:                  OS_ENTER_CRITICAL();
002B62  800211     MOV SR, W1
002B64  200E00     MOV #0xE0, W0
002B66  B72042     IOR SR
1258:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
002B68  434FE1     ADD.B W6, #0x1, [W15]
002B6A  3A0002     BRA NZ, 0x2B70
1259:                      ptcb = OSTCBCur;
002B6C  8040E0     MOV OSTCBCur, W0
002B6E  370004     BRA 0x2B78
1260:                  } else {
1261:                      ptcb = OSTCBPrioTbl[prio];
002B70  FB8006     ZE W6, W0
002B72  400000     ADD W0, W0, W0
002B74  2169E5     MOV #0x169E, W5
002B76  780065     MOV [W5+W0], W0
1262:                  }
1263:                  ptcb->OSTCBRegTbl[id] = value;
002B78  981832     MOV W2, [W0+54]
002B7A  981843     MOV W3, [W0+56]
1264:                  OS_EXIT_CRITICAL();
002B7C  880211     MOV W1, SR
1265:                  *perr                 = OS_ERR_NONE;
002B7E  EB4A00     CLR.B [W4]
002B80  060000     RETURN
1266:              }
1267:              #endif
1268:              
1269:              /*$PAGE*/
1270:              /*
1271:              *********************************************************************************************************
1272:              *                                    CATCH ACCIDENTAL TASK RETURN
1273:              *
1274:              * Description: This function is called if a task accidentally returns without deleting itself.  In other
1275:              *              words, a task should either be an infinite loop or delete itself if it's done.
1276:              *
1277:              * Arguments  : none
1278:              *
1279:              * Returns    : none
1280:              *
1281:              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
1282:              *********************************************************************************************************
1283:              */
1284:              
1285:              void  OS_TaskReturn (void)
1286:              {
1287:                  OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
002B82  8040E0     MOV OSTCBCur, W0
002B84  0711EB     RCALL OSTaskReturnHook
1288:              
1289:              #if OS_TASK_DEL_EN > 0u
1290:                  (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
002B86  EBC000     SETM.B W0
002B88  37FE02     BRA OSTaskDel
1291:              #else
1292:                  for (;;) {
1293:                      OSTimeDly(OS_TICKS_PER_SEC);
1294:                  }
1295:              #endif
1296:              }
1297:              
1298:              /*$PAGE*/
1299:              /*
1300:              *********************************************************************************************************
1301:              *                                          CLEAR TASK STACK
1302:              *
1303:              * Description: This function is used to clear the stack of a task (i.e. write all zeros)
1304:              *
1305:              * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
1306:              *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
1307:              *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
1308:              *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
1309:              *                       highest memory location of the stack and the stack will grow with increasing
1310:              *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
1311:              *
1312:              *              size     is the number of 'stack elements' to clear.
1313:              *
1314:              *              opt      contains additional information (or options) about the behavior of the task.  The
1315:              *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
1316:              *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
1317:              *
1318:              * Returns    : none
1319:              *********************************************************************************************************
1320:              */
1321:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1322:              void  OS_TaskStkClr (OS_STK  *pbos,
002B8A  6080E3     AND W1, #0x3, W1
1323:                                   INT32U   size,
1324:                                   INT16U   opt)
1325:              {
1326:                  if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
1327:                      if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
002B8C  508FE3     SUB W1, #0x3, [W15]
002B8E  320004     BRA Z, 0x2B98
002B90  060000     RETURN
1328:              #if OS_STK_GROWTH == 1u
1329:                          while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
1330:                              size--;
1331:                              *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
1332:                          }
1333:              #else
1334:                          while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
002B98  510FE0     SUB W2, #0x0, [W15]
002B9A  598FE0     SUBB W3, #0x0, [W15]
002B9C  3AFFFA     BRA NZ, 0x2B92
002B9E  060000     RETURN
1335:                              size--;
002B92  510161     SUB W2, #0x1, W2
002B94  5981E0     SUBB W3, #0x0, W3
1336:                              *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
002B96  EB1000     CLR [W0--]
1337:                          }
1338:              #endif
1339:                      }
1340:                  }
1341:              }
1342:              
1343:              #endif
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Source/os_sem.c  -------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                          SEMAPHORE MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_SEM.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if OS_SEM_EN > 0u
31:                /*$PAGE*/
32:                /*
33:                *********************************************************************************************************
34:                *                                          ACCEPT SEMAPHORE
35:                *
36:                * Description: This function checks the semaphore to see if a resource is available or, if an event
37:                *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
38:                *              resource is not available or the event did not occur.
39:                *
40:                * Arguments  : pevent     is a pointer to the event control block
41:                *
42:                * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
43:                *                         decremented to obtain the resource.
44:                *              == 0       if the resource is not available or the event did not occur or,
45:                *                         if 'pevent' is a NULL pointer or,
46:                *                         if you didn't pass a pointer to a semaphore
47:                *********************************************************************************************************
48:                */
49:                
50:                #if OS_SEM_ACCEPT_EN > 0u
51:                INT16U  OSSemAccept (OS_EVENT *pevent)
52:                {
00385C  780080     MOV W0, W1
53:                    INT16U     cnt;
54:                #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
55:                    OS_CPU_SR  cpu_sr = 0u;
56:                #endif
57:                
58:                
59:                
60:                #if OS_ARG_CHK_EN > 0u
61:                    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
003860  E00001     CP0 W1
003862  32000C     BRA Z, 0x387C
62:                        return (0u);
00385E  EB0000     CLR W0
63:                    }
64:                #endif
65:                    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
003864  B3C032     MOV.B #0x3, W2
003866  114F91     SUBR.B W2, [W1], [W15]
003868  3A0009     BRA NZ, 0x387C
66:                        return (0u);
67:                    }
68:                    OS_ENTER_CRITICAL();
00386A  800212     MOV SR, W2
00386C  200E00     MOV #0xE0, W0
00386E  B72042     IOR SR
69:                    cnt = pevent->OSEventCnt;
003870  900021     MOV [W1+4], W0
70:                    if (cnt > 0u) {                                   /* See if resource is available                  */
003872  E00000     CP0 W0
003874  320002     BRA Z, 0x387A
71:                        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
003876  E90180     DEC W0, W3
003878  9800A3     MOV W3, [W1+4]
72:                    }
73:                    OS_EXIT_CRITICAL();
00387A  880212     MOV W2, SR
74:                    return (cnt);                                     /* Return semaphore count                        */
75:                }
00387C  060000     RETURN
76:                #endif
77:                
78:                /*$PAGE*/
79:                /*
80:                *********************************************************************************************************
81:                *                                         CREATE A SEMAPHORE
82:                *
83:                * Description: This function creates a semaphore.
84:                *
85:                * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
86:                *                            available (or no event has occurred).  You initialize the semaphore to a
87:                *                            non-zero value to specify how many resources are available (e.g. if you have
88:                *                            10 resources, you would initialize the semaphore to 10).
89:                *
90:                * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
91:                *                            created semaphore
92:                *              == (void *)0  if no event control blocks were available
93:                *********************************************************************************************************
94:                */
95:                
96:                OS_EVENT  *OSSemCreate (INT16U cnt)
97:                {
00387E  781F88     MOV W8, [W15++]
003880  780180     MOV W0, W3
98:                    OS_EVENT  *pevent;
99:                #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
100:                   OS_CPU_SR  cpu_sr = 0u;
101:               #endif
102:               
103:               
104:               
105:               #ifdef OS_SAFETY_CRITICAL_IEC61508
106:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
107:                       OS_SAFETY_CRITICAL_EXCEPTION();
108:                       return ((OS_EVENT *)0);
109:                   }
110:               #endif
111:               
112:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
003884  E24811     CP0.B OSIntNesting
003886  3A0014     BRA NZ, 0x38B0
113:                       return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
003882  EB0400     CLR W8
114:                   }
115:                   OS_ENTER_CRITICAL();
003888  800211     MOV SR, W1
00388A  200E00     MOV #0xE0, W0
00388C  B72042     IOR SR
116:                   pevent = OSEventFreeList;                              /* Get next free event control block        */
00388E  804028     MOV OSEventFreeList, W8
117:                   if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
003890  E00008     CP0 W8
003892  320002     BRA Z, 0x3898
118:                       OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
003894  900018     MOV [W8+2], W0
003896  884020     MOV W0, OSEventFreeList
119:                   }
120:                   OS_EXIT_CRITICAL();
003898  880211     MOV W1, SR
121:                   if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
00389A  E00008     CP0 W8
00389C  320009     BRA Z, 0x38B0
122:                       pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00389E  B3C031     MOV.B #0x3, W1
0038A0  784C01     MOV.B W1, [W8]
123:                       pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
0038A2  980423     MOV W3, [W8+4]
124:                       pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
0038A4  EB0000     CLR W0
0038A6  980410     MOV W0, [W8+2]
125:               #if OS_EVENT_NAME_EN > 0u
126:                       pevent->OSEventName    = (INT8U *)(void *)"?";
0038A8  29E7E0     MOV #0x9E7E, W0
0038AA  980450     MOV W0, [W8+10]
127:               #endif
128:                       OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
0038AC  780008     MOV W8, W0
0038AE  07F49F     RCALL OS_EventWaitListInit
129:                   }
130:                   return (pevent);
131:               }
0038B0  780008     MOV W8, W0
0038B2  78044F     MOV [--W15], W8
0038B4  060000     RETURN
132:               
133:               /*$PAGE*/
134:               /*
135:               *********************************************************************************************************
136:               *                                         DELETE A SEMAPHORE
137:               *
138:               * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
139:               *
140:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
141:               *                            semaphore.
142:               *
143:               *              opt           determines delete options as follows:
144:               *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
145:               *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
146:               *                                                    In this case, all the tasks pending will be readied.
147:               *
148:               *              perr          is a pointer to an error code that can contain one of the following values:
149:               *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
150:               *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
151:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
152:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
153:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
154:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
155:               *
156:               * Returns    : pevent        upon error
157:               *              (OS_EVENT *)0 if the semaphore was successfully deleted.
158:               *
159:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
160:               *                 the semaphore MUST check the return code of OSSemPend().
161:               *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
162:               *                 they check 'pevent' to see that it's a NULL pointer.
163:               *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
164:               *                 time is directly proportional to the number of tasks waiting on the semaphore.
165:               *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
166:               *                 applications where the semaphore is used for mutual exclusion because the resource(s)
167:               *                 will no longer be guarded by the semaphore.
168:               *              5) All tasks that were waiting for the semaphore will be readied and returned an 
169:               *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
170:               *********************************************************************************************************
171:               */
172:               
173:               #if OS_SEM_DEL_EN > 0u
174:               OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
175:                                    INT8U      opt,
176:                                    INT8U     *perr)
177:               {
0038B6  BE9F88     MOV.D W8, [W15++]
0038B8  BE9F8A     MOV.D W10, [W15++]
0038BA  780400     MOV W0, W8
0038BC  780482     MOV W2, W9
178:                   BOOLEAN    tasks_waiting;
179:                   OS_EVENT  *pevent_return;
180:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
181:                   OS_CPU_SR  cpu_sr = 0u;
182:               #endif
183:               
184:               
185:               
186:               #ifdef OS_SAFETY_CRITICAL
187:                   if (perr == (INT8U *)0) {
188:                       OS_SAFETY_CRITICAL_EXCEPTION();
189:                       return ((OS_EVENT *)0);
190:                   }
191:               #endif
192:               
193:               #if OS_ARG_CHK_EN > 0u
194:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
0038C0  E00008     CP0 W8
0038C2  32003D     BRA Z, 0x393E
195:                       *perr = OS_ERR_PEVENT_NULL;
0038BE  B3C040     MOV.B #0x4, W0
196:                       return (pevent);
197:                   }
198:               #endif
199:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
0038C4  B3C030     MOV.B #0x3, W0
0038C6  104F98     SUBR.B W0, [W8], [W15]
0038C8  320002     BRA Z, 0x38CE
200:                       *perr = OS_ERR_EVENT_TYPE;
0038CA  B3C010     MOV.B #0x1, W0
0038CC  370038     BRA 0x393E
201:                       return (pevent);
202:                   }
203:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0038D0  E24811     CP0.B OSIntNesting
0038D2  3A0035     BRA NZ, 0x393E
204:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0038CE  B3C0F0     MOV.B #0xF, W0
205:                       return (pevent);
206:                   }
207:                   OS_ENTER_CRITICAL();
0038D4  80021A     MOV SR, W10
0038D6  200E00     MOV #0xE0, W0
0038D8  B72042     IOR SR
208:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
209:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
0038DA  904068     MOV.B [W8+6], W0
0038DC  FB8000     ZE W0, W0
0038DE  EA0000     NEG W0, W0
0038E0  DE004F     LSR W0, #15, W0
0038E2  784580     MOV.B W0, W11
210:                   } else {
211:                       tasks_waiting = OS_FALSE;                          /* No                                       */
212:                   }
213:                   switch (opt) {
0038E4  E00401     CP0.B W1
0038E6  320003     BRA Z, 0x38EE
0038E8  50CFE1     SUB.B W1, #0x1, [W15]
0038EA  3A0027     BRA NZ, 0x393A
0038EC  370014     BRA 0x3916
214:                       case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
215:                            if (tasks_waiting == OS_FALSE) {
0038EE  E00400     CP0.B W0
0038F0  3A000A     BRA NZ, 0x3906
216:               #if OS_EVENT_NAME_EN > 0u
217:                                pevent->OSEventName    = (INT8U *)(void *)"?";
0038F2  29E7E1     MOV #0x9E7E, W1
0038F4  980451     MOV W1, [W8+10]
218:               #endif
219:                                pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0038F6  784C00     MOV.B W0, [W8]
220:                                pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
0038F8  804020     MOV OSEventFreeList, W0
0038FA  980410     MOV W0, [W8+2]
221:                                pevent->OSEventCnt     = 0u;
0038FC  EB0000     CLR W0
0038FE  980420     MOV W0, [W8+4]
222:                                OSEventFreeList        = pevent;          /* Get next free event control block        */
003900  884028     MOV W8, OSEventFreeList
223:                                OS_EXIT_CRITICAL();
003902  88021A     MOV W10, SR
003904  370017     BRA 0x3934
224:                                *perr                  = OS_ERR_NONE;
225:                                pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
226:                            } else {
227:                                OS_EXIT_CRITICAL();
003906  88021A     MOV W10, SR
228:                                *perr                  = OS_ERR_TASK_WAITING;
003908  B3C490     MOV.B #0x49, W0
00390A  370019     BRA 0x393E
229:                                pevent_return          = pevent;
230:                            }
231:                            break;
232:               
233:                       case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
234:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
003916  904068     MOV.B [W8+6], W0
003918  E00400     CP0.B W0
00391A  3AFFF8     BRA NZ, 0x390C
235:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00390C  B3C023     MOV.B #0x2, W3
00390E  B3C012     MOV.B #0x1, W2
003910  EB0080     CLR W1
003912  780008     MOV W8, W0
003914  07F43B     RCALL OS_EventTaskRdy
236:                            }
237:               #if OS_EVENT_NAME_EN > 0u
238:                            pevent->OSEventName    = (INT8U *)(void *)"?";
00391C  29E7E1     MOV #0x9E7E, W1
00391E  980451     MOV W1, [W8+10]
239:               #endif
240:                            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
003920  784C00     MOV.B W0, [W8]
241:                            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
003922  804020     MOV OSEventFreeList, W0
003924  980410     MOV W0, [W8+2]
242:                            pevent->OSEventCnt     = 0u;
003926  EB0000     CLR W0
003928  980420     MOV W0, [W8+4]
243:                            OSEventFreeList        = pevent;              /* Get next free event control block        */
00392A  884028     MOV W8, OSEventFreeList
244:                            OS_EXIT_CRITICAL();
00392C  88021A     MOV W10, SR
245:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00392E  55CFE1     SUB.B W11, #0x1, [W15]
003930  3A0001     BRA NZ, 0x3934
246:                                OS_Sched();                               /* Find highest priority task ready to run  */
003932  07F4AB     RCALL OS_Sched
247:                            }
248:                            *perr                  = OS_ERR_NONE;
003934  EB4C80     CLR.B [W9]
249:                            pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
003936  EB0400     CLR W8
250:                            break;
003938  370003     BRA 0x3940
251:               
252:                       default:
253:                            OS_EXIT_CRITICAL();
00393A  88021A     MOV W10, SR
254:                            *perr                  = OS_ERR_INVALID_OPT;
00393C  B3C070     MOV.B #0x7, W0
00393E  784C80     MOV.B W0, [W9]
255:                            pevent_return          = pevent;
256:                            break;
257:                   }
258:                   return (pevent_return);
259:               }
003940  780008     MOV W8, W0
003942  BE054F     MOV.D [--W15], W10
003944  BE044F     MOV.D [--W15], W8
003946  060000     RETURN
260:               #endif
261:               
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                          PEND ON SEMAPHORE
266:               *
267:               * Description: This function waits for a semaphore.
268:               *
269:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
270:               *                            semaphore.
271:               *
272:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
273:               *                            wait for the resource up to the amount of time specified by this argument.
274:               *                            If you specify 0, however, your task will wait forever at the specified
275:               *                            semaphore or, until the resource becomes available (or the event occurs).
276:               *
277:               *              perr          is a pointer to where an error message will be deposited.  Possible error
278:               *                            messages are:
279:               *
280:               *                            OS_ERR_NONE         The call was successful and your task owns the resource
281:               *                                                or, the event you are waiting for occurred.
282:               *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
283:               *                                                'timeout'.
284:               *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
285:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
286:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
287:               *                                                would lead to a suspension.
288:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
289:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
290:               *
291:               * Returns    : none
292:               *********************************************************************************************************
293:               */
294:               /*$PAGE*/
295:               void  OSSemPend (OS_EVENT  *pevent,
296:                                INT32U     timeout,
297:                                INT8U     *perr)
298:               {
003948  BE9F88     MOV.D W8, [W15++]
00394A  781F8A     MOV W10, [W15++]
00394C  BE0400     MOV.D W0, W8
299:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
300:                   OS_CPU_SR  cpu_sr = 0u;
301:               #endif
302:               
303:               
304:               
305:               #ifdef OS_SAFETY_CRITICAL
306:                   if (perr == (INT8U *)0) {
307:                       OS_SAFETY_CRITICAL_EXCEPTION();
308:                       return;
309:                   }
310:               #endif
311:               
312:               #if OS_ARG_CHK_EN > 0u
313:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
003950  E00008     CP0 W8
003952  32000B     BRA Z, 0x396A
314:                       *perr = OS_ERR_PEVENT_NULL;
00394E  B3C040     MOV.B #0x4, W0
315:                       return;
316:                   }
317:               #endif
318:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
003954  B3C030     MOV.B #0x3, W0
003956  104F98     SUBR.B W0, [W8], [W15]
003958  320002     BRA Z, 0x395E
319:                       *perr = OS_ERR_EVENT_TYPE;
00395A  B3C010     MOV.B #0x1, W0
00395C  370006     BRA 0x396A
320:                       return;
321:                   }
322:                   if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
003960  E24811     CP0.B OSIntNesting
003962  3A0003     BRA NZ, 0x396A
323:                       *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00395E  B3C020     MOV.B #0x2, W0
324:                       return;
325:                   }
326:                   if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
003964  E24812     CP0.B OSLockNesting
003966  320003     BRA Z, 0x396E
327:                       *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
003968  B3C0D0     MOV.B #0xD, W0
00396A  784C80     MOV.B W0, [W9]
328:                       return;
00396C  370030     BRA 0x39CE
329:                   }
330:                   OS_ENTER_CRITICAL();
00396E  80021A     MOV SR, W10
003970  200E00     MOV #0xE0, W0
003972  B72042     IOR SR
331:                   if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
003974  9000A8     MOV [W8+4], W1
003976  E00001     CP0 W1
003978  320005     BRA Z, 0x3984
332:                       pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
00397A  E90081     DEC W1, W1
00397C  980421     MOV W1, [W8+4]
333:                       OS_EXIT_CRITICAL();
00397E  88021A     MOV W10, SR
334:                       *perr = OS_ERR_NONE;
003980  EB4C80     CLR.B [W9]
335:                       return;
003982  370025     BRA 0x39CE
336:                   }
337:                                                                     /* Otherwise, must wait until event occurs       */
338:                   OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
003984  8040E0     MOV OSTCBCur, W0
003986  905A20     MOV.B [W0+26], W4
003988  A00404     BSET.B W4, #0
00398A  985824     MOV.B W4, [W0+26]
339:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00398C  985831     MOV.B W1, [W0+27]
340:                   OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00398E  980832     MOV W2, [W0+22]
003990  980843     MOV W3, [W0+24]
341:                   OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
003992  780008     MOV W8, W0
003994  07F399     RCALL OS_EventTaskWait
342:                   OS_EXIT_CRITICAL();
003996  88021A     MOV W10, SR
343:                   OS_Sched();                                       /* Find next highest priority task ready         */
003998  07F478     RCALL OS_Sched
344:                   OS_ENTER_CRITICAL();
00399A  80021A     MOV SR, W10
00399C  200E00     MOV #0xE0, W0
00399E  B72042     IOR SR
345:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
0039A0  8040E0     MOV OSTCBCur, W0
0039A2  9058B0     MOV.B [W0+27], W1
0039A4  E00401     CP0.B W1
0039A6  320003     BRA Z, 0x39AE
0039A8  50CFE2     SUB.B W1, #0x2, [W15]
0039AA  3A0005     BRA NZ, 0x39B6
0039AC  370002     BRA 0x39B2
346:                       case OS_STAT_PEND_OK:
347:                            *perr = OS_ERR_NONE;
0039AE  784C81     MOV.B W1, [W9]
348:                            break;
0039B0  370006     BRA 0x39BE
349:               
350:                       case OS_STAT_PEND_ABORT:
351:                            *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
0039B2  B3C0E0     MOV.B #0xE, W0
0039B4  370003     BRA 0x39BC
352:                            break;
353:               
354:                       case OS_STAT_PEND_TO:
355:                       default:
356:                            OS_EventTaskRemove(OSTCBCur, pevent);
0039B6  780088     MOV W8, W1
0039B8  07F3C0     RCALL OS_EventTaskRemove
357:                            *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
0039BA  B3C0A0     MOV.B #0xA, W0
0039BC  784C80     MOV.B W0, [W9]
358:                            break;
359:                   }
360:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0039BE  8040E0     MOV OSTCBCur, W0
0039C0  EB4080     CLR.B W1
0039C2  985821     MOV.B W1, [W0+26]
361:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0039C4  985831     MOV.B W1, [W0+27]
362:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
0039C6  EB0080     CLR W1
0039C8  980811     MOV W1, [W0+18]
363:               #if (OS_EVENT_MULTI_EN > 0u)
364:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0039CA  980821     MOV W1, [W0+20]
365:               #endif
366:                   OS_EXIT_CRITICAL();
0039CC  88021A     MOV W10, SR
367:               }
0039CE  78054F     MOV [--W15], W10
0039D0  BE044F     MOV.D [--W15], W8
0039D2  060000     RETURN
368:               
369:               /*$PAGE*/
370:               /*
371:               *********************************************************************************************************
372:               *                                    ABORT WAITING ON A SEMAPHORE
373:               *
374:               * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
375:               *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
376:               *              the semaphore via OSSemPost().
377:               *
378:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
379:               *                            semaphore.
380:               *
381:               *              opt           determines the type of ABORT performed:
382:               *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
383:               *                                                     semaphore
384:               *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
385:               *                                                     semaphore
386:               *
387:               *              perr          is a pointer to where an error message will be deposited.  Possible error
388:               *                            messages are:
389:               *
390:               *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
391:               *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
392:               *                                                and informed of the aborted wait; check return value
393:               *                                                for the number of tasks whose wait on the semaphore
394:               *                                                was aborted.
395:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
396:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
397:               *
398:               * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
399:               *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
400:               *********************************************************************************************************
401:               */
402:               
403:               #if OS_SEM_PEND_ABORT_EN > 0u
404:               INT8U  OSSemPendAbort (OS_EVENT  *pevent,
405:                                      INT8U      opt,
406:                                      INT8U     *perr)
407:               {
0039D4  BE9F88     MOV.D W8, [W15++]
0039D6  BE9F8A     MOV.D W10, [W15++]
0039D8  780480     MOV W0, W9
0039DA  780502     MOV W2, W10
408:                   INT8U      nbr_tasks;
409:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
410:                   OS_CPU_SR  cpu_sr = 0u;
411:               #endif
412:               
413:               
414:               
415:               #ifdef OS_SAFETY_CRITICAL
416:                   if (perr == (INT8U *)0) {
417:                       OS_SAFETY_CRITICAL_EXCEPTION();
418:                       return (0u);
419:                   }
420:               #endif
421:               
422:               #if OS_ARG_CHK_EN > 0u
423:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0039DE  E00009     CP0 W9
0039E0  320025     BRA Z, 0x3A2C
424:                       *perr = OS_ERR_PEVENT_NULL;
0039DC  B3C040     MOV.B #0x4, W0
425:                       return (0u);
426:                   }
427:               #endif
428:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0039E2  B3C030     MOV.B #0x3, W0
0039E4  104F99     SUBR.B W0, [W9], [W15]
0039E6  320002     BRA Z, 0x39EC
429:                       *perr = OS_ERR_EVENT_TYPE;
0039E8  B3C010     MOV.B #0x1, W0
0039EA  370020     BRA 0x3A2C
430:                       return (0u);
431:                   }
432:                   OS_ENTER_CRITICAL();
0039EC  80021B     MOV SR, W11
0039EE  200E00     MOV #0xE0, W0
0039F0  B72042     IOR SR
433:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
0039F2  904069     MOV.B [W9+6], W0
0039F4  E00400     CP0.B W0
0039F6  320019     BRA Z, 0x3A2A
434:                       nbr_tasks = 0u;
435:                       switch (opt) {
0039F8  EB4400     CLR.B W8
0039FA  50CFE1     SUB.B W1, #0x1, [W15]
0039FC  3A000B     BRA NZ, 0x3A14
0039FE  370006     BRA 0x3A0C
436:                           case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
437:                                while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
003A0C  904069     MOV.B [W9+6], W0
003A0E  E00400     CP0.B W0
003A10  3AFFF7     BRA NZ, 0x3A00
003A12  370006     BRA 0x3A20
438:                                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
003A00  B3C023     MOV.B #0x2, W3
003A02  B3C012     MOV.B #0x1, W2
003A04  EB0080     CLR W1
003A06  780009     MOV W9, W0
003A08  07F3C1     RCALL OS_EventTaskRdy
439:                                    nbr_tasks++;
003A0A  E84408     INC.B W8, W8
440:                                }
441:                                break;
442:               
443:                           case OS_PEND_OPT_NONE:
444:                           default:                                  /* No,  ready HPT       waiting on semaphore     */
445:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
003A14  B3C023     MOV.B #0x2, W3
003A16  B3C012     MOV.B #0x1, W2
003A18  EB0080     CLR W1
003A1A  780009     MOV W9, W0
003A1C  07F3B7     RCALL OS_EventTaskRdy
446:                                nbr_tasks++;
003A1E  B3C018     MOV.B #0x1, W8
447:                                break;
448:                       }
449:                       OS_EXIT_CRITICAL();
003A20  88021B     MOV W11, SR
450:                       OS_Sched();                                   /* Find HPT ready to run                         */
003A22  07F433     RCALL OS_Sched
451:                       *perr = OS_ERR_PEND_ABORT;
003A24  B3C0E0     MOV.B #0xE, W0
003A26  784D00     MOV.B W0, [W10]
452:                       return (nbr_tasks);
003A28  370003     BRA 0x3A30
453:                   }
454:                   OS_EXIT_CRITICAL();
003A2A  88021B     MOV W11, SR
455:                   *perr = OS_ERR_NONE;
003A2C  784D00     MOV.B W0, [W10]
456:                   return (0u);                                      /* No tasks waiting on semaphore                 */
003A2E  EB4400     CLR.B W8
457:               }
003A30  784008     MOV.B W8, W0
003A32  BE054F     MOV.D [--W15], W10
003A34  BE044F     MOV.D [--W15], W8
003A36  060000     RETURN
458:               #endif
459:               
460:               /*$PAGE*/
461:               /*
462:               *********************************************************************************************************
463:               *                                         POST TO A SEMAPHORE
464:               *
465:               * Description: This function signals a semaphore
466:               *
467:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
468:               *                            semaphore.
469:               *
470:               * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
471:               *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
472:               *                                  signaled the semaphore more often than you waited on it with either
473:               *                                  OSSemAccept() or OSSemPend().
474:               *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
475:               *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
476:               *********************************************************************************************************
477:               */
478:               
479:               INT8U  OSSemPost (OS_EVENT *pevent)
480:               {
003A38  781F88     MOV W8, [W15++]
003A3A  780200     MOV W0, W4
481:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
482:                   OS_CPU_SR  cpu_sr = 0u;
483:               #endif
484:               
485:               
486:               
487:               #if OS_ARG_CHK_EN > 0u
488:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
003A3E  E00004     CP0 W4
003A40  32001B     BRA Z, 0x3A78
489:                       return (OS_ERR_PEVENT_NULL);
003A3C  B3C042     MOV.B #0x4, W2
490:                   }
491:               #endif
492:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
003A44  B3C030     MOV.B #0x3, W0
003A46  104F94     SUBR.B W0, [W4], [W15]
003A48  3A0017     BRA NZ, 0x3A78
493:                       return (OS_ERR_EVENT_TYPE);
003A42  B3C012     MOV.B #0x1, W2
494:                   }
495:                   OS_ENTER_CRITICAL();
003A4A  800218     MOV SR, W8
003A4C  200E00     MOV #0xE0, W0
003A4E  B72042     IOR SR
496:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
003A50  9040E4     MOV.B [W4+6], W1
003A52  E00401     CP0.B W1
003A54  320007     BRA Z, 0x3A64
497:                                                                     /* Ready HPT waiting on event                    */
498:                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
003A56  EB4180     CLR.B W3
003A58  EB0080     CLR W1
003A5A  780004     MOV W4, W0
003A5C  07F397     RCALL OS_EventTaskRdy
499:                       OS_EXIT_CRITICAL();
003A5E  880218     MOV W8, SR
500:                       OS_Sched();                                   /* Find HPT ready to run                         */
003A60  07F414     RCALL OS_Sched
003A62  370006     BRA 0x3A70
501:                       return (OS_ERR_NONE);
502:                   }
503:                   if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
003A64  9000A4     MOV [W4+4], W1
003A66  408FE1     ADD W1, #0x1, [W15]
003A68  320005     BRA Z, 0x3A74
504:                       pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
003A6A  E80081     INC W1, W1
003A6C  980221     MOV W1, [W4+4]
505:                       OS_EXIT_CRITICAL();
003A6E  880218     MOV W8, SR
506:                       return (OS_ERR_NONE);
003A70  EB4100     CLR.B W2
003A72  370002     BRA 0x3A78
507:                   }
508:                   OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
003A74  880218     MOV W8, SR
509:                   return (OS_ERR_SEM_OVF);
003A76  B3C332     MOV.B #0x33, W2
510:               }
003A78  784002     MOV.B W2, W0
003A7A  78044F     MOV [--W15], W8
003A7C  060000     RETURN
511:               
512:               /*$PAGE*/
513:               /*
514:               *********************************************************************************************************
515:               *                                          QUERY A SEMAPHORE
516:               *
517:               * Description: This function obtains information about a semaphore
518:               *
519:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
520:               *                            semaphore
521:               *
522:               *              p_sem_data    is a pointer to a structure that will contain information about the
523:               *                            semaphore.
524:               *
525:               * Returns    : OS_ERR_NONE         The call was successful and the message was sent
526:               *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
527:               *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
528:               *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
529:               *********************************************************************************************************
530:               */
531:               
532:               #if OS_SEM_QUERY_EN > 0u
533:               INT8U  OSSemQuery (OS_EVENT     *pevent,
003AA2  4302E9     ADD W6, #0x9, W5
534:                                  OS_SEM_DATA  *p_sem_data)
535:               {
003A7E  780300     MOV W0, W6
536:                   INT8U       i;
537:                   OS_PRIO    *psrc;
538:                   OS_PRIO    *pdest;
539:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
540:                   OS_CPU_SR   cpu_sr = 0u;
541:               #endif
542:               
543:               
544:               
545:               #if OS_ARG_CHK_EN > 0u
546:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
003A82  E00006     CP0 W6
003A84  320016     BRA Z, 0x3AB2
547:                       return (OS_ERR_PEVENT_NULL);
003A80  B3C042     MOV.B #0x4, W2
548:                   }
549:                   if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
003A88  E00001     CP0 W1
003A8A  320013     BRA Z, 0x3AB2
550:                       return (OS_ERR_PDATA_NULL);
003A86  B3C092     MOV.B #0x9, W2
551:                   }
552:               #endif
553:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
003A8E  B3C030     MOV.B #0x3, W0
003A90  104F96     SUBR.B W0, [W6], [W15]
003A92  3A000F     BRA NZ, 0x3AB2
554:                       return (OS_ERR_EVENT_TYPE);
003A8C  B3C012     MOV.B #0x1, W2
555:                   }
556:                   OS_ENTER_CRITICAL();
003A94  800214     MOV SR, W4
003A96  200E00     MOV #0xE0, W0
003A98  B72042     IOR SR
557:                   p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
003A9A  9041E6     MOV.B [W6+6], W3
003A9C  9840C3     MOV.B W3, [W1+4]
558:                   psrc                   = &pevent->OSEventTbl[0];
003AA0  430167     ADD W6, #0x7, W2
559:                   pdest                  = &p_sem_data->OSEventTbl[0];
003A9E  E88181     INC2 W1, W3
560:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
003AA6  510F85     SUB W2, W5, [W15]
003AA8  3AFFFD     BRA NZ, 0x3AA4
561:                       *pdest++ = *psrc++;
003AA4  7859B2     MOV.B [W2++], [W3++]
562:                   }
563:                   p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
003AAA  900326     MOV [W6+4], W6
003AAC  780886     MOV W6, [W1]
564:                   OS_EXIT_CRITICAL();
003AAE  880214     MOV W4, SR
565:                   return (OS_ERR_NONE);
003AB0  EB4100     CLR.B W2
566:               }
003AB2  784002     MOV.B W2, W0
003AB4  060000     RETURN
567:               #endif                                                     /* OS_SEM_QUERY_EN                          */
568:               
569:               /*$PAGE*/
570:               /*
571:               *********************************************************************************************************
572:               *                                            SET SEMAPHORE
573:               *
574:               * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
575:               *              this value would be 0.
576:               *
577:               *              You would typically use this function when a semaphore is used as a signaling mechanism
578:               *              and, you want to reset the count value.
579:               *
580:               * Arguments  : pevent     is a pointer to the event control block
581:               *
582:               *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
583:               *                         semaphore count.
584:               *
585:               *              perr       is a pointer to an error code returned by the function as follows:
586:               *
587:               *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
588:               *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
589:               *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
590:               *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
591:               *********************************************************************************************************
592:               */
593:               
594:               #if OS_SEM_SET_EN > 0u
595:               void  OSSemSet (OS_EVENT  *pevent,
596:                               INT16U     cnt,
597:                               INT8U     *perr)
598:               {
003AB6  780280     MOV W0, W5
599:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
600:                   OS_CPU_SR  cpu_sr = 0u;
601:               #endif
602:               
603:               
604:               
605:               #ifdef OS_SAFETY_CRITICAL
606:                   if (perr == (INT8U *)0) {
607:                       OS_SAFETY_CRITICAL_EXCEPTION();
608:                       return;
609:                   }
610:               #endif
611:               
612:               #if OS_ARG_CHK_EN > 0u
613:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
003ABA  E00005     CP0 W5
003ABC  320004     BRA Z, 0x3AC6
614:                       *perr = OS_ERR_PEVENT_NULL;
003AB8  B3C040     MOV.B #0x4, W0
615:                       return;
616:                   }
617:               #endif
618:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
003ABE  B3C030     MOV.B #0x3, W0
003AC0  104F95     SUBR.B W0, [W5], [W15]
003AC2  320003     BRA Z, 0x3ACA
619:                       *perr = OS_ERR_EVENT_TYPE;
003AC4  B3C010     MOV.B #0x1, W0
003AC6  784900     MOV.B W0, [W2]
620:                       return;
003AC8  060000     RETURN
621:                   }
622:                   OS_ENTER_CRITICAL();
003ACA  800213     MOV SR, W3
003ACC  200E00     MOV #0xE0, W0
003ACE  B72042     IOR SR
623:                   *perr = OS_ERR_NONE;
003AD0  EB4900     CLR.B [W2]
624:                   if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
003AD2  900225     MOV [W5+4], W4
003AD4  E00004     CP0 W4
003AD6  3A0003     BRA NZ, 0x3ADE
625:                       pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
626:                   } else {                                          /* No                                            */
627:                       if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
003AD8  904265     MOV.B [W5+6], W4
003ADA  E00404     CP0.B W4
003ADC  3A0002     BRA NZ, 0x3AE2
628:                           pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
003ADE  9802A1     MOV W1, [W5+4]
003AE0  370002     BRA 0x3AE6
629:                       } else {
630:                           *perr              = OS_ERR_TASK_WAITING;
003AE2  B3C490     MOV.B #0x49, W0
003AE4  784900     MOV.B W0, [W2]
631:                       }
632:                   }
633:                   OS_EXIT_CRITICAL();
003AE6  880213     MOV W3, SR
634:               }
635:               #endif
636:               
637:               #endif                                                /* OS_SEM_EN                                     */
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Source/os_core.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             CORE FUNCTIONS
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_CORE.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.10
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #define  OS_GLOBALS
28:                #include <ucos_ii.h>
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                      PRIORITY RESOLUTION TABLE
34:                *
35:                * Note: Index into table is bit pattern to resolve highest priority
36:                *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
37:                *********************************************************************************************************
38:                */
39:                
40:                INT8U  const  OSUnMapTbl[256] = {
41:                    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
42:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
43:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
44:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
45:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
46:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
47:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
48:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
49:                    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
50:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
51:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
52:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
53:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
54:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
55:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
56:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
57:                };
58:                
59:                /*$PAGE*/
60:                /*
61:                *********************************************************************************************************
62:                *                                         FUNCTION PROTOTYPES
63:                *********************************************************************************************************
64:                */
65:                
66:                static  void  OS_InitEventList(void);
67:                
68:                static  void  OS_InitMisc(void);
69:                
70:                static  void  OS_InitRdyList(void);
71:                
72:                static  void  OS_InitTaskIdle(void);
73:                
74:                #if OS_TASK_STAT_EN > 0u
75:                static  void  OS_InitTaskStat(void);
76:                #endif
77:                
78:                static  void  OS_InitTCBList(void);
79:                
80:                static  void  OS_SchedNew(void);
81:                
82:                /*$PAGE*/
83:                /*
84:                *********************************************************************************************************
85:                *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
86:                *
87:                * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
88:                *
89:                * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
90:                *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
91:                *                        type is irrelevant.
92:                *
93:                *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
94:                *                        mutex, mailbox or queue.
95:                *
96:                *              perr      is a pointer to an error code that can contain one of the following values:
97:                *
98:                *                        OS_ERR_NONE                if the name was copied to 'pname'
99:                *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
100:               *                                                   control block type.
101:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
102:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
103:               *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
104:               *
105:               * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
106:               *********************************************************************************************************
107:               */
108:               
109:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
110:               INT8U  OSEventNameGet (OS_EVENT   *pevent,
111:                                      INT8U     **pname,
112:                                      INT8U      *perr)
113:               {
00242A  BE9F88     MOV.D W8, [W15++]
00242C  780180     MOV W0, W3
00242E  780402     MOV W2, W8
114:                   INT8U      len;
115:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
116:                   OS_CPU_SR  cpu_sr = 0u;
117:               #endif
118:               
119:               
120:               
121:               #ifdef OS_SAFETY_CRITICAL
122:                   if (perr == (INT8U *)0) {
123:                       OS_SAFETY_CRITICAL_EXCEPTION();
124:                       return (0u);
125:                   }
126:               #endif
127:               
128:               #if OS_ARG_CHK_EN > 0u
129:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
002432  E00003     CP0 W3
002434  320003     BRA Z, 0x243C
130:                       *perr = OS_ERR_PEVENT_NULL;
002430  B3C040     MOV.B #0x4, W0
131:                       return (0u);
132:                   }
133:                   if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
002436  E00001     CP0 W1
002438  3A0004     BRA NZ, 0x2442
134:                       *perr = OS_ERR_PNAME_NULL;
00243A  B3C0C0     MOV.B #0xC, W0
00243C  784C00     MOV.B W0, [W8]
135:                       return (0u);
00243E  EB4000     CLR.B W0
002440  37000F     BRA 0x2460
136:                   }
137:               #endif
138:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
002444  E24811     CP0.B OSIntNesting
002446  3AFFFA     BRA NZ, 0x243C
139:                       *perr  = OS_ERR_NAME_GET_ISR;
002442  B3C110     MOV.B #0x11, W0
140:                       return (0u);
141:                   }
142:                   switch (pevent->OSEventType) {
002448  E94113     DEC.B [W3], W2
00244C  514FE3     SUB.B W2, #0x3, [W15]
00244E  3EFFF6     BRA GTU, 0x243C
143:                       case OS_EVENT_TYPE_SEM:
144:                       case OS_EVENT_TYPE_MUTEX:
145:                       case OS_EVENT_TYPE_MBOX:
146:                       case OS_EVENT_TYPE_Q:
147:                            break;
148:               
149:                       default:
150:                            *perr = OS_ERR_EVENT_TYPE;
00244A  B3C010     MOV.B #0x1, W0
151:                            return (0u);
152:                   }
153:                   OS_ENTER_CRITICAL();
002450  800219     MOV SR, W9
002452  200E00     MOV #0xE0, W0
002454  B72042     IOR SR
154:                   *pname = pevent->OSEventName;
002456  900053     MOV [W3+10], W0
002458  780880     MOV W0, [W1]
155:                   len    = OS_StrLen(*pname);
00245A  07FFDE     RCALL OS_StrLen
156:                   OS_EXIT_CRITICAL();
00245C  880219     MOV W9, SR
157:                   *perr  = OS_ERR_NONE;
00245E  EB4C00     CLR.B [W8]
158:                   return (len);
159:               }
002460  BE044F     MOV.D [--W15], W8
002462  060000     RETURN
160:               #endif
161:               
162:               /*$PAGE*/
163:               /*
164:               *********************************************************************************************************
165:               *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
166:               *
167:               * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
168:               *
169:               * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
170:               *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
171:               *                        matter the actual type.
172:               *
173:               *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
174:               *                        mutex, mailbox or queue.
175:               *
176:               *              perr      is a pointer to an error code that can contain one of the following values:
177:               *
178:               *                        OS_ERR_NONE                if the requested task is resumed
179:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
180:               *                                                   control block type.
181:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
182:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
183:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
184:               *
185:               * Returns    : None
186:               *********************************************************************************************************
187:               */
188:               
189:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
190:               void  OSEventNameSet (OS_EVENT  *pevent,
191:                                     INT8U     *pname,
192:                                     INT8U     *perr)
193:               {
001F42  780280     MOV W0, W5
194:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
195:                   OS_CPU_SR  cpu_sr = 0u;
196:               #endif
197:               
198:               
199:               
200:               #ifdef OS_SAFETY_CRITICAL
201:                   if (perr == (INT8U *)0) {
202:                       OS_SAFETY_CRITICAL_EXCEPTION();
203:                       return;
204:                   }
205:               #endif
206:               
207:               #if OS_ARG_CHK_EN > 0u
208:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
001F46  E00005     CP0 W5
001F48  32000A     BRA Z, 0x1F5E
209:                       *perr = OS_ERR_PEVENT_NULL;
001F44  B3C040     MOV.B #0x4, W0
210:                       return;
211:                   }
212:                   if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
001F4C  E00001     CP0 W1
001F4E  320007     BRA Z, 0x1F5E
213:                       *perr = OS_ERR_PNAME_NULL;
001F4A  B3C0C0     MOV.B #0xC, W0
214:                       return;
215:                   }
216:               #endif
217:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
001F52  E24811     CP0.B OSIntNesting
001F54  3A0004     BRA NZ, 0x1F5E
218:                       *perr = OS_ERR_NAME_SET_ISR;
001F50  B3C120     MOV.B #0x12, W0
219:                       return;
220:                   }
221:                   switch (pevent->OSEventType) {
001F56  E94195     DEC.B [W5], W3
001F58  51CFE3     SUB.B W3, #0x3, [W15]
001F5A  360003     BRA LEU, 0x1F62
222:                       case OS_EVENT_TYPE_SEM:
223:                       case OS_EVENT_TYPE_MUTEX:
224:                       case OS_EVENT_TYPE_MBOX:
225:                       case OS_EVENT_TYPE_Q:
226:                            break;
227:               
228:                       default:
229:                            *perr = OS_ERR_EVENT_TYPE;
001F5C  B3C010     MOV.B #0x1, W0
001F5E  784900     MOV.B W0, [W2]
230:                            return;
001F60  060000     RETURN
231:                   }
232:                   OS_ENTER_CRITICAL();
001F62  800213     MOV SR, W3
001F64  200E00     MOV #0xE0, W0
001F66  B72042     IOR SR
233:                   pevent->OSEventName = pname;
001F68  9802D1     MOV W1, [W5+10]
234:                   OS_EXIT_CRITICAL();
001F6A  880213     MOV W3, SR
235:                   *perr = OS_ERR_NONE;
001F6C  EB4900     CLR.B [W2]
001F6E  060000     RETURN
236:               }
237:               #endif
238:               
239:               /*$PAGE*/
240:               /*
241:               *********************************************************************************************************
242:               *                                       PEND ON MULTIPLE EVENTS
243:               *
244:               * Description: This function waits for multiple events.  If multiple events are ready at the start of the
245:               *              pend call, then all available events are returned as ready.  If the task must pend on the
246:               *              multiple events, then only the first posted or aborted event is returned as ready.
247:               *
248:               * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
249:               *
250:               *              pevents_rdy   is a pointer to an array to return which event control blocks are available
251:               *                            or ready.  The size of the array MUST be greater than or equal to the size
252:               *                            of the 'pevents_pend' array, including terminating NULL.
253:               *
254:               *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
255:               *                            events.  The size of the array MUST be greater than or equal to the size of
256:               *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
257:               *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
258:               *                            every available message-type event returns its messages in the 'pmsgs_rdy'
259:               *                            array at the same index as the event is returned in the 'pevents_rdy' array.
260:               *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
261:               *
262:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
263:               *                            wait for the resources up to the amount of time specified by this argument.
264:               *                            If you specify 0, however, your task will wait forever for the specified
265:               *                            events or, until the resources becomes available (or the events occur).
266:               *
267:               *              perr          is a pointer to where an error message will be deposited.  Possible error
268:               *                            messages are:
269:               *
270:               *                            OS_ERR_NONE         The call was successful and your task owns the resources
271:               *                                                or, the events you are waiting for occurred; check the
272:               *                                                'pevents_rdy' array for which events are available.
273:               *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
274:               *                                                'pevents_rdy' array for which events were aborted.
275:               *                            OS_ERR_TIMEOUT      The events were not received within the specified
276:               *                                                'timeout'.
277:               *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
278:               *                                                NULL pointer.
279:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
280:               *                                                mailboxes, and/or queues.
281:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
282:               *                                                would lead to a suspension.
283:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
284:               *
285:               * Returns    : >  0          the number of events returned as ready or aborted.
286:               *              == 0          if no events are returned as ready because of timeout or upon error.
287:               *
288:               * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
289:               *
290:               *                        semaphores, mailboxes, queues
291:               *
292:               *                 b. Return ALL available events and messages, if any
293:               *
294:               *                 c. Add    current task priority as pending to   each events's wait list
295:               *                      Performed in OS_EventTaskWaitMulti()
296:               *
297:               *                 d. Wait on any of multiple events
298:               *
299:               *                 e. Remove current task priority as pending from each events's wait list
300:               *                      Performed in OS_EventTaskRdy(), if events posted or aborted
301:               *
302:               *                 f. Return any event posted or aborted, if any
303:               *                      else
304:               *                    Return timeout
305:               *
306:               *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
307:               *                 case of any error(s).
308:               *********************************************************************************************************
309:               */
310:               /*$PAGE*/
311:               #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
312:               INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
313:                                         OS_EVENT  **pevents_rdy,
314:                                         void      **pmsgs_rdy,
315:                                         INT32U      timeout,
316:                                         INT8U      *perr)
317:               {
002300  BE9F88     MOV.D W8, [W15++]
002302  BE9F8A     MOV.D W10, [W15++]
002304  BE9F8C     MOV.D W12, [W15++]
002306  781F8E     MOV W14, [W15++]
002308  780480     MOV W0, W9
00230A  780401     MOV W1, W8
00230C  BE0502     MOV.D W2, W10
318:                   OS_EVENT  **pevents;
319:                   OS_EVENT   *pevent;
320:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
321:                   OS_Q       *pq;
322:               #endif
323:                   BOOLEAN     events_rdy;
324:                   INT16U      events_rdy_nbr;
325:                   INT8U       events_stat;
326:               #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
327:                   OS_CPU_SR   cpu_sr = 0u;
328:               #endif
329:               
330:               
331:               
332:               #ifdef OS_SAFETY_CRITICAL
333:                   if (perr == (INT8U *)0) {
334:                       OS_SAFETY_CRITICAL_EXCEPTION();
335:                       return (0u);
336:                   }
337:               #endif
338:               
339:               #if (OS_ARG_CHK_EN > 0u)
340:                   if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
00230E  E00009     CP0 W9
002310  320006     BRA Z, 0x231E
341:                      *perr =  OS_ERR_PEVENT_NULL;
342:                       return (0u);
343:                   }
344:                   if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
002312  E00019     CP0 [W9]
002314  320004     BRA Z, 0x231E
345:                      *perr =  OS_ERR_PEVENT_NULL;
346:                       return (0u);
347:                   }
348:                   if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
002316  E00008     CP0 W8
002318  320002     BRA Z, 0x231E
349:                      *perr =  OS_ERR_PEVENT_NULL;
350:                       return (0u);
351:                   }
352:                   if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
00231A  E0000A     CP0 W10
00231C  3A0002     BRA NZ, 0x2322
353:                      *perr =  OS_ERR_PEVENT_NULL;
00231E  B3C040     MOV.B #0x4, W0
002320  370014     BRA 0x234A
354:                       return (0u);
355:                   }
356:               #endif
357:               
358:                  *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
002322  EB0C00     CLR [W8]
359:               
360:                   pevents     =  pevents_pend;
361:                   pevent      = *pevents;
002324  780619     MOV [W9], W12
002326  780089     MOV W9, W1
00232A  78000C     MOV W12, W0
362:                   while  (pevent != (OS_EVENT *)0) {
002328  780109     MOV W9, W2
00232C  370006     BRA 0x233A
00233A  E00000     CP0 W0
00233C  3AFFF8     BRA NZ, 0x232E
363:                       switch (pevent->OSEventType) {                  /* Validate event block types                  */
00232E  B3C033     MOV.B #0x3, W3
002330  11CF90     SUBR.B W3, [W0], [W15]
002332  320002     BRA Z, 0x2338
364:               #if (OS_SEM_EN  > 0u)
365:                           case OS_EVENT_TYPE_SEM:
366:                                break;
367:               #endif
368:               #if (OS_MBOX_EN > 0u)
369:                           case OS_EVENT_TYPE_MBOX:
370:                                break;
371:               #endif
372:               #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
373:                           case OS_EVENT_TYPE_Q:
374:                                break;
375:               #endif
376:               
377:                           case OS_EVENT_TYPE_MUTEX:
378:                           case OS_EVENT_TYPE_FLAG:
379:                           default:
380:                               *perr = OS_ERR_EVENT_TYPE;
002334  B3C010     MOV.B #0x1, W0
002336  370009     BRA 0x234A
381:                                return (0u);
382:                       }
383:                       pevents++;
384:                       pevent = *pevents;
002338  780052     MOV [++W2], W0
385:                   }
386:               
387:                   if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
002340  E24811     CP0.B OSIntNesting
002342  3A0003     BRA NZ, 0x234A
388:                      *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
00233E  B3C020     MOV.B #0x2, W0
389:                       return (0u);
390:                   }
391:                   if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
002344  E24812     CP0.B OSLockNesting
002346  320004     BRA Z, 0x2350
392:                      *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
002348  B3C0D0     MOV.B #0xD, W0
00234A  784D80     MOV.B W0, [W11]
393:                       return (0u);
00234C  EB0680     CLR W13
00234E  37005E     BRA 0x240C
394:                   }
395:               
396:               /*$PAGE*/
397:                   events_rdy     =  OS_FALSE;
00235A  784002     MOV.B W2, W0
398:                   events_rdy_nbr =  0u;
002358  EB0680     CLR W13
399:                   events_stat    =  OS_STAT_RDY;
002356  EB4100     CLR.B W2
400:                   pevents        =  pevents_pend;
401:                   pevent         = *pevents;
402:                   OS_ENTER_CRITICAL();
002350  80021E     MOV SR, W14
002352  200E00     MOV #0xE0, W0
002354  B72042     IOR SR
403:                   while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
00235C  37000F     BRA 0x237C
00237C  E0000C     CP0 W12
00237E  3AFFEF     BRA NZ, 0x235E
404:                       switch (pevent->OSEventType) {
00235E  B3C033     MOV.B #0x3, W3
002360  11CF9C     SUBR.B W3, [W12], [W15]
002362  3A0041     BRA NZ, 0x23E6
405:               #if (OS_SEM_EN > 0u)
406:                           case OS_EVENT_TYPE_SEM:
407:                                if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
002364  9001AC     MOV [W12+4], W3
002366  E00003     CP0 W3
002368  320007     BRA Z, 0x2378
408:                                    pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00236A  E90183     DEC W3, W3
00236C  980623     MOV W3, [W12+4]
409:                                   *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
00236E  781C0C     MOV W12, [W8++]
410:                                     events_rdy   =  OS_TRUE;
002374  B3C010     MOV.B #0x1, W0
002376  370001     BRA 0x237A
411:                                   *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
002370  EB1D00     CLR [W10++]
412:                                     events_rdy_nbr++;
002372  E8068D     INC W13, W13
413:               
414:                                } else {
415:                                     events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
002378  B3C012     MOV.B #0x1, W2
416:                                }
417:                                break;
418:               #endif
419:               
420:               #if (OS_MBOX_EN > 0u)
421:                           case OS_EVENT_TYPE_MBOX:
422:                                if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
423:                                                                       /* ... return available message,           ... */
424:                                   *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
425:                                    pevent->OSEventPtr  = (void *)0;
426:                                   *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
427:                                     events_rdy         =  OS_TRUE;
428:                                     events_rdy_nbr++;
429:               
430:                                } else {
431:                                     events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
432:                                }
433:                                break;
434:               #endif
435:               
436:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
437:                           case OS_EVENT_TYPE_Q:
438:                                pq = (OS_Q *)pevent->OSEventPtr;
439:                                if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
440:                                                                       /* ... return available message,           ... */
441:                                   *pmsgs_rdy++ = (void *)*pq->OSQOut++;
442:                                    if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
443:                                        pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
444:                                    }
445:                                    pq->OSQEntries--;                  /* Update number of queue entries              */
446:                                   *pevents_rdy++ = pevent;            /* ... and return available queue event        */
447:                                     events_rdy   = OS_TRUE;
448:                                     events_rdy_nbr++;
449:               
450:                                } else {
451:                                     events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
452:                                }
453:                                break;
454:               #endif
455:               
456:                           case OS_EVENT_TYPE_MUTEX:
457:                           case OS_EVENT_TYPE_FLAG:
458:                           default:
459:                                OS_EXIT_CRITICAL();
460:                               *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
461:                               *perr        =  OS_ERR_EVENT_TYPE;
462:                                return (events_rdy_nbr);
463:                       }
464:                       pevents++;
465:                       pevent = *pevents;
00237A  780651     MOV [++W1], W12
466:                   }
467:               
468:                   if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
002380  504FE1     SUB.B W0, #0x1, [W15]
002382  3A0004     BRA NZ, 0x238C
469:                      *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
002384  EB0C00     CLR [W8]
470:                       OS_EXIT_CRITICAL();
002386  88021E     MOV W14, SR
471:                      *perr        =  OS_ERR_NONE;
002388  EB4D80     CLR.B [W11]
472:                       return (events_rdy_nbr);
00238A  370040     BRA 0x240C
473:                   }
474:               /*$PAGE*/
475:                                                                       /* Otherwise, must wait until any event occurs */
476:                   OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00238C  8040E0     MOV OSTCBCur, W0
00238E  9058A0     MOV.B [W0+26], W1
002390  A07401     BSET.B W1, #7
002392  70C082     IOR.B W1, W2, W1
002394  985821     MOV.B W1, [W0+26]
477:                                              OS_STAT_MULTI;           /* ... pend on multiple events                 */
478:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
002396  98583C     MOV.B W12, [W0+27]
479:                   OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
002398  980834     MOV W4, [W0+22]
00239A  980845     MOV W5, [W0+24]
480:                   OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00239C  780009     MOV W9, W0
00239E  07FEAE     RCALL OS_EventTaskWaitMulti
481:               
482:                   OS_EXIT_CRITICAL();
0023A0  88021E     MOV W14, SR
483:                   OS_Sched();                                         /* Find next highest priority task ready       */
0023A2  07FF73     RCALL OS_Sched
484:                   OS_ENTER_CRITICAL();
0023A4  80021E     MOV SR, W14
0023A6  200E00     MOV #0xE0, W0
0023A8  B72042     IOR SR
485:               
486:                   switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
0023AA  8040E0     MOV OSTCBCur, W0
0023AC  9058B0     MOV.B [W0+27], W1
0023AE  E00401     CP0.B W1
0023B0  320002     BRA Z, 0x23B6
0023B2  50CFE2     SUB.B W1, #0x2, [W15]
0023B4  3A0009     BRA NZ, 0x23C8
487:                       case OS_STAT_PEND_OK:
488:                       case OS_STAT_PEND_ABORT:
489:                            pevent = OSTCBCur->OSTCBEventPtr;
0023B6  900E10     MOV [W0+18], W12
490:                            if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
0023B8  E0000C     CP0 W12
0023BA  320004     BRA Z, 0x23C4
491:                               *pevents_rdy++   =  pevent;             /* ... return available event ...              */
0023BC  780C0C     MOV W12, [W8]
492:                               *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
0023BE  EB2C00     CLR [++W8]
493:                                 events_rdy_nbr =  1;
0023C0  20001D     MOV #0x1, W13
0023C2  370004     BRA 0x23CC
494:               
495:                            } else {                                   /* Else NO event available, handle as timeout  */
496:                                OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
0023C4  B3C011     MOV.B #0x1, W1
0023C6  985831     MOV.B W1, [W0+27]
497:                                OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
498:                            }
499:                            break;
500:               
501:                       case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
502:                       default:                                        /* ... remove task from events' wait lists     */
503:                            OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
0023C8  780089     MOV W9, W1
0023CA  07FECA     RCALL OS_EventTaskRemoveMulti
504:                            break;
505:                   }
506:               
507:                   switch (OSTCBCur->OSTCBStatPend) {
0023CC  8040E0     MOV OSTCBCur, W0
0023CE  905830     MOV.B [W0+27], W0
0023D0  E00400     CP0.B W0
0023D2  320003     BRA Z, 0x23DA
0023D4  504FE2     SUB.B W0, #0x2, [W15]
0023D6  3A000F     BRA NZ, 0x23F6
0023D8  37000B     BRA 0x23F0
508:                       case OS_STAT_PEND_OK:
509:                            switch (pevent->OSEventType) {             /* Return event's message                      */
0023DA  B3C030     MOV.B #0x3, W0
0023DC  104F9C     SUBR.B W0, [W12], [W15]
0023DE  3A0003     BRA NZ, 0x23E6
510:               #if (OS_SEM_EN > 0u)
511:                                case OS_EVENT_TYPE_SEM:
512:                                    *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
0023E0  EB0D00     CLR [W10]
513:                                     break;
514:               #endif
515:               
516:               #if ((OS_MBOX_EN > 0u) ||                 \
517:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
518:                                case OS_EVENT_TYPE_MBOX:
519:                                case OS_EVENT_TYPE_Q:
520:                                    *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
521:                                     break;
522:               #endif
523:               
524:                                case OS_EVENT_TYPE_MUTEX:
525:                                case OS_EVENT_TYPE_FLAG:
526:                                default:
527:                                     OS_EXIT_CRITICAL();
0023E6  88021E     MOV W14, SR
528:                                    *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
0023E8  EB0C00     CLR [W8]
529:                                    *perr        =  OS_ERR_EVENT_TYPE;
0023EA  B3C010     MOV.B #0x1, W0
0023EC  784D80     MOV.B W0, [W11]
530:                                     return (events_rdy_nbr);
0023EE  37000E     BRA 0x240C
531:                            }
532:                           *perr = OS_ERR_NONE;
0023E2  EB4D80     CLR.B [W11]
533:                            break;
0023E4  37000B     BRA 0x23FC
534:               
535:                       case OS_STAT_PEND_ABORT:
536:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
0023F0  EB0D00     CLR [W10]
537:                           *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
0023F2  B3C0E0     MOV.B #0xE, W0
0023F4  370002     BRA 0x23FA
538:                            break;
539:               
540:                       case OS_STAT_PEND_TO:
541:                       default:
542:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
0023F6  EB0D00     CLR [W10]
543:                           *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
0023F8  B3C0A0     MOV.B #0xA, W0
0023FA  784D80     MOV.B W0, [W11]
544:                            break;
545:                   }
546:               
547:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
0023FC  8040E0     MOV OSTCBCur, W0
0023FE  EB4080     CLR.B W1
002400  985821     MOV.B W1, [W0+26]
548:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
002402  985831     MOV.B W1, [W0+27]
549:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
002404  EB0080     CLR W1
002406  980811     MOV W1, [W0+18]
550:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
002408  980821     MOV W1, [W0+20]
551:               #if ((OS_MBOX_EN > 0u) ||                 \
552:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
553:                   OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
554:               #endif
555:                   OS_EXIT_CRITICAL();
00240A  88021E     MOV W14, SR
556:               
557:                   return (events_rdy_nbr);
558:               }
00240C  78000D     MOV W13, W0
00240E  78074F     MOV [--W15], W14
002410  BE064F     MOV.D [--W15], W12
002412  BE054F     MOV.D [--W15], W10
002414  BE044F     MOV.D [--W15], W8
002416  060000     RETURN
559:               #endif
560:               
561:               /*$PAGE*/
562:               /*
563:               *********************************************************************************************************
564:               *                                           INITIALIZATION
565:               *
566:               * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
567:               *              creating any uC/OS-II object and, prior to calling OSStart().
568:               *
569:               * Arguments  : none
570:               *
571:               * Returns    : none
572:               *********************************************************************************************************
573:               */
574:               
575:               void  OSInit (void)
576:               {
577:               #if OS_TASK_CREATE_EXT_EN > 0u
578:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
579:                   INT8U  err;
580:               #endif
581:               #endif
582:               
583:                   OSInitHookBegin();                                           /* Call port specific initialization code   */
00226E  07166F     RCALL OSInitHookBegin
584:               
585:                   OS_InitMisc();                                               /* Initialize miscellaneous variables       */
002270  07FE08     RCALL _OS_InitMisc
586:               
587:                   OS_InitRdyList();                                            /* Initialize the Ready List                */
002272  07FE16     RCALL _OS_InitRdyList
588:               
589:                   OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
002274  07FFCB     RCALL _OS_InitTCBList
590:               
591:                   OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
002276  07FFE3     RCALL _OS_InitEventList
592:               
593:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
594:                   OS_FlagInit();                                               /* Initialize the event flag structures     */
595:               #endif
596:               
597:               #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
598:                   OS_MemInit();                                                /* Initialize the memory manager            */
599:               #endif
600:               
601:               #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
602:                   OS_QInit();                                                  /* Initialize the message queue structures  */
603:               #endif
604:               
605:               #if OS_TASK_CREATE_EXT_EN > 0u
606:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
607:                   OS_TLS_Init(&err);                                           /* Initialize TLS, before creating tasks    */
608:                   if (err != OS_ERR_NONE) {
609:                       return;
610:                   }
611:               #endif
612:               #endif
613:               
614:                   OS_InitTaskIdle();                                           /* Create the Idle Task                     */
002278  07FE3A     RCALL _OS_InitTaskIdle
615:               #if OS_TASK_STAT_EN > 0u
616:                   OS_InitTaskStat();                                           /* Create the Statistic Task                */
00227A  07FE4E     RCALL _OS_InitTaskStat
617:               #endif
618:               
619:               #if OS_TMR_EN > 0u
620:                   OSTmr_Init();                                                /* Initialize the Timer Manager             */
621:               #endif
622:               
623:                   OSInitHookEnd();                                             /* Call port specific init. code            */
00227C  37166B     BRA OSInitHookEnd
624:               
625:               #if OS_DEBUG_EN > 0u
626:                   OSDebugInit();
627:               #endif
628:               }
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                              ENTER ISR
633:               *
634:               * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
635:               *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
636:               *              only perform rescheduling at the last nested ISR.
637:               *
638:               * Arguments  : none
639:               *
640:               * Returns    : none
641:               *
642:               * Notes      : 1) This function should be called with interrupts already disabled
643:               *              2) Your ISR can directly increment OSIntNesting without calling this function because
644:               *                 OSIntNesting has been declared 'global'.
645:               *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
646:               *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
647:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
648:               *                 end of the ISR.
649:               *              5) You are allowed to nest interrupts up to 255 levels deep.
650:               *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
651:               *                 OSIntEnter() is always called with interrupts disabled.
652:               *********************************************************************************************************
653:               */
654:               
655:               void  OSIntEnter (void)
656:               {
657:                   if (OSRunning == OS_TRUE) {
001F70  BFC816     MOV.B OSRunning, WREG
001F72  504FE1     SUB.B W0, #0x1, [W15]
001F74  3A0005     BRA NZ, 0x1F80
658:                       if (OSIntNesting < 255u) {
001F76  BFC811     MOV.B OSIntNesting, WREG
001F78  404FE1     ADD.B W0, #0x1, [W15]
001F7A  320002     BRA Z, 0x1F80
659:                           OSIntNesting++;                      /* Increment ISR nesting level                        */
001F7C  E84000     INC.B W0, W0
001F7E  B7E811     MOV.B WREG, OSIntNesting
001F80  060000     RETURN
660:                       }
661:                   }
662:               }
663:               /*$PAGE*/
664:               /*
665:               *********************************************************************************************************
666:               *                                              EXIT ISR
667:               *
668:               * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
669:               *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
670:               *              a new, high-priority task, is ready to run.
671:               *
672:               * Arguments  : none
673:               *
674:               * Returns    : none
675:               *
676:               * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
677:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
678:               *                 end of the ISR.
679:               *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
680:               *********************************************************************************************************
681:               */
682:               
683:               void  OSIntExit (void)
684:               {
001F82  781F88     MOV W8, [W15++]
685:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
686:                   OS_CPU_SR  cpu_sr = 0u;
687:               #endif
688:               
689:               
690:               
691:                   if (OSRunning == OS_TRUE) {
001F84  BFC816     MOV.B OSRunning, WREG
001F86  504FE1     SUB.B W0, #0x1, [W15]
001F88  3A0025     BRA NZ, 0x1FD4
692:                       OS_ENTER_CRITICAL();
001F8A  800218     MOV SR, W8
001F8C  200E00     MOV #0xE0, W0
001F8E  B72042     IOR SR
693:                       if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
001F90  BFC811     MOV.B OSIntNesting, WREG
001F92  320002     BRA Z, 0x1F98
694:                           OSIntNesting--;
001F94  E94000     DEC.B W0, W0
001F96  B7E811     MOV.B WREG, OSIntNesting
695:                       }
696:                       if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
001F98  E24811     CP0.B OSIntNesting
001F9A  3A001B     BRA NZ, 0x1FD2
697:                           if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
001F9C  E24812     CP0.B OSLockNesting
001F9E  3A0019     BRA NZ, 0x1FD2
698:                               OS_SchedNew();
001FA0  07FF8A     RCALL _OS_SchedNew
699:                               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
001FA2  208141     MOV #0x814, W1
001FA4  784091     MOV.B [W1], W1
001FA6  FB8001     ZE W1, W0
001FA8  400000     ADD W0, W0, W0
001FAA  2169E2     MOV #0x169E, W2
001FAC  780062     MOV [W2+W0], W0
001FAE  884100     MOV W0, OSTCBHighRdy
700:                               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
001FB0  208132     MOV #0x813, W2
001FB2  784112     MOV.B [W2], W2
001FB4  514F81     SUB.B W2, W1, [W15]
001FB6  32000D     BRA Z, 0x1FD2
701:               #if OS_TASK_PROFILE_EN > 0u
702:                                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
001FB8  901110     MOV [W0+34], W2
001FBA  9011A0     MOV [W0+36], W3
001FBC  410161     ADD W2, #0x1, W2
001FBE  4981E0     ADDC W3, #0x0, W3
001FC0  981012     MOV W2, [W0+34]
001FC2  981023     MOV W3, [W0+36]
703:               #endif
704:                                   OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
001FC4  804000     MOV OSCtxSwCtr, W0
001FC6  804011     MOV 0x802, W1
001FC8  400061     ADD W0, #0x1, W0
001FCA  4880E0     ADDC W1, #0x0, W1
001FCC  884000     MOV W0, OSCtxSwCtr
001FCE  884011     MOV W1, 0x802
705:               
706:               #if OS_TASK_CREATE_EXT_EN > 0u
707:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
708:                                   OS_TLS_TaskSw();
709:               #endif
710:               #endif
711:               
712:                                   OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
001FD0  0716C6     RCALL 0x4D5E
713:                               }
714:                           }
715:                       }
716:                       OS_EXIT_CRITICAL();
001FD2  880218     MOV W8, SR
717:                   }
718:               }
001FD4  78044F     MOV [--W15], W8
001FD6  060000     RETURN
719:               /*$PAGE*/
720:               /*
721:               *********************************************************************************************************
722:               *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
723:               *
724:               * Description: This function is called by the application code to indicate that all initialization has
725:               *              been completed and that kernel objects are no longer allowed to be created.
726:               *
727:               * Arguments  : none
728:               *
729:               * Returns    : none
730:               *
731:               * Note(s)    : 1) You should call this function when you no longer want to allow application code to
732:               *                 create kernel objects.
733:               *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
734:               *********************************************************************************************************
735:               */
736:               
737:               #ifdef OS_SAFETY_CRITICAL_IEC61508
738:               void  OSSafetyCriticalStart (void)
739:               {
740:                   OSSafetyCriticalStartFlag = OS_TRUE;
741:               }
742:               
743:               #endif
744:               
745:               /*$PAGE*/
746:               /*
747:               *********************************************************************************************************
748:               *                                         PREVENT SCHEDULING
749:               *
750:               * Description: This function is used to prevent rescheduling to take place.  This allows your application
751:               *              to prevent context switches until you are ready to permit context switching.
752:               *
753:               * Arguments  : none
754:               *
755:               * Returns    : none
756:               *
757:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
758:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
759:               *********************************************************************************************************
760:               */
761:               
762:               #if OS_SCHED_LOCK_EN > 0u
763:               void  OSSchedLock (void)
764:               {
765:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
766:                   OS_CPU_SR  cpu_sr = 0u;
767:               #endif
768:               
769:               
770:               
771:                   if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
001FD8  BFC816     MOV.B OSRunning, WREG
001FDA  504FE1     SUB.B W0, #0x1, [W15]
001FDC  3A000B     BRA NZ, 0x1FF4
772:                       OS_ENTER_CRITICAL();
001FDE  800211     MOV SR, W1
001FE0  200E00     MOV #0xE0, W0
001FE2  B72042     IOR SR
773:                       if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
001FE4  E24811     CP0.B OSIntNesting
001FE6  3A0005     BRA NZ, 0x1FF2
774:                           if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
001FE8  BFC812     MOV.B OSLockNesting, WREG
001FEA  404FE1     ADD.B W0, #0x1, [W15]
001FEC  320002     BRA Z, 0x1FF2
775:                               OSLockNesting++;                 /* Increment lock nesting level                       */
001FEE  E84000     INC.B W0, W0
001FF0  B7E812     MOV.B WREG, OSLockNesting
776:                           }
777:                       }
778:                       OS_EXIT_CRITICAL();
001FF2  880211     MOV W1, SR
001FF4  060000     RETURN
779:                   }
780:               }
781:               #endif
782:               
783:               /*$PAGE*/
784:               /*
785:               *********************************************************************************************************
786:               *                                          ENABLE SCHEDULING
787:               *
788:               * Description: This function is used to re-allow rescheduling.
789:               *
790:               * Arguments  : none
791:               *
792:               * Returns    : none
793:               *
794:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
795:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
796:               *********************************************************************************************************
797:               */
798:               
799:               #if OS_SCHED_LOCK_EN > 0u
800:               void  OSSchedUnlock (void)
801:               {
802:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
803:                   OS_CPU_SR  cpu_sr = 0u;
804:               #endif
805:               
806:               
807:               
808:                   if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
0022D2  BFC816     MOV.B OSRunning, WREG
0022D4  504FE1     SUB.B W0, #0x1, [W15]
0022D6  3A0013     BRA NZ, 0x22FE
809:                       OS_ENTER_CRITICAL();
0022D8  800213     MOV SR, W3
0022DA  200E00     MOV #0xE0, W0
0022DC  B72042     IOR SR
810:                       if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
0022DE  E24811     CP0.B OSIntNesting
0022E0  3A000D     BRA NZ, 0x22FC
811:                           if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
0022E2  208121     MOV #0x812, W1
0022E4  784091     MOV.B [W1], W1
0022E6  E00401     CP0.B W1
0022E8  320007     BRA Z, 0x22F8
812:                               OSLockNesting--;                           /* Decrement lock nesting level             */
0022EA  E94081     DEC.B W1, W1
0022EC  208122     MOV #0x812, W2
0022EE  784901     MOV.B W1, [W2]
813:                               if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
0022F0  E00401     CP0.B W1
0022F2  3A0002     BRA NZ, 0x22F8
814:                                   OS_EXIT_CRITICAL();
0022F4  880213     MOV W3, SR
815:                                   OS_Sched();                            /* See if a HPT is ready                    */
0022F6  37FFC9     BRA OS_Sched
816:                               } else {
817:                                   OS_EXIT_CRITICAL();
818:                               }
819:                           } else {
820:                               OS_EXIT_CRITICAL();
0022F8  880213     MOV W3, SR
0022FA  060000     RETURN
821:                           }
822:                       } else {
823:                           OS_EXIT_CRITICAL();
0022FC  880213     MOV W3, SR
0022FE  060000     RETURN
824:                       }
825:                   }
826:               }
827:               #endif
828:               
829:               /*$PAGE*/
830:               /*
831:               *********************************************************************************************************
832:               *                                         START MULTITASKING
833:               *
834:               * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
835:               *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
836:               *              and you MUST have created at least one task.
837:               *
838:               * Arguments  : none
839:               *
840:               * Returns    : none
841:               *
842:               * Note       : OSStartHighRdy() MUST:
843:               *                 a) Call OSTaskSwHook() then,
844:               *                 b) Set OSRunning to OS_TRUE.
845:               *                 c) Load the context of the task pointed to by OSTCBHighRdy.
846:               *                 d_ Execute the task.
847:               *********************************************************************************************************
848:               */
849:               
850:               void  OSStart (void)
851:               {
852:                   if (OSRunning == OS_FALSE) {
001FF6  E24816     CP0.B OSRunning
001FF8  3A000A     BRA NZ, 0x200E
853:                       OS_SchedNew();                               /* Find highest priority's task priority number   */
001FFA  07FF5D     RCALL _OS_SchedNew
854:                       OSPrioCur     = OSPrioHighRdy;
001FFC  BFC814     MOV.B OSPrioHighRdy, WREG
001FFE  B7E813     MOV.B WREG, OSPrioCur
855:                       OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
002000  FB8000     ZE W0, W0
002002  400000     ADD W0, W0, W0
002004  2169E1     MOV #0x169E, W1
002006  780061     MOV [W1+W0], W0
002008  884100     MOV W0, OSTCBHighRdy
856:                       OSTCBCur      = OSTCBHighRdy;
00200A  8840E0     MOV W0, OSTCBCur
857:                       OSStartHighRdy();                            /* Execute target specific code to start task     */
00200C  071665     RCALL 0x4CD8
00200E  060000     RETURN
858:                   }
859:               }
860:               /*$PAGE*/
861:               /*
862:               *********************************************************************************************************
863:               *                                      STATISTICS INITIALIZATION
864:               *
865:               * Description: This function is called by your application to establish CPU usage by first determining
866:               *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
867:               *              during that time.  CPU usage is then determined by a low priority task which keeps track
868:               *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
869:               *              determined by:
870:               *
871:               *                                             OSIdleCtr
872:               *                 CPU Usage (%) = 100 * (1 - ------------)
873:               *                                            OSIdleCtrMax
874:               *
875:               * Arguments  : none
876:               *
877:               * Returns    : none
878:               *********************************************************************************************************
879:               */
880:               
881:               #if OS_TASK_STAT_EN > 0u
882:               void  OSStatInit (void)
883:               {
002010  781F88     MOV W8, [W15++]
884:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
885:                   OS_CPU_SR  cpu_sr = 0u;
886:               #endif
887:               
888:               
889:               
890:                   OSTimeDly(2u);                               /* Synchronize with clock tick                        */
002012  200020     MOV #0x2, W0
002014  200001     MOV #0x0, W1
002016  071597     RCALL OSTimeDly
891:                   OS_ENTER_CRITICAL();
002018  800211     MOV SR, W1
00201A  200E08     MOV #0xE0, W8
00201C  780008     MOV W8, W0
00201E  B72042     IOR SR
892:                   OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
002020  EF2818     CLR OSIdleCtr
002022  EF281A     CLR 0x81A
893:                   OS_EXIT_CRITICAL();
002024  880211     MOV W1, SR
894:                   OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
002026  200640     MOV #0x64, W0
002028  200001     MOV #0x0, W1
00202A  07158D     RCALL OSTimeDly
895:                   OS_ENTER_CRITICAL();
00202C  800213     MOV SR, W3
00202E  780008     MOV W8, W0
002030  B72042     IOR SR
896:                   OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
002032  8040C0     MOV OSIdleCtr, W0
002034  8040D1     MOV 0x81A, W1
002036  884040     MOV W0, OSIdleCtrMax
002038  884051     MOV W1, 0x80A
897:                   OSStatRdy    = OS_TRUE;
00203A  B3C011     MOV.B #0x1, W1
00203C  208102     MOV #0x810, W2
00203E  784901     MOV.B W1, [W2]
898:                   OS_EXIT_CRITICAL();
002040  880213     MOV W3, SR
899:               }
002042  78044F     MOV [--W15], W8
002044  060000     RETURN
900:               #endif
901:               /*$PAGE*/
902:               /*
903:               *********************************************************************************************************
904:               *                                         PROCESS SYSTEM TICK
905:               *
906:               * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
907:               *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
908:               *              called by a high priority task.
909:               *
910:               * Arguments  : none
911:               *
912:               * Returns    : none
913:               *********************************************************************************************************
914:               */
915:               
916:               void  OSTimeTick (void)
917:               {
918:                   OS_TCB    *ptcb;
919:               #if OS_TICK_STEP_EN > 0u
920:                   BOOLEAN    step;
921:               #endif
922:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
923:                   OS_CPU_SR  cpu_sr = 0u;
924:               #endif
925:               
926:               
927:               
928:               #if OS_TIME_TICK_HOOK_EN > 0u
929:                   OSTimeTickHook();                                      /* Call user definable hook                     */
930:               #endif
931:               #if OS_TIME_GET_SET_EN > 0u
932:                   OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
933:                   OSTime++;
934:                   OS_EXIT_CRITICAL();
935:               #endif
936:                   if (OSRunning == OS_TRUE) {
002046  208161     MOV #0x816, W1
002048  784091     MOV.B [W1], W1
00204A  50CFE1     SUB.B W1, #0x1, [W15]
00204C  3A0039     BRA NZ, 0x20C0
937:               #if OS_TICK_STEP_EN > 0u
938:                       switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
00204E  BFC824     MOV.B OSTickStepState, WREG
002050  504FE1     SUB.B W0, #0x1, [W15]
002052  320036     BRA Z, 0x20C0
002054  390006     BRA NC, 0x2062
002056  504FE2     SUB.B W0, #0x2, [W15]
002058  3A0003     BRA NZ, 0x2060
939:                           case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
940:                                step = OS_TRUE;
941:                                break;
942:               
943:                           case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
944:                                step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
945:                                break;
946:               
947:                           case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
948:                                step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
949:                                OSTickStepState = OS_TICK_STEP_WAIT;
00205A  208240     MOV #0x824, W0
00205C  784801     MOV.B W1, [W0]
950:                                break;
00205E  370001     BRA 0x2062
951:               
952:                           default:                                       /* Invalid case, correct situation              */
953:                                step            = OS_TRUE;
954:                                OSTickStepState = OS_TICK_STEP_DIS;
002060  EF6824     CLR.B OSTickStepState
955:                                break;
956:                       }
957:                       if (step == OS_FALSE) {                            /* Return if waiting for step command           */
958:                           return;
959:                       }
960:               #endif
961:                       ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
002062  804117     MOV OSTCBList, W7
002064  208151     MOV #0x815, W1
002066  784091     MOV.B [W1], W1
962:                       while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
002068  370026     BRA 0x20B6
0020B6  905947     MOV.B [W7+28], W2
0020B8  514FEA     SUB.B W2, #0xA, [W15]
0020BA  3AFFD7     BRA NZ, 0x206A
0020BC  208152     MOV #0x815, W2
0020BE  784901     MOV.B W1, [W2]
0020C0  060000     RETURN
963:                           OS_ENTER_CRITICAL();
00206A  800214     MOV SR, W4
00206C  200E00     MOV #0xE0, W0
00206E  B72042     IOR SR
964:                           if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
002070  900937     MOV [W7+22], W2
002072  9009C7     MOV [W7+24], W3
002074  510FE0     SUB W2, #0x0, [W15]
002076  598FE0     SUBB W3, #0x0, [W15]
002078  32001C     BRA Z, 0x20B2
965:                               ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
00207A  510161     SUB W2, #0x1, W2
00207C  5981E0     SUBB W3, #0x0, W3
00207E  980BB2     MOV W2, [W7+22]
002080  980BC3     MOV W3, [W7+24]
966:                               if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
002082  510FE0     SUB W2, #0x0, [W15]
002084  598FE0     SUBB W3, #0x0, [W15]
002086  3A0015     BRA NZ, 0x20B2
967:               
968:                                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
002088  9059A7     MOV.B [W7+26], W3
00208A  780103     MOV W3, W2
00208C  B20372     AND #0x37, W2
00208E  320004     BRA Z, 0x2098
969:                                       ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
002090  B3CC82     MOV.B #0xC8, W2
002092  61C182     AND.B W3, W2, W3
002094  985BA3     MOV.B W3, [W7+26]
970:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
002096  B3C012     MOV.B #0x1, W2
971:                                   } else {
972:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
002098  985BB2     MOV.B W2, [W7+27]
973:                                   }
974:               
975:                                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
00209A  905927     MOV.B [W7+26], W2
00209C  A33802     BTST.Z W2, #3
00209E  3A0009     BRA NZ, 0x20B2
976:                                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
0020A0  906107     MOV.B [W7+32], W2
0020A2  70C082     IOR.B W1, W2, W1
977:                                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0020A4  905967     MOV.B [W7+30], W2
0020A6  FB8102     ZE W2, W2
0020A8  2161C3     MOV #0x161C, W3
0020AA  794363     MOV.B [W3+W2], W6
0020AC  905AF7     MOV.B [W7+31], W5
0020AE  734285     IOR.B W6, W5, W5
0020B0  797185     MOV.B W5, [W3+W2]
978:                                   }
979:                               }
980:                           }
981:                           ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
0020B2  9003F7     MOV [W7+14], W7
982:                           OS_EXIT_CRITICAL();
0020B4  880214     MOV W4, SR
983:                       }
984:                   }
985:               }
986:               
987:               /*$PAGE*/
988:               /*
989:               *********************************************************************************************************
990:               *                                             GET VERSION
991:               *
992:               * Description: This function is used to return the version number of uC/OS-II.  The returned value 
993:               *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
994:               *              2.01.00 would be returned as 20100.
995:               *
996:               * Arguments  : none
997:               *
998:               * Returns    : The version number of uC/OS-II multiplied by 10000.
999:               *********************************************************************************************************
1000:              */
1001:              
1002:              INT16U  OSVersion (void)
1003:              {
1004:                  return (OS_VERSION);
1005:              }
0020C2  2721B0     MOV #0x721B, W0
0020C4  060000     RETURN
1006:              
1007:              /*$PAGE*/
1008:              /*
1009:              *********************************************************************************************************
1010:              *                                           DUMMY FUNCTION
1011:              *
1012:              * Description: This function doesn't do anything.  It is called by OSTaskDel().
1013:              *
1014:              * Arguments  : none
1015:              *
1016:              * Returns    : none
1017:              *********************************************************************************************************
1018:              */
1019:              
1020:              #if OS_TASK_DEL_EN > 0u
1021:              void  OS_Dummy (void)
1022:              {
1023:              }
0020C6  060000     RETURN
1024:              #endif
1025:              
1026:              /*$PAGE*/
1027:              /*
1028:              *********************************************************************************************************
1029:              *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
1030:              *
1031:              * Description: This function is called by other uC/OS-II services and is used to ready a task that was
1032:              *              waiting for an event to occur.
1033:              *
1034:              * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
1035:              *
1036:              *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
1037:              *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
1038:              *                          service functions.
1039:              *
1040:              *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
1041:              *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
1042:              *
1043:              *              pend_stat   is used to indicate the readied task's pending status:
1044:              *
1045:              *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
1046:              *                                               an abort.
1047:              *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
1048:              *
1049:              * Returns    : none
1050:              *
1051:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1052:              *********************************************************************************************************
1053:              */
1054:              #if (OS_EVENT_EN)
1055:              INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
1056:                                      void      *pmsg,
1057:                                      INT8U      msk,
1058:                                      INT8U      pend_stat)
1059:              {
00218C  BE9F88     MOV.D W8, [W15++]
00218E  781F8A     MOV W10, [W15++]
002190  780400     MOV W0, W8
1060:                  OS_TCB   *ptcb;
1061:                  INT8U     y;
1062:                  INT8U     x;
1063:                  INT8U     prio;
1064:              #if OS_LOWEST_PRIO > 63u
1065:                  OS_PRIO  *ptbl;
1066:              #endif
1067:              
1068:              
1069:              #if OS_LOWEST_PRIO <= 63u
1070:                  y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
002192  904068     MOV.B [W8+6], W0
002194  FB8000     ZE W0, W0
002196  299E21     MOV #0x99E2, W1
002198  784261     MOV.B [W1+W0], W4
1071:                  x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00219A  FB8304     ZE W4, W6
00219C  440286     ADD W8, W6, W5
00219E  9042F5     MOV.B [W5+7], W5
0021A0  FB8285     ZE W5, W5
1072:                  prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
0021A2  20003A     MOV #0x3, W10
0021A4  DD250A     SL W4, W10, W10
0021A6  7AC0E1     MOV.B [W1+W5], W1
0021A8  454501     ADD.B W10, W1, W10
1073:              #else
1074:                  if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
1075:                      y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
1076:                  } else {
1077:                      y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
1078:                  }
1079:                  ptbl = &pevent->OSEventTbl[y];
1080:                  if ((*ptbl & 0xFFu) != 0u) {
1081:                      x = OSUnMapTbl[*ptbl & 0xFFu];
1082:                  } else {
1083:                      x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
1084:                  }
1085:                  prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
1086:              #endif
1087:              
1088:                  ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0021AA  FB808A     ZE W10, W1
0021AC  408081     ADD W1, W1, W1
0021AE  2169E4     MOV #0x169E, W4
0021B0  7884E4     MOV [W4+W1], W9
1089:                  ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
0021B2  B82260     MUL.UU W4, #0, W4
0021B4  980CB4     MOV W4, [W9+22]
0021B6  980CC5     MOV W5, [W9+24]
1090:              #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
1091:                  ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
1092:              #else
1093:                  pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
1094:              #endif
1095:                  ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
0021B8  EAC102     COM.B W2, W2
0021BA  9058A9     MOV.B [W9+26], W1
0021BC  614101     AND.B W2, W1, W2
0021BE  985CA2     MOV.B W2, [W9+26]
1096:                  ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
0021C0  985CB3     MOV.B W3, [W9+27]
1097:                                                                      /* See if task is ready (could be susp'd)      */
1098:                  if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
0021C2  A33802     BTST.Z W2, #3
0021C4  3A0007     BRA NZ, 0x21D4
1099:                      OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
0021C6  906009     MOV.B [W9+32], W0
0021C8  B76815     IOR.B OSRdyGrp
1100:                      OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
0021CA  2161C1     MOV #0x161C, W1
0021CC  7B41E1     MOV.B [W1+W6], W3
0021CE  905979     MOV.B [W9+31], W2
0021D0  71C102     IOR.B W3, W2, W2
0021D2  7B7082     MOV.B W2, [W1+W6]
1101:                  }
1102:              
1103:                  OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
0021D4  780088     MOV W8, W1
0021D6  780009     MOV W9, W0
0021D8  07FFB0     RCALL OS_EventTaskRemove
1104:              #if (OS_EVENT_MULTI_EN > 0u)
1105:                  if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
0021DA  9008A9     MOV [W9+20], W1
0021DC  E00001     CP0 W1
0021DE  320003     BRA Z, 0x21E6
1106:                      OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0021E0  780009     MOV W9, W0
0021E2  07FFBE     RCALL OS_EventTaskRemoveMulti
1107:                      ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
0021E4  980C98     MOV W8, [W9+18]
1108:                  }
1109:              #endif
1110:              
1111:                  return (prio);
1112:              }
0021E6  78400A     MOV.B W10, W0
0021E8  78054F     MOV [--W15], W10
0021EA  BE044F     MOV.D [--W15], W8
0021EC  060000     RETURN
1113:              #endif
1114:              /*$PAGE*/
1115:              /*
1116:              *********************************************************************************************************
1117:              *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
1118:              *
1119:              * Description: This function is called by other uC/OS-II services to suspend a task because an event has
1120:              *              not occurred.
1121:              *
1122:              * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
1123:              *
1124:              * Returns    : none
1125:              *
1126:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1127:              *********************************************************************************************************
1128:              */
1129:              #if (OS_EVENT_EN)
1130:              void  OS_EventTaskWait (OS_EVENT *pevent)
1131:              {
1132:                  INT8U  y;
1133:              
1134:              
1135:                  OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
0020C8  8040E1     MOV OSTCBCur, W1
0020CA  980890     MOV W0, [W1+18]
1136:              
1137:                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0020CC  905961     MOV.B [W1+30], W2
0020CE  FB8102     ZE W2, W2
0020D0  400182     ADD W0, W2, W3
0020D2  904273     MOV.B [W3+7], W4
0020D4  905971     MOV.B [W1+31], W2
0020D6  724102     IOR.B W4, W2, W2
0020D8  9841F2     MOV.B W2, [W3+7]
1138:                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0020DA  9041E0     MOV.B [W0+6], W3
0020DC  906101     MOV.B [W1+32], W2
0020DE  71C102     IOR.B W3, W2, W2
0020E0  984062     MOV.B W2, [W0+6]
1139:              
1140:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
1141:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0020E2  905961     MOV.B [W1+30], W2
0020E4  FB8102     ZE W2, W2
0020E6  2161C3     MOV #0x161C, W3
0020E8  905871     MOV.B [W1+31], W0
0020EA  EAC000     COM.B W0, W0
0020EC  794263     MOV.B [W3+W2], W4
0020EE  604004     AND.B W0, W4, W0
0020F0  797180     MOV.B W0, [W3+W2]
1142:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
0020F2  3A0003     BRA NZ, 0x20FA
1143:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0020F4  906001     MOV.B [W1+32], W0
0020F6  EAC000     COM.B W0, W0
0020F8  B66815     AND.B OSRdyGrp
0020FA  060000     RETURN
1144:                  }
1145:              }
1146:              #endif
1147:              /*$PAGE*/
1148:              /*
1149:              *********************************************************************************************************
1150:              *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
1151:              *
1152:              * Description: This function is called by other uC/OS-II services to suspend a task because any one of
1153:              *              multiple events has not occurred.
1154:              *
1155:              * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
1156:              *                               which the task will be waiting for.
1157:              *
1158:              * Returns    : none.
1159:              *
1160:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1161:              *********************************************************************************************************
1162:              */
1163:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1164:              void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
1165:              {
1166:                  OS_EVENT **pevents;
1167:                  OS_EVENT  *pevent;
1168:                  INT8U      y;
1169:              
1170:              
1171:                  OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
0020FC  8040E1     MOV OSTCBCur, W1
0020FE  EB0100     CLR W2
002100  980892     MOV W2, [W1+18]
1172:                  OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
002102  9808A0     MOV W0, [W1+20]
1173:              
1174:                  pevents =  pevents_wait;
1175:                  pevent  = *pevents;
002104  780110     MOV [W0], W2
1176:                  while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
002106  37000A     BRA 0x211C
002120  E00002     CP0 W2
002122  3AFFF2     BRA NZ, 0x2108
1177:                      pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
002108  FB8183     ZE W3, W3
00210A  410283     ADD W2, W3, W5
00210C  9041F5     MOV.B [W5+7], W3
00210E  71C204     IOR.B W3, W4, W4
002110  9842F4     MOV.B W4, [W5+7]
1178:                      pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
002112  904262     MOV.B [W2+6], W4
002114  906181     MOV.B [W1+32], W3
002116  724183     IOR.B W4, W3, W3
002118  984163     MOV.B W3, [W2+6]
1179:                      pevents++;
1180:                      pevent = *pevents;
00211A  780150     MOV [++W0], W2
00211C  9059E1     MOV.B [W1+30], W3
00211E  905A71     MOV.B [W1+31], W4
1181:                  }
1182:              
1183:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
1184:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
002124  FB8103     ZE W3, W2
002126  2161C3     MOV #0x161C, W3
002128  EAC004     COM.B W4, W0
00212A  7942E3     MOV.B [W3+W2], W5
00212C  604005     AND.B W0, W5, W0
00212E  797180     MOV.B W0, [W3+W2]
1185:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
002130  3A0003     BRA NZ, 0x2138
1186:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
002132  906001     MOV.B [W1+32], W0
002134  EAC000     COM.B W0, W0
002136  B66815     AND.B OSRdyGrp
002138  060000     RETURN
1187:                  }
1188:              }
1189:              #endif
1190:              /*$PAGE*/
1191:              /*
1192:              *********************************************************************************************************
1193:              *                                  REMOVE TASK FROM EVENT WAIT LIST
1194:              *
1195:              * Description: Remove a task from an event's wait list.
1196:              *
1197:              * Arguments  : ptcb     is a pointer to the task to remove.
1198:              *
1199:              *              pevent   is a pointer to the event control block.
1200:              *
1201:              * Returns    : none
1202:              *
1203:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1204:              *********************************************************************************************************
1205:              */
1206:              #if (OS_EVENT_EN)
1207:              void  OS_EventTaskRemove (OS_TCB   *ptcb,
1208:                                        OS_EVENT *pevent)
1209:              {
1210:                  INT8U  y;
1211:              
1212:              
1213:                  y                       =  ptcb->OSTCBY;
1214:                  pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
00213A  9059E0     MOV.B [W0+30], W3
00213C  FB8183     ZE W3, W3
00213E  408203     ADD W1, W3, W4
002140  905970     MOV.B [W0+31], W2
002142  EAC102     COM.B W2, W2
002144  904274     MOV.B [W4+7], W4
002146  614104     AND.B W2, W4, W2
002148  408183     ADD W1, W3, W3
00214A  9841F2     MOV.B W2, [W3+7]
1215:                  if (pevent->OSEventTbl[y] == 0u) {
00214C  E00402     CP0.B W2
00214E  3A0005     BRA NZ, 0x215A
1216:                      pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
002150  906100     MOV.B [W0+32], W2
002152  EAC102     COM.B W2, W2
002154  9041E1     MOV.B [W1+6], W3
002156  61C102     AND.B W3, W2, W2
002158  9840E2     MOV.B W2, [W1+6]
1217:                  }
1218:                  ptcb->OSTCBEventPtr     = (OS_EVENT  *)0;               /* Unlink OS_EVENT from OS_TCB             */
00215A  EB0080     CLR W1
00215C  980811     MOV W1, [W0+18]
1219:              }
00215E  060000     RETURN
1220:              #endif
1221:              /*$PAGE*/
1222:              /*
1223:              *********************************************************************************************************
1224:              *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
1225:              *
1226:              * Description: Remove a task from multiple events' wait lists.
1227:              *
1228:              * Arguments  : ptcb             is a pointer to the task to remove.
1229:              *
1230:              *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
1231:              *
1232:              * Returns    : none
1233:              *
1234:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1235:              *********************************************************************************************************
1236:              */
1237:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1238:              void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
1239:                                             OS_EVENT **pevents_multi)
1240:              {
1241:                  OS_EVENT **pevents;
1242:                  OS_EVENT  *pevent;
1243:                  INT8U      y;
1244:                  OS_PRIO    bity;
1245:                  OS_PRIO    bitx;
1246:              
1247:              
1248:                  y       =  ptcb->OSTCBY;
002160  905B60     MOV.B [W0+30], W6
1249:                  bity    =  ptcb->OSTCBBitY;
002162  906280     MOV.B [W0+32], W5
1250:                  bitx    =  ptcb->OSTCBBitX;
002164  905A70     MOV.B [W0+31], W4
1251:                  pevents =  pevents_multi;
1252:                  pevent  = *pevents;
002166  780011     MOV [W1], W0
1253:                  while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
002168  37000E     BRA 0x2186
002186  E00000     CP0 W0
002188  3AFFF0     BRA NZ, 0x216A
1254:                      pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
00216A  FB8186     ZE W6, W3
00216C  400103     ADD W0, W3, W2
00216E  EAC384     COM.B W4, W7
002170  904172     MOV.B [W2+7], W2
002172  63C102     AND.B W7, W2, W2
002174  400183     ADD W0, W3, W3
002176  9841F2     MOV.B W2, [W3+7]
1255:                      if (pevent->OSEventTbl[y] == 0u) {
002178  E00402     CP0.B W2
00217A  3A0004     BRA NZ, 0x2184
1256:                          pevent->OSEventGrp &= (OS_PRIO)~bity;
00217C  EAC105     COM.B W5, W2
00217E  9041E0     MOV.B [W0+6], W3
002180  61C102     AND.B W3, W2, W2
002182  984062     MOV.B W2, [W0+6]
1257:                      }
1258:                      pevents++;
1259:                      pevent = *pevents;
002184  780051     MOV [++W1], W0
1260:                  }
1261:              }
00218A  060000     RETURN
1262:              #endif
1263:              /*$PAGE*/
1264:              /*
1265:              *********************************************************************************************************
1266:              *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
1267:              *
1268:              * Description: This function is called by other uC/OS-II services to initialize the event wait list.
1269:              *
1270:              * Arguments  : pevent    is a pointer to the event control block allocated to the event.
1271:              *
1272:              * Returns    : none
1273:              *
1274:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1275:              *********************************************************************************************************
1276:              */
1277:              #if (OS_EVENT_EN)
1278:              void  OS_EventWaitListInit (OS_EVENT *pevent)
0021F2  E88080     INC2 W0, W1
1279:              {
1280:                  INT8U  i;
1281:              
1282:              
1283:                  pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
0021EE  EB4080     CLR.B W1
0021F0  984061     MOV.B W1, [W0+6]
1284:                  for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0021FA  500F81     SUB W0, W1, [W15]
0021FC  3AFFFB     BRA NZ, 0x21F4
1285:                      pevent->OSEventTbl[i] = 0u;
0021F4  EB4100     CLR.B W2
0021F6  984072     MOV.B W2, [W0+7]
0021F8  E80000     INC W0, W0
1286:                  }
1287:              }
0021FE  060000     RETURN
1288:              #endif
1289:              /*$PAGE*/
1290:              /*
1291:              *********************************************************************************************************
1292:              *                                             INITIALIZATION
1293:              *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
1294:              *
1295:              * Description: This function is called by OSInit() to initialize the free list of event control blocks.
1296:              *
1297:              * Arguments  : none
1298:              *
1299:              * Returns    : none
1300:              *********************************************************************************************************
1301:              */
1302:              
1303:              static  void  OS_InitEventList (void)
1304:              {
1305:              #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
1306:              #if (OS_MAX_EVENTS > 1u)
1307:                  INT16U     ix;
1308:                  INT16U     ix_next;
1309:                  OS_EVENT  *pevent1;
1310:                  OS_EVENT  *pevent2;
1311:              
1312:              
1313:                  OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00223E  200481     MOV #0x48, W1
002240  215540     MOV #0x1554, W0
002242  07FFDE     RCALL OS_MemClr
002244  215540     MOV #0x1554, W0
1314:                  for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
002246  EB0080     CLR W1
00225A  508FE5     SUB W1, #0x5, [W15]
00225C  3AFFF5     BRA NZ, 0x2248
1315:                      ix_next = ix + 1u;
002248  E80081     INC W1, W1
1316:                      pevent1 = &OSEventTbl[ix];
1317:                      pevent2 = &OSEventTbl[ix_next];
00224C  B90A6C     MUL.SU W1, #12, W4
00224E  215542     MOV #0x1554, W2
002250  410184     ADD W2, W4, W3
1318:                      pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00224A  EB4800     CLR.B [W0]
1319:                      pevent1->OSEventPtr     = pevent2;
002252  980013     MOV W3, [W0+2]
1320:              #if OS_EVENT_NAME_EN > 0u
1321:                      pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
002254  299E03     MOV #0x99E0, W3
002256  980053     MOV W3, [W0+10]
002258  40006C     ADD W0, #0xC, W0
1322:              #endif
1323:                  }
1324:                  pevent1                         = &OSEventTbl[ix];
1325:                  pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00225E  2003C0     MOV #0x3C, W0
002260  400002     ADD W0, W2, W0
002262  EB4800     CLR.B [W0]
1326:                  pevent1->OSEventPtr             = (OS_EVENT *)0;
002264  E88000     INC2 W0, W0
002266  EB0800     CLR [W0]
1327:              #if OS_EVENT_NAME_EN > 0u
1328:                  pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
002268  88ACD3     MOV W3, 0x159A
1329:              #endif
1330:                  OSEventFreeList                 = &OSEventTbl[0];
00226A  884022     MOV W2, OSEventFreeList
1331:              #else
1332:                  OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
1333:                  OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
1334:                  OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
1335:              #if OS_EVENT_NAME_EN > 0u
1336:                  OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
1337:              #endif
1338:              #endif
1339:              #endif
1340:              }
00226C  060000     RETURN
1341:              /*$PAGE*/
1342:              /*
1343:              *********************************************************************************************************
1344:              *                                             INITIALIZATION
1345:              *                                    INITIALIZE MISCELLANEOUS VARIABLES
1346:              *
1347:              * Description: This function is called by OSInit() to initialize miscellaneous variables.
1348:              *
1349:              * Arguments  : none
1350:              *
1351:              * Returns    : none
1352:              *********************************************************************************************************
1353:              */
1354:              
1355:              static  void  OS_InitMisc (void)
1356:              {
1357:              #if OS_TIME_GET_SET_EN > 0u
1358:                  OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
1359:              #endif
1360:              
1361:                  OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
001E82  EF6811     CLR.B OSIntNesting
1362:                  OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
001E84  EF6812     CLR.B OSLockNesting
1363:              
1364:                  OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
001E86  EF6817     CLR.B OSTaskCtr
1365:              
1366:                  OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
001E88  EF6816     CLR.B OSRunning
1367:              
1368:                  OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
001E8A  EF2800     CLR OSCtxSwCtr
001E8C  EF2802     CLR 0x802
1369:                  OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
001E8E  EF2818     CLR OSIdleCtr
001E90  EF281A     CLR 0x81A
1370:              
1371:              #if OS_TASK_STAT_EN > 0u
1372:                  OSIdleCtrRun              = 0uL;
001E92  EF280C     CLR OSIdleCtrRun
001E94  EF280E     CLR 0x80E
1373:                  OSIdleCtrMax              = 0uL;
001E96  EF2808     CLR OSIdleCtrMax
001E98  EF280A     CLR 0x80A
1374:                  OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
001E9A  EF6810     CLR.B OSStatRdy
1375:              #endif
1376:              
1377:              #ifdef OS_SAFETY_CRITICAL_IEC61508
1378:                  OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
1379:              #endif
1380:              
1381:              #if OS_TASK_REG_TBL_SIZE > 0u
1382:                  OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
001E9C  EF6825     CLR.B OSTaskRegNextAvailID
1383:              #endif
1384:              }
001E9E  060000     RETURN
1385:              /*$PAGE*/
1386:              /*
1387:              *********************************************************************************************************
1388:              *                                             INITIALIZATION
1389:              *                                       INITIALIZE THE READY LIST
1390:              *
1391:              * Description: This function is called by OSInit() to initialize the Ready List.
1392:              *
1393:              * Arguments  : none
1394:              *
1395:              * Returns    : none
1396:              *********************************************************************************************************
1397:              */
1398:              
1399:              static  void  OS_InitRdyList (void)
001EA4  E88080     INC2 W0, W1
1400:              {
1401:                  INT8U  i;
1402:              
1403:              
1404:                  OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
001EA0  EF6815     CLR.B OSRdyGrp
001EA2  2161B0     MOV #0x161B, W0
1405:                  for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
001EA8  500F81     SUB W0, W1, [W15]
001EAA  3AFFFD     BRA NZ, 0x1EA6
1406:                      OSRdyTbl[i] = 0u;
001EA6  EB6800     CLR.B [++W0]
1407:                  }
1408:              
1409:                  OSPrioCur     = 0u;
001EAC  EF6813     CLR.B OSPrioCur
1410:                  OSPrioHighRdy = 0u;
001EAE  EF6814     CLR.B OSPrioHighRdy
1411:              
1412:                  OSTCBHighRdy  = (OS_TCB *)0;
001EB0  EF2820     CLR OSTCBHighRdy
1413:                  OSTCBCur      = (OS_TCB *)0;
001EB2  EF281C     CLR OSTCBCur
1414:              }
001EB4  060000     RETURN
1415:              
1416:              /*$PAGE*/
1417:              /*
1418:              *********************************************************************************************************
1419:              *                                             INITIALIZATION
1420:              *                                         CREATING THE IDLE TASK
1421:              *
1422:              * Description: This function creates the Idle Task.
1423:              *
1424:              * Arguments  : none
1425:              *
1426:              * Returns    : none
1427:              *********************************************************************************************************
1428:              */
1429:              
1430:              static  void  OS_InitTaskIdle (void)
1431:              {
001EEE  FA0002     LNK #0x2
1432:              #if OS_TASK_NAME_EN > 0u
1433:                  INT8U  err;
1434:              #endif
1435:              
1436:              
1437:              #if OS_TASK_CREATE_EXT_EN > 0u
1438:                  #if OS_STK_GROWTH == 1u
1439:                  (void)OSTaskCreateExt(OS_TaskIdle,
1440:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1441:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
1442:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1443:                                        OS_TASK_IDLE_ID,
1444:                                        &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
1445:                                        OS_TASK_IDLE_STK_SIZE,
1446:                                        (void *)0,                                 /* No TCB extension                     */
1447:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1448:                  #else
1449:                  (void)OSTaskCreateExt(OS_TaskIdle,
001EF0  200030     MOV #0x3, W0
001EF2  781F80     MOV W0, [W15++]
001EF4  EB1F80     CLR [W15++]
001EF6  200406     MOV #0x40, W6
001EF8  200007     MOV #0x0, W7
001EFA  2169C5     MOV #0x169C, W5
001EFC  EB8200     SETM W4
001EFE  B3C0A3     MOV.B #0xA, W3
001F00  2FF822     MOV #0xFF82, W2
001F02  410105     ADD W2, W5, W2
001F04  EB0080     CLR W1
001F06  21ED60     MOV #0x1ED6, W0
001F08  07064B     RCALL OSTaskCreateExt
1450:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1451:                                        &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
1452:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1453:                                        OS_TASK_IDLE_ID,
1454:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
1455:                                        OS_TASK_IDLE_STK_SIZE,
1456:                                        (void *)0,                                 /* No TCB extension                     */
1457:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1458:                  #endif
1459:              #else
1460:                  #if OS_STK_GROWTH == 1u
1461:                  (void)OSTaskCreate(OS_TaskIdle,
1462:                                     (void *)0,
1463:                                     &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
1464:                                     OS_TASK_IDLE_PRIO);
1465:                  #else
1466:                  (void)OSTaskCreate(OS_TaskIdle,
1467:                                     (void *)0,
1468:                                     &OSTaskIdleStk[0],
1469:                                     OS_TASK_IDLE_PRIO);
1470:                  #endif
1471:              #endif
1472:              
1473:              #if OS_TASK_NAME_EN > 0u
1474:                  OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
001F0A  578166     SUB W15, #0x6, W2
001F0C  299C41     MOV #0x99C4, W1
001F0E  B3C0A0     MOV.B #0xA, W0
001F10  0704FB     RCALL OSTaskNameSet
001F12  5787E4     SUB W15, #0x4, W15
1475:              #endif
1476:              }
001F14  FA8000     ULNK
001F16  060000     RETURN
1477:              /*$PAGE*/
1478:              /*
1479:              *********************************************************************************************************
1480:              *                                             INITIALIZATION
1481:              *                                      CREATING THE STATISTIC TASK
1482:              *
1483:              * Description: This function creates the Statistic Task.
1484:              *
1485:              * Arguments  : none
1486:              *
1487:              * Returns    : none
1488:              *********************************************************************************************************
1489:              */
1490:              
1491:              #if OS_TASK_STAT_EN > 0u
1492:              static  void  OS_InitTaskStat (void)
1493:              {
001F18  FA0002     LNK #0x2
1494:              #if OS_TASK_NAME_EN > 0u
1495:                  INT8U  err;
1496:              #endif
1497:              
1498:              
1499:              #if OS_TASK_CREATE_EXT_EN > 0u
1500:                  #if OS_STK_GROWTH == 1u
1501:                  (void)OSTaskCreateExt(OS_TaskStat,
1502:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1503:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
1504:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1505:                                        OS_TASK_STAT_ID,
1506:                                        &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
1507:                                        OS_TASK_STAT_STK_SIZE,
1508:                                        (void *)0,                                   /* No TCB extension               */
1509:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1510:                  #else
1511:                  (void)OSTaskCreateExt(OS_TaskStat,
001F1A  200030     MOV #0x3, W0
001F1C  781F80     MOV W0, [W15++]
001F1E  EB1F80     CLR [W15++]
001F20  200406     MOV #0x40, W6
001F22  200007     MOV #0x0, W7
001F24  2161A5     MOV #0x161A, W5
001F26  2FFFE4     MOV #0xFFFE, W4
001F28  B3C093     MOV.B #0x9, W3
001F2A  2FF822     MOV #0xFF82, W2
001F2C  410105     ADD W2, W5, W2
001F2E  EB0080     CLR W1
001F30  224A00     MOV #0x24A0, W0
001F32  070636     RCALL OSTaskCreateExt
1512:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1513:                                        &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
1514:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1515:                                        OS_TASK_STAT_ID,
1516:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
1517:                                        OS_TASK_STAT_STK_SIZE,
1518:                                        (void *)0,                                   /* No TCB extension               */
1519:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1520:                  #endif
1521:              #else
1522:                  #if OS_STK_GROWTH == 1u
1523:                  (void)OSTaskCreate(OS_TaskStat,
1524:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1525:                                     &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
1526:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1527:                  #else
1528:                  (void)OSTaskCreate(OS_TaskStat,
1529:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1530:                                     &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
1531:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1532:                  #endif
1533:              #endif
1534:              
1535:              #if OS_TASK_NAME_EN > 0u
1536:                  OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
001F34  578166     SUB W15, #0x6, W2
001F36  299D21     MOV #0x99D2, W1
001F38  B3C090     MOV.B #0x9, W0
001F3A  0704E6     RCALL OSTaskNameSet
001F3C  5787E4     SUB W15, #0x4, W15
1537:              #endif
1538:              }
001F3E  FA8000     ULNK
001F40  060000     RETURN
1539:              #endif
1540:              /*$PAGE*/
1541:              /*
1542:              *********************************************************************************************************
1543:              *                                             INITIALIZATION
1544:              *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
1545:              *
1546:              * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
1547:              *
1548:              * Arguments  : none
1549:              *
1550:              * Returns    : none
1551:              *********************************************************************************************************
1552:              */
1553:              
1554:              static  void  OS_InitTCBList (void)
1555:              {
1556:                  INT8U    ix;
1557:                  INT8U    ix_next;
1558:                  OS_TCB  *ptcb1;
1559:                  OS_TCB  *ptcb2;
1560:              
1561:              
1562:                  OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
00220C  202441     MOV #0x244, W1
00220E  216B40     MOV #0x16B4, W0
002210  07FFF7     RCALL OS_MemClr
1563:                  OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
002212  200161     MOV #0x16, W1
002214  2169E0     MOV #0x169E, W0
002216  07FFF4     RCALL OS_MemClr
002218  216C21     MOV #0x16C2, W1
00221A  EB0000     CLR W0
00221C  E80000     INC W0, W0
1564:                  for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
00222C  500FE9     SUB W0, #0x9, [W15]
00222E  3AFFF6     BRA NZ, 0x221C
1565:                      ix_next =  ix + 1u;
1566:                      ptcb1   = &OSTCBTbl[ix];
1567:                      ptcb2   = &OSTCBTbl[ix_next];
00221E  2003A4     MOV #0x3A, W4
002220  B98204     MUL.SS W0, W4, W4
002222  216B42     MOV #0x16B4, W2
002224  410884     ADD W2, W4, [W1]
1568:                      ptcb1->OSTCBNext = ptcb2;
1569:              #if OS_TASK_NAME_EN > 0u
1570:                      ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
002226  299E03     MOV #0x99E0, W3
002228  9810B3     MOV W3, [W1+38]
00222A  B003A1     ADD #0x3A, W1
1571:              #endif
1572:                  }
1573:                  ptcb1                   = &OSTCBTbl[ix];
1574:                  ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
002230  202180     MOV #0x218, W0
002232  400002     ADD W0, W2, W0
002234  EB0800     CLR [W0]
1575:              #if OS_TASK_NAME_EN > 0u
1576:                  ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
002236  88C793     MOV W3, 0x18F2
1577:              #endif
1578:                  OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
002238  EF2822     CLR OSTCBList
1579:                  OSTCBFreeList           = &OSTCBTbl[0];
00223A  8840F2     MOV W2, OSTCBFreeList
1580:              }
00223C  060000     RETURN
1581:              /*$PAGE*/
1582:              /*
1583:              *********************************************************************************************************
1584:              *                                      CLEAR A SECTION OF MEMORY
1585:              *
1586:              * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
1587:              *
1588:              * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
1589:              *
1590:              *              size     is the number of bytes to clear.
1591:              *
1592:              * Returns    : none
1593:              *
1594:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1595:              *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
1596:              *                 of the uses of this function gets close to this limit.
1597:              *              3) The clear is done one byte at a time since this will work on any processor irrespective
1598:              *                 of the alignment of the destination.
1599:              *********************************************************************************************************
1600:              */
1601:              
1602:              void  OS_MemClr (INT8U  *pdest,
1603:                               INT16U  size)
1604:              {
1605:                  while (size > 0u) {
002200  370002     BRA 0x2206
002206  E00001     CP0 W1
002208  3AFFFC     BRA NZ, 0x2202
1606:                      *pdest++ = (INT8U)0;
002202  EB5800     CLR.B [W0++]
1607:                      size--;
002204  E90081     DEC W1, W1
1608:                  }
1609:              }
00220A  060000     RETURN
1610:              /*$PAGE*/
1611:              /*
1612:              *********************************************************************************************************
1613:              *                                       COPY A BLOCK OF MEMORY
1614:              *
1615:              * Description: This function is called by other uC/OS-II services to copy a block of memory from one
1616:              *              location to another.
1617:              *
1618:              * Arguments  : pdest    is a pointer to the 'destination' memory block
1619:              *
1620:              *              psrc     is a pointer to the 'source'      memory block
1621:              *
1622:              *              size     is the number of bytes to copy.
1623:              *
1624:              * Returns    : none
1625:              *
1626:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
1627:              *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
1628:              *                 is not a situation that will happen.
1629:              *              2) Note that we can only copy up to 64K bytes of RAM
1630:              *              3) The copy is done one byte at a time since this will work on any processor irrespective
1631:              *                 of the alignment of the source and destination.
1632:              *********************************************************************************************************
1633:              */
1634:              
1635:              void  OS_MemCopy (INT8U  *pdest,
1636:                                INT8U  *psrc,
1637:                                INT16U  size)
1638:              {
1639:                  while (size > 0u) {
00227E  370002     BRA 0x2284
002284  E00002     CP0 W2
002286  3AFFFC     BRA NZ, 0x2280
1640:                      *pdest++ = *psrc++;
002280  785831     MOV.B [W1++], [W0++]
1641:                      size--;
002282  E90102     DEC W2, W2
1642:                  }
1643:              }
002288  060000     RETURN
1644:              /*$PAGE*/
1645:              /*
1646:              *********************************************************************************************************
1647:              *                                              SCHEDULER
1648:              *
1649:              * Description: This function is called by other uC/OS-II services to determine whether a new, high
1650:              *              priority task has been made ready to run.  This function is invoked by TASK level code
1651:              *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
1652:              *
1653:              * Arguments  : none
1654:              *
1655:              * Returns    : none
1656:              *
1657:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1658:              *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
1659:              *********************************************************************************************************
1660:              */
1661:              
1662:              void  OS_Sched (void)
1663:              {
00228A  781F88     MOV W8, [W15++]
1664:              #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
1665:                  OS_CPU_SR  cpu_sr = 0u;
1666:              #endif
1667:              
1668:              
1669:              
1670:                  OS_ENTER_CRITICAL();
00228C  800218     MOV SR, W8
00228E  200E00     MOV #0xE0, W0
002290  B72042     IOR SR
1671:                  if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
002292  E24811     CP0.B OSIntNesting
002294  3A001B     BRA NZ, 0x22CC
1672:                      if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
002296  E24812     CP0.B OSLockNesting
002298  3A0019     BRA NZ, 0x22CC
1673:                          OS_SchedNew();
00229A  07FE0D     RCALL _OS_SchedNew
1674:                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00229C  208141     MOV #0x814, W1
00229E  784091     MOV.B [W1], W1
0022A0  FB8001     ZE W1, W0
0022A2  400000     ADD W0, W0, W0
0022A4  2169E2     MOV #0x169E, W2
0022A6  780062     MOV [W2+W0], W0
0022A8  884100     MOV W0, OSTCBHighRdy
1675:                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
0022AA  208132     MOV #0x813, W2
0022AC  784112     MOV.B [W2], W2
0022AE  514F81     SUB.B W2, W1, [W15]
0022B0  32000D     BRA Z, 0x22CC
1676:              #if OS_TASK_PROFILE_EN > 0u
1677:                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
0022B2  901110     MOV [W0+34], W2
0022B4  9011A0     MOV [W0+36], W3
0022B6  410161     ADD W2, #0x1, W2
0022B8  4981E0     ADDC W3, #0x0, W3
0022BA  981012     MOV W2, [W0+34]
0022BC  981023     MOV W3, [W0+36]
1678:              #endif
1679:                              OSCtxSwCtr++;                          /* Increment context switch counter             */
0022BE  804000     MOV OSCtxSwCtr, W0
0022C0  804011     MOV 0x802, W1
0022C2  400061     ADD W0, #0x1, W0
0022C4  4880E0     ADDC W1, #0x0, W1
0022C6  884000     MOV W0, OSCtxSwCtr
0022C8  884011     MOV W1, 0x802
1680:              
1681:              #if OS_TASK_CREATE_EXT_EN > 0u
1682:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1683:                              OS_TLS_TaskSw();
1684:              #endif
1685:              #endif
1686:              
1687:                              OS_TASK_SW();                          /* Perform a context switch                     */
0022CA  07151C     RCALL 0x4D04
1688:                          }
1689:                      }
1690:                  }
1691:                  OS_EXIT_CRITICAL();
0022CC  880218     MOV W8, SR
1692:              }
0022CE  78044F     MOV [--W15], W8
0022D0  060000     RETURN
1693:              
1694:              
1695:              /*
1696:              *********************************************************************************************************
1697:              *                               FIND HIGHEST PRIORITY TASK READY TO RUN
1698:              *
1699:              * Description: This function is called by other uC/OS-II services to determine the highest priority task
1700:              *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
1701:              *
1702:              * Arguments  : none
1703:              *
1704:              * Returns    : none
1705:              *
1706:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1707:              *              2) Interrupts are assumed to be disabled when this function is called.
1708:              *********************************************************************************************************
1709:              */
1710:              
1711:              static  void  OS_SchedNew (void)
1712:              {
1713:              #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
1714:                  INT8U   y;
1715:              
1716:              
1717:                  y             = OSUnMapTbl[OSRdyGrp];
001EB6  208151     MOV #0x815, W1
001EB8  784091     MOV.B [W1], W1
001EBA  FB8081     ZE W1, W1
001EBC  299E20     MOV #0x99E2, W0
001EBE  78C0E0     MOV.B [W0+W1], W1
1718:                  OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
001EC0  FB8101     ZE W1, W2
001EC2  2161C3     MOV #0x161C, W3
001EC4  794163     MOV.B [W3+W2], W2
001EC6  FB8102     ZE W2, W2
001EC8  200033     MOV #0x3, W3
001ECA  DD0883     SL W1, W3, W1
001ECC  794060     MOV.B [W0+W2], W0
001ECE  404081     ADD.B W0, W1, W1
001ED0  208140     MOV #0x814, W0
001ED2  784801     MOV.B W1, [W0]
1719:              #else                                            /* We support up to 256 tasks                         */
1720:                  INT8U     y;
1721:                  OS_PRIO  *ptbl;
1722:              
1723:              
1724:                  if ((OSRdyGrp & 0xFFu) != 0u) {
1725:                      y = OSUnMapTbl[OSRdyGrp & 0xFFu];
1726:                  } else {
1727:                      y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
1728:                  }
1729:                  ptbl = &OSRdyTbl[y];
1730:                  if ((*ptbl & 0xFFu) != 0u) {
1731:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
1732:                  } else {
1733:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
1734:                  }
1735:              #endif
1736:              }
001ED4  060000     RETURN
1737:              
1738:              /*$PAGE*/
1739:              /*
1740:              *********************************************************************************************************
1741:              *                               DETERMINE THE LENGTH OF AN ASCII STRING
1742:              *
1743:              * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
1744:              *              (excluding the NUL character).
1745:              *
1746:              * Arguments  : psrc     is a pointer to the string for which we need to know the size.
1747:              *
1748:              * Returns    : The size of the string (excluding the NUL terminating character)
1749:              *
1750:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1751:              *              2) The string to check must be less than 255 characters long.
1752:              *********************************************************************************************************
1753:              */
1754:              
1755:              #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
1756:              INT8U  OS_StrLen (INT8U *psrc)
1757:              {
1758:                  INT8U  len;
1759:              
1760:              
1761:              #if OS_ARG_CHK_EN > 0u
1762:                  if (psrc == (INT8U *)0) {
00241A  E00000     CP0 W0
00241C  320004     BRA Z, 0x2426
00241E  780080     MOV W0, W1
002420  50C100     SUB.B W1, W0, W2
1763:                      return (0u);
002418  EB4100     CLR.B W2
1764:                  }
1765:              #endif
1766:              
1767:                  len = 0u;
1768:                  while (*psrc != OS_ASCII_NUL) {
002422  E00431     CP0.B [W1++]
002424  3AFFFD     BRA NZ, 0x2420
1769:                      psrc++;
1770:                      len++;
1771:                  }
1772:                  return (len);
1773:              }
002426  784002     MOV.B W2, W0
002428  060000     RETURN
1774:              #endif
1775:              /*$PAGE*/
1776:              /*
1777:              *********************************************************************************************************
1778:              *                                              IDLE TASK
1779:              *
1780:              * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
1781:              *              executes because they are ALL waiting for event(s) to occur.
1782:              *
1783:              * Arguments  : none
1784:              *
1785:              * Returns    : none
1786:              *
1787:              * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
1788:              *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
1789:              *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
1790:              *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
1791:              *                 interrupts.
1792:              *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
1793:              *                 power.
1794:              *********************************************************************************************************
1795:              */
1796:              
1797:              void  OS_TaskIdle (void *p_arg)
1798:              {
1799:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1800:                  OS_CPU_SR  cpu_sr = 0u;
1801:              #endif
1802:              
1803:              
1804:              
1805:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1806:                  for (;;) {
1807:                      OS_ENTER_CRITICAL();
001ED6  800212     MOV SR, W2
001ED8  200E00     MOV #0xE0, W0
001EDA  B72042     IOR SR
1808:                      OSIdleCtr++;
001EDC  8040C0     MOV OSIdleCtr, W0
001EDE  8040D1     MOV 0x81A, W1
001EE0  400061     ADD W0, #0x1, W0
001EE2  4880E0     ADDC W1, #0x0, W1
001EE4  8840C0     MOV W0, OSIdleCtr
001EE6  8840D1     MOV W1, 0x81A
1809:                      OS_EXIT_CRITICAL();
001EE8  880212     MOV W2, SR
1810:                      OSTaskIdleHook();                        /* Call user definable HOOK                           */
001EEA  071837     RCALL OSTaskIdleHook
001EEC  37FFF4     BRA OS_TaskIdle
1811:                  }
1812:              }
1813:              /*$PAGE*/
1814:              /*
1815:              *********************************************************************************************************
1816:              *                                           STATISTICS TASK
1817:              *
1818:              * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
1819:              *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
1820:              *              CPU usage is determined by:
1821:              *
1822:              *                                          OSIdleCtr
1823:              *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
1824:              *                                         OSIdleCtrMax
1825:              *
1826:              * Arguments  : parg     this pointer is not used at this time.
1827:              *
1828:              * Returns    : none
1829:              *
1830:              * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
1831:              *                 next higher priority, OS_TASK_IDLE_PRIO-1.
1832:              *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
1833:              *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
1834:              *                 maximum value for the idle counter.
1835:              *********************************************************************************************************
1836:              */
1837:              
1838:              #if OS_TASK_STAT_EN > 0u
1839:              void  OS_TaskStat (void *p_arg)
1840:              {
0024A0  781F88     MOV W8, [W15++]
1841:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1842:                  OS_CPU_SR  cpu_sr = 0u;
1843:              #endif
1844:              
1845:              
1846:              
1847:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1848:                  while (OSStatRdy == OS_FALSE) {
0024A2  370003     BRA 0x24AA
0024AA  E24810     CP0.B OSStatRdy
0024AC  32FFFB     BRA Z, 0x24A4
1849:                      OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
0024A4  200C80     MOV #0xC8, W0
0024A6  200001     MOV #0x0, W1
0024A8  07134E     RCALL OSTimeDly
1850:                  }
1851:                  OSIdleCtrMax /= 100uL;
0024AE  200642     MOV #0x64, W2
0024B0  200003     MOV #0x0, W3
0024B2  804040     MOV OSIdleCtrMax, W0
0024B4  804051     MOV 0x80A, W1
0024B6  07F0D2     RCALL 0x65C
0024B8  884040     MOV W0, OSIdleCtrMax
0024BA  884051     MOV W1, 0x80A
1852:                  if (OSIdleCtrMax == 0uL) {
0024BC  500FE0     SUB W0, #0x0, [W15]
0024BE  588FE0     SUBB W1, #0x0, [W15]
0024C0  3A0003     BRA NZ, 0x24C8
1853:                      OSCPUUsage = 0u;
0024C2  EF6806     CLR.B OSCPUUsage
1854:              #if OS_TASK_SUSPEND_EN > 0u
1855:                      (void)OSTaskSuspend(OS_PRIO_SELF);
0024C4  EBC000     SETM.B W0
0024C6  0702B0     RCALL OSTaskSuspend
1856:              #else
1857:                      for (;;) {
1858:                          OSTimeDly(OS_TICKS_PER_SEC);
1859:                      }
1860:              #endif
1861:                  }
1862:                  OS_ENTER_CRITICAL();
0024C8  800218     MOV SR, W8
0024CA  200E00     MOV #0xE0, W0
0024CC  B72042     IOR SR
1863:                  OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
0024CE  200642     MOV #0x64, W2
0024D0  200003     MOV #0x0, W3
0024D2  804040     MOV OSIdleCtrMax, W0
0024D4  804051     MOV 0x80A, W1
0024D6  07F0D5     RCALL 0x682
0024D8  8840C0     MOV W0, OSIdleCtr
0024DA  8840D1     MOV W1, 0x81A
1864:                  OS_EXIT_CRITICAL();
0024DC  880218     MOV W8, SR
1865:                  for (;;) {
1866:                      OS_ENTER_CRITICAL();
0024DE  800212     MOV SR, W2
0024E0  200E00     MOV #0xE0, W0
0024E2  B72042     IOR SR
1867:                      OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0024E4  8040C0     MOV OSIdleCtr, W0
0024E6  8040D1     MOV 0x81A, W1
0024E8  884060     MOV W0, OSIdleCtrRun
0024EA  884071     MOV W1, 0x80E
1868:                      OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
0024EC  EF2818     CLR OSIdleCtr
0024EE  EF281A     CLR 0x81A
1869:                      OS_EXIT_CRITICAL();
0024F0  880212     MOV W2, SR
1870:                      OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
0024F2  804042     MOV OSIdleCtrMax, W2
0024F4  804053     MOV 0x80A, W3
0024F6  07F0B2     RCALL 0x65C
0024F8  B3C642     MOV.B #0x64, W2
0024FA  514080     SUB.B W2, W0, W1
0024FC  208060     MOV #0x806, W0
0024FE  784801     MOV.B W1, [W0]
1871:                      OSTaskStatHook();                        /* Invoke user definable hook                         */
002500  07152E     RCALL OSTaskStatHook
1872:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1873:                      OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
002502  07FFB0     RCALL OS_TaskStatStkChk
1874:              #endif
1875:                      OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
002504  200640     MOV #0x64, W0
002506  200001     MOV #0x0, W1
002508  07131E     RCALL OSTimeDly
00250A  37FFE9     BRA 0x24DE
1876:                  }
1877:              }
1878:              #endif
1879:              /*$PAGE*/
1880:              /*
1881:              *********************************************************************************************************
1882:              *                                        CHECK ALL TASK STACKS
1883:              *
1884:              * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
1885:              *
1886:              * Arguments  : none
1887:              *
1888:              * Returns    : none
1889:              *********************************************************************************************************
1890:              */
1891:              
1892:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1893:              void  OS_TaskStatStkChk (void)
1894:              {
002464  FA0008     LNK #0x8
002466  BE9F88     MOV.D W8, [W15++]
1895:                  OS_TCB      *ptcb;
1896:                  OS_STK_DATA  stk_data;
1897:                  INT8U        err;
1898:                  INT8U        prio;
1899:              
1900:              
1901:                  for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
002468  2169E9     MOV #0x169E, W9
00246A  EB4400     CLR.B W8
002492  E84408     INC.B W8, W8
002494  E88489     INC2 W9, W9
002496  544FEB     SUB.B W8, #0xB, [W15]
002498  3AFFE9     BRA NZ, 0x246C
1902:                      err = OSTaskStkChk(prio, &stk_data);
00246C  5780EC     SUB W15, #0xC, W1
00246E  784008     MOV.B W8, W0
002470  0702A3     RCALL OSTaskStkChk
1903:                      if (err == OS_ERR_NONE) {
002472  E00400     CP0.B W0
002474  3A000E     BRA NZ, 0x2492
1904:                          ptcb = OSTCBPrioTbl[prio];
002476  780019     MOV [W9], W0
1905:                          if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
002478  E00000     CP0 W0
00247A  32000B     BRA Z, 0x2492
1906:                              if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00247C  500FE1     SUB W0, #0x1, [W15]
00247E  320009     BRA Z, 0x2492
1907:              #if OS_TASK_PROFILE_EN > 0u
1908:                                  #if OS_STK_GROWTH == 1u
1909:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
1910:                                  #else
1911:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
002480  9000B0     MOV [W0+6], W1
002482  408081     ADD W1, W1, W1
002484  900120     MOV [W0+4], W2
002486  510081     SUB W2, W1, W1
002488  981071     MOV W1, [W0+46]
1912:                                  #endif
1913:                                  ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
00248A  97B94F     MOV [W15-8], W2
00248C  97B9DF     MOV [W15-6], W3
00248E  981802     MOV W2, [W0+48]
002490  981813     MOV W3, [W0+50]
1914:              #endif
1915:                              }
1916:                          }
1917:                      }
1918:                  }
1919:              }
00249A  BE044F     MOV.D [--W15], W8
00249C  FA8000     ULNK
00249E  060000     RETURN
1920:              #endif
1921:              /*$PAGE*/
1922:              /*
1923:              *********************************************************************************************************
1924:              *                                           INITIALIZE TCB
1925:              *
1926:              * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
1927:              *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
1928:              *
1929:              * Arguments  : prio          is the priority of the task being created
1930:              *
1931:              *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
1932:              *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
1933:              *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
1934:              *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
1935:              *                            specific.
1936:              *
1937:              *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
1938:              *                            'OSTaskCreate()'.
1939:              *
1940:              *              id            is the task's ID (0..65535)
1941:              *
1942:              *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
1943:              *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
1944:              *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
1945:              *                            units are established by the #define constant OS_STK which is CPU
1946:              *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
1947:              *
1948:              *              pext          is a pointer to a user supplied memory area that is used to extend the task
1949:              *                            control block.  This allows you to store the contents of floating-point
1950:              *                            registers, MMU registers or anything else you could find useful during a
1951:              *                            context switch.  You can even assign a name to each task and store this name
1952:              *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
1953:              *
1954:              *              opt           options as passed to 'OSTaskCreateExt()' or,
1955:              *                            0 if called from 'OSTaskCreate()'.
1956:              *
1957:              * Returns    : OS_ERR_NONE              if the call was successful
1958:              *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task
1959:              *                                       cannot be created.
1960:              *
1961:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1962:              *********************************************************************************************************
1963:              */
1964:              
1965:              INT8U  OS_TCBInit (INT8U    prio,
1966:                                 OS_STK  *ptos,
1967:                                 OS_STK  *pbos,
1968:                                 INT16U   id,
1969:                                 INT32U   stk_size,
1970:                                 void    *pext,
1971:                                 INT16U   opt)
1972:              {
00250C  BE9F88     MOV.D W8, [W15++]
00250E  BE9F8A     MOV.D W10, [W15++]
002510  784400     MOV.B W0, W8
1973:                  OS_TCB    *ptcb;
1974:              #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
1975:                  OS_CPU_SR  cpu_sr = 0u;
1976:              #endif
1977:              #if OS_TASK_REG_TBL_SIZE > 0u
1978:                  INT8U      i;
1979:              #endif
1980:              #if OS_TASK_CREATE_EXT_EN > 0u
1981:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1982:                  INT8U      j;
1983:              #endif
1984:              #endif
1985:              
1986:              
1987:                  OS_ENTER_CRITICAL();
002512  80021A     MOV SR, W10
002514  200E00     MOV #0xE0, W0
002516  B72042     IOR SR
1988:                  ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
002518  8040F9     MOV OSTCBFreeList, W9
1989:                  if (ptcb != (OS_TCB *)0) {
00251A  E00009     CP0 W9
00251C  32005A     BRA Z, 0x25D2
1990:                      OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00251E  9005F9     MOV [W9+14], W11
002520  8840FB     MOV W11, OSTCBFreeList
1991:                      OS_EXIT_CRITICAL();
002522  88021A     MOV W10, SR
1992:                      ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
002524  780C81     MOV W1, [W9]
1993:                      ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
002526  985CC8     MOV.B W8, [W9+28]
1994:                      ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
002528  EB4500     CLR.B W10
00252A  985CAA     MOV.B W10, [W9+26]
1995:                      ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00252C  985CBA     MOV.B W10, [W9+27]
1996:                      ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00252E  B80060     MUL.UU W0, #0, W0
002530  980CB0     MOV W0, [W9+22]
002532  980CC1     MOV W1, [W9+24]
1997:              
1998:              #if OS_TASK_CREATE_EXT_EN > 0u
1999:                      ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
002534  980496     MOV W6, [W9+2]
2000:                      ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
002536  9804B4     MOV W4, [W9+6]
002538  9804C5     MOV W5, [W9+8]
2001:                      ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00253A  9804A2     MOV W2, [W9+4]
2002:                      ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00253C  9804D7     MOV W7, [W9+10]
2003:                      ptcb->OSTCBId            = id;                     /* Store task ID                            */
00253E  9804E3     MOV W3, [W9+12]
2004:              #else
2005:                      pext                     = pext;                   /* Prevent compiler warning if not used     */
2006:                      stk_size                 = stk_size;
2007:                      pbos                     = pbos;
2008:                      opt                      = opt;
2009:                      id                       = id;
2010:              #endif
2011:              
2012:              #if OS_TASK_DEL_EN > 0u
2013:                      ptcb->OSTCBDelReq        = OS_ERR_NONE;
002540  98649A     MOV.B W10, [W9+33]
2014:              #endif
2015:              
2016:              #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
2017:                      ptcb->OSTCBY             = (INT8U)(prio >> 3u);
002542  FB8508     ZE W8, W10
002544  DE5243     LSR W10, #3, W4
002546  985CE4     MOV.B W4, [W9+30]
2018:                      ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
002548  644467     AND.B W8, #0x7, W8
00254A  985CD8     MOV.B W8, [W9+29]
2019:              #else                                                             /* Pre-compute X, Y                  */
2020:                      ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
2021:                      ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
2022:              #endif
2023:                                                                                /* Pre-compute BitX and BitY         */
2024:                      ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
00254C  200012     MOV #0x1, W2
00254E  200003     MOV #0x0, W3
002550  BE0302     MOV.D W2, W6
002552  780584     MOV W4, W11
002554  E9058B     DEC W11, W11
002556  330003     BRA N, 0x255E
002558  430306     ADD W6, W6, W6
00255A  4B8387     ADDC W7, W7, W7
00255C  37FFFB     BRA 0x2554
00255E  986486     MOV.B W6, [W9+32]
2025:                      ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
002560  FB8408     ZE W8, W8
002562  E90408     DEC W8, W8
002564  330003     BRA N, 0x256C
002566  410102     ADD W2, W2, W2
002568  498183     ADDC W3, W3, W3
00256A  37FFFB     BRA 0x2562
00256C  985CF2     MOV.B W2, [W9+31]
2026:              
2027:              #if (OS_EVENT_EN)
2028:                      ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
00256E  EB0400     CLR W8
002570  980C98     MOV W8, [W9+18]
2029:              #if (OS_EVENT_MULTI_EN > 0u)
2030:                      ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
002572  980CA8     MOV W8, [W9+20]
2031:              #endif
2032:              #endif
2033:              
2034:              #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
2035:                      ptcb->OSTCBFlagNode      = (OS_FLAG_NODE *)0;      /* Task is not pending on an event flag     */
2036:              #endif
2037:              
2038:              #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
2039:                      ptcb->OSTCBMsg           = (void *)0;              /* No message received                      */
2040:              #endif
2041:              
2042:              #if OS_TASK_PROFILE_EN > 0u
2043:                      ptcb->OSTCBCtxSwCtr      = 0uL;                    /* Initialize profiling variables           */
002574  981490     MOV W0, [W9+34]
002576  9814A1     MOV W1, [W9+36]
2044:                      ptcb->OSTCBCyclesStart   = 0uL;
002578  9814D0     MOV W0, [W9+42]
00257A  9814E1     MOV W1, [W9+44]
2045:                      ptcb->OSTCBCyclesTot     = 0uL;
00257C  9814B0     MOV W0, [W9+38]
00257E  9814C1     MOV W1, [W9+40]
2046:                      ptcb->OSTCBStkBase       = (OS_STK *)0;
002580  9814F8     MOV W8, [W9+46]
2047:                      ptcb->OSTCBStkUsed       = 0uL;
002582  981C80     MOV W0, [W9+48]
002584  981C91     MOV W1, [W9+50]
2048:              #endif
2049:              
2050:              #if OS_TASK_NAME_EN > 0u
2051:                      ptcb->OSTCBTaskName      = (INT8U *)(void *)"?";
002586  299E02     MOV #0x99E0, W2
002588  981CA2     MOV W2, [W9+52]
2052:              #endif
2053:              
2054:              #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
2055:                      for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
2056:                          ptcb->OSTCBRegTbl[i] = 0u;
00258A  981CB0     MOV W0, [W9+54]
00258C  981CC1     MOV W1, [W9+56]
2057:                      }
2058:              #endif
2059:              
2060:                      OSTCBInitHook(ptcb);
00258E  780009     MOV W9, W0
002590  0714E8     RCALL OSTCBInitHook
2061:              
2062:                      OS_ENTER_CRITICAL();
002592  800212     MOV SR, W2
002594  200E00     MOV #0xE0, W0
002596  B72042     IOR SR
2063:                      OSTCBPrioTbl[prio] = ptcb;
002598  45050A     ADD W10, W10, W10
00259A  2169E1     MOV #0x169E, W1
00259C  7D3089     MOV W9, [W1+W10]
2064:                      OS_EXIT_CRITICAL();
00259E  880212     MOV W2, SR
2065:              
2066:                      OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0025A0  780009     MOV W9, W0
0025A2  0714D9     RCALL OSTaskCreateHook
2067:              
2068:              #if OS_TASK_CREATE_EXT_EN > 0u
2069:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
2070:                      for (j = 0u; j < OS_TLS_TBL_SIZE; j++) {
2071:                          ptcb->OSTCBTLSTbl[j] = (OS_TLS)0;
2072:                      }
2073:                      OS_TLS_TaskCreate(ptcb);                           /* Call TLS hook                            */
2074:              #endif
2075:              #endif
2076:              
2077:                      OS_ENTER_CRITICAL();
0025A4  800211     MOV SR, W1
0025A6  200E00     MOV #0xE0, W0
0025A8  B72042     IOR SR
2078:                      ptcb->OSTCBNext = OSTCBList;                       /* Link into TCB chain                      */
0025AA  804110     MOV OSTCBList, W0
0025AC  9804F0     MOV W0, [W9+14]
2079:                      ptcb->OSTCBPrev = (OS_TCB *)0;         
0025AE  980C88     MOV W8, [W9+16]
2080:                      if (OSTCBList != (OS_TCB *)0) {
0025B0  E00000     CP0 W0
0025B2  320001     BRA Z, 0x25B6
2081:                          OSTCBList->OSTCBPrev = ptcb;
0025B4  980809     MOV W9, [W0+16]
2082:                      }
2083:                      OSTCBList               = ptcb;
0025B6  884119     MOV W9, OSTCBList
2084:                      OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0025B8  906009     MOV.B [W9+32], W0
0025BA  B76815     IOR.B OSRdyGrp
2085:                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0025BC  905869     MOV.B [W9+30], W0
0025BE  FB8000     ZE W0, W0
0025C0  2161C2     MOV #0x161C, W2
0025C2  784262     MOV.B [W2+W0], W4
0025C4  9059F9     MOV.B [W9+31], W3
0025C6  724183     IOR.B W4, W3, W3
0025C8  787103     MOV.B W3, [W2+W0]
2086:                      OSTaskCtr++;                                       /* Increment the #tasks counter             */
0025CA  EC6817     INC.B OSTaskCtr
2087:                      OS_EXIT_CRITICAL();
0025CC  880211     MOV W1, SR
2088:                      return (OS_ERR_NONE);
0025CE  EB4000     CLR.B W0
0025D0  370002     BRA 0x25D6
2089:                  }
2090:                  OS_EXIT_CRITICAL();
0025D2  88021A     MOV W10, SR
2091:                  return (OS_ERR_TASK_NO_MORE_TCB);
0025D4  B3C420     MOV.B #0x42, W0
2092:              }
0025D6  BE054F     MOV.D [--W15], W10
2093:              
2094:              
2095:              
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Ports/os_cpu_c.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                               uC/OS-II
4:                 *                                         The Real-Time Kernel
5:                 *
6:                 *                               (c) Copyright 2006, Micrium, Weston, FL
7:                 *                                          All Rights Reserved
8:                 *
9:                 *
10:                *                                          dsPIC33/PIC24 MPLab Port
11:                *
12:                *
13:                * File         : OS_CPU_C.C
14:                * By           : Eric Shufro
15:                * Port Version : V2.81 (and higher)
16:                *********************************************************************************************************
17:                */
18:                
19:                #include  "uCOS_II.H"
20:                
21:                /*
22:                *********************************************************************************************************
23:                *                                             LOCALS
24:                *********************************************************************************************************
25:                */
26:                
27:                #if OS_TMR_EN > 0
28:                static  INT16U  OSTmrCtr;
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                       OS INITIALIZATION HOOK
34:                *                                            (BEGINNING)
35:                *
36:                * Description: This function is called by OSInit() at the beginning of OSInit().
37:                *
38:                * Arguments  : none
39:                *
40:                * Note(s)    : 1) Interrupts should be disabled during this call.
41:                *********************************************************************************************************
42:                */
43:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
44:                void  OSInitHookBegin (void)
45:                {
46:                #if OS_TMR_EN > 0
47:                    OSTmrCtr =      0;
48:                #endif
49:                
50:                    SPLIM    = 0xFFFE;                                                  /* Initialize the stack pointer limit register to a maximum */
004F4E  2FFFE0     MOV #0xFFFE, W0
004F50  880100     MOV W0, SPLIM
51:                }                                                                       /* address thus effectively disabling stack checking        */
004F52  060000     RETURN
52:                #endif
53:                
54:                /*
55:                *********************************************************************************************************
56:                *                                       OS INITIALIZATION HOOK
57:                *                                               (END)
58:                *
59:                * Description: This function is called by OSInit() at the end of OSInit().
60:                *
61:                * Arguments  : none
62:                *
63:                * Note(s)    : 1) Interrupts should be disabled during this call.
64:                *********************************************************************************************************
65:                */
66:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
67:                void  OSInitHookEnd (void)
68:                {
69:                #if OS_CPU_INT_DIS_MEAS_EN > 0
70:                    OS_CPU_IntDisMeasInit();
71:                #endif
72:                }
004F54  060000     RETURN
73:                #endif
74:                
75:                /*$PAGE*/
76:                /*
77:                *********************************************************************************************************
78:                *                                          TASK CREATION HOOK
79:                *
80:                * Description: This function is called when a task is created.
81:                *
82:                * Arguments  : ptcb   is a pointer to the task control block of the task being created.
83:                *
84:                * Note(s)    : 1) Interrupts are disabled during this call.
85:                *********************************************************************************************************
86:                */
87:                #if OS_CPU_HOOKS_EN > 0
88:                void  OSTaskCreateHook (OS_TCB *ptcb)
89:                {
90:                #if OS_APP_HOOKS_EN > 0
91:                    App_TaskCreateHook(ptcb);
92:                #else
93:                    (void)ptcb;                                                         /* Prevent compiler warning                                 */
94:                #endif
95:                }
004F56  060000     RETURN
96:                #endif
97:                
98:                /*
99:                *********************************************************************************************************
100:               *                                           TASK DELETION HOOK
101:               *
102:               * Description: This function is called when a task is deleted.
103:               *
104:               * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
105:               *
106:               * Note(s)    : 1) Interrupts are disabled during this call.
107:               *********************************************************************************************************
108:               */
109:               #if OS_CPU_HOOKS_EN > 0
110:               void  OSTaskDelHook (OS_TCB *ptcb)
111:               {
112:               #if OS_APP_HOOKS_EN > 0
113:                   App_TaskDelHook(ptcb);
114:               #else
115:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
116:               #endif
117:               }
004F58  060000     RETURN
118:               #endif
119:               
120:               /*
121:               *********************************************************************************************************
122:               *                                             IDLE TASK HOOK
123:               *
124:               * Description: This function is called by the idle task.  This hook has been added to allow you to do
125:               *              such things as STOP the CPU to conserve power.
126:               *
127:               * Arguments  : none
128:               *
129:               * Note(s)    : 1) Interrupts are enabled during this call.
130:               *********************************************************************************************************
131:               */
132:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
133:               void  OSTaskIdleHook (void)
134:               {
135:               #if OS_APP_HOOKS_EN > 0
136:                   App_TaskIdleHook();
137:               #endif
138:               }
004F5A  060000     RETURN
139:               #endif
140:               
141:               /*
142:               *********************************************************************************************************
143:               *                                            TASK RETURN HOOK
144:               *
145:               * Description: This function is called if a task accidentally returns.  In other words, a task should
146:               *              either be an infinite loop or delete itself when done.
147:               *
148:               * Arguments  : ptcb      is a pointer to the task control block of the task that is returning.
149:               *
150:               * Note(s)    : none
151:               *********************************************************************************************************
152:               */
153:               
154:               #if OS_CPU_HOOKS_EN > 0u
155:               void  OSTaskReturnHook (OS_TCB  *ptcb)
156:               {
157:               #if OS_APP_HOOKS_EN > 0u
158:                   App_TaskReturnHook(ptcb);
159:               #else
160:                   (void)ptcb;
161:               #endif
162:               }
004F5C  060000     RETURN
163:               #endif
164:               /*
165:               *********************************************************************************************************
166:               *                                           STATISTIC TASK HOOK
167:               *
168:               * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
169:               *              application to add functionality to the statistics task.
170:               *
171:               * Arguments  : none
172:               *********************************************************************************************************
173:               */
174:               
175:               #if OS_CPU_HOOKS_EN > 0
176:               void  OSTaskStatHook (void)
177:               {
178:               #if OS_APP_HOOKS_EN > 0
179:                   App_TaskStatHook();
180:               #endif
181:               }
004F5E  060000     RETURN
182:               #endif
183:               
184:               /*$PAGE*/
185:               /*
186:               *********************************************************************************************************
187:               *                                           TASK SWITCH HOOK
188:               *
189:               * Description: This function is called when a task switch is performed.  This allows you to perform other
190:               *              operations during a context switch.
191:               *
192:               * Arguments  : none
193:               *
194:               * Note(s)    : 1) Interrupts are disabled during this call.
195:               *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
196:               *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
197:               *                 task being switched out (i.e. the preempted task).
198:               *********************************************************************************************************
199:               */
200:               #if OS_CPU_HOOKS_EN > 0
201:               void  OSTaskSwHook (void)
202:               {
203:               #if OS_APP_HOOKS_EN > 0
204:                   App_TaskSwHook();
205:               #endif
206:               }
004F60  060000     RETURN
207:               #endif
208:               
209:               /*
210:               *********************************************************************************************************
211:               *                                           OSTCBInit() HOOK
212:               *
213:               * Description: This function is called by OS_TCBInit() after setting up most of the TCB.
214:               *
215:               * Arguments  : ptcb    is a pointer to the TCB of the task being created.
216:               *
217:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
218:               *********************************************************************************************************
219:               */
220:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
221:               void  OSTCBInitHook (OS_TCB *ptcb)
222:               {
223:               #if OS_APP_HOOKS_EN > 0
224:                   App_TCBInitHook(ptcb);
225:               #else
226:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
227:               #endif
228:               }
004F62  060000     RETURN
229:               #endif
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                               TICK HOOK
234:               *
235:               * Description: This function is called every tick.
236:               *
237:               * Arguments  : none
238:               *
239:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
240:               *********************************************************************************************************
241:               */
242:               #if (OS_CPU_HOOKS_EN > 0) && (OS_TIME_TICK_HOOK_EN > 0)
243:               void  OSTimeTickHook (void)
244:               {
245:               #if OS_APP_HOOKS_EN > 0
246:                   App_TimeTickHook();
247:               #endif
248:               
249:               #if OS_TMR_EN > 0
250:                   OSTmrCtr++;
251:                   if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
252:                       OSTmrCtr = 0;
253:                       OSTmrSignal();
254:                   }
255:               #endif
256:               }
257:               #endif
258:               
259:               /*
260:               *********************************************************************************************************
261:               *                             INTERRUPT DISABLE TIME MEASUREMENT, START
262:               *********************************************************************************************************
263:               */
264:               
265:               #if OS_CPU_INT_DIS_MEAS_EN > 0u
266:               void  OS_CPU_IntDisMeasInit (void)
267:               {
268:                   OS_CPU_IntDisMeasNestingCtr = 0u;
269:                   OS_CPU_IntDisMeasCntsEnter  = 0u;
270:                   OS_CPU_IntDisMeasCntsExit   = 0u;
271:                   OS_CPU_IntDisMeasCntsMax    = 0u;
272:                   OS_CPU_IntDisMeasCntsDelta  = 0u;
273:                   OS_CPU_IntDisMeasCntsOvrhd  = 0u;
274:                   OS_CPU_IntDisMeasStart();                              /* Measure the overhead of the functions    */
275:                   OS_CPU_IntDisMeasStop();
276:                   OS_CPU_IntDisMeasCntsOvrhd  = OS_CPU_IntDisMeasCntsDelta;
277:               }
278:               
279:               
280:               void  OS_CPU_IntDisMeasStart (void)
281:               {
282:                   OS_CPU_IntDisMeasNestingCtr++;
283:                   if (OS_CPU_IntDisMeasNestingCtr == 1u) {               /* Only measure at the first nested level   */
284:                       OS_CPU_IntDisMeasCntsEnter = OS_CPU_IntDisMeasTmrRd();
285:                   }
286:               }
287:               
288:               
289:               void  OS_CPU_IntDisMeasStop (void)
290:               {
291:                   OS_CPU_IntDisMeasNestingCtr--;                                      /* Decrement nesting ctr       */
292:                   if (OS_CPU_IntDisMeasNestingCtr == 0u) {
293:                       OS_CPU_IntDisMeasCntsExit  = OS_CPU_IntDisMeasTmrRd();
294:                       OS_CPU_IntDisMeasCntsDelta = OS_CPU_IntDisMeasCntsExit - OS_CPU_IntDisMeasCntsEnter;
295:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsOvrhd) {  /* Ensure overhead < delta     */
296:                           OS_CPU_IntDisMeasCntsDelta -= OS_CPU_IntDisMeasCntsOvrhd;
297:                       } else {
298:                           OS_CPU_IntDisMeasCntsDelta  = OS_CPU_IntDisMeasCntsOvrhd;
299:                       }
300:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsMax) {    /* Track MAXIMUM               */
301:                           OS_CPU_IntDisMeasCntsMax = OS_CPU_IntDisMeasCntsDelta;
302:                       }
303:                   }
304:               }
305:               #endif
306:               /*$PAGE*/
307:               /*
308:               *********************************************************************************************************
309:               *                                        INITIALIZE A TASK'S STACK
310:               *
311:               * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
312:               *              stack frame of the task being created.  This function is highly processor specific.
313:               *
314:               * Arguments  : task          is a pointer to the task code
315:               *
316:               *              p_arg         is a pointer to a user supplied data area that will be passed to the task
317:               *                            when the task first executes.
318:               *
319:               *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
320:               *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
321:               *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
322:               *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
323:               *                            of the stack.
324:               *
325:               *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
326:               *                            (see uCOS_II.H for OS_TASK_OPT_???).
327:               *
328:               * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
329:               *              been placed on the stack in the proper order.
330:               *
331:               * Note(s)    : 1) You may pass a task creation parameters through the opt variable. You MUST only use the
332:               *                 upper 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make
333:               *                 changes to the code below, you will need to ensure that it doesn't affect the behaviour
334:               *                 of OSTaskIdle() and OSTaskStat().
335:               *              2) Registers are initialized to make them easy to differentiate with a debugger.
336:               *
337:               *              3) Setup the stack frame of the task:
338:               *
339:               *                        ptos -  0  ->
340:               *                        ptos -  2  ->  CORCON
341:               *                        ptos -  4  ->  SR (initialized to 0)
342:               *                        ptos -  6  ->  DOENDH
343:               *                        ptos -  8  ->  DOENDL
344:               *                        ptos - 10  ->  DOSTARTH
345:               *                        ptos - 12  ->  DOSTARTL
346:               *                        ptos - 14  ->  DCOUNT
347:               *                        ptos - 16  ->  RCOUNT
348:               *                        ptos - 18  ->  PSVPAG
349:               *                        ptos - 20  ->  TBLPAG
350:               *                        ptos - 22  ->  ACCBU
351:               *                        ptos - 24  ->  ACCBH
352:               *                        ptos - 26  ->  ACCBL
353:               *                        ptos - 28  ->  ACCAU
354:               *                        ptos - 30  ->  ACCAH
355:               *                        ptos - 32  ->  ACCAL
356:               *                        ptos - 34  ->  W14
357:               *                        ptos - 36  ->  W13
358:               *                        ptos - 38  ->  W12
359:               *                        ptos - 40  ->  W11
360:               *                        ptos - 42  ->  W10
361:               *                        ptos - 44  ->  W9
362:               *                        ptos - 46  ->  W8
363:               *                        ptos - 48  ->  W7
364:               *                        ptos - 50  ->  W6
365:               *                        ptos - 52  ->  W5
366:               *                        ptos - 54  ->  W4
367:               *                        ptos - 56  ->  W3
368:               *                        ptos - 58  ->  W2
369:               *                        ptos - 60  ->  W1
370:               *                        ptos - 62  ->  p_arg
371:               *                        ptos - 64  ->   0 (15..8) | CORCON.7 | PC (22..16)      Simulate ISR
372:               *                        ptos - 66  ->  PC (15..0)
373:               *                        ptos - 68  ->  PC (22..16)                              Simulate function call
374:               *                        ptos - 70  ->  PC (15..0)
375:               *********************************************************************************************************
376:               */
377:               
378:               OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
379:               {
380:                   INT16U  x;
381:                   INT16U   pc_high;
382:               
383:               
384:               	pc_high =   0;                                                      /* Upper byte of PC always 0. Pointers are 16 bit unsigned  */
385:               
386:                  *ptos++  =  (OS_STK)task;                                            /* Simulate a call to the task by putting 32 bits of data   */
004F64  781900     MOV W0, [W2++]
387:                  *ptos++  =  (OS_STK)pc_high;                                         /* data on the stack.                                       */
004F66  EB1900     CLR [W2++]
388:               
389:                                                                                       /* Simulate an interrupt                                    */
390:                  *ptos++  =  (OS_STK)task;                                            /* Put the address of this task on the stack (PC)           */
004F68  781900     MOV W0, [W2++]
391:               
392:                   x       =  0;                                                       /* Set the SR to enable ALL interrupts                      */
004F70  EB0180     CLR W3
393:                   if (CORCONbits.IPL3) {                                              /* Check the CPU's current interrupt level 3 bit            */
004F6C  AB6044     BTST CORCON, #3
004F6E  3A0001     BRA NZ, 0x4F72
394:                       x  |= 0x0080;                                                   /* If set, then save the priority level bit in x bit [7]    */
004F6A  200803     MOV #0x80, W3
395:                   }
396:                  *ptos++  = (OS_STK)(x | (INT16U)pc_high);                            /* Push the SR Low, CORCON IPL3 and PC (22..16)             */
004F72  780002     MOV W2, W0
004F74  781803     MOV W3, [W0++]
397:               
398:                                                                                       /* Push all of the registers to stack                       */
399:                  *ptos++  = (OS_STK)p_arg;                                            /* Register W0 holds data passed to the task when started   */
004F76  781801     MOV W1, [W0++]
400:                  *ptos++  = 0x1111;                                                   /* Initialize register W1                                   */
004F78  211111     MOV #0x1111, W1
004F7A  781801     MOV W1, [W0++]
401:                  *ptos++  = 0x2222;                                                   /* Initialize register W2                                   */
004F7C  222221     MOV #0x2222, W1
004F7E  781801     MOV W1, [W0++]
402:                  *ptos++  = 0x3333;                                                   /* Initialize register W3                                   */
004F80  233331     MOV #0x3333, W1
004F82  781801     MOV W1, [W0++]
403:                  *ptos++  = 0x4444;                                                   /* Initialize register W4                                   */
004F84  244441     MOV #0x4444, W1
004F86  781801     MOV W1, [W0++]
404:                  *ptos++  = 0x5555;                                                   /* Initialize register W5                                   */
004F88  255551     MOV #0x5555, W1
004F8A  781801     MOV W1, [W0++]
405:                  *ptos++  = 0x6666;                                                   /* Initialize register W6                                   */
004F8C  266661     MOV #0x6666, W1
004F8E  781801     MOV W1, [W0++]
406:                  *ptos++  = 0x7777;                                                   /* Initialize register W7                                   */
004F90  277771     MOV #0x7777, W1
004F92  781801     MOV W1, [W0++]
407:                  *ptos++  = 0x8888;                                                   /* Initialize register W8                                   */
004F94  288881     MOV #0x8888, W1
004F96  781801     MOV W1, [W0++]
408:                  *ptos++  = 0x9999;                                                   /* Initialize register W9                                   */
004F98  299991     MOV #0x9999, W1
004F9A  781801     MOV W1, [W0++]
409:                  *ptos++  = 0xAAAA;                                                   /* Initialize register W10                                  */
004F9C  2AAAA1     MOV #0xAAAA, W1
004F9E  781801     MOV W1, [W0++]
410:                  *ptos++  = 0xBBBB;                                                   /* Initialize register W11                                  */
004FA0  2BBBB1     MOV #0xBBBB, W1
004FA2  781801     MOV W1, [W0++]
411:                  *ptos++  = 0xCCCC;                                                   /* Initialize register W12                                  */
004FA4  2CCCC1     MOV #0xCCCC, W1
004FA6  781801     MOV W1, [W0++]
412:                  *ptos++  = 0xDDDD;                                                   /* Initialize register W13                                  */
004FA8  2DDDD1     MOV #0xDDDD, W1
004FAA  781801     MOV W1, [W0++]
413:                  *ptos++  = 0xEEEE;                                                   /* Initialize register W14                                  */
004FAC  2EEEE1     MOV #0xEEEE, W1
004FAE  781801     MOV W1, [W0++]
414:               
415:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
416:                  *ptos++  = ACCAL;                                                    /* Push Accumulator A onto the stack                        */
417:                  *ptos++  = ACCAH;                                                    /* Push Accumulator A onto the stack                        */
418:                  *ptos++  = ACCAU;                                                    /* Push Accumulator A onto the stack                        */
419:                  *ptos++  = ACCBL;                                                    /* Push Accumulator B onto the stack                        */
420:                  *ptos++  = ACCBH;                                                    /* Push Accumulator B onto the stack                        */
421:                  *ptos++  = ACCBU;                                                    /* Push Accumulator B onto the stack                        */
422:               #endif
423:                  *ptos++  = TBLPAG;                                                   /* Push the Data Table Page Address onto the stack          */
004FB0  8002A1     MOV TBLPAG, W1
004FB2  781801     MOV W1, [W0++]
424:               #if defined(__dsPIC33E__)
425:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
426:                  *ptos++  = DSWPAG;
427:               #elif defined (__dsPIC33F__) || defined(__PIC24F__)
428:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
004FB4  800191     MOV DSRPAG, W1
004FB6  781801     MOV W1, [W0++]
429:                  *ptos++  = DSWPAG;
004FB8  8001A1     MOV DSWPAG, W1
004FBA  781801     MOV W1, [W0++]
430:               //   *ptos++  = PSVPAG;
431:               #endif
432:                  *ptos++  = RCOUNT;                                                   /* Push the Repeat Loop Counter Register onto the stack     */
004FBC  8001B1     MOV RCOUNT, W1
004FBE  781801     MOV W1, [W0++]
433:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
434:                  *ptos++  = DCOUNT;                                                   /* Push the Do Loop     Counter Register onto the stack     */
435:                  *ptos++  = DOSTARTL;                                                 /* Push the Do Loop Start Address Register onto the stack   */
436:                  *ptos++  = DOSTARTH;                                                 /* Push the Do Loop Start Address Register onto the stack   */
437:                  *ptos++  = DOENDL;                                                   /* Push the Do Loop End   Address Register onto the stack   */
438:                  *ptos++  = DOENDH;                                                   /* Push the Do Loop End   Address Register onto the stack   */
439:               #endif
440:                  *ptos++  = 0;                                                        /* Force the SR to enable all interrupt, clear flags        */
004FC0  EB1800     CLR [W0++]
441:                  *ptos++  = CORCON;                                                   /* Push the Core Control Register on to the stack           */
004FC2  800221     MOV CORCON, W1
004FC4  781801     MOV W1, [W0++]
442:               
443:                   return (ptos);                                                      /* Return the stack pointer to the new tasks stack          */
444:               }
004FC6  060000     RETURN
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uCOS-II/Ports/os_cpu_a.s  ------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                                (c) Copyright 2006, Micrium, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                          dsPIC33/PIC24 MPLab Port
                                                  11:    ;                                                 
                                                  12:    ;
                                                  13:    ; File         : os_cpu_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ; Port Version : V2.81 (and higher)
                                                  16:    ;********************************************************************************************************
                                                  17:    ;
                                                  18:    
                                                  19:    ;
                                                  20:    ;********************************************************************************************************
                                                  21:    ;                                                CONSTANTS
                                                  22:    ;********************************************************************************************************
                                                  23:    ;
                                                  24:     
                                                  25:    ;
                                                  26:    ;********************************************************************************************************
                                                  27:    ;                                                INCLUDES
                                                  28:    ;********************************************************************************************************
                                                  29:    ;
                                                  30:    
                                                  31:    .include "xc.inc"
                                                  32:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  33:    
                                                  34:    ;
                                                  35:    ;********************************************************************************************************
                                                  36:    ;                                             LINKER SPECIFICS
                                                  37:    ;********************************************************************************************************
                                                  38:    ;
                                                  39:    
                                                  40:        .text                                         ; Locate this file in the text region of the build
                                                  41:    
                                                  42:    ;
                                                  43:    ;********************************************************************************************************
                                                  44:    ;                                                 GLOBALS
                                                  45:    ;********************************************************************************************************
                                                  46:    ;
                                                  47:    
                                                  48:        .global  _OSStartHighRdy
                                                  49:        .global  _OSCtxSw
                                                  50:        .global  _OSIntCtxSw
                                                  51:    
                                                  52:    ;
                                                  53:    ;********************************************************************************************************
                                                  54:    ;                                            OSStartHighRdy
                                                  55:    ;
                                                  56:    ; Description : This function determines the highest priority task that is ready to run after
                                                  57:    ;               OSInit() is called.
                                                  58:    ;********************************************************************************************************
                                                  59:    ;
                                                  60:    
                                                  61:    _OSStartHighRdy:
004CD8  024F60     CALL 0x4F60                    62:        call   _OSTaskSwHook                          ; Call user defined task switch hook
                                                  63:    
004CDC  200010     MOV #0x1, W0                   64:        mov    #0x0001, w0                            ; Set OSRunning to TRUE
004CDE  208161     MOV #0x816, W1                 65:        mov    #_OSRunning, w1
004CE0  784880     MOV.B W0, [W1]                 66:        mov.b  w0, [w1]                               ; Set OSRunning to TRUE
                                                  67:    
                                                  68:                                                      ; Get stack pointer of the task to resume
004CE2  804100     MOV 0x820, W0                  69:        mov    _OSTCBHighRdy, w0                      ; Get the pointer to the stack to resume
004CE4  780790     MOV [W0], W15                  70:        mov    [w0], w15                              ; Dereference the pointer and store the data (the new stack address) W15, the stack pointer register
                                                  71:    
004CE6  F90044     POP CORCON                     72:        OS_REGS_RESTORE                               ; Restore all of this tasks registers from the stack
                                                  73:        
004D02  064000     RETFIE                         74:        retfie                                        ; Return from the interrupt, the task is now ready to run
                                                  75:    
                                                  76:    ;
                                                  77:    ;********************************************************************************************************
                                                  78:    ;                                            OSCtxSw
                                                  79:    ;
                                                  80:    ; Description : TThe code to perform a 'task level' context switch.  OSCtxSw() is called 
                                                  81:    ;               when a higher priority task is made ready to run by another task or, 
                                                  82:    ;               when the current task can no longer execute (e.g. it calls OSTimeDly(), 
                                                  83:    ;               OSSemPend() and the semaphore is not available, etc.). 
                                                  84:    ;********************************************************************************************************
                                                  85:    ;
                                                  86:        
                                                  87:    _OSCtxSw:
                                                  88:                                                      ; TRAP (interrupt) should bring us here, not 'call'.
                                                  89:                                                      ; Since dsPIC has no TRAP, it is necessary to correct the stack to simulate an interrupt
                                                  90:                                                      ; In other words, this function must also save SR and IPL3 to the stack, not just the PC.
                                                  91:    
004D04  BFC042     MOV.B SR, WREG                 92:        mov.b  SRL, wreg                              ; Load SRL
004D06  DD0048     SL W0, #8, W0                  93:        sl w0, #8, w0                                 ; Shift left by 8
004D08  AF6044     BTSC CORCON, #3                94:        btsc   CORCON, #IPL3                          ; Test IPL3 bit, skip if clear
004D0A  A07000     BSET W0, #7                    95:        bset   w0, #7;                                ; Copy IPL3 to bit7 of w0
                                                  96:        
004D0C  70004F     IOR W0, [--W15], W0            97:        ior    w0, [--w15], w0                        ; Merge bits
004D0E  781F80     MOV W0, [W15++]                98:        mov    w0, [w15++]                            ; Write back
                                                  99:    
004D10  BE9F80     MOV.D W0, [W15++]              100:       OS_REGS_SAVE                                  ; Save processor registers
                                                  101:   
                                                  102:                                                     ; Save current task's stack pointer into the currect tasks TCB
004D2C  8040E0     MOV 0x81C, W0                  103:       mov    _OSTCBCur, w0                          ; Get the address of the location in this tasks TCB to store the stack pointer
004D2E  78080F     MOV W15, [W0]                  104:       mov    w15, [w0]                              ; Store the stack pointer in this tasks TCB        
                                                  105:   
004D30  024F60     CALL 0x4F60                    106:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  107:   
004D34  804101     MOV 0x820, W1                  108:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
004D36  8840E1     MOV W1, 0x81C                  109:       mov    w1, _OSTCBCur
004D38  208140     MOV #0x814, W0                 110:       mov    #_OSPrioHighRdy, w0
004D3A  208132     MOV #0x813, W2                 111:       mov    #_OSPrioCur, w2
004D3C  784910     MOV.B [W0], [W2]               112:       mov.b  [w0], [w2]
                                                  113:           
004D3E  780791     MOV [W1], W15                  114:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  115:   
004D40  F90044     POP CORCON                     116:       OS_REGS_RESTORE                               ; Restore registers
                                                  117:       
004D5C  064000     RETFIE                         118:       retfie                                        ; Return from interrupt
                                                  119:   
                                                  120:   ;
                                                  121:   ;********************************************************************************************************
                                                  122:   ;                                            OSIntCtxSw
                                                  123:   ;
                                                  124:   ; Description : When an ISR (Interrupt Service Routine) completes, OSIntExit() is called to 
                                                  125:   ;               determine whether a more important task than the interrupted task needs to 
                                                  126:   ;               execute.  If that's the case, OSIntExit() determines which task to run next 
                                                  127:   ;               and calls OSIntCtxSw() to perform the actual context switch to that task.  
                                                  128:   ;********************************************************************************************************
                                                  129:   ;
                                                  130:   
                                                  131:   _OSIntCtxSw:
004D5E  024F60     CALL 0x4F60                    132:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  133:   
004D62  804101     MOV 0x820, W1                  134:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
004D64  8840E1     MOV W1, 0x81C                  135:       mov    w1, _OSTCBCur
004D66  208140     MOV #0x814, W0                 136:       mov    #_OSPrioHighRdy, w0
004D68  208132     MOV #0x813, W2                 137:       mov    #_OSPrioCur, w2
004D6A  784910     MOV.B [W0], [W2]               138:       mov.b  [w0], [w2]
                                                  139:           
004D6C  780791     MOV [W1], W15                  140:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  141:   
004D6E  F90044     POP CORCON                     142:       OS_REGS_RESTORE                               ; Restore registers
                                                  143:       
004D8A  064000     RETFIE                         144:       retfie                                        ; Return from interrupt
                                                  145:   
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uC-LIB/lib_str.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                       ASCII STRING MANAGEMENT
29:                *
30:                * Filename      : lib_str.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 BAN
34:                *                 JDH
35:                *********************************************************************************************************
36:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
37:                *
38:                *                     (a) ALL standard library functions are implemented in the custom library modules :
39:                *
40:                *                         (1) \<Custom Library Directory>\lib_*.*
41:                *
42:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
43:                *
44:                *                               where
45:                *                                       <Custom Library Directory>      directory path for custom library software
46:                *                                       <cpu>                           directory name for specific processor (CPU)
47:                *                                       <compiler>                      directory name for specific compiler
48:                *
49:                *                     (b) Product-specific library functions are implemented in individual products.
50:                *
51:                *********************************************************************************************************
52:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
53:                *                     us permission to reprint portions of their documentation.  Portions of this text are
54:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
55:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
56:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
57:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
58:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
59:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
60:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
61:                *********************************************************************************************************
62:                */
63:                
64:                
65:                /*
66:                *********************************************************************************************************
67:                *                                            INCLUDE FILES
68:                *********************************************************************************************************
69:                */
70:                
71:                #define    MICRIUM_SOURCE
72:                #define    LIB_STR_MODULE
73:                #include  <lib_str.h>
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                            LOCAL DEFINES
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                           LOCAL CONSTANTS
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                          LOCAL DATA TYPES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                            LOCAL TABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
104:                  (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
105:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
106:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
107:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
108:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
109:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
110:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
111:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
112:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
113:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
114:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
115:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
116:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
117:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
118:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
119:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
120:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
121:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
122:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
123:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
124:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
125:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
126:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
127:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
128:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
129:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
130:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
131:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
132:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
133:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
134:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
135:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
136:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
137:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
138:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
139:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
140:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
141:               };
142:               
143:               
144:               /*
145:               *********************************************************************************************************
146:               *                                       LOCAL GLOBAL VARIABLES
147:               *********************************************************************************************************
148:               */
149:               
150:               
151:               /*
152:               *********************************************************************************************************
153:               *                                      LOCAL FUNCTION PROTOTYPES
154:               *********************************************************************************************************
155:               */
156:               
157:               static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
158:                                                              CPU_INT08U     nbr_dig,
159:                                                              CPU_INT08U     nbr_base,
160:                                                              CPU_BOOLEAN    nbr_neg,
161:                                                              CPU_CHAR       lead_char,
162:                                                              CPU_BOOLEAN    lower_case,
163:                                                              CPU_BOOLEAN    nul,
164:                                                              CPU_CHAR      *pstr);
165:               
166:               static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
167:                                                              CPU_CHAR     **pstr_next,
168:                                                              CPU_INT08U     nbr_base,
169:                                                              CPU_BOOLEAN    nbr_signed,
170:                                                              CPU_BOOLEAN   *pnbr_neg);
171:               
172:               
173:               /*
174:               *********************************************************************************************************
175:               *                                     LOCAL CONFIGURATION ERRORS
176:               *********************************************************************************************************
177:               */
178:               
179:               
180:               /*
181:               *********************************************************************************************************
182:               *                                              Str_Len()
183:               *
184:               * Description : Calculate length of a string.
185:               *
186:               * Argument(s) : pstr        Pointer to string (see Note #1).
187:               *
188:               * Return(s)   : Length of string; number of characters in string before terminating NULL character
189:               *                   (see Note #2b1).
190:               *
191:               * Caller(s)   : Application.
192:               *
193:               * Note(s)     : (1) String buffer NOT modified.
194:               *
195:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
196:               *
197:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
198:               *                            which 's' ('pstr') points," ...
199:               *                       (2) "not including the terminating null byte."
200:               *
201:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
202:               *
203:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
204:               *                       (2) "no return value shall be reserved to indicate an error."
205:               *
206:               *               (3) String length calculation terminates when :
207:               *
208:               *                   (a) String pointer points to NULL.
209:               *                       (1) String buffer overlaps with NULL address.
210:               *                       (2) String length calculated for string up to but NOT beyond or including
211:               *                           the NULL address.
212:               *
213:               *                   (b) Terminating NULL character found.
214:               *                       (1) String length calculated for string up to but NOT           including
215:               *                           the NULL character (see Note #2a2).
216:               *********************************************************************************************************
217:               */
218:               
219:               CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
220:               {
221:                   CPU_SIZE_T  len;
222:               
223:               
224:                   len = Str_Len_N(pstr,
003562  EB8080     SETM W1
003564  37FFF3     BRA Str_Len_N
225:                                   DEF_INT_CPU_U_MAX_VAL);
226:               
227:                   return (len);
228:               }
229:               
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                             Str_Len_N()
234:               *
235:               * Description : Calculate length of a string, up to a maximum number of characters.
236:               *
237:               * Argument(s) : pstr        Pointer to string (see Note #1).
238:               *
239:               *               len_max     Maximum number of characters to search (see Note #3c).
240:               *
241:               * Return(s)   : Length of string; number of characters in string before terminating NULL character,
242:               *                   if terminating NULL character     found (see Note #2b1).
243:               *
244:               *               Requested maximum number of characters to search,
245:               *                   if terminating NULL character NOT found (see Note #3c).
246:               *
247:               * Caller(s)   : Application.
248:               *
249:               * Note(s)     : (1) String buffer NOT modified.
250:               *
251:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
252:               *
253:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
254:               *                            which 's' ('pstr') points," ...
255:               *                       (2) "not including the terminating null byte."
256:               *
257:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
258:               *
259:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
260:               *                       (2) "no return value shall be reserved to indicate an error."
261:               *
262:               *               (3) String length calculation terminates when :
263:               *
264:               *                   (a) String pointer points to NULL.
265:               *                       (1) String buffer overlaps with NULL address.
266:               *                       (2) String length calculated for string up to but NOT beyond or including
267:               *                           the NULL address.
268:               *
269:               *                   (b) Terminating NULL character found.
270:               *                       (1) String length calculated for string up to but NOT           including
271:               *                           the NULL character (see Note #2a2).
272:               *
273:               *                   (c) 'len_max' number of characters searched.
274:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
275:               *********************************************************************************************************
276:               */
277:               
278:               CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
279:                                             CPU_SIZE_T   len_max)
280:               {
281:                   const  CPU_CHAR    *pstr_len;
282:                          CPU_SIZE_T   len;
283:               
284:               
285:                   pstr_len = pstr;
286:                   len      = 0u;
00354C  780100     MOV W0, W2
00354E  EB0000     CLR W0
287:                   while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
003550  370001     BRA 0x3554
003554  E00002     CP0 W2
003556  320004     BRA Z, 0x3560
003558  E00432     CP0.B [W2++]
00355A  320002     BRA Z, 0x3560
288:                          (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
00355C  500F81     SUB W0, W1, [W15]
00355E  39FFF9     BRA NC, 0x3552
289:                          ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
290:                       pstr_len++;
291:                       len++;
003552  E80000     INC W0, W0
292:                   }
293:               
294:                   return (len);                                               /* Rtn str len (see Note #3b1).                         */
295:               }
003560  060000     RETURN
296:               
297:               
298:               /*
299:               *********************************************************************************************************
300:               *                                             Str_Copy()
301:               *
302:               * Description : Copy source string to destination string buffer.
303:               *
304:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
305:               *
306:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
307:               *
308:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
309:               *
310:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
311:               *
312:               * Caller(s)   : Application.
313:               *
314:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
315:               *
316:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
317:               *                           string size including the terminating NULL character.
318:               *
319:               *                   (b) Source buffer NOT modified.
320:               *
321:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
322:               *
323:               *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src')
324:               *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
325:               *                       (2) "(including the terminating null byte)."
326:               *
327:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
328:               *
329:               *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
330:               *                       (2) "no return value is reserved to indicate an error."
331:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
332:               *                               NULL for any error(s).
333:               *
334:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
335:               *                       copying takes place between objects that overlap, the behavior is undefined".
336:               *
337:               *               (3) String copy terminates when :
338:               *
339:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
340:               *                       (1) No string copy performed; NULL pointer returned.
341:               *
342:               *                   (b) Destination/Source string pointer(s) point to NULL.
343:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
344:               *
345:               *                   (c) Source string's terminating NULL character found.
346:               *                       (1) Entire source string copied into destination string buffer (see Note #2a).
347:               *********************************************************************************************************
348:               */
349:               
350:               CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
351:                                    const  CPU_CHAR  *pstr_src)
352:               {
353:                   CPU_CHAR  *pstr_rtn;
354:               
355:               
356:                   pstr_rtn = Str_Copy_N(pstr_dest,
00359C  EB8100     SETM W2
00359E  37FFE3     BRA Str_Copy_N
357:                                         pstr_src,
358:                                         DEF_INT_CPU_U_MAX_VAL);
359:               
360:                   return (pstr_rtn);
361:               }
362:               
363:               
364:               /*
365:               *********************************************************************************************************
366:               *                                            Str_Copy_N()
367:               *
368:               * Description : Copy source string to destination string buffer, up to a maximum number of characters.
369:               *
370:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
371:               *
372:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
373:               *
374:               *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
375:               *
376:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
377:               *
378:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
379:               *
380:               * Caller(s)   : Application.
381:               *
382:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
383:               *
384:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
385:               *                           string size including the terminating NULL character.
386:               *
387:               *                   (b) Source string buffer NOT modified.
388:               *
389:               *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
390:               *
391:               *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2'
392:               *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
393:               *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
394:               *                           (C)  &   "(bytes that follow a null byte are not copied)".
395:               *
396:               *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that
397:               *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter
398:               *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in
399:               *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes
400:               *                               in all are written."
401:               *
402:               *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy
403:               *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters,
404:               *                                   this requirement is intentionally NOT implemented to avoid appending
405:               *                                   a potentially large number of unnecessary terminating NULL characters.
406:               *
407:               *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also
408:               *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of
409:               *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
410:               *
411:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
412:               *
413:               *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
414:               *                       (2) "no return value is reserved to indicate an error."
415:               *                           (A) #### This requirement is intentionally ignored in order to return NULL
416:               *                               for any error(s).
417:               *
418:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
419:               *                       copying takes place between objects that overlap, the behavior is undefined".
420:               *
421:               *               (3) String copy terminates when :
422:               *
423:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
424:               *                       (1) No string copy performed; NULL pointer returned.
425:               *
426:               *                   (b) Destination/Source string pointer(s) point to NULL.
427:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
428:               *
429:               *                   (c) Source string's terminating NULL character found.
430:               *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
431:               *
432:               *                   (d) 'len_max' number of characters copied.
433:               *                       (1) 'len_max' number of characters MAY include the terminating NULL character
434:               *                           (see Note #2a1C).
435:               *                       (2) Null copies allowed (i.e. zero-length copies).
436:               *                           (A) No string copy performed; destination string returned  (see Note #2b1).
437:               *********************************************************************************************************
438:               */
439:               
440:               CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
441:                                      const  CPU_CHAR    *pstr_src,
442:                                             CPU_SIZE_T   len_max)
443:               {
444:                          CPU_CHAR    *pstr_copy_dest;
445:                   const  CPU_CHAR    *pstr_copy_src;
446:                          CPU_SIZE_T   len_copy;
447:               
448:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
449:                   if (pstr_dest == (CPU_CHAR *)0) {
003566  E00000     CP0 W0
003568  320015     BRA Z, 0x3594
450:                       return ((CPU_CHAR *)0);
451:                   }
452:                   if (pstr_src  == (const CPU_CHAR *)0) {
00356A  E00001     CP0 W1
00356C  320011     BRA Z, 0x3590
00356E  780200     MOV W0, W4
003570  EB0180     CLR W3
003572  370004     BRA 0x357C
453:                       return ((CPU_CHAR *)0);
454:                   }
455:               
456:               
457:                   pstr_copy_dest = pstr_dest;
458:                   pstr_copy_src  = pstr_src;
459:                   len_copy       = 0u;
460:               
461:                   while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
003576  E00004     CP0 W4
003578  32000B     BRA Z, 0x3590
00357C  E00001     CP0 W1
00357E  320009     BRA Z, 0x3592
462:                          ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
003582  E00405     CP0.B W5
003584  320008     BRA Z, 0x3596
463:                          (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
003580  7842B1     MOV.B [W1++], W5
003586  518F82     SUB W3, W2, [W15]
003588  39FFF5     BRA NC, 0x3574
00358A  370005     BRA 0x3596
464:                          ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
465:                      *pstr_copy_dest = *pstr_copy_src;
003574  785A05     MOV.B W5, [W4++]
466:                       pstr_copy_dest++;
467:                       pstr_copy_src++;
468:                       len_copy++;
00357A  E80183     INC W3, W3
469:                   }
470:                                                                               /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
471:                   if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
472:                       (pstr_copy_src  == (const CPU_CHAR *)0)) {
473:                        return ((CPU_CHAR *)0);
003590  050000     RETLW #0x0, W0
003592  EB0000     CLR W0
474:                   }
475:               
476:                   if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
003596  518F82     SUB W3, W2, [W15]
003598  39FFF9     BRA NC, 0x358C
00359A  060000     RETURN
477:                      *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
00358C  EB4A00     CLR.B [W4]
00358E  060000     RETURN
478:                   }
479:               
480:               
481:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
482:               }
003594  060000     RETURN
483:               
484:               
485:               /*
486:               *********************************************************************************************************
487:               *                                              Str_Cat()
488:               *
489:               * Description : Append concatenation string to destination string.
490:               *
491:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
492:               *
493:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
494:               *
495:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
496:               *
497:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
498:               *
499:               * Caller(s)   : Application.
500:               *
501:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
502:               *
503:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
504:               *                           concatenated string size including the terminating NULL character.
505:               *
506:               *                   (b) Concatenation string buffer NOT modified.
507:               *
508:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
509:               *
510:               *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2'
511:               *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
512:               *
513:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
514:               *                                end of 's1' ('pstr_dest')."
515:               *                           (B)  A "terminating null byte" is appended at the end of the concatenated
516:               *                                destination strings.
517:               *
518:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
519:               *
520:               *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
521:               *                       (2) "no return value shall be reserved to indicate an error."
522:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
523:               *                               NULL for any error(s).
524:               *
525:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
526:               *                       copying takes place between objects that overlap, the behavior is undefined."
527:               *
528:               *               (3) String concatenation terminates when :
529:               *
530:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
531:               *                       (1) No string concatenation performed; NULL pointer returned.
532:               *
533:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
534:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
535:               *
536:               *                   (c) Concatenation string's terminating NULL character found.
537:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
538:               *********************************************************************************************************
539:               */
540:               
541:               CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
542:                                   const  CPU_CHAR  *pstr_cat)
543:               {
544:                   CPU_CHAR  *pstr_rtn;
545:               
546:               
547:                   pstr_rtn = Str_Cat_N(pstr_dest,
0035E4  EB8100     SETM W2
0035E6  37FFDC     BRA Str_Cat_N
548:                                        pstr_cat,
549:                                        DEF_INT_CPU_U_MAX_VAL);
550:               
551:                   return (pstr_rtn);
552:               }
553:               
554:               
555:               /*
556:               *********************************************************************************************************
557:               *                                             Str_Cat_N()
558:               *
559:               * Description : Append concatenation string to destination string, up to a maximum number of characters.
560:               *
561:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
562:               *
563:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
564:               *
565:               *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
566:               *
567:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
568:               *
569:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
570:               *
571:               * Caller(s)   : Application.
572:               *
573:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
574:               *
575:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
576:               *                           concatenated string size including the terminating NULL character.
577:               *
578:               *                   (b) Concatenation string buffer NOT modified.
579:               *
580:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
581:               *
582:               *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2'
583:               *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
584:               *                           (B)  but "not more than 'n' ('len_max') bytes".
585:               *
586:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
587:               *                                end of 's1' ('pstr_dest')."
588:               *                           (B) "(a null byte and bytes that follow it are not appended)."
589:               *                           (C) "A terminating null byte is always appended to the result."
590:               *
591:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
592:               *
593:               *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
594:               *                       (2) "no return value shall be reserved to indicate an error."
595:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
596:               *                               NULL for any error(s).
597:               *
598:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
599:               *                       copying takes place between objects that overlap, the behavior is undefined."
600:               *
601:               *               (3) String concatenation terminates when :
602:               *
603:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
604:               *                       (1) No string concatenation performed; NULL pointer returned.
605:               *
606:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
607:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
608:               *
609:               *                   (c) Concatenation string's terminating NULL character found.
610:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
611:               *
612:               *                   (d) 'len_max' number of characters concatenated.
613:               *
614:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character
615:               *                           (see Note #2a2).
616:               *
617:               *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
618:               *                           (A) No string concatenation performed; destination string returned
619:               *                               (see Note #2b1).
620:               *********************************************************************************************************
621:               */
622:               
623:               CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
624:                                     const  CPU_CHAR    *pstr_cat,
625:                                            CPU_SIZE_T   len_max)
626:               {
627:                          CPU_CHAR    *pstr_cat_dest;
628:                   const  CPU_CHAR    *pstr_cat_src;
629:                          CPU_SIZE_T   len_cat;
630:               
631:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
632:                   if (pstr_dest == (CPU_CHAR *)0) {
0035A0  E00000     CP0 W0
0035A2  32001B     BRA Z, 0x35DA
633:                       return ((CPU_CHAR *)0);
634:                   }
635:                   if (pstr_cat  == (const CPU_CHAR *)0) {
0035A4  E00001     CP0 W1
0035A6  320017     BRA Z, 0x35D6
636:                       return ((CPU_CHAR *)0);
637:                   }
638:               
639:                   if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
0035A8  E00002     CP0 W2
0035AA  320017     BRA Z, 0x35DA
0035AC  780200     MOV W0, W4
0035AE  370002     BRA 0x35B4
640:                       return ((CPU_CHAR *)pstr_dest);
641:                   }
642:               
643:               
644:                   pstr_cat_dest = pstr_dest;
645:                   while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
0035B0  E00004     CP0 W4
0035B2  320011     BRA Z, 0x35D6
0035B4  780184     MOV W4, W3
0035B8  E00434     CP0.B [W4++]
0035BA  3AFFFA     BRA NZ, 0x35B0
0035BC  37000F     BRA 0x35DC
0035DC  EB0200     CLR W4
0035DE  37FFF3     BRA 0x35C6
646:                          (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
0035B6  780203     MOV W3, W4
647:                       pstr_cat_dest++;
648:                   }
649:                   if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
650:                       return ((CPU_CHAR *)0);
651:                   }
652:               
653:                   pstr_cat_src = pstr_cat;
654:                   len_cat      = 0u;
655:               
656:                   while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
0035C0  E00003     CP0 W3
0035C2  320009     BRA Z, 0x35D6
0035C6  E00001     CP0 W1
0035C8  320007     BRA Z, 0x35D8
657:                          ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
0035CC  E00405     CP0.B W5
0035CE  320008     BRA Z, 0x35E0
658:                          (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
0035CA  7842B1     MOV.B [W1++], W5
0035D0  520F82     SUB W4, W2, [W15]
0035D2  39FFF5     BRA NC, 0x35BE
0035D4  370005     BRA 0x35E0
659:                          ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
660:                      *pstr_cat_dest = *pstr_cat_src;
0035BE  785985     MOV.B W5, [W3++]
661:                       pstr_cat_dest++;
662:                       pstr_cat_src++;
663:                       len_cat++;
0035C4  E80204     INC W4, W4
664:                   }
665:                                                                               /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
666:                   if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
667:                       (pstr_cat_src  == (const CPU_CHAR *)0)) {
668:                        return ((CPU_CHAR *)0);
0035D6  050000     RETLW #0x0, W0
0035D8  EB0000     CLR W0
669:                   }
670:               
671:                  *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
0035E0  EB4980     CLR.B [W3]
672:               
673:               
674:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
0035E2  060000     RETURN
675:               }
0035DA  060000     RETURN
676:               
677:               
678:               /*
679:               *********************************************************************************************************
680:               *                                              Str_Cmp()
681:               *
682:               * Description : Determine if two strings are identical.
683:               *
684:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
685:               *
686:               *               p2_str      Pointer to second string (see Note #1).
687:               *
688:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
689:               *
690:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
691:               *
692:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
693:               *
694:               *               See also Note #2b.
695:               *
696:               * Caller(s)   : Application.
697:               *
698:               * Note(s)     : (1) String buffers NOT modified.
699:               *
700:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
701:               *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
702:               *                       string pointed to by 's2' ('p2_str)".
703:               *
704:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
705:               *                          "upon successful completion, strcmp() shall return an integer greater than,
706:               *                           equal to, or less than 0".
707:               *
708:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
709:               *                           sign of a non-zero return value shall be determined by the sign of the difference
710:               *                           between the values of the first pair of bytes ... that differ in the strings
711:               *                           being compared".
712:               *
713:               *               (3) String comparison terminates when :
714:               *
715:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
716:               *                               (1) NULL strings identical; 0 returned.
717:               *
718:               *                           (B) (1) 'p1_str' passed a NULL pointer.
719:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
720:               *
721:               *                               (2) 'p2_str' passed a NULL pointer.
722:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
723:               *
724:               *                       (2) (A) BOTH strings point to NULL.
725:               *                               (1) Strings overlap with NULL address.
726:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
727:               *                                   0 returned.
728:               *
729:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
730:               *                                   (a) 'p1_str' overlaps with NULL address.
731:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
732:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
733:               *
734:               *                               (2) 'p2_str_cmp_next' points to NULL.
735:               *                                   (a) 'p2_str' overlaps with NULL address.
736:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
737:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
738:               *
739:               *                   (b) Terminating NULL character found in both strings.
740:               *                       (1) Strings identical; 0 returned.
741:               *                       (2) Only one NULL character test required in conditional since previous condition
742:               *                           tested character equality.
743:               *
744:               *                   (c) Non-matching characters found.
745:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
746:               *                           from the character pointed to by 'p1_str'.
747:               *
748:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
749:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
750:               *********************************************************************************************************
751:               */
752:               
753:               CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
754:                                    const  CPU_CHAR  *p2_str)
755:               {
756:                   CPU_INT16S  cmp_val;
757:               
758:               
759:                   cmp_val = Str_Cmp_N(p1_str,
003652  EB8100     SETM W2
003654  37FFC9     BRA Str_Cmp_N
760:                                       p2_str,
761:                                       DEF_INT_CPU_U_MAX_VAL);
762:               
763:                   return (cmp_val);
764:               }
765:               
766:               
767:               /*
768:               *********************************************************************************************************
769:               *                                             Str_Cmp_N()
770:               *
771:               * Description : Determine if two strings are identical for up to a maximum number of characters.
772:               *
773:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
774:               *
775:               *               p2_str      Pointer to second string (see Note #1).
776:               *
777:               *               len_max     Maximum number of characters to compare  (see Note  #3d).
778:               *
779:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
780:               *
781:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
782:               *
783:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
784:               *
785:               *               See also Note #2b.
786:               *
787:               * Caller(s)   : Application.
788:               *
789:               * Note(s)     : (1) String buffers NOT modified.
790:               *
791:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
792:               *
793:               *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str')
794:               *                            to the array pointed to by 's2' ('p2_str)" ...
795:               *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
796:               *
797:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
798:               *                          "upon successful completion, strncmp() shall return an integer greater than,
799:               *                           equal to, or less than 0".
800:               *
801:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
802:               *                          "the sign of a non-zero return value is determined by the sign of the difference
803:               *                           between the values of the first pair of bytes ... that differ in the strings
804:               *                           being compared".
805:               *
806:               *               (3) String comparison terminates when :
807:               *
808:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
809:               *                               (1) NULL strings identical; 0 returned.
810:               *
811:               *                           (B) (1) 'p1_str' passed a NULL pointer.
812:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
813:               *
814:               *                               (2) 'p2_str' passed a NULL pointer.
815:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
816:               *
817:               *                       (2) (A) BOTH strings point to NULL.
818:               *                               (1) Strings overlap with NULL address.
819:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
820:               *                                   0 returned.
821:               *
822:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
823:               *                                   (a) 'p1_str' overlaps with NULL address.
824:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
825:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
826:               *
827:               *                               (2) 'p2_str_cmp_next' points to NULL.
828:               *                                   (a) 'p2_str' overlaps with NULL address.
829:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
830:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
831:               *
832:               *                   (b) Terminating NULL character found in both strings.
833:               *                       (1) Strings identical; 0 returned.
834:               *                       (2) Only one NULL character test required in conditional since previous condition
835:               *                           tested character equality.
836:               *
837:               *                   (c) Non-matching characters found.
838:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
839:               *                           from the character pointed to by 'p1_str'.
840:               *
841:               *                   (d) (1) 'len_max' passed a zero length.
842:               *                           (A) Zero-length strings identical; 0 returned.
843:               *
844:               *                       (2) First 'len_max' number of characters identical.
845:               *                           (A) Strings identical; 0 returned.
846:               *
847:               *                       See also Note #2a2.
848:               *
849:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
850:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
851:               *********************************************************************************************************
852:               */
853:               
854:               CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
003608  E80281     INC W1, W5
00360A  E80200     INC W0, W4
855:                                      const  CPU_CHAR    *p2_str,
856:                                             CPU_SIZE_T   len_max)
857:               {
858:                   const  CPU_CHAR    *p1_str_cmp;
859:                   const  CPU_CHAR    *p2_str_cmp;
860:                   const  CPU_CHAR    *p1_str_cmp_next;
861:                   const  CPU_CHAR    *p2_str_cmp_next;
862:                          CPU_INT16S   cmp_val;
863:                          CPU_SIZE_T   cmp_len;
864:               
865:               
866:                   if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
0035EA  E00002     CP0 W2
0035EC  320030     BRA Z, 0x364E
867:                       return (0);
0035E8  EB0180     CLR W3
868:                   }
869:               
870:                   if (p1_str == (const CPU_CHAR *)0) {
0035EE  E00000     CP0 W0
0035F0  3A0004     BRA NZ, 0x35FA
871:                       if (p2_str == (const CPU_CHAR *)0) {
0035F2  E00001     CP0 W1
0035F4  32002C     BRA Z, 0x364E
872:                           return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
873:                       }
874:                       cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
0035F6  FB8191     ZE [W1], W3
0035F8  370027     BRA 0x3648
875:                       return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
876:                   }
877:                   if (p2_str == (const CPU_CHAR *)0) {
0035FC  E00001     CP0 W1
0035FE  3A0004     BRA NZ, 0x3608
878:                       cmp_val = (CPU_INT16S)(*p1_str);
003600  FB8190     ZE [W0], W3
879:                       return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
003602  370025     BRA 0x364E
880:                   }
881:               
882:               
883:                   p1_str_cmp      = p1_str;
884:                   p2_str_cmp      = p2_str;
885:                   p1_str_cmp_next = p1_str_cmp;
886:                   p2_str_cmp_next = p2_str_cmp;
887:                   p1_str_cmp_next++;
888:                   p2_str_cmp_next++;
889:                   cmp_len         = 0u;
0035FA  EB0300     CLR W6
890:               
891:                   while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
00360C  784010     MOV.B [W0], W0
00360E  784091     MOV.B [W1], W1
003610  504F81     SUB.B W0, W1, [W15]
003612  3A0009     BRA NZ, 0x3626
003614  E00400     CP0.B W0
003616  320006     BRA Z, 0x3624
003624  784080     MOV.B W0, W1
892:                          (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
003618  E00004     CP0 W4
00361A  320004     BRA Z, 0x3624
893:                          ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
00361C  E00005     CP0 W5
00361E  320002     BRA Z, 0x3624
894:                          ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
003620  530F82     SUB W6, W2, [W15]
003622  39FFF0     BRA NC, 0x3604
895:                          ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
896:                       p1_str_cmp++;
897:                       p2_str_cmp++;
898:                       p1_str_cmp_next++;
899:                       p2_str_cmp_next++;
900:                       cmp_len++;
003604  E80306     INC W6, W6
003606  BE0004     MOV.D W4, W0
901:                   }
902:               
903:               
904:                   if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
003628  530F82     SUB W6, W2, [W15]
00362A  320011     BRA Z, 0x364E
905:                       return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
003626  EB0180     CLR W3
906:                   }
907:               
908:                   if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
00362C  504F81     SUB.B W0, W1, [W15]
00362E  320004     BRA Z, 0x3638
909:                                                                               /* ... calc & rtn char diff  (see Note #3c1).           */
910:                        cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
003630  FB8180     ZE W0, W3
003632  FB8081     ZE W1, W1
003634  518181     SUB W3, W1, W3
003636  37000B     BRA 0x364E
911:               
912:                   } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
00363A  E00400     CP0.B W0
00363C  320008     BRA Z, 0x364E
913:                        cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
003638  EB0180     CLR W3
914:               
915:                   } else {
916:                       if (p1_str_cmp_next == (const CPU_CHAR *)0) {
00363E  E00004     CP0 W4
003640  3A0005     BRA NZ, 0x364C
917:                           if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
003642  E00005     CP0 W5
003644  320004     BRA Z, 0x364E
918:                               cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
919:                           } else {                                            /* If p1_str_cmp_next NULL, ...                         */
920:                                                                               /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
921:                               cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
003646  FB8195     ZE [W5], W3
003648  EA0183     NEG W3, W3
00364A  370001     BRA 0x364E
922:                           }
923:                       } else {                                                /* If p2_str_cmp_next NULL, ...                         */
924:                           cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
00364C  FB8194     ZE [W4], W3
925:                       }
926:                   }
927:               
928:               
929:                   return (cmp_val);
930:               }
00364E  780003     MOV W3, W0
003650  060000     RETURN
931:               
932:               
933:               /*
934:               *********************************************************************************************************
935:               *                                         Str_CmpIgnoreCase()
936:               *
937:               * Description : Determine if two strings are identical, ignoring case.
938:               *
939:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
940:               *
941:               *               p2_str      Pointer to second string (see Note #1).
942:               *
943:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
944:               *
945:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
946:               *
947:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
948:               *
949:               *               See also Note #2b.
950:               *
951:               * Caller(s)   : Application.
952:               *
953:               * Note(s)     : (1) String buffers NOT modified.
954:               *
955:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
956:               *
957:               *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1'
958:               *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
959:               *                           (B) "ignoring differences in case".
960:               *
961:               *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
962:               *                            and then a byte comparison performed."
963:               *
964:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
965:               *                          "upon successful completion, strcasecmp() shall return an integer greater than,
966:               *                           equal to, or less than 0".
967:               *
968:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
969:               *                           sign of a non-zero return value shall be determined by the sign of the difference
970:               *                           between the values of the first pair of bytes ... that differ in the strings
971:               *                           being compared".
972:               *
973:               *               (3) String comparison terminates when :
974:               *
975:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
976:               *                               (1) NULL strings identical; 0 returned.
977:               *
978:               *                           (B) (1) 'p1_str' passed a NULL pointer.
979:               *                                   (a) Return negative value of character pointed to by 'p2_str', converted
980:               *                                       to lower case (see Note #2a2).
981:               *
982:               *                               (2) 'p2_str' passed a NULL pointer.
983:               *                                   (a) Return positive value of character pointed to by 'p1_str', converted
984:               *                                       to lower case (see Note #2a2).
985:               *
986:               *                       (2) (A) BOTH strings point to NULL.
987:               *                               (1) Strings overlap with NULL address.
988:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
989:               *                                   0 returned.
990:               *
991:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
992:               *                                   (a) 'p1_str' overlaps with NULL address.
993:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
994:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
995:               *                                       converted to lower case (see Note #2a2).
996:               *
997:               *                               (2) 'p2_str_cmp_next' points to NULL.
998:               *                                   (a) 'p2_str' overlaps with NULL address.
999:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1000:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1001:              *                                       converted to lower case (see Note #2a2).
1002:              *
1003:              *                   (b) Terminating NULL character found in both strings.
1004:              *                       (1) Strings identical; 0 returned.
1005:              *                       (2) Only one NULL character test required in conditional since previous condition
1006:              *                           tested character equality.
1007:              *
1008:              *                   (c) Non-matching characters found.
1009:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1010:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1011:              *                           to lower case.
1012:              *
1013:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1014:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1015:              *********************************************************************************************************
1016:              */
1017:              
1018:              CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
1019:                                             const  CPU_CHAR  *p2_str)
1020:              {
1021:                  CPU_INT16S  cmp_val;
1022:              
1023:              
1024:                  cmp_val = Str_CmpIgnoreCase_N(p1_str,
0036E0  EB8100     SETM W2
0036E2  37FFB9     BRA Str_CmpIgnoreCase_N
1025:                                                p2_str,
1026:                                                DEF_INT_CPU_U_MAX_VAL);
1027:              
1028:                  return (cmp_val);
1029:              }
1030:              
1031:              
1032:              /*
1033:              *********************************************************************************************************
1034:              *                                        Str_CmpIgnoreCase_N()
1035:              *
1036:              * Description : Determine if two strings are identical for up to a maximum number of characters,
1037:              *                   ignoring case.
1038:              *
1039:              * Argument(s) : p1_str      Pointer to first  string (see Note #1).
1040:              *
1041:              *               p2_str      Pointer to second string (see Note #1).
1042:              *
1043:              *               len_max     Maximum number of characters to compare  (see Note  #3d).
1044:              *
1045:              * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
1046:              *
1047:              *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
1048:              *
1049:              *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
1050:              *
1051:              *               See also Note #2b.
1052:              *
1053:              * Caller(s)   : Application.
1054:              *
1055:              * Note(s)     : (1) String buffers NOT modified.
1056:              *
1057:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
1058:              *
1059:              *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1'
1060:              *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
1061:              *                           (B) "ignoring differences in case"                           ...
1062:              *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
1063:              *
1064:              *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
1065:              *                            and then a byte comparison performed."
1066:              *
1067:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
1068:              *                          "upon successful completion, strncasecmp() shall return an integer greater than,
1069:              *                           equal to, or less than 0".
1070:              *
1071:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
1072:              *                           sign of a non-zero return value shall be determined by the sign of the difference
1073:              *                           between the values of the first pair of bytes ... that differ in the strings
1074:              *                           being compared".
1075:              *
1076:              *               (3) String comparison terminates when :
1077:              *
1078:              *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
1079:              *                               (1) NULL strings identical; 0 returned.
1080:              *
1081:              *                           (B) (1) 'p1_str' passed a NULL pointer.
1082:              *                                   (a) Return negative value of character pointed to by 'p2_str', converted
1083:              *                                       to lower case (see Note #2a2).
1084:              *
1085:              *                               (2) 'p2_str' passed a NULL pointer.
1086:              *                                   (a) Return positive value of character pointed to by 'p1_str', converted
1087:              *                                       to lower case (see Note #2a2).
1088:              *
1089:              *                       (2) (A) BOTH strings point to NULL.
1090:              *                               (1) Strings overlap with NULL address.
1091:              *                               (2) Strings identical up to but NOT beyond or including the NULL address;
1092:              *                                   0 returned.
1093:              *
1094:              *                           (B) (1) 'p1_str_cmp_next' points to NULL.
1095:              *                                   (a) 'p1_str' overlaps with NULL address.
1096:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1097:              *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
1098:              *                                       converted to lower case (see Note #2a2).
1099:              *
1100:              *                               (2) 'p2_str_cmp_next' points to NULL.
1101:              *                                   (a) 'p2_str' overlaps with NULL address.
1102:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1103:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1104:              *                                       converted to lower case (see Note #2a2).
1105:              *
1106:              *                   (b) Terminating NULL character found in both strings.
1107:              *                       (1) Strings identical; 0 returned.
1108:              *                       (2) Only one NULL character test required in conditional since previous condition
1109:              *                           tested character equality.
1110:              *
1111:              *                   (c) Non-matching characters found.
1112:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1113:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1114:              *                           to lower case.
1115:              *
1116:              *                   (d) (1) 'len_max' passed a zero length.
1117:              *                           (A) Zero-length strings identical; 0 returned.
1118:              *
1119:              *                       (2) First 'len_max' number of characters identical.
1120:              *                           (A) Strings identical; 0 returned.
1121:              *
1122:              *                       See also Note #2a1C.
1123:              *$PAGE*
1124:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1125:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1126:              *********************************************************************************************************
1127:              */
1128:              
1129:              CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
1130:                                               const  CPU_CHAR    *p2_str,
1131:                                                      CPU_SIZE_T   len_max)
1132:              {
003656  BE9F88     MOV.D W8, [W15++]
003658  BE9F8A     MOV.D W10, [W15++]
00365A  781F8C     MOV W12, [W15++]
00365C  780401     MOV W1, W8
00365E  780602     MOV W2, W12
1133:                  const  CPU_CHAR    *p1_str_cmp;
1134:                  const  CPU_CHAR    *p2_str_cmp;
1135:                  const  CPU_CHAR    *p1_str_cmp_next;
1136:                  const  CPU_CHAR    *p2_str_cmp_next;
1137:                         CPU_CHAR     char_1;
1138:                         CPU_CHAR     char_2;
1139:                         CPU_INT16S   cmp_val;
1140:                         CPU_SIZE_T   cmp_len;
1141:              
1142:              
1143:                  if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
003662  E0000C     CP0 W12
003664  320038     BRA Z, 0x36D6
1144:                      return (0);
003660  EB0080     CLR W1
1145:                  }
1146:              
1147:                  if (p1_str == (const CPU_CHAR *)0) {
003666  E00000     CP0 W0
003668  32002C     BRA Z, 0x36C2
1148:                      if (p2_str == (const CPU_CHAR *)0) {
1149:                          return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
1150:                      }
1151:                      char_2  =  ASCII_ToLower(*p2_str);
1152:                      cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
1153:                      return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
1154:                  }
1155:                  if (p2_str == (const CPU_CHAR *)0) {
00366A  E00008     CP0 W8
00366C  3A0002     BRA NZ, 0x3672
1156:                      char_1  =  ASCII_ToLower(*p1_str);
00366E  784010     MOV.B [W0], W0
003670  370030     BRA 0x36D2
1157:                      cmp_val = (CPU_INT16S)char_1;
1158:                      return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
1159:                  }
1160:              
1161:              
1162:                  p1_str_cmp      = p1_str;
1163:                  p2_str_cmp      = p2_str;
1164:                  p1_str_cmp_next = p1_str_cmp;
1165:                  p2_str_cmp_next = p2_str_cmp;
1166:                  p1_str_cmp_next++;
1167:                  p2_str_cmp_next++;
1168:                  char_1          = ASCII_ToLower(*p1_str_cmp);
003672  780500     MOV W0, W10
003674  78403A     MOV.B [W10++], W0
003676  07088A     RCALL ASCII_ToLower
003678  784480     MOV.B W0, W9
1169:                  char_2          = ASCII_ToLower(*p2_str_cmp);
00367A  784038     MOV.B [W8++], W0
00367C  070887     RCALL ASCII_ToLower
1170:                  cmp_len         = 0u;
00367E  EB0580     CLR W11
1171:              
1172:                  while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
003680  370006     BRA 0x368E
00368E  54CF80     SUB.B W9, W0, [W15]
003690  3A000A     BRA NZ, 0x36A6
003692  97F87A     MOV.B [W10-1], W0
003694  E00400     CP0.B W0
003696  320006     BRA Z, 0x36A4
1173:                         (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
003698  E0000A     CP0 W10
00369A  320004     BRA Z, 0x36A4
1174:                         ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
00369C  E00008     CP0 W8
00369E  320002     BRA Z, 0x36A4
0036A4  784009     MOV.B W9, W0
1175:                         ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
0036A0  558F8C     SUB W11, W12, [W15]
0036A2  39FFEF     BRA NC, 0x3682
1176:                         ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
1177:                      p1_str_cmp++;
1178:                      p2_str_cmp++;
1179:                      p1_str_cmp_next++;
1180:                      p2_str_cmp_next++;
1181:                      cmp_len++;
003682  E8058B     INC W11, W11
1182:                      char_1 = ASCII_ToLower(*p1_str_cmp);
003684  78403A     MOV.B [W10++], W0
003686  070882     RCALL ASCII_ToLower
003688  784480     MOV.B W0, W9
1183:                      char_2 = ASCII_ToLower(*p2_str_cmp);
00368A  784038     MOV.B [W8++], W0
00368C  07087F     RCALL ASCII_ToLower
1184:                  }
1185:              
1186:              
1187:                  if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
0036A8  558F8C     SUB W11, W12, [W15]
0036AA  320015     BRA Z, 0x36D6
1188:                      return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
0036A6  EB0080     CLR W1
1189:                  }
1190:              
1191:                  if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
0036AC  54CF80     SUB.B W9, W0, [W15]
0036AE  320004     BRA Z, 0x36B8
1192:                                                                              /* ... calc & rtn char diff  (see Note #3c1).           */
1193:                       cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
0036B0  FB8089     ZE W9, W1
0036B2  FB8000     ZE W0, W0
0036B4  508080     SUB W1, W0, W1
0036B6  37000F     BRA 0x36D6
1194:              
1195:                  } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
0036BA  E00409     CP0.B W9
0036BC  32000C     BRA Z, 0x36D6
1196:                       cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
0036B8  EB0080     CLR W1
1197:              
1198:                  } else {
1199:                      if (p1_str_cmp_next == (const CPU_CHAR *)0) {
0036BE  E0000A     CP0 W10
0036C0  3A0007     BRA NZ, 0x36D0
1200:                          if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
0036C2  E00008     CP0 W8
0036C4  320008     BRA Z, 0x36D6
1201:                              cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
1202:                          } else {                                            /* If p1_str_cmp_next NULL, ...                         */
1203:                              char_2  =  ASCII_ToLower(*p2_str_cmp_next);
0036C6  784018     MOV.B [W8], W0
0036C8  070861     RCALL ASCII_ToLower
1204:                                                                              /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
1205:                              cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
0036CA  FB8080     ZE W0, W1
0036CC  EA0081     NEG W1, W1
0036CE  370003     BRA 0x36D6
1206:                          }
1207:                      } else {                                                /* If p2_str_cmp_next NULL, ...                         */
1208:                          char_1  =  ASCII_ToLower(*p1_str_cmp_next);
0036D0  78401A     MOV.B [W10], W0
0036D2  07085C     RCALL ASCII_ToLower
1209:                          cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
0036D4  FB8080     ZE W0, W1
1210:                      }
1211:                  }
1212:              
1213:              
1214:                  return (cmp_val);
1215:              }
0036D6  780001     MOV W1, W0
0036D8  78064F     MOV [--W15], W12
0036DA  BE054F     MOV.D [--W15], W10
0036DC  BE044F     MOV.D [--W15], W8
0036DE  060000     RETURN
1216:              
1217:              
1218:              /*
1219:              *********************************************************************************************************
1220:              *                                             Str_Char()
1221:              *
1222:              * Description : Search string for first occurrence of specific character.
1223:              *
1224:              * Argument(s) : pstr            Pointer to string (see Note #1).
1225:              *
1226:              *               srch_char       Search character.
1227:              *
1228:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1229:              *
1230:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1231:              *
1232:              * Caller(s)   : Application.
1233:              *
1234:              * Note(s)     : (1) String buffer NOT modified.
1235:              *
1236:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1237:              *
1238:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1239:              *                            ... in the string pointed to by 's' ('pstr')."
1240:              *                       (2) "The terminating null byte is considered to be part of the string."
1241:              *
1242:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1243:              *                       "upon completion, strchr() shall return" :
1244:              *
1245:              *                       (1) "a pointer to the byte," ...
1246:              *                       (2) "or a null pointer if the byte was not found."
1247:              *                           (A) #### Although NO strchr() specification states to return NULL for
1248:              *                               any other reason(s), NULL is also returned for any error(s).
1249:              *
1250:              *               (3) String search terminates when :
1251:              *
1252:              *                   (a) String pointer passed a NULL pointer.
1253:              *                       (1) No string search performed; NULL pointer returned.
1254:              *
1255:              *                   (b) String pointer points to NULL.
1256:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1257:              *
1258:              *                   (c) String's terminating NULL character found.
1259:              *                       (1) Search character NOT found in search string; NULL pointer returned
1260:              *                           (see Note #2b2).
1261:              *                       (2) Applicable even if search character is the terminating NULL character
1262:              *                           (see Note #2a2).
1263:              *
1264:              *                   (d) Search character found.
1265:              *                       (1) Return pointer to first occurrence of search character in search string
1266:              *                           (see Note #2a1).
1267:              *********************************************************************************************************
1268:              */
1269:              
1270:              CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
1271:                                          CPU_CHAR   srch_char)
1272:              {
1273:                  CPU_CHAR  *pstr_rtn;
1274:              
1275:              
1276:                  pstr_rtn = Str_Char_N(pstr,
00371E  784101     MOV.B W1, W2
003720  EB8080     SETM W1
003722  37FFE0     BRA Str_Char_N
1277:                                        DEF_INT_CPU_U_MAX_VAL,
1278:                                        srch_char);
1279:              
1280:                  return (pstr_rtn);
1281:              }
1282:              
1283:              
1284:              /*
1285:              *********************************************************************************************************
1286:              *                                            Str_Char_N()
1287:              *
1288:              * Description : Search string for first occurrence of specific character, up to a maximum number
1289:              *                   of characters.
1290:              *
1291:              * Argument(s) : pstr            Pointer to string (see Note #1).
1292:              *
1293:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1294:              *
1295:              *               srch_char       Search character.
1296:              *
1297:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1298:              *
1299:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1300:              *
1301:              * Caller(s)   : Application.
1302:              *
1303:              * Note(s)     : (1) String buffer NOT modified.
1304:              *
1305:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1306:              *
1307:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1308:              *                            ... in the string pointed to by 's' ('pstr')."
1309:              *                       (2) "The terminating null byte is considered to be part of the string."
1310:              *
1311:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1312:              *                       "upon completion, strchr() shall return" :
1313:              *
1314:              *                       (1) "a pointer to the byte," ...
1315:              *                       (2) "or a null pointer if the byte was not found."
1316:              *                           (A) #### Although NO strchr() specification states to return NULL for
1317:              *                               any other reason(s), NULL is also returned for any error(s).
1318:              *
1319:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1320:              *                       argument list for consistency with all other custom string library functions.
1321:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1322:              *                       to comply with most standard library's strnchr() argument list.
1323:              *
1324:              *               (3) String search terminates when :
1325:              *
1326:              *                   (a) String pointer passed a NULL pointer.
1327:              *                       (1) No string search performed; NULL pointer returned.
1328:              *
1329:              *                   (b) String pointer points to NULL.
1330:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1331:              *
1332:              *                   (c) String's terminating NULL character found.
1333:              *                       (1) Search character NOT found in search string; NULL pointer returned
1334:              *                           (see Note #2b2).
1335:              *                       (2) Applicable even if search character is the terminating NULL character
1336:              *                           (see Note #2a2).
1337:              *
1338:              *                   (d) Search character found.
1339:              *                       (1) Return pointer to first occurrence of search character in search string
1340:              *                           (see Note #2a1).
1341:              *
1342:              *                   (e) 'len_max' number of characters searched.
1343:              *                       (1) Search character NOT found in search string within first 'len_max' number
1344:              *                           of characters; NULL pointer returned.
1345:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1346:              *                           (see Note #2a2).
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
1351:                                            CPU_SIZE_T   len_max,
1352:                                            CPU_CHAR     srch_char)
1353:              {
1354:                  const  CPU_CHAR    *pstr_char;
1355:                         CPU_SIZE_T   len_srch;
1356:              
1357:              
1358:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
0036E6  E00000     CP0 W0
0036E8  320015     BRA Z, 0x3714
1359:                      return ((CPU_CHAR *)0);
0036E4  EB0180     CLR W3
1360:                  }
1361:              
1362:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
0036EA  EB0200     CLR W4
0036EC  E00001     CP0 W1
0036EE  320012     BRA Z, 0x3714
0036F0  370004     BRA 0x36FA
0036F2  780180     MOV W0, W3
1363:                      return ((CPU_CHAR *)0);
1364:                  }
1365:              
1366:              
1367:                  pstr_char = pstr;
1368:                  len_srch  = 0u;
1369:              
1370:                  while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
0036F4  E00000     CP0 W0
0036F6  32000E     BRA Z, 0x3714
003700  E00405     CP0.B W5
003702  32000A     BRA Z, 0x3718
1371:                         (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
0036FC  780003     MOV W3, W0
0036FE  7842B0     MOV.B [W0++], W5
003704  52CF82     SUB.B W5, W2, [W15]
003706  320008     BRA Z, 0x3718
1372:                         (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
003708  520F81     SUB W4, W1, [W15]
00370A  39FFF3     BRA NC, 0x36F2
00370C  370002     BRA 0x3712
1373:                         ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
1374:                      pstr_char++;
1375:                      len_srch++;
0036F8  E80204     INC W4, W4
0036FA  780180     MOV W0, W3
1376:                  }
1377:              
1378:              
1379:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
1380:                      return ((CPU_CHAR *)0);
1381:                  }
1382:              
1383:                  if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
003718  520F81     SUB W4, W1, [W15]
00371A  31FFFB     BRA C, 0x3712
00371C  37FFF8     BRA 0x370E
1384:                      return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
003712  EB0180     CLR W3
1385:                  }
1386:              
1387:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
00370E  52CF82     SUB.B W5, W2, [W15]
003710  320001     BRA Z, 0x3714
1388:                       return ((CPU_CHAR *)0);
1389:                  }
1390:              
1391:              
1392:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
1393:              }
003714  780003     MOV W3, W0
003716  060000     RETURN
1394:              
1395:              
1396:              /*
1397:              *********************************************************************************************************
1398:              *                                           Str_Char_Last()
1399:              *
1400:              * Description : Search string for last occurrence of specific character.
1401:              *
1402:              * Argument(s) : pstr            Pointer to string (see Note #1).
1403:              *
1404:              *               srch_char       Search character.
1405:              *
1406:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1407:              *
1408:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1409:              *
1410:              * Caller(s)   : Application.
1411:              *
1412:              * Note(s)     : (1) String buffer NOT modified.
1413:              *
1414:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1415:              *
1416:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1417:              *                            ... in the string pointed to by 's' ('pstr')."
1418:              *                       (2) "The terminating null byte is considered to be part of the string."
1419:              *
1420:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1421:              *                       "upon successful completion, strrchr() shall return" :
1422:              *
1423:              *                       (1) "a pointer to the byte" ...
1424:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1425:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1426:              *                               any other reason(s), NULL is also returned for any error(s).
1427:              *
1428:              *               (3) String search terminates when :
1429:              *
1430:              *                   (a) String pointer passed a NULL pointer.
1431:              *                       (1) No string search performed; NULL pointer returned.
1432:              *
1433:              *                   (b) String pointer points to NULL.
1434:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1435:              *
1436:              *                   (c) String searched from end to beginning.
1437:              *                       (1) Search character NOT found in search string; NULL pointer returned.
1438:              *                       (2) Applicable even if search character is the terminating NULL character
1439:              *                           (see Note #2a2).
1440:              *
1441:              *                   (d) Search character found.
1442:              *                       (1) Return pointer to last occurrence of search character in search string
1443:              *                           (see Note #2a1).
1444:              *********************************************************************************************************
1445:              */
1446:              
1447:              CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
1448:                                               CPU_CHAR   srch_char)
1449:              {
1450:                  CPU_CHAR  *pstr_rtn;
1451:              
1452:              
1453:                  pstr_rtn = Str_Char_Last_N(pstr,
003754  784101     MOV.B W1, W2
003756  EB8080     SETM W1
003758  37FFE5     BRA Str_Char_Last_N
1454:                                             DEF_INT_CPU_U_MAX_VAL,
1455:                                             srch_char);
1456:              
1457:                  return (pstr_rtn);
1458:              }
1459:              
1460:              
1461:              /*
1462:              *********************************************************************************************************
1463:              *                                          Str_Char_Last_N()
1464:              *
1465:              * Description : Search string for last occurrence of specific character, up to a maximum number
1466:              *                   of characters.
1467:              *
1468:              * Argument(s) : pstr            Pointer to string (see Note #1).
1469:              *
1470:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1471:              *
1472:              *               srch_char       Search character.
1473:              *
1474:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1475:              *
1476:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1477:              *
1478:              * Caller(s)   : Application.
1479:              *
1480:              * Note(s)     : (1) String buffer NOT modified.
1481:              *
1482:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1483:              *
1484:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1485:              *                            ... in the string pointed to by 's' ('pstr')."
1486:              *                       (2) "The terminating null byte is considered to be part of the string."
1487:              *
1488:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1489:              *                       "upon successful completion, strrchr() shall return" :
1490:              *
1491:              *                       (1) "a pointer to the byte" ...
1492:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1493:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1494:              *                               any other reason(s), NULL is also returned for any error(s).
1495:              *
1496:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1497:              *                       argument list for consistency with all other custom string library functions.
1498:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1499:              *                       to comply with most standard library's strnrchr() argument list.
1500:              *
1501:              *                       See also 'Str_Char_N()  Note #2c'.
1502:              *
1503:              *               (3) String search terminates when :
1504:              *
1505:              *                   (a) String pointer passed a NULL pointer.
1506:              *                       (1) No string search performed; NULL pointer returned.
1507:              *
1508:              *                   (b) String pointer points to NULL.
1509:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1510:              *
1511:              *                   (c) String searched from end to beginning.
1512:              *                       (1) Search character NOT found in search string; NULL pointer returned
1513:              *                           (see Note #2b2).
1514:              *                       (2) Applicable even if search character is the terminating NULL character
1515:              *                           (see Note #2a2).
1516:              *
1517:              *                   (d) Search character found.
1518:              *                       (1) Return pointer to last occurrence of search character in search string
1519:              *                           (see Note #2a1).
1520:              *
1521:              *                   (e) 'len_max' number of characters searched.
1522:              *                       (1) Search character NOT found in search string within last 'len_max' number
1523:              *                           of characters; NULL pointer returned.
1524:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1525:              *                           (see Note #2a2).
1526:              *********************************************************************************************************
1527:              */
1528:              
1529:              CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
1530:                                                 CPU_SIZE_T   len_max,
1531:                                                 CPU_CHAR     srch_char)
1532:              {
003724  BE9F88     MOV.D W8, [W15++]
003726  780400     MOV W0, W8
003728  784482     MOV.B W2, W9
1533:                  const  CPU_CHAR    *pstr_char;
1534:                         CPU_SIZE_T   str_len_max;
1535:                         CPU_SIZE_T   str_len;
1536:              
1537:              
1538:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
00372C  E00008     CP0 W8
00372E  320010     BRA Z, 0x3750
1539:                      return ((CPU_CHAR *)0);
00372A  EB0000     CLR W0
1540:                  }
1541:              
1542:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
003730  E00001     CP0 W1
003732  32000E     BRA Z, 0x3750
1543:                      return ((CPU_CHAR *)0);
1544:                  }
1545:              
1546:              
1547:                  pstr_char    = pstr;
1548:                   str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
003734  E90081     DEC W1, W1
1549:                   str_len     = Str_Len_N(pstr_char, str_len_max);
003736  780008     MOV W8, W0
003738  07FF09     RCALL Str_Len_N
1550:                  pstr_char   += str_len;
00373A  440000     ADD W8, W0, W0
1551:              
1552:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
00373C  320009     BRA Z, 0x3750
00373E  780080     MOV W0, W1
003740  780001     MOV W1, W0
1553:                      return ((CPU_CHAR *)0);
1554:                  }
1555:              
1556:                  while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
003742  508F88     SUB W1, W8, [W15]
003744  320002     BRA Z, 0x374A
003746  14CFA1     SUBR.B W9, [W1--], [W15]
003748  3AFFFB     BRA NZ, 0x3740
1557:                         (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
1558:                      pstr_char--;
1559:                  }
1560:              
1561:              
1562:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
00374A  14CF90     SUBR.B W9, [W0], [W15]
00374C  320001     BRA Z, 0x3750
1563:                       return ((CPU_CHAR *)0);
00374E  EB0000     CLR W0
1564:                  }
1565:              
1566:              
1567:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
1568:              }
003750  BE044F     MOV.D [--W15], W8
003752  060000     RETURN
1569:              
1570:              
1571:              /*
1572:              *********************************************************************************************************
1573:              *                                         Str_Char_Replace()
1574:              *
1575:              * Description : Search string for specific character and replace it by another specific character.
1576:              *
1577:              * Argument(s) : pstr            Pointer to string (see Note #1).
1578:              *
1579:              *               char_srch       Search character.
1580:              *
1581:              *               char_replace    Replace character.
1582:              *
1583:              * Return(s)   : Pointer to string, if NO error(s).
1584:              *
1585:              *               Pointer to NULL,   otherwise.
1586:              *
1587:              * Caller(s)   : Application.
1588:              *
1589:              * Note(s)     : (1) String buffer modified.
1590:              *
1591:              *               (2) String search terminates when :
1592:              *
1593:              *                   (a) String pointer passed a NULL pointer.
1594:              *                       (1) No string search performed; NULL pointer returned.
1595:              *
1596:              *                   (b) String pointer points to NULL.
1597:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1598:              *
1599:              *                   (c) String's terminating NULL character found.
1600:              *                       (1) Search character NOT found in search string; NULL pointer returned
1601:              *                       (2) Applicable even if search character is the terminating NULL character
1602:              *
1603:              *                   (d) Search character found.
1604:              *                       (1) Replace character found by the specified character.
1605:              *********************************************************************************************************
1606:              */
1607:              
1608:              CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
1609:                                           CPU_CHAR   char_srch,
1610:                                           CPU_CHAR   char_replace)
1611:              {
1612:                  CPU_CHAR  *pstr_rtn;
1613:              
1614:              
1615:                  pstr_rtn = Str_Char_Replace_N(pstr,
003782  EB8180     SETM W3
003784  37FFEA     BRA Str_Char_Replace_N
1616:                                                char_srch,
1617:                                                char_replace,
1618:                                                DEF_INT_CPU_U_MAX_VAL);
1619:              
1620:                  return (pstr_rtn);
1621:              }
1622:              
1623:              
1624:              /*
1625:              *********************************************************************************************************
1626:              *                                        Str_Char_Replace_N()
1627:              *
1628:              * Description : Search string for specific character and replace it by another specific character, up to
1629:              *               a maximum number of characters.
1630:              *
1631:              * Argument(s) : pstr            Pointer to string (see Note #1).
1632:              *
1633:              *               char_srch       Search character.
1634:              *
1635:              *               char_replace    Replace character.
1636:              *
1637:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1638:              *
1639:              * Return(s)   : Pointer to string, if NO error(s).
1640:              *
1641:              *               Pointer to NULL,   otherwise.
1642:              *
1643:              * Caller(s)   : Application.
1644:              *
1645:              * Note(s)     : (1) String buffer modified.
1646:              *
1647:              *               (2) String search terminates when :
1648:              *
1649:              *                   (a) String pointer passed a NULL pointer.
1650:              *                       (1) No string search performed; NULL pointer returned.
1651:              *
1652:              *                   (b) String pointer points to NULL.
1653:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1654:              *
1655:              *                   (c) String's terminating NULL character found.
1656:              *                       (1) Search character NOT found in search string; NULL pointer returned
1657:              *                       (2) Applicable even if search character is the terminating NULL character
1658:              *
1659:              *                   (d) Search character found.
1660:              *                       (1) Replace character found by the specified character.
1661:              *
1662:              *                   (e) 'len_max' number of characters searched.
1663:              *                       (1) Search character NOT found in search string within first 'len_max' number
1664:              *                           of characters; NULL pointer returned.
1665:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1666:              *                           (see Note #2a2).
1667:              *********************************************************************************************************
1668:              */
1669:              
1670:              CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
1671:                                             CPU_CHAR     char_srch,
1672:                                             CPU_CHAR     char_replace,
1673:                                             CPU_SIZE_T   len_max)
1674:              {
1675:                  CPU_CHAR    *pstr_char;
1676:                  CPU_SIZE_T   len;
1677:              
1678:              
1679:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
00375A  E00000     CP0 W0
00375C  320011     BRA Z, 0x3780
1680:                      return ((CPU_CHAR *)0);
1681:                  }
1682:              
1683:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
00375E  E00003     CP0 W3
003760  32000E     BRA Z, 0x377E
003762  780200     MOV W0, W4
003764  370006     BRA 0x3772
1684:                      return ((CPU_CHAR *)0);
00377E  EB0000     CLR W0
1685:                  }
1686:              
1687:                  pstr_char = pstr;
1688:                  len       = len_max;
1689:              
1690:                  while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
00376C  E00004     CP0 W4
00376E  320008     BRA Z, 0x3780
003774  E00405     CP0.B W5
003776  320004     BRA Z, 0x3780
1691:                         (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
003772  7842B4     MOV.B [W4++], W5
003778  E00003     CP0 W3
00377A  3AFFF5     BRA NZ, 0x3766
00377C  060000     RETURN
1692:                         ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
1693:              
1694:                      if (*pstr_char == char_srch) {
003766  52CF81     SUB.B W5, W1, [W15]
003768  3A0001     BRA NZ, 0x376C
1695:                          *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
00376A  9FFA72     MOV.B W2, [W4-1]
1696:                      }
1697:              
1698:                      pstr_char++;
1699:                      len--;
003770  E90183     DEC W3, W3
1700:                  }
1701:              
1702:                  return (pstr);
1703:              }
003780  060000     RETURN
1704:              
1705:              
1706:              /*
1707:              *********************************************************************************************************
1708:              *                                              Str_Str()
1709:              *
1710:              * Description : Search string for first occurence of a specific search string.
1711:              *
1712:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1713:              *
1714:              *               pstr_srch       Pointer to search string (see Note #1).
1715:              *
1716:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1717:              *
1718:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1719:              *
1720:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1721:              *
1722:              * Caller(s)   : Application.
1723:              *
1724:              * Note(s)     : (1) String buffers NOT modified.
1725:              *
1726:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1727:              *
1728:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1729:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1730:              *                            pointed to by 's2' ('pstr_srch')" ...
1731:              *                       (2) "(excluding the terminating null byte)."
1732:              *
1733:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1734:              *
1735:              *                       (1) "Upon successful completion, strstr() shall return" :
1736:              *                           (A) "a pointer to the located string" ...
1737:              *                           (B) "or a null pointer if the string is not found."
1738:              *                               (1) #### Although NO strstr() specification states to return NULL for
1739:              *                                   any other reason(s), NULL is also returned for any error(s).
1740:              *
1741:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1742:              *                            shall return 's1' ('pstr')."
1743:              *
1744:              *               (3) String search terminates when :
1745:              *
1746:              *                   (a) String pointer(s) are passed NULL pointers.
1747:              *                       (1) No string search performed; NULL pointer returned.
1748:              *
1749:              *                   (b) String pointer(s) point to NULL.
1750:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1751:              *
1752:              *                   (c) Search string length equal to zero.
1753:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1754:              *
1755:              *                   (d) Search string length greater than string length.
1756:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1757:              *
1758:              *                   (e) Entire string has been searched.
1759:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1760:              *
1761:              *                   (f) Search string found.
1762:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1763:              *********************************************************************************************************
1764:              */
1765:              
1766:              CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
1767:                                  const  CPU_CHAR  *pstr_srch)
1768:              {
1769:                  CPU_CHAR  *pstr_rtn;
1770:              
1771:              
1772:                  pstr_rtn = Str_Str_N(pstr,
0037EE  EB8100     SETM W2
0037F0  37FFCA     BRA Str_Str_N
1773:                                       pstr_srch,
1774:                                       DEF_INT_CPU_U_MAX_VAL);
1775:              
1776:                  return (pstr_rtn);
1777:              }
1778:              
1779:              
1780:              /*
1781:              *********************************************************************************************************
1782:              *                                             Str_Str_N()
1783:              *
1784:              * Description : Search string for first occurence of a specific search string, up to a maximum number
1785:              *                   of characters.
1786:              *
1787:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1788:              *
1789:              *               pstr_srch       Pointer to search string (see Note #1).
1790:              *
1791:              *               len_max         Maximum number of characters to search (see Note #3g).
1792:              *
1793:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1794:              *
1795:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1796:              *
1797:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1798:              *
1799:              * Caller(s)   : Application.
1800:              *
1801:              * Note(s)     : (1) String buffers NOT modified.
1802:              *
1803:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1804:              *
1805:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1806:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1807:              *                            pointed to by 's2' ('pstr_srch')" ...
1808:              *                       (2) "(excluding the terminating null byte)."
1809:              *
1810:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1811:              *
1812:              *                       (1) "Upon successful completion, strstr() shall return" :
1813:              *                           (A) "a pointer to the located string" ...
1814:              *                           (B) "or a null pointer if the string is not found."
1815:              *                               (1) #### Although NO strstr() specification states to return NULL for
1816:              *                                   any other reason(s), NULL is also returned for any error(s).
1817:              *
1818:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1819:              *                            shall return 's1' ('pstr')."
1820:              *
1821:              *               (3) String search terminates when :
1822:              *
1823:              *                   (a) String pointer(s) are passed NULL pointers.
1824:              *                       (1) No string search performed; NULL pointer returned.
1825:              *
1826:              *                   (b) String pointer(s) point to NULL.
1827:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1828:              *
1829:              *                   (c) Search string length equal to zero.
1830:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1831:              *
1832:              *                   (d) Search string length greater than string length.
1833:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1834:              *
1835:              *                   (e) Entire string has been searched.
1836:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1837:              *                       (2) Maximum size of the search is defined as the subtraction of the
1838:              *                           search string length from the string length.
1839:              *
1840:              *                   (f) Search string found.
1841:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1842:              *                       (2) Search string found via Str_Cmp_N().
1843:              *
1844:              *                   (g) 'len_max' number of characters searched.
1845:              *                       (1) 'len_max' number of characters does NOT include terminating NULL character
1846:              *                           (see Note #2a2).
1847:              *********************************************************************************************************
1848:              */
1849:              
1850:              CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
0037CA  44060A     ADD W8, W10, W12
1851:                                    const  CPU_CHAR    *pstr_srch,
1852:                                           CPU_SIZE_T   len_max)
1853:              {
003786  BE9F88     MOV.D W8, [W15++]
003788  BE9F8A     MOV.D W10, [W15++]
00378A  BE9F8C     MOV.D W12, [W15++]
00378C  780400     MOV W0, W8
00378E  780581     MOV W1, W11
003790  780082     MOV W2, W1
1854:                         CPU_SIZE_T    str_len;
1855:                         CPU_SIZE_T    str_len_srch;
1856:                         CPU_SIZE_T    len_max_srch;
1857:                         CPU_SIZE_T    srch_len;
1858:                         CPU_SIZE_T    srch_ix;
1859:                         CPU_BOOLEAN   srch_done;
1860:                         CPU_INT16S    srch_cmp;
1861:                  const  CPU_CHAR     *pstr_str;
1862:                  const  CPU_CHAR     *pstr_srch_ix;
1863:              
1864:                                                                              /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
1865:                  if (pstr == (const CPU_CHAR *)0) {
003792  E00008     CP0 W8
003794  320027     BRA Z, 0x37E4
1866:                      return ((CPU_CHAR *)0);
1867:                  }
1868:                  if (pstr_srch == (const CPU_CHAR *)0) {
003796  E0000B     CP0 W11
003798  320022     BRA Z, 0x37DE
1869:                      return ((CPU_CHAR *)0);
1870:                  }
1871:              
1872:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
00379A  E00001     CP0 W1
00379C  320020     BRA Z, 0x37DE
1873:                      return ((CPU_CHAR *)0);
1874:                  }
1875:              
1876:                                                                              /* Lim max srch str len (to chk > str len).             */
1877:                  len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
1878:                               ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
00379E  408FE1     ADD W1, #0x1, [W15]
0037A0  320002     BRA Z, 0x37A6
0037A2  E80481     INC W1, W9
0037A4  370001     BRA 0x37A8
0037A6  780481     MOV W1, W9
1879:              
1880:                  str_len      = Str_Len_N(pstr,      len_max);
0037A8  780008     MOV W8, W0
0037AA  07FED0     RCALL Str_Len_N
0037AC  780680     MOV W0, W13
1881:                  str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
0037AE  780089     MOV W9, W1
0037B0  78000B     MOV W11, W0
0037B2  07FECC     RCALL Str_Len_N
0037B4  780480     MOV W0, W9
1882:                  if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
0037B6  E00009     CP0 W9
0037B8  320015     BRA Z, 0x37E4
1883:                      return ((CPU_CHAR *)pstr);
1884:                  }
1885:                  if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
0037BA  548F8D     SUB W9, W13, [W15]
0037BC  3E0010     BRA GTU, 0x37DE
1886:                      return ((CPU_CHAR *)0);
1887:                  }
1888:                                                                              /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
1889:                  pstr_str = pstr      + str_len;
0037BE  44000D     ADD W8, W13, W0
1890:                  if (pstr_str == (const CPU_CHAR *)0) {
0037C0  32000E     BRA Z, 0x37DE
1891:                      return ((CPU_CHAR *)0);
1892:                  }
1893:                  pstr_str = pstr_srch + str_len_srch;
0037C2  458009     ADD W11, W9, W0
1894:                  if (pstr_str == (const CPU_CHAR *)0) {
0037C4  32000C     BRA Z, 0x37DE
1895:                      return ((CPU_CHAR *)0);
0037DE  EB0400     CLR W8
0037E0  370001     BRA 0x37E4
1896:                  }
1897:              
1898:              
1899:                  srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
0037C6  568689     SUB W13, W9, W13
1900:                  srch_ix   = 0u;
0037C8  EB0500     CLR W10
1901:                  srch_done = DEF_NO;
1902:              
1903:                  do {
1904:                      pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
0037E2  78040C     MOV W12, W8
1905:                      srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
0037CC  780109     MOV W9, W2
0037CE  78008B     MOV W11, W1
0037D0  78000C     MOV W12, W0
0037D2  07FF0A     RCALL Str_Cmp_N
1906:                      srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
1907:                      srch_ix++;
0037D8  E8050A     INC W10, W10
1908:                  } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
0037D4  E00000     CP0 W0
0037D6  320005     BRA Z, 0x37E2
0037DA  550F8D     SUB W10, W13, [W15]
0037DC  36FFF6     BRA LEU, 0x37CA
1909:              
1910:              
1911:                  if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
1912:                      return ((CPU_CHAR *)0);
1913:                  }
1914:              
1915:                  return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
1916:              }
0037E4  780008     MOV W8, W0
0037E6  BE064F     MOV.D [--W15], W12
0037E8  BE054F     MOV.D [--W15], W10
0037EA  BE044F     MOV.D [--W15], W8
0037EC  060000     RETURN
1917:              
1918:              
1919:              /*
1920:              *********************************************************************************************************
1921:              *                                         Str_FmtNbr_Int32U()
1922:              *
1923:              * Description : Format 32-bit unsigned integer into a multi-digit character string.
1924:              *
1925:              * Argument(s) : nbr             Number           to format.
1926:              *
1927:              *               nbr_dig         Number of digits to format (see Note #1).
1928:              *
1929:              *                               The following may be used to specify the number of digits to format :
1930:              *
1931:              *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
1932:              *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
1933:              *
1934:              *               nbr_base        Base   of number to format (see Note #2).
1935:              *
1936:              *                               The following may be used to specify the number base :
1937:              *
1938:              *                                   DEF_NBR_BASE_BIN            Base  2
1939:              *                                   DEF_NBR_BASE_OCT            Base  8
1940:              *                                   DEF_NBR_BASE_DEC            Base 10
1941:              *                                   DEF_NBR_BASE_HEX            Base 16
1942:              *
1943:              *               lead_char       Prepend leading character  (see Note #3) :
1944:              *
1945:              *                                   '\0'                    Do NOT prepend leading character to string.
1946:              *                                     Printable character          Prepend leading character to string.
1947:              *                                   Unprintable character   Format invalid string (see Note #6).
1948:              *
1949:              *               lower_case      Format alphabetic characters (if any) in lower case :
1950:              *
1951:              *                                   DEF_NO          Format alphabetic characters in upper case.
1952:              *                                   DEF_YES         Format alphabetic characters in lower case.
1953:              *
1954:              *               nul             Append terminating NULL-character (see Note #4) :
1955:              *
1956:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
1957:              *                                   DEF_YES                Append terminating NULL-character to string.
1958:              *
1959:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
1960:              *
1961:              * Return(s)   : Pointer to formatted string, if NO error(s).
1962:              *
1963:              *               Pointer to NULL,             otherwise.
1964:              *
1965:              * Caller(s)   : Application.
1966:              *
1967:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
1968:              *                       is performed except possible NULL-termination of the string (see Note #4).
1969:              *
1970:              *                           Example :
1971:              *
1972:              *                               nbr      = 23456
1973:              *                               nbr_dig  = 0
1974:              *                               nbr_base = 10
1975:              *
1976:              *                               pstr     = ""                   See Note #6a
1977:              *
1978:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
1979:              *                       significant integer digits of the number to format ('nbr'); then an invalid
1980:              *                       string is formatted instead of truncating any significant integer digits.
1981:              *
1982:              *                           Example :
1983:              *
1984:              *                               nbr      = 23456
1985:              *                               nbr_dig  = 3
1986:              *                               nbr_base = 10
1987:              *
1988:              *                               pstr     = "???"                See Note #6b
1989:              *
1990:              *               (2) The number's base MUST be between 2 & 36, inclusive.
1991:              *$PAGE*
1992:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
1993:              *
1994:              *                   (a) (1) Leading character MUST be a printable ASCII character.
1995:              *
1996:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
1997:              *                           (B) with the exception of '0'.
1998:              *
1999:              *                   (b) The number of leading characters is such that the total number of significant
2000:              *                       integer digits plus the number of leading characters is equal to the requested
2001:              *                       number of integer digits to format ('nbr_dig').
2002:              *
2003:              *                           Example :
2004:              *
2005:              *                               nbr       = 23456
2006:              *                               nbr_dig   = 7
2007:              *                               nbr_base  = 10
2008:              *                               lead_char = ' '
2009:              *
2010:              *                               pstr      = "  23456"
2011:              *
2012:              *                   (c) (1) If the value of the number to format is     zero  ...
2013:              *                       (2) ... & the number of digits to format is non-zero, ...
2014:              *                       (3) ... but NO leading character available;           ...
2015:              *                       (4) ... then one digit of '0' value is formatted.
2016:              *
2017:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2018:              *
2019:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2020:              *                       array formatting.
2021:              *
2022:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2023:              *                       terminate option DISABLED will cause character string run-on.
2024:              *
2025:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2026:              *
2027:              *                   (b) To prevent character buffer overrun :
2028:              *
2029:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2030:              *                                                               1 'NUL' terminator)  characters
2031:              *
2032:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2033:              *                   ('?') will be formatted, where the number of question marks is determined by the
2034:              *                   number of digits to format ('nbr_dig') :
2035:              *
2036:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2037:              *                          number of     =  {
2038:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2039:              *
2040:              *********************************************************************************************************
2041:              */
2042:              
2043:              CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
2044:                                            CPU_INT08U    nbr_dig,
2045:                                            CPU_INT08U    nbr_base,
2046:                                            CPU_CHAR      lead_char,
2047:                                            CPU_BOOLEAN   lower_case,
2048:                                            CPU_BOOLEAN   nul,
2049:                                            CPU_CHAR     *pstr)
2050:              {
2051:                  CPU_CHAR  *pstr_fmt;
2052:              
2053:              
2054:                  pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
0037F2  781F87     MOV W7, [W15++]
0037F4  784386     MOV.B W6, W7
0037F6  784305     MOV.B W5, W6
0037F8  784284     MOV.B W4, W5
0037FA  EB4200     CLR.B W4
0037FC  07FDE9     RCALL _Str_FmtNbr_Int32
0037FE  E9878F     DEC2 W15, W15
2055:                                              nbr_dig,
2056:                                              nbr_base,
2057:                                              DEF_NO,
2058:                                              lead_char,
2059:                                              lower_case,
2060:                                              nul,
2061:                                              pstr);
2062:              
2063:                  return (pstr_fmt);
2064:              }
003800  060000     RETURN
2065:              
2066:              
2067:              /*
2068:              *********************************************************************************************************
2069:              *                                         Str_FmtNbr_Int32S()
2070:              *
2071:              * Description : Format 32-bit signed integer into a multi-digit character string.
2072:              *
2073:              * Argument(s) : nbr             Number           to format.
2074:              *
2075:              *               nbr_dig         Number of digits to format (see Note #1).
2076:              *
2077:              *                               The following may be used to specify the number of digits to format :
2078:              *
2079:              *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
2080:              *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
2081:              *                                                                   (plus 1 digit for possible negative sign)
2082:              *
2083:              *               nbr_base        Base   of number to format (see Note #2).
2084:              *
2085:              *                               The following may be used to specify the number base :
2086:              *
2087:              *                                   DEF_NBR_BASE_BIN            Base  2
2088:              *                                   DEF_NBR_BASE_OCT            Base  8
2089:              *                                   DEF_NBR_BASE_DEC            Base 10
2090:              *                                   DEF_NBR_BASE_HEX            Base 16
2091:              *
2092:              *               lead_char       Prepend leading character  (see Note #3) :
2093:              *
2094:              *                                   '\0'                    Do NOT prepend leading character to string.
2095:              *                                     Printable character          Prepend leading character to string.
2096:              *                                   Unprintable character   Format invalid string (see Note #6).
2097:              *
2098:              *               lower_case      Format alphabetic characters (if any) in lower case :
2099:              *
2100:              *                                   DEF_NO          Format alphabetic characters in upper case.
2101:              *                                   DEF_YES         Format alphabetic characters in lower case.
2102:              *
2103:              *               nul             Append terminating NULL-character (see Note #4) :
2104:              *
2105:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2106:              *                                   DEF_YES                Append terminating NULL-character to string.
2107:              *
2108:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2109:              *
2110:              * Return(s)   : Pointer to formatted string, if NO error(s).
2111:              *
2112:              *               Pointer to NULL,             otherwise.
2113:              *
2114:              * Caller(s)   : Application.
2115:              *
2116:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
2117:              *                       is performed except possible NULL-termination of the string (see Note #4).
2118:              *
2119:              *                           Example :
2120:              *
2121:              *                               nbr      = -23456
2122:              *                               nbr_dig  =  0
2123:              *                               nbr_base = 10
2124:              *
2125:              *                               pstr     = ""                   See Note #6a
2126:              *
2127:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
2128:              *                       significant integer digits of the number to format ('nbr'); then an invalid
2129:              *                       string is formatted instead of truncating any significant integer digits.
2130:              *
2131:              *                           Example :
2132:              *
2133:              *                               nbr      = 23456
2134:              *                               nbr_dig  = 3
2135:              *                               nbr_base = 10
2136:              *
2137:              *                               pstr     = "???"                See Note #6b
2138:              *
2139:              *                   (c) If the number to format ('nbr') is negative but the number of digits to format
2140:              *                       ('nbr_dig') is equal to the number of significant integer digits of the number
2141:              *                       to format ('nbr'); then an invalid string is formatted instead of truncating
2142:              *                       the negative sign.
2143:              *
2144:              *                           Example :
2145:              *
2146:              *                               nbr      = -23456
2147:              *                               nbr_dig  =  5
2148:              *                               nbr_base = 10
2149:              *
2150:              *                               pstr     = "?????"              See Note #6b
2151:              *
2152:              *               (2) The number's base MUST be between 2 & 36, inclusive.
2153:              *$PAGE*
2154:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2155:              *
2156:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2157:              *
2158:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
2159:              *                           (B) with the exception of '0'.
2160:              *
2161:              *                   (b) (1) The number of leading characters is such that the total number of significant
2162:              *                           integer digits plus the number of leading characters plus possible negative
2163:              *                           sign character is equal to the requested number of integer digits to format
2164:              *                           ('nbr_dig').
2165:              *
2166:              *                               Examples :
2167:              *
2168:              *                                   nbr       = 23456
2169:              *                                   nbr_dig   = 7
2170:              *                                   nbr_base  = 10
2171:              *                                   lead_char = ' '
2172:              *
2173:              *                                   pstr      = "  23456"
2174:              *
2175:              *
2176:              *                                   nbr       = -23456
2177:              *                                   nbr_dig   =  7
2178:              *                                   nbr_base  = 10
2179:              *                                   lead_char = ' '
2180:              *
2181:              *                                   pstr      = " -23456"
2182:              *
2183:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2184:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2185:              *                               prefixes all leading characters prior to the formatted number.
2186:              *
2187:              *                                   Examples :
2188:              *
2189:              *                                       nbr        = -23456
2190:              *                                       nbr_dig    =  8
2191:              *                                       nbr_base   = 10
2192:              *                                       lead_char  = '0'
2193:              *
2194:              *                                       pstr       = "-0023456"
2195:              *
2196:              *
2197:              *                                       nbr        = -43981
2198:              *                                       nbr_dig    =  8
2199:              *                                       nbr_base   = 16
2200:              *                                       lead_char  = '0'
2201:              *                                       lower_case = DEF_NO
2202:              *
2203:              *                                       pstr       = "-000ABCD"
2204:              *
2205:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2206:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2207:              *                               immediately prefixes the most significant digit of the formatted number.
2208:              *
2209:              *                                   Examples :
2210:              *
2211:              *                                       nbr        = -23456
2212:              *                                       nbr_dig    =  8
2213:              *                                       nbr_base   = 10
2214:              *                                       lead_char  = '#'
2215:              *
2216:              *                                       pstr       = "##-23456"
2217:              *
2218:              *
2219:              *                                       nbr        = -43981
2220:              *                                       nbr_dig    =  8
2221:              *                                       nbr_base   = 16
2222:              *                                       lead_char  = '#'
2223:              *                                       lower_case = DEF_YES
2224:              *
2225:              *                                       pstr       = "###-abcd"
2226:              *
2227:              *                   (c) (1) If the value of the number to format is     zero  ...
2228:              *                       (2) ... & the number of digits to format is non-zero, ...
2229:              *                       (3) ... but NO leading character available;           ...
2230:              *                       (4) ... then one digit of '0' value is formatted.
2231:              *
2232:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2233:              *$PAGE*
2234:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2235:              *                       array formatting.
2236:              *
2237:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2238:              *                       terminate option DISABLED will cause character string run-on.
2239:              *
2240:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2241:              *
2242:              *                   (b) To prevent character buffer overrun :
2243:              *
2244:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2245:              *                                                               1 negative sign   +
2246:              *                                                               1 'NUL' terminator)  characters
2247:              *
2248:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2249:              *                   ('?') will be formatted, where the number of question marks is determined by the
2250:              *                   number of digits to format ('nbr_dig') :
2251:              *
2252:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2253:              *                          number of     =  {
2254:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2255:              *
2256:              *********************************************************************************************************
2257:              */
2258:              
2259:              CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
2260:                                            CPU_INT08U    nbr_dig,
2261:                                            CPU_INT08U    nbr_base,
2262:                                            CPU_CHAR      lead_char,
2263:                                            CPU_BOOLEAN   lower_case,
2264:                                            CPU_BOOLEAN   nul,
2265:                                            CPU_CHAR     *pstr)
2266:              {
003802  781F88     MOV W8, [W15++]
003804  784404     MOV.B W4, W8
2267:                  CPU_CHAR     *pstr_fmt;
2268:                  CPU_INT32S    nbr_fmt;
2269:                  CPU_BOOLEAN   nbr_neg;
2270:              
2271:              
2272:                  if (nbr < 0) {                                              /* If nbr neg, ...                                      */
003808  500FE0     SUB W0, #0x0, [W15]
00380A  588FE0     SUBB W1, #0x0, [W15]
00380C  3D0003     BRA GE, 0x3814
2273:                      nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
00380E  100060     SUBR W0, #0x0, W0
003810  1880E0     SUBBR W1, #0x0, W1
2274:                      nbr_neg =  DEF_YES;
003812  B3C014     MOV.B #0x1, W4
2275:                  } else {
2276:                      nbr_fmt =  nbr;
2277:                      nbr_neg =  DEF_NO;
003806  EB4200     CLR.B W4
2278:                  }
2279:              
2280:                  pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
003814  781F87     MOV W7, [W15++]
003816  784386     MOV.B W6, W7
003818  784305     MOV.B W5, W6
00381A  784288     MOV.B W8, W5
00381C  07FDD9     RCALL _Str_FmtNbr_Int32
00381E  E9878F     DEC2 W15, W15
2281:                                                          nbr_dig,
2282:                                                          nbr_base,
2283:                                                          nbr_neg,
2284:                                                          lead_char,
2285:                                                          lower_case,
2286:                                                          nul,
2287:                                                          pstr);
2288:              
2289:                  return (pstr_fmt);
2290:              }
003820  78044F     MOV [--W15], W8
003822  060000     RETURN
2291:              
2292:              
2293:              /*
2294:              *********************************************************************************************************
2295:              *                                           Str_FmtNbr_32()
2296:              *
2297:              * Description : Format number into a multi-digit character string.
2298:              *
2299:              * Argument(s) : nbr             Number                         to format (see Note #1).
2300:              *
2301:              *               nbr_dig         Number of decimal       digits to format (see Note #2).
2302:              *
2303:              *               nbr_dp          Number of decimal point digits to format.
2304:              *
2305:              *               lead_char       Prepend leading character (see Note #3) :
2306:              *
2307:              *                                   '\0'                    Do NOT prepend leading character to string.
2308:              *                                     Printable character          Prepend leading character to string.
2309:              *                                   Unprintable character   Format invalid string (see Note #6d).
2310:              *
2311:              *               nul             Append terminating NULL-character (see Note #4) :
2312:              *
2313:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2314:              *                                   DEF_YES                Append terminating NULL-character to string.
2315:              *
2316:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2317:              *
2318:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
2319:              *
2320:              *               Pointer to NULL,             otherwise.
2321:              *
2322:              * Caller(s)   : Application.
2323:              *
2324:              * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
2325:              *
2326:              *
2327:              *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
2328:              *                           32-bit Floating-point Number  =  -----------------------------------------------------
2329:              *                                                                             log [External-Base]
2330:              *
2331:              *                                                             log [2 ^ 24]
2332:              *                                                         =  --------------
2333:              *                                                               log [10]
2334:              *
2335:              *                                                         <  7.225  Base-10 Digits
2336:              *
2337:              *                               where
2338:              *                                       Internal-Base                   Internal number base of floating-
2339:              *                                                                           point numbers (i.e.  2)
2340:              *                                       External-Base                   External number base of floating-
2341:              *                                                                           point numbers (i.e. 10)
2342:              *                                       Number-Internal-Base-Digits     Number of internal number base
2343:              *                                                                           significant digits (i.e. 24)
2344:              *
2345:              *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
2346:              *                       maximum accuracy.
2347:              *$PAGE*
2348:              *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
2349:              *                       formatting is performed except possible NULL-termination of the string (see Note #4).
2350:              *
2351:              *                           Example :
2352:              *
2353:              *                               nbr     = -23456.789
2354:              *                               nbr_dig =  0
2355:              *                               nbr_dp  =  0
2356:              *
2357:              *                               pstr    = ""                        See Note #7a
2358:              *
2359:              *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
2360:              *                           significant integer digits of the number to format ('nbr'); then an invalid
2361:              *                           string is formatted instead of truncating any significant integer digits.
2362:              *
2363:              *                               Example :
2364:              *
2365:              *                                   nbr     = 23456.789
2366:              *                                   nbr_dig = 3
2367:              *                                   nbr_dp  = 2
2368:              *
2369:              *                                   pstr    = "??????"              See Note #7d
2370:              *
2371:              *                       (2) If the number to format ('nbr') is negative but the number of digits to format
2372:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
2373:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
2374:              *                           the negative sign.
2375:              *
2376:              *                               Example :
2377:              *
2378:              *                                   nbr     = -23456.789
2379:              *                                   nbr_dig =  5
2380:              *                                   nbr_dp  =  2
2381:              *
2382:              *                                   pstr    = "????????"            See Note #7d
2383:              *
2384:              *                       (3) If the number to format ('nbr') is negative but the number of significant
2385:              *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one
2386:              *                           but the number of decimal point digits to format ('nbr_dp') is zero; then
2387:              *                           an invalid string is formatted instead of truncating the negative sign.
2388:              *
2389:              *                               Example :
2390:              *
2391:              *                                   nbr     = -0.7895
2392:              *                                   nbr_dig =  1
2393:              *                                   nbr_dp  =  0
2394:              *
2395:              *                                   pstr    = "?"                   See Note #7d
2396:              *
2397:              *                       (4) (A) If the number to format ('nbr') is negative but the number of significant
2398:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2399:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2400:              *                               zero; then the negative sign immediately prefixes the decimal point --
2401:              *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
2402:              *
2403:              *                                   Example :
2404:              *
2405:              *                                       nbr     = -0.7895
2406:              *                                       nbr_dig =  0
2407:              *                                       nbr_dp  =  2
2408:              *
2409:              *                                       pstr    = "-.78"
2410:              *
2411:              *                           (B) If the number to format ('nbr') is positive but the number of significant
2412:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2413:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2414:              *                               zero; then a single decimal digit of '0' prefixes the decimal point.
2415:              *
2416:              *                               This '0' digit is used whenever a negative sign is not formatted (see
2417:              *                               Note #2b4A) so that the formatted string's decimal point is not floating,
2418:              *                               but fixed in the string as the 2nd character.
2419:              *
2420:              *                                   Example :
2421:              *
2422:              *                                       nbr     =  0.7895
2423:              *                                       nbr_dig =  0
2424:              *                                       nbr_dp  =  2
2425:              *
2426:              *                                       pstr    = "0.78"
2427:              *$PAGE*
2428:              *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
2429:              *
2430:              *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point
2431:              *                               numbers, digits following all significantly-accurate digits of the number to
2432:              *                               format ('nbr') will be inaccurate; ...
2433:              *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all
2434:              *                               digits or decimal places following all significantly-accurate digits of the
2435:              *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
2436:              *
2437:              *                                   Example :
2438:              *
2439:              *                                       nbr                            = 123456789.012345
2440:              *                                       nbr_dig                        = 9
2441:              *                                       nbr_dp                         = 6
2442:              *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
2443:              *
2444:              *                                       pstr                           = "123456700.000000"
2445:              *
2446:              *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr')
2447:              *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
2448:              *                           &/or compiler's floating-point implementation.
2449:              *
2450:              *                       See also Note #1.
2451:              *
2452:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2453:              *
2454:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2455:              *
2456:              *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
2457:              *                           (B) with the exception of '0'.
2458:              *
2459:              *                   (b) (1) The number of leading characters is such that the total number of significant
2460:              *                           integer digits plus the number of leading characters plus possible negative
2461:              *                           sign character is equal to the requested number of integer digits to format
2462:              *                           ('nbr_dig').
2463:              *
2464:              *                               Examples :
2465:              *
2466:              *                                   nbr       = 23456.789
2467:              *                                   nbr_dig   = 7
2468:              *                                   nbr_dp    = 2
2469:              *                                   lead_char = ' '
2470:              *
2471:              *                                   pstr      = "  23456.78"
2472:              *
2473:              *
2474:              *                                   nbr       = -23456.789
2475:              *                                   nbr_dig   =  7
2476:              *                                   nbr_dp    =  2
2477:              *                                   lead_char = ' '
2478:              *
2479:              *                                   pstr      = " -23456.78"
2480:              *
2481:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2482:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2483:              *                               prefixes all leading characters prior to the formatted number.
2484:              *
2485:              *                                   Example :
2486:              *
2487:              *                                       nbr       = -23456.789
2488:              *                                       nbr_dig   =  8
2489:              *                                       nbr_dp    =  2
2490:              *                                       lead_char = '0'
2491:              *
2492:              *                                       pstr      = "-0023456.78"
2493:              *
2494:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2495:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2496:              *                               immediately prefixes the most significant digit of the formatted number.
2497:              *
2498:              *                                   Examples :
2499:              *
2500:              *                                       nbr       = -23456.789
2501:              *                                       nbr_dig   =  8
2502:              *                                       nbr_dp    =  2
2503:              *                                       lead_char = '#'
2504:              *
2505:              *                                       pstr      = "##-23456.78"
2506:              *
2507:              *                   (c) (1) If the integer value of the number to format is zero & ...
2508:              *                       (2) ... the number of digits to format is greater than one ...
2509:              *                       (3) ... OR  the number is NOT negative,                    ...
2510:              *                       (4) ... but NO leading character available;                ...
2511:              *                       (5) ... then one digit of '0' value is formatted.
2512:              *
2513:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2514:              *
2515:              *                       See also Note #2b4B.
2516:              *$PAGE*
2517:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2518:              *                       array formatting.
2519:              *
2520:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2521:              *                       terminate option DISABLED will cause character string run-on.
2522:              *
2523:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2524:              *
2525:              *                   (b) To prevent character buffer overrun :
2526:              *
2527:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2528:              *                                                              'nbr_dp'           +
2529:              *                                                               1 negative sign   +
2530:              *                                                               1 decimal point   +
2531:              *                                                               1 'NUL' terminator)  characters
2532:              *
2533:              *               (6) String format terminates when :
2534:              *
2535:              *                   (a) Format string pointer is passed a NULL pointer.
2536:              *                       (1) No      string formatted;                NULL pointer returned.
2537:              *
2538:              *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
2539:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
2540:              *
2541:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
2542:              *                           integer digits of the number to format ('nbr'), including possible
2543:              *                           negative sign.
2544:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2545:              *
2546:              *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
2547:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2548:              *
2549:              *                   (e) Number successfully formatted into character string array.
2550:              *
2551:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
2552:              *                   ('?') will be formatted, where the number of question marks is determined by the
2553:              *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
2554:              *
2555:              *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
2556:              *                                           {                                        'nbr_dp'  = 0
2557:              *                                           {
2558:              *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
2559:              *                                           {                                        'nbr_dp'  = 0
2560:              *                      Invalid string's     {
2561:              *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
2562:              *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
2563:              *                                           {         1 (for negative sign) ]
2564:              *                                           {
2565:              *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
2566:              *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
2567:              *                                           {         1 (for decimal point) ]
2568:              *
2569:              *********************************************************************************************************
2570:              */
2571:              
2572:              #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
2573:              CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
2574:                                        CPU_INT08U    nbr_dig,
2575:                                        CPU_INT08U    nbr_dp,
2576:                                        CPU_CHAR      lead_char,
2577:                                        CPU_BOOLEAN   nul,
2578:                                        CPU_CHAR     *pstr)
2579:              {
2580:                  CPU_CHAR     *pstr_fmt;
2581:                  CPU_DATA      i;
2582:                  CPU_FP32      nbr_fmt;
2583:                  CPU_FP32      nbr_log;
2584:                  CPU_INT32U    nbr_shiftd;
2585:                  CPU_INT16U    nbr_dig_max;
2586:                  CPU_INT16U    nbr_dig_sig;
2587:                  CPU_INT08U    nbr_neg_sign;
2588:                  CPU_INT08U    dig_val;
2589:                  CPU_FP32      dig_exp;
2590:                  CPU_FP32      dp_exp;
2591:                  CPU_BOOLEAN   lead_char_dig;
2592:                  CPU_BOOLEAN   lead_char_fmtd;
2593:                  CPU_BOOLEAN   lead_char_0;
2594:                  CPU_BOOLEAN   fmt_invalid;
2595:                  CPU_BOOLEAN   print_char;
2596:                  CPU_BOOLEAN   nbr_neg;
2597:                  CPU_BOOLEAN   nbr_neg_fmtd;
2598:              
2599:              
2600:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
2601:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
2602:                      return ((CPU_CHAR *)0);
2603:                  }
2604:              
2605:                  dig_exp     =  1.0f;
2606:                  fmt_invalid =  DEF_NO;
2607:                  lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;        /* Chk if lead char a '0' dig (see Note #3b2).          */
2608:                  nbr_fmt     =  0.0f;
2609:                  nbr_neg     =  DEF_NO;
2610:              
2611:                  if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
2612:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
2613:                  }
2614:              
2615:                  if (lead_char != (CPU_CHAR)'\0') {
2616:                      print_char =  ASCII_IsPrint(lead_char);
2617:                      if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
2618:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
2619:              
2620:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
2621:                          lead_char_dig = ASCII_IsDig(lead_char);
2622:                          if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
2623:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
2624:                          }
2625:                      }
2626:                  }
2627:              
2628:              
2629:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
2630:                  pstr_fmt = pstr;
2631:              
2632:                  if (fmt_invalid == DEF_NO) {
2633:                      if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
2634:                          nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
2635:                          nbr_neg_sign =  1u;
2636:                          nbr_neg      =  DEF_YES;
2637:                      } else {
2638:                          nbr_fmt      =  nbr;
2639:                          nbr_neg_sign =  0u;
2640:                          nbr_neg      =  DEF_NO;
2641:                      }
2642:              
2643:                      nbr_log     = nbr_fmt;
2644:                      nbr_dig_max = 0u;
2645:                      while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
2646:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
2647:                          nbr_log /= 10.0f;
2648:                      }
2649:              
2650:                      if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
2651:                           (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
2652:                          ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
2653:                           (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
2654:                           (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
2655:                                                                              /* .. prepare nbr digs to fmt.                          */
2656:                          for (i = 1u; i < nbr_dig; i++) {
2657:                              dig_exp *= 10.0f;
2658:                          }
2659:              
2660:                          nbr_neg_fmtd   =  DEF_NO;
2661:                          nbr_dig_sig    =  0u;
2662:                          lead_char_fmtd =  DEF_NO;
2663:                      } else {                                                /* Else if nbr trunc'd, ...                             */
2664:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
2665:                      }
2666:                  }
2667:              
2668:              
2669:                                                                              /* ------------------- FMT NBR STR -------------------- */
2670:                  for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
2671:                      if (fmt_invalid == DEF_NO) {
2672:                          if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
2673:                              nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
2674:                              if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
2675:                                  (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
2676:                                                                              /* ... calc & fmt dig val;                     ...      */
2677:                                  if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
2678:                                      (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
2679:              
2680:                                      if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
2681:                                          pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
2682:                                      }
2683:                                     *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
2684:                                      nbr_neg_fmtd = DEF_YES;
2685:                                  }
2686:              
2687:                                  if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
2688:                                      dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
2689:                                     *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
2690:              
2691:                                      nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
2692:              
2693:                                  } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
2694:                                             (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
2695:                                     *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
2696:                                  }
2697:              
2698:                              } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
2699:                                         (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
2700:                                         (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
2701:              
2702:                                 *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
2703:                                  nbr_neg_fmtd = DEF_YES;
2704:              
2705:                              } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
2706:                                 *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
2707:                                  lead_char_fmtd = DEF_YES;
2708:                              }
2709:              
2710:                              dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
2711:              
2712:                          } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
2713:                             *pstr_fmt++ = '0';
2714:                          }
2715:              
2716:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2717:                         *pstr_fmt++ = '?';
2718:                      }
2719:                  }
2720:              
2721:              
2722:                  if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
2723:                      if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
2724:                          if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
2725:                              if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
2726:                                  (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
2727:                                  *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
2728:                              } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
2729:                                  *pstr_fmt++ = '0';
2730:                              }
2731:                          } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
2732:                              *pstr_fmt++ = '?';
2733:                          }
2734:                      }
2735:              
2736:                      if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
2737:                         *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
2738:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2739:                         *pstr_fmt++ = '?';
2740:                      }
2741:              
2742:                      dp_exp = 10.0f;
2743:                      for (i = 0u; i < nbr_dp; i++) {
2744:                          if (fmt_invalid == DEF_NO) {
2745:                                                                              /* If nbr sig digs < max, fmt str dps;    ...           */
2746:                              if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
2747:                                  nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
2748:                                  dig_val     = (CPU_INT08U)(nbr_shiftd % 10u);
2749:                                 *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
2750:                                  dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
2751:              
2752:                                  if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
2753:                                      (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
2754:                                       nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
2755:                                  }
2756:              
2757:                              } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
2758:                                 *pstr_fmt++ = '0';
2759:                              }
2760:              
2761:                          } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
2762:                             *pstr_fmt++ = '?';
2763:                          }
2764:                      }
2765:                  }
2766:              
2767:              
2768:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
2769:                     *pstr_fmt = (CPU_CHAR)'\0';
2770:                  }
2771:              
2772:              
2773:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
2774:                      return ((CPU_CHAR *)0);
2775:                  }
2776:              
2777:              
2778:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
2779:              }
2780:              #endif
2781:              
2782:              
2783:              /*
2784:              *********************************************************************************************************
2785:              *                                        Str_ParseNbr_Int32U()
2786:              *
2787:              * Description : Parse 32-bit unsigned integer from string.
2788:              *
2789:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
2790:              *
2791:              *               pstr_next   Optional pointer to a variable to ... :
2792:              *
2793:              *                               (a) Return a pointer to first character following the integer string,
2794:              *                                       if NO error(s) [see Note #2a2B2];
2795:              *                               (b) Return a pointer to 'pstr',
2796:              *                                       otherwise      (see Note #2a2A2).
2797:              *
2798:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
2799:              *
2800:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
2801:              *
2802:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
2803:              *
2804:              *               0,                   otherwise                            (see Note #2a3B).
2805:              *
2806:              * Caller(s)   : Application.
2807:              *
2808:              * Note(s)     : (1) String buffer NOT modified.
2809:              *
2810:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
2811:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
2812:              *                       to a type unsigned long ... representation" :
2813:              *
2814:              *                       (1) "First, they decompose the input string into three parts" :
2815:              *
2816:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
2817:              *                                by isspace()]."
2818:              *
2819:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
2820:              *                                    input string, starting with the first non-white-space character that is of
2821:              *                                    the expected form.  The subject sequence shall contain no characters if the
2822:              *                                    input string is empty or consists entirely of white-space characters."
2823:              *
2824:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
2825:              *                                    determined by the value of 'base' ('nbr_base')" :
2826:              *
2827:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
2828:              *                                        subject sequence is that of a decimal constant, octal constant, or
2829:              *                                        hexadecimal constant" :
2830:              *
2831:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
2832:              *                                            sequence of decimal digits."
2833:              *
2834:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
2835:              *                                            a sequence of the digits '0' to '7' only."
2836:              *
2837:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
2838:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
2839:              *                                            (or 'F') with values 10 to 15 respectively."
2840:              *
2841:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
2842:              *                                        of the subject sequence is a sequence of letters and digits representing
2843:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
2844:              *
2845:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
2846:              *                                                ascribed the values 10 to 35"; ...
2847:              *                                           (B) "only letters whose ascribed values are less than that of base
2848:              *                                                are permitted."
2849:              *
2850:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
2851:              *                                                '0X' may optionally precede the sequence of letters and digits."
2852:              *
2853:              *                                           (B) Although NO specification states that "if the value of 'base'
2854:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
2855:              *                                               the sequence of letters and digits"; it seems reasonable to
2856:              *                                               allow the '0' character to be optionally parsed.
2857:              *
2858:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
2859:              *
2860:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
2861:              *                                       integer string into an unsigned integer.
2862:              *
2863:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
2864:              *                                   (b) "including the terminating null byte of the input string" ...
2865:              *                               (2) "other than a sign or a permissible letter or digit."
2866:              *$PAGE*
2867:              *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
2868:              *
2869:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
2870:              *
2871:              *                               (1) "no conversion [is] performed"; ...
2872:              *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr'
2873:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
2874:              *
2875:              *                           (B) "If the subject sequence has the expected form" :
2876:              *
2877:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
2878:              *                                        starting with the first digit shall be interpreted as an integer constant."
2879:              *
2880:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
2881:              *                                        used as the base for conversion, ascribing to each letter its value as
2882:              *                                        given above" (see Note #2a1B1b1A).
2883:              *
2884:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
2885:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
2886:              *                                   pointer."
2887:              *
2888:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
2889:              *
2890:              *                           (A) "Upon successful completion, these functions shall return the converted value."
2891:              *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
2892:              *                                    ... shall be returned."
2893:              *
2894:              *                           (B) "If no conversion could be performed, 0 shall be returned."
2895:              *
2896:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2897:              *                           shall fail if" :
2898:              *
2899:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
2900:              *
2901:              *                           (B) "[ERANGE] - The value to be returned is not representable."
2902:              *
2903:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2904:              *                           may fail if" :
2905:              *
2906:              *                           (A) "[EINVAL] - No conversion could be performed."
2907:              *
2908:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
2909:              *
2910:              *                   (a) Valid parse string integer :
2911:              *
2912:              *                           pstr      = "     ABCDE xyz"
2913:              *                           nbr_base  = 16
2914:              *
2915:              *                           nbr       = 703710
2916:              *                           pstr_next = " xyz"
2917:              *
2918:              *
2919:              *                   (b) Invalid parse string integer :
2920:              *
2921:              *                           pstr      = "     ABCDE"
2922:              *                           nbr_base  = 10
2923:              *
2924:              *                           nbr       =  0
2925:              *                           pstr_next = pstr = "     ABCDE"
2926:              *
2927:              *
2928:              *                   (c) Valid hexadecimal parse string integer :
2929:              *
2930:              *                           pstr      = "     0xGABCDE"
2931:              *                           nbr_base  = 16
2932:              *
2933:              *                           nbr       =  0
2934:              *                           pstr_next = "xGABCDE"
2935:              *
2936:              *
2937:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
2938:              *                               following invalid hexadecimal characters) :
2939:              *
2940:              *                           pstr      = "     0xGABCDE"
2941:              *                           nbr_base  =  0
2942:              *
2943:              *                           nbr       =  0
2944:              *                           pstr_next = "xGABCDE"
2945:              *
2946:              *
2947:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
2948:              *                               following invalid octal       characters) :
2949:              *
2950:              *                           pstr      = "     0GABCDE"
2951:              *                           nbr_base  =  0
2952:              *
2953:              *                           nbr       =  0
2954:              *                           pstr_next = "GABCDE"
2955:              *
2956:              *$PAGE*
2957:              *                   (f) Parse string integer overflow :
2958:              *
2959:              *                           pstr      = "   12345678901234567890*123456"
2960:              *                           nbr_base  = 10
2961:              *
2962:              *                           nbr       = DEF_INT_32U_MAX_VAL
2963:              *                           pstr_next = "*123456"
2964:              *
2965:              *
2966:              *                   (g) Invalid negative unsigned parse string :
2967:              *
2968:              *                           pstr      = "  -12345678901234567890*123456"
2969:              *                           nbr_base  = 10
2970:              *
2971:              *                           nbr       = 0
2972:              *                           pstr_next = pstr = "  -12345678901234567890*123456"
2973:              *
2974:              *********************************************************************************************************
2975:              */
2976:              
2977:              CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
2978:                                                      CPU_CHAR    **pstr_next,
2979:                                                      CPU_INT08U    nbr_base)
2980:              {
2981:                  CPU_INT32U  nbr;
2982:              
2983:              
2984:                  nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
003824  EB0200     CLR W4
003826  EB4180     CLR.B W3
003828  37FD18     BRA _Str_ParseNbr_Int32
2985:                                                          pstr_next,
2986:                                                          nbr_base,
2987:                                                          DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
2988:                                           (CPU_BOOLEAN *)0);
2989:              
2990:                  return (nbr);
2991:              }
2992:              
2993:              
2994:              /*
2995:              *********************************************************************************************************
2996:              *                                        Str_ParseNbr_Int32S()
2997:              *
2998:              * Description : Parse 32-bit signed integer from string.
2999:              *
3000:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
3001:              *
3002:              *               pstr_next   Optional pointer to a variable to ... :
3003:              *
3004:              *                               (a) Return a pointer to first character following the integer string,
3005:              *                                       if NO error(s) [see Note #2a2B2];
3006:              *                               (b) Return a pointer to 'pstr',
3007:              *                                       otherwise      (see Note #2a2A2).
3008:              *
3009:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
3010:              *
3011:              * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
3012:              *
3013:              *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
3014:              *
3015:              *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
3016:              *
3017:              *               0,                   otherwise                                    (see Note #2a3B).
3018:              *
3019:              * Caller(s)   : Application.
3020:              *
3021:              * Note(s)     : (1) String buffer NOT modified.
3022:              *
3023:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3024:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3025:              *                       to a type long ... representation" :
3026:              *
3027:              *                       (1) "First, they decompose the input string into three parts" :
3028:              *
3029:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3030:              *                                by isspace()]."
3031:              *
3032:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3033:              *                                    input string, starting with the first non-white-space character that is of
3034:              *                                    the expected form.  The subject sequence shall contain no characters if the
3035:              *                                    input string is empty or consists entirely of white-space characters."
3036:              *
3037:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3038:              *                                    determined by the value of 'base' ('nbr_base')" :
3039:              *
3040:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3041:              *                                        subject sequence is that of a decimal constant, octal constant, or
3042:              *                                        hexadecimal constant" :
3043:              *
3044:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3045:              *                                            sequence of decimal digits."
3046:              *
3047:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3048:              *                                            a sequence of the digits '0' to '7' only."
3049:              *
3050:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3051:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3052:              *                                            (or 'F') with values 10 to 15 respectively."
3053:              *
3054:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3055:              *                                        of the subject sequence is a sequence of letters and digits representing
3056:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3057:              *
3058:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3059:              *                                                ascribed the values 10 to 35"; ...
3060:              *                                           (B) "only letters whose ascribed values are less than that of base
3061:              *                                                are permitted."
3062:              *
3063:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3064:              *                                                '0X' may optionally precede the sequence of letters and digits."
3065:              *
3066:              *                                           (B) Although NO specification states that "if the value of 'base'
3067:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3068:              *                                               the sequence of letters and digits"; it seems reasonable to
3069:              *                                               allow the '0' character to be optionally parsed.
3070:              *
3071:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3072:              *
3073:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
3074:              *                                       integer string into an unsigned integer.
3075:              *
3076:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3077:              *                                   (b) "including the terminating null byte of the input string" ...
3078:              *                               (2) "other than a sign or a permissible letter or digit."
3079:              *$PAGE*
3080:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3081:              *
3082:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3083:              *
3084:              *                               (1) "no conversion is performed"; ...
3085:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3086:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3087:              *
3088:              *                           (B) "If the subject sequence has the expected form" :
3089:              *
3090:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3091:              *                                        starting with the first digit shall be interpreted as an integer constant."
3092:              *
3093:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3094:              *                                        used as the base for conversion, ascribing to each letter its value as
3095:              *                                        given above" (see Note #2a1B1b1A).
3096:              *
3097:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3098:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3099:              *                                   pointer."
3100:              *
3101:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3102:              *
3103:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3104:              *
3105:              *                               (1) "If the correct value is outside the range of representable values", either
3106:              *                                    of the following "shall be returned" :
3107:              *                                   (a) "{LONG_MIN}" or ...
3108:              *                                   (b) "{LONG_MAX}"
3109:              *
3110:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3111:              *
3112:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3113:              *                           shall fail if" :
3114:              *
3115:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3116:              *
3117:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3118:              *
3119:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3120:              *                           may fail if" :
3121:              *
3122:              *                           (A) "[EINVAL] - No conversion could be performed."
3123:              *
3124:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3125:              *
3126:              *                   (a) Valid parse string integer :
3127:              *
3128:              *                           pstr      = "     ABCDE xyz"
3129:              *                           nbr_base  = 16
3130:              *
3131:              *                           nbr       = 703710
3132:              *                           pstr_next = " xyz"
3133:              *
3134:              *
3135:              *                   (b) Invalid parse string integer :
3136:              *
3137:              *                           pstr      = "     ABCDE"
3138:              *                           nbr_base  = 10
3139:              *
3140:              *                           nbr       =  0
3141:              *                           pstr_next = pstr = "     ABCDE"
3142:              *
3143:              *
3144:              *                   (c) Valid hexadecimal parse string integer :
3145:              *
3146:              *                           pstr      = "     0xGABCDE"
3147:              *                           nbr_base  = 16
3148:              *
3149:              *                           nbr       =  0
3150:              *                           pstr_next = "xGABCDE"
3151:              *
3152:              *
3153:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3154:              *                               following invalid hexadecimal characters) :
3155:              *
3156:              *                           pstr      = "     0xGABCDE"
3157:              *                           nbr_base  =  0
3158:              *
3159:              *                           nbr       =  0
3160:              *                           pstr_next = "xGABCDE"
3161:              *
3162:              *
3163:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3164:              *                               following invalid octal       characters) :
3165:              *
3166:              *                           pstr      = "     0GABCDE"
3167:              *                           nbr_base  =  0
3168:              *
3169:              *                           nbr       =  0
3170:              *                           pstr_next = "GABCDE"
3171:              *
3172:              *$PAGE*
3173:              *                   (f) Parse string integer overflow :
3174:              *
3175:              *                           pstr      = "   12345678901234567890*123456"
3176:              *                           nbr_base  = 10
3177:              *
3178:              *                           nbr       = DEF_INT_32S_MAX_VAL
3179:              *                           pstr_next = "*123456"
3180:              *
3181:              *
3182:              *                   (g) Parse string integer underflow :
3183:              *
3184:              *                           pstr      = "  -12345678901234567890*123456"
3185:              *                           nbr_base  = 10
3186:              *
3187:              *                           nbr       = DEF_INT_32S_MIN_VAL
3188:              *                           pstr_next = "*123456"
3189:              *
3190:              *********************************************************************************************************
3191:              */
3192:              
3193:              CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
3194:                                                      CPU_CHAR    **pstr_next,
3195:                                                      CPU_INT08U    nbr_base)
3196:              {
00382A  FA0002     LNK #0x2
3197:                  CPU_INT32S   nbr;
3198:                  CPU_INT32U   nbr_abs;
3199:                  CPU_BOOLEAN  nbr_neg;
3200:              
3201:              
3202:                  nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
00382C  E9820F     DEC2 W15, W4
00382E  B3C013     MOV.B #0x1, W3
003830  07FD14     RCALL _Str_ParseNbr_Int32
003832  BE0100     MOV.D W0, W2
3203:                                               pstr_next,
3204:                                               nbr_base,
3205:                                               DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
3206:                                              &nbr_neg);
3207:              
3208:                  if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
003834  97F86F     MOV.B [W15-2], W0
003836  E00400     CP0.B W0
003838  3A0005     BRA NZ, 0x3844
3209:                      nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
00383A  BE0002     MOV.D W2, W0
3210:                                                                                  :  (CPU_INT32S)nbr_abs;
00383C  510FE0     SUB W2, #0x0, [W15]
00383E  598FE0     SUBB W3, #0x0, [W15]
003840  3D000B     BRA GE, 0x3858
003842  370008     BRA 0x3854
003854  2FFFF0     MOV #0xFFFF, W0
003856  27FFF1     MOV #0x7FFF, W1
3211:                  } else {
3212:                      nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
3213:                                                                                  : -(CPU_INT32S)nbr_abs;
003844  200000     MOV #0x0, W0
003846  280001     MOV #0x8000, W1
003848  510FE0     SUB W2, #0x0, [W15]
00384A  598FE0     SUBB W3, #0x0, [W15]
00384C  350005     BRA LT, 0x3858
00384E  110060     SUBR W2, #0x0, W0
003850  1980E0     SUBBR W3, #0x0, W1
003852  370002     BRA 0x3858
3214:                  }
3215:              
3216:                  return (nbr);
3217:              }
003858  FA8000     ULNK
3218:              
3219:              
3220:              /*
3221:              *********************************************************************************************************
3222:              *********************************************************************************************************
3223:              *                                           LOCAL FUNCTIONS
3224:              *********************************************************************************************************
3225:              *********************************************************************************************************
3226:              */
3227:              
3228:              /*
3229:              *********************************************************************************************************
3230:              *                                         Str_FmtNbr_Int32()
3231:              *
3232:              * Description : Format 32-bit integer into a multi-digit character string.
3233:              *
3234:              * Argument(s) : nbr             Number           to format.
3235:              *
3236:              *               nbr_dig         Number of digits to format (see Note #1).
3237:              *
3238:              *               nbr_base        Base   of number to format (see Note #2).
3239:              *
3240:              *               nbr_neg         Indicates whether number to format is negative :
3241:              *               -------
3242:              *                                   DEF_NO          Number is non-negative.
3243:              *                                   DEF_YES         Number is     negative.
3244:              *
3245:              *                               Argument validated in Str_FmtNbr_Int32U(),
3246:              *                                                     Str_FmtNbr_Int32S().
3247:              *
3248:              *               lead_char       Prepend leading character  (see Note #3) :
3249:              *
3250:              *                                   '\0'                    Do NOT prepend leading character to string.
3251:              *                                     Printable character          Prepend leading character to string.
3252:              *                                   Unprintable character   Format invalid string (see Note #6e).
3253:              *
3254:              *               lower_case      Format alphabetic characters (if any) in lower case :
3255:              *
3256:              *                                   DEF_NO          Format alphabetic characters in upper case.
3257:              *                                   DEF_YES         Format alphabetic characters in lower case.
3258:              *
3259:              *               nul             Append terminating NULL-character (see Note #4) :
3260:              *
3261:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
3262:              *                                   DEF_YES                Append terminating NULL-character to string.
3263:              *
3264:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
3265:              *
3266:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
3267:              *
3268:              *               Pointer to NULL,             otherwise.
3269:              *
3270:              * Caller(s)   : Str_FmtNbr_Int32U(),
3271:              *               Str_FmtNbr_Int32S().
3272:              *$PAGE*
3273:              * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
3274:              *
3275:              *
3276:              *                               Maximum Number of             [  log (Number)      ]
3277:              *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
3278:              *                                   to Format                 [   log (Base)       ]
3279:              *
3280:              *                               where
3281:              *                                       Number                  Number to format
3282:              *                                       Base            Base of number to format
3283:              *
3284:              *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting
3285:              *                           is performed except possible NULL-termination of the string (see Note #4).
3286:              *
3287:              *                               Example :
3288:              *
3289:              *                                   nbr      = -23456
3290:              *                                   nbr_dig  =  0
3291:              *                                   nbr_base = 10
3292:              *
3293:              *                                   pstr     = ""                   See Note #7a
3294:              *
3295:              *                       (2) If the number of digits to format ('nbr_dig') is less than the number of
3296:              *                           significant integer digits of the number to format ('nbr'); then an invalid
3297:              *                           string is formatted instead of truncating any significant integer digits.
3298:              *
3299:              *                               Example :
3300:              *
3301:              *                                   nbr      = 23456
3302:              *                                   nbr_dig  = 3
3303:              *                                   nbr_base = 10
3304:              *
3305:              *                                   pstr     = "???"                See Note #7b
3306:              *
3307:              *                       (3) If the number to format ('nbr') is negative but the number of digits to format
3308:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
3309:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
3310:              *                           the negative sign.
3311:              *
3312:              *                               Example :
3313:              *
3314:              *                                   nbr      = -23456
3315:              *                                   nbr_dig  =  5
3316:              *                                   nbr_base = 10
3317:              *
3318:              *                                   pstr     = "?????"              See Note #7b
3319:              *
3320:              *               (2) The number's base MUST be between 2 & 36, inclusive.
3321:              *$PAGE*
3322:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
3323:              *
3324:              *                   (a) (1) Leading character MUST be a printable ASCII character.
3325:              *
3326:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
3327:              *                           (B) with the exception of '0'.
3328:              *
3329:              *                   (b) (1) The number of leading characters is such that the total number of significant
3330:              *                           integer digits plus the number of leading characters plus possible negative
3331:              *                           sign character is equal to the requested number of integer digits to format
3332:              *                           ('nbr_dig').
3333:              *
3334:              *                               Examples :
3335:              *
3336:              *                                   nbr       = 23456
3337:              *                                   nbr_dig   = 7
3338:              *                                   nbr_base  = 10
3339:              *                                   lead_char = ' '
3340:              *
3341:              *                                   pstr      = "  23456"
3342:              *
3343:              *
3344:              *                                   nbr       = -23456
3345:              *                                   nbr_dig   = 7
3346:              *                                   nbr_base  = 10
3347:              *                                   lead_char = ' '
3348:              *
3349:              *                                   pstr      = " -23456"
3350:              *
3351:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
3352:              *                               ('lead_char') is     a '0' digit; then the negative sign character
3353:              *                               prefixes all leading characters prior to the formatted number.
3354:              *
3355:              *                                   Examples :
3356:              *
3357:              *                                       nbr        = -23456
3358:              *                                       nbr_dig    =  8
3359:              *                                       nbr_base   = 10
3360:              *                                       lead_char  = '0'
3361:              *
3362:              *                                       pstr       = "-0023456"
3363:              *
3364:              *
3365:              *                                       nbr        = -43981
3366:              *                                       nbr_dig    =  8
3367:              *                                       nbr_base   = 16
3368:              *                                       lead_char  = '0'
3369:              *                                       lower_case = DEF_NO
3370:              *
3371:              *                                       pstr       = "-000ABCD"
3372:              *
3373:              *                           (B) If the number to format ('nbr') is negative AND the leading character
3374:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
3375:              *                               immediately prefixes the most significant digit of the formatted number.
3376:              *
3377:              *                                   Examples :
3378:              *
3379:              *                                       nbr        = -23456
3380:              *                                       nbr_dig    =  8
3381:              *                                       nbr_base   = 10
3382:              *                                       lead_char  = '#'
3383:              *
3384:              *                                       pstr       = "##-23456"
3385:              *
3386:              *
3387:              *                                       nbr        = -43981
3388:              *                                       nbr_dig    =  8
3389:              *                                       nbr_base   = 16
3390:              *                                       lead_char  = '#'
3391:              *                                       lower_case = DEF_YES
3392:              *
3393:              *                                       pstr       = "###-abcd"
3394:              *
3395:              *                   (c) (1) If the value of the number to format is     zero  ...
3396:              *                       (2) ... & the number of digits to format is non-zero, ...
3397:              *                       (3) ... but NO leading character available;           ...
3398:              *                       (4) ... then one digit of '0' value is formatted.
3399:              *
3400:              *                           This is NOT a leading character; but a single integer digit of '0' value.
3401:              *$PAGE*
3402:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
3403:              *                       array formatting.
3404:              *
3405:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
3406:              *                       terminate option DISABLED will cause character string run-on.
3407:              *
3408:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
3409:              *
3410:              *                   (b) To prevent character buffer overrun :
3411:              *
3412:              *                           Character array size MUST be  >=  ('nbr_dig'          +
3413:              *                                                               1 negative sign   +
3414:              *                                                               1 'NUL' terminator)  characters
3415:              *
3416:              *               (6) String format terminates when :
3417:              *
3418:              *                   (a) Format string pointer is passed a NULL pointer.
3419:              *                       (1) No      string formatted;                NULL pointer returned.
3420:              *
3421:              *                   (b) Number of digits to format ('nbr_dig') is zero.
3422:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
3423:              *
3424:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
3425:              *                           integer digits of the number to format ('nbr'), including possible
3426:              *                           negative sign.
3427:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3428:              *
3429:              *                   (d) Base is passed an invalid base (see Note #2).
3430:              *                       (1) Invalid string format performed; NULL pointer returned.
3431:              *
3432:              *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
3433:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3434:              *
3435:              *                   (f) Number successfully formatted into character string array.
3436:              *
3437:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
3438:              *                   ('?') will be formatted, where the number of question marks is determined by the
3439:              *                   number of digits to format ('nbr_dig') :
3440:              *
3441:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
3442:              *                          number of     =  {
3443:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
3444:              *
3445:              *********************************************************************************************************
3446:              */
3447:              
3448:              static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
3449:                                                   CPU_INT08U    nbr_dig,
3450:                                                   CPU_INT08U    nbr_base,
3451:                                                   CPU_BOOLEAN   nbr_neg,
3452:                                                   CPU_CHAR      lead_char,
3453:                                                   CPU_BOOLEAN   lower_case,
3454:                                                   CPU_BOOLEAN   nul,
3455:                                                   CPU_CHAR     *pstr)
3456:              {
0033D0  4787EE     ADD W15, #0xE, W15
0033D2  BE9F88     MOV.D W8, [W15++]
0033D4  BE9F8A     MOV.D W10, [W15++]
0033D6  BE9F8C     MOV.D W12, [W15++]
0033D8  781F8E     MOV W14, [W15++]
0033DA  BE0500     MOV.D W0, W10
0033DC  784682     MOV.B W2, W13
0033DE  9FEFC3     MOV.B W3, [W15-20]
0033E0  9FE7F4     MOV.B W4, [W15-25]
0033E2  784605     MOV.B W5, W12
0033E4  9FE7E6     MOV.B W6, [W15-26]
0033E6  9FEF87     MOV.B W7, [W15-24]
3457:                  CPU_CHAR     *pstr_fmt;
3458:                  CPU_DATA      i;
3459:                  CPU_INT32U    nbr_fmt;
3460:                  CPU_INT32U    nbr_log;
3461:                  CPU_INT08U    nbr_dig_max;
3462:                  CPU_INT08U    nbr_dig_min;
3463:                  CPU_INT08U    nbr_dig_fmtd;
3464:                  CPU_INT08U    nbr_neg_sign;
3465:                  CPU_INT08U    nbr_lead_char;
3466:                  CPU_INT08U    dig_val;
3467:                  CPU_INT08U    lead_char_delta_0;
3468:                  CPU_INT08U    lead_char_delta_a;
3469:                  CPU_BOOLEAN   lead_char_dig;
3470:                  CPU_BOOLEAN   lead_char_0;
3471:                  CPU_BOOLEAN   fmt_invalid;
3472:                  CPU_BOOLEAN   print_char;
3473:                  CPU_BOOLEAN   nbr_neg_fmtd;
3474:              
3475:              
3476:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
3477:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
0033E8  97A87F     MOV [W15-34], W0
0033EA  E00000     CP0 W0
0033EC  3200A6     BRA Z, 0x353A
3478:                      return ((CPU_CHAR *)0);
3479:                  }
3480:              
3481:                  fmt_invalid = DEF_NO;
0033FC  FB800D     ZE W13, W0
0033FE  E90000     DEC W0, W0
003400  DE004F     LSR W0, #15, W0
003402  9FEFA0     MOV.B W0, [W15-22]
3482:                  lead_char_0 = DEF_NO;
3483:              
3484:                  if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
3485:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
3486:                  }
3487:                                                                              /* If invalid base, ...                                 */
3488:                  if ((nbr_base <  2u) ||
0033EE  784103     MOV.B W3, W2
0033F0  E9C082     DEC2.B W2, W1
0033F6  B3C220     MOV.B #0x22, W0
0033F8  50CF80     SUB.B W1, W0, [W15]
0033FA  3E0004     BRA GTU, 0x3404
3489:                      (nbr_base > 36u)) {
3490:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
0033F2  B3C014     MOV.B #0x1, W4
0033F4  9FEFA4     MOV.B W4, [W15-22]
3491:                  }
3492:              
3493:                  if (lead_char != (CPU_CHAR)'\0') {
003404  E0040C     CP0.B W12
003406  32001D     BRA Z, 0x3442
3494:                      print_char =  ASCII_IsPrint(lead_char);
003408  78400C     MOV.B W12, W0
00340A  07098E     RCALL ASCII_IsPrint
3495:                      if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
00340C  504FE1     SUB.B W0, #0x1, [W15]
00340E  3A0044     BRA NZ, 0x3498
3496:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
3497:              
3498:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
003410  B3C301     MOV.B #0x30, W1
003412  564F81     SUB.B W12, W1, [W15]
003414  320016     BRA Z, 0x3442
3499:                          lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
003416  564081     SUB.B W12, W1, W1
3500:                          if (lower_case != DEF_YES) {
003418  97E06F     MOV.B [W15-26], W0
00341A  504FE1     SUB.B W0, #0x1, [W15]
00341C  320002     BRA Z, 0x3422
3501:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
00341E  B3CBF0     MOV.B #0xBF, W0
003420  370001     BRA 0x3424
3502:                          } else {
3503:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
003422  B3C9F0     MOV.B #0x9F, W0
003424  464000     ADD.B W12, W0, W0
3504:                          }
3505:              
3506:                          lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
003426  97E94F     MOV.B [W15-20], W2
003428  514FEA     SUB.B W2, #0xA, [W15]
00342A  3E0003     BRA GTU, 0x3432
00342C  50CF82     SUB.B W1, W2, [W15]
00342E  390034     BRA NC, 0x3498
003430  370008     BRA 0x3442
3507:                                           ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
003432  50CFE9     SUB.B W1, #0x9, [W15]
003434  360031     BRA LEU, 0x3498
00343E  500F81     SUB W0, W1, [W15]
003440  39002B     BRA NC, 0x3498
3508:                                                                  (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
003436  FB8000     ZE W0, W0
003438  97EA4F     MOV.B [W15-20], W4
00343A  FB8084     ZE W4, W1
00343C  5080EA     SUB W1, #0xA, W1
3509:              
3510:                          if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
3511:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
3512:                          }
3513:                      }
3514:                  }
3515:              
3516:              
3517:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
3518:                  pstr_fmt    = pstr;
3519:                  lead_char_0 = DEF_NO;
003488  EB4700     CLR.B W14
00348A  37005E     BRA 0x3548
3520:              
3521:                  if (fmt_invalid == DEF_NO) {
003442  97E82F     MOV.B [W15-22], W0
003444  E00400     CP0.B W0
003446  3A0028     BRA NZ, 0x3498
003448  BE000A     MOV.D W10, W0
00344A  B3C018     MOV.B #0x1, W8
00344C  370002     BRA 0x3452
3522:                      nbr_fmt     = nbr;
003496  BE040A     MOV.D W10, W8
003498  B3C010     MOV.B #0x1, W0
00349A  9FEFA0     MOV.B W0, [W15-22]
00349C  EB4700     CLR.B W14
003548  BE040A     MOV.D W10, W8
00354A  37FFA9     BRA 0x349E
3523:                      nbr_log     = nbr;
3524:                      nbr_dig_max = 1u;
3525:                      while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
003452  97EA4F     MOV.B [W15-20], W4
003454  FB8104     ZE W4, W2
003456  EB0180     CLR W3
003458  500F82     SUB W0, W2, [W15]
00345A  588F83     SUBB W1, W3, [W15]
00345C  31FFF8     BRA C, 0x344E
3526:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
00344E  E84408     INC.B W8, W8
3527:                          nbr_log /= nbr_base;
003450  07E905     RCALL 0x65C
3528:                      }
3529:              
3530:                      nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
00345E  97E07F     MOV.B [W15-25], W0
003460  A20400     BTG.B W0, #0
003462  FB8000     ZE W0, W0
003464  E90000     DEC W0, W0
003466  DE004F     LSR W0, #15, W0
3531:                      if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
003468  FB810D     ZE W13, W2
00346A  FB8188     ZE W8, W3
00346C  FB8080     ZE W0, W1
00346E  418081     ADD W3, W1, W1
003470  510F81     SUB W2, W1, [W15]
003472  350011     BRA LT, 0x3496
3532:                          nbr_neg_fmtd = DEF_NO;
3533:                          nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
003474  544F8D     SUB.B W8, W13, [W15]
003476  360001     BRA LEU, 0x347A
003478  78440D     MOV.B W13, W8
3534:                                                                              /* ... calc nbr digs to fmt & nbr lead chars.           */
3535:                          if (lead_char != (CPU_CHAR)'\0') {
00347A  E0040C     CP0.B W12
00347C  320004     BRA Z, 0x3486
3536:                              nbr_dig_fmtd  = nbr_dig;
3537:                              nbr_lead_char = nbr_dig     -
00347E  56C408     SUB.B W13, W8, W8
3538:                                              nbr_dig_min - nbr_neg_sign;
3539:                          } else {
3540:                              nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
003486  444680     ADD.B W8, W0, W13
3541:                              nbr_lead_char = 0u;
3542:                          }
3543:              
3544:                          if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
003480  544F80     SUB.B W8, W0, [W15]
003482  3A0004     BRA NZ, 0x348C
003484  370001     BRA 0x3488
3545:                              lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
00348C  B3C300     MOV.B #0x30, W0
00348E  B3C01E     MOV.B #0x1, W14
003490  564F80     SUB.B W12, W0, [W15]
003492  3AFFFA     BRA NZ, 0x3488
003494  370059     BRA 0x3548
3546:                                          ?  DEF_YES : DEF_NO;
3547:                          }
3548:              
3549:                      } else {                                                /* Else if nbr trunc'd, ...                             */
3550:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
3551:                      }
3552:                  }
3553:              
3554:                  if (fmt_invalid != DEF_NO) {
3555:                      nbr_dig_fmtd = nbr_dig;
3556:                  }
3557:              
3558:              
3559:                                                                              /* ------------------- FMT NBR STR -------------------- */
3560:                  pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
00349E  FB858D     ZE W13, W11
0034A0  97A97F     MOV [W15-34], W2
0034A2  41050B     ADD W2, W11, W10
3561:              
3562:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
0034A4  97EA0F     MOV.B [W15-24], W4
0034A6  E00404     CP0.B W4
0034A8  320001     BRA Z, 0x34AC
3563:                     *pstr_fmt = (CPU_CHAR)'\0';
0034AA  EB4D00     CLR.B [W10]
3564:                  }
3565:                  pstr_fmt--;
0034AC  E9050A     DEC W10, W10
3566:              
3567:              
3568:                  for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
0034AE  EB4000     CLR.B W0
0034B0  9FEF80     MOV.B W0, [W15-24]
0034B2  EB0680     CLR W13
0034B4  37003B     BRA 0x352C
00352A  E8068D     INC W13, W13
00352C  568F8B     SUB W13, W11, [W15]
00352E  39FFC3     BRA NC, 0x34B6
3569:                      if (fmt_invalid == DEF_NO) {
0034B6  97E92F     MOV.B [W15-22], W2
0034B8  E00402     CP0.B W2
0034BA  3A0035     BRA NZ, 0x3526
3570:                          if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
0034BC  540FE0     SUB W8, #0x0, [W15]
0034BE  5C8FE0     SUBB W9, #0x0, [W15]
0034C0  3A0002     BRA NZ, 0x34C6
0034C2  E0000D     CP0 W13
0034C4  3A001B     BRA NZ, 0x34FC
3571:                              (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
3572:                                                                              /* ... calc & fmt dig val;                      ...     */
3573:                              dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
0034C6  97E84F     MOV.B [W15-20], W0
0034C8  FB8200     ZE W0, W4
0034CA  EB0280     CLR W5
0034CC  BE0104     MOV.D W4, W2
0034CE  BE0008     MOV.D W8, W0
0034D0  9FB7F4     MOV W4, [W15-18]
0034D2  9FBF85     MOV W5, [W15-16]
0034D4  07E8D3     RCALL 0x67C
0034D6  E9008A     DEC W10, W1
3574:                              if (dig_val < 10u) {
0034D8  97B27F     MOV [W15-18], W4
0034DA  97BA8F     MOV [W15-16], W5
0034DE  504FE9     SUB.B W0, #0x9, [W15]
0034E0  360006     BRA LEU, 0x34EE
3575:                                 *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
0034DC  B3C302     MOV.B #0x30, W2
3576:                              } else {
3577:                                  if (lower_case !=  DEF_YES) {
0034E2  97E16F     MOV.B [W15-26], W2
0034E4  514FE1     SUB.B W2, #0x1, [W15]
0034E6  320002     BRA Z, 0x34EC
3578:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
0034E8  B3C372     MOV.B #0x37, W2
0034EA  370001     BRA 0x34EE
3579:                                  } else {
3580:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
0034EC  B3C572     MOV.B #0x57, W2
0034EE  404D02     ADD.B W0, W2, [W10]
0034F0  780501     MOV W1, W10
3581:                                  }
3582:                              }
3583:              
3584:                              nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
0034F2  BE0104     MOV.D W4, W2
0034F4  BE0008     MOV.D W8, W0
0034F6  07E8B2     RCALL 0x65C
0034F8  BE0400     MOV.D W0, W8
0034FA  370017     BRA 0x352A
3585:              
3586:                          } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
0034FC  97E27F     MOV.B [W15-25], W4
0034FE  524FE1     SUB.B W4, #0x1, [W15]
003500  3A000E     BRA NZ, 0x351E
003502  E0040E     CP0.B W14
003504  3A0004     BRA NZ, 0x350E
3587:                                   (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
003506  97E80F     MOV.B [W15-24], W0
003508  E00400     CP0.B W0
00350A  320004     BRA Z, 0x3514
00350C  370008     BRA 0x351E
3588:                                     (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
3589:                                    ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
003510  568F80     SUB W13, W0, [W15]
003512  3A0005     BRA NZ, 0x351E
3590:                                     (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
00350E  E9000B     DEC W11, W0
3591:              
3592:                             *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
003514  B3C2D0     MOV.B #0x2D, W0
003516  785500     MOV.B W0, [W10--]
3593:                              nbr_neg_fmtd = DEF_YES;
003518  B3C012     MOV.B #0x1, W2
00351A  9FEF82     MOV.B W2, [W15-24]
00351C  370006     BRA 0x352A
3594:              
3595:                          } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
00351E  E0040C     CP0.B W12
003520  320004     BRA Z, 0x352A
3596:                             *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
003522  78550C     MOV.B W12, [W10--]
003524  370002     BRA 0x352A
3597:                          }
3598:              
3599:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
3600:                         *pstr_fmt-- = '?';
003526  B3C3F0     MOV.B #0x3F, W0
003528  785500     MOV.B W0, [W10--]
3601:                      }
3602:                  }
3603:              
3604:              
3605:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
003530  97EA2F     MOV.B [W15-22], W4
003532  E00404     CP0.B W4
003534  320002     BRA Z, 0x353A
3606:                      return ((CPU_CHAR *)0);
003536  EB0000     CLR W0
003538  9FAFF0     MOV W0, [W15-34]
3607:                  }
3608:              
3609:              
3610:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
3611:              }
00353A  97A87F     MOV [W15-34], W0
00353C  78074F     MOV [--W15], W14
00353E  BE064F     MOV.D [--W15], W12
003540  BE054F     MOV.D [--W15], W10
003542  BE044F     MOV.D [--W15], W8
003544  B100EF     SUB #0xE, W15
003546  060000     RETURN
3612:              
3613:              
3614:              /*
3615:              *********************************************************************************************************
3616:              *                                        Str_ParseNbr_Int32()
3617:              *
3618:              * Description : Parse 32-bit integer from string.
3619:              *
3620:              * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
3621:              *
3622:              *               pstr_next       Optional pointer to a variable to ... :
3623:              *
3624:              *                                   (a) Return a pointer to first character following the integer string,
3625:              *                                           if NO error(s) [see Note #2a2B2];
3626:              *                                   (b) Return a pointer to 'pstr',
3627:              *                                           otherwise      (see Note #2a2A2).
3628:              *
3629:              *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
3630:              *
3631:              *               nbr_signed      Indicates whether number to parse is signed :
3632:              *
3633:              *                                   DEF_NO                  Number is unsigned.
3634:              *                                   DEF_YES                 Number is   signed.
3635:              *
3636:              *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
3637:              *
3638:              *                                   DEF_NO                  Number is non-negative.
3639:              *                                   DEF_YES                 Number is     negative.
3640:              *
3641:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
3642:              *
3643:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
3644:              *
3645:              *               0,                   otherwise                            (see Note #2a3B).
3646:              *
3647:              * Caller(s)   : Str_ParseNbr_Int32U(),
3648:              *               Str_ParseNbr_Int32S().
3649:              *
3650:              * Note(s)     : (1) String buffer NOT modified.
3651:              *
3652:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3653:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3654:              *                       to a type long ... representation" :
3655:              *
3656:              *                       (1) "First, they decompose the input string into three parts" :
3657:              *
3658:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3659:              *                                by isspace()]."
3660:              *
3661:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3662:              *                                    input string, starting with the first non-white-space character that is of
3663:              *                                    the expected form.  The subject sequence shall contain no characters if the
3664:              *                                    input string is empty or consists entirely of white-space characters."
3665:              *
3666:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3667:              *                                    determined by the value of 'base' ('nbr_base')" :
3668:              *
3669:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3670:              *                                        subject sequence is that of a decimal constant, octal constant, or
3671:              *                                        hexadecimal constant" :
3672:              *
3673:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3674:              *                                            sequence of decimal digits."
3675:              *
3676:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3677:              *                                            a sequence of the digits '0' to '7' only."
3678:              *
3679:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3680:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3681:              *                                            (or 'F') with values 10 to 15 respectively."
3682:              *
3683:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3684:              *                                        of the subject sequence is a sequence of letters and digits representing
3685:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3686:              *
3687:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3688:              *                                                ascribed the values 10 to 35"; ...
3689:              *                                           (B) "only letters whose ascribed values are less than that of base
3690:              *                                                are permitted."
3691:              *
3692:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3693:              *                                               '0X' may optionally precede the sequence of letters and digits."
3694:              *
3695:              *                                           (B) Although NO specification states that "if the value of 'base'
3696:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3697:              *                                               the sequence of letters and digits"; it seems reasonable to
3698:              *                                               allow the '0' character to be optionally parsed.
3699:              *$PAGE*
3700:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3701:              *
3702:              *                                   (a) It does NOT seem reasonable to parse & convert a negative number
3703:              *                                       integer string into an unsigned integer.  However, a negative sign
3704:              *                                       for an unsigned integer will automatically be parsed as an invalid
3705:              *                                       character (see Note #2aC1).
3706:              *
3707:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3708:              *                                   (b) "including the terminating null byte of the input string" ...
3709:              *                               (2) "other than a sign or a permissible letter or digit."
3710:              *
3711:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3712:              *
3713:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3714:              *
3715:              *                               (1) "no conversion is performed"; ...
3716:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3717:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3718:              *
3719:              *                           (B) "If the subject sequence has the expected form" :
3720:              *
3721:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3722:              *                                        starting with the first digit shall be interpreted as an integer constant."
3723:              *
3724:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3725:              *                                        used as the base for conversion, ascribing to each letter its value as
3726:              *                                        given above" (see Note #2a1B1b1A).
3727:              *
3728:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3729:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3730:              *                                   pointer."
3731:              *
3732:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3733:              *
3734:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3735:              *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
3736:              *                                    [or] {LONG_MAX} ... shall be returned."
3737:              *
3738:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3739:              *
3740:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3741:              *                           shall fail if" :
3742:              *
3743:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3744:              *
3745:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3746:              *
3747:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3748:              *                           may fail if" :
3749:              *
3750:              *                           (A) "[EINVAL] - No conversion could be performed."
3751:              *$PAGE*
3752:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3753:              *
3754:              *                   (a) Valid parse string integer :
3755:              *
3756:              *                           pstr      = "     ABCDE xyz"
3757:              *                           nbr_base  = 16
3758:              *
3759:              *                           nbr       = 703710
3760:              *                           pstr_next = " xyz"
3761:              *
3762:              *
3763:              *                   (b) Invalid parse string integer :
3764:              *
3765:              *                           pstr      = "     ABCDE"
3766:              *                           nbr_base  = 10
3767:              *
3768:              *                           nbr       =  0
3769:              *                           pstr_next = pstr = "     ABCDE"
3770:              *
3771:              *
3772:              *                   (c) Valid hexadecimal parse string integer :
3773:              *
3774:              *                           pstr      = "     0xGABCDE"
3775:              *                           nbr_base  = 16
3776:              *
3777:              *                           nbr       =  0
3778:              *                           pstr_next = "xGABCDE"
3779:              *
3780:              *
3781:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3782:              *                               following invalid hexadecimal characters) :
3783:              *
3784:              *                           pstr      = "     0xGABCDE"
3785:              *                           nbr_base  =  0
3786:              *
3787:              *                           nbr       =  0
3788:              *                           pstr_next = "xGABCDE"
3789:              *
3790:              *
3791:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3792:              *                               following invalid octal       characters) :
3793:              *
3794:              *                           pstr      = "     0GABCDE"
3795:              *                           nbr_base  =  0
3796:              *
3797:              *                           nbr       =  0
3798:              *                           pstr_next = "GABCDE"
3799:              *
3800:              *
3801:              *                   (f) Parse string integer overflow :
3802:              *
3803:              *                           pstr      = "   12345678901234567890*123456"
3804:              *                           nbr_base  = 10
3805:              *
3806:              *                           nbr       = DEF_INT_32U_MAX_VAL
3807:              *                           pstr_next = "*123456"
3808:              *
3809:              *
3810:              *                   (g) Parse string integer underflow :
3811:              *
3812:              *                           pstr      = "  -12345678901234567890*123456"
3813:              *                           nbr_base  = 10
3814:              *
3815:              *                           nbr       = DEF_INT_32S_MIN_VAL
3816:              *                           pstr_next = "*123456"
3817:              *
3818:              *
3819:              *               (4) String parse terminates when :
3820:              *
3821:              *                   (a) Base passed an invalid base (see Note #2a1B1b).
3822:              *                       (1) No conversion performed; 0 returned.
3823:              *
3824:              *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
3825:              *                           (A) No conversion performed; 0 returned.
3826:              *
3827:              *                       (2) Invalid parse string character found (see Note #2a1C).
3828:              *                           (A) Parsed integer returned.
3829:              *                           (B) 'pstr_next' points to invalid character.
3830:              *
3831:              *                       (3) Entire  parse string converted (see Note #2a2B).
3832:              *                           (A) Parsed integer returned.
3833:              *                           (B) 'pstr_next' points to terminating NULL character.
3834:              *
3835:              *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
3836:              *                   validation or function handling in case of any error(s).
3837:              *********************************************************************************************************
3838:              */
3839:              
3840:              static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
3841:                                                             CPU_CHAR     **pstr_next,
3842:                                                             CPU_INT08U     nbr_base,
3843:                                                             CPU_BOOLEAN    nbr_signed,
3844:                                                             CPU_BOOLEAN   *pnbr_neg)
3845:              {
00325A  4787EE     ADD W15, #0xE, W15
00325C  BE9F88     MOV.D W8, [W15++]
00325E  BE9F8A     MOV.D W10, [W15++]
003260  BE9F8C     MOV.D W12, [W15++]
003262  781F8E     MOV W14, [W15++]
003264  780500     MOV W0, W10
003266  780481     MOV W1, W9
003268  784402     MOV.B W2, W8
00326A  784583     MOV.B W3, W11
00326C  780704     MOV W4, W14
3846:                  const  CPU_CHAR     *pstr_parse;
3847:                  const  CPU_CHAR     *pstr_parse_nbr;
3848:                         CPU_CHAR     *pstr_parse_unused;
3849:                         CPU_CHAR      parse_char;
3850:                         CPU_INT08U    parse_dig;
3851:                         CPU_INT32U    nbr;
3852:                         CPU_BOOLEAN   nbr_neg_unused;
3853:                         CPU_BOOLEAN   nbr_dig;
3854:                         CPU_BOOLEAN   nbr_alpha;
3855:                         CPU_BOOLEAN   nbr_hex;
3856:                         CPU_BOOLEAN   nbr_hex_lower;
3857:                         CPU_BOOLEAN   whitespace;
3858:                         CPU_BOOLEAN   neg;
3859:                         CPU_BOOLEAN   ovf;
3860:                         CPU_BOOLEAN   done;
3861:              
3862:                                                                              /* --------------- VALIDATE PARSE ARGS ---------------- */
3863:                  if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
00326E  E00009     CP0 W9
003270  3A0001     BRA NZ, 0x3274
3864:                      pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
003272  5784F8     SUB W15, #0x18, W9
3865:                     (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
3866:                  }
3867:                 *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
003274  780C8A     MOV W10, [W9]
3868:              
3869:                  if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
003276  E0000E     CP0 W14
003278  3A0001     BRA NZ, 0x327C
3870:                      pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
00327A  57877A     SUB W15, #0x1A, W14
3871:                     (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
3872:                  }
3873:                 *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
00327C  EB4F00     CLR.B [W14]
3874:              
3875:              
3876:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
003280  E0000A     CP0 W10
003282  32009F     BRA Z, 0x33C2
3877:                      return (0u);
00327E  B82260     MUL.UU W4, #0, W4
3878:                  }
3879:                                                                              /* Rtn zero if invalid base (see Note #4a).             */
3880:                  if ((nbr_base == 1u) ||
003284  544FE1     SUB.B W8, #0x1, [W15]
003286  32009D     BRA Z, 0x33C2
003288  B3C240     MOV.B #0x24, W0
00328A  544F80     SUB.B W8, W0, [W15]
00328C  3E009A     BRA GTU, 0x33C2
3881:                      (nbr_base > 36u)) {
3882:                      return (0u);
3883:                  }
3884:              
3885:              
3886:                                                                              /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
3887:                  pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
3888:              
3889:                  whitespace = ASCII_IsSpace(*pstr_parse);
00328E  78401A     MOV.B [W10], W0
003290  070A39     RCALL ASCII_IsSpace
003292  78068A     MOV W10, W13
3890:                  while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
003294  370002     BRA 0x329A
00329C  504FE1     SUB.B W0, #0x1, [W15]
00329E  32FFFB     BRA Z, 0x3296
3891:                      pstr_parse++;
3892:                      whitespace = ASCII_IsSpace(*pstr_parse);
003296  78405D     MOV.B [++W13], W0
003298  070A35     RCALL ASCII_IsSpace
00329A  78060D     MOV W13, W12
3893:                  }
3894:              
3895:                  switch (*pstr_parse) {
0032A0  78401D     MOV.B [W13], W0
0032A2  B3C2B1     MOV.B #0x2B, W1
0032A4  504F81     SUB.B W0, W1, [W15]
0032A6  320004     BRA Z, 0x32B0
0032A8  E8C081     INC2.B W1, W1
0032AA  504F81     SUB.B W0, W1, [W15]
0032AC  3A0009     BRA NZ, 0x32C0
0032AE  370002     BRA 0x32B4
3896:                      case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
3897:                           pstr_parse++;
0032B0  E8060D     INC W13, W12
0032B2  370006     BRA 0x32C0
3898:                           neg = DEF_NO;
3899:                           break;
3900:              
3901:              
3902:                      case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
3903:                           if (nbr_signed == DEF_YES) {
0032B8  55CF80     SUB.B W11, W0, [W15]
0032BA  3A0004     BRA NZ, 0x32C4
3904:                               pstr_parse++;
0032BC  E8060D     INC W13, W12
0032BE  370002     BRA 0x32C4
3905:                           }
3906:                           neg = DEF_YES;
0032B4  B3C010     MOV.B #0x1, W0
0032B6  9FEFA0     MOV.B W0, [W15-22]
3907:                           break;
3908:              
3909:              
3910:                      default:
3911:                           neg = DEF_NO;
0032C0  EB4000     CLR.B W0
0032C2  9FEFA0     MOV.B W0, [W15-22]
3912:                           break;
3913:                  }
3914:              
3915:              
3916:                                                                              /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
3917:                  pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
3918:              
3919:                  switch (nbr_base) {
0032C4  544FE8     SUB.B W8, #0x8, [W15]
0032C6  320016     BRA Z, 0x32F4
0032C8  544FF0     SUB.B W8, #0x10, [W15]
0032CA  320019     BRA Z, 0x32FE
0032CC  E00408     CP0.B W8
0032CE  3A002E     BRA NZ, 0x332C
3920:                      case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
3921:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0032D0  B3C300     MOV.B #0x30, W0
0032D2  104F9C     SUBR.B W0, [W12], [W15]
0032D4  3A0025     BRA NZ, 0x3320
003320  78058C     MOV W12, W11
3922:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
0032D6  78058C     MOV W12, W11
3923:                                switch (*pstr_parse) {
0032D8  78405B     MOV.B [++W11], W0
0032DA  B3C581     MOV.B #0x58, W1
0032DC  504F81     SUB.B W0, W1, [W15]
0032DE  320004     BRA Z, 0x32E8
0032E0  B3C781     MOV.B #0x78, W1
0032E4  504F81     SUB.B W0, W1, [W15]
0032E6  3A0025     BRA NZ, 0x3332
3924:                                    case 'x':                                 /* For '0x' prefix, ...                                 */
3925:                                    case 'X':
3926:                                         nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
003328  B3C108     MOV.B #0x10, W8
00332A  370003     BRA 0x3332
3927:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
0032E8  78040B     MOV W11, W8
3928:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
0032EA  784058     MOV.B [++W8], W0
0032EC  0709F1     RCALL ASCII_IsDigHex
3929:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
0032EE  504FE1     SUB.B W0, #0x1, [W15]
0032F0  3A001B     BRA NZ, 0x3328
0032F2  370019     BRA 0x3326
003326  780588     MOV W8, W11
3930:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
3931:                                         }
3932:                                         break;
3933:              
3934:              
3935:                                    default:                                  /* For '0'  prefix, ...                                 */
3936:                                         nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
0032E2  B3C088     MOV.B #0x8, W8
3937:                                         break;
3938:                                }
3939:              
3940:                           } else {                                           /* For non-'0' prefix, ...                              */
3941:                               nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
003322  B3C0A8     MOV.B #0xA, W8
003324  370006     BRA 0x3332
3942:                           }
3943:                           break;
3944:              
3945:              
3946:                      case  8u:                                               /* See Note #2a1B1a2.                                   */
3947:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0032F4  B3C300     MOV.B #0x30, W0
0032F6  104F9C     SUBR.B W0, [W12], [W15]
0032F8  3A0019     BRA NZ, 0x332C
3948:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
0032FA  E8058C     INC W12, W11
0032FC  37001A     BRA 0x3332
3949:                           }
3950:                           break;
3951:              
3952:              
3953:                      case 16u:                                               /* See Note #2a1B1a3.                                   */
3954:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0032FE  B3C300     MOV.B #0x30, W0
003300  104F9C     SUBR.B W0, [W12], [W15]
003302  3A0014     BRA NZ, 0x332C
00332C  78058C     MOV W12, W11
00332E  370001     BRA 0x3332
3955:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
003304  78058C     MOV W12, W11
3956:                                switch (*pstr_parse) {
003306  78405B     MOV.B [++W11], W0
003308  B3C581     MOV.B #0x58, W1
00330A  504F81     SUB.B W0, W1, [W15]
00330C  320003     BRA Z, 0x3314
00330E  B3C781     MOV.B #0x78, W1
003310  504F81     SUB.B W0, W1, [W15]
003312  3A000F     BRA NZ, 0x3332
3957:                                    case 'x':
3958:                                    case 'X':
3959:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
003314  78068B     MOV W11, W13
3960:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
003316  78405D     MOV.B [++W13], W0
003318  0709DB     RCALL ASCII_IsDigHex
3961:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
00331A  504FE1     SUB.B W0, #0x1, [W15]
00331C  3A000A     BRA NZ, 0x3332
00331E  370008     BRA 0x3330
003330  78058D     MOV W13, W11
3962:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
3963:                                         }
3964:                                         break;
3965:              
3966:              
3967:                                    default:
3968:                                         break;
3969:                                }
3970:                           }
3971:                           break;
3972:              
3973:              
3974:                      default:                                                /* See Note #2a1B1b.                                    */
3975:                           break;
3976:                  }
3977:              
3978:              
3979:                                                                              /* ------------------ PARSE INT STR ------------------- */
3980:                  nbr  = 0u;
003332  B82260     MUL.UU W4, #0, W4
3981:                  ovf  = DEF_NO;
003334  EB4680     CLR.B W13
3982:                  done = DEF_NO;
3983:              
3984:                  while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
3985:                      parse_char = (CPU_CHAR)*pstr_parse;
003336  78409B     MOV.B [W11], W1
3986:                      nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
003338  784001     MOV.B W1, W0
00333A  9FBF81     MOV W1, [W15-16]
00333C  9FB7E4     MOV W4, [W15-20]
00333E  9FB7F5     MOV W5, [W15-18]
003340  07099B     RCALL ASCII_IsAlphaNum
3987:                      if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
003342  97B88F     MOV [W15-16], W1
003344  97B26F     MOV [W15-20], W4
003346  97B2FF     MOV [W15-18], W5
003348  504FE1     SUB.B W0, #0x1, [W15]
00334A  3A0030     BRA NZ, 0x33AC
3988:                                                                              /* ... convert parse char into nbr dig.                 */
3989:                          nbr_dig = ASCII_IsDig(parse_char);
00334C  784001     MOV.B W1, W0
00334E  0709B2     RCALL ASCII_IsDig
3990:                          if (nbr_dig == DEF_YES) {
003350  97B88F     MOV [W15-16], W1
003352  97B26F     MOV [W15-20], W4
003354  97B2FF     MOV [W15-18], W5
003358  504FE1     SUB.B W0, #0x1, [W15]
00335A  32000C     BRA Z, 0x3374
3991:                              parse_dig = (CPU_INT08U)(parse_char - '0');
003356  B3CD06     MOV.B #0xD0, W6
3992:                          } else {
3993:                              nbr_hex_lower = ASCII_IsLower(parse_char);
00335C  784001     MOV.B W1, W0
00335E  9FBF81     MOV W1, [W15-16]
003360  9FB7E4     MOV W4, [W15-20]
003362  9FB7F5     MOV W5, [W15-18]
003364  070999     RCALL ASCII_IsLower
3994:                              if (nbr_hex_lower == DEF_YES) {
003366  97B88F     MOV [W15-16], W1
003368  97B26F     MOV [W15-20], W4
00336A  97B2FF     MOV [W15-18], W5
00336E  504FE1     SUB.B W0, #0x1, [W15]
003370  320001     BRA Z, 0x3374
3995:                                  parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
00336C  B3CA96     MOV.B #0xA9, W6
3996:                              } else {
3997:                                  parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
003372  B3CC96     MOV.B #0xC9, W6
003374  40C306     ADD.B W1, W6, W6
3998:                              }
3999:                          }
4000:              
4001:                          if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
003376  534F88     SUB.B W6, W8, [W15]
003378  310019     BRA C, 0x33AC
4002:                              if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
00337A  E0040D     CP0.B W13
00337C  3A0014     BRA NZ, 0x33A6
4003:                                  if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
00337E  FB8008     ZE W8, W0
003380  DD0042     SL W0, #2, W0
003382  29D801     MOV #0x9D80, W1
003384  408000     ADD W1, W0, W0
003386  520FB0     SUB W4, [W0++], [W15]
003388  5A8FA0     SUBB W5, [W0--], [W15]
00338A  3E000D     BRA GTU, 0x33A6
4004:                                                                              /* ... merge parse char dig into nbr.                   */
4005:                                      nbr *= nbr_base;
00338C  FB8108     ZE W8, W2
00338E  EB0180     CLR W3
003390  BE0004     MOV.D W4, W0
003392  9FB7E6     MOV W6, [W15-20]
003394  07E976     RCALL 0x682
4006:                                      nbr += parse_dig;
003396  97B36F     MOV [W15-20], W6
003398  FB8306     ZE W6, W6
00339A  EB0380     CLR W7
00339C  400206     ADD W0, W6, W4
00339E  488287     ADDC W1, W7, W5
4007:                                      if (nbr < parse_dig) {
0033A0  520F86     SUB W4, W6, [W15]
0033A2  5A8F87     SUBB W5, W7, [W15]
0033A4  310001     BRA C, 0x33A8
4008:                                          ovf = DEF_YES;
0033A6  B3C01D     MOV.B #0x1, W13
4009:                                      }
4010:                                  } else {
4011:                                      ovf = DEF_YES;
4012:                                  }
4013:                              }
4014:                              pstr_parse++;
0033A8  E8058B     INC W11, W11
0033AA  37FFC5     BRA 0x3336
4015:              
4016:                          } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
4017:                              done = DEF_YES;
4018:                          }
4019:              
4020:                      } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
4021:                          done = DEF_YES;
4022:                      }
4023:                  }
4024:              
4025:                  if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
0033AC  56CFE1     SUB.B W13, #0x1, [W15]
0033AE  3A0002     BRA NZ, 0x33B4
4026:                      nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
0033B0  EB8200     SETM W4
0033B2  EB8280     SETM W5
4027:                  }
4028:              
4029:              
4030:                  if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
0033B4  558F8C     SUB W11, W12, [W15]
0033B6  320002     BRA Z, 0x33BC
4031:                     *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
0033B8  780C8B     MOV W11, [W9]
0033BA  370001     BRA 0x33BE
4032:                  } else {
4033:                     *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
0033BC  780C8A     MOV W10, [W9]
4034:                  }
4035:              
4036:                 *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
0033BE  97E82F     MOV.B [W15-22], W0
0033C0  784F00     MOV.B W0, [W14]
4037:              
4038:              
4039:                  return (nbr);
4040:              }
0033C2  BE0004     MOV.D W4, W0
0033C4  78074F     MOV [--W15], W14
0033C6  BE064F     MOV.D [--W15], W12
0033C8  BE054F     MOV.D [--W15], W10
0033CA  BE044F     MOV.D [--W15], W8
0033CC  B100EF     SUB #0xE, W15
0033CE  060000     RETURN
4041:              
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uC-LIB/lib_mem.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     STANDARD MEMORY OPERATIONS
29:                *
30:                * Filename      : lib_mem.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 FGK
34:                *                 JFD
35:                *                 FBJ
36:                *                 EJ
37:                *********************************************************************************************************
38:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
39:                *
40:                *                     (a) ALL standard library functions are implemented in the custom library modules :
41:                *
42:                *                         (1) \<Custom Library Directory>\lib_*.*
43:                *
44:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
45:                *
46:                *                               where
47:                *                                       <Custom Library Directory>      directory path for custom library software
48:                *                                       <cpu>                           directory name for specific processor (CPU)
49:                *                                       <compiler>                      directory name for specific compiler
50:                *
51:                *                     (b) Product-specific library functions are implemented in individual products.
52:                *********************************************************************************************************
53:                */
54:                
55:                
56:                /*
57:                *********************************************************************************************************
58:                *                                            INCLUDE FILES
59:                *********************************************************************************************************
60:                */
61:                
62:                #define    MICRIUM_SOURCE
63:                #define    LIB_MEM_MODULE
64:                #include  "lib_mem.h"
65:                #include  "lib_math.h"
66:                #include  "lib_str.h"
67:                
68:                
69:                /*
70:                *********************************************************************************************************
71:                *                                            LOCAL DEFINES
72:                *********************************************************************************************************
73:                */
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                           LOCAL CONSTANTS
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                          LOCAL DATA TYPES
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                            LOCAL TABLES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                       LOCAL GLOBAL VARIABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               
104:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
105:               #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
106:               CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
107:               #endif
108:               
109:               MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
110:               #endif
111:               
112:               MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
113:               
114:               
115:               /*
116:               *********************************************************************************************************
117:               *                                      LOCAL FUNCTION PROTOTYPES
118:               *********************************************************************************************************
119:               */
120:               
121:               static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
122:                                                                      MEM_SEG       *p_seg,
123:                                                                      CPU_ADDR       seg_base_addr,
124:                                                                      CPU_SIZE_T     padding_align,
125:                                                                      CPU_SIZE_T     size);
126:               
127:               static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
128:                                                                      CPU_SIZE_T     size,
129:                                                                      LIB_ERR       *p_err);
130:               
131:               static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
132:                                                                      MEM_SEG       *p_seg,
133:                                                                      CPU_SIZE_T     size,
134:                                                                      CPU_SIZE_T     align,
135:                                                                      CPU_SIZE_T     padding_align,
136:                                                                      CPU_SIZE_T    *p_bytes_reqd,
137:                                                                      LIB_ERR       *p_err);
138:               
139:               static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
140:                                                                      CPU_SIZE_T     size,
141:                                                                      CPU_SIZE_T     align,
142:                                                                      CPU_SIZE_T     padding_align,
143:                                                                      CPU_SIZE_T    *p_bytes_reqd,
144:                                                                      LIB_ERR       *p_err);
145:               
146:               static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
147:                                                                      MEM_DYN_POOL  *p_pool,
148:                                                                      MEM_SEG       *p_seg,
149:                                                                      CPU_SIZE_T     blk_size,
150:                                                                      CPU_SIZE_T     blk_align,
151:                                                                      CPU_SIZE_T     blk_padding_align,
152:                                                                      CPU_SIZE_T     blk_qty_init,
153:                                                                      CPU_SIZE_T     blk_qty_max,
154:                                                                      LIB_ERR       *p_err);
155:               
156:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
157:               static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
158:                                                                      MEM_SEG       *p_seg,
159:                                                                      CPU_SIZE_T     size,
160:                                                                      LIB_ERR       *p_err);
161:               #endif
162:               
163:               #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
164:                    (LIB_MEM_CFG_HEAP_SIZE      >  0u))
165:               static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
166:                                                                      void          *p_mem);
167:               #endif
168:               
169:               
170:               /*
171:               *********************************************************************************************************
172:               *                                     LOCAL CONFIGURATION ERRORS
173:               *********************************************************************************************************
174:               */
175:               
176:               /*
177:               *********************************************************************************************************
178:               *********************************************************************************************************
179:               *                                            GLOBAL FUNCTIONS
180:               *********************************************************************************************************
181:               *********************************************************************************************************
182:               */
183:               
184:               /*
185:               *********************************************************************************************************
186:               *                                             Mem_Init()
187:               *
188:               * Description : (1) Initializes Memory Management Module :
189:               *
190:               *                   (a) Initialize heap memory pool
191:               *                   (b) Initialize      memory pool table
192:               *
193:               *
194:               * Argument(s) : none.
195:               *
196:               * Return(s)   : none.
197:               *
198:               * Caller(s)   : Application.
199:               *
200:               * Note(s)     : (2) Mem_Init() MUST be called ... :
201:               *
202:               *                   (a) ONLY ONCE from a product's application; ...
203:               *                   (b) BEFORE product's application calls any memory library module function(s)
204:               *********************************************************************************************************
205:               */
206:               
207:               void  Mem_Init (void)
208:               {
002F54  FA0002     LNK #0x2
209:               
210:                                                                               /* ------------------ INIT SEG LIST ------------------- */
211:                   Mem_SegHeadPtr = DEF_NULL;
002F56  EF2846     CLR Mem_SegHeadPtr
212:               
213:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
214:                   {
215:                       LIB_ERR   err;
216:                       CPU_ADDR  heap_base_addr;
217:               
218:               
219:                                                                               /* ------------------ INIT HEAP SEG ------------------- */
220:               #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
221:                       heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
222:               #else
223:                       heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
224:               #endif
225:               
226:                       Mem_SegCreate("Heap",
002F58  E9828F     DEC2 W15, W5
002F5A  200014     MOV #0x1, W4
002F5C  204003     MOV #0x400, W3
002F5E  2114A2     MOV #0x114A, W2
002F60  2154A1     MOV #0x154A, W1
002F62  29E140     MOV #0x9E14, W0
002F64  07FFE7     RCALL Mem_SegCreate
227:                                     &Mem_SegHeap,                             /* Create heap seg.                                     */
228:                                      heap_base_addr,
229:                                      LIB_MEM_CFG_HEAP_SIZE,
230:                                      LIB_MEM_PADDING_ALIGN_NONE,
231:                                     &err);
232:                       if (err != LIB_MEM_ERR_NONE) {
002F66  227100     MOV #0x2710, W0
002F68  97B8FF     MOV [W15-2], W1
002F6A  508F80     SUB W1, W0, [W15]
002F6C  320001     BRA Z, 0x2F70
233:                           CPU_SW_EXCEPTION(;);
002F6E  0708F6     RCALL CPU_SW_Exception
234:                       }
235:                   }
236:               #endif
237:               }
002F70  FA8000     ULNK
002F72  060000     RETURN
238:               
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                              Mem_Clr()
243:               *
244:               * Description : Clears data buffer (see Note #2).
245:               *
246:               * Argument(s) : pmem        Pointer to memory buffer to clear.
247:               *
248:               *               size        Number of data buffer octets to clear (see Note #1).
249:               *
250:               * Return(s)   : none.
251:               *
252:               * Caller(s)   : Application.
253:               *
254:               * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
255:               *
256:               *                   See also 'Mem_Set()  Note #1'.
257:               *
258:               *               (2) Clear data by setting each data octet to 0.
259:               *********************************************************************************************************
260:               */
261:               
262:               void  Mem_Clr (void        *pmem,
263:                              CPU_SIZE_T   size)
264:               {
265:                   Mem_Set(pmem,
002DF6  780101     MOV W1, W2
002DF8  EB4080     CLR.B W1
002DFA  37FFDC     BRA Mem_Set
266:                           0u,                                                 /* See Note #2.                                         */
267:                           size);
268:               }
269:               
270:               
271:               /*
272:               *********************************************************************************************************
273:               *                                              Mem_Set()
274:               *
275:               * Description : Fills data buffer with specified data octet.
276:               *
277:               * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
278:               *
279:               *               data_val    Data fill octet value.
280:               *
281:               *               size        Number of data buffer octets to fill (see Note #1).
282:               *
283:               * Return(s)   : none.
284:               *
285:               * Caller(s)   : Application.
286:               *
287:               * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
288:               *
289:               *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
290:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
291:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
292:               *                   addresses.
293:               *
294:               *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
295:               *                   address boundary.
296:               *
297:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
298:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
299:               *                  'mem_align_mod' arithmetic operation.
300:               *********************************************************************************************************
301:               */
302:               
303:               void  Mem_Set (void        *pmem,
002DE8  780182     MOV W2, W3
002DEA  A10003     BCLR W3, #0
304:                              CPU_INT08U   data_val,
305:                              CPU_SIZE_T   size)
306:               {
307:                   CPU_SIZE_T   size_rem;
308:                   CPU_ALIGN    data_align;
309:                   CPU_ALIGN   *pmem_align;
310:                   CPU_INT08U  *pmem_08;
311:                   CPU_DATA     mem_align_mod;
312:                   CPU_DATA     i;
313:               
314:               
315:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
316:                   if (size < 1) {                                             /* See Note #1.                                         */
317:                       return;
318:                   }
319:                   if (pmem == (void *)0) {
320:                       return;
321:                   }
322:               #endif
323:               
324:               
325:                   data_align = 0u;
002DB6  EB0200     CLR W4
326:                   for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
002DB4  EB0180     CLR W3
002DBE  E80183     INC W3, W3
002DC0  518FE2     SUB W3, #0x2, [W15]
002DC2  3AFFFA     BRA NZ, 0x2DB8
327:                       data_align <<=  DEF_OCTET_NBR_BITS;
002DB8  DD2248     SL W4, #8, W4
328:                       data_align  |= (CPU_ALIGN)data_val;
002DBA  FB8281     ZE W1, W5
002DBC  728204     IOR W5, W4, W4
329:                   }
330:               
331:                   size_rem      =  size;
332:                   mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
333:               
334:                   pmem_08 = (CPU_INT08U *)pmem;
335:                   if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
002DC4  200013     MOV #0x1, W3
002DC6  A30800     BTST.Z W0, #0
002DC8  3A0004     BRA NZ, 0x2DD2
002DCA  370007     BRA 0x2DDA
336:                       i = mem_align_mod;
337:                       while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
002DD2  E00002     CP0 W2
002DD4  320002     BRA Z, 0x2DDA
002DD6  518FE1     SUB W3, #0x1, [W15]
002DD8  32FFF9     BRA Z, 0x2DCC
338:                              (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
339:                          *pmem_08++ = data_val;
002DCC  785801     MOV.B W1, [W0++]
340:                           size_rem -= sizeof(CPU_INT08U);
002DCE  E90102     DEC W2, W2
341:                           i++;
002DD0  200023     MOV #0x2, W3
342:                       }
343:                   }
344:               
345:                   pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
002DDA  780280     MOV W0, W5
346:                   while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
002DDC  780182     MOV W2, W3
002DDE  370002     BRA 0x2DE4
002DE4  518FE1     SUB W3, #0x1, [W15]
002DE6  3EFFFC     BRA GTU, 0x2DE0
347:                      *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
002DE0  781A84     MOV W4, [W5++]
348:                       size_rem    -= sizeof(CPU_ALIGN);
002DE2  E98183     DEC2 W3, W3
349:                   }
350:               
351:                   pmem_08 = (CPU_INT08U *)pmem_align;
002DEC  400003     ADD W0, W3, W0
352:                   while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
002DEE  A30802     BTST.Z W2, #0
002DF0  320001     BRA Z, 0x2DF4
353:                      *pmem_08++   = data_val;
002DF2  784801     MOV.B W1, [W0]
002DF4  060000     RETURN
354:                       size_rem   -= sizeof(CPU_INT08U);
355:                   }
356:               }
357:               
358:               
359:               /*
360:               *********************************************************************************************************
361:               *                                             Mem_Copy()
362:               *
363:               * Description : Copies data octets from one memory buffer to another memory buffer.
364:               *
365:               * Argument(s) : pdest       Pointer to destination memory buffer.
366:               *
367:               *               psrc        Pointer to source      memory buffer.
368:               *
369:               *               size        Number of octets to copy (see Note #1).
370:               *
371:               * Return(s)   : none.
372:               *
373:               * Caller(s)   : Application.
374:               *
375:               * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
376:               *
377:               *               (2) Memory buffers NOT checked for overlapping.
378:               *
379:               *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
380:               *                       copying takes place between objects that overlap, the behavior is undefined".
381:               *
382:               *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
383:               *                       successfully copy to a destination memory buffer at a lower  address value even
384:               *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
385:               *                       word copy overlaps.
386:               *
387:               *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
388:               *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
389:               *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
390:               *                       ever overlap.
391:               *
392:               *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
393:               *                       buffers as long as the source memory buffer is at a higher address value than the
394:               *                       destination memory buffer.
395:               *
396:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
397:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
398:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
399:               *                   addresses.
400:               *
401:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
402:               *                   address boundary.
403:               *
404:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
405:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
406:               *                  'mem_align_mod' arithmetic operation.
407:               *********************************************************************************************************
408:               */
409:               
410:               #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
411:               void  Mem_Copy (       void        *pdest,
002E36  A10002     BCLR W2, #0
412:                               const  void        *psrc,
413:                                      CPU_SIZE_T   size)
414:               {
415:                          CPU_SIZE_T    size_rem;
416:                          CPU_SIZE_T    mem_gap_octets;
417:                          CPU_ALIGN    *pmem_align_dest;
418:                   const  CPU_ALIGN    *pmem_align_src;
419:                          CPU_INT08U   *pmem_08_dest;
420:                   const  CPU_INT08U   *pmem_08_src;
421:                          CPU_DATA      i;
422:                          CPU_DATA      mem_align_mod_dest;
423:                          CPU_DATA      mem_align_mod_src;
424:                          CPU_BOOLEAN   mem_aligned;
425:               
426:               
427:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
428:                   if (size < 1) {                                             /* See Note #1.                                         */
429:                       return;
430:                   }
431:                   if (pdest == (void *)0) {
432:                       return;
433:                   }
434:                   if (psrc  == (void *)0) {
435:                       return;
436:                   }
437:               #endif
438:               
439:               
440:                   size_rem           =  size;
002E3E  780082     MOV W2, W1
002E40  370002     BRA 0x2E46
441:               
442:                   pmem_08_dest       = (      CPU_INT08U *)pdest;
443:                   pmem_08_src        = (const CPU_INT08U *)psrc;
002DFC  780181     MOV W1, W3
444:               
445:                   mem_gap_octets     = pmem_08_src - pmem_08_dest;
002DFE  508200     SUB W1, W0, W4
446:               
447:               
448:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
002E00  520FE1     SUB W4, #0x1, [W15]
002E02  36001D     BRA LEU, 0x2E3E
449:                                                                               /* See Note #4.                                         */
450:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
002E04  600261     AND W0, #0x1, W4
451:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
002E06  6082E1     AND W1, #0x1, W5
452:               
453:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
002E08  520F85     SUB W4, W5, [W15]
002E0A  3A0019     BRA NZ, 0x2E3E
454:               
455:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
456:                                                                               /* ... optimize copy for mem buf alignment.             */
457:                           if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
002E0C  E00004     CP0 W4
002E0E  32000A     BRA Z, 0x2E24
002E10  200014     MOV #0x1, W4
002E12  370003     BRA 0x2E1A
458:                               i = mem_align_mod_dest;
459:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
002E1C  E00002     CP0 W2
002E1E  320002     BRA Z, 0x2E24
002E20  520FE1     SUB W4, #0x1, [W15]
002E22  32FFF8     BRA Z, 0x2E14
460:                                      (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
461:                                  *pmem_08_dest++ = *pmem_08_src++;
002E14  785831     MOV.B [W1++], [W0++]
462:                                   size_rem      -=  sizeof(CPU_INT08U);
002E16  E90102     DEC W2, W2
463:                                   i++;
002E18  200024     MOV #0x2, W4
002E1A  780181     MOV W1, W3
464:                               }
465:                           }
466:               
467:                           pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
002E26  780200     MOV W0, W4
468:                           pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
002E24  780283     MOV W3, W5
469:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
002E28  780082     MOV W2, W1
002E2A  370002     BRA 0x2E30
002E30  508FE1     SUB W1, #0x1, [W15]
002E32  3EFFFC     BRA GTU, 0x2E2C
002E34  6100E1     AND W2, #0x1, W1
470:                              *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
002E2C  781A35     MOV [W5++], [W4++]
471:                               size_rem         -=  sizeof(CPU_ALIGN);
002E2E  E98081     DEC2 W1, W1
472:                           }
473:               
474:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
002E38  400002     ADD W0, W2, W0
475:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
002E3A  418182     ADD W3, W2, W3
002E3C  370004     BRA 0x2E46
476:                       }
477:                   }
478:               
479:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
002E46  E00001     CP0 W1
002E48  3AFFFC     BRA NZ, 0x2E42
480:                      *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
002E42  785833     MOV.B [W3++], [W0++]
481:                       size_rem      -=  sizeof(CPU_INT08U);
002E44  E90081     DEC W1, W1
482:                   }
483:               }
002E4A  060000     RETURN
484:               #endif
485:               
486:               
487:               /*
488:               *********************************************************************************************************
489:               *                                             Mem_Move()
490:               *
491:               * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
492:               *               memory buffer. Overlapping is correctly handled for all move operations.
493:               *
494:               * Argument(s) : pdest       Pointer to destination memory buffer.
495:               *
496:               *               psrc        Pointer to source      memory buffer.
497:               *
498:               *               size        Number of octets to move (see Note #1).
499:               *
500:               * Return(s)   : none.
501:               *
502:               * Caller(s)   : Application.
503:               *
504:               * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
505:               *
506:               *               (2) Memory buffers checked for overlapping.
507:               *
508:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
509:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
510:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
511:               *                   addresses.
512:               *
513:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
514:               *                   address boundary.
515:               *
516:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
517:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
518:               *                  'mem_align_mod' arithmetic operation.
519:               *********************************************************************************************************
520:               */
521:               
522:               void  Mem_Move (       void        *pdest,
002E86  E80183     INC W3, W3
002E98  D10102     LSR W2, W2
002E9A  2FFFE1     MOV #0xFFFE, W1
002E9C  B99101     MUL.SS W2, W1, W2
523:                               const  void        *psrc,
524:                                      CPU_SIZE_T   size)
525:               {
526:                          CPU_SIZE_T    size_rem;
527:                          CPU_SIZE_T    mem_gap_octets;
528:                          CPU_ALIGN    *pmem_align_dest;
529:                   const  CPU_ALIGN    *pmem_align_src;
530:                          CPU_INT08U   *pmem_08_dest;
531:                   const  CPU_INT08U   *pmem_08_src;
532:                          CPU_INT08S    i;
533:                          CPU_DATA      mem_align_mod_dest;
534:                          CPU_DATA      mem_align_mod_src;
535:                          CPU_BOOLEAN   mem_aligned;
536:               
537:               
538:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
539:                   if (size < 1) {
540:                       return;
541:                   }
542:                   if (pdest == (void *)0) {
543:                       return;
544:                   }
545:                   if (psrc  == (void *)0) {
546:                       return;
547:                   }
548:               #endif
549:               
550:                   pmem_08_src  = (const CPU_INT08U *)psrc;
551:                   pmem_08_dest = (      CPU_INT08U *)pdest;
552:                   if (pmem_08_src > pmem_08_dest) {
002E4C  508F80     SUB W1, W0, [W15]
002E4E  360001     BRA LEU, 0x2E52
553:                       Mem_Copy(pdest, psrc, size);
002E50  37FFD5     BRA Mem_Copy
554:                       return;
555:                   }
556:               
557:                   size_rem           =  size;
002EA8  780202     MOV W2, W4
002EAA  370002     BRA 0x2EB0
558:               
559:                   pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
002E52  E90182     DEC W2, W3
002E54  400003     ADD W0, W3, W0
560:                   pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
002E56  408183     ADD W1, W3, W3
561:               
562:                   mem_gap_octets     = pmem_08_dest - pmem_08_src;
002E58  500083     SUB W0, W3, W1
563:               
564:               
565:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
002E5A  508FE1     SUB W1, #0x1, [W15]
002E5C  360025     BRA LEU, 0x2EA8
566:               
567:                                                                               /* See Note #4.                                         */
568:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
002E5E  600261     AND W0, #0x1, W4
569:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
002E60  780083     MOV W3, W1
002E62  6182E1     AND W3, #0x1, W5
570:               
571:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
002E64  520F85     SUB W4, W5, [W15]
002E66  3A0020     BRA NZ, 0x2EA8
572:               
573:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
574:                                                                               /* ... optimize copy for mem buf alignment.             */
575:                           if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
002E68  520FE1     SUB W4, #0x1, [W15]
002E6A  3A0005     BRA NZ, 0x2E76
002E6C  37000A     BRA 0x2E82
002E76  EB4200     CLR.B W4
576:                               i = mem_align_mod_dest;
577:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
002E7A  E00002     CP0 W2
002E7C  320002     BRA Z, 0x2E82
002E7E  E00404     CP0.B W4
002E80  32FFF6     BRA Z, 0x2E6E
578:                                      (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
579:                                  *pmem_08_dest-- = *pmem_08_src--;
002E6E  785021     MOV.B [W1--], [W0--]
580:                                   size_rem      -=  sizeof(CPU_INT08U);
002E70  E90102     DEC W2, W2
581:                                   i--;
002E72  EBC200     SETM.B W4
002E74  370001     BRA 0x2E78
002E78  780181     MOV W1, W3
582:                               }
583:                           }
584:               
585:                                                                               /* See Note #3.                                         */
586:                           pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
002E82  E90000     DEC W0, W0
002E88  780280     MOV W0, W5
587:                           pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
002E84  E90303     DEC W3, W6
588:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
002E8A  780202     MOV W2, W4
002E8C  370002     BRA 0x2E92
002E92  520FE1     SUB W4, #0x1, [W15]
002E94  3EFFFC     BRA GTU, 0x2E8E
002E96  610261     AND W2, #0x1, W4
589:                              *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
002E8E  7812C3     MOV [--W3], [W5--]
590:                               size_rem         -=  sizeof(CPU_ALIGN);
002E90  E98204     DEC2 W4, W4
591:                           }
592:               
593:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
002E9E  400002     ADD W0, W2, W0
002EA0  E80000     INC W0, W0
594:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
002EA2  430182     ADD W6, W2, W3
002EA4  E80183     INC W3, W3
002EA6  370004     BRA 0x2EB0
595:               
596:                       }
597:                   }
598:               
599:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
002EB0  E00004     CP0 W4
002EB2  3AFFFC     BRA NZ, 0x2EAC
002EB4  060000     RETURN
600:                      *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
002EAC  785023     MOV.B [W3--], [W0--]
601:                       size_rem      -=  sizeof(CPU_INT08U);
002EAE  E90204     DEC W4, W4
602:                   }
603:               }
604:               
605:               
606:               /*
607:               *********************************************************************************************************
608:               *                                              Mem_Cmp()
609:               *
610:               * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
611:               *
612:               * Argument(s) : p1_mem      Pointer to first  memory buffer.
613:               *
614:               *               p2_mem      Pointer to second memory buffer.
615:               *
616:               *               size        Number of data buffer octets to compare (see Note #1).
617:               *
618:               * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
619:               *
620:               *               DEF_NO,  otherwise.
621:               *
622:               * Caller(s)   : Application.
623:               *
624:               * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
625:               *                   identical null compare.
626:               *
627:               *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
628:               *                   network address buffers.  Consequently, memory buffer comparison is more efficient
629:               *                   if the comparison starts from the end of the memory buffers which will abort sooner
630:               *                   on dissimilar memory buffers that vary only in the least significant octets.
631:               *
632:               *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
633:               *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
634:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
635:               *                   addresses.
636:               *
637:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
638:               *                   address boundary.
639:               *
640:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
641:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
642:               *                  'mem_align_mod' arithmetic operation.
643:               *********************************************************************************************************
644:               */
645:               
646:               CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
647:                                     const  void        *p2_mem,
648:                                            CPU_SIZE_T   size)
649:               {
650:                          CPU_SIZE_T    size_rem;
651:                          CPU_ALIGN    *p1_mem_align;
652:                          CPU_ALIGN    *p2_mem_align;
653:                   const  CPU_INT08U   *p1_mem_08;
654:                   const  CPU_INT08U   *p2_mem_08;
655:                          CPU_DATA      i;
656:                          CPU_DATA      mem_align_mod_1;
657:                          CPU_DATA      mem_align_mod_2;
658:                          CPU_BOOLEAN   mem_aligned;
659:                          CPU_BOOLEAN   mem_cmp;
660:               
661:               
662:                   if (size < 1) {                                             /* See Note #1.                                         */
002EB8  E00002     CP0 W2
002EBA  32002A     BRA Z, 0x2F10
663:                       return (DEF_YES);
002EB6  B3C013     MOV.B #0x1, W3
664:                   }
665:                   if (p1_mem == (void *)0) {
002EBE  E00000     CP0 W0
002EC0  320027     BRA Z, 0x2F10
666:                       return (DEF_NO);
002EBC  EB4180     CLR.B W3
667:                   }
668:                   if (p2_mem == (void *)0) {
002EC2  E00001     CP0 W1
002EC4  320025     BRA Z, 0x2F10
669:                       return (DEF_NO);
670:                   }
671:               
672:               
673:                   mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
002EF4  B3C013     MOV.B #0x1, W3
002EF6  370006     BRA 0x2F04
674:                   size_rem        =  size;
675:                                                                               /* Start @ end of mem bufs (see Note #2).               */
676:                   p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
002EC6  400002     ADD W0, W2, W0
677:                   p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
002EC8  408082     ADD W1, W2, W1
678:                                                                               /* See Note #4.                                         */
679:                   mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
002ECA  6001E1     AND W0, #0x1, W3
680:                   mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
002ECC  608261     AND W1, #0x1, W4
681:               
682:                   mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
002ECE  518F84     SUB W3, W4, [W15]
002ED0  3A0011     BRA NZ, 0x2EF4
683:               
684:                   if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
685:                                                                               /* ... optimize cmp for mem buf alignment.              */
686:                       if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
002ED2  E00003     CP0 W3
002ED4  32000A     BRA Z, 0x2EEA
687:                           i = mem_align_mod_1;
688:                           while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
002ED8  EB4180     CLR.B W3
002EDA  784240     MOV.B [--W0], W4
002EDC  524FC1     SUB.B W4, [--W1], [W15]
002EDE  320005     BRA Z, 0x2EEA
002EE0  370011     BRA 0x2F04
689:                                  (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
690:                                  (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
691:                               p1_mem_08--;
692:                               p2_mem_08--;
693:                               if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
694:                                    mem_cmp = DEF_NO;
695:                               }
696:                               size_rem -= sizeof(CPU_INT08U);
002ED6  E90102     DEC W2, W2
697:                               i--;
698:                           }
699:                       }
700:               
701:                       if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
702:                           p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
703:                           p2_mem_align = (CPU_ALIGN *)p2_mem_08;
704:               
705:                           while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
002EE4  7801C0     MOV [--W0], W3
002EE6  518FC1     SUB W3, [--W1], [W15]
002EE8  3A0003     BRA NZ, 0x2EF0
002EEA  510FE1     SUB W2, #0x1, [W15]
002EEC  3EFFFA     BRA GTU, 0x2EE2
002EEE  370002     BRA 0x2EF4
002EF0  EB4180     CLR.B W3
002EF2  370008     BRA 0x2F04
706:                                  (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
707:                               p1_mem_align--;
708:                               p2_mem_align--;
709:                               if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
710:                                    mem_cmp = DEF_NO;
711:                               }
712:                               size_rem -= sizeof(CPU_ALIGN);
002EE2  E98102     DEC2 W2, W2
713:                           }
714:               
715:                           p1_mem_08 = (CPU_INT08U *)p1_mem_align;
716:                           p2_mem_08 = (CPU_INT08U *)p2_mem_align;
717:                       }
718:                   }
719:               
720:                   while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
002F04  51CFE1     SUB.B W3, #0x1, [W15]
002F06  3A0003     BRA NZ, 0x2F0E
002F08  E00002     CP0 W2
002F0A  3AFFF6     BRA NZ, 0x2EF8
002F0C  370001     BRA 0x2F10
002F0E  EB4180     CLR.B W3
721:                          (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
722:                       p1_mem_08--;
723:                       p2_mem_08--;
724:                       if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
725:                            mem_cmp = DEF_NO;
002EF8  784240     MOV.B [--W0], W4
002EFA  6A41C1     XOR.B W4, [--W1], W3
002EFC  FB8183     ZE W3, W3
002EFE  E90183     DEC W3, W3
002F00  DE19CF     LSR W3, #15, W3
726:                       }
727:                       size_rem -= sizeof(CPU_INT08U);
002F02  E90102     DEC W2, W2
728:                   }
729:               
730:                   return (mem_cmp);
731:               }
002F10  784003     MOV.B W3, W0
002F12  060000     RETURN
732:               
733:               
734:               /*
735:               *********************************************************************************************************
736:               *                                           Mem_HeapAlloc()
737:               *
738:               * Description : Allocates a memory block from the heap memory segment.
739:               *
740:               * Argument(s) : size            Size      of memory block to allocate (in bytes).
741:               *
742:               *               align           Alignment of memory block to specific word boundary (in bytes).
743:               *
744:               *               p_bytes_reqd    Optional pointer to a variable to ... :
745:               *
746:               *                                   (a) Return the number of bytes required to successfully
747:               *                                           allocate the memory block, if any error(s);
748:               *                                   (b) Return 0, otherwise.
749:               *
750:               *               p_err           Pointer to variable that will receive the return error code from this function :
751:               *
752:               *                                   LIB_MEM_ERR_NONE                Operation was successful.
753:               *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
754:               *
755:               *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
756:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
757:               *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
758:               *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
759:               *
760:               * Return(s)   : Pointer to memory block, if NO error(s).
761:               *
762:               *               Pointer to NULL,         otherwise.
763:               *
764:               * Caller(s)   : Application.
765:               *
766:               * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
767:               *                   validation or function handling in case of any error(s).
768:               *
769:               *               (2) This function is DEPRECATED and will be removed in a future version of this product.
770:               *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
771:               *********************************************************************************************************
772:               */
773:               
774:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
775:               void  *Mem_HeapAlloc (CPU_SIZE_T   size,
776:                                     CPU_SIZE_T   align,
777:                                     CPU_SIZE_T  *p_bytes_reqd,
778:                                     LIB_ERR     *p_err)
779:               {
002F14  781F88     MOV W8, [W15++]
002F16  780282     MOV W2, W5
002F18  780403     MOV W3, W8
780:                   void  *p_mem;
781:               
782:               
783:                   p_mem = Mem_SegAllocInternal(DEF_NULL,
002F1A  780308     MOV W8, W6
002F1C  200014     MOV #0x1, W4
002F1E  BE0100     MOV.D W0, W2
002F20  2154A1     MOV #0x154A, W1
002F22  EB0000     CLR W0
002F24  07FEDB     RCALL _Mem_SegAllocInternal
784:                                               &Mem_SegHeap,
785:                                                size,
786:                                                align,
787:                                                LIB_MEM_CFG_HEAP_PADDING_ALIGN,
788:                                                p_bytes_reqd,
789:                                                p_err);
790:                   if (*p_err == LIB_MEM_ERR_SEG_OVF) {
002F26  227D91     MOV #0x27D9, W1
002F28  108F98     SUBR W1, [W8], [W15]
002F2A  3A0002     BRA NZ, 0x2F30
791:                      *p_err = LIB_MEM_ERR_HEAP_OVF;
002F2C  4080EA     ADD W1, #0xA, W1
002F2E  780C01     MOV W1, [W8]
792:                   }
793:               
794:                   return (p_mem);
795:               }
002F30  78044F     MOV [--W15], W8
002F32  060000     RETURN
796:               #endif
797:               
798:               
799:               /*
800:               *********************************************************************************************************
801:               *                                        Mem_HeapGetSizeRem()
802:               *
803:               * Description : Gets remaining heap memory size available to allocate.
804:               *
805:               * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
806:               *
807:               *               p_err       Pointer to variable that will receive the return error code from this function
808:               *
809:               *                               LIB_MEM_ERR_NONE                Operation was successful.
810:               *
811:               *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
812:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
813:               *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
814:               *
815:               * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
816:               *
817:               *               0,                                     otherwise.
818:               *
819:               * Caller(s)   : Application.
820:               *
821:               * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
822:               *                   Mem_SegRemSizeGet() should be used instead.
823:               *********************************************************************************************************
824:               */
825:               
826:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
827:               CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
828:                                               LIB_ERR     *p_err)
829:               {
002FCA  781F88     MOV W8, [W15++]
002FCC  780401     MOV W1, W8
830:                   CPU_SIZE_T  rem_size;
831:               
832:               
833:                   rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
002FCE  780188     MOV W8, W3
002FD0  EB0100     CLR W2
002FD2  780080     MOV W0, W1
002FD4  2154A0     MOV #0x154A, W0
002FD6  07FFD8     RCALL Mem_SegRemSizeGet
834:                                                 align,
835:                                                 DEF_NULL,
836:                                                 p_err);
837:                   if (*p_err != LIB_MEM_ERR_NONE) {
002FD8  227101     MOV #0x2710, W1
002FDA  108F98     SUBR W1, [W8], [W15]
002FDC  320001     BRA Z, 0x2FE0
838:                       return (0u);
002FDE  EB0000     CLR W0
839:                   }
840:               
841:                   return (rem_size);
842:               }
002FE0  78044F     MOV [--W15], W8
002FE2  060000     RETURN
843:               #endif
844:               
845:               
846:               /*
847:               *********************************************************************************************************
848:               *                                            Mem_SegCreate()
849:               *
850:               * Description : Creates a new memory segment to be used for runtime memory allocation.
851:               *
852:               * Argument(s) : p_name          Pointer to segment name.
853:               *
854:               *               p_seg           Pointer to segment data. Must be allocated by caller.
855:               *
856:               *               seg_base_addr   Address of segment's first byte.
857:               *
858:               *               size            Total size of segment, in bytes.
859:               *
860:               *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
861:               *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
862:               *                               means no padding.
863:               *
864:               *               p_err           Pointer to variable that will receive the return error code from this function :
865:               *
866:               *                                   LIB_MEM_ERR_NONE                    Operation was successful.
867:               *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
868:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
869:               *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
870:               *
871:               *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
872:               *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
873:               *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
874:               *
875:               * Return(s)   : None.
876:               *
877:               * Caller(s)   : Application.
878:               *
879:               * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
880:               *                   to be maintained during the whole list search and add procedure to prevent a reentrant
881:               *                   call from creating another segment overlapping with the one being added.
882:               *********************************************************************************************************
883:               */
884:               
885:               void  Mem_SegCreate (const  CPU_CHAR    *p_name,
886:                                           MEM_SEG     *p_seg,
887:                                           CPU_ADDR     seg_base_addr,
888:                                           CPU_SIZE_T   size,
889:                                           CPU_SIZE_T   padding_align,
890:                                           LIB_ERR     *p_err)
891:               {
002F34  BE9F88     MOV.D W8, [W15++]
002F36  780380     MOV W0, W7
002F38  780304     MOV W4, W6
002F3A  780405     MOV W5, W8
892:                   CPU_SR_ALLOC();
893:               
894:               
895:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
896:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
897:                       CPU_SW_EXCEPTION(;);
898:                   }
899:               
900:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
901:                      *p_err = LIB_MEM_ERR_NULL_PTR;
902:                       return;
903:                   }
904:               
905:                   if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
906:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
907:                       return;
908:                   }
909:                                                                               /* Chk for addr space ovf.                              */
910:                   if (seg_base_addr + (size - 1u) < seg_base_addr) {
911:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
912:                       return;
913:                   }
914:               
915:                   if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
916:                       (MATH_IS_PWR2(padding_align) != DEF_YES)) {
917:                      *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
918:                       return;
919:                   }
920:               #endif
921:               
922:                   CPU_CRITICAL_ENTER();
002F3C  800219     MOV SR, W9
002F3E  200E00     MOV #0xE0, W0
002F40  B72042     IOR SR
923:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
924:                   (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
925:                                                   size,
926:                                                   p_err);
927:                   if (*p_err != LIB_MEM_ERR_NONE) {
928:                       CPU_CRITICAL_EXIT();
929:                       return;
930:                   }
931:               #endif
932:               
933:                   Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
002F42  780203     MOV W3, W4
002F44  780186     MOV W6, W3
002F46  780007     MOV W7, W0
002F48  07FE78     RCALL _Mem_SegCreateCritical
934:                                         p_seg,
935:                                         seg_base_addr,
936:                                         padding_align,
937:                                         size);
938:                   CPU_CRITICAL_EXIT();
002F4A  880219     MOV W9, SR
939:               
940:                  *p_err = LIB_MEM_ERR_NONE;
002F4C  227100     MOV #0x2710, W0
002F4E  780C00     MOV W0, [W8]
941:               }
002F50  BE044F     MOV.D [--W15], W8
002F52  060000     RETURN
942:               
943:               
944:               /*
945:               *********************************************************************************************************
946:               *                                            Mem_SegClr()
947:               *
948:               * Description : Clears a memory segment.
949:               *
950:               * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
951:               *
952:               *               p_err           Pointer to variable that will receive the return error code from this function :
953:               *
954:               *                               LIB_MEM_ERR_NONE                Operation was successful.
955:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
956:               *
957:               * Return(s)   : None.
958:               *
959:               * Caller(s)   : Application.
960:               *
961:               * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
962:               *                   segments that are no longer used.
963:               *
964:               *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
965:               *********************************************************************************************************
966:               */
967:               
968:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)
969:               void  Mem_SegClr (MEM_SEG  *p_seg,
970:                                 LIB_ERR  *p_err)
971:               {
002F74  780200     MOV W0, W4
972:                   CPU_SR_ALLOC();
973:               
974:               
975:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
976:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
977:                       CPU_SW_EXCEPTION(;);
978:                   }
979:               
980:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
981:                      *p_err = LIB_MEM_ERR_NULL_PTR;
982:                       return;
983:                   }
984:               #endif
985:               
986:                   CPU_CRITICAL_ENTER();
002F76  800212     MOV SR, W2
002F78  200E00     MOV #0xE0, W0
002F7A  B72042     IOR SR
987:                   p_seg->AddrNext = p_seg->AddrBase;
002F7C  780014     MOV [W4], W0
002F7E  980220     MOV W0, [W4+4]
988:                   CPU_CRITICAL_EXIT();
002F80  880212     MOV W2, SR
989:               
990:                  *p_err = LIB_MEM_ERR_NONE;
002F82  227100     MOV #0x2710, W0
002F84  780880     MOV W0, [W1]
991:               }
002F86  060000     RETURN
992:               #endif
993:               
994:               
995:               /*
996:               *********************************************************************************************************
997:               *                                         Mem_SegRemSizeGet()
998:               *
999:               * Description : Gets free space of memory segment.
1000:              *
1001:              * Argument(s) : p_seg       Pointer to segment data.
1002:              *
1003:              *               align       Alignment in bytes to assume for calculation of free space.
1004:              *
1005:              *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
1006:              *                           total size, base address and next allocation address).
1007:              *
1008:              *               p_err       Pointer to variable that will receive the return error code from this function :
1009:              *
1010:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1011:              *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
1012:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
1013:              *
1014:              * Return(s)   : Memory segment remaining size in bytes,     if successful.
1015:              *               0,                                          otherwise or if memory segment empty.
1016:              *
1017:              * Caller(s)   : Application,
1018:              *               Mem_HeapGetSizeRem(),
1019:              *               Mem_OutputUsage().
1020:              *
1021:              * Note(s)     : None.
1022:              *********************************************************************************************************
1023:              */
1024:              
1025:              CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
1026:                                             CPU_SIZE_T     align,
1027:                                             MEM_SEG_INFO  *p_seg_info,
1028:                                             LIB_ERR       *p_err)
1029:              {
002F88  781F88     MOV W8, [W15++]
002F8A  780400     MOV W0, W8
1030:                  CPU_SIZE_T  rem_size;
1031:                  CPU_SIZE_T  total_size;
1032:                  CPU_SIZE_T  used_size;
1033:                  CPU_ADDR    next_addr_align;
1034:                  CPU_SR_ALLOC();
1035:              
1036:              
1037:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1038:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
1039:                      CPU_SW_EXCEPTION(seg_info);
1040:                  }
1041:              
1042:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
1043:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
1044:                      return (0u);
1045:                  }
1046:              #endif
1047:              
1048:                  if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
002F8C  E00008     CP0 W8
002F8E  3A0001     BRA NZ, 0x2F92
1049:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1050:                      p_seg = &Mem_SegHeap;
002F90  2154A8     MOV #0x154A, W8
1051:              #else
1052:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1053:                      return (0u);
1054:              #endif
1055:                  }
1056:              
1057:                  CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
002F92  800215     MOV SR, W5
002F94  200E00     MOV #0xE0, W0
002F96  B72042     IOR SR
1058:                  next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
002F98  900228     MOV [W8+4], W4
002F9A  EA0301     NEG W1, W6
002F9C  630304     AND W6, W4, W6
002F9E  E90381     DEC W1, W7
002FA0  638204     AND W7, W4, W4
002FA2  3A0001     BRA NZ, 0x2FA6
002FA4  EB0080     CLR W1
002FA6  408086     ADD W1, W6, W1
1059:                  CPU_CRITICAL_EXIT();
002FA8  880215     MOV W5, SR
1060:              
1061:                  total_size = p_seg->AddrEnd  - p_seg->AddrBase + 1u;
002FAA  780218     MOV [W8], W4
002FAC  900318     MOV [W8+2], W6
002FAE  E80306     INC W6, W6
002FB0  530304     SUB W6, W4, W6
1062:                  used_size  = next_addr_align - p_seg->AddrBase;
002FB2  508284     SUB W1, W4, W5
1063:                  rem_size   = total_size      - used_size;
002FB4  530005     SUB W6, W5, W0
1064:              
1065:                  if (p_seg_info != DEF_NULL) {
002FB6  E00002     CP0 W2
002FB8  320004     BRA Z, 0x2FC2
1066:                      p_seg_info->TotalSize     = total_size;
002FBA  980116     MOV W6, [W2+2]
1067:                      p_seg_info->UsedSize      = used_size;
002FBC  780905     MOV W5, [W2]
1068:                      p_seg_info->AddrBase      = p_seg->AddrBase;
002FBE  980124     MOV W4, [W2+4]
1069:                      p_seg_info->AddrNextAlloc = next_addr_align;
002FC0  980131     MOV W1, [W2+6]
1070:                  }
1071:              
1072:                 *p_err = LIB_MEM_ERR_NONE;
002FC2  227101     MOV #0x2710, W1
002FC4  780981     MOV W1, [W3]
1073:              
1074:                  return (rem_size);
1075:              }
002FC6  78044F     MOV [--W15], W8
002FC8  060000     RETURN
1076:              
1077:              
1078:              /*
1079:              *********************************************************************************************************
1080:              *                                            Mem_SegAlloc()
1081:              *
1082:              * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
1083:              *               word boundary.
1084:              *
1085:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1086:              *
1087:              *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
1088:              *                       general-purpose heap if null.
1089:              *
1090:              *               size    Size of memory block to allocate, in bytes.
1091:              *
1092:              *               p_err   Pointer to variable that will receive the return error code from this function :
1093:              *
1094:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1095:              *
1096:              *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1097:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1098:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1099:              *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1100:              *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1101:              *
1102:              * Return(s)   : Pointer to allocated memory block, if successful.
1103:              *
1104:              *               DEF_NULL, otherwise.
1105:              *
1106:              * Caller(s)   : Application.
1107:              *
1108:              * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
1109:              *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
1110:              *                   Mem_SegAllocHW().
1111:              *********************************************************************************************************
1112:              */
1113:              
1114:              void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
1115:                                          MEM_SEG     *p_seg,
1116:                                          CPU_SIZE_T   size,
1117:                                          LIB_ERR     *p_err)
1118:              {
1119:                  void  *p_blk;
1120:              
1121:              
1122:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
002FE4  E00001     CP0 W1
002FE6  3A0001     BRA NZ, 0x2FEA
1123:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1124:                      p_seg = &Mem_SegHeap;
002FE8  2154A1     MOV #0x154A, W1
1125:              #else
1126:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1127:                      return (DEF_NULL);
1128:              #endif
1129:                  }
1130:              
1131:                  p_blk = Mem_SegAllocInternal(p_name,
002FEA  780303     MOV W3, W6
002FEC  EB0280     CLR W5
002FEE  200014     MOV #0x1, W4
002FF0  200023     MOV #0x2, W3
002FF2  37FE74     BRA _Mem_SegAllocInternal
1132:                                               p_seg,
1133:                                               size,
1134:                                               sizeof(CPU_ALIGN),
1135:                                               LIB_MEM_PADDING_ALIGN_NONE,
1136:                                               DEF_NULL,
1137:                                               p_err);
1138:              
1139:                  return (p_blk);
1140:              }
1141:              
1142:              
1143:              /*
1144:              *********************************************************************************************************
1145:              *                                           Mem_SegAllocExt()
1146:              *
1147:              * Description : Allocates memory from specified memory segment.
1148:              *
1149:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1150:              *
1151:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1152:              *                               general-purpose heap if null.
1153:              *
1154:              *               size            Size of memory block to allocate, in bytes.
1155:              *
1156:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1157:              *
1158:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1159:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1160:              *
1161:              *               p_err           Pointer to variable that will receive the return error code from this function :
1162:              *
1163:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1164:              *
1165:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1166:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1167:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1168:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1169:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1170:              *
1171:              * Return(s)   : Pointer to allocated memory block, if successful.
1172:              *
1173:              *               DEF_NULL, otherwise.
1174:              *
1175:              * Caller(s)   : Application.
1176:              *
1177:              * Note(s)     : none.
1178:              *********************************************************************************************************
1179:              */
1180:              
1181:              void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
1182:                                             MEM_SEG     *p_seg,
1183:                                             CPU_SIZE_T   size,
1184:                                             CPU_SIZE_T   align,
1185:                                             CPU_SIZE_T  *p_bytes_reqd,
1186:                                             LIB_ERR     *p_err)
1187:              {
1188:                  void  *p_blk;
1189:              
1190:              
1191:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
002FF4  E00001     CP0 W1
002FF6  3A0001     BRA NZ, 0x2FFA
1192:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1193:                      p_seg = &Mem_SegHeap;
002FF8  2154A1     MOV #0x154A, W1
1194:              #else
1195:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1196:                      return (DEF_NULL);
1197:              #endif
1198:                  }
1199:              
1200:                  p_blk = Mem_SegAllocInternal(p_name,
002FFA  780305     MOV W5, W6
002FFC  780284     MOV W4, W5
002FFE  200014     MOV #0x1, W4
003000  37FE6D     BRA _Mem_SegAllocInternal
1201:                                               p_seg,
1202:                                               size,
1203:                                               align,
1204:                                               LIB_MEM_PADDING_ALIGN_NONE,
1205:                                               p_bytes_reqd,
1206:                                               p_err);
1207:              
1208:                  return (p_blk);
1209:              }
1210:              
1211:              
1212:              /*
1213:              *********************************************************************************************************
1214:              *                                          Mem_SegAllocHW()
1215:              *
1216:              * Description : Allocates memory from specified segment. The returned buffer will be padded in function
1217:              *               of memory segment's properties.
1218:              *
1219:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1220:              *
1221:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1222:              *                               general-purpose heap if null.
1223:              *
1224:              *               size            Size of memory block to allocate, in bytes.
1225:              *
1226:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1227:              *
1228:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1229:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1230:              *
1231:              *               p_err           Pointer to variable that will receive the return error code from this function :
1232:              *
1233:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1234:              *
1235:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1236:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1237:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1238:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1239:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1240:              *
1241:              * Return(s)   : Pointer to allocated memory block, if successful.
1242:              *
1243:              *               DEF_NULL, otherwise.
1244:              *
1245:              * Caller(s)   : Application.
1246:              *
1247:              * Note(s)     : none.
1248:              *********************************************************************************************************
1249:              */
1250:              
1251:              void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
1252:                                            MEM_SEG     *p_seg,
1253:                                            CPU_SIZE_T   size,
1254:                                            CPU_SIZE_T   align,
1255:                                            CPU_SIZE_T  *p_bytes_reqd,
1256:                                            LIB_ERR     *p_err)
1257:              {
1258:                  void  *p_blk;
1259:              
1260:              
1261:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
003002  E00001     CP0 W1
003004  3A0001     BRA NZ, 0x3008
1262:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1263:                      p_seg = &Mem_SegHeap;
003006  2154A1     MOV #0x154A, W1
1264:              #else
1265:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1266:                      return (DEF_NULL);
1267:              #endif
1268:                  }
1269:              
1270:                  p_blk = Mem_SegAllocInternal(p_name,
003008  780305     MOV W5, W6
00300A  780284     MOV W4, W5
00300C  900241     MOV [W1+8], W4
00300E  37FE66     BRA _Mem_SegAllocInternal
1271:                                               p_seg,
1272:                                               size,
1273:                                               align,
1274:                                               p_seg->PaddingAlign,
1275:                                               p_bytes_reqd,
1276:                                               p_err);
1277:              
1278:                  return (p_blk);
1279:              }
1280:              
1281:              
1282:              /*
1283:              *********************************************************************************************************
1284:              *                                          Mem_PoolCreate()
1285:              *
1286:              * Description : (1) Creates a memory pool :
1287:              *
1288:              *                   (a) Create    memory pool from heap or dedicated memory
1289:              *                   (b) Allocate  memory pool memory blocks
1290:              *                   (c) Configure memory pool
1291:              *
1292:              *
1293:              * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
1294:              *
1295:              *               p_mem_base      Memory pool segment base address :
1296:              *
1297:              *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
1298:              *                                       (b) Non-null address    Memory pool allocated from dedicated memory
1299:              *                                                                   specified by its base address.
1300:              *
1301:              *               mem_size        Size      of memory pool segment          (in bytes).
1302:              *
1303:              *               blk_nbr         Number    of memory pool blocks to create.
1304:              *
1305:              *               blk_size        Size      of memory pool blocks to create (in bytes).
1306:              *
1307:              *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
1308:              *
1309:              *               p_bytes_reqd    Optional pointer to a variable to ... :
1310:              *
1311:              *                                   (a) Return the number of bytes required to successfully
1312:              *                                               allocate the memory pool, if any error(s);
1313:              *                                       (b) Return 0, otherwise.
1314:              *
1315:              *               p_err           Pointer to variable that will receive the return error code from this function :
1316:              *
1317:              *                                   LIB_MEM_ERR_NONE                    Operation was successful.
1318:              *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
1319:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
1320:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
1321:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
1322:              *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
1323:              *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
1324:              *
1325:              *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
1326:              *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
1327:              *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
1328:              *
1329:              *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
1330:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1331:              *
1332:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1333:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1334:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1335:              *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1336:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1337:              *
1338:              *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
1339:              *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
1340:              *
1341:              * Return(s)   : none.
1342:              *
1343:              * Caller(s)   : Application.
1344:              *
1345:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1346:              *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1351:              void  Mem_PoolCreate (MEM_POOL          *p_pool,
1352:                                    void              *p_mem_base,
1353:                                    CPU_SIZE_T         mem_size,
1354:                                    MEM_POOL_BLK_QTY   blk_nbr,
1355:                                    CPU_SIZE_T         blk_size,
1356:                                    CPU_SIZE_T         blk_align,
1357:                                    CPU_SIZE_T        *p_bytes_reqd,
1358:                                    LIB_ERR           *p_err)
1359:              {
003024  4787EC     ADD W15, #0xC, W15
003026  BE9F88     MOV.D W8, [W15++]
003028  BE9F8A     MOV.D W10, [W15++]
00302A  BE9F8C     MOV.D W12, [W15++]
00302C  781F8E     MOV W14, [W15++]
00302E  780480     MOV W0, W9
003030  9FB7F1     MOV W1, [W15-18]
003032  9FB7D2     MOV W2, [W15-22]
003034  780503     MOV W3, W10
003036  9FB7C4     MOV W4, [W15-24]
003038  780605     MOV W5, W12
00303A  9FB7E6     MOV W6, [W15-20]
00303C  780407     MOV W7, W8
1360:                  MEM_SEG           *p_seg;
1361:                  void              *p_pool_mem;
1362:                  CPU_SIZE_T         pool_size;
1363:                  CPU_SIZE_T         blk_size_align;
1364:                  CPU_ADDR           pool_addr_end;
1365:                  MEM_POOL_BLK_QTY   blk_ix;
1366:                  CPU_INT08U        *p_blk;
1367:                  CPU_SR_ALLOC();
1368:              
1369:              
1370:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
1371:                  if (p_err == DEF_NULL) {
1372:                      CPU_SW_EXCEPTION(;);
1373:                  }
1374:              
1375:                                                                              /* ------------- VALIDATE MEM POOL CREATE ------------- */
1376:                  if (p_pool == DEF_NULL) {
1377:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1378:                      return;
1379:                  }
1380:              
1381:                  if (p_mem_base != DEF_NULL) {
1382:                      if (mem_size < 1u) {
1383:                         *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
1384:                          return;
1385:                      }
1386:                  }
1387:              
1388:                  if (blk_nbr < 1u) {
1389:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
1390:                      return;
1391:                  }
1392:              
1393:                  if (blk_size < 1u) {
1394:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1395:                      return;
1396:                  }
1397:              
1398:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
1399:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
1400:                      return;
1401:                  }
1402:              #endif
1403:              
1404:                  Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
00303E  780088     MOV W8, W1
003040  780009     MOV W9, W0
003042  07FFE6     RCALL Mem_PoolClr
1405:                  if (*p_err != LIB_MEM_ERR_NONE) {
003044  780198     MOV [W8], W3
003046  227100     MOV #0x2710, W0
003048  518F80     SUB W3, W0, [W15]
00304A  3A005C     BRA NZ, 0x3104
1406:                       return;
1407:                  }
1408:              
1409:                                                                              /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
1410:                  if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
00304C  97B07F     MOV [W15-18], W0
00304E  E00000     CP0 W0
003050  320026     BRA Z, 0x309E
1411:                      p_seg = &Mem_SegHeap;
00309E  2154AB     MOV #0x154A, W11
1412:                  } else {                                                    /* Use other seg.                                       */
1413:                      CPU_CRITICAL_ENTER();
003052  80021E     MOV SR, W14
003054  200E00     MOV #0xE0, W0
003056  B72042     IOR SR
1414:                      p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
003058  780108     MOV W8, W2
00305A  97B0DF     MOV [W15-22], W1
00305C  97B07F     MOV [W15-18], W0
00305E  9FBF83     MOV W3, [W15-16]
003060  07FDF8     RCALL _Mem_SegOverlapChkCritical
003062  780580     MOV W0, W11
1415:                                                                  mem_size,
1416:                                                                  p_err);
1417:                      switch (*p_err) {
003064  780698     MOV [W8], W13
003066  97B98F     MOV [W15-16], W3
003068  568F83     SUB W13, W3, [W15]
00306A  320004     BRA Z, 0x3074
00306C  227800     MOV #0x2780, W0
00306E  568F80     SUB W13, W0, [W15]
003070  3A0012     BRA NZ, 0x3096
003072  370013     BRA 0x309A
1418:                          case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
1419:                               break;
1420:              
1421:                          case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
1422:                               p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
003074  780288     MOV W8, W5
003076  97B26F     MOV [W15-20], W4
003078  200013     MOV #0x1, W3
00307A  200022     MOV #0x2, W2
00307C  2000A1     MOV #0xA, W1
00307E  2154A0     MOV #0x154A, W0
003080  07FE05     RCALL _Mem_SegAllocExtCritical
003086  780580     MOV W0, W11
1423:                                                                           sizeof(MEM_SEG),
1424:                                                                           sizeof(CPU_ALIGN),
1425:                                                                           LIB_MEM_PADDING_ALIGN_NONE,
1426:                                                                           p_bytes_reqd,
1427:                                                                           p_err);
1428:                               if (*p_err != LIB_MEM_ERR_NONE) {
003082  168F98     SUBR W13, [W8], [W15]
003084  3A0008     BRA NZ, 0x3096
1429:                                   CPU_CRITICAL_EXIT();
1430:                                   return;
1431:                               }
1432:              
1433:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
1434:                               Mem_SegAllocTrackCritical("Unknown segment data",
1435:                                                         &Mem_SegHeap,
1436:                                                          sizeof(MEM_SEG),
1437:                                                          p_err);
1438:                               if (*p_err != LIB_MEM_ERR_NONE) {
1439:                                   CPU_CRITICAL_EXIT();
1440:                                   return;
1441:                               }
1442:              #endif
1443:              
1444:                               Mem_SegCreateCritical(          DEF_NULL,
003088  97B25F     MOV [W15-22], W4
00308A  200013     MOV #0x1, W3
00308C  97B17F     MOV [W15-18], W2
00308E  78008B     MOV W11, W1
003090  EB0000     CLR W0
003092  07FDD3     RCALL _Mem_SegCreateCritical
1445:                                                               p_seg,
1446:                                                     (CPU_ADDR)p_mem_base,
1447:                                                               LIB_MEM_PADDING_ALIGN_NONE,
1448:                                                               mem_size);
1449:                               break;
003094  370002     BRA 0x309A
1450:              
1451:              
1452:                          case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
1453:                          default:
1454:                               CPU_CRITICAL_EXIT();
003096  88021E     MOV W14, SR
1455:                               return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
003098  370035     BRA 0x3104
1456:                      }
1457:              
1458:                      CPU_CRITICAL_EXIT();
00309A  88021E     MOV W14, SR
00309C  370001     BRA 0x30A0
1459:                  }
1460:              
1461:              
1462:                                                                              /* ---------------- ALLOC MEM FOR POOL ---------------- */
1463:                                                                              /* Calc blk size with align.                            */
1464:                  blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
0030A0  EA068C     NEG W12, W13
0030A2  97B04F     MOV [W15-24], W0
0030A4  668680     AND W13, W0, W13
0030A6  E9008C     DEC W12, W1
0030A8  608080     AND W1, W0, W1
0030AA  EB0000     CLR W0
0030AC  320001     BRA Z, 0x30B0
0030AE  78000C     MOV W12, W0
0030B0  40068D     ADD W0, W13, W13
1465:                  pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
0030B2  B9E80A     MUL.SS W13, W10, W0
0030B4  780700     MOV W0, W14
1466:              
1467:                                                                              /* Alloc mem for pool.                                  */
1468:                  p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
0030B6  780308     MOV W8, W6
0030B8  97B2EF     MOV [W15-20], W5
0030BA  200014     MOV #0x1, W4
0030BC  78018C     MOV W12, W3
0030BE  780100     MOV W0, W2
0030C0  78008B     MOV W11, W1
0030C2  29E190     MOV #0x9E19, W0
0030C4  07FE0B     RCALL _Mem_SegAllocInternal
0030C6  780580     MOV W0, W11
1469:                                                             p_seg,
1470:                                                             pool_size,
1471:                                                             blk_align,
1472:                                                             LIB_MEM_PADDING_ALIGN_NONE,
1473:                                                             p_bytes_reqd,
1474:                                                             p_err);
1475:                  if (*p_err != LIB_MEM_ERR_NONE) {
0030C8  780618     MOV [W8], W12
0030CA  227100     MOV #0x2710, W0
0030CC  560F80     SUB W12, W0, [W15]
0030CE  3A001A     BRA NZ, 0x3104
1476:                      return;
1477:                  }
1478:              
1479:                                                                              /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
1480:                  p_pool->BlkFreeTbl = (void *)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
0030D0  45010A     ADD W10, W10, W2
0030D2  780308     MOV W8, W6
0030D4  97B2EF     MOV [W15-20], W5
0030D6  200014     MOV #0x1, W4
0030D8  200023     MOV #0x2, W3
0030DA  2154A1     MOV #0x154A, W1
0030DC  29E2D0     MOV #0x9E2D, W0
0030DE  07FDFE     RCALL _Mem_SegAllocInternal
0030E0  9804C0     MOV W0, [W9+8]
1481:                                                                    &Mem_SegHeap,
1482:                                                                     blk_nbr * sizeof(void *),
1483:                                                                     sizeof(CPU_ALIGN),
1484:                                                                     LIB_MEM_PADDING_ALIGN_NONE,
1485:                                                                     p_bytes_reqd,
1486:                                                                     p_err);
1487:                  if (*p_err != LIB_MEM_ERR_NONE) {
0030E2  160F98     SUBR W12, [W8], [W15]
0030E4  3A000F     BRA NZ, 0x3104
1488:                      return;
1489:                  }
1490:              
1491:                                                                              /* ------------------ INIT BLK LIST ------------------- */
1492:                  p_blk = (CPU_INT08U *)p_pool_mem;
0030E6  78010B     MOV W11, W2
1493:                  for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
0030E8  EB0080     CLR W1
0030EA  370003     BRA 0x30F2
0030F0  E80081     INC W1, W1
0030F2  508F8A     SUB W1, W10, [W15]
0030F4  39FFFB     BRA NC, 0x30EC
1494:                      p_pool->BlkFreeTbl[blk_ix]  = p_blk;
0030EC  781802     MOV W2, [W0++]
1495:                      p_blk                      += blk_size_align;
0030EE  41010D     ADD W2, W13, W2
1496:                  }
1497:              
1498:              
1499:                                                                              /* ------------------ INIT POOL DATA ------------------ */
1500:                  pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
0030F8  E9058B     DEC W11, W11
0030FA  45870E     ADD W11, W14, W14
1501:                  p_pool->PoolAddrStart =  p_pool_mem;
0030F6  780C8B     MOV W11, [W9]
1502:                  p_pool->PoolAddrEnd   = (void *)pool_addr_end;
0030FC  98049E     MOV W14, [W9+2]
1503:                  p_pool->BlkNbr        =  blk_nbr;
0030FE  9804AA     MOV W10, [W9+4]
1504:                  p_pool->BlkSize       =  blk_size_align;
003100  9804BD     MOV W13, [W9+6]
1505:                  p_pool->BlkFreeTblIx  =  blk_nbr;
003102  9804DA     MOV W10, [W9+10]
1506:              }
003104  78074F     MOV [--W15], W14
003106  BE064F     MOV.D [--W15], W12
003108  BE054F     MOV.D [--W15], W10
00310A  BE044F     MOV.D [--W15], W8
00310C  B100CF     SUB #0xC, W15
00310E  060000     RETURN
1507:              #endif
1508:              
1509:              
1510:              /*
1511:              *********************************************************************************************************
1512:              *                                            Mem_PoolClr()
1513:              *
1514:              * Description : Clears a memory pool (see Note #1).
1515:              *
1516:              * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
1517:              *
1518:              *               p_err        Pointer to variable that will receive the return error code from this function :
1519:              *
1520:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1521:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1522:              *
1523:              * Return(s)   : none.
1524:              *
1525:              * Caller(s)   : Application,
1526:              *               Mem_PoolCreate().
1527:              *
1528:              * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
1529:              *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
1530:              *
1531:              *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
1532:              *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
1533:              *                       this will likely corrupt the memory pool management.
1534:              *
1535:              *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
1536:              *
1537:              *               (3) This function is DEPRECATED and will be removed in a future version of this product.
1538:              *********************************************************************************************************
1539:              */
1540:              
1541:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1542:              void  Mem_PoolClr (MEM_POOL  *p_pool,
1543:                                 LIB_ERR   *p_err)
1544:              {
1545:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
1546:                  if (p_err == DEF_NULL) {
1547:                      CPU_SW_EXCEPTION(;);
1548:                  }
1549:              
1550:                                                                              /* -------------- VALIDATE MEM POOL PTR --------------- */
1551:                  if (p_pool == DEF_NULL) {
1552:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1553:                      return;
1554:                  }
1555:              #endif
1556:              
1557:                  p_pool->PoolAddrStart = DEF_NULL;
003010  EB0100     CLR W2
003012  780802     MOV W2, [W0]
1558:                  p_pool->PoolAddrEnd   = DEF_NULL;
003014  980012     MOV W2, [W0+2]
1559:                  p_pool->BlkSize       = 0u;
003016  980032     MOV W2, [W0+6]
1560:                  p_pool->BlkNbr        = 0u;
003018  980022     MOV W2, [W0+4]
1561:                  p_pool->BlkFreeTbl    = DEF_NULL;
00301A  980042     MOV W2, [W0+8]
1562:                  p_pool->BlkFreeTblIx  = 0u;
00301C  980052     MOV W2, [W0+10]
1563:              
1564:                 *p_err = LIB_MEM_ERR_NONE;
00301E  227100     MOV #0x2710, W0
003020  780880     MOV W0, [W1]
1565:              }
003022  060000     RETURN
1566:              #endif
1567:              
1568:              
1569:              /*
1570:              *********************************************************************************************************
1571:              *                                          Mem_PoolBlkGet()
1572:              *
1573:              * Description : Gets a memory block from memory pool.
1574:              *
1575:              * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
1576:              *
1577:              *               size    Size of requested memory (in bytes).
1578:              *
1579:              *               p_err   Pointer to variable that will receive the return error code from this function :
1580:              *
1581:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1582:              *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
1583:              *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1584:              *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
1585:              *
1586:              * Return(s)   : Pointer to memory block, if NO error(s).
1587:              *
1588:              *               Pointer to NULL,         otherwise.
1589:              *
1590:              * Caller(s)   : Application.
1591:              *
1592:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1593:              *                   Mem_DynPoolBlkGet() should be used instead.
1594:              *********************************************************************************************************
1595:              */
1596:              
1597:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1598:              void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
1599:                                     CPU_SIZE_T   size,
1600:                                     LIB_ERR     *p_err)
1601:              {
003110  FA0002     LNK #0x2
003112  780280     MOV W0, W5
003114  9FBFF1     MOV W1, [W15-2]
1602:                  CPU_INT08U  *p_blk;
1603:                  CPU_SR_ALLOC();
1604:              
1605:              
1606:                 (void)&size;                                                 /* Prevent possible 'variable unused' warning.          */
1607:              
1608:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
1609:                  if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
1610:                      CPU_SW_EXCEPTION(DEF_NULL);
1611:                  }
1612:              
1613:                  if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
1614:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1615:                      return (DEF_NULL);
1616:                  }
1617:              
1618:                  if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
1619:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1620:                      return (DEF_NULL);
1621:                  }
1622:              
1623:                  if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
1624:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1625:                      return (DEF_NULL);
1626:                  }
1627:              #endif
1628:              
1629:              
1630:                                                                              /* -------------- GET MEM BLK FROM POOL --------------- */
1631:                  p_blk = DEF_NULL;
00311E  EB0080     CLR W1
1632:                  CPU_CRITICAL_ENTER();
003116  800214     MOV SR, W4
003118  200E00     MOV #0xE0, W0
00311A  B72042     IOR SR
1633:                  if (p_pool->BlkFreeTblIx > 0u) {
00311C  9001D5     MOV [W5+10], W3
003120  E00003     CP0 W3
003122  320007     BRA Z, 0x3132
1634:                      p_pool->BlkFreeTblIx                     -= 1u;
003124  E90083     DEC W3, W1
003126  9802D1     MOV W1, [W5+10]
1635:                      p_blk                                     = p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
003128  408081     ADD W1, W1, W1
00312A  900045     MOV [W5+8], W0
00312C  400001     ADD W0, W1, W0
00312E  780090     MOV [W0], W1
1636:                      p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = DEF_NULL;
003130  EB0800     CLR [W0]
1637:                  }
1638:                  CPU_CRITICAL_EXIT();
003132  880214     MOV W4, SR
1639:              
1640:                  if (p_blk == DEF_NULL) {
003136  E00001     CP0 W1
003138  320001     BRA Z, 0x313C
1641:                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
003134  227DE0     MOV #0x27DE, W0
1642:                  } else {
1643:                     *p_err = LIB_MEM_ERR_NONE;
00313A  227100     MOV #0x2710, W0
00313C  780900     MOV W0, [W2]
1644:                  }
1645:              
1646:                  return (p_blk);
1647:              }
00313E  780001     MOV W1, W0
003140  FA8000     ULNK
003142  060000     RETURN
1648:              #endif
1649:              
1650:              
1651:              /*
1652:              *********************************************************************************************************
1653:              *                                          Mem_PoolBlkFree()
1654:              *
1655:              * Description : Free a memory block to memory pool.
1656:              *
1657:              * Argument(s) : p_pool  Pointer to memory pool to free memory block.
1658:              *
1659:              *               p_blk   Pointer to memory block address to free.
1660:              *
1661:              *               p_err   Pointer to variable that will receive the return error code from this function :
1662:              *
1663:              *                           LIB_MEM_ERR_NONE                        Operation was successful.
1664:              *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
1665:              *                                                                       a NULL pointer.
1666:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
1667:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
1668:              *                                                                        in memory pool.
1669:              *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
1670:              *
1671:              * Return(s)   : none.
1672:              *
1673:              * Caller(s)   : Application.
1674:              *
1675:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1676:              *                   Mem_DynPoolBlkFree() should be used instead.
1677:              *********************************************************************************************************
1678:              */
1679:              
1680:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1681:              void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
1682:                                     void      *p_blk,
1683:                                     LIB_ERR   *p_err)
1684:              {
003144  780380     MOV W0, W7
1685:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1686:                  CPU_SIZE_T   tbl_ix;
1687:                  CPU_BOOLEAN  addr_valid;
1688:              #endif
1689:                  CPU_SR_ALLOC();
1690:              
1691:              
1692:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
1693:                  if (p_err == DEF_NULL) {
1694:                      CPU_SW_EXCEPTION(;);
1695:                  }
1696:              
1697:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
1698:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1699:                      return;
1700:                  }
1701:              
1702:                  if (p_blk == DEF_NULL) {
1703:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1704:                      return;
1705:                  }
1706:              
1707:                  addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
1708:                  if (addr_valid != DEF_OK) {
1709:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
1710:                      return;
1711:                  }
1712:              
1713:                  CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
1714:                  for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
1715:                      if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
1716:                          CPU_CRITICAL_EXIT();
1717:                         *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
1718:                          return;
1719:                      }
1720:                  }
1721:              #else                                                           /* Double-free possibility if not in critical section.  */
1722:                  CPU_CRITICAL_ENTER();
003146  800214     MOV SR, W4
003148  200E00     MOV #0xE0, W0
00314A  B72042     IOR SR
1723:              #endif
1724:                                                                              /* --------------- FREE MEM BLK TO POOL --------------- */
1725:                  if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
00314C  9001D7     MOV [W7+10], W3
00314E  9002A7     MOV [W7+4], W5
003150  518F85     SUB W3, W5, [W15]
003152  390003     BRA NC, 0x315A
1726:                      CPU_CRITICAL_EXIT();
003154  880214     MOV W4, SR
1727:                     *p_err = LIB_MEM_ERR_POOL_FULL;
003156  227DD0     MOV #0x27DD, W0
003158  370007     BRA 0x3168
1728:                      return;
1729:                  }
1730:              
1731:                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
00315A  900347     MOV [W7+8], W6
00315C  418283     ADD W3, W3, W5
00315E  7AB301     MOV W1, [W6+W5]
1732:                  p_pool->BlkFreeTblIx                     += 1u;
003160  E80183     INC W3, W3
003162  9803D3     MOV W3, [W7+10]
1733:                  CPU_CRITICAL_EXIT();
003164  880214     MOV W4, SR
1734:              
1735:                 *p_err = LIB_MEM_ERR_NONE;
003166  227100     MOV #0x2710, W0
003168  780900     MOV W0, [W2]
00316A  060000     RETURN
1736:              }
1737:              #endif
1738:              
1739:              
1740:              /*
1741:              *********************************************************************************************************
1742:              *                                      Mem_PoolBlkGetNbrAvail()
1743:              *
1744:              * Description : Get memory pool's remaining number of blocks available to allocate.
1745:              *
1746:              * Argument(s) : p_pool   Pointer to a memory pool structure.
1747:              *
1748:              *               p_err    Pointer to variable that will receive the return error code from this function :
1749:              *
1750:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1751:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1752:              *
1753:              * Return(s)   : Remaining memory pool blocks,   if NO error(s).
1754:              *
1755:              *               0,                              otherwise.
1756:              *
1757:              * Caller(s)   : Application.
1758:              *
1759:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1760:              *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
1761:              *********************************************************************************************************
1762:              */
1763:              
1764:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1765:              MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
1766:                                                        LIB_ERR   *p_err)
1767:              {
00316C  780200     MOV W0, W4
1768:                  CPU_SIZE_T  nbr_avail;
1769:                  CPU_SR_ALLOC();
1770:              
1771:              
1772:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1773:                                                                              /* --------------- VALIDATE RTN ERR PTR --------------- */
1774:                  if (p_err == DEF_NULL) {
1775:                      CPU_SW_EXCEPTION(0u);
1776:                  }
1777:                                                                              /* ---------------- VALIDATE MEM POOL ----------------- */
1778:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
1779:                     *p_err =  LIB_MEM_ERR_NULL_PTR;
1780:                      return (0u);
1781:                  }
1782:              #endif
1783:              
1784:                  CPU_CRITICAL_ENTER();
00316E  800212     MOV SR, W2
003170  200E00     MOV #0xE0, W0
003172  B72042     IOR SR
1785:                  nbr_avail = p_pool->BlkFreeTblIx;
003174  900054     MOV [W4+10], W0
1786:                  CPU_CRITICAL_EXIT();
003176  880212     MOV W2, SR
1787:              
1788:                 *p_err = LIB_MEM_ERR_NONE;
003178  227102     MOV #0x2710, W2
00317A  780882     MOV W2, [W1]
1789:              
1790:                  return (nbr_avail);
1791:              }
00317C  060000     RETURN
1792:              #endif
1793:              
1794:              
1795:              /*
1796:              *********************************************************************************************************
1797:              *                                          Mem_DynPoolCreate()
1798:              *
1799:              * Description : Creates a dynamic memory pool.
1800:              *
1801:              * Argument(s) : p_name          Pointer to pool name.
1802:              *
1803:              *               p_pool          Pointer to pool data.
1804:              *
1805:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1806:              *                               general-purpose heap if null.
1807:              *
1808:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1809:              *
1810:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1811:              *
1812:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1813:              *
1814:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1815:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1816:              *
1817:              *               p_err           Pointer to variable that will receive the return error code from this function :
1818:              *
1819:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1820:              *
1821:              *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1822:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
1823:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
1824:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
1825:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
1826:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1827:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1828:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1829:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1830:              *
1831:              * Return(s)   : None.
1832:              *
1833:              * Caller(s)   : Application.
1834:              *
1835:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1836:              *                   block is stored in the block itself (only when free/unused).
1837:              *********************************************************************************************************
1838:              */
1839:              
1840:              void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
1841:                                              MEM_DYN_POOL  *p_pool,
1842:                                              MEM_SEG       *p_seg,
1843:                                              CPU_SIZE_T     blk_size,
1844:                                              CPU_SIZE_T     blk_align,
1845:                                              CPU_SIZE_T     blk_qty_init,
1846:                                              CPU_SIZE_T     blk_qty_max,
1847:                                              LIB_ERR       *p_err)
1848:              {
1849:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
00317E  E00002     CP0 W2
003180  3A0001     BRA NZ, 0x3184
1850:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1851:                      p_seg = &Mem_SegHeap;
003182  2154A2     MOV #0x154A, W2
1852:              #else
1853:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1854:                      return (DEF_NULL);
1855:              #endif
1856:                  }
1857:              
1858:                  Mem_DynPoolCreateInternal(p_name,
003184  781F87     MOV W7, [W15++]
003186  780386     MOV W6, W7
003188  780305     MOV W5, W6
00318A  200015     MOV #0x1, W5
00318C  07FDC0     RCALL _Mem_DynPoolCreateInternal
00318E  E9878F     DEC2 W15, W15
1859:                                            p_pool,
1860:                                            p_seg,
1861:                                            blk_size,
1862:                                            blk_align,
1863:                                            LIB_MEM_PADDING_ALIGN_NONE,
1864:                                            blk_qty_init,
1865:                                            blk_qty_max,
1866:                                            p_err);
1867:              }
003190  060000     RETURN
1868:              
1869:              
1870:              /*
1871:              *********************************************************************************************************
1872:              *                                        Mem_DynPoolCreateHW()
1873:              *
1874:              * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
1875:              *               properties.
1876:              *
1877:              * Argument(s) : p_name          Pointer to pool name.
1878:              *
1879:              *               p_pool          Pointer to pool data.
1880:              *
1881:              *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
1882:              *                               general-purpose heap if null.
1883:              *
1884:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1885:              *
1886:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1887:              *
1888:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1889:              *
1890:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1891:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1892:              *
1893:              *               p_err           Pointer to variable that will receive the return error code from this function :
1894:              *
1895:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1896:              *
1897:              *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1898:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1899:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1900:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1901:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1902:              *
1903:              * Return(s)   : None.
1904:              *
1905:              * Caller(s)   : Application.
1906:              *
1907:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1908:              *                   block is stored in the block itself (only when free/unused).
1909:              *********************************************************************************************************
1910:              */
1911:              
1912:              void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
1913:                                                MEM_DYN_POOL  *p_pool,
1914:                                                MEM_SEG       *p_seg,
1915:                                                CPU_SIZE_T     blk_size,
1916:                                                CPU_SIZE_T     blk_align,
1917:                                                CPU_SIZE_T     blk_qty_init,
1918:                                                CPU_SIZE_T     blk_qty_max,
1919:                                                LIB_ERR       *p_err)
1920:              {
1921:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
003192  E00002     CP0 W2
003194  3A0001     BRA NZ, 0x3198
1922:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1923:                      p_seg = &Mem_SegHeap;
003196  2154A2     MOV #0x154A, W2
1924:              #else
1925:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1926:                      return (DEF_NULL);
1927:              #endif
1928:                  }
1929:              
1930:                  Mem_DynPoolCreateInternal(p_name,
003198  781F87     MOV W7, [W15++]
00319A  780386     MOV W6, W7
00319C  780305     MOV W5, W6
00319E  9002C2     MOV [W2+8], W5
0031A0  07FDB6     RCALL _Mem_DynPoolCreateInternal
0031A2  E9878F     DEC2 W15, W15
1931:                                            p_pool,
1932:                                            p_seg,
1933:                                            blk_size,
1934:                                            blk_align,
1935:                                            p_seg->PaddingAlign,
1936:                                            blk_qty_init,
1937:                                            blk_qty_max,
1938:                                            p_err);
1939:              }
0031A4  060000     RETURN
1940:              
1941:              
1942:              /*
1943:              *********************************************************************************************************
1944:              *                                          Mem_DynPoolBlkGet()
1945:              *
1946:              * Description : Gets a memory block from specified pool, growing it if needed.
1947:              *
1948:              * Argument(s) : p_pool  Pointer to pool data.
1949:              *
1950:              *               p_err   Pointer to variable that will receive the return error code from this function :
1951:              *
1952:              *                           LIB_MEM_ERR_NONE                    Operation was successful.
1953:              *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
1954:              *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
1955:              *
1956:              *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
1957:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1958:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1959:              *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1960:              *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1961:              *
1962:              * Return(s)   : Pointer to memory block, if successful.
1963:              *
1964:              *               DEF_NULL, otherwise.
1965:              *
1966:              * Caller(s)   : Application.
1967:              *
1968:              * Note(s)     : none.
1969:              *********************************************************************************************************
1970:              */
1971:              
1972:              void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
1973:                                        LIB_ERR       *p_err)
1974:              {
0031A6  BE9F88     MOV.D W8, [W15++]
0031A8  780380     MOV W0, W7
0031AA  780481     MOV W1, W9
1975:                         void      *p_blk;
1976:                  const  CPU_CHAR  *p_pool_name;
1977:                  CPU_SR_ALLOC();
1978:              
1979:              
1980:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1981:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
1982:                      CPU_SW_EXCEPTION(DEF_NULL);
1983:                  }
1984:              
1985:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
1986:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1987:                      return (DEF_NULL);
1988:                  }
1989:              #endif
1990:              
1991:                                                                              /* Ensure pool is not empty if qty is limited.          */
1992:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
0031AC  9001D7     MOV [W7+10], W3
0031AE  E00003     CP0 W3
0031B0  32000E     BRA Z, 0x31CE
1993:                      CPU_CRITICAL_ENTER();
0031B2  800211     MOV SR, W1
0031B4  200E00     MOV #0xE0, W0
0031B6  B72042     IOR SR
1994:                      if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
0031B8  900167     MOV [W7+12], W2
0031BA  510F83     SUB W2, W3, [W15]
0031BC  390005     BRA NC, 0x31C8
1995:                          CPU_CRITICAL_EXIT();
0031BE  880211     MOV W1, SR
1996:              
1997:                         *p_err = LIB_MEM_ERR_POOL_EMPTY;
0031C0  227DE0     MOV #0x27DE, W0
0031C2  780C80     MOV W0, [W9]
1998:                          return (DEF_NULL);
0031C4  EB0400     CLR W8
0031C6  37001C     BRA 0x3200
1999:                      }
2000:              
2001:                      p_pool->BlkAllocCnt++;
0031C8  E80102     INC W2, W2
0031CA  9803E2     MOV W2, [W7+12]
2002:                      CPU_CRITICAL_EXIT();
0031CC  880211     MOV W1, SR
2003:                  }
2004:              
2005:                                                                              /* --------------- ALLOC FROM FREE LIST --------------- */
2006:                  CPU_CRITICAL_ENTER();
0031CE  800211     MOV SR, W1
0031D0  200E00     MOV #0xE0, W0
0031D2  B72042     IOR SR
2007:                  if (p_pool->BlkFreePtr != DEF_NULL) {
0031D4  900447     MOV [W7+8], W8
0031D6  E00008     CP0 W8
0031D8  320006     BRA Z, 0x31E6
2008:                      p_blk              = p_pool->BlkFreePtr;
2009:                      p_pool->BlkFreePtr = *((void **)p_blk);
0031DA  780018     MOV [W8], W0
0031DC  9803C0     MOV W0, [W7+8]
2010:                      CPU_CRITICAL_EXIT();
0031DE  880211     MOV W1, SR
2011:              
2012:                     *p_err = LIB_MEM_ERR_NONE;
0031E0  227100     MOV #0x2710, W0
0031E2  780C80     MOV W0, [W9]
2013:              
2014:                      return (p_blk);
0031E4  37000D     BRA 0x3200
2015:                  }
2016:                  CPU_CRITICAL_EXIT();
0031E6  880211     MOV W1, SR
2017:              
2018:                                                                              /* ------------------ ALLOC NEW BLK ------------------- */
2019:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2020:                  p_pool_name = p_pool->NamePtr;
2021:              #else
2022:                  p_pool_name = DEF_NULL;
2023:              #endif
2024:                  p_blk = Mem_SegAllocInternal(p_pool_name,
0031E8  780309     MOV W9, W6
0031EA  EB0280     CLR W5
0031EC  900237     MOV [W7+6], W4
0031EE  9001A7     MOV [W7+4], W3
0031F0  900117     MOV [W7+2], W2
0031F2  780097     MOV [W7], W1
0031F4  EB0000     CLR W0
0031F6  07FD72     RCALL _Mem_SegAllocInternal
2025:                                               p_pool->PoolSegPtr,
2026:                                               p_pool->BlkSize,
2027:                                               p_pool->BlkAlign,
2028:                                               p_pool->BlkPaddingAlign,
2029:                                               DEF_NULL,
2030:                                               p_err);
2031:                  if (*p_err != LIB_MEM_ERR_NONE) {
0031F8  227101     MOV #0x2710, W1
0031FA  108F99     SUBR W1, [W9], [W15]
0031FC  3A0001     BRA NZ, 0x3200
2032:                      return (DEF_NULL);
2033:                  }
2034:              
2035:                  return (p_blk);
0031FE  780400     MOV W0, W8
2036:              }
003200  780008     MOV W8, W0
003202  BE044F     MOV.D [--W15], W8
003204  060000     RETURN
2037:              
2038:              
2039:              /*
2040:              *********************************************************************************************************
2041:              *                                         Mem_DynPoolBlkFree()
2042:              *
2043:              * Description : Frees memory block, making it available for future use.
2044:              *
2045:              * Argument(s) : p_pool  Pointer to pool data.
2046:              *
2047:              *               p_blk   Pointer to first byte of memory block.
2048:              *
2049:              *               p_err   Pointer to variable that will receive the return error code from this function :
2050:              *
2051:              *                           LIB_MEM_ERR_NONE        Operation was successful.
2052:              *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
2053:              *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
2054:              *
2055:              * Return(s)   : none.
2056:              *
2057:              * Caller(s)   : Application.
2058:              *
2059:              * Note(s)     : none.
2060:              *********************************************************************************************************
2061:              */
2062:              
2063:              void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
2064:                                        void          *p_blk,
2065:                                        LIB_ERR       *p_err)
2066:              {
003206  780280     MOV W0, W5
2067:                  CPU_SR_ALLOC();
2068:              
2069:              
2070:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2071:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2072:                      CPU_SW_EXCEPTION(;);
2073:                  }
2074:              
2075:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2076:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2077:                      return;
2078:                  }
2079:              
2080:                  if (p_blk == DEF_NULL) {
2081:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2082:                      return;
2083:                  }
2084:              #endif
2085:              
2086:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
003208  9001D5     MOV [W5+10], W3
00320A  E00003     CP0 W3
00320C  32000C     BRA Z, 0x3226
2087:                      CPU_CRITICAL_ENTER();
00320E  800213     MOV SR, W3
003210  200E00     MOV #0xE0, W0
003212  B72042     IOR SR
2088:                      if (p_pool->BlkAllocCnt == 0u) {
003214  900265     MOV [W5+12], W4
003216  E00004     CP0 W4
003218  3A0003     BRA NZ, 0x3220
2089:                          CPU_CRITICAL_EXIT();
00321A  880213     MOV W3, SR
2090:              
2091:                         *p_err = LIB_MEM_ERR_POOL_FULL;
00321C  227DD0     MOV #0x27DD, W0
00321E  37000B     BRA 0x3236
2092:                          return;
2093:                      }
2094:              
2095:                      p_pool->BlkAllocCnt--;
003220  E90204     DEC W4, W4
003222  9802E4     MOV W4, [W5+12]
2096:                      CPU_CRITICAL_EXIT();
003224  880213     MOV W3, SR
2097:                  }
2098:              
2099:                  CPU_CRITICAL_ENTER();
003226  800213     MOV SR, W3
003228  200E00     MOV #0xE0, W0
00322A  B72042     IOR SR
2100:                 *((void **)p_blk)   = p_pool->BlkFreePtr;
00322C  900045     MOV [W5+8], W0
00322E  780880     MOV W0, [W1]
2101:                  p_pool->BlkFreePtr = p_blk;
003230  9802C1     MOV W1, [W5+8]
2102:                  CPU_CRITICAL_EXIT();
003232  880213     MOV W3, SR
2103:              
2104:                 *p_err = LIB_MEM_ERR_NONE;
003234  227100     MOV #0x2710, W0
003236  780900     MOV W0, [W2]
003238  060000     RETURN
2105:              }
2106:              
2107:              
2108:              /*
2109:              *********************************************************************************************************
2110:              *                                     Mem_DynPoolBlkNbrAvailGet()
2111:              *
2112:              * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
2113:              *               dynamic memory pool for which no limit was set at creation.
2114:              *
2115:              * Argument(s) : p_pool  Pointer to pool data.
2116:              *
2117:              *               p_err   Pointer to variable that will receive the return error code from this function :
2118:              *
2119:              *                           LIB_MEM_ERR_NONE                Operation was successful.
2120:              *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
2121:              *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
2122:              *
2123:              * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
2124:              *
2125:              *               0, if pool is empty or if an error occurred.
2126:              *
2127:              * Caller(s)   : Application.
2128:              *
2129:              * Note(s)     : None.
2130:              *********************************************************************************************************
2131:              */
2132:              
2133:              CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
2134:                                                     LIB_ERR       *p_err)
2135:              {
00323A  780280     MOV W0, W5
2136:                  CPU_SIZE_T  blk_nbr_avail;
2137:                  CPU_SR_ALLOC();
2138:              
2139:              
2140:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2141:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2142:                      CPU_SW_EXCEPTION(;);
2143:                  }
2144:              
2145:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2146:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2147:                      return (0u);
2148:                  }
2149:              #endif
2150:              
2151:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
00323C  900155     MOV [W5+10], W2
00323E  E00002     CP0 W2
003240  320009     BRA Z, 0x3254
2152:                      CPU_CRITICAL_ENTER();
003242  800213     MOV SR, W3
003244  200E00     MOV #0xE0, W0
003246  B72042     IOR SR
2153:                      blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
003248  900065     MOV [W5+12], W0
00324A  510000     SUB W2, W0, W0
2154:                      CPU_CRITICAL_EXIT();
00324C  880213     MOV W3, SR
2155:              
2156:                     *p_err = LIB_MEM_ERR_NONE;
00324E  227102     MOV #0x2710, W2
003250  780882     MOV W2, [W1]
003252  060000     RETURN
2157:                  } else {
2158:                      blk_nbr_avail = 0u;
003258  050000     RETLW #0x0, W0
2159:                     *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
003254  227DF0     MOV #0x27DF, W0
003256  780880     MOV W0, [W1]
2160:                  }
2161:              
2162:                  return (blk_nbr_avail);
2163:              }
2164:              
2165:              
2166:              /*
2167:              *********************************************************************************************************
2168:              *                                           Mem_OutputUsage()
2169:              *
2170:              * Description : Outputs memory usage report through 'out_fnct'.
2171:              *
2172:              * Argument(s) : out_fnct        Pointer to output function.
2173:              *
2174:              *               print_details   DEF_YES, if the size of each allocation should be printed.
2175:              *                               DEF_NO,  otherwise.
2176:              *
2177:              *               p_err           Pointer to variable that will receive the return error code from this function :
2178:              *
2179:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
2180:              *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
2181:              *
2182:              *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
2183:              *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
2184:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
2185:              *
2186:              * Return(s)   : None.
2187:              *
2188:              * Caller(s)   : Application.
2189:              *
2190:              * Note(s)     : none.
2191:              *********************************************************************************************************
2192:              */
2193:              
2194:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2195:              void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
2196:                                    LIB_ERR   *p_err)
2197:              {
2198:                  CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
2199:                  MEM_SEG   *p_seg;
2200:                  CPU_SR_ALLOC();
2201:              
2202:              
2203:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2204:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2205:                      CPU_SW_EXCEPTION(;);
2206:                  }
2207:              
2208:                  if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
2209:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2210:                      return;
2211:                  }
2212:              #endif
2213:              
2214:                  out_fnct("---------------- Memory allocation info ----------------\r\n");
2215:                  out_fnct("| Type    | Size       | Free size  | Name\r\n");
2216:                  out_fnct("|---------|------------|------------|-------------------\r\n");
2217:              
2218:                  CPU_CRITICAL_ENTER();
2219:                  p_seg = Mem_SegHeadPtr;
2220:                  while (p_seg != DEF_NULL) {
2221:                      CPU_SIZE_T       rem_size;
2222:                      MEM_SEG_INFO     seg_info;
2223:                      MEM_ALLOC_INFO  *p_alloc;
2224:              
2225:              
2226:                      rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
2227:                      if (*p_err != LIB_MEM_ERR_NONE) {
2228:                          return;
2229:                      }
2230:              
2231:                      out_fnct("| Section | ");
2232:              
2233:                      (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
2234:                                              10u,
2235:                                              DEF_NBR_BASE_DEC,
2236:                                              ' ',
2237:                                              DEF_NO,
2238:                                              DEF_YES,
2239:                                             &str[0u]);
2240:              
2241:                      out_fnct(str);
2242:                      out_fnct(" | ");
2243:              
2244:                      (void)Str_FmtNbr_Int32U(rem_size,
2245:                                              10u,
2246:                                              DEF_NBR_BASE_DEC,
2247:                                              ' ',
2248:                                              DEF_NO,
2249:                                              DEF_YES,
2250:                                             &str[0u]);
2251:              
2252:                      out_fnct(str);
2253:                      out_fnct(" | ");
2254:                      out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
2255:                      out_fnct("\r\n");
2256:              
2257:                      p_alloc = p_seg->AllocInfoHeadPtr;
2258:                      while (p_alloc != DEF_NULL) {
2259:                          out_fnct("| -> Obj  | ");
2260:              
2261:                          (void)Str_FmtNbr_Int32U(p_alloc->Size,
2262:                                                  10u,
2263:                                                  DEF_NBR_BASE_DEC,
2264:                                                  ' ',
2265:                                                  DEF_NO,
2266:                                                  DEF_YES,
2267:                                                 &str[0u]);
2268:              
2269:                          out_fnct(str);
2270:                          out_fnct(" |            | ");
2271:              
2272:                          out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
2273:                          out_fnct("\r\n");
2274:              
2275:                          p_alloc = p_alloc->NextPtr;
2276:                      }
2277:              
2278:                      p_seg = p_seg->NextPtr;
2279:                  }
2280:                  CPU_CRITICAL_EXIT();
2281:              
2282:                 *p_err = LIB_MEM_ERR_NONE;
2283:              }
2284:              #endif
2285:              
2286:              
2287:              /*
2288:              *********************************************************************************************************
2289:              *********************************************************************************************************
2290:              *                                           LOCAL FUNCTIONS
2291:              *********************************************************************************************************
2292:              *********************************************************************************************************
2293:              */
2294:              
2295:              /*
2296:              *********************************************************************************************************
2297:              *                                       Mem_SegCreateCritical()
2298:              *
2299:              * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
2300:              *
2301:              * Argument(s) : p_name          Pointer to segment name.
2302:              *
2303:              *               p_seg           Pointer to segment data. Must be allocated by caller.
2304:              *               -----           Argument validated by caller.
2305:              *
2306:              *               seg_base_addr   Segment's first byte address.
2307:              *
2308:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
2309:              *                               from this memory segment. MUST be a power of 2.
2310:              *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
2311:              *               -------------   Argument validated by caller.
2312:              *
2313:              *               size            Total size of segment, in bytes.
2314:              *               ----            Argument validated by caller.
2315:              *
2316:              * Return(s)   : Pointer to segment data, if successful.
2317:              *
2318:              *               DEF_NULL, otherwise.
2319:              *
2320:              * Caller(s)   : Mem_PoolCreate(),
2321:              *               Mem_SegCreate().
2322:              *
2323:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2324:              *********************************************************************************************************
2325:              */
2326:              
2327:              static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
2328:                                                         MEM_SEG     *p_seg,
2329:                                                         CPU_ADDR     seg_base_addr,
2330:                                                         CPU_SIZE_T   padding_align,
2331:                                                         CPU_SIZE_T   size)
2332:              {
002C3A  FA0002     LNK #0x2
2333:                  p_seg->AddrBase         =  seg_base_addr;
002C3C  780882     MOV W2, [W1]
2334:                  p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
002C3E  E90002     DEC W2, W0
002C40  400004     ADD W0, W4, W0
002C42  980090     MOV W0, [W1+2]
2335:                  p_seg->AddrNext         =  seg_base_addr;
002C44  9800A2     MOV W2, [W1+4]
2336:                  p_seg->NextPtr          =  Mem_SegHeadPtr;
002C46  804230     MOV Mem_SegHeadPtr, W0
002C48  9800B0     MOV W0, [W1+6]
2337:                  p_seg->PaddingAlign     =  padding_align;
002C4A  9800C3     MOV W3, [W1+8]
2338:              
2339:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2340:                  p_seg->NamePtr          = p_name;
2341:                  p_seg->AllocInfoHeadPtr = DEF_NULL;
2342:              #else
2343:                  (void)&p_name;
2344:              #endif
2345:              
2346:                  Mem_SegHeadPtr = p_seg;
002C4C  884231     MOV W1, Mem_SegHeadPtr
2347:              }
002C4E  FA8000     ULNK
002C50  060000     RETURN
2348:              
2349:              
2350:              /*
2351:              *********************************************************************************************************
2352:              *                                      Mem_SegOverlapChkCritical()
2353:              *
2354:              * Description : Checks if existing memory segment exists or overlaps with specified memory area.
2355:              *
2356:              * Argument(s) : seg_base_addr   Address of first byte of memory area.
2357:              *
2358:              *               size            Size of memory area, in bytes.
2359:              *
2360:              *               p_err       Pointer to variable that will receive the return error code from this function :
2361:              *
2362:              *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
2363:              *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
2364:              *
2365:              * Return(s)   : Pointer to memory segment that overlaps.
2366:              *
2367:              *               DEF_NULL, otherwise.
2368:              *
2369:              * Caller(s)   : Mem_PoolCreate(),
2370:              *               Mem_SegCreate().
2371:              *
2372:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2373:              *********************************************************************************************************
2374:              */
2375:              
2376:              static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
2377:                                                           CPU_SIZE_T   size,
2378:                                                           LIB_ERR     *p_err)
2379:              {
2380:                  MEM_SEG   *p_seg_chk;
2381:                  CPU_ADDR   seg_new_end;
2382:                  CPU_ADDR   seg_chk_start;
2383:                  CPU_ADDR   seg_chk_end;
2384:              
2385:              
2386:                  seg_new_end = seg_base_addr + (size - 1u);
002C52  E90180     DEC W0, W3
002C54  418081     ADD W3, W1, W1
2387:                  p_seg_chk   = Mem_SegHeadPtr;
002C56  804233     MOV Mem_SegHeadPtr, W3
2388:              
2389:                  while (p_seg_chk != DEF_NULL) {
002C58  370013     BRA 0x2C80
002C80  E00003     CP0 W3
002C82  3AFFEB     BRA NZ, 0x2C5A
2390:                      seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
002C5A  780213     MOV [W3], W4
2391:                      seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
002C5C  900293     MOV [W3+2], W5
2392:              
2393:                      if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
002C5E  500F84     SUB W0, W4, [W15]
002C60  3A0004     BRA NZ, 0x2C6A
002C62  508F85     SUB W1, W5, [W15]
002C64  3A0004     BRA NZ, 0x2C6E
2394:                         *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
002C66  227800     MOV #0x2780, W0
002C68  37000E     BRA 0x2C86
2395:                          return (p_seg_chk);
2396:                      } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
002C6A  500F84     SUB W0, W4, [W15]
002C6C  390004     BRA NC, 0x2C76
002C6E  500F85     SUB W0, W5, [W15]
002C70  360004     BRA LEU, 0x2C7A
002C72  500F84     SUB W0, W4, [W15]
002C74  3E0004     BRA GTU, 0x2C7E
2397:                                 ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
002C76  508F84     SUB W1, W4, [W15]
002C78  390002     BRA NC, 0x2C7E
2398:                         *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
002C7A  2277F0     MOV #0x277F, W0
002C7C  370004     BRA 0x2C86
2399:                          return (p_seg_chk);
2400:                      }
2401:              
2402:                      p_seg_chk = p_seg_chk->NextPtr;
002C7E  9001B3     MOV [W3+6], W3
2403:                  }
2404:              
2405:                 *p_err = LIB_MEM_ERR_NONE;
002C84  227100     MOV #0x2710, W0
002C86  780900     MOV W0, [W2]
2406:              
2407:                  return (DEF_NULL);
2408:              }
002C88  780003     MOV W3, W0
002C8A  060000     RETURN
2409:              
2410:              
2411:              /*
2412:              *********************************************************************************************************
2413:              *                                       Mem_SegAllocInternal()
2414:              *
2415:              * Description : Allocates memory from specified segment.
2416:              *
2417:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
2418:              *
2419:              *               p_seg           Pointer to segment from which to allocate memory.
2420:              *               -----           Argument validated by caller.
2421:              *
2422:              *               size            Size of memory block to allocate, in bytes.
2423:              *
2424:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2425:              *
2426:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2427:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2428:              *                               means no padding.
2429:              *
2430:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2431:              *                                the allocation to succeed. Set to DEF_NULL to skip calculation.
2432:              *
2433:              *               p_err           Pointer to variable that will receive the return error code from this function :
2434:              *
2435:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2436:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2437:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2438:              *
2439:              *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
2440:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2441:              *
2442:              * Return(s)   : Pointer to allocated memory block, if successful.
2443:              *
2444:              *               DEF_NULL, otherwise.
2445:              *
2446:              * Caller(s)   : Mem_DynPoolBlkGet(),
2447:              *               Mem_DynPoolCreateInternal(),
2448:              *               Mem_HeapAlloc(),
2449:              *               Mem_PoolCreate(),
2450:              *               Mem_SegAlloc(),
2451:              *               Mem_SegAllocExt(),
2452:              *               Mem_SegAllocHW().
2453:              *
2454:              * Note(s)     : none.
2455:              *********************************************************************************************************
2456:              */
2457:              
2458:              static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
2459:                                                          MEM_SEG     *p_seg,
2460:                                                          CPU_SIZE_T   size,
2461:                                                          CPU_SIZE_T   align,
2462:                                                          CPU_SIZE_T   padding_align,
2463:                                                          CPU_SIZE_T  *p_bytes_reqd,
2464:                                                          LIB_ERR     *p_err)
2465:              {
002CDC  FA0002     LNK #0x2
002CDE  BE9F88     MOV.D W8, [W15++]
002CE0  9FBFD0     MOV W0, [W15-6]
002CE2  780381     MOV W1, W7
002CE4  780082     MOV W2, W1
002CE6  780103     MOV W3, W2
002CE8  780184     MOV W4, W3
002CEA  780205     MOV W5, W4
002CEC  780486     MOV W6, W9
2466:                  void  *p_blk;
2467:                  CPU_SR_ALLOC();
2468:              
2469:              
2470:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2471:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
2472:                      CPU_SW_EXCEPTION(DEF_NULL);
2473:                  }
2474:              
2475:                  if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
2476:                     *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
2477:                      return (DEF_NULL);
2478:                  }
2479:              
2480:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
2481:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
2482:                      return (DEF_NULL);
2483:                  }
2484:              #endif
2485:              
2486:                  CPU_CRITICAL_ENTER();
002CEE  800218     MOV SR, W8
002CF0  200E00     MOV #0xE0, W0
002CF2  B72042     IOR SR
2487:                  p_blk = Mem_SegAllocExtCritical(p_seg,
002CF4  780289     MOV W9, W5
002CF6  780007     MOV W7, W0
002CF8  07FFC9     RCALL _Mem_SegAllocExtCritical
2488:                                                  size,
2489:                                                  align,
2490:                                                  padding_align,
2491:                                                  p_bytes_reqd,
2492:                                                  p_err);
2493:                  if (*p_err != LIB_MEM_ERR_NONE) {
002CFA  227101     MOV #0x2710, W1
002CFC  108F99     SUBR W1, [W9], [W15]
002CFE  320003     BRA Z, 0x2D06
2494:                      CPU_CRITICAL_EXIT();
002D00  880218     MOV W8, SR
2495:                      return (DEF_NULL);
002D02  EB0000     CLR W0
002D04  370001     BRA 0x2D08
2496:                  }
2497:              
2498:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
2499:                  Mem_SegAllocTrackCritical(p_name,
2500:                                            p_seg,
2501:                                            size,
2502:                                            p_err);
2503:                  if (*p_err != LIB_MEM_ERR_NONE) {
2504:                      CPU_CRITICAL_EXIT();
2505:                      return (DEF_NULL);
2506:                  }
2507:              #else
2508:                  (void)&p_name;
2509:              #endif
2510:                  CPU_CRITICAL_EXIT();
002D06  880218     MOV W8, SR
2511:              
2512:                  return (p_blk);
2513:              }
002D08  BE044F     MOV.D [--W15], W8
002D0A  FA8000     ULNK
002D0C  060000     RETURN
2514:              
2515:              
2516:              /*
2517:              *********************************************************************************************************
2518:              *                                      Mem_SegAllocExtCritical()
2519:              *
2520:              * Description : Allocates memory from specified segment.
2521:              *
2522:              * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
2523:              *
2524:              *               size            Size of memory block to allocate, in bytes.
2525:              *
2526:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2527:              *
2528:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2529:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2530:              *                               means no padding.
2531:              *
2532:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2533:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
2534:              *
2535:              *               p_err           Pointer to variable that will receive the return error code from this function :
2536:              *
2537:              *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
2538:              *
2539:              * Return(s)   : Pointer to allocated memory block, if successful.
2540:              *
2541:              *               DEF_NULL, otherwise.
2542:              *
2543:              * Caller(s)   : Mem_PoolCreate(),
2544:              *               Mem_SegAllocInternal(),
2545:              *               Mem_SegAllocTrackCritical().
2546:              *
2547:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2548:              *********************************************************************************************************
2549:              */
2550:              
2551:              static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
2552:                                                      CPU_SIZE_T   size,
2553:                                                      CPU_SIZE_T   align,
2554:                                                      CPU_SIZE_T   padding_align,
2555:                                                      CPU_SIZE_T  *p_bytes_reqd,
2556:                                                      LIB_ERR     *p_err)
2557:              {
002C8C  781F88     MOV W8, [W15++]
2558:                  CPU_ADDR    blk_addr;
2559:                  CPU_ADDR    addr_next;
2560:                  CPU_SIZE_T  size_rem_seg;
2561:                  CPU_SIZE_T  size_tot_blk;
2562:                  CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
002C8E  780303     MOV W3, W6
002C90  518F82     SUB W3, W2, [W15]
002C92  310001     BRA C, 0x2C96
002C94  780302     MOV W2, W6
2563:              
2564:              
2565:                  blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
002C96  900120     MOV [W0+4], W2
002C98  EA0386     NEG W6, W7
002C9A  638382     AND W7, W2, W7
002C9C  E90406     DEC W6, W8
002C9E  640402     AND W8, W2, W8
002CA0  3A0001     BRA NZ, 0x2CA4
002CA2  EB0300     CLR W6
002CA4  430307     ADD W6, W7, W6
2566:                                                        blk_align);
2567:                  addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
002CA6  430081     ADD W6, W1, W1
002CA8  EA0383     NEG W3, W7
002CAA  608387     AND W1, W7, W7
002CAC  E90403     DEC W3, W8
002CAE  608088     AND W1, W8, W1
002CB0  3A0001     BRA NZ, 0x2CB4
002CB2  EB0180     CLR W3
002CB4  418187     ADD W3, W7, W3
2568:                                                        padding_align);
2569:                  size_rem_seg = p_seg->AddrEnd - p_seg->AddrNext + 1u;
002CB6  900090     MOV [W0+2], W1
002CB8  E80081     INC W1, W1
002CBA  508082     SUB W1, W2, W1
2570:                  size_tot_blk = addr_next - p_seg->AddrNext;                 /* Compute tot blk size including align and padding.    */
002CBC  518102     SUB W3, W2, W2
2571:                  if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
002CBE  508F82     SUB W1, W2, [W15]
002CC0  310007     BRA C, 0x2CD0
2572:                      if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
002CC2  E00004     CP0 W4
002CC4  320001     BRA Z, 0x2CC8
2573:                         *p_bytes_reqd = size_tot_blk - size_rem_seg;
002CC6  510A01     SUB W2, W1, [W4]
2574:                      }
2575:              
2576:                     *p_err = LIB_MEM_ERR_SEG_OVF;
002CC8  227D90     MOV #0x27D9, W0
002CCA  780A80     MOV W0, [W5]
2577:                      return (DEF_NULL);
002CCC  EB0000     CLR W0
002CCE  370004     BRA 0x2CD8
2578:                  }
2579:              
2580:                  p_seg->AddrNext = addr_next;
002CD0  980023     MOV W3, [W0+4]
2581:              
2582:                 *p_err = LIB_MEM_ERR_NONE;
002CD2  227100     MOV #0x2710, W0
002CD4  780A80     MOV W0, [W5]
2583:              
2584:                  return ((void *)blk_addr);
002CD6  780006     MOV W6, W0
2585:              }
002CD8  78044F     MOV [--W15], W8
002CDA  060000     RETURN
2586:              
2587:              
2588:              /*
2589:              *********************************************************************************************************
2590:              *                                     Mem_SegAllocTrackCritical()
2591:              *
2592:              * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
2593:              *
2594:              * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
2595:              *                       remain accessible at all times.
2596:              *
2597:              *               p_seg   Pointer to segment data.
2598:              *
2599:              *               size    Allocation size, in bytes.
2600:              *
2601:              *               p_err   Pointer to variable that will receive the return error code from this function :
2602:              *
2603:              *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
2604:              *
2605:              *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
2606:              *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
2607:              *
2608:              * Return(s)   : none.
2609:              *
2610:              * Caller(s)   : Mem_PoolCreate(),
2611:              *               Mem_SegAllocInternal().
2612:              *
2613:              * Note(s)     : none.
2614:              *********************************************************************************************************
2615:              */
2616:              
2617:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2618:              static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
2619:                                                              MEM_SEG     *p_seg,
2620:                                                              CPU_SIZE_T   size,
2621:                                                              LIB_ERR     *p_err)
2622:              {
2623:                  MEM_ALLOC_INFO  *p_alloc;
2624:              
2625:              
2626:                                                                              /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
2627:                  p_alloc = p_seg->AllocInfoHeadPtr;
2628:                  while (p_alloc != DEF_NULL) {
2629:                      if (p_alloc->NamePtr == p_name) {
2630:                          p_alloc->Size += size;
2631:                         *p_err = LIB_MEM_ERR_NONE;
2632:                          return;
2633:                      }
2634:              
2635:                      p_alloc = p_alloc->NextPtr;
2636:                  }
2637:              
2638:                                                                              /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
2639:                  p_alloc = Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
2640:                                                     sizeof(MEM_ALLOC_INFO),
2641:                                                     sizeof(CPU_ALIGN),
2642:                                                     LIB_MEM_PADDING_ALIGN_NONE,
2643:                                                     DEF_NULL,
2644:                                                     p_err);
2645:                  if (*p_err != LIB_MEM_ERR_NONE) {
2646:                      return;
2647:                  }
2648:              
2649:                  p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
2650:                  p_alloc->Size    = size;
2651:              
2652:                  p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
2653:                  p_seg->AllocInfoHeadPtr = p_alloc;
2654:              }
2655:              #endif
2656:              
2657:              
2658:              /*
2659:              *********************************************************************************************************
2660:              *                                     Mem_DynPoolCreateInternal()
2661:              *
2662:              * Description : Creates a dynamic memory pool.
2663:              *
2664:              * Argument(s) : p_name              Pointer to pool name.
2665:              *
2666:              *               p_pool              Pointer to pool data.
2667:              *
2668:              *               p_seg               Pointer to segment from which to allocate memory.
2669:              *
2670:              *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
2671:              *
2672:              *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
2673:              *
2674:              *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
2675:              *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2676:              *                                   means no padding.
2677:              *
2678:              *               blk_qty_init        Initial number of elements to be allocated in pool.
2679:              *
2680:              *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
2681:              *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
2682:              *
2683:              *               p_err           Pointer to variable that will receive the return error code from this function :
2684:              *
2685:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
2686:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
2687:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
2688:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
2689:              *
2690:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
2691:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2692:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2693:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2694:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2695:              *
2696:              * Return(s)   : None.
2697:              *
2698:              * Caller(s)   : Mem_DynPoolCreate(),
2699:              *               Mem_DynPoolCreateHW().
2700:              *
2701:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
2702:              *                   block is stored in the block itself (only when free/unused).
2703:              *********************************************************************************************************
2704:              */
2705:              
2706:              static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
002D8C  40810B     ADD W1, W11, W2
002D9A  B9D902     MUL.SS W11, W2, W2
2707:                                                              MEM_DYN_POOL  *p_pool,
2708:                                                              MEM_SEG       *p_seg,
2709:                                                              CPU_SIZE_T     blk_size,
2710:                                                              CPU_SIZE_T     blk_align,
2711:                                                              CPU_SIZE_T     blk_padding_align,
2712:                                                              CPU_SIZE_T     blk_qty_init,
2713:                                                              CPU_SIZE_T     blk_qty_max,
2714:                                                              LIB_ERR       *p_err)
2715:              {
002D0E  4787EA     ADD W15, #0xA, W15
002D10  BE9F88     MOV.D W8, [W15++]
002D12  BE9F8A     MOV.D W10, [W15++]
002D14  BE9F8C     MOV.D W12, [W15++]
002D16  781F8E     MOV W14, [W15++]
002D18  9FB7E0     MOV W0, [W15-20]
002D1A  780401     MOV W1, W8
002D1C  9FB7F2     MOV W2, [W15-18]
002D1E  780603     MOV W3, W12
002D20  780705     MOV W5, W14
002D22  780506     MOV W6, W10
002D24  9FB7D7     MOV W7, [W15-22]
002D26  97B39F     MOV [W15-30], W7
2716:                  CPU_INT08U  *p_blks;
2717:                  CPU_SIZE_T   blk_size_align;
2718:                  CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
002D28  78048E     MOV W14, W9
002D2A  570F84     SUB W14, W4, [W15]
002D2C  310001     BRA C, 0x2D30
002D2E  780484     MOV W4, W9
002D30  EA0589     NEG W9, W11
002D32  E90009     DEC W9, W0
2719:              
2720:              
2721:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2722:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2723:                      CPU_SW_EXCEPTION(DEF_NULL);
2724:                  }
2725:              
2726:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2727:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2728:                      return;
2729:                  }
2730:              
2731:                  if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
2732:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
2733:                      return;
2734:                  }
2735:              
2736:                  if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
2737:                      (blk_qty_init >  blk_qty_max)) {
2738:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
2739:                      return;
2740:                  }
2741:              
2742:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
2743:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
2744:                      return;
2745:                  }
2746:              #endif
2747:              
2748:                                                                              /* Calc blk size with align.                            */
2749:                  if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
002D34  560FE1     SUB W12, #0x1, [W15]
002D36  3E0005     BRA GTU, 0x2D42
2750:                                                                              /* ... inc size to ptr size.                            */
2751:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
002D38  6585E2     AND W11, #0x2, W11
002D3A  A31800     BTST.Z W0, #1
002D3C  3A0006     BRA NZ, 0x2D4A
002D3E  EB0000     CLR W0
002D40  370005     BRA 0x2D4C
2752:                  } else {
2753:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
002D42  65858C     AND W11, W12, W11
002D44  60008C     AND W0, W12, W1
002D46  EB0000     CLR W0
002D48  320001     BRA Z, 0x2D4C
002D4A  780009     MOV W9, W0
002D4C  40058B     ADD W0, W11, W11
2754:                  }
2755:              
2756:                  if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
002D4E  E0000A     CP0 W10
002D50  32000F     BRA Z, 0x2D70
2757:                      p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
002D52  B9D80A     MUL.SS W11, W10, W0
002D54  780307     MOV W7, W6
002D56  EB0280     CLR W5
002D58  200014     MOV #0x1, W4
002D5A  780189     MOV W9, W3
002D5C  780100     MOV W0, W2
002D5E  97B0FF     MOV [W15-18], W1
002D60  97B06F     MOV [W15-20], W0
002D62  9FBF87     MOV W7, [W15-16]
002D64  07FFBB     RCALL _Mem_SegAllocInternal
002D6E  780680     MOV W0, W13
2758:                                                                  p_seg,
2759:                                                                  blk_size_align * blk_qty_init,
2760:                                                                  blk_align_worst,
2761:                                                                  LIB_MEM_PADDING_ALIGN_NONE,
2762:                                                                  DEF_NULL,
2763:                                                                  p_err);
2764:                      if (*p_err != LIB_MEM_ERR_NONE) {
002D66  227101     MOV #0x2710, W1
002D68  97BB8F     MOV [W15-16], W7
002D6A  108F97     SUBR W1, [W7], [W15]
002D6C  3A001D     BRA NZ, 0x2DA8
2765:                          return;
2766:                      }
2767:                  }
2768:              
2769:              
2770:                                                                              /* ----------------- CREATE POOL DATA ----------------- */
2771:                  p_pool->PoolSegPtr      = p_seg;
002D70  97B07F     MOV [W15-18], W0
002D72  780C00     MOV W0, [W8]
2772:                  p_pool->BlkSize         = blk_size;
002D74  98041C     MOV W12, [W8+2]
2773:                  p_pool->BlkAlign        = blk_align_worst;
002D76  980429     MOV W9, [W8+4]
2774:                  p_pool->BlkPaddingAlign = blk_padding_align;
002D78  98043E     MOV W14, [W8+6]
2775:                  p_pool->BlkQtyMax       = blk_qty_max;
002D7A  97B05F     MOV [W15-22], W0
002D7C  980450     MOV W0, [W8+10]
2776:                  p_pool->BlkAllocCnt     = 0u;
002D7E  EB0000     CLR W0
002D80  980460     MOV W0, [W8+12]
2777:              
2778:                  if (blk_qty_init != 0u) {                                   /* Init free list.                                      */
002D82  E0000A     CP0 W10
002D84  32000E     BRA Z, 0x2DA2
2779:                      CPU_SIZE_T  i;
2780:              
2781:              
2782:                      p_pool->BlkFreePtr = (void *)p_blks;
002D86  98044D     MOV W13, [W8+8]
2783:                      for (i = 0u; i < blk_qty_init - 1u; i++) {
002D88  78008D     MOV W13, W1
002D8A  370004     BRA 0x2D94
002D92  E80000     INC W0, W0
002D94  E9010A     DEC W10, W2
002D96  500F82     SUB W0, W2, [W15]
002D98  39FFF9     BRA NC, 0x2D8C
2784:                         *((void **)p_blks)  = p_blks + blk_size_align;
002D8E  780882     MOV W2, [W1]
002D90  780082     MOV W2, W1
2785:                          p_blks            += blk_size_align;
2786:                      }
2787:                     *((void **)p_blks) = DEF_NULL;
002D9C  EB0000     CLR W0
002D9E  793680     MOV W0, [W13+W2]
002DA0  370001     BRA 0x2DA4
2788:                  } else {
2789:                      p_pool->BlkFreePtr = DEF_NULL;
002DA2  98044A     MOV W10, [W8+8]
2790:                  }
2791:              
2792:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2793:                  p_pool->NamePtr = p_name;
2794:              #endif
2795:              
2796:                 *p_err = LIB_MEM_ERR_NONE;
002DA4  227100     MOV #0x2710, W0
002DA6  780B80     MOV W0, [W7]
2797:              }
002DA8  78074F     MOV [--W15], W14
002DAA  BE064F     MOV.D [--W15], W12
002DAC  BE054F     MOV.D [--W15], W10
002DAE  BE044F     MOV.D [--W15], W8
002DB0  B100AF     SUB #0xA, W15
002DB2  060000     RETURN
2798:              
2799:              
2800:              /*
2801:              *********************************************************************************************************
2802:              *                                      Mem_PoolBlkIsValidAddr()
2803:              *
2804:              * Description : Calculates if a given memory block address is valid for the memory pool.
2805:              *
2806:              * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
2807:              *               ------   Argument validated by caller.
2808:              *
2809:              *               p_mem    Pointer to memory block address to validate.
2810:              *               -----    Argument validated by caller.
2811:              *
2812:              * Return(s)   : DEF_YES, if valid memory pool block address.
2813:              *
2814:              *               DEF_NO,  otherwise.
2815:              *
2816:              * Caller(s)   : Mem_PoolBlkFree().
2817:              *
2818:              * Note(s)     : none.
2819:              *********************************************************************************************************
2820:              */
2821:              
2822:              #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
2823:                   (LIB_MEM_CFG_HEAP_SIZE      >  0u))
2824:              static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
2825:                                                           void      *p_mem)
2826:              {
2827:                  CPU_ADDR  pool_offset;
2828:              
2829:              
2830:                  if ((p_mem < p_pool->PoolAddrStart) ||
2831:                      (p_mem > p_pool->PoolAddrEnd)) {
2832:                      return (DEF_FALSE);
2833:                  }
2834:              
2835:                  pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
2836:                  if (pool_offset % p_pool->BlkSize != 0u) {
2837:                      return (DEF_FALSE);
2838:                  } else {
2839:                      return (DEF_TRUE);
2840:                  }
2841:              }
2842:              #endif
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uC-LIB/lib_math.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                        MATHEMATIC OPERATIONS
29:                *
30:                * Filename      : lib_math.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : SR
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *********************************************************************************************************
51:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
52:                *                     us permission to reprint portions of their documentation.  Portions of this text are
53:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
54:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
55:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
56:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
57:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
58:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
59:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
60:                *********************************************************************************************************
61:                */
62:                
63:                
64:                /*
65:                *********************************************************************************************************
66:                *                                            INCLUDE FILES
67:                *********************************************************************************************************
68:                */
69:                
70:                #define    MICRIUM_SOURCE
71:                #define    LIB_MATH_MODULE
72:                #include  <lib_math.h>
73:                
74:                
75:                /*
76:                *********************************************************************************************************
77:                *                                            LOCAL DEFINES
78:                *********************************************************************************************************
79:                */
80:                
81:                
82:                /*
83:                *********************************************************************************************************
84:                *                                           LOCAL CONSTANTS
85:                *********************************************************************************************************
86:                */
87:                
88:                
89:                /*
90:                *********************************************************************************************************
91:                *                                          LOCAL DATA TYPES
92:                *********************************************************************************************************
93:                */
94:                
95:                
96:                /*
97:                *********************************************************************************************************
98:                *                                            LOCAL TABLES
99:                *********************************************************************************************************
100:               */
101:               
102:               
103:               /*
104:               *********************************************************************************************************
105:               *                                       LOCAL GLOBAL VARIABLES
106:               *********************************************************************************************************
107:               */
108:               
109:               RAND_NBR  Math_RandSeedCur;                                     /* Cur rand nbr seed.                                   */
110:               
111:               
112:               /*
113:               *********************************************************************************************************
114:               *                                      LOCAL FUNCTION PROTOTYPES
115:               *********************************************************************************************************
116:               */
117:               
118:               
119:               /*
120:               *********************************************************************************************************
121:               *                                     LOCAL CONFIGURATION ERRORS
122:               *********************************************************************************************************
123:               */
124:               
125:               
126:               /*
127:               *********************************************************************************************************
128:               *                                             Math_Init()
129:               *
130:               * Description : (1) Initialize Mathematic Module :
131:               *
132:               *                   (a) Initialize random number seed value
133:               *
134:               *
135:               * Argument(s) : none.
136:               *
137:               * Return(s)   : none.
138:               *
139:               * Caller(s)   : Application.
140:               *
141:               * Note(s)     : (2) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "if rand()
142:               *                   is called before any calls to srand() are made, the same sequence shall be generated
143:               *                   as when srand() is first called with a seed value of 1".
144:               *********************************************************************************************************
145:               */
146:               
147:               void  Math_Init (void)
148:               {
149:                   Math_RandSetSeed((RAND_NBR)RAND_SEED_INIT_VAL);             /* See Note #2.                                         */
005156  200010     MOV #0x1, W0
005158  200001     MOV #0x0, W1
00515A  37FFF5     BRA Math_RandSetSeed
150:               }
151:               
152:               
153:               /*
154:               *********************************************************************************************************
155:               *                                         Math_RandSetSeed()
156:               *
157:               * Description : Set the current pseudo-random number generator seed.
158:               *
159:               * Argument(s) : seed        Initial (or current) value to set for the pseudo-random number sequence.
160:               *
161:               * Return(s)   : none.
162:               *
163:               * Caller(s)   : Application.
164:               *
165:               * Note(s)     : (1) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "srand()
166:               *                   ... uses the argument as a seed for a new sequence of pseudo-random numbers to be
167:               *                   returned by subsequent calls to rand()".
168:               *
169:               *               (2) 'Math_RandSeedCur' MUST always be accessed exclusively in critical sections.
170:               *
171:               *                   See also 'Math_Rand()  Note #1b'.
172:               *********************************************************************************************************
173:               */
174:               
175:               void  Math_RandSetSeed (RAND_NBR  seed)
176:               {
005146  BE0100     MOV.D W0, W2
177:                   CPU_SR_ALLOC();
178:               
179:               
180:                   CPU_CRITICAL_ENTER();
005148  800211     MOV SR, W1
00514A  200E00     MOV #0xE0, W0
00514C  B72042     IOR SR
181:                   Math_RandSeedCur = seed;
00514E  884202     MOV W2, Math_RandSeedCur
005150  884213     MOV W3, 0x842
182:                   CPU_CRITICAL_EXIT();
005152  880211     MOV W1, SR
183:               }
005154  060000     RETURN
184:               
185:               
186:               /*
187:               *********************************************************************************************************
188:               *                                             Math_Rand()
189:               *
190:               * Description : Calculate the next pseudo-random number.
191:               *
192:               * Argument(s) : none.
193:               *
194:               * Return(s)   : Next pseudo-random number in the sequence after 'Math_RandSeedCur'.
195:               *
196:               * Caller(s)   : Application.
197:               *
198:               * Note(s)     : (1) (a) The pseudo-random number generator is implemented as a Linear Congruential
199:               *                       Generator (LCG).
200:               *
201:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
202:               *
203:               *                   See also 'Math_RandSeed()  Note #1'.
204:               *
205:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
206:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
207:               *
208:               *                   (b) However, in order to implement Math_Rand() as re-entrant; 'Math_RandSeedCur' MUST
209:               *                       always be accessed & updated exclusively in critical sections.
210:               *
211:               *                   See also 'Math_RandSeed()  Note #2'.
212:               *********************************************************************************************************
213:               */
214:               
215:               RAND_NBR  Math_Rand (void)
216:               {
005176  781F88     MOV W8, [W15++]
217:                   RAND_NBR  seed;
218:                   RAND_NBR  rand_nbr;
219:                   CPU_SR_ALLOC();
220:               
221:               
222:                   CPU_CRITICAL_ENTER();
005178  800218     MOV SR, W8
00517A  200E00     MOV #0xE0, W0
00517C  B72042     IOR SR
223:                   seed             = Math_RandSeedCur;
224:                   rand_nbr         = Math_RandSeed(seed);
00517E  804200     MOV Math_RandSeedCur, W0
005180  804211     MOV 0x842, W1
005182  07FFEC     RCALL Math_RandSeed
225:                   Math_RandSeedCur = rand_nbr;
005184  884200     MOV W0, Math_RandSeedCur
005186  884211     MOV W1, 0x842
226:                   CPU_CRITICAL_EXIT();
005188  880218     MOV W8, SR
227:               
228:                   return (rand_nbr);
229:               }
00518A  78044F     MOV [--W15], W8
230:               
231:               
232:               /*
233:               *********************************************************************************************************
234:               *                                           Math_RandSeed()
235:               *
236:               * Description : Calculate the next pseudo-random number.
237:               *
238:               * Argument(s) : seed        Initial (or current) value for the pseudo-random number sequence.
239:               *
240:               * Return(s)   : Next pseudo-random number in the sequence after 'seed'.
241:               *
242:               * Caller(s)   : Math_Rand(),
243:               *               Application.
244:               *
245:               * Note(s)     : (1) (a) BSD/ANSI-C implements rand() as a Linear Congruential Generator (LCG) :
246:               *
247:               *                       (A) random_number       =  [(a * random_number ) + b]  modulo m
248:               *                                        n + 1                        n
249:               *
250:               *                               where
251:               *                                       (1) (a) random_number           Next     random number to generate
252:               *                                                            n+1
253:               *                                           (b) random_number           Previous random number    generated
254:               *                                                            n
255:               *
256:               *                                       (2) a = RAND_LCG_PARAM_A        LCG multiplier
257:               *                                       (3) b = RAND_LCG_PARAM_B        LCG incrementor
258:               *                                       (4) m = RAND_LCG_PARAM_M + 1    LCG modulus
259:               *
260:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
261:               *
262:                                   See also 'lib_math.h  RANDOM NUMBER DEFINES  Note #1b'.
263:               *
264:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
265:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
266:               *
267:               *                   (b) However, Math_RandSeed() is re-entrant since it calculates the next random number
268:               *                       using ONLY local variables.
269:               *********************************************************************************************************
270:               */
271:               
272:               RAND_NBR  Math_RandSeed (RAND_NBR  seed)
273:               {
274:                   RAND_NBR  rand_nbr;
275:               
276:               
277:                   rand_nbr = (((RAND_NBR)RAND_LCG_PARAM_A * seed) + (RAND_NBR)RAND_LCG_PARAM_B)  %  ((RAND_NBR)RAND_LCG_PARAM_M + 1u);
00515C  24E6D2     MOV #0x4E6D, W2
00515E  241C63     MOV #0x41C6, W3
005160  07DA90     RCALL 0x682
005162  230392     MOV #0x3039, W2
005164  200003     MOV #0x0, W3
005166  410200     ADD W2, W0, W4
005168  498281     ADDC W3, W1, W5
00516A  780105     MOV W5, W2
00516C  A1F002     BCLR W2, #15
00516E  780182     MOV W2, W3
005170  780104     MOV W4, W2
005172  BE0002     MOV.D W2, W0
278:               
279:                   return (rand_nbr);
280:               }
005174  060000     RETURN
281:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uC-LIB/lib_ascii.c  ------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     ASCII CHARACTER OPERATIONS
29:                *
30:                * Filename      : lib_ascii.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : BAN
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *
51:                *                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
52:                *                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
53:                *
54:                *                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
55:                *                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
56:                *                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
57:                *                             All other characters are explicitly specified.
58:                *
59:                *                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
60:                *                             in the 7-bit character set.
61:                *
62:                *                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
63:                *                             standard in specified ways.
64:                *
65:                *                     (b) The character set represented in this file reproduces the Internation Reference
66:                *                         Version.  This is identical to the 7-bit character set which occupies Unicode
67:                *                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
68:                *                         Unicode specification, with certain abbreviations so that the resulting #define
69:                *                         names will not violate ANSI C naming restriction :
70:                *
71:                *                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
72:                *                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
73:                *********************************************************************************************************
74:                */
75:                
76:                
77:                /*
78:                *********************************************************************************************************
79:                *                                            INCLUDE FILES
80:                *********************************************************************************************************
81:                */
82:                
83:                #define    MICRIUM_SOURCE
84:                #define    LIB_ASCII_MODULE
85:                #include  <lib_ascii.h>
86:                
87:                
88:                /*
89:                *********************************************************************************************************
90:                *                                            LOCAL DEFINES
91:                *********************************************************************************************************
92:                */
93:                
94:                
95:                /*
96:                *********************************************************************************************************
97:                *                                           LOCAL CONSTANTS
98:                *********************************************************************************************************
99:                */
100:               
101:               
102:               /*
103:               *********************************************************************************************************
104:               *                                          LOCAL DATA TYPES
105:               *********************************************************************************************************
106:               */
107:               
108:               
109:               /*
110:               *********************************************************************************************************
111:               *                                            LOCAL TABLES
112:               *********************************************************************************************************
113:               */
114:               
115:               
116:               /*
117:               *********************************************************************************************************
118:               *                                       LOCAL GLOBAL VARIABLES
119:               *********************************************************************************************************
120:               */
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                      LOCAL FUNCTION PROTOTYPES
126:               *********************************************************************************************************
127:               */
128:               
129:               
130:               /*
131:               *********************************************************************************************************
132:               *                                     LOCAL CONFIGURATION ERRORS
133:               *********************************************************************************************************
134:               */
135:               
136:               
137:               /*
138:               *********************************************************************************************************
139:               *                                           ASCII_IsAlpha()
140:               *
141:               * Description : Determine whether a character is an alphabetic character.
142:               *
143:               * Argument(s) : c           Character to examine.
144:               *
145:               * Return(s)   : DEF_YES, if character is     an alphabetic character.
146:               *
147:               *               DEF_NO,     if character is NOT an alphabetic character.
148:               *
149:               * Caller(s)   : Application.
150:               *
151:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
152:               *                   characters for which isupper() or islower() is true".
153:               *********************************************************************************************************
154:               */
155:               
156:               CPU_BOOLEAN  ASCII_IsAlpha (CPU_CHAR  c)
157:               {
004660  784080     MOV.B W0, W1
158:                   CPU_BOOLEAN  alpha;
159:               
160:               
161:                   alpha = ASCII_IS_ALPHA(c);
004662  B3CBF2     MOV.B #0xBF, W2
004664  40C102     ADD.B W1, W2, W2
004666  B3C010     MOV.B #0x1, W0
004668  514FF9     SUB.B W2, #0x19, [W15]
00466A  360005     BRA LEU, 0x4676
00466C  B3C9F2     MOV.B #0x9F, W2
00466E  40C082     ADD.B W1, W2, W1
004670  50CFF9     SUB.B W1, #0x19, [W15]
004672  360001     BRA LEU, 0x4676
004674  EB4000     CLR.B W0
162:               
163:                   return (alpha);
164:               }
004676  060000     RETURN
165:               
166:               
167:               /*
168:               *********************************************************************************************************
169:               *                                         ASCII_IsAlphaNum()
170:               *
171:               * Description : Determine whether a character is an alphanumeric character.
172:               *
173:               * Argument(s) : c           Character to examine.
174:               *
175:               * Return(s)   : DEF_YES, if character is     an alphanumeric character.
176:               *
177:               *               DEF_NO,     if character is NOT an alphanumeric character.
178:               *
179:               * Caller(s)   : Application.
180:               *
181:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
182:               *                   for which isalpha() or isdigit() is true".
183:               *********************************************************************************************************
184:               */
185:               
186:               CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
187:               {
188:                   CPU_BOOLEAN  alpha_num;
189:               
190:               
191:                   alpha_num = ASCII_IS_ALPHA_NUM(c);
004678  B3CBF2     MOV.B #0xBF, W2
00467A  404102     ADD.B W0, W2, W2
00467C  B3C011     MOV.B #0x1, W1
00467E  514FF9     SUB.B W2, #0x19, [W15]
004680  360009     BRA LEU, 0x4694
004682  B3C9F2     MOV.B #0x9F, W2
004684  404102     ADD.B W0, W2, W2
004686  514FF9     SUB.B W2, #0x19, [W15]
004688  360005     BRA LEU, 0x4694
00468A  B3CD02     MOV.B #0xD0, W2
00468C  404002     ADD.B W0, W2, W0
00468E  504FE9     SUB.B W0, #0x9, [W15]
004690  360001     BRA LEU, 0x4694
004692  EB4080     CLR.B W1
192:               
193:                   return (alpha_num);
194:               }
004694  784001     MOV.B W1, W0
004696  060000     RETURN
195:               
196:               
197:               /*
198:               *********************************************************************************************************
199:               *                                           ASCII_IsLower()
200:               *
201:               * Description : Determine whether a character is a lowercase alphabetic character.
202:               *
203:               * Argument(s) : c           Character to examine.
204:               *
205:               * Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
206:               *
207:               *               DEF_NO,     if character is NOT a lowercase alphabetic character.
208:               *
209:               * Caller(s)   : Application.
210:               *
211:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
212:               *                   the lowercase letters".
213:               *********************************************************************************************************
214:               */
215:               
216:               CPU_BOOLEAN  ASCII_IsLower (CPU_CHAR  c)
217:               {
218:                   CPU_BOOLEAN  lower;
219:               
220:               
221:                   lower = ASCII_IS_LOWER(c);
004698  B3C9F1     MOV.B #0x9F, W1
00469A  404081     ADD.B W0, W1, W1
00469C  B3C010     MOV.B #0x1, W0
00469E  50CFF9     SUB.B W1, #0x19, [W15]
0046A0  360001     BRA LEU, 0x46A4
0046A2  EB4000     CLR.B W0
222:               
223:                   return (lower);
224:               }
0046A4  060000     RETURN
225:               
226:               
227:               /*
228:               *********************************************************************************************************
229:               *                                           ASCII_IsUpper()
230:               *
231:               * Description : Determine whether a character is an uppercase alphabetic character.
232:               *
233:               * Argument(s) : c           Character to examine.
234:               *
235:               * Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
236:               *
237:               *               DEF_NO,     if character is NOT an uppercase alphabetic character.
238:               *
239:               * Caller(s)   : Application.
240:               *
241:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
242:               *                   the uppercase letters".
243:               *********************************************************************************************************
244:               */
245:               
246:               CPU_BOOLEAN  ASCII_IsUpper (CPU_CHAR  c)
247:               {
248:                   CPU_BOOLEAN  upper;
249:               
250:               
251:                   upper = ASCII_IS_UPPER(c);
0046A6  B3CBF1     MOV.B #0xBF, W1
0046A8  404081     ADD.B W0, W1, W1
0046AA  B3C010     MOV.B #0x1, W0
0046AC  50CFF9     SUB.B W1, #0x19, [W15]
0046AE  360001     BRA LEU, 0x46B2
0046B0  EB4000     CLR.B W0
252:               
253:                   return (upper);
254:               }
0046B2  060000     RETURN
255:               
256:               
257:               /*
258:               *********************************************************************************************************
259:               *                                            ASCII_IsDig()
260:               *
261:               * Description : Determine whether a character is a decimal-digit character.
262:               *
263:               * Argument(s) : c           Character to examine.
264:               *
265:               * Return(s)   : DEF_YES, if character is     a decimal-digit character.
266:               *
267:               *               DEF_NO,     if character is NOT a decimal-digit character.
268:               *
269:               * Caller(s)   : Application.
270:               *
271:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
272:               *                   decimal-digit character".
273:               *********************************************************************************************************
274:               */
275:               
276:               CPU_BOOLEAN  ASCII_IsDig (CPU_CHAR  c)
277:               {
278:                   CPU_BOOLEAN  dig;
279:               
280:               
281:                   dig = ASCII_IS_DIG(c);
0046B4  B3CD01     MOV.B #0xD0, W1
0046B6  404081     ADD.B W0, W1, W1
0046B8  B3C010     MOV.B #0x1, W0
0046BA  50CFE9     SUB.B W1, #0x9, [W15]
0046BC  360001     BRA LEU, 0x46C0
0046BE  EB4000     CLR.B W0
282:               
283:                   return (dig);
284:               }
0046C0  060000     RETURN
285:               
286:               
287:               /*
288:               *********************************************************************************************************
289:               *                                          ASCII_IsDigOct()
290:               *
291:               * Description : Determine whether a character is an octal-digit character.
292:               *
293:               * Argument(s) : c           Character to examine.
294:               *
295:               * Return(s)   : DEF_YES, if character is     an octal-digit character.
296:               *
297:               *               DEF_NO,     if character is NOT an octal-digit character.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               * Note(s)     : none.
302:               *********************************************************************************************************
303:               */
304:               
305:               CPU_BOOLEAN  ASCII_IsDigOct (CPU_CHAR  c)
306:               {
307:                   CPU_BOOLEAN  dig_oct;
308:               
309:               
310:                   dig_oct = ASCII_IS_DIG_OCT(c);
0046C2  B3CD01     MOV.B #0xD0, W1
0046C4  404081     ADD.B W0, W1, W1
0046C6  B3C010     MOV.B #0x1, W0
0046C8  50CFE7     SUB.B W1, #0x7, [W15]
0046CA  360001     BRA LEU, 0x46CE
0046CC  EB4000     CLR.B W0
311:               
312:                   return (dig_oct);
313:               }
0046CE  060000     RETURN
314:               
315:               
316:               /*
317:               *********************************************************************************************************
318:               *                                          ASCII_IsDigHex()
319:               *
320:               * Description : Determine whether a character is a hexadecimal-digit character.
321:               *
322:               * Argument(s) : c           Character to examine.
323:               *
324:               * Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
325:               *
326:               *               DEF_NO,     if character is NOT a hexadecimal-digit character.
327:               *
328:               * Caller(s)   : Application.
329:               *
330:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
331:               *                   hexadecimal-digit character".
332:               *********************************************************************************************************
333:               */
334:               
335:               CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
336:               {
337:                   CPU_BOOLEAN  dig_hex;
338:               
339:               
340:                   dig_hex = ASCII_IS_DIG_HEX(c);
0046D0  B3CD02     MOV.B #0xD0, W2
0046D2  404102     ADD.B W0, W2, W2
0046D4  B3C011     MOV.B #0x1, W1
0046D6  514FE9     SUB.B W2, #0x9, [W15]
0046D8  360009     BRA LEU, 0x46EC
0046DA  B3CBF2     MOV.B #0xBF, W2
0046DC  404102     ADD.B W0, W2, W2
0046DE  514FE5     SUB.B W2, #0x5, [W15]
0046E0  360005     BRA LEU, 0x46EC
0046E2  B3C9F2     MOV.B #0x9F, W2
0046E4  404002     ADD.B W0, W2, W0
0046E6  504FE5     SUB.B W0, #0x5, [W15]
0046E8  360001     BRA LEU, 0x46EC
0046EA  EB4080     CLR.B W1
341:               
342:                   return (dig_hex);
343:               }
0046EC  784001     MOV.B W1, W0
0046EE  060000     RETURN
344:               
345:               
346:               /*
347:               *********************************************************************************************************
348:               *                                           ASCII_IsBlank()
349:               *
350:               * Description : Determine whether a character is a standard blank character.
351:               *
352:               * Argument(s) : c           Character to examine.
353:               *
354:               * Return(s)   : DEF_YES, if character is     a standard blank character.
355:               *
356:               *               DEF_NO,     if character is NOT a standard blank character.
357:               *
358:               * Caller(s)   : Application.
359:               *
360:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
361:               *                       the standard blank characters".
362:               *
363:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
364:               *                       the "space (' '), and horizontal tab ('\t')".
365:               *********************************************************************************************************
366:               */
367:               
368:               CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
369:               {
0046F0  784080     MOV.B W0, W1
370:                   CPU_BOOLEAN  blank;
371:               
372:               
373:                   blank = ASCII_IS_BLANK(c);
0046F2  B3C010     MOV.B #0x1, W0
0046F4  B3C202     MOV.B #0x20, W2
0046F6  50CF82     SUB.B W1, W2, [W15]
0046F8  320004     BRA Z, 0x4702
0046FA  B2C091     XOR.B #0x9, W1
0046FC  FB8001     ZE W1, W0
0046FE  E90000     DEC W0, W0
004700  DE004F     LSR W0, #15, W0
374:               
375:                   return (blank);
376:               }
004702  060000     RETURN
377:               
378:               
379:               /*
380:               *********************************************************************************************************
381:               *                                           ASCII_IsSpace()
382:               *
383:               * Description : Determine whether a character is a white-space character.
384:               *
385:               * Argument(s) : c           Character to examine.
386:               *
387:               * Return(s)   : DEF_YES, if character is     a white-space character.
388:               *
389:               *               DEF_NO,     if character is NOT a white-space character.
390:               *
391:               * Caller(s)   : Application.
392:               *
393:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
394:               *                       for the standard white-space characters".
395:               *
396:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
397:               *                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
398:               *                       horizontal tab ('\t'), and vertical tab ('\v')".
399:               *********************************************************************************************************
400:               */
401:               
402:               CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
403:               {
404:                   CPU_BOOLEAN  space;
405:               
406:               
407:                   space = ASCII_IS_SPACE(c);
004704  B3C011     MOV.B #0x1, W1
004706  B3C202     MOV.B #0x20, W2
004708  504F82     SUB.B W0, W2, [W15]
00470A  32000C     BRA Z, 0x4724
00470C  504FED     SUB.B W0, #0xD, [W15]
00470E  32000A     BRA Z, 0x4724
004710  504FEA     SUB.B W0, #0xA, [W15]
004712  320008     BRA Z, 0x4724
004714  504FEC     SUB.B W0, #0xC, [W15]
004716  320006     BRA Z, 0x4724
004718  504FE9     SUB.B W0, #0x9, [W15]
00471A  320004     BRA Z, 0x4724
00471C  B2C0B0     XOR.B #0xB, W0
00471E  FB8080     ZE W0, W1
004720  E90081     DEC W1, W1
004722  DE08CF     LSR W1, #15, W1
408:               
409:                   return (space);
410:               }
004724  784001     MOV.B W1, W0
004726  060000     RETURN
411:               
412:               
413:               /*
414:               *********************************************************************************************************
415:               *                                           ASCII_IsPrint()
416:               *
417:               * Description : Determine whether a character is a printing character.
418:               *
419:               * Argument(s) : c           Character to examine.
420:               *
421:               * Return(s)   : DEF_YES, if character is     a printing character.
422:               *
423:               *               DEF_NO,     if character is NOT a printing character.
424:               *
425:               * Caller(s)   : Application.
426:               *
427:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
428:               *                       printing character including space (' ')".
429:               *
430:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
431:               *                       ASCII character set, the printing characters are those whose values lie from
432:               *                       0x20 (space) through 0x7E (tilde)".
433:               *********************************************************************************************************
434:               */
435:               
436:               CPU_BOOLEAN  ASCII_IsPrint (CPU_CHAR  c)
437:               {
438:                   CPU_BOOLEAN  print;
439:               
440:               
441:                   print = ASCII_IS_PRINT(c);
004728  B3CE01     MOV.B #0xE0, W1
00472A  404101     ADD.B W0, W1, W2
00472C  B3C010     MOV.B #0x1, W0
00472E  B3C5E1     MOV.B #0x5E, W1
004730  514F81     SUB.B W2, W1, [W15]
004732  360001     BRA LEU, 0x4736
004734  EB4000     CLR.B W0
442:               
443:                   return (print);
444:               }
004736  060000     RETURN
445:               
446:               
447:               /*
448:               *********************************************************************************************************
449:               *                                           ASCII_IsGraph()
450:               *
451:               * Description : Determine whether a character is any printing character except a space character.
452:               *
453:               * Argument(s) : c           Character to examine.
454:               *
455:               * Return(s)   : DEF_YES, if character is     a graphic character.
456:               *
457:               *               DEF_NO,     if character is NOT a graphic character.
458:               *
459:               * Caller(s)   : Application.
460:               *
461:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
462:               *                       printing character except space (' ')".
463:               *
464:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
465:               *                       ASCII character set, the printing characters are those whose values lie from
466:               *                       0x20 (space) through 0x7E (tilde)".
467:               *********************************************************************************************************
468:               */
469:               
470:               CPU_BOOLEAN  ASCII_IsGraph (CPU_CHAR  c)
471:               {
472:                   CPU_BOOLEAN  graph;
473:               
474:               
475:                   graph = ASCII_IS_GRAPH(c);
004738  B3CDF1     MOV.B #0xDF, W1
00473A  404101     ADD.B W0, W1, W2
00473C  B3C010     MOV.B #0x1, W0
00473E  B3C5D1     MOV.B #0x5D, W1
004740  514F81     SUB.B W2, W1, [W15]
004742  360001     BRA LEU, 0x4746
004744  EB4000     CLR.B W0
476:               
477:                   return (graph);
478:               }
004746  060000     RETURN
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           ASCII_IsPunct()
484:               *
485:               * Description : Determine whether a character is a punctuation character.
486:               *
487:               * Argument(s) : c           Character to examine.
488:               *
489:               * Return(s)   : DEF_YES, if character is     a punctuation character.
490:               *
491:               *               DEF_NO,     if character is NOT a punctuation character.
492:               *
493:               * Caller(s)   : Application.
494:               *
495:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
496:               *                   printing character for which neither isspace() nor isalnum() is true".
497:               *********************************************************************************************************
498:               */
499:               
500:               CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
004770  B3C010     MOV.B #0x1, W0
004772  50CFE9     SUB.B W1, #0x9, [W15]
004774  3E0001     BRA GTU, 0x4778
004776  EB4000     CLR.B W0
501:               {
004748  784080     MOV.B W0, W1
502:                   CPU_BOOLEAN  punct;
503:               
504:               
505:                   punct = ASCII_IS_PUNCT(c);
00474A  B3CE03     MOV.B #0xE0, W3
00474C  40C183     ADD.B W1, W3, W3
00474E  EB4000     CLR.B W0
004750  B3C5E2     MOV.B #0x5E, W2
004752  51CF82     SUB.B W3, W2, [W15]
004754  3E0011     BRA GTU, 0x4778
004756  B3C202     MOV.B #0x20, W2
004758  50CF82     SUB.B W1, W2, [W15]
00475A  32000E     BRA Z, 0x4778
00475C  B3CBF2     MOV.B #0xBF, W2
00475E  40C102     ADD.B W1, W2, W2
004760  514FF9     SUB.B W2, #0x19, [W15]
004762  36000A     BRA LEU, 0x4778
004764  B3C9F2     MOV.B #0x9F, W2
004766  40C102     ADD.B W1, W2, W2
004768  514FF9     SUB.B W2, #0x19, [W15]
00476A  360006     BRA LEU, 0x4778
00476C  B3CD00     MOV.B #0xD0, W0
00476E  40C080     ADD.B W1, W0, W1
506:               
507:                   return (punct);
508:               }
004778  060000     RETURN
509:               
510:               
511:               /*
512:               *********************************************************************************************************
513:               *                                           ASCII_IsCtrl()
514:               *
515:               * Description : Determine whether a character is a control character.
516:               *
517:               * Argument(s) : c           Character to examine.
518:               *
519:               * Return(s)   : DEF_YES, if character is     a control character.
520:               *
521:               *               DEF_NO,     if character is NOT a control character.
522:               *
523:               * Caller(s)   : Application.
524:               *
525:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
526:               *                       control character".
527:               *
528:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
529:               *                       ASCII character set, ... the control characters are those whose values lie from
530:               *                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
531:               *********************************************************************************************************
532:               */
533:               
534:               CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
535:               {
00477A  784080     MOV.B W0, W1
536:                   CPU_BOOLEAN  ctrl;
537:               
538:               
539:                   ctrl = ASCII_IS_CTRL(c);
00477C  B3C010     MOV.B #0x1, W0
00477E  50CFFF     SUB.B W1, #0x1F, [W15]
004780  360004     BRA LEU, 0x478A
004782  B2C7F1     XOR.B #0x7F, W1
004784  FB8001     ZE W1, W0
004786  E90000     DEC W0, W0
004788  DE004F     LSR W0, #15, W0
540:               
541:                   return (ctrl);
542:               }
00478A  060000     RETURN
543:               
544:               
545:               /*
546:               *********************************************************************************************************
547:               *                                           ASCII_ToLower()
548:               *
549:               * Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
550:               *
551:               * Argument(s) : c           Character to convert.
552:               *
553:               * Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
554:               *
555:               *               Character 'c',               otherwise                                  (see Note #1b2).
556:               *
557:               * Caller(s)   : Application.
558:               *
559:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
560:               *                       uppercase letter to a corresponding lowercase letter".
561:               *
562:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
563:               *
564:               *                       (1) (A) "if the argument is a character for which isupper() is true and there are
565:               *                                one or more corresponding characters ... for which islower() is true," ...
566:               *                           (B) "tolower() ... returns one of the corresponding characters;" ...
567:               *
568:               *                       (2) "otherwise, the argument is returned unchanged."
569:               *********************************************************************************************************
570:               */
571:               
572:               CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
573:               {
574:                   CPU_CHAR  lower;
575:               
576:               
577:                   lower = ASCII_TO_LOWER(c);
00478C  B3CBF1     MOV.B #0xBF, W1
00478E  404081     ADD.B W0, W1, W1
004790  50CFF9     SUB.B W1, #0x19, [W15]
004792  3E0001     BRA GTU, 0x4796
004794  B04200     ADD.B #0x20, W0
578:               
579:                   return (lower);
580:               }
004796  060000     RETURN
581:               
582:               
583:               /*
584:               *********************************************************************************************************
585:               *                                           ASCII_ToUpper()
586:               *
587:               * Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
588:               *
589:               * Argument(s) : c           Character to convert.
590:               *
591:               * Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
592:               *
593:               *               Character 'c',               otherwise                                 (see Note #1b2).
594:               *
595:               * Caller(s)   : Application.
596:               *
597:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
598:               *                       lowercase letter to a corresponding uppercase letter".
599:               *
600:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
601:               *
602:               *                       (1) (A) "if the argument is a character for which islower() is true and there are
603:               *                                one or more corresponding characters ... for which isupper() is true," ...
604:               *                           (B) "toupper() ... returns one of the corresponding characters;" ...
605:               *
606:               *                       (2) "otherwise, the argument is returned unchanged."
607:               *********************************************************************************************************
608:               */
609:               
610:               CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
611:               {
612:                   CPU_CHAR  upper;
613:               
614:               
615:                   upper = ASCII_TO_UPPER(c);
004798  B3C9F1     MOV.B #0x9F, W1
00479A  404081     ADD.B W0, W1, W1
00479C  50CFF9     SUB.B W1, #0x19, [W15]
00479E  3E0002     BRA GTU, 0x47A4
0047A0  B3CE01     MOV.B #0xE0, W1
0047A2  404001     ADD.B W0, W1, W0
616:               
617:                   return (upper);
618:               }
0047A4  060000     RETURN
619:               
620:               
621:               /*
622:               *********************************************************************************************************
623:               *                                             ASCII_Cmp()
624:               *
625:               * Description : Determine if two characters are identical (case-insensitive).
626:               *
627:               * Argument(s) : c1          First  character.
628:               *
629:               *               c2          Second character.
630:               *
631:               * Return(s)   : DEF_YES, if the characters are     identical.
632:               *
633:               *               DEF_NO,  if the characters are NOT identical.
634:               *
635:               * Caller(s)   : Application.
636:               *
637:               * Note(s)     : none.
638:               *********************************************************************************************************
639:               */
640:               
641:               CPU_BOOLEAN  ASCII_Cmp (CPU_CHAR  c1,
642:                                       CPU_CHAR  c2)
643:               {
0047A6  BE9F88     MOV.D W8, [W15++]
0047A8  784481     MOV.B W1, W9
644:                   CPU_CHAR     c1_upper;
645:                   CPU_CHAR     c2_upper;
646:                   CPU_BOOLEAN  cmp;
647:               
648:               
649:                   c1_upper =  ASCII_ToUpper(c1);
0047AA  07FFF6     RCALL ASCII_ToUpper
0047AC  784400     MOV.B W0, W8
650:                   c2_upper =  ASCII_ToUpper(c2);
0047AE  784009     MOV.B W9, W0
0047B0  07FFF3     RCALL ASCII_ToUpper
651:                   cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);
0047B2  6C4000     XOR.B W8, W0, W0
0047B4  FB8000     ZE W0, W0
0047B6  E90000     DEC W0, W0
0047B8  DE004F     LSR W0, #15, W0
652:               
653:                   return (cmp);
654:               }
0047BA  BE044F     MOV.D [--W15], W8
655:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/uC-CPU/cpu_core.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/CPU
4:                 *                                    CPU CONFIGURATION & PORT LAYER
5:                 *
6:                 *                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
7:                 *
8:                 *               All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *               uC/CPU is provided in source form to registered licensees ONLY.  It is
11:                *               illegal to distribute this source code to any third party unless you receive
12:                *               written permission by an authorized Micrium representative.  Knowledge of
13:                *               the source code may NOT be used to develop a similar product.
14:                *
15:                *               Please help us continue to provide the Embedded community with the finest
16:                *               software available.  Your honesty is greatly appreciated.
17:                *
18:                *               You can find our product's user manual, API reference, release notes and
19:                *               more information at https://doc.micrium.com.
20:                *               You can contact us at www.micrium.com.
21:                *********************************************************************************************************
22:                */
23:                
24:                /*
25:                *********************************************************************************************************
26:                *
27:                *                                           CORE CPU MODULE
28:                *
29:                * Filename      : cpu_core.c
30:                * Version       : V1.30.01
31:                * Programmer(s) : SR
32:                *                 ITJ
33:                *********************************************************************************************************
34:                */
35:                
36:                
37:                /*
38:                *********************************************************************************************************
39:                *                                            INCLUDE FILES
40:                *********************************************************************************************************
41:                */
42:                
43:                #define    MICRIUM_SOURCE
44:                #define    CPU_CORE_MODULE
45:                #include  "cpu_core.h"
46:                
47:                #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
48:                #include  "cpu_cache.h"
49:                #endif
50:                
51:                
52:                /*
53:                *********************************************************************************************************
54:                *                                            LOCAL DEFINES
55:                *********************************************************************************************************
56:                */
57:                
58:                
59:                /*
60:                *********************************************************************************************************
61:                *                                           LOCAL CONSTANTS
62:                *********************************************************************************************************
63:                */
64:                
65:                
66:                /*
67:                *********************************************************************************************************
68:                *                                          LOCAL DATA TYPES
69:                *********************************************************************************************************
70:                */
71:                
72:                
73:                /*
74:                *********************************************************************************************************
75:                *                                            LOCAL TABLES
76:                *********************************************************************************************************
77:                */
78:                
79:                /*
80:                *********************************************************************************************************
81:                *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
82:                *
83:                * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
84:                *
85:                *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
86:                *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
87:                *                          1    x    x    x    x    x    x    x            0
88:                *                          0    1    x    x    x    x    x    x            1
89:                *                          0    0    1    x    x    x    x    x            2
90:                *                          0    0    0    1    x    x    x    x            3
91:                *                          0    0    0    0    1    x    x    x            4
92:                *                          0    0    0    0    0    1    x    x            5
93:                *                          0    0    0    0    0    0    1    x            6
94:                *                          0    0    0    0    0    0    0    1            7
95:                *                          0    0    0    0    0    0    0    0            8
96:                *********************************************************************************************************
97:                */
98:                
99:                #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
100:                     (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))
101:               static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
102:               /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
103:                   8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
104:                   3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
105:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
106:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
107:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
108:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
109:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
110:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
111:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
112:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
113:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
114:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
115:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
116:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
117:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
118:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
119:               };
120:               #endif
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                       LOCAL GLOBAL VARIABLES
126:               *********************************************************************************************************
127:               */
128:               
129:               CPU_INT32U  const  CPU_EndiannessTest = 0x12345678LU;               /* Variable to test CPU endianness.                 */
130:               
131:               
132:               /*
133:               *********************************************************************************************************
134:               *                                      LOCAL FUNCTION PROTOTYPES
135:               *********************************************************************************************************
136:               */
137:               
138:               #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
139:               static  void        CPU_NameInit         (void);
140:               #endif
141:               
142:               
143:                                                                                   /* ----------------- CPU TS FNCTS ----------------- */
144:               #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
145:                      (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
146:               static  void        CPU_TS_Init          (void);
147:               #endif
148:               
149:               
150:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
151:               static  void        CPU_IntDisMeasInit   (void);
152:               
153:               static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
154:               #endif
155:               
156:               
157:               /*
158:               *********************************************************************************************************
159:               *                                     LOCAL CONFIGURATION ERRORS
160:               *********************************************************************************************************
161:               */
162:               
163:               
164:               /*
165:               *********************************************************************************************************
166:               *                                             CPU_Init()
167:               *
168:               * Description : (1) Initialize CPU module :
169:               *
170:               *                   (a) Initialize CPU timestamps
171:               *                   (b) Initialize CPU interrupts disabled time measurements
172:               *                   (c) Initialize CPU host name
173:               *
174:               *
175:               * Argument(s) : none.
176:               *
177:               * Return(s)   : none.
178:               *
179:               * Caller(s)   : Your Product's Application.
180:               *
181:               *               This function is a CPU initialization function & MAY be called by application/
182:               *               initialization function(s).
183:               *
184:               * Note(s)     : (2) CPU_Init() MUST be called ... :
185:               *
186:               *                   (a) ONLY ONCE from a product's application; ...
187:               *                   (b) BEFORE product's application calls any core CPU module function(s)
188:               *
189:               *               (3) The following initialization functions MUST be sequenced as follows :
190:               *
191:               *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
192:               *
193:               *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
194:               *                                                   & other CPU interrupts disabled time measurement functions
195:               *********************************************************************************************************
196:               */
197:               
198:               void  CPU_Init (void)
199:               {
200:                                                                               /* --------------------- INIT TS ---------------------- */
201:               #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
202:                    (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
203:                   CPU_TS_Init();                                              /* See Note #3a.                                        */
204:               #endif
205:                                                                               /* -------------- INIT INT DIS TIME MEAS -------------- */
206:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
207:                   CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
208:               #endif
209:               
210:                                                                               /* ------------------ INIT CPU NAME ------------------- */
211:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
212:                    CPU_NameInit();
213:               #endif
214:               
215:               #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
216:                    CPU_Cache_Init();
217:               #endif
218:               }
00415A  060000     RETURN
219:               
220:               
221:               /*
222:               *********************************************************************************************************
223:               *                                         CPU_SW_Exception()
224:               *
225:               * Description : Trap unrecoverable software exception.
226:               *
227:               * Argument(s) : none.
228:               *
229:               * Return(s)   : none.
230:               *
231:               * Caller(s)   : various.
232:               *
233:               * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
234:               *                   -processed/-threaded or single-threaded -- when the current code execution cannot 
235:               *                   gracefully recover or report a fault or exception condition.
236:               *
237:               *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
238:               *********************************************************************************************************
239:               */
240:               
241:               void  CPU_SW_Exception (void)
242:               {
00415C  37FFFF     BRA CPU_SW_Exception
243:                   while (DEF_ON) {
244:                       ;
245:                   }
246:               }
247:               
248:               
249:               /*
250:               *********************************************************************************************************
251:               *                                            CPU_NameClr()
252:               *
253:               * Description : Clear CPU Name.
254:               *
255:               * Argument(s) : none.
256:               *
257:               * Return(s)   : none.
258:               *
259:               * Caller(s)   : CPU_NameInit(),
260:               *               Application.
261:               *
262:               *               This function is a CPU module application programming interface (API) function & MAY be 
263:               *               called by application function(s).
264:               *
265:               * Note(s)     : none.
266:               *********************************************************************************************************
267:               */
268:               
269:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
270:               void  CPU_NameClr (void)
271:               {
272:                   CPU_SR_ALLOC();
273:               
274:               
275:                   CPU_CRITICAL_ENTER();
276:                   Mem_Clr((void     *)&CPU_Name[0],
277:                           (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
278:                   CPU_CRITICAL_EXIT();
279:               }
280:               #endif
281:               
282:               
283:               /*
284:               *********************************************************************************************************
285:               *                                            CPU_NameGet()
286:               *
287:               * Description : Get CPU host name.
288:               *
289:               * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
290:               *                               name ASCII string from this function (see Note #1).
291:               *
292:               *               p_err       Pointer to variable that will receive the return error code from this function :
293:               *
294:               *                               CPU_ERR_NONE                    CPU host name successfully returned.
295:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
296:               *
297:               * Return(s)   : none.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               *               This function is a CPU module application programming interface (API) function & MAY 
302:               *               be called by application function(s).
303:               *
304:               * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
305:               *                   ASCII string :
306:               *
307:               *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
308:               *                           size including the terminating NULL character;
309:               *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
310:               *********************************************************************************************************
311:               */
312:               
313:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
314:               void  CPU_NameGet (CPU_CHAR  *p_name,
315:                                  CPU_ERR   *p_err)
316:               {
317:                   CPU_SR_ALLOC();
318:               
319:               
320:                   if (p_err == (CPU_ERR *)0) {
321:                       CPU_SW_EXCEPTION(;);
322:                   }
323:               
324:                   if (p_name == (CPU_CHAR *)0) {
325:                      *p_err = CPU_ERR_NULL_PTR;
326:                       return;
327:                   }
328:               
329:                   CPU_CRITICAL_ENTER();
330:                  (void)Str_Copy_N(p_name,
331:                                  &CPU_Name[0],
332:                                   CPU_CFG_NAME_SIZE);
333:                   CPU_CRITICAL_EXIT();
334:               
335:                  *p_err = CPU_ERR_NONE;
336:               }
337:               #endif
338:               
339:               
340:               /*
341:               *********************************************************************************************************
342:               *                                            CPU_NameSet()
343:               *
344:               * Description : Set CPU host name.
345:               *
346:               * Argument(s) : p_name      Pointer to CPU host name to set.
347:               *
348:               *               p_err       Pointer to variable that will receive the return error code from this function :
349:               *
350:               *                               CPU_ERR_NONE                    CPU host name successfully set.
351:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
352:               *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
353:               *
354:               * Return(s)   : none.
355:               *
356:               * Caller(s)   : Application.
357:               *
358:               *               This function is a CPU module application programming interface (API) function & MAY be 
359:               *               called by application function(s).
360:               *
361:               * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
362:               *                    than or equal to CPU_CFG_NAME_SIZE.
363:               *********************************************************************************************************
364:               */
365:               
366:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
367:               void  CPU_NameSet (const  CPU_CHAR  *p_name,
368:                                         CPU_ERR   *p_err)
369:               {
370:                   CPU_SIZE_T  len;
371:                   CPU_SR_ALLOC();
372:               
373:               
374:                   if (p_err == (CPU_ERR *)0) {
375:                       CPU_SW_EXCEPTION(;);
376:                   }
377:               
378:                   if (p_name == (const CPU_CHAR *)0) {
379:                      *p_err = CPU_ERR_NULL_PTR;
380:                       return;
381:                   }
382:               
383:                   len = Str_Len_N(p_name,
384:                                   CPU_CFG_NAME_SIZE);
385:                   if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
386:                       CPU_CRITICAL_ENTER();
387:                      (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
388:                                        p_name,
389:                                        CPU_CFG_NAME_SIZE);
390:                       CPU_CRITICAL_EXIT();
391:                      *p_err = CPU_ERR_NONE;
392:               
393:                   } else {
394:                      *p_err = CPU_ERR_NAME_SIZE;
395:                   }
396:               }
397:               #endif
398:               
399:               
400:               /*
401:               *********************************************************************************************************
402:               *                                           CPU_TS_Get32()
403:               *
404:               * Description : Get current 32-bit CPU timestamp.
405:               *
406:               * Argument(s) : none.
407:               *
408:               * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
409:               *
410:               * Caller(s)   : Application.
411:               *
412:               *               This function is a CPU module application programming interface (API) function & MAY 
413:               *               be called by application function(s).
414:               *
415:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
416:               *                   either of the following equations :
417:               *
418:               *                       (a) Time measured  =  Number timer counts  *  Timer period
419:               *
420:               *                               where
421:               *
422:               *                                   Number timer counts     Number of timer counts measured
423:               *                                   Timer period            Timer's period in some units of
424:               *                                                               (fractional) seconds
425:               *                                   Time measured           Amount of time measured, in same
426:               *                                                               units of (fractional) seconds
427:               *                                                               as the Timer period
428:               *
429:               *                                              Number timer counts
430:               *                       (b) Time measured  =  ---------------------
431:               *                                                Timer frequency
432:               *
433:               *                               where
434:               *
435:               *                                   Number timer counts     Number of timer counts measured
436:               *                                   Timer frequency         Timer's frequency in some units
437:               *                                                               of counts per second
438:               *                                   Time measured           Amount of time measured, in seconds
439:               *
440:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
441:               *
442:               *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
443:               *                   its precision is extended via periodic updates by accumulating the deltas of the
444:               *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
445:               *
446:               *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
447:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
448:               *                   with critical sections.
449:               *********************************************************************************************************
450:               */
451:               
452:               #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
453:               CPU_TS32  CPU_TS_Get32 (void)
454:               {
455:                   CPU_TS32    ts;
456:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
457:                   CPU_TS_TMR  tmr_cur;
458:                   CPU_TS_TMR  tmr_delta;
459:                   CPU_SR_ALLOC();
460:               #endif
461:               
462:               
463:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
464:                   ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
465:               
466:               #else
467:                   CPU_INT_DIS();
468:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
469:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
470:                   CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
471:                   CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
472:                   ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
473:                   CPU_INT_EN();
474:               #endif
475:               
476:                   return (ts);
477:               }
478:               #endif
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           CPU_TS_Get64()
484:               *
485:               * Description : Get current 64-bit CPU timestamp.
486:               *
487:               * Argument(s) : none.
488:               *
489:               * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
490:               *
491:               * Caller(s)   : Application.
492:               *
493:               *               This function is a CPU module application programming interface (API) function & MAY 
494:               *               be called by application function(s).
495:               *
496:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
497:               *                   either of the following equations :
498:               *
499:               *                       (a) Time measured  =  Number timer counts  *  Timer period
500:               *
501:               *                               where
502:               *
503:               *                                   Number timer counts     Number of timer counts measured
504:               *                                   Timer period            Timer's period in some units of
505:               *                                                               (fractional) seconds
506:               *                                   Time measured           Amount of time measured, in same
507:               *                                                               units of (fractional) seconds
508:               *                                                               as the Timer period
509:               *
510:               *                                              Number timer counts
511:               *                       (b) Time measured  =  ---------------------
512:               *                                                Timer frequency
513:               *
514:               *                               where
515:               *
516:               *                                   Number timer counts     Number of timer counts measured
517:               *                                   Timer frequency         Timer's frequency in some units
518:               *                                                               of counts per second
519:               *                                   Time measured           Amount of time measured, in seconds
520:               *
521:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
522:               *
523:               *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
524:               *                   its precision is extended via periodic updates by accumulating the deltas of the
525:               *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
526:               *
527:               *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
528:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
529:               *                   with critical sections.
530:               *********************************************************************************************************
531:               */
532:               
533:               #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
534:               CPU_TS64  CPU_TS_Get64 (void)
535:               {
536:                   CPU_TS64    ts;
537:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
538:                   CPU_TS_TMR  tmr_cur;
539:                   CPU_TS_TMR  tmr_delta;
540:                   CPU_SR_ALLOC();
541:               #endif
542:               
543:               
544:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
545:                   ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
546:               
547:               #else
548:                   CPU_INT_DIS();
549:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
550:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
551:                   CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
552:                   CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
553:                   ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
554:                   CPU_INT_EN();
555:               #endif
556:               
557:                   return (ts);
558:               }
559:               #endif
560:               
561:               
562:               /*
563:               *********************************************************************************************************
564:               *                                           CPU_TS_Update()
565:               *
566:               * Description : Update current CPU timestamp(s).
567:               *
568:               * Argument(s) : none.
569:               *
570:               * Return(s)   : none.
571:               *
572:               * Caller(s)   : Application/BSP periodic time handler (see Note #1).
573:               *
574:               *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
575:               *               application/BSP function(s).
576:               *
577:               * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
578:               *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
579:               *
580:               *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
581:               *                       overflows; otherwise, CPU timestamp(s) will lose time.
582:               *
583:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
584:               *********************************************************************************************************
585:               */
586:               
587:               #if (CPU_CFG_TS_EN == DEF_ENABLED)
588:               void  CPU_TS_Update (void)
589:               {
590:               #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
591:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
592:                  (void)CPU_TS_Get32();
593:               #endif
594:               
595:               #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
596:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
597:                  (void)CPU_TS_Get64();
598:               #endif
599:               }
600:               #endif
601:               
602:               
603:               /*
604:               *********************************************************************************************************
605:               *                                         CPU_TS_TmrFreqGet()
606:               *
607:               * Description : Get CPU timestamp's timer frequency.
608:               *
609:               * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
610:               *
611:               *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
612:               *                                                                   returned.
613:               *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
614:               *                                                                   NOT yet configured.
615:               *
616:               * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
617:               *
618:               *               0,                                          otherwise.
619:               *
620:               * Caller(s)   : Application.
621:               *
622:               *               This function is a CPU module application programming interface (API) function & MAY be 
623:               *               called by application function(s).
624:               *
625:               * Note(s)     : none.
626:               *********************************************************************************************************
627:               */
628:               
629:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
630:               CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
631:               {
632:                   CPU_TS_TMR_FREQ  freq_hz;
633:               
634:               
635:                   if (p_err == (CPU_ERR *)0) {
636:                       CPU_SW_EXCEPTION(;);
637:                   }
638:               
639:                   freq_hz =  CPU_TS_TmrFreq_Hz;
640:                  *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
641:               
642:                   return (freq_hz);
643:               }
644:               #endif
645:               
646:               
647:               /*
648:               *********************************************************************************************************
649:               *                                         CPU_TS_TmrFreqSet()
650:               *
651:               * Description : Set CPU timestamp's timer frequency.
652:               *
653:               * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
654:               *
655:               * Return(s)   : none.
656:               *
657:               * Caller(s)   : CPU_TS_TmrInit(),
658:               *               Application/BSP initialization function(s).
659:               *
660:               *               This function is a CPU module BSP function & SHOULD be called only by appropriate
661:               *               application/BSP function(s) [see Note #1].
662:               *
663:               * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
664:               *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
665:               *                           application/BSP initialization functions.
666:               *
667:               *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
668:               *                           to convert CPU timestamps from timer counts into microseconds.
669:               *
670:               *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
671:               *
672:               *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
673:               *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
674:               *                       measure desired times.
675:               *
676:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
677:               *********************************************************************************************************
678:               */
679:               
680:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
681:               void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
682:               {
683:                   CPU_TS_TmrFreq_Hz = freq_hz;
684:               }
685:               #endif
686:               
687:               
688:               /*
689:               *********************************************************************************************************
690:               *                                     CPU_IntDisMeasMaxCurReset()
691:               *
692:               * Description : Reset current maximum interrupts disabled time.
693:               *
694:               * Argument(s) : none.
695:               *
696:               * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
697:               *
698:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
699:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
700:               *
701:               * Caller(s)   : Application.
702:               *
703:               *               This function is a CPU module application programming interface (API) function 
704:               *               & MAY be called by application function(s).
705:               *
706:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
707:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
708:               *********************************************************************************************************
709:               */
710:               
711:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
712:               CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
713:               {
714:                   CPU_TS_TMR  time_max_cnts;
715:                   CPU_SR_ALLOC();
716:               
717:               
718:                   time_max_cnts             = CPU_IntDisMeasMaxCurGet();
719:                   CPU_INT_DIS();
720:                   CPU_IntDisMeasMaxCur_cnts = 0u;
721:                   CPU_INT_EN();
722:               
723:                   return (time_max_cnts);
724:               }
725:               #endif
726:               
727:               
728:               /*
729:               *********************************************************************************************************
730:               *                                      CPU_IntDisMeasMaxCurGet()
731:               *
732:               * Description : Get current maximum interrupts disabled time.
733:               *
734:               * Argument(s) : none.
735:               *
736:               * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
737:               *
738:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
739:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
740:               *
741:               * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
742:               *               Application.
743:               *
744:               *               This function is a CPU module application programming interface (API) function 
745:               *               & MAY be called by application function(s).
746:               *
747:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
748:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
749:               *********************************************************************************************************
750:               */
751:               
752:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
753:               CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
754:               {
755:                   CPU_TS_TMR  time_tot_cnts;
756:                   CPU_TS_TMR  time_max_cnts;
757:                   CPU_SR_ALLOC();
758:               
759:               
760:                   CPU_INT_DIS();
761:                   time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
762:                   CPU_INT_EN();
763:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
764:               
765:                   return (time_max_cnts);
766:               }
767:               #endif
768:               
769:               
770:               /*
771:               *********************************************************************************************************
772:               *                                       CPU_IntDisMeasMaxGet()
773:               *
774:               * Description : Get (non-resetable) maximum interrupts disabled time.
775:               *
776:               * Argument(s) : none.
777:               *
778:               * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
779:               *
780:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
781:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
782:               *
783:               * Caller(s)   : CPU_IntDisMeasInit(),
784:               *               Application.
785:               *
786:               *               This function is a CPU module application programming interface (API) function 
787:               *               & MAY be called by application function(s).
788:               *
789:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
790:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
791:               *********************************************************************************************************
792:               */
793:               
794:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
795:               CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
796:               {
797:                   CPU_TS_TMR  time_tot_cnts;
798:                   CPU_TS_TMR  time_max_cnts;
799:                   CPU_SR_ALLOC();
800:               
801:               
802:                   CPU_INT_DIS();
803:                   time_tot_cnts = CPU_IntDisMeasMax_cnts;
804:                   CPU_INT_EN();
805:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
806:               
807:                   return (time_max_cnts);
808:               }
809:               #endif
810:               
811:               
812:               /*
813:               *********************************************************************************************************
814:               *                                        CPU_IntDisMeasStart()
815:               *
816:               * Description : Start interrupts disabled time measurement.
817:               *
818:               * Argument(s) : none.
819:               *
820:               * Return(s)   : none.
821:               *
822:               * Caller(s)   : CPU_CRITICAL_ENTER().
823:               *
824:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
825:               *               function(s).
826:               *
827:               * Note(s)     : none.
828:               *********************************************************************************************************
829:               */
830:               
831:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
832:               void  CPU_IntDisMeasStart (void)
833:               {
834:                   CPU_IntDisMeasCtr++;
835:                   if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
836:                       CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
837:                   }
838:                   CPU_IntDisNestCtr++;
839:               }
840:               #endif
841:               
842:               
843:               /*
844:               *********************************************************************************************************
845:               *                                        CPU_IntDisMeasStop()
846:               *
847:               * Description : Stop interrupts disabled time measurement.
848:               *
849:               * Argument(s) : none.
850:               *
851:               * Return(s)   : none.
852:               *
853:               * Caller(s)   : CPU_CRITICAL_EXIT().
854:               *
855:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
856:               *               function(s).
857:               *
858:               * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
859:               *                       during critical sections is calculated by the following equations :
860:               *
861:               *                       (1) When interrupts disabled time measurements are disabled :
862:               *
863:               *
864:               *                               |   CRITICAL  |                           |   CRITICAL  |
865:               *                               |<- SECTION ->|                           |<- SECTION ->|
866:               *                               |    ENTER    |                           |    EXIT     |
867:               *
868:               *                            Disable                                    Enable
869:               *                           Interrupts                                Interrupts
870:               *
871:               *                               ||           ||                           ||           ||
872:               *                               ||           ||                           ||           ||
873:               *                               ||       |   ||<------------------------->||       |   ||
874:               *                               ||       |<->||             |             ||<----->|   ||
875:               *                               ||       | | ||             |             ||   |   |   ||
876:               *                                        | |                |                  |   |
877:               *                                   interrupts            time                 interrupts
878:               *                                    disabled                 interrupts       |enabled
879:               *                                          |                   disabled        |
880:               *                                          |              (via application)    |
881:               *                                       time                                 time
882:               *                                           interrupts                           interrupts
883:               *                                         disabled ovrhd                        enabled ovrhd
884:               *
885:               *
886:               *                           (A) time            =  [ time            -  time           ]  -  time
887:               *                                   interrupts     [     interrupts         interrupts ]         total
888:               *                                    disabled      [      enabled            disabled  ]         ovrhd
889:               *                               (via application)
890:               *
891:               *
892:               *                           (B) time       =  time              +  time
893:               *                                   total         interrupts           interrupts
894:               *                                   ovrhd        enabled ovrhd       disabled ovrhd
895:               *
896:               *
897:               *                                   where
898:               *
899:               *                                           time                    time interrupts are disabled between
900:               *                                               interrupts              first critical section enter &
901:               *                                                disabled               last  critical section exit (i.e.
902:               *                                           (via application)           minus total overhead time)
903:               *
904:               *                                           time                    time when interrupts are disabled
905:               *                                               interrupts
906:               *                                                disabled
907:               *
908:               *                                           time                    time when interrupts are  enabled
909:               *                                               interrupts
910:               *                                                enabled
911:               *
912:               *
913:               *                                           time                    total overhead time to disable/enable
914:               *                                               total                   interrupts during critical section
915:               *                                               ovrhd                   enter & exit
916:               *
917:               *                                           time                    total overhead time to disable interrupts
918:               *                                               interrupts              during critical section enter
919:               *                                             disabled ovrhd
920:               *
921:               *                                           time                    total overhead time to enable  interrupts
922:               *                                               interrupts              during critical section exit
923:               *                                              enabled ovrhd
924:               *
925:               *
926:               *                       (2) When interrupts disabled time measurements are enabled :
927:               *
928:               *
929:               *        |                                    |                           |                                       |
930:               *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
931:               *        |                                    |                           |                                       |
932:               *
933:               *                   Time                                                 Time
934:               *     Disable    Measurement                                          Measurement                  Enable
935:               *    Interrupts     Start                                                Stop                    Interrupts
936:               *
937:               *        ||           |                      ||                           ||                         |           ||
938:               *        ||           |                      ||                           ||                         |           ||
939:               *        ||           |        |             ||<------------------------->||               |         |           ||
940:               *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
941:               *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
942:               *                 |            |      |                     |                      |       |                 |
943:               *            interrupts       get     |                   time                     |      get            interrupts
944:               *             disabled    start time  |                       interrupts           |   stop time          enabled
945:               *                            meas     |                        disabled            |     meas
946:               *                                   time                  (via application)      time
947:               *                                       start meas                                   stop meas
948:               *                                         ovrhd                                        ovrhd
949:               *
950:               *
951:               *                           (A) time            =  [ time       -  time      ]  -  time
952:               *                                   interrupts     [      stop         start ]         total meas
953:               *                                    disabled      [      meas         meas  ]           ovrhd
954:               *                               (via application)
955:               *
956:               *
957:               *                           (B) time            =  time            +  time
958:               *                                   total meas         start meas         stop meas
959:               *                                     ovrhd              ovrhd              ovrhd
960:               *
961:               *
962:               *                                   where
963:               *
964:               *                                           time                    time interrupts are disabled between first
965:               *                                               interrupts              critical section enter & last critical
966:               *                                                disabled               section exit (i.e. minus measurement
967:               *                                           (via application)           overhead time; however, this does NOT
968:               *                                                                       include any overhead time to disable
969:               *                                                                       or enable interrupts during critical
970:               *                                                                       section enter & exit)
971:               *
972:               *                                           time                    time of disable interrupts start time
973:               *                                               start                   measurement (in timer counts)
974:               *                                               meas
975:               *
976:               *                                           time                    time of disable interrupts stop  time
977:               *                                               stop                    measurement (in timer counts)
978:               *                                               meas
979:               *
980:               *
981:               *                                           time                    total overhead time to start/stop disabled
982:               *                                               total meas              interrupts time measurements (in timer
983:               *                                                 ovrhd                 counts)
984:               *
985:               *                                           time                    total overhead time after getting start
986:               *                                               start meas              time until end of start measurement
987:               *                                                 ovrhd                 function  (in timer counts)
988:               *
989:               *                                           time                    total overhead time from beginning of stop
990:               *                                               stop meas               measurement function until after getting
991:               *                                                 ovrhd                 stop time (in timer counts)
992:               *
993:               *
994:               *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times 
995:               *                               from stop times, CPU timestamp timer count values MUST be returned via 
996:               *                               word-size-configurable 'CPU_TS_TMR' data type.
997:               *
998:               *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
999:               *
1000:              *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
1001:              *                               values, timestamp timer count values MUST increase with each time count.
1002:              *
1003:              *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
1004:              *
1005:              *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
1006:              *                               subtraction of start times from stop times is performed.
1007:              *
1008:              *                           (B) The final calculations to subtract the interrupts disabled time measurement
1009:              *                               overhead is performed asynchronously in appropriate API functions.
1010:              *
1011:              *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
1012:              *********************************************************************************************************
1013:              */
1014:              
1015:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
1016:              void  CPU_IntDisMeasStop (void)
1017:              {
1018:                  CPU_TS_TMR  time_ints_disd_cnts;
1019:              
1020:              
1021:                  CPU_IntDisNestCtr--;
1022:                  if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
1023:                      CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
1024:                                                                                  /* ... calc ints dis'd tot  time (see Note #1b2A).  */
1025:                      time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
1026:                                                CPU_IntDisMeasStart_cnts;
1027:                                                                                  /* Calc max ints dis'd times.                       */
1028:                      if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
1029:                          CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
1030:                      }
1031:                      if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
1032:                          CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
1033:                      }
1034:                  }
1035:              }
1036:              #endif
1037:              
1038:              
1039:              /*
1040:              *********************************************************************************************************
1041:              *                                         CPU_CntLeadZeros()
1042:              *
1043:              * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
1044:              *
1045:              * Argument(s) : val         Data value to count leading zero bits.
1046:              *
1047:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
1048:              *
1049:              *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
1050:              *
1051:              * Caller(s)   : CPU_CntTrailZeros(),
1052:              *               Application.
1053:              *
1054:              *               This function is a CPU module application programming interface (API) function & MAY 
1055:              *               be called by application function(s).
1056:              *
1057:              * Note(s)     : (1) (a) Supports the following data value sizes :
1058:              *
1059:              *                       (1)  8-bits
1060:              *                       (2) 16-bits
1061:              *                       (3) 32-bits
1062:              *                       (4) 64-bits
1063:              *
1064:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1065:              *
1066:              *                   (b) (1) For  8-bit values :
1067:              *
1068:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1069:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1070:              *                                   1    x    x    x    x    x    x    x            0
1071:              *                                   0    1    x    x    x    x    x    x            1
1072:              *                                   0    0    1    x    x    x    x    x            2
1073:              *                                   0    0    0    1    x    x    x    x            3
1074:              *                                   0    0    0    0    1    x    x    x            4
1075:              *                                   0    0    0    0    0    1    x    x            5
1076:              *                                   0    0    0    0    0    0    1    x            6
1077:              *                                   0    0    0    0    0    0    0    1            7
1078:              *                                   0    0    0    0    0    0    0    0            8
1079:              *
1080:              *
1081:              *                       (2) For 16-bit values :
1082:              *
1083:              *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1084:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1085:              *                              1    x    x         x    x    x    x    x            0
1086:              *                              0    1    x         x    x    x    x    x            1
1087:              *                              0    0    1         x    x    x    x    x            2
1088:              *                              :    :    :         :    :    :    :    :            :
1089:              *                              :    :    :         :    :    :    :    :            :
1090:              *                              0    0    0         1    x    x    x    x           11
1091:              *                              0    0    0         0    1    x    x    x           12
1092:              *                              0    0    0         0    0    1    x    x           13
1093:              *                              0    0    0         0    0    0    1    x           14
1094:              *                              0    0    0         0    0    0    0    1           15
1095:              *                              0    0    0         0    0    0    0    0           16
1096:              *
1097:              *                       (3) For 32-bit values :
1098:              *
1099:              *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1100:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1101:              *                              1    x    x         x    x    x    x    x            0
1102:              *                              0    1    x         x    x    x    x    x            1
1103:              *                              0    0    1         x    x    x    x    x            2
1104:              *                              :    :    :         :    :    :    :    :            :
1105:              *                              :    :    :         :    :    :    :    :            :
1106:              *                              0    0    0         1    x    x    x    x           27
1107:              *                              0    0    0         0    1    x    x    x           28
1108:              *                              0    0    0         0    0    1    x    x           29
1109:              *                              0    0    0         0    0    0    1    x           30
1110:              *                              0    0    0         0    0    0    0    1           31
1111:              *                              0    0    0         0    0    0    0    0           32
1112:              *
1113:              *
1114:              *                       (4) For 64-bit values :
1115:              *
1116:              *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1117:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1118:              *                              1    x    x         x    x    x    x    x            0
1119:              *                              0    1    x         x    x    x    x    x            1
1120:              *                              0    0    1         x    x    x    x    x            2
1121:              *                              :    :    :         :    :    :    :    :            :
1122:              *                              :    :    :         :    :    :    :    :            :
1123:              *                              0    0    0         1    x    x    x    x           59
1124:              *                              0    0    0         0    1    x    x    x           60
1125:              *                              0    0    0         0    0    1    x    x           61
1126:              *                              0    0    0         0    0    0    1    x           62
1127:              *                              0    0    0         0    0    0    0    1           63
1128:              *                              0    0    0         0    0    0    0    0           64
1129:              *
1130:              *
1131:              *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1132:              *********************************************************************************************************
1133:              */
1134:              
1135:              #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
1136:              CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
1137:              {
1138:                  CPU_DATA  nbr_lead_zeros;
1139:              
1140:              
1141:              #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
1142:                  nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
1143:              
1144:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
1145:                  nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
004180  37FFF3     BRA CPU_CntLeadZeros16
1146:              
1147:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
1148:                  nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
1149:              
1150:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
1151:                  nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
1152:              
1153:              #else                                                           /* See Note #1a.                                        */
1154:                  nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
1155:              #endif
1156:              
1157:              
1158:                  return (nbr_lead_zeros);
1159:              }
1160:              #endif
1161:              
1162:              
1163:              /*
1164:              *********************************************************************************************************
1165:              *                                        CPU_CntLeadZeros08()
1166:              *
1167:              * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
1168:              *
1169:              * Argument(s) : val         Data value to count leading zero bits.
1170:              *
1171:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1172:              *
1173:              * Caller(s)   : CPU_CntLeadZeros(),
1174:              *               CPU_CntTrailZeros08(),
1175:              *               Application.
1176:              *
1177:              *               This function is a CPU module application programming interface (API) function & MAY be 
1178:              *               called by application function(s).
1179:              *
1180:              * Note(s)     : (1) Supports  8-bit values :
1181:              *
1182:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1183:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1184:              *                                1    x    x    x    x    x    x    x            0
1185:              *                                0    1    x    x    x    x    x    x            1
1186:              *                                0    0    1    x    x    x    x    x            2
1187:              *                                0    0    0    1    x    x    x    x            3
1188:              *                                0    0    0    0    1    x    x    x            4
1189:              *                                0    0    0    0    0    1    x    x            5
1190:              *                                0    0    0    0    0    0    1    x            6
1191:              *                                0    0    0    0    0    0    0    1            7
1192:              *                                0    0    0    0    0    0    0    0            8
1193:              *
1194:              *
1195:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1196:              *********************************************************************************************************
1197:              */
1198:              
1199:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1200:              CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
1201:              {
1202:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1203:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1204:                  CPU_DATA  ix;
1205:              #endif
1206:                  CPU_DATA  nbr_lead_zeros;
1207:              
1208:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1209:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1210:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1211:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1212:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1213:              
1214:              
1215:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1216:                                                                                              /* Chk bits [07:00] :                   */
1217:                                                                                              /* .. Nbr lead zeros =               .. */
1218:                  ix              = (CPU_DATA)(val);                                          /* .. lookup tbl ix  = 'val' >>  0 bits */
00415E  FB8000     ZE W0, W0
1219:                  nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                      /* .. plus nbr msb lead zeros =  0 bits.*/
004160  29AE61     MOV #0x9AE6, W1
004162  784061     MOV.B [W1+W0], W0
004164  FB8000     ZE W0, W0
1220:              #endif
1221:              
1222:              
1223:                  return (nbr_lead_zeros);
1224:              }
004166  060000     RETURN
1225:              #endif
1226:              
1227:              
1228:              /*
1229:              *********************************************************************************************************
1230:              *                                        CPU_CntLeadZeros16()
1231:              *
1232:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
1233:              *
1234:              * Argument(s) : val         Data value to count leading zero bits.
1235:              *
1236:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1237:              *
1238:              * Caller(s)   : CPU_CntLeadZeros(),
1239:              *               CPU_CntTrailZeros16(),
1240:              *               Application.
1241:              *
1242:              *               This function is a CPU module application programming interface (API) function & MAY be 
1243:              *               called by application function(s).
1244:              *
1245:              * Note(s)     : (1) Supports 16-bit values :
1246:              *
1247:              *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1248:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1249:              *                           1    x    x         x    x    x    x    x            0
1250:              *                           0    1    x         x    x    x    x    x            1
1251:              *                           0    0    1         x    x    x    x    x            2
1252:              *                           :    :    :         :    :    :    :    :            :
1253:              *                           :    :    :         :    :    :    :    :            :
1254:              *                           0    0    0         1    x    x    x    x           11
1255:              *                           0    0    0         0    1    x    x    x           12
1256:              *                           0    0    0         0    0    1    x    x           13
1257:              *                           0    0    0         0    0    0    1    x           14
1258:              *                           0    0    0         0    0    0    0    1           15
1259:              *                           0    0    0         0    0    0    0    0           16
1260:              *
1261:              *
1262:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1263:              *********************************************************************************************************
1264:              */
1265:              
1266:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1267:              CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
1268:              {
004168  29AE61     MOV #0x9AE6, W1
1269:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1270:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1271:                  CPU_DATA  ix;
1272:              #endif
1273:                  CPU_DATA  nbr_lead_zeros;
1274:              
1275:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1276:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1277:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1278:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1279:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1280:              
1281:              
1282:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1283:                  if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
00416A  200FF2     MOV #0xFF, W2
00416C  500F82     SUB W0, W2, [W15]
00416E  360004     BRA LEU, 0x4178
1284:                                                                                              /* .. Nbr lead zeros =               .. */
1285:                      ix             = (CPU_DATA)((CPU_DATA)val >> 8u);                       /* .. lookup tbl ix  = 'val' >>  8 bits */
004170  DE0048     LSR W0, #8, W0
1286:                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                   /* .. plus nbr msb lead zeros =  0 bits.*/
004172  784061     MOV.B [W1+W0], W0
004174  FB8000     ZE W0, W0
004176  060000     RETURN
1287:              
1288:                  } else {                                                                    /* Chk bits [07:00] :                   */
1289:                                                                                              /* .. Nbr lead zeros =               .. */
1290:                      ix             = (CPU_DATA)(val);                                       /* .. lookup tbl ix  = 'val' >>  0 bits */
1291:                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);   /* .. plus nbr msb lead zeros =  8 bits.*/
004178  784061     MOV.B [W1+W0], W0
00417A  FB8000     ZE W0, W0
00417C  400068     ADD W0, #0x8, W0
1292:                  }
1293:              #endif
1294:              
1295:              
1296:                  return (nbr_lead_zeros);
1297:              }
00417E  060000     RETURN
1298:              #endif
1299:              
1300:              
1301:              /*
1302:              *********************************************************************************************************
1303:              *                                        CPU_CntLeadZeros32()
1304:              *
1305:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
1306:              *
1307:              * Argument(s) : val         Data value to count leading zero bits.
1308:              *
1309:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1310:              *
1311:              * Caller(s)   : CPU_CntLeadZeros(),
1312:              *               CPU_CntTrailZeros32(),
1313:              *               Application.
1314:              *
1315:              *               This function is a CPU module application programming interface (API) function & MAY be 
1316:              *               called by application function(s).
1317:              *
1318:              * Note(s)     : (1) Supports 32-bit values :
1319:              *
1320:              *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1321:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1322:              *                           1    x    x         x    x    x    x    x            0
1323:              *                           0    1    x         x    x    x    x    x            1
1324:              *                           0    0    1         x    x    x    x    x            2
1325:              *                           :    :    :         :    :    :    :    :            :
1326:              *                           :    :    :         :    :    :    :    :            :
1327:              *                           0    0    0         1    x    x    x    x           27
1328:              *                           0    0    0         0    1    x    x    x           28
1329:              *                           0    0    0         0    0    1    x    x           29
1330:              *                           0    0    0         0    0    0    1    x           30
1331:              *                           0    0    0         0    0    0    0    1           31
1332:              *                           0    0    0         0    0    0    0    0           32
1333:              *
1334:              *
1335:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1336:              *********************************************************************************************************
1337:              */
1338:              
1339:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1340:              CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
1341:              {
1342:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1343:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1344:                  CPU_DATA  ix;
1345:              #endif
1346:                  CPU_DATA  nbr_lead_zeros;
1347:              
1348:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1349:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1350:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1351:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1352:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1353:              
1354:              
1355:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1356:                  if (val > 0x0000FFFFu) {
004182  400FE1     ADD W0, #0x1, [W15]
004184  588FE0     SUBB W1, #0x0, [W15]
004186  36000E     BRA LEU, 0x41A4
004188  29AE62     MOV #0x9AE6, W2
1357:                      if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
00418A  2FFFF4     MOV #0xFFFF, W4
00418C  200FF5     MOV #0xFF, W5
00418E  500F84     SUB W0, W4, [W15]
004190  588F85     SUBB W1, W5, [W15]
004192  360004     BRA LEU, 0x419C
1358:                                                                                              /* .. Nbr lead zeros =               .. */
1359:                          ix             = (CPU_DATA)(val >> 24u);                  /* .. lookup tbl ix  = 'val' >> 24 bits */
004194  DE0848     LSR W1, #8, W0
1360:                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);               /* .. plus nbr msb lead zeros =  0 bits.*/
004196  410000     ADD W2, W0, W0
004198  FB8010     ZE [W0], W0
00419A  060000     RETURN
1361:              
1362:                      } else {                                                                /* Chk bits [23:16] :                   */
1363:                                                                                              /* .. Nbr lead zeros =               .. */
1364:                          ix             = (CPU_DATA)(val >> 16u);                  /* .. lookup tbl ix  = 'val' >> 16 bits */
1365:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
00419C  410101     ADD W2, W1, W2
00419E  FB8012     ZE [W2], W0
0041A0  400068     ADD W0, #0x8, W0
0041A2  060000     RETURN
0041A4  29AE62     MOV #0x9AE6, W2
1366:                      }
1367:              
1368:                  } else {
1369:                      if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
0041A6  200FF3     MOV #0xFF, W3
0041A8  500F83     SUB W0, W3, [W15]
0041AA  588FE0     SUBB W1, #0x0, [W15]
0041AC  360005     BRA LEU, 0x41B8
1370:                                                                                              /* .. Nbr lead zeros =               .. */
1371:                          ix             = (CPU_DATA)((CPU_DATA)val >>  8u);                  /* .. lookup tbl ix  = 'val' >>  8 bits */
0041AE  DE0048     LSR W0, #8, W0
1372:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
0041B0  784062     MOV.B [W2+W0], W0
0041B2  FB8000     ZE W0, W0
0041B4  400070     ADD W0, #0x10, W0
0041B6  060000     RETURN
1373:              
1374:                      } else {                                                                /* Chk bits [07:00] :                   */
1375:                                                                                              /* .. Nbr lead zeros =               .. */
1376:                          ix             = (CPU_DATA)((CPU_DATA)val >>  0u);                  /* .. lookup tbl ix  = 'val' >>  0 bits */
1377:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
0041B8  410000     ADD W2, W0, W0
0041BA  FB8010     ZE [W0], W0
0041BC  400078     ADD W0, #0x18, W0
1378:                      }
1379:                  }
1380:              #endif
1381:              
1382:              
1383:                  return (nbr_lead_zeros);
1384:              }
0041BE  060000     RETURN
1385:              #endif
1386:              
1387:              
1388:              /*
1389:              *********************************************************************************************************
1390:              *                                        CPU_CntLeadZeros64()
1391:              *
1392:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
1393:              *
1394:              * Argument(s) : val         Data value to count leading zero bits.
1395:              *
1396:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1397:              *
1398:              * Caller(s)   : CPU_CntLeadZeros(),
1399:              *               CPU_CntTrailZeros64(),
1400:              *               Application.
1401:              *
1402:              *               This function is a CPU module application programming interface (API) function & MAY be 
1403:              *               called by application function(s).
1404:              *
1405:              * Note(s)     : (1) Supports 64-bit values :
1406:              *
1407:              *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1408:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1409:              *                           1    x    x         x    x    x    x    x            0
1410:              *                           0    1    x         x    x    x    x    x            1
1411:              *                           0    0    1         x    x    x    x    x            2
1412:              *                           :    :    :         :    :    :    :    :            :
1413:              *                           :    :    :         :    :    :    :    :            :
1414:              *                           0    0    0         1    x    x    x    x           59
1415:              *                           0    0    0         0    1    x    x    x           60
1416:              *                           0    0    0         0    0    1    x    x           61
1417:              *                           0    0    0         0    0    0    1    x           62
1418:              *                           0    0    0         0    0    0    0    1           63
1419:              *                           0    0    0         0    0    0    0    0           64
1420:              *
1421:              *
1422:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1423:              *********************************************************************************************************
1424:              */
1425:              
1426:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
1427:              CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
1428:              {
0041C0  BE9F88     MOV.D W8, [W15++]
0041C2  BE9F8A     MOV.D W10, [W15++]
1429:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1430:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
1431:                  CPU_DATA  ix;
1432:              #endif
1433:                  CPU_DATA  nbr_lead_zeros;
1434:              
1435:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1436:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1437:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
1438:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1439:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1440:              
1441:              
1442:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1443:                  if (val > 0x00000000FFFFFFFFu) {
0041C4  2FFFF4     MOV #0xFFFF, W4
0041C6  2FFFF5     MOV #0xFFFF, W5
0041C8  B83360     MUL.UU W6, #0, W6
0041CA  E10004     CP W0, W4
0041CC  E18805     CPB W1, W5
0041CE  E19006     CPB W2, W6
0041D0  E19807     CPB W3, W7
0041D2  360030     BRA LEU, 0x4234
1444:                      if (val > 0x0000FFFFFFFFFFFFu) {
0041D4  2FFFF4     MOV #0xFFFF, W4
0041D6  2FFFF5     MOV #0xFFFF, W5
0041D8  2FFFF6     MOV #0xFFFF, W6
0041DA  200007     MOV #0x0, W7
0041DC  E10004     CP W0, W4
0041DE  E18805     CPB W1, W5
0041E0  E19006     CPB W2, W6
0041E2  E19807     CPB W3, W7
0041E4  360012     BRA LEU, 0x420A
0041E6  29AE64     MOV #0x9AE6, W4
1445:                          if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
0041E8  2FFFF8     MOV #0xFFFF, W8
0041EA  2FFFF9     MOV #0xFFFF, W9
0041EC  2FFFFA     MOV #0xFFFF, W10
0041EE  200FFB     MOV #0xFF, W11
0041F0  E10008     CP W0, W8
0041F2  E18809     CPB W1, W9
0041F4  E1900A     CPB W2, W10
0041F6  E1980B     CPB W3, W11
0041F8  360004     BRA LEU, 0x4202
1446:                                                                                              /* .. Nbr lead zeros =               .. */
1447:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 56u);            /* .. lookup tbl ix  = 'val' >> 56 bits */
0041FA  DE1848     LSR W3, #8, W0
1448:                              nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);           /* .. plus nbr msb lead zeros =  0 bits.*/
0041FC  420000     ADD W4, W0, W0
0041FE  FB8010     ZE [W0], W0
004200  370048     BRA 0x4292
1449:              
1450:                          } else {                                                            /* Chk bits [55:48] :                   */
1451:                                                                                              /* .. Nbr lead zeros =               .. */
1452:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 48u);            /* .. lookup tbl ix  = 'val' >> 48 bits */
1453:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
004202  420203     ADD W4, W3, W4
004204  FB8014     ZE [W4], W0
004206  400068     ADD W0, #0x8, W0
004208  370044     BRA 0x4292
00420A  29AE64     MOV #0x9AE6, W4
1454:                          }
1455:              
1456:                      } else {
1457:                          if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
00420C  2FFFF8     MOV #0xFFFF, W8
00420E  2FFFF9     MOV #0xFFFF, W9
004210  200FFA     MOV #0xFF, W10
004212  20000B     MOV #0x0, W11
004214  E10008     CP W0, W8
004216  E18809     CPB W1, W9
004218  E1900A     CPB W2, W10
00421A  E1980B     CPB W3, W11
00421C  360007     BRA LEU, 0x422C
1458:                                                                                              /* .. Nbr lead zeros =               .. */
1459:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 40u);            /* .. lookup tbl ix  = 'val' >> 40 bits */
00421E  DE1048     LSR W2, #8, W0
004220  DD1AC8     SL W3, #8, W5
004222  728000     IOR W5, W0, W0
1460:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
004224  420000     ADD W4, W0, W0
004226  FB8010     ZE [W0], W0
004228  400070     ADD W0, #0x10, W0
00422A  370033     BRA 0x4292
1461:              
1462:                          } else {                                                            /* Chk bits [39:32] :                   */
1463:                                                                                              /* .. Nbr lead zeros =               .. */
1464:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 32u);            /* .. lookup tbl ix  = 'val' >> 32 bits */
1465:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
00422C  420202     ADD W4, W2, W4
00422E  FB8014     ZE [W4], W0
004230  400078     ADD W0, #0x18, W0
004232  37002F     BRA 0x4292
1466:                          }
1467:                      }
1468:              
1469:                  } else {
1470:                      if (val > 0x000000000000FFFFu) {
004234  2FFFF4     MOV #0xFFFF, W4
004236  200005     MOV #0x0, W5
004238  B83360     MUL.UU W6, #0, W6
00423A  E10004     CP W0, W4
00423C  E18805     CPB W1, W5
00423E  E19006     CPB W2, W6
004240  E19807     CPB W3, W7
004242  360014     BRA LEU, 0x426C
004244  29AE64     MOV #0x9AE6, W4
1471:                          if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
004246  2FFFF8     MOV #0xFFFF, W8
004248  200FF9     MOV #0xFF, W9
00424A  B85560     MUL.UU W10, #0, W10
00424C  E10008     CP W0, W8
00424E  E18809     CPB W1, W9
004250  E1900A     CPB W2, W10
004252  E1980B     CPB W3, W11
004254  360007     BRA LEU, 0x4264
1472:                                                                                              /* .. Nbr lead zeros =               .. */
1473:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 24u);              /* .. lookup tbl ix  = 'val' >> 24 bits */
004256  DE0848     LSR W1, #8, W0
004258  DD12C8     SL W2, #8, W5
00425A  728000     IOR W5, W0, W0
1474:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);/* .. plus nbr msb lead zeros = 32 bits.*/
00425C  420000     ADD W4, W0, W0
00425E  FB8010     ZE [W0], W0
004260  B00200     ADD #0x20, W0
004262  370017     BRA 0x4292
1475:              
1476:                          } else {                                                            /* Chk bits [23:16] :                   */
1477:                                                                                              /* .. Nbr lead zeros =               .. */
1478:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 16u);            /* .. lookup tbl ix  = 'val' >> 16 bits */
1479:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);/* .. plus nbr msb lead zeros = 40 bits.*/
004264  420201     ADD W4, W1, W4
004266  FB8014     ZE [W4], W0
004268  B00280     ADD #0x28, W0
00426A  370013     BRA 0x4292
00426C  29AE64     MOV #0x9AE6, W4
1480:                          }
1481:              
1482:                      } else {
1483:                          if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
00426E  200FF8     MOV #0xFF, W8
004270  200009     MOV #0x0, W9
004272  B85560     MUL.UU W10, #0, W10
004274  E10008     CP W0, W8
004276  E18809     CPB W1, W9
004278  E1900A     CPB W2, W10
00427A  E1980B     CPB W3, W11
00427C  360007     BRA LEU, 0x428C
1484:                                                                                              /* .. Nbr lead zeros =               .. */
1485:                              ix             = (CPU_DATA)((CPU_INT64U)val >>  8u);            /* .. lookup tbl ix  = 'val' >>  8 bits */
00427E  DE0048     LSR W0, #8, W0
004280  DD0AC8     SL W1, #8, W5
004282  728000     IOR W5, W0, W0
1486:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);/* .. plus nbr msb lead zeros = 48 bits.*/
004284  420000     ADD W4, W0, W0
004286  FB8010     ZE [W0], W0
004288  B00300     ADD #0x30, W0
00428A  370003     BRA 0x4292
1487:              
1488:                          } else {                                                            /* Chk bits [07:00] :                   */
1489:                                                                                              /* .. Nbr lead zeros =               .. */
1490:                              ix             = (CPU_DATA)(val);                               /* .. lookup tbl ix  = 'val' >>  0 bits */
1491:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);/* .. plus nbr msb lead zeros = 56 bits.*/
00428C  420000     ADD W4, W0, W0
00428E  FB8010     ZE [W0], W0
004290  B00380     ADD #0x38, W0
1492:                          }
1493:                      }
1494:                  }
1495:              #endif
1496:              
1497:              
1498:                  return (nbr_lead_zeros);
1499:              }
004292  BE054F     MOV.D [--W15], W10
004294  BE044F     MOV.D [--W15], W8
004296  060000     RETURN
1500:              #endif
1501:              
1502:              
1503:              /*
1504:              *********************************************************************************************************
1505:              *                                         CPU_CntTrailZeros()
1506:              *
1507:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
1508:              *
1509:              * Argument(s) : val         Data value to count trailing zero bits.
1510:              *
1511:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1512:              *
1513:              * Caller(s)   : Application.
1514:              *
1515:              *               This function is a CPU module application programming interface (API) function & MAY 
1516:              *               be called by application function(s).
1517:              *
1518:              * Note(s)     : (1) (a) Supports the following data value sizes :
1519:              *
1520:              *                       (1)  8-bits
1521:              *                       (2) 16-bits
1522:              *                       (3) 32-bits
1523:              *                       (4) 64-bits
1524:              *
1525:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1526:              *
1527:              *                   (b) (1) For  8-bit values :
1528:              *
1529:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1530:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1531:              *                                   x    x    x    x    x    x    x    1            0
1532:              *                                   x    x    x    x    x    x    1    0            1
1533:              *                                   x    x    x    x    x    1    0    0            2
1534:              *                                   x    x    x    x    1    0    0    0            3
1535:              *                                   x    x    x    1    0    0    0    0            4
1536:              *                                   x    x    1    0    0    0    0    0            5
1537:              *                                   x    1    0    0    0    0    0    0            6
1538:              *                                   1    0    0    0    0    0    0    0            7
1539:              *                                   0    0    0    0    0    0    0    0            8
1540:              *
1541:              *
1542:              *                       (2) For 16-bit values :
1543:              *
1544:              *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1545:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1546:              *                              x    x    x    x    x         x    x    1            0
1547:              *                              x    x    x    x    x         x    1    0            1
1548:              *                              x    x    x    x    x         1    0    0            2
1549:              *                              :    :    :    :    :         :    :    :            :
1550:              *                              :    :    :    :    :         :    :    :            :
1551:              *                              x    x    x    x    1         0    0    0           11
1552:              *                              x    x    x    1    0         0    0    0           12
1553:              *                              x    x    1    0    0         0    0    0           13
1554:              *                              x    1    0    0    0         0    0    0           14
1555:              *                              1    0    0    0    0         0    0    0           15
1556:              *                              0    0    0    0    0         0    0    0           16
1557:              *
1558:              *
1559:              *                       (3) For 32-bit values :
1560:              *
1561:              *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1562:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1563:              *                              x    x    x    x    x         x    x    1            0
1564:              *                              x    x    x    x    x         x    1    0            1
1565:              *                              x    x    x    x    x         1    0    0            2
1566:              *                              :    :    :    :    :         :    :    :            :
1567:              *                              :    :    :    :    :         :    :    :            :
1568:              *                              x    x    x    x    1         0    0    0           27
1569:              *                              x    x    x    1    0         0    0    0           28
1570:              *                              x    x    1    0    0         0    0    0           29
1571:              *                              x    1    0    0    0         0    0    0           30
1572:              *                              1    0    0    0    0         0    0    0           31
1573:              *                              0    0    0    0    0         0    0    0           32
1574:              *
1575:              *
1576:              *                       (4) For 64-bit values :
1577:              *
1578:              *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1579:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1580:              *                              x    x    x    x    x         x    x    1            0
1581:              *                              x    x    x    x    x         x    1    0            1
1582:              *                              x    x    x    x    x         1    0    0            2
1583:              *                              :    :    :    :    :         :    :    :            :
1584:              *                              :    :    :    :    :         :    :    :            :
1585:              *                              x    x    x    x    1         0    0    0           59
1586:              *                              x    x    x    1    0         0    0    0           60
1587:              *                              x    x    1    0    0         0    0    0           61
1588:              *                              x    1    0    0    0         0    0    0           62
1589:              *                              1    0    0    0    0         0    0    0           63
1590:              *                              0    0    0    0    0         0    0    0           64
1591:              *
1592:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1593:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1594:              *
1595:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1596:              *
1597:              *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of 
1598:              *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's 
1599:              *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
1600:              *
1601:              *                           if (val != 0u) {
1602:              *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1603:              *                           } else {
1604:              *                               nbr_trail_zeros = nbr_lead_zeros;
1605:              *                           }
1606:              *
1607:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1608:              *                       execute the final 'if' statement.
1609:              *********************************************************************************************************
1610:              */
1611:              
1612:              #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
1613:              CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
1614:              {
1615:                  CPU_DATA  val_bit_mask;
1616:                  CPU_DATA  nbr_lead_zeros;
1617:                  CPU_DATA  nbr_trail_zeros;
1618:              
1619:              
1620:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
00429A  E00000     CP0 W0
00429C  320004     BRA Z, 0x42A6
1621:                      return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
004298  200101     MOV #0x10, W1
1622:                  }
1623:              
1624:              
1625:                  val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
00429E  EA0080     NEG W0, W1
0042A0  608000     AND W1, W0, W0
1626:                  nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
0042A2  07FF6E     RCALL CPU_CntLeadZeros
1627:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1628:                  nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0042A4  1000EF     SUBR W0, #0xF, W1
1629:              
1630:              
1631:                  return (nbr_trail_zeros);
1632:              }
0042A6  780001     MOV W1, W0
0042A8  060000     RETURN
1633:              #endif
1634:              
1635:              
1636:              /*
1637:              *********************************************************************************************************
1638:              *                                        CPU_CntTrailZeros08()
1639:              *
1640:              * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
1641:              *
1642:              * Argument(s) : val         Data value to count trailing zero bits.
1643:              *
1644:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1645:              *
1646:              * Caller(s)   : Application.
1647:              *
1648:              *               This function is a CPU module application programming interface (API) function & MAY be 
1649:              *               called by application function(s).
1650:              *
1651:              * Note(s)     : (1) Supports  8-bit values :
1652:              *
1653:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1654:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1655:              *                                x    x    x    x    x    x    x    1            0
1656:              *                                x    x    x    x    x    x    1    0            1
1657:              *                                x    x    x    x    x    1    0    0            2
1658:              *                                x    x    x    x    1    0    0    0            3
1659:              *                                x    x    x    1    0    0    0    0            4
1660:              *                                x    x    1    0    0    0    0    0            5
1661:              *                                x    1    0    0    0    0    0    0            6
1662:              *                                1    0    0    0    0    0    0    0            7
1663:              *                                0    0    0    0    0    0    0    0            8
1664:              *
1665:              *
1666:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1667:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1668:              *
1669:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1670:              *
1671:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1672:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1673:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return 
1674:              *                       data size, then the returned number of zeros must be offset by the difference 
1675:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
1676:              *
1677:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1678:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
1679:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1680:              *                           }
1681:              *
1682:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit 
1683:              *                       values would return a number of trailing zeros less than or equal to  8 bits.
1684:              *
1685:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1686:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1687:              *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
1688:              *
1689:              *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement 
1690:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s 
1691:              *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1692:              *                       initial 'val' is non-'0' :
1693:              *
1694:              *                           if (val != 0u) {
1695:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1696:              *                           } else {
1697:              *                               nbr_trail_zeros = nbr_lead_zeros;
1698:              *                           }
1699:              *
1700:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1701:              *                       execute the final 'if' statement.
1702:              *********************************************************************************************************
1703:              */
1704:              
1705:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1706:              CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
1707:              {
0042AA  784080     MOV.B W0, W1
1708:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1709:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1710:                  CPU_INT08U  val_bit_mask;
1711:                  CPU_DATA    nbr_lead_zeros;
1712:              #endif
1713:                  CPU_DATA    nbr_trail_zeros;
1714:              
1715:              
1716:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0042AE  E00401     CP0.B W1
0042B0  320004     BRA Z, 0x42BA
1717:                      return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
0042AC  200080     MOV #0x8, W0
1718:                  }
1719:              
1720:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1721:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1722:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1723:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1724:              
1725:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1726:                  val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0042B2  EA4001     NEG.B W1, W0
0042B4  604001     AND.B W0, W1, W0
1727:                  nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0042B6  07FF53     RCALL CPU_CntLeadZeros08
1728:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1729:                  nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0042B8  100067     SUBR W0, #0x7, W0
1730:              #endif
1731:              
1732:              
1733:                  return (nbr_trail_zeros);
1734:              }
0042BA  060000     RETURN
1735:              #endif
1736:              
1737:              
1738:              /*
1739:              *********************************************************************************************************
1740:              *                                        CPU_CntTrailZeros16()
1741:              *
1742:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
1743:              *
1744:              * Argument(s) : val         Data value to count trailing zero bits.
1745:              *
1746:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1747:              *
1748:              * Caller(s)   : Application.
1749:              *
1750:              *               This function is a CPU module application programming interface (API) function & MAY be 
1751:              *               called by application function(s).
1752:              *
1753:              * Note(s)     : (1) Supports 16-bit values :
1754:              *
1755:              *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1756:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1757:              *                           x    x    x    x    x         x    x    1            0
1758:              *                           x    x    x    x    x         x    1    0            1
1759:              *                           x    x    x    x    x         1    0    0            2
1760:              *                           :    :    :    :    :         :    :    :            :
1761:              *                           :    :    :    :    :         :    :    :            :
1762:              *                           x    x    x    x    1         0    0    0           11
1763:              *                           x    x    x    1    0         0    0    0           12
1764:              *                           x    x    1    0    0         0    0    0           13
1765:              *                           x    1    0    0    0         0    0    0           14
1766:              *                           1    0    0    0    0         0    0    0           15
1767:              *                           0    0    0    0    0         0    0    0           16
1768:              *
1769:              *
1770:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1771:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1772:              *
1773:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1774:              *
1775:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1776:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1777:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return 
1778:              *                       data size, then the returned number of zeros must be offset by the difference 
1779:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
1780:              *
1781:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1782:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
1783:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1784:              *                           }
1785:              *
1786:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit 
1787:              *                       values would return a number of trailing zeros less than or equal to 16 bits.
1788:              *
1789:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1790:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1791:              *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
1792:              *
1793:              *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement 
1794:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s 
1795:              *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1796:              *                       initial 'val' is non-'0' :
1797:              *
1798:              *                           if (val != 0u) {
1799:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1800:              *                           } else {
1801:              *                               nbr_trail_zeros = nbr_lead_zeros;
1802:              *                           }
1803:              *
1804:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1805:              *                       execute the final 'if' statement.
1806:              *********************************************************************************************************
1807:              */
1808:              
1809:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1810:              CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
1811:              {
1812:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1813:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1814:                  CPU_INT16U  val_bit_mask;
1815:                  CPU_DATA    nbr_lead_zeros;
1816:              #endif
1817:                  CPU_DATA    nbr_trail_zeros;
1818:              
1819:              
1820:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0042BE  E00000     CP0 W0
0042C0  320004     BRA Z, 0x42CA
1821:                      return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
0042BC  200101     MOV #0x10, W1
1822:                  }
1823:              
1824:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1825:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1826:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1827:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1828:              
1829:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1830:                  val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0042C2  EA0080     NEG W0, W1
0042C4  608000     AND W1, W0, W0
1831:                  nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0042C6  07FF50     RCALL CPU_CntLeadZeros16
1832:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1833:                  nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0042C8  1000EF     SUBR W0, #0xF, W1
1834:              #endif
1835:              
1836:              
1837:                  return (nbr_trail_zeros);
1838:              }
0042CA  780001     MOV W1, W0
0042CC  060000     RETURN
1839:              #endif
1840:              
1841:              
1842:              /*
1843:              *********************************************************************************************************
1844:              *                                        CPU_CntTrailZeros32()
1845:              *
1846:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
1847:              *
1848:              * Argument(s) : val         Data value to count trailing zero bits.
1849:              *
1850:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1851:              *
1852:              * Caller(s)   : Application.
1853:              *
1854:              *               This function is a CPU module application programming interface (API) function & MAY be 
1855:              *               called by application function(s).
1856:              *
1857:              * Note(s)     : (1) Supports 32-bit values :
1858:              *
1859:              *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1860:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1861:              *                           x    x    x    x    x         x    x    1            0
1862:              *                           x    x    x    x    x         x    1    0            1
1863:              *                           x    x    x    x    x         1    0    0            2
1864:              *                           :    :    :    :    :         :    :    :            :
1865:              *                           :    :    :    :    :         :    :    :            :
1866:              *                           x    x    x    x    1         0    0    0           27
1867:              *                           x    x    x    1    0         0    0    0           28
1868:              *                           x    x    1    0    0         0    0    0           29
1869:              *                           x    1    0    0    0         0    0    0           30
1870:              *                           1    0    0    0    0         0    0    0           31
1871:              *                           0    0    0    0    0         0    0    0           32
1872:              *
1873:              *
1874:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1875:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1876:              *
1877:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1878:              *
1879:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1880:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1881:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return 
1882:              *                       data size, then the returned number of zeros must be offset by the difference 
1883:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
1884:              *
1885:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1886:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
1887:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1888:              *                           }
1889:              *
1890:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit 
1891:              *                       values would return a number of trailing zeros less than or equal to 32 bits.
1892:              *
1893:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1894:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1895:              *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
1896:              *
1897:              *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement 
1898:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s 
1899:              *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1900:              *                       initial 'val' is non-'0' :
1901:              *
1902:              *                           if (val != 0u) {
1903:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1904:              *                           } else {
1905:              *                               nbr_trail_zeros = nbr_lead_zeros;
1906:              *                           }
1907:              *
1908:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1909:              *                       execute the final 'if' statement.
1910:              *********************************************************************************************************
1911:              */
1912:              
1913:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1914:              CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
1915:              {
1916:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1917:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1918:                  CPU_INT32U  val_bit_mask;
1919:                  CPU_DATA    nbr_lead_zeros;
1920:              #endif
1921:                  CPU_DATA    nbr_trail_zeros;
1922:              
1923:              
1924:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0042D0  500FE0     SUB W0, #0x0, [W15]
0042D2  588FE0     SUBB W1, #0x0, [W15]
0042D4  320009     BRA Z, 0x42E8
1925:                      return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
0042CE  200202     MOV #0x20, W2
1926:                  }
1927:              
1928:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1929:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1930:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1931:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1932:              
1933:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1934:                  val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0042D6  100160     SUBR W0, #0x0, W2
0042D8  1881E0     SUBBR W1, #0x0, W3
0042DA  600202     AND W0, W2, W4
0042DC  608103     AND W1, W3, W2
0042DE  780182     MOV W2, W3
0042E0  780104     MOV W4, W2
0042E2  BE0002     MOV.D W2, W0
1935:                  nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0042E4  07FF4E     RCALL CPU_CntLeadZeros32
1936:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1937:                  nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0042E6  10017F     SUBR W0, #0x1F, W2
1938:              #endif
1939:              
1940:              
1941:                  return (nbr_trail_zeros);
1942:              }
0042E8  780002     MOV W2, W0
0042EA  060000     RETURN
1943:              #endif
1944:              
1945:              
1946:              /*
1947:              *********************************************************************************************************
1948:              *                                        CPU_CntTrailZeros64()
1949:              *
1950:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
1951:              *
1952:              * Argument(s) : val         Data value to count trailing zero bits.
1953:              *
1954:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1955:              *
1956:              * Caller(s)   : Application.
1957:              *
1958:              *               This function is a CPU module application programming interface (API) function & MAY be 
1959:              *               called by application function(s).
1960:              *
1961:              * Note(s)     : (1) Supports 64-bit values :
1962:              *
1963:              *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1964:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1965:              *                           x    x    x    x    x         x    x    1            0
1966:              *                           x    x    x    x    x         x    1    0            1
1967:              *                           x    x    x    x    x         1    0    0            2
1968:              *                           :    :    :    :    :         :    :    :            :
1969:              *                           :    :    :    :    :         :    :    :            :
1970:              *                           x    x    x    x    1         0    0    0           59
1971:              *                           x    x    x    1    0         0    0    0           60
1972:              *                           x    x    1    0    0         0    0    0           61
1973:              *                           x    1    0    0    0         0    0    0           62
1974:              *                           1    0    0    0    0         0    0    0           63
1975:              *                           0    0    0    0    0         0    0    0           64
1976:              *
1977:              *
1978:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1979:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1980:              *
1981:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1982:              *
1983:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1984:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1985:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return 
1986:              *                       data size, then the returned number of zeros must be offset by the difference 
1987:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
1988:              *
1989:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1990:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
1991:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1992:              *                           }
1993:              *
1994:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit 
1995:              *                       values would return a number of trailing zeros less than or equal to 64 bits.
1996:              *
1997:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1998:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1999:              *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
2000:              *
2001:              *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement 
2002:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s 
2003:              *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the 
2004:              *                       initial 'val' is non-'0' :
2005:              *
2006:              *                           if (val != 0u) {
2007:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
2008:              *                           } else {
2009:              *                               nbr_trail_zeros = nbr_lead_zeros;
2010:              *                           }
2011:              *
2012:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
2013:              *                       execute the final 'if' statement.
2014:              *********************************************************************************************************
2015:              */
2016:              
2017:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
2018:              CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
2019:              {
0042EC  BE9F88     MOV.D W8, [W15++]
0042EE  BE9F8A     MOV.D W10, [W15++]
2020:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2021:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
2022:                  CPU_INT64U  val_bit_mask;
2023:                  CPU_DATA    nbr_lead_zeros;
2024:              #endif
2025:                  CPU_DATA    nbr_trail_zeros;
2026:              
2027:              
2028:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0042F2  500FE0     SUB W0, #0x0, [W15]
0042F4  588FE0     SUBB W1, #0x0, [W15]
0042F6  590FE0     SUBB W2, #0x0, [W15]
0042F8  598FE0     SUBB W3, #0x0, [W15]
0042FA  32000D     BRA Z, 0x4316
2029:                      return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
0042F0  200404     MOV #0x40, W4
2030:                  }
2031:              
2032:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
2033:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2034:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
2035:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
2036:              
2037:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
2038:                  val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0042FC  B84460     MUL.UU W8, #0, W8
0042FE  B85560     MUL.UU W10, #0, W10
004300  540200     SUB W8, W0, W4
004302  5C8281     SUBB W9, W1, W5
004304  5D0302     SUBB W10, W2, W6
004306  5D8383     SUBB W11, W3, W7
004308  620000     AND W4, W0, W0
00430A  628081     AND W5, W1, W1
00430C  630102     AND W6, W2, W2
00430E  638183     AND W7, W3, W3
2039:                  nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
004310  07FF57     RCALL CPU_CntLeadZeros64
2040:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
2041:                  nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
004312  2003F4     MOV #0x3F, W4
004314  520200     SUB W4, W0, W4
2042:              #endif
2043:              
2044:              
2045:                  return (nbr_trail_zeros);
2046:              }
004316  780004     MOV W4, W0
2047:              #endif
2048:              
2049:              
2050:              /*
2051:              *********************************************************************************************************
2052:              *********************************************************************************************************
2053:              *                                           LOCAL FUNCTIONS
2054:              *********************************************************************************************************
2055:              *********************************************************************************************************
2056:              */
2057:              
2058:              /*
2059:              *********************************************************************************************************
2060:              *                                           CPU_NameInit()
2061:              *
2062:              * Description : Initialize CPU Name.
2063:              *
2064:              * Argument(s) : none.
2065:              *
2066:              * Return(s)   : none.
2067:              *
2068:              * Caller(s)   : CPU_Init().
2069:              *
2070:              * Note(s)     : none.
2071:              *********************************************************************************************************
2072:              */
2073:              
2074:              #if (CPU_CFG_NAME_EN == DEF_ENABLED)
2075:              static  void  CPU_NameInit (void)
2076:              {
2077:                  CPU_NameClr();
2078:              }
2079:              #endif
2080:              
2081:              
2082:              /*
2083:              *********************************************************************************************************
2084:              *                                            CPU_TS_Init()
2085:              *
2086:              * Description : (1) Initialize CPU timestamp :
2087:              *
2088:              *                   (a) Initialize/start CPU timestamp timer                            See Note #1
2089:              *                   (b) Initialize       CPU timestamp controls
2090:              *
2091:              *
2092:              * Argument(s) : none.
2093:              *
2094:              * Return(s)   : none.
2095:              *
2096:              * Caller(s)   : CPU_Init().
2097:              *
2098:              * Note(s)     : (1) The following initialization MUST be sequenced as follows :
2099:              *
2100:              *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
2101:              *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
2102:              *                                                 otherwise, invalid time measurements may be calculated/
2103:              *                                                 returned.
2104:              *
2105:              *                   See also 'CPU_Init()  Note #3a'.
2106:              *********************************************************************************************************
2107:              */
2108:              
2109:              #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
2110:                   (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
2111:              static  void  CPU_TS_Init (void)
2112:              {
2113:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2114:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2115:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2116:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2117:                  CPU_TS_TMR  ts_tmr_cnts;
2118:              #endif
2119:              
2120:              
2121:                                                                              /* ----------------- INIT CPU TS TMR ------------------ */
2122:              #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
2123:                  CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
2124:                  CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
2125:              #endif
2126:              
2127:              
2128:                                                                              /* ------------------- INIT CPU TS -------------------- */
2129:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2130:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2131:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2132:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2133:                  ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
2134:              #endif
2135:              
2136:              #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
2137:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
2138:                  CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
2139:                  CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
2140:              #endif
2141:              
2142:              #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
2143:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
2144:                  CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
2145:                  CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
2146:              #endif
2147:              }
2148:              #endif
2149:              
2150:              
2151:              /*
2152:              *********************************************************************************************************
2153:              *                                        CPU_IntDisMeasInit()
2154:              *
2155:              * Description : (1) Initialize interrupts disabled time measurements feature :
2156:              *
2157:              *                   (a) Initialize interrupts disabled time measurement controls
2158:              *                   (b) Calculate  interrupts disabled time measurement overhead
2159:              *
2160:              *
2161:              * Argument(s) : none.
2162:              *
2163:              * Return(s)   : none.
2164:              *
2165:              * Caller(s)   : CPU_Init().
2166:              *
2167:              * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
2168:              *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
2169:              *                   disabled time measurements may be calculated/returned.
2170:              *
2171:              *                   See also 'CPU_Init()  Note #3b'.
2172:              *
2173:              *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
2174:              *                           a rounded average with better accuracy, hopefully of +/- one timer count.
2175:              *
2176:              *                       (2) However, a single overhead time measurement is recommended, even for instruction-
2177:              *                           cache-enabled CPUs, since critical sections are NOT typically called within
2178:              *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
2179:              *                           is a more realistic overhead for the majority of non-cached interrupts disabled
2180:              *                           time measurements.
2181:              *
2182:              *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
2183:              *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
2184:              *                       calculate an inflated overhead time which would then incorrectly calculate deflated
2185:              *                       interrupts disabled times.
2186:              *********************************************************************************************************
2187:              */
2188:              
2189:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2190:              static  void  CPU_IntDisMeasInit (void)
2191:              {
2192:                  CPU_TS_TMR  time_meas_tot_cnts;
2193:                  CPU_INT16U  i;
2194:                  CPU_SR_ALLOC();
2195:              
2196:                                                                              /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
2197:                  CPU_IntDisMeasCtr         = 0u;
2198:                  CPU_IntDisNestCtr         = 0u;
2199:                  CPU_IntDisMeasStart_cnts  = 0u;
2200:                  CPU_IntDisMeasStop_cnts   = 0u;
2201:                  CPU_IntDisMeasMaxCur_cnts = 0u;
2202:                  CPU_IntDisMeasMax_cnts    = 0u;
2203:                  CPU_IntDisMeasOvrhd_cnts  = 0u;
2204:              
2205:                                                                              /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
2206:                  time_meas_tot_cnts = 0u;
2207:                  CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
2208:                  for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
2209:                      CPU_IntDisMeasMaxCur_cnts = 0u;
2210:                      CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
2211:                      CPU_IntDisMeasStop();
2212:                      time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
2213:                  }
2214:                                                                              /* ... to calc avg time meas ovrhd (see Note #3a).      */
2215:                  CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
2216:                                                                  /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
2217:                  CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
2218:                  CPU_IntDisMeasMax_cnts    =  0u;
2219:                  CPU_INT_EN();
2220:              }
2221:              #endif
2222:              
2223:              
2224:              /*
2225:              *********************************************************************************************************
2226:              *                                       CPU_IntDisMeasMaxCalc()
2227:              *
2228:              * Description : Calculate maximum interrupts disabled time.
2229:              *
2230:              * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
2231:              *
2232:              * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
2233:              *
2234:              * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
2235:              *               CPU_IntDisMeasMaxGet().
2236:              *
2237:              * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
2238:              *                       during critical sections is calculated by the following equations :
2239:              *
2240:              *                       (1) time            =   [ time      -  time      ]  -  time
2241:              *                               interrupts      [     stop         start ]         total meas
2242:              *                                disabled       [     meas         meas  ]           ovrhd
2243:              *                           (via application)
2244:              *
2245:              *
2246:              *                       (2) time            =  time            +  time
2247:              *                               total meas         start meas         stop meas
2248:              *                                 ovrhd              ovrhd              ovrhd
2249:              *
2250:              *
2251:              *                               where
2252:              *
2253:              *                                       time                    time interrupts are disabled between
2254:              *                                           interrupts              first critical section enter &
2255:              *                                            disabled               last  critical section exit minus
2256:              *                                       (via application)           time measurement overhead
2257:              *
2258:              *                                       time                    time of disable interrupts start time
2259:              *                                           start                   measurement (in timer counts)
2260:              *                                           meas
2261:              *
2262:              *                                       time                    time of disable interrupts stop  time
2263:              *                                           stop                    measurement (in timer counts)
2264:              *                                           meas
2265:              *
2266:              *                                       time                    total overhead time to start/stop disabled
2267:              *                                           total meas              interrupts time measurements (in timer
2268:              *                                             ovrhd                 counts)
2269:              *
2270:              *                                       time                    total overhead time after getting start
2271:              *                                           start meas              time until end of start measurement
2272:              *                                             ovrhd                 function  (in timer counts)
2273:              *
2274:              *                                       time                    total overhead time from beginning of stop
2275:              *                                           stop meas               measurement function until after getting
2276:              *                                             ovrhd                 stop time (in timer counts)
2277:              *
2278:              *
2279:              *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final 
2280:              *                       calculations to subtract the interrupts disabled time measurement overhead is 
2281:              *                       performed asynchronously in API functions.
2282:              *
2283:              *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
2284:              *
2285:              *                   (c) The amount of time interrupts are disabled is calculated by either of the
2286:              *                       following equations :
2287:              *
2288:              *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
2289:              *
2290:              *                               where
2291:              *
2292:              *                                   Number timer counts             Number of timer counts measured
2293:              *                                   Timer period                    Timer's period in some units of
2294:              *                                                                       (fractional) seconds
2295:              *                                   Interrupts disabled time        Amount of time interrupts are
2296:              *                                                                       disabled, in same units of
2297:              *                                                                       (fractional) seconds as the
2298:              *                                                                       Timer period
2299:              *
2300:              *                                                         Number timer counts
2301:              *                       (2) Interrupts disabled time  =  ---------------------
2302:              *                                                           Timer frequency
2303:              *
2304:              *                               where
2305:              *
2306:              *                                   Number timer counts             Number of timer counts measured
2307:              *                                   Timer frequency                 Timer's frequency in some units
2308:              *                                                                       of counts per second
2309:              *                                   Interrupts disabled time        Amount of time interrupts are
2310:              *                                                                       disabled, in seconds
2311:              *
2312:              *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
2313:              *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
2314:              *
2315:              *               (2) Although it is not typical, it is possible for an interrupts disabled time
2316:              *                   measurement to be less than the interrupts disabled time measurement overhead;
2317:              *                   especially if the overhead was calculated with a single, non-cached measurement
2318:              *                   & critical sections are called within instruction-cached loops.
2319:              *********************************************************************************************************
2320:              */
2321:              
2322:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2323:              static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
2324:              {
2325:                  CPU_TS_TMR  time_max_cnts;
2326:              
2327:              
2328:                  time_max_cnts = time_tot_cnts;
2329:                  if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
2330:                      time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
2331:                  } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
2332:                      time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
2333:                  }
2334:              
2335:                  return (time_max_cnts);
2336:              }
2337:              #endif
2338:              
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                /*
25:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
26:                
27:                Microchip licenses to you the right to use, modify, copy and distribute
28:                Software only when embedded on a Microchip microcontroller or digital signal
29:                controller that is integrated into your product or third party product
30:                (pursuant to the sublicense terms in the accompanying license agreement).
31:                
32:                You should refer to the license agreement accompanying this Software for
33:                additional information regarding your rights and obligations.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                 */
46:                
47:                
48:                #include <includes.h>
49:                #include "Configbits.h"
50:                
51:                //#include "HL6528.h"
52:                //#include "UART.h"
53:                //#include <xc.h>
54:                //#include "mcc_generated_files/mcc.h"
55:                //volatile uint8_t TMR1_CNT;
56:                
57:                
58:                uint8_t WGC_sta;
59:                OS_STK LEDStk[128];
60:                OS_STK HL6528Stk[512]; //mark
61:                OS_STK E41Stk[256];
62:                OS_STK Tsk7[256]; //
63:                //OS_STK I2CStk[128];
64:                //OS_STK U485Stk[128];
65:                //OS_STK SLPStk[32];
66:                //OS_STK PCCopStk[32];
67:                OS_EVENT *sem_set_alarm, *sem_get_pressure, *sem_send_pressure, *sem_receive_pressure;
68:                //OS_EVENT* E41_Dat; //, *sem2;
69:                //OS_FLAG_GRP *sem_F;
70:                
71:                static void Task1Led(void* p_arg);
72:                //static void Task2CopGPRS(void* p_arg);
73:                static void Task2UseHL6528(void *p_arg);
74:                static void Task3UseE41(void *parg);
75:                static void Task4Use485(void *parg);
76:                static void Task5TestI2C(void* parg);
77:                static void Task6Sleep(void* p_arg);
78:                static void Task7SetAlarm(void *p_arg);
79:                extern I2C1_Buffer i2c_buf;
80:                extern volatile uint8_t i2c1_state;
81:                
82:                /*
83:                                         Main application
84:                 */
85:                CPU_INT16S main(void) {
86:                    // initialize the device
87:                    //    SYSTEM_Initialize();
88:                    //    TMR1_Stop();
89:                    //    TMR1_Stop();
90:                    INT8U err;
91:                    BSP_Init(); //
0048C6  0701FD     RCALL BSP_Init
92:                
93:                    OSInit();
0048C8  07ECD2     RCALL OSInit
94:                    sem_send_pressure = OSSemCreate(0);
0048CA  EB0000     CLR W0
0048CC  07F7D8     RCALL OSSemCreate
0048CE  8841B0     MOV W0, sem_send_pressure
95:                    sem_get_pressure = OSSemCreate(0);
0048D0  EB0000     CLR W0
0048D2  07F7D5     RCALL OSSemCreate
0048D4  8841A0     MOV W0, sem_get_pressure
96:                    sem_receive_pressure = OSSemCreate(0);
0048D6  EB0000     CLR W0
0048D8  07F7D2     RCALL OSSemCreate
0048DA  8841C0     MOV W0, sem_receive_pressure
97:                    sem_set_alarm = OSSemCreate(0);
0048DC  EB0000     CLR W0
0048DE  07F7CF     RCALL OSSemCreate
0048E0  884190     MOV W0, sem_set_alarm
98:                    //    sem_F = OSFlagCreate(0, &err);
99:                    //    sem2 = OSSemCreate(0);
100:                   //    E41_Dat = OSMboxCreate((void*) 0);
101:                   //    sem2 = OSSemCreate(1);
102:               
103:                   OSTaskCreate(Task1Led, (void*) 0, (OS_STK *) & LEDStk[0], 3);
0048E2  B3C033     MOV.B #0x3, W3
0048E4  2084A2     MOV #0x84A, W2
0048E6  EB0080     CLR W1
0048E8  248800     MOV #0x4880, W0
0048EA  07EF1B     RCALL OSTaskCreate
104:                   OSTaskCreate(Task7SetAlarm, (void*) 0, (OS_STK*) & Tsk7[0], 4);
0048EC  B3C043     MOV.B #0x4, W3
0048EE  20F4A2     MOV #0xF4A, W2
0048F0  EB0080     CLR W1
0048F2  248380     MOV #0x4838, W0
0048F4  07EF16     RCALL OSTaskCreate
105:                   OSTaskCreate(Task3UseE41, (void*) 0, (OS_STK*) & E41Stk[0], 5);
0048F6  B3C053     MOV.B #0x5, W3
0048F8  20D4A2     MOV #0xD4A, W2
0048FA  EB0080     CLR W1
0048FC  247F80     MOV #0x47F8, W0
0048FE  07EF11     RCALL OSTaskCreate
106:                   OSTaskCreate(Task2UseHL6528, (void*) 0, (OS_STK *) & HL6528Stk[0], 6); //mark
004900  B3C063     MOV.B #0x6, W3
004902  2094A2     MOV #0x94A, W2
004904  EB0080     CLR W1
004906  247BE0     MOV #0x47BE, W0
004908  07EF0C     RCALL OSTaskCreate
107:                   //    OSTaskCreate(Task4Use485, (void*) 0, (OS_STK *) & U485Stk[0], 4);
108:                   //    OSTaskCreate(Task5TestI2C, (void*) 0, (OS_STK*) & I2CStk[0], 6);
109:                   //    OSTaskCreate(Task6Sleep, (void*) 0, (OS_STK*) & SLPStk[0], 8);
110:                   OSStart();
00490A  07EB75     RCALL OSStart
111:                   return -1;
112:               
113:               }
00490C  EB8000     SETM W0
114:               
115:               /**
116:                End of File
117:                */
118:               
119:               void Task1Led(void* p_arg) {
004880  781F88     MOV W8, [W15++]
120:                   INT8U err;
121:                   //    uint8_t cnt = 0;
122:                   //    OS_EVENT sem1;
123:                   while (1) {
124:                       //        PrintTime();
125:                       switch (WGC_sta) {
004882  208308     MOV #0x830, W8
004884  784418     MOV.B [W8], W8
004886  544FE2     SUB.B W8, #0x2, [W15]
004888  32000B     BRA Z, 0x48A0
00488A  3E0003     BRA GTU, 0x4892
00488C  544FE1     SUB.B W8, #0x1, [W15]
00488E  3A0014     BRA NZ, 0x48B8
004890  370005     BRA 0x489C
004892  544FE3     SUB.B W8, #0x3, [W15]
004894  320008     BRA Z, 0x48A6
004896  544FE4     SUB.B W8, #0x4, [W15]
004898  3A000F     BRA NZ, 0x48B8
00489A  370009     BRA 0x48AE
126:                           case 1://
127:                           {
128:                               LED_Toggle();
00489C  0701FD     RCALL LED_Toggle
00489E  370004     BRA 0x48A8
129:                               OSTimeDlyHMSM(0, 0, 1, 0); //1s 
130:                               break;
131:                           }
132:                           case 2://
133:                           {
134:                               LED_Toggle();
0048A0  0701FB     RCALL LED_Toggle
135:                               OSTimeDlyHMSM(0, 0, 0, 500); //1s  
0048A2  201F43     MOV #0x1F4, W3
0048A4  370006     BRA 0x48B2
136:                               break;
137:                           }
138:                           case 3://
139:                           {
140:                               LED_On();
0048A6  0701F2     RCALL LED_On
141:                               OSTimeDlyHMSM(0, 0, 3, 0); //  
0048A8  EB0180     CLR W3
0048AA  784108     MOV.B W8, W2
0048AC  370008     BRA 0x48BE
142:                               break;
143:                           }
144:                           case 4://
145:                           {
146:                               LED_Toggle();
0048AE  0701F4     RCALL LED_Toggle
147:                               OSTimeDlyHMSM(0, 0, 0, 200); //1s  
0048B0  200C83     MOV #0xC8, W3
0048B2  EB4100     CLR.B W2
0048B4  784082     MOV.B W2, W1
0048B6  370004     BRA 0x48C0
148:                               break;
149:                           }
150:                           default://
151:                           {
152:                               LED_Toggle();
0048B8  0701EF     RCALL LED_Toggle
153:                               err = OSTimeDlyHMSM(0, 0, 2, 0); //1s  
0048BA  EB0180     CLR W3
0048BC  B3C022     MOV.B #0x2, W2
0048BE  EB4080     CLR.B W1
0048C0  784001     MOV.B W1, W0
0048C2  07015E     RCALL OSTimeDlyHMSM
0048C4  37FFDE     BRA 0x4882
154:                               break;
155:                           }
156:               
157:                       }
158:                   }
159:               }
160:               
161:               void Task2UseHL6528(void *p_arg) {
0047BE  FA0002     LNK #0x2
162:                   INT8U err;
163:                   //    uint8_t tmp[55];//IP
164:                   //    float press = 0;
165:                   //    struct tm time2;
166:                   //    time_t time3;
167:                   //    uint8_t press[] = {0, 1, 2, 3};
168:                   HL6528_Init(); /*Initialize the HL6528*/
0047C0  07FC41     RCALL HL6528_Init
169:                   //    OSTimeDlyHMSM(0, 0, 5, 0);
170:                   while (1) {
171:                       OSSemPend(sem_send_pressure, 0, &err);
0047C2  E9808F     DEC2 W15, W1
0047C4  B81160     MUL.UU W2, #0, W2
0047C6  8041B0     MOV sem_send_pressure, W0
0047C8  07F8BF     RCALL OSSemPend
172:                       UART2_Open();
0047CA  07033F     RCALL UART2_Open
173:                       WGC_sta = 2; //GPRS
0047CC  B3C020     MOV.B #0x2, W0
0047CE  B7E830     MOV.B WREG, WGC_sta
174:                       //        HL6528_GetIP_Port(tmp);
175:                       if (!HL6528_DialingIsERR()) {
0047D0  07FC46     RCALL HL6528_DialingIsERR
0047D2  E00400     CP0.B W0
0047D4  3A000E     BRA NZ, 0x47F2
176:                           WGC_sta = 3; //GPRS
0047D6  B3C030     MOV.B #0x3, W0
0047D8  B7E830     MOV.B WREG, WGC_sta
177:                           OSTimeDlyHMSM(0, 0, 1, 0); //1s
0047DA  EB0180     CLR W3
0047DC  B3C012     MOV.B #0x1, W2
0047DE  EB4080     CLR.B W1
0047E0  784001     MOV.B W1, W0
0047E2  0701CE     RCALL OSTimeDlyHMSM
178:                           UART2_SendString("*89887#6688#sample*");
0047E4  29E6A0     MOV #0x9E6A, W0
0047E6  07033E     RCALL UART2_SendString
179:                           OSTimeDlyHMSM(0, 0, 1, 0); //1s
0047E8  EB0180     CLR W3
0047EA  B3C012     MOV.B #0x1, W2
0047EC  EB4080     CLR.B W1
0047EE  784001     MOV.B W1, W0
0047F0  0701C7     RCALL OSTimeDlyHMSM
180:                       }
181:                       HL6528_Close();
0047F2  07FC7A     RCALL HL6528_Close
182:                       WGC_sta = 0; //GPRS
0047F4  EF6830     CLR.B WGC_sta
183:                   }
0047F6  37FFE5     BRA 0x47C2
184:               }
185:               
186:               void Task3UseE41(void *parg) {
0047F8  FA0006     LNK #0x6
187:                   INT8U err;
188:                   float f_dat;
189:                   E41_Init();
0047FA  0700A6     RCALL E41_Init
190:                   OSTimeDlyHMSM(0, 0, 1, 0); //1s
0047FC  EB0180     CLR W3
0047FE  B3C012     MOV.B #0x1, W2
004800  EB4080     CLR.B W1
004802  784001     MOV.B W1, W0
004804  0701BD     RCALL OSTimeDlyHMSM
191:                   //    uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34};
192:                   //    E41_SetArg(); //E41
193:                   while (1) {
194:                       OSSemPend(sem_get_pressure, 0, &err); //
004806  5780E6     SUB W15, #0x6, W1
004808  B81160     MUL.UU W2, #0, W2
00480A  8041A0     MOV sem_get_pressure, W0
00480C  07F89D     RCALL OSSemPend
195:                       E41_Active_Send();
00480E  0700EC     RCALL E41_Active_Send
196:                       OSSemPend(sem_receive_pressure, 1000, &err);
004810  5780E6     SUB W15, #0x6, W1
004812  203E82     MOV #0x3E8, W2
004814  200003     MOV #0x0, W3
004816  8041C0     MOV sem_receive_pressure, W0
004818  07F897     RCALL OSSemPend
197:                       WGC_sta = 4;
00481A  B3C040     MOV.B #0x4, W0
00481C  B7E830     MOV.B WREG, WGC_sta
198:                       OSTimeDlyHMSM(0, 0, 3, 0); //1s
00481E  EB0180     CLR W3
004820  B3C032     MOV.B #0x3, W2
004822  EB4080     CLR.B W1
004824  784001     MOV.B W1, W0
004826  0701AC     RCALL OSTimeDlyHMSM
199:                       //        LED_Toggle();
200:                       //        OSTimeDlyHMSM(0, 0, 0, 200);
201:                       if (E41_PressureIsGet(&f_dat)) {
004828  578064     SUB W15, #0x4, W0
00482A  0700A5     RCALL E41_PressureIsGet
00482C  E00400     CP0.B W0
00482E  320002     BRA Z, 0x4834
202:                           OSSemPost(sem_send_pressure);
004830  8041B0     MOV sem_send_pressure, W0
004832  07F902     RCALL OSSemPost
203:                           //            OSMboxPost(E41_Dat, &f_dat); //
204:                       }
205:                       WGC_sta = 0;
004834  EF6830     CLR.B WGC_sta
206:                       //        UART3_SendString(E41_tmp, 5);
207:                       //        OSTimeDlyHMSM(0, 0, 10, 0); //1s
208:                   }
004836  37FFE7     BRA 0x4806
209:               }
210:               
211:               //void Task4Use485(void *parg) {
212:               //    parg = parg;
213:               //    while (1) {
214:               //        RS485SendChar(0x30);
215:               //        //        RS485SendString("123", 3);
216:               //        OSTimeDlyHMSM(0, 0, 1, 0);
217:               //        //        OSSemPost(sem1);
218:               //    }
219:               //}
220:               
221:               //void Task5TestI2C(void* parg) {
222:               //    parg = parg;
223:               //    struct tm Alatime;
224:               //    uint32_t timestamp = 1499598934;
225:               // CAT24C512_Init(); //
226:               //    INT8U err;
227:               //    PCF8583_SetTime(&timestamp);
228:               //    OSTimeDlyHMSM(0, 0, 0, 100);
229:               //    PCF8583_SetStatusReg(0x05);
230:               //    OSTimeDlyHMSM(0, 0, 0, 100);
231:               //    Alatime.tm_hour = 11;
232:               //    Alatime.tm_min = 15;
233:               //    Alatime.tm_sec = 50;
234:               //    PCF8583_SetAlarmTime(Alatime);
235:               //    while (1) {
236:               //
237:               //        //        OSTimeDlyHMSM(0, 0, 50, 0);
238:               //        if (!PORTBbits.RB13) {
239:               //            OSTimeDlyHMSM(0, 0, 1, 0);
240:               //            PCF8583_SetStatusReg(0x05); //PCF8583
241:               //        }
242:               //
243:               //        OSSemPend(sem2, 0, &err); //, 0, &err);
244:               //        //        CAT24C512_Read(0, tmp2);
245:               //        //        timestamp1 = PCF8583_ReadTime(); //1499598934
246:               //        //        PCF8583_ReadStatus(tmp2);
247:               //        //        OSTimeDlyHMSM(0, 0, 0, 500);
248:               //    }
249:               //}
250:               
251:               //void Task6Sleep(void* p_arg) {
252:               //    p_arg = p_arg;
253:               //    LED_Off();
254:               //    //    TRIS
255:               //    while (1) {
256:               //        DeepSleep();
257:               //        OSSemPost(sem2); //, 0, &err);
258:               //        //        Sleep();
259:               //
260:               //    }
261:               //}
262:               //
263:               
264:               void Task7SetAlarm(void *p_arg) {
004838  FA0018     LNK #0x18
00483A  781F88     MOV W8, [W15++]
265:                   INT8U err;
266:                   //    static uint8_t tag_Time; //
267:                   //    uint8_t quotients, remainders; //
268:                   //    static uint8_t repeat_cnt = 0; //
269:                   time_t now_time;
270:                   struct tm now_time1;
271:                   //    struct WGC_ARG tmp_arg;
272:                   WGC_sta = 0;
00483C  EF6830     CLR.B WGC_sta
273:                   //    uint8_t sta = 0; //
274:               
275:                   //    WGC_Get_Arg(&tmp_arg); //WGC
276:               
277:                   //    if (tmp_arg.Sample_Time >= tmp_arg.Send_Time[0]) {//
278:                   //        quotients = remainders = 1;
279:                   //    } else {
280:                   //        quotients = tmp_arg.Send_Time[0] / tmp_arg.Sample_Time;
281:                   //        remainders = tmp_arg.Send_Time[0] % tmp_arg.Sample_Time;
282:                   //    }
283:                   IFS3bits.RTCIF = 1; //
00483E  A8C08B     BSET 0x8B, #6
284:               
285:                   while (1) {
286:                       OSSemPend(sem_set_alarm, 0, &err);
004840  78008E     MOV W14, W1
004842  B81160     MUL.UU W2, #0, W2
004844  804190     MOV sem_set_alarm, W0
004846  07F880     RCALL OSSemPend
287:                       PrintTime();
004848  07FB46     RCALL PrintTime
288:                       while (!RTC_Read_Time(&now_time1)); // 
00484A  470066     ADD W14, #0x6, W0
00484C  07FACC     RCALL RTC_Read_Time
00484E  E00000     CP0 W0
004850  32FFFC     BRA Z, 0x484A
289:                       now_time = mktime(&now_time1); //
004852  470066     ADD W14, #0x6, W0
004854  07DF20     RCALL 0x696
290:                       //        if (repeat_cnt >= quotients) {
291:                       //            if (remainders)
292:                       //                now_time += remainders; //
293:                       //            else
294:                       //                now_time += 20;
295:                       //            repeat_cnt = 0;
296:                       //            //
297:                       //            if (tmp_arg.Sample_Time >= tmp_arg.Send_Time[0]) {//
298:                       //                quotients = remainders = 1;
299:                       //            } else {
300:                       //                quotients = tmp_arg.Send_Time[0] / tmp_arg.Sample_Time;
301:                       //                remainders = tmp_arg.Send_Time[0] % tmp_arg.Sample_Time;
302:                       //            }
303:                       //        } else {
304:                       //            now_time += 15; //(unsigned int) (tmp_arg.Sample_Time) * 60; //
305:                       //            repeat_cnt += 1;
306:                       //        }
307:                       now_time += 60; //
004856  B003C0     ADD #0x3C, W0
004858  B08001     ADDC #0x0, W1
00485A  980710     MOV W0, [W14+2]
00485C  980721     MOV W1, [W14+4]
308:                       now_time1 = *gmtime(&now_time); //
00485E  E8800E     INC2 W14, W0
004860  07DF16     RCALL 0x68E
004862  4700E6     ADD W14, #0x6, W1
004864  090008     REPEAT #0x8
004866  7818B0     MOV [W0++], [W1++]
004868  B10120     SUB #0x12, W0
309:                       RTC_Set_Alarm(now_time1);
00486A  4787F2     ADD W15, #0x12, W15
00486C  578472     SUB W15, #0x12, W8
00486E  470066     ADD W14, #0x6, W0
004870  090008     REPEAT #0x8
004872  781C30     MOV [W0++], [W8++]
004874  B10128     SUB #0x12, W8
004876  07FA92     RCALL RTC_Set_Alarm
310:                       OSSemPost(sem_get_pressure); //
004878  8041A0     MOV sem_get_pressure, W0
00487A  07F8DE     RCALL OSSemPost
311:                   }
00487C  780788     MOV W8, W15
00487E  37FFE0     BRA 0x4840
312:               }
313:               
314:               
315:               
316:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/WCG.c  --------------------------------------
1:                 //#include<stdbool.h>
2:                 //#include<stdint.h>
3:                 #include "WCG.h"
4:                 //uint8_t wcg_arg[] ={
5:                 //    0xDD, 0xC2, 0x66, 0x8D, /*IP*/0xAE, 0x08, /**/0x30, /*GPRS*/0x30, /*TCP*/
6:                 //    0x30, /*IP*/0x0B, 0x13, 0x80, 0x57, 0x71, 0x11, 0x1F, /**/0x0B, 0x13, 0x80, 0x57, 0x72, 0x22, 0x2F, /**/
7:                 //    0x30, /**/0x30, /**/0x31, /*9600*/0x00, 0x00, /**/0x2D, 0x00, /**/0x00, 0x00, /**/
8:                 //    0x30, /**/0x0D, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2E, 0x63, 0x6F, 0x6D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
9:                 //    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /*DNS*/0x05, 0x63, 0x6D, 0x6E, 0x65, 0x74, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
10:                //    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /*APN*/
11:                //    0x30, /**/0x0B, 0x13, 0x80, 0x57, 0x73, 0x33, 0x3F, /**/0x0B, 0x13, 0x80, 0x57, 0x70, 0x01, 0x1F, /*2*/
12:                //    0x0B, 0x13, 0x80, 0x05, 0x77, 0x50, 0x0F, /**/0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF/**/
13:                //}
14:                
15:                
16:                
17:                static struct WGC_ARG WGC_arg = {
18:                    .Sample_Time = 0x05, /*byte=1 */
19:                    .Send_Time =
20:                    {
21:                        0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
22:                        0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
23:                        0x1E, 0x1E, 0x1E, 0x1E
24:                    }, /*byte=24 */
25:                    .Net_arg =
26:                    {
27:                        .IP_Addr = "139.196.122.159", //"139.196.122.15900000"
28:                        .Port = 5080, //5080
29:                        .APN =
30:                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
31:                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //APN=NULL;
32:                        .APN_User =
33:                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
34:                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //APN_Name=NULL;
35:                        .APN_Password =
36:                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
37:                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} //APN_Password=NULL;
38:                    },
39:                    .Channel_arg =
40:                    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
41:                    .Pulse_arg =
42:                    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
43:                    .PT_arg =
44:                    {
45:                        .P_87_full_scale = 0,
46:                        .P_88_full_scale = 0,
47:                        .P_lower_limit = 0,
48:                        .P_upper_limit = 0,
49:                        .P_Max_of_Mutations = 0
50:                    },
51:                    .SST_arg =
52:                    {
53:                        .Send_time = 0x5,
54:                        .Start_time_hour = 0x8,
55:                        .Start_time_minutes = 0x1e
56:                    },
57:                    .Set_minute =
58:                    {
59:                        .Channel_number = 0x01,
60:                        .Minuent =
61:                        {0x01, 0x00, 0x00, 0x00, 0x00}
62:                    },
63:                    .Other_onlie_arg =
64:                    {
65:                        .Start_day = 0,
66:                        .Start_hour = 0,
67:                        .Start_minutes = 0,
68:                        .Serial_interval_Type = 3,
69:                        .Serial_interval_Num = 1,
70:                        .Is_send_by_addr = 0,
71:                        .Send_serial_interval_by_addr = 0x1e
72:                    },
73:                    .WCG_id =
74:                    {
75:                        .Producer_id = 0x0008,
76:                        .Producer_name = 0x5747,
77:                        .client_id = 0x03
78:                    }
79:                };
80:                //static uint8_t wcg_arg[] = {
81:                //    0x05, /*byte=1 */
82:                //    0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
83:                //    0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
84:                //    0x1E, 0x1E, 0x1E, 0x1E, /*byte=24 */
85:                //};
86:                
87:                void WGC_Import_Arg(void) {
88:                
89:                }
0051E8  060000     RETURN
90:                
91:                void WGC_Export_Arg(void) {
92:                
93:                }
0051EA  060000     RETURN
94:                
95:                void WGC_Get_Arg(struct WGC_ARG *tmp_arg) {
96:                    //    uint8_t bytes=sizeof (WGC_arg);
97:                    memcpy(tmp_arg, &WGC_arg, sizeof (WGC_arg));
0051EC  29CDA1     MOV #0x9CDA, W1
0051EE  090052     REPEAT #0x52
0051F0  781831     MOV [W1++], [W0++]
0051F2  B10A60     SUB #0xA6, W0
98:                    //memcpy(b, a,sizeof(b)); //sizeof(a)b
99:                
100:                   //strcpy'\0'
101:               }
0051F4  060000     RETURN
102:               
103:               /*
104:               				
105:               1	0x00		1	0x010x050x0A0x0F0x140x1E
106:               2	0x01		24	0-59:
107:               0xff:
108:               0x99:
109:               3	0x02		82	
110:                       IP	[20]	20ASCII0()
111:                       	[2]	2
112:                       APN	[20]	20ASCII0()
113:                       APN	[20]	20ASCII0()
114:                       APN	[20]	20ASCII0()
115:               4	0x03		8	
116:               5	0x04		6	
117:               6	0x05		20	
118:                       87	[4]	1
119:               2*1000
120:               40060000 =1.6MPa
121:               3
122:                       88	[4]	
123:                       	[4]	
124:                       	[4]	
125:                       	[4]	
126:               7	0x06		4	
127:                       	[2]	
128:                       -	[1]	
129:                       -	[1]	
130:               8	0x07		6	
131:                       	[1]	
132:                       	[5]	1(0-9)4()
133:               9	0x08		7	
134:                       	[1]	
135:                       	[1]	
136:                       	[1]	
137:                       	[1]	0
138:               1
139:               2
140:               3
141:                       	[1]	
142:                       	[1]	00 - 01 - 
143:                       	[1]	
144:               10	0xFF	ID	5	
145:                       ID	[2]	0000-0xFFFF
146:                       	[2]	WG
147:                       ID	[1]	
148:                */
149:               
150:               //uint8_t WGC_Get_Sta(void)
151:               //{
152:               //    if()
153:               //}
154:               
155:               
156:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**************************************************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 
25:                Input: 12 
26:                Output: 
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {// 
00431E  BFC83A     MOV.B bufferWptr_uart1, WREG
004320  FB8080     ZE W0, W1
004322  2083B2     MOV #0x83B, W2
004324  784112     MOV.B [W2], W2
004326  FB8102     ZE W2, W2
004328  E90102     DEC W2, W2
00432A  508F82     SUB W1, W2, [W15]
00432C  3A0002     BRA NZ, 0x4332
31:                        tmp = U1RXREG; //
00432E  801130     MOV U1RXREG, W0
32:                        return;
004330  060000     RETURN
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
004332  801133     MOV U1RXREG, W3
004334  21A662     MOV #0x1A66, W2
004336  78F103     MOV.B W3, [W2+W1]
35:                    bufferWptr_uart1++;
004338  E84000     INC.B W0, W0
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
00433A  B243F0     AND.B #0x3F, W0
00433C  B7E83A     MOV.B WREG, bufferWptr_uart1
00433E  060000     RETURN
37:                }
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 
42:                Input: 12 
43:                Output: 
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
46:                    uint8_t tmp = 0;
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {// 
004340  BFC83C     MOV.B bufferWptr_uart2, WREG
004342  FB8080     ZE W0, W1
004344  2083D2     MOV #0x83D, W2
004346  784112     MOV.B [W2], W2
004348  FB8102     ZE W2, W2
00434A  E90102     DEC W2, W2
00434C  508F82     SUB W1, W2, [W15]
00434E  3A0002     BRA NZ, 0x4354
48:                        tmp = U2RXREG; //
004350  8011B0     MOV U2RXREG, W0
49:                        return;
004352  060000     RETURN
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
004354  8011B3     MOV U2RXREG, W3
004356  21AA62     MOV #0x1AA6, W2
004358  78F103     MOV.B W3, [W2+W1]
52:                    bufferWptr_uart2++;
00435A  E84000     INC.B W0, W0
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
00435C  B243F0     AND.B #0x3F, W0
00435E  B7E83C     MOV.B WREG, bufferWptr_uart2
004360  060000     RETURN
54:                }
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 
59:                Input: 12 
60:                Output: 
61:                 *************************************/
62:                void BufferWrite_UART3(void) {
63:                    uint8_t tmp = 0;
64:                    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {// 
004362  BFC83E     MOV.B bufferWptr_uart3, WREG
004364  FB8080     ZE W0, W1
004366  2083F2     MOV #0x83F, W2
004368  784112     MOV.B [W2], W2
00436A  FB8102     ZE W2, W2
00436C  E90102     DEC W2, W2
00436E  508F82     SUB W1, W2, [W15]
004370  3A0002     BRA NZ, 0x4376
65:                        tmp = U3RXREG; //
004372  8012B0     MOV U3RXREG, W0
66:                        return;
004374  060000     RETURN
67:                    }
68:                    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
004376  8012B3     MOV U3RXREG, W3
004378  21AE62     MOV #0x1AE6, W2
00437A  78F103     MOV.B W3, [W2+W1]
69:                    bufferWptr_uart3++;
00437C  E84000     INC.B W0, W0
70:                    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
00437E  B243F0     AND.B #0x3F, W0
004380  B7E83E     MOV.B WREG, bufferWptr_uart3
004382  060000     RETURN
71:                }
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 
76:                Input:  
77:                Output: 10
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
004384  780100     MOV W0, W2
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
004386  2083B1     MOV #0x83B, W1
004388  784091     MOV.B [W1], W1
00438C  2083A3     MOV #0x83A, W3
00438E  784193     MOV.B [W3], W3
004390  51CF81     SUB.B W3, W1, [W15]
004392  320007     BRA Z, 0x43A2
81:                        return 0;
00438A  EB4000     CLR.B W0
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
004394  FB8081     ZE W1, W1
004396  21A660     MOV #0x1A66, W0
004398  78C960     MOV.B [W0+W1], [W2]
84:                    bufferRptr_uart1++;
00439A  EC483B     INC.B bufferRptr_uart1, WREG
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
00439C  B243F0     AND.B #0x3F, W0
00439E  B7E83B     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
0043A0  B3C010     MOV.B #0x1, W0
87:                }
0043A2  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 
92:                Input:  
93:                Output: 10
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
0043A4  2083D1     MOV #0x83D, W1
0043A6  784091     MOV.B [W1], W1
0043A8  2083C2     MOV #0x83C, W2
0043AA  784112     MOV.B [W2], W2
0043AC  514F81     SUB.B W2, W1, [W15]
0043AE  3A0005     BRA NZ, 0x43BA
97:                        if (U2STAbits.OERR)
0043B2  AB2232     BTST U2STA, #1
0043B4  320009     BRA Z, 0x43C8
98:                            U2STAbits.OERR = 0; //FIFO
0043B6  A92232     BCLR U2STA, #1
0043B8  060000     RETURN
99:                        return 0;
0043B0  EB4000     CLR.B W0
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
0043BA  FB8081     ZE W1, W1
0043BC  21AA62     MOV #0x1AA6, W2
0043BE  78C862     MOV.B [W2+W1], [W0]
102:                   bufferRptr_uart2++;
0043C0  EC483D     INC.B bufferRptr_uart2, WREG
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
0043C2  B243F0     AND.B #0x3F, W0
0043C4  B7E83D     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
0043C6  B3C010     MOV.B #0x1, W0
106:               }
0043C8  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 
111:               Input:  
112:               Output: 10
113:                *************************************/
114:               bool BufferRead_UART3(uint8_t *data) {
115:                   if (bufferRptr_uart3 == bufferWptr_uart3) {
0043CA  2083F1     MOV #0x83F, W1
0043CC  784091     MOV.B [W1], W1
0043CE  2083E2     MOV #0x83E, W2
0043D0  784112     MOV.B [W2], W2
0043D2  514F81     SUB.B W2, W1, [W15]
0043D4  3A0005     BRA NZ, 0x43E0
116:                       if (U3STAbits.OERR)
0043D8  AB2252     BTST U3STA, #1
0043DA  320009     BRA Z, 0x43EE
117:                           U3STAbits.OERR = 0; //FIFO
0043DC  A92252     BCLR U3STA, #1
0043DE  060000     RETURN
118:                       return 0;
0043D6  EB4000     CLR.B W0
119:                   }
120:                   *data = Buffer_uart3[bufferRptr_uart3];
0043E0  FB8081     ZE W1, W1
0043E2  21AE62     MOV #0x1AE6, W2
0043E4  78C862     MOV.B [W2+W1], [W0]
121:                   bufferRptr_uart3++;
0043E6  EC483F     INC.B bufferRptr_uart3, WREG
122:                   bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
0043E8  B243F0     AND.B #0x3F, W0
0043EA  B7E83F     MOV.B WREG, bufferRptr_uart3
123:                   //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:                   return 1;
0043EC  B3C010     MOV.B #0x1, W0
125:               }
0043EE  060000     RETURN
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 
130:               Input: 
131:               Output: 
132:               Notice256    
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//
0043F0  781F88     MOV W8, [W15++]
135:                   bool IsFind = false; //
136:                   uint8_t cnt = 0/**/, cnt1 = 0/**/, cnt2/**/, /*offset,*/ byte = 0;
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//0
0043F2  904260     MOV.B [W0+6], W4
0043F6  E00404     CP0.B W4
0043F8  32004A     BRA Z, 0x448E
0043FA  9041A0     MOV.B [W0+2], W3
0043FC  E00403     CP0.B W3
0043FE  320047     BRA Z, 0x448E
004400  EB0080     CLR W1
004402  370017     BRA 0x4432
139:                       return false; //
0043F4  EB4080     CLR.B W1
140:               
141:                   while (cnt < strcmp->Source_len) {
004434  50CF83     SUB.B W1, W3, [W15]
004436  39FFE6     BRA NC, 0x4404
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//==head           
004404  408410     ADD W1, [W0], W8
004406  9003A0     MOV [W0+4], W7
004408  784298     MOV.B [W8], W5
00440A  52CF97     SUB.B W5, [W7], [W15]
00440C  3A0011     BRA NZ, 0x4430
00440E  B3C015     MOV.B #0x1, W5
004410  EB4300     CLR.B W6
004412  370005     BRA 0x441E
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//               
00441A  E84285     INC.B W5, W5
00441E  52CF84     SUB.B W5, W4, [W15]
004420  39FFF9     BRA NC, 0x4414
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//
004414  784358     MOV.B [++W8], W6
004416  534FD7     SUB.B W6, [++W7], [W15]
004418  3A000B     BRA NZ, 0x4430
145:                                   IsFind = true;
00441C  B3C016     MOV.B #0x1, W6
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
149:                                   break;
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //
004422  E00406     CP0.B W6
004424  320005     BRA Z, 0x4430
154:                       cnt++; //1
155:                   }
156:               
157:                   if (IsFind) {//
158:                       if (strcmp->Get_len < strcmp->Check_len) {
004426  9048A0     MOV.B [W0+10], W1
004428  50CF84     SUB.B W1, W4, [W15]
00442A  310010     BRA C, 0x444C
00442C  EB0100     CLR W2
00442E  37000B     BRA 0x4446
004430  E80081     INC W1, W1
004432  784101     MOV.B W1, W2
159:                           byte = strcmp->Get_len; //,
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //
004446  50CF82     SUB.B W1, W2, [W15]
004448  3EFFFA     BRA GTU, 0x443E
00444A  37001F     BRA 0x448A
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
00443E  9001C0     MOV [W0+8], W3
004440  900220     MOV [W0+4], W4
004442  7971E4     MOV.B [W4+W2], [W3+W2]
004444  E80102     INC W2, W2
162:                       } else {//
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//
00444C  FB8202     ZE W2, W4
00444E  FB8183     ZE W3, W3
004450  518184     SUB W3, W4, W3
004452  FB8281     ZE W1, W5
004454  EB4080     CLR.B W1
004456  518F85     SUB W3, W5, [W15]
004458  350007     BRA LT, 0x4468
00445A  370014     BRA 0x4484
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //
004466  E84081     INC.B W1, W1
004468  FB8181     ZE W1, W3
00446A  9042A0     MOV.B [W0+2], W5
00446C  FB8285     ZE W5, W5
00446E  528284     SUB W5, W4, W5
004470  518F85     SUB W3, W5, [W15]
004472  35FFF4     BRA LT, 0x445C
004474  37000A     BRA 0x448A
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
00445C  9002C0     MOV [W0+8], W5
00445E  FB8302     ZE W2, W6
004460  418390     ADD W3, [W0], W7
004462  7B43E7     MOV.B [W7+W6], W7
004464  79F287     MOV.B W7, [W5+W3]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //
004482  E84081     INC.B W1, W1
004484  9049A0     MOV.B [W0+10], W3
004486  50CF83     SUB.B W1, W3, [W15]
004488  36FFF6     BRA LEU, 0x4476
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
004476  FB8181     ZE W1, W3
004478  900240     MOV [W0+8], W4
00447A  FB8282     ZE W2, W5
00447C  418310     ADD W3, [W0], W6
00447E  7AC366     MOV.B [W6+W5], W6
004480  79F206     MOV.B W6, [W4+W3]
169:                       }
170:                       strcmp->Real_len = cnt2; //
00448A  984831     MOV.B W1, [W0+11]
171:                       return true;
00448C  B3C011     MOV.B #0x1, W1
172:                   }
173:                   strcmp->Real_len = 0;
004438  EB4080     CLR.B W1
00443A  984831     MOV.B W1, [W0+11]
174:                   return false;
00443C  370028     BRA 0x448E
175:               }
00448E  784001     MOV.B W1, W0
004490  78044F     MOV [--W15], W8
004492  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 
180:               Input: UARTn
181:               Output: 
182:               Notice256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data) {//, const uint8_t get_size) {//'\0'
004494  BE9F88     MOV.D W8, [W15++]
004496  781F8A     MOV W10, [W15++]
004498  780400     MOV W0, W8
00449A  780501     MOV W1, W10
185:                   uint8_t byte = 0;
00449C  EB4480     CLR.B W9
186:                   while (1) {
187:                       if (f_uart(Get_Data + byte))
00449E  FB8009     ZE W9, W0
0044A0  450000     ADD W10, W0, W0
0044A2  010008     CALL W8
0044A4  E00400     CP0.B W0
0044A6  320002     BRA Z, 0x44AC
188:                           byte++;
0044A8  E84489     INC.B W9, W9
189:                       else
190:                           break;
191:                   }
0044AA  37FFF9     BRA 0x449E
192:                   return byte;
193:               }
0044AC  784009     MOV.B W9, W0
0044AE  78054F     MOV [--W15], W10
0044B0  BE044F     MOV.D [--W15], W8
0044B2  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 
198:               Input: 
199:               Output: 
200:               Notice
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
0044B4  FA0002     LNK #0x2
0044B6  781F88     MOV W8, [W15++]
0044B8  780400     MOV W0, W8
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
0044BA  578064     SUB W15, #0x4, W0
0044BC  010008     CALL W8
0044BE  E00400     CP0.B W0
0044C0  3AFFFC     BRA NZ, 0x44BA
205:               }
0044C2  78044F     MOV [--W15], W8
206:               //UARTGetData
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//505050
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/PCF8583.c  ----------------------------------
1:                 #include <PCF8583.h>
2:                 #include <I2C.h>
3:                 #include "Common.h"
4:                 
5:                 #define PCF_ADD 0xA2//
6:                 #define PCF_CON_STA 0x00//PCF8583
7:                 
8:                 //typedef enum {
9:                 //    con = 0, /* sec_100 = 1, sec = 2, min = 3, hours = 4, year = 5, months = 6, */timer = 7,
10:                //    alarm_con = 8, alarm_reg = 9
11:                //} PCF_Reg;
12:                
13:                void PCF8583_Init(void) {
14:                    TRISBbits.TRISB13 = 1; //RTCC
0044C8  A8A2C9     BSET 0x2C9, #5
15:                
16:                }
0044CA  060000     RETURN
17:                
18:                void PCF8583_SetTime(uint32_t* timestamp) {//1s2s
0044CC  FA001A     LNK #0x1A
0044CE  781F88     MOV W8, [W15++]
19:                    struct tm time_tmp;
20:                    time_tmp = *gmtime((time_t*) timestamp);
0044D0  07E0DE     RCALL 0x68E
0044D2  5780F4     SUB W15, #0x14, W1
0044D4  090008     REPEAT #0x8
0044D6  7818B0     MOV [W0++], [W1++]
0044D8  B10120     SUB #0x12, W0
21:                    uint8_t tmp[8] = {0x85, 00}; // 05
0044DA  57807C     SUB W15, #0x1C, W0
0044DC  090003     REPEAT #0x3
0044DE  EB1800     CLR [W0++]
0044E0  B3C850     MOV.B #0x85, W0
0044E2  9FE7C0     MOV.B W0, [W15-28]
22:                    tmp[2] = DCH(time_tmp.tm_sec);
0044E4  97E84F     MOV.B [W15-20], W0
0044E6  0702BC     RCALL DCH
0044E8  9FE7E0     MOV.B W0, [W15-26]
23:                    tmp[3] = DCH(time_tmp.tm_min);
0044EA  97E86F     MOV.B [W15-18], W0
0044EC  0702B9     RCALL DCH
0044EE  9FE7F0     MOV.B W0, [W15-25]
24:                    tmp[4] = DCH(time_tmp.tm_hour) & 0x3F;
0044F0  97F00F     MOV.B [W15-16], W0
0044F2  0702B6     RCALL DCH
0044F4  B243F0     AND.B #0x3F, W0
0044F6  9FEF80     MOV.B W0, [W15-24]
25:                    tmp[5] = (GetMod(time_tmp.tm_year + 1900, 2) << 6) + (DCH(time_tmp.tm_mday) & 0x3F);
0044F8  2076C0     MOV #0x76C, W0
0044FA  97B8BF     MOV [W15-10], W1
0044FC  408000     ADD W1, W0, W0
0044FE  B3C021     MOV.B #0x2, W1
004500  0702FD     RCALL GetMod
004502  784400     MOV.B W0, W8
004504  97F02F     MOV.B [W15-14], W0
004506  0702AC     RCALL DCH
004508  B243F0     AND.B #0x3F, W0
00450A  200061     MOV #0x6, W1
00450C  DD4401     SL W8, W1, W8
00450E  404408     ADD.B W0, W8, W8
004510  9FEF98     MOV.B W8, [W15-23]
26:                    tmp[6] = (DCH(time_tmp.tm_wday) << 5)+(DCH(time_tmp.tm_mon + 1) & 0x1F); //tm10
004512  97F80F     MOV.B [W15-8], W0
004514  0702A5     RCALL DCH
004516  97B82F     MOV [W15-12], W0
004518  E84000     INC.B W0, W0
00451A  0702A2     RCALL DCH
27:                    tmp[7] = 0; //
28:                    //    tmp[8] = 0xB0; //0x90; //
29:                    //    tmp[9] = 00; //
30:                    //    tmp[10] = 4; //GetMod(alarmtime, 30); //
31:                    //    tmp[11] = 0; //GetMod(alarmtime / 30, 60); //
32:                    //    tmp[12] = 0; //GetMod(alarmtime / 1800, 60); //
33:                    //    tmp[13] = tmp[14] = 0; //=0
34:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};    
35:                    i2c1_state = S_MASTER_IDLE;//123
00451C  EF6844     CLR.B i2c1_state
36:                    i2c_buf.operatcode = PCF_ADD;
00451E  B3CA21     MOV.B #0xA2, W1
004520  21C3E0     MOV #0x1C3E, W0
004522  784801     MOV.B W1, [W0]
37:                    i2c_buf.address = PCF_CON_STA;
004524  E88000     INC2 W0, W0
004526  EB0800     CLR [W0]
38:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
004528  B3C081     MOV.B #0x8, W1
00452A  E88000     INC2 W0, W0
00452C  784801     MOV.B W1, [W0]
39:                    i2c_buf.pbuffer = tmp;
00452E  5780FC     SUB W15, #0x1C, W1
004530  88E221     MOV W1, 0x1C44
40:                    i2c_buf.flag.F_IsSelectiveMode = 1;
004532  80E230     MOV 0x1C46, W0
004534  A00000     BSET W0, #0
41:                    i2c_buf.flag.F_WriteOrRead = 0;
004536  A12000     BCLR W0, #2
42:                    i2c_buf.flag.F_Is16bitsDevice = 0;
004538  A11000     BCLR W0, #1
00453A  88E230     MOV W0, 0x1C46
43:                    IFS1bits.MI2C1IF = 1;
00453C  A82086     BSET IFS1, #1
44:                
45:                    while (i2c1_state != S_MASTER_Finish); //
00453E  BFC844     MOV.B i2c1_state, WREG
004540  504FED     SUB.B W0, #0xD, [W15]
004542  3AFFFD     BRA NZ, 0x453E
46:                    //    while (IFS1bits.MI2C1IF);
47:                    //    while (i2c1_state != S_MASTER_IDLE);
48:                }
004544  78044F     MOV [--W15], W8
004546  FA8000     ULNK
004548  060000     RETURN
49:                
50:                void PCF8583_SetAlarmTime(struct tm alarmtime) {
00454A  FA0008     LNK #0x8
51:                    uint8_t tmp[7] = {0x90, 00}; //cat24c512 0xA8 05
00454C  578068     SUB W15, #0x8, W0
00454E  090002     REPEAT #0x2
004550  EB1800     CLR [W0++]
004552  EB5800     CLR.B [W0++]
004554  B3C900     MOV.B #0x90, W0
004556  9FFF80     MOV.B W0, [W15-8]
52:                    //    tmp[8] = 0xB0; //0x90; //
53:                    //    tmp[9] = 00; //
54:                    tmp[2] = DCH(alarmtime.tm_sec); //GetMod(alarmtime, 30); //
004558  97E00F     MOV.B [W15-32], W0
00455A  070282     RCALL DCH
00455C  9FFFA0     MOV.B W0, [W15-6]
55:                    tmp[3] = DCH(alarmtime.tm_min); //GetMod(alarmtime / 30, 60); //
00455E  97E02F     MOV.B [W15-30], W0
004560  07027F     RCALL DCH
004562  9FFFB0     MOV.B W0, [W15-5]
56:                    tmp[4] = DCH(alarmtime.tm_hour); //GetMod(alarmtime / 1800, 60); //
004564  97E04F     MOV.B [W15-28], W0
004566  07027C     RCALL DCH
57:                    tmp[5] = tmp[6] = 0; //=0
58:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};
59:                    i2c_buf.operatcode = PCF_ADD;
004568  B3CA21     MOV.B #0xA2, W1
00456A  21C3E0     MOV #0x1C3E, W0
00456C  784801     MOV.B W1, [W0]
60:                    i2c_buf.address = PCF_CON_STA + 8;
00456E  200080     MOV #0x8, W0
004570  88E200     MOV W0, 0x1C40
61:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
004572  B3C071     MOV.B #0x7, W1
004574  21C420     MOV #0x1C42, W0
004576  784801     MOV.B W1, [W0]
62:                    i2c_buf.pbuffer = tmp;
004578  578068     SUB W15, #0x8, W0
00457A  88E220     MOV W0, 0x1C44
63:                    i2c_buf.flag.F_IsSelectiveMode = 1;
00457C  80E230     MOV 0x1C46, W0
00457E  A00000     BSET W0, #0
64:                    i2c_buf.flag.F_WriteOrRead = 0;
004580  A12000     BCLR W0, #2
65:                    i2c_buf.flag.F_Is16bitsDevice = 0;
004582  A11000     BCLR W0, #1
004584  88E230     MOV W0, 0x1C46
66:                    i2c1_state = S_MASTER_IDLE;
004586  EF6844     CLR.B i2c1_state
67:                    IFS1bits.MI2C1IF = 1;
004588  A82086     BSET IFS1, #1
68:                
69:                    while (i2c1_state != S_MASTER_Finish); //
00458A  BFC844     MOV.B i2c1_state, WREG
00458C  504FED     SUB.B W0, #0xD, [W15]
00458E  3AFFFD     BRA NZ, 0x458A
70:                }
004590  FA8000     ULNK
004592  060000     RETURN
71:                
72:                uint32_t PCF8583_ReadTime(void) {
004594  FA0018     LNK #0x18
73:                    struct tm time_tmp; //timestamp
74:                
75:                    uint8_t tmp[5] = {0x03, 00}; //cat24c512 0xA8 
004596  578078     SUB W15, #0x18, W0
004598  090001     REPEAT #0x1
00459A  EB1800     CLR [W0++]
00459C  EB5800     CLR.B [W0++]
00459E  B3C030     MOV.B #0x3, W0
0045A0  9FEF80     MOV.B W0, [W15-24]
76:                    i2c_buf.operatcode = PCF_ADD;
0045A2  B3CA21     MOV.B #0xA2, W1
0045A4  21C3E0     MOV #0x1C3E, W0
0045A6  784801     MOV.B W1, [W0]
77:                    i2c_buf.address = PCF_CON_STA + 2; //
0045A8  200020     MOV #0x2, W0
0045AA  88E200     MOV W0, 0x1C40
78:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
0045AC  B3C051     MOV.B #0x5, W1
0045AE  21C420     MOV #0x1C42, W0
0045B0  784801     MOV.B W1, [W0]
79:                    i2c_buf.pbuffer = tmp;
0045B2  578078     SUB W15, #0x18, W0
0045B4  88E220     MOV W0, 0x1C44
80:                    i2c_buf.flag.F_IsSelectiveMode = 1;
0045B6  80E230     MOV 0x1C46, W0
81:                    i2c_buf.flag.F_WriteOrRead = 1;
0045B8  B30050     IOR #0x5, W0
82:                    i2c_buf.flag.F_Is16bitsDevice = 0;
0045BA  A11000     BCLR W0, #1
0045BC  88E230     MOV W0, 0x1C46
83:                    i2c1_state = S_MASTER_IDLE;
0045BE  EF6844     CLR.B i2c1_state
84:                    IFS1bits.MI2C1IF = 1;
0045C0  A82086     BSET IFS1, #1
85:                    while (i2c1_state != S_MASTER_Finish); //
0045C2  BFC844     MOV.B i2c1_state, WREG
0045C4  504FED     SUB.B W0, #0xD, [W15]
0045C6  3AFFFD     BRA NZ, 0x45C2
86:                
87:                    time_tmp.tm_sec = HCD(tmp[0]); //
0045C8  B3C030     MOV.B #0x3, W0
0045CA  070244     RCALL HCD
0045CC  FB8000     ZE W0, W0
0045CE  9FB7F0     MOV W0, [W15-18]
88:                    time_tmp.tm_min = HCD(tmp[1]); //
0045D0  97E81F     MOV.B [W15-23], W0
0045D2  070240     RCALL HCD
0045D4  FB8000     ZE W0, W0
0045D6  9FBF80     MOV W0, [W15-16]
89:                    time_tmp.tm_hour = HCD(tmp[2]&0x3F); //
0045D8  97E82F     MOV.B [W15-22], W0
0045DA  B243F0     AND.B #0x3F, W0
0045DC  07023B     RCALL HCD
0045DE  FB8000     ZE W0, W0
0045E0  9FBF90     MOV W0, [W15-14]
90:                    time_tmp.tm_mday = HCD(tmp[3]&0x3F); //
0045E2  97E83F     MOV.B [W15-21], W0
0045E4  B243F0     AND.B #0x3F, W0
0045E6  070236     RCALL HCD
0045E8  FB8000     ZE W0, W0
0045EA  9FBFA0     MOV W0, [W15-12]
91:                    time_tmp.tm_mon = HCD(tmp[4]&0x1F) - 1; //
0045EC  97E84F     MOV.B [W15-20], W0
0045EE  60407F     AND.B W0, #0x1F, W0
0045F0  070231     RCALL HCD
0045F2  FB8000     ZE W0, W0
0045F4  E90000     DEC W0, W0
0045F6  9FBFB0     MOV W0, [W15-10]
92:                    time_tmp.tm_year = (uint16_t) (tmp[3] >> 6) + 2016 - 1900; //2016E2ROM
0045F8  97E83F     MOV.B [W15-21], W0
0045FA  FB8000     ZE W0, W0
0045FC  DE0046     LSR W0, #6, W0
0045FE  B00740     ADD #0x74, W0
004600  9FBFC0     MOV W0, [W15-8]
93:                
94:                    return mktime(&time_tmp);
004602  578072     SUB W15, #0x12, W0
004604  07E048     RCALL 0x696
95:                }
004606  FA8000     ULNK
004608  060000     RETURN
96:                
97:                void PCF8583_SetStatusReg(uint8_t reg) {//
00460A  FA0002     LNK #0x2
00460C  9FFFE0     MOV.B W0, [W15-2]
98:                    //    uint8_t tmp = 0x05; // 05
99:                    i2c_buf.operatcode = PCF_ADD;
00460E  B3CA21     MOV.B #0xA2, W1
004610  21C3E0     MOV #0x1C3E, W0
004612  784801     MOV.B W1, [W0]
100:                   i2c_buf.address = PCF_CON_STA;
004614  E88000     INC2 W0, W0
004616  EB0800     CLR [W0]
101:                   i2c_buf.length = 1;
004618  B3C011     MOV.B #0x1, W1
00461A  E88000     INC2 W0, W0
00461C  784801     MOV.B W1, [W0]
102:                   i2c_buf.pbuffer = &reg;
00461E  E9800F     DEC2 W15, W0
004620  88E220     MOV W0, 0x1C44
103:                   i2c_buf.flag.F_IsSelectiveMode = 1;
004622  80E230     MOV 0x1C46, W0
004624  A00000     BSET W0, #0
104:                   i2c_buf.flag.F_WriteOrRead = 0;
004626  A12000     BCLR W0, #2
105:                   i2c_buf.flag.F_Is16bitsDevice = 0;
004628  A11000     BCLR W0, #1
00462A  88E230     MOV W0, 0x1C46
106:                   i2c1_state = S_MASTER_IDLE;
00462C  EF6844     CLR.B i2c1_state
107:                   IFS1bits.MI2C1IF = 1;
00462E  A82086     BSET IFS1, #1
108:                   while (i2c1_state != S_MASTER_Finish); //
004630  BFC844     MOV.B i2c1_state, WREG
004632  504FED     SUB.B W0, #0xD, [W15]
004634  3AFFFD     BRA NZ, 0x4630
109:               }
004636  FA8000     ULNK
004638  060000     RETURN
110:               
111:               void PCF8583_ReadStatus(uint8_t *tmp) {
112:                   //    struct tm time_tmp; //timestamp
113:               
114:                   //    uint8_t tmp[16] = {0x03, 00}; //cat24c512 0xA8 
115:                   i2c_buf.operatcode = PCF_ADD;
00463A  B3CA22     MOV.B #0xA2, W2
00463C  21C3E1     MOV #0x1C3E, W1
00463E  784882     MOV.B W2, [W1]
116:                   i2c_buf.address = PCF_CON_STA; //
004640  E88081     INC2 W1, W1
004642  EB0880     CLR [W1]
117:                   i2c_buf.length = 16;
004644  B3C102     MOV.B #0x10, W2
004646  E88081     INC2 W1, W1
004648  784882     MOV.B W2, [W1]
118:                   i2c_buf.pbuffer = tmp;
00464A  88E220     MOV W0, 0x1C44
119:                   i2c_buf.flag.F_IsSelectiveMode = 1;
00464C  80E230     MOV 0x1C46, W0
120:                   i2c_buf.flag.F_WriteOrRead = 1;
00464E  B30050     IOR #0x5, W0
121:                   i2c_buf.flag.F_Is16bitsDevice = 0;
004650  A11000     BCLR W0, #1
004652  88E230     MOV W0, 0x1C46
122:                   i2c1_state = S_MASTER_IDLE;
004654  EF6844     CLR.B i2c1_state
123:                   IFS1bits.MI2C1IF = 1;
004656  A82086     BSET IFS1, #1
124:                   while (i2c1_state != S_MASTER_Finish); //
004658  BFC844     MOV.B i2c1_state, WREG
00465A  504FED     SUB.B W0, #0xD, [W15]
00465C  3AFFFD     BRA NZ, 0x4658
125:               
126:                   //    time_tmp.tm_sec = HCD(tmp[0]); //
127:                   //    time_tmp.tm_min = HCD(tmp[1]); //
128:                   //    time_tmp.tm_hour = HCD(tmp[2]&0x3F); //
129:                   //    time_tmp.tm_mday = HCD(tmp[3]&0x3F); //
130:                   //    time_tmp.tm_mon = HCD(tmp[4]&0x1F) - 1; //
131:                   //    time_tmp.tm_year = (uint16_t) (tmp[3] >> 6) + 2016 - 1900; //2016E2ROM
132:               
133:                   //    return mktime(&time_tmp);
134:               }
00465E  060000     RETURN
135:               
136:               //void PCF8583_CelarFlag(void) {
137:               //    uint8_t tmp = 0x05; // 05
138:               //    i2c_buf.operatcode = PCF_ADD;
139:               //    i2c_buf.address = PCF_CON_STA;
140:               //    i2c_buf.length = 1;
141:               //    i2c_buf.pbuffer = &tmp;
142:               //    i2c_buf.flag.F_IsSelectiveMode = 1;
143:               //    i2c_buf.flag.F_WriteOrRead = 0;
144:               //    i2c_buf.flag.F_Is16bitsDevice = 0;
145:               //    i2c1_state = S_MASTER_IDLE;
146:               //    IFS1bits.MI2C1IF = 1;
147:               //    while (i2c1_state != S_MASTER_Finish); //
148:               //}
149:               
150:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/PC.c  ---------------------------------------
1:                 //#include "pc.h"
2:                 #include "includes.h"
3:                 
4:                 void PCCop_Init(void)
5:                 {
6:                     RS485_Init();
0051D6  37FEF8     BRA RS485_Init
7:                 }
8:                 
9:                 
10:                void PCCopTask(void*arg) {
11:                
12:                    while (1) {
13:                        RS485SendChar(0x31);
0051D8  B3C310     MOV.B #0x31, W0
0051DA  07FF03     RCALL RS485SendChar
14:                        //        RS485SendString("ErrCode:\r\n", 10);
15:                        OSTimeDlyHMSM(0, 0, 1, 0);
0051DC  EB0180     CLR W3
16:                    }
17:                }
18:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/HL6528.c  -----------------------------------
1:                 #include "HL6528.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 //#include <stdlib.h>
5:                 //#include "includes.h"
6:                 //#include <stdbool.h>
7:                 //#include "cJSON.h"
8:                 
9:                 
10:                //extern OS_EVENT* sem1, *sem2; //
11:                
12:                //struct ATCommand {
13:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
14:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
15:                const uint8_t AT[] = {"AT\r\n"};
16:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
17:                const uint8_t OK[] = {"OK"};
18:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
19:                const uint8_t READY[] = {"+CPIN: READY"};
20:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
21:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
22:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
23:                const uint8_t _5[] = {",5"};
24:                const uint8_t _1[] = {",1"};
25:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
26:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
27:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
28:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
29:                static uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
30:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
31:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//ONENET
32:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
33:                const uint8_t CONNECT[] = {"CONNECT"};
34:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
35:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
36:                //} ATCmd;
37:                
38:                //struct AT_Arg {
39:                //    //    uint8_t KCNXCFG[] = {"AT+KCNXCFG,\"GPRS\",\"CMNET\"\r\n"};
40:                //    uint8_t time; //
41:                //    uint8_t count; //
42:                //    uint8_t *sendstr; //
43:                //    uint8_t sendstrlen; //
44:                //    uint8_t *checkstr; //
45:                //    uint8_t checkstrlen; //
46:                //    uint8_t errcode; //
47:                //};
48:                
49:                //
50:                
51:                static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
52:                //static void HL6528_IOStart(void);
53:                //static void HL6528_IOClose(void);
54:                static void HL6528_GetIP_Port(void);
55:                
56:                void HL6528_Init(void) {
57:                    //
58:                    PWRON_TRIS = 0; //PWN_ON 6528
004044  A9C2D8     BCLR TRISD, #6
59:                    PWR_TRIS = 0; //6528
004046  A9E2D8     BCLR TRISD, #7
60:                    DSR_TRIS = 0; //    
004048  A922D8     BCLR TRISD, #1
61:                    DTR_TRIS = 0; //
00404A  A902D8     BCLR TRISD, #0
62:                    RTS_TRIS = 0; //
00404C  A982D8     BCLR TRISD, #4
63:                    CTS_TRIS = 0; //  
00404E  A9A2D8     BCLR TRISD, #5
64:                    PWR = 0;
004050  A9E2DC     BCLR LATD, #7
65:                    PWRON = 0;
004052  A9C2DC     BCLR LATD, #6
66:                    CTS = 0;
004054  A9A2DC     BCLR LATD, #5
67:                    RTS = 0;
004056  A982DC     BCLR LATD, #4
68:                    DSR = 0;
004058  A922DC     BCLR LATD, #1
69:                    DTR = 0;
00405A  A902DC     BCLR LATD, #0
70:                    //    UART2_Init();
71:                }
00405C  060000     RETURN
72:                
73:                bool HL6528_DialingIsERR(void) {
74:                    uint8_t sta; //, cnt, cnt1, IP_bytes, Port_bytes;
75:                    //    uint8_t str_tmp[50]; // [4]='\0'
76:                    //
77:                    //    HL6528_GetIP_Port(str_tmp);
78:                    PWR = 1;
00405E  A8E2DC     BSET LATD, #7
79:                    PWRON = 1;
004060  A8C2DC     BSET LATD, #6
80:                    CTS = 0;
004062  A9A2DC     BCLR LATD, #5
81:                    RTS = 0;
004064  A982DC     BCLR LATD, #4
82:                    DSR = 0;
004066  A922DC     BCLR LATD, #1
83:                    DTR = 0;
004068  A902DC     BCLR LATD, #0
84:                    OSTimeDlyHMSM(0, 0, 1, 0);
00406A  EB0180     CLR W3
00406C  200012     MOV #0x1, W2
00406E  B80060     MUL.UU W0, #0, W0
004070  070587     RCALL OSTimeDlyHMSM
85:                    if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
004072  B3C024     MOV.B #0x2, W4
004074  784184     MOV.B W4, W3
004076  EB0100     CLR W2
004078  29C071     MOV #0x9C07, W1
00407A  29BEE0     MOV #0x9BEE, W0
00407C  07FF75     RCALL _HL6528SendCmd
004080  E00400     CP0.B W0
004082  32002E     BRA Z, 0x40E0
86:                        if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
004084  B3C024     MOV.B #0x2, W4
004086  B3C083     MOV.B #0x8, W3
004088  EB0100     CLR W2
00408A  29C151     MOV #0x9C15, W1
00408C  29C0A0     MOV #0x9C0A, W0
00408E  07FF6C     RCALL _HL6528SendCmd
004092  E00400     CP0.B W0
004094  320025     BRA Z, 0x40E0
87:                            if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//
004096  B3C0A4     MOV.B #0xA, W4
004098  29C462     MOV #0x9C46, W2
00409A  29C431     MOV #0x9C43, W1
00409C  29C2C0     MOV #0x9C2C, W0
00409E  07FF64     RCALL _HL6528SendCmd
0040A2  E00400     CP0.B W0
0040A4  32001D     BRA Z, 0x40E0
88:                                if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
0040A6  784203     MOV.B W3, W4
0040A8  B3C023     MOV.B #0x2, W3
0040AA  EB0100     CLR W2
0040AC  29C071     MOV #0x9C07, W1
0040AE  29C530     MOV #0x9C53, W0
0040B0  07FF5B     RCALL _HL6528SendCmd
0040B4  E00400     CP0.B W0
0040B6  320014     BRA Z, 0x40E0
89:                                    HL6528_GetIP_Port();//IP
0040B8  07FF92     RCALL _HL6528_GetIP_Port
90:                                    if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
0040BA  B3C034     MOV.B #0x3, W4
0040BC  B3C023     MOV.B #0x2, W3
0040BE  EB0100     CLR W2
0040C0  29C071     MOV #0x9C07, W1
0040C2  21BCA0     MOV #0x1BCA, W0
0040C4  07FF51     RCALL _HL6528SendCmd
0040C8  E00400     CP0.B W0
0040CA  32000A     BRA Z, 0x40E0
91:                                        if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 7, 5)) {
0040CC  784203     MOV.B W3, W4
0040CE  B3C073     MOV.B #0x7, W3
0040D0  EB0100     CLR W2
0040D2  29CAF1     MOV #0x9CAF, W1
0040D4  29C9E0     MOV #0x9C9E, W0
0040D6  07FF48     RCALL _HL6528SendCmd
0040DA  E00400     CP0.B W0
0040DC  320001     BRA Z, 0x40E0
92:                                            sta = 0;
0040DE  EB4180     CLR.B W3
93:                                        } else
94:                                            sta = 6; //TCP
0040D8  B3C063     MOV.B #0x6, W3
95:                                    } else
96:                                        sta = 5; //TCP
0040C6  B3C053     MOV.B #0x5, W3
97:                                } else
98:                                    sta = 4; //APN
0040B2  B3C043     MOV.B #0x4, W3
99:                            } else
100:                               sta = 3; //
0040A0  B3C033     MOV.B #0x3, W3
101:                       } else
102:                           sta = 2; //
004090  B3C023     MOV.B #0x2, W3
103:                   } else
104:                       sta = 1; //
00407E  B3C013     MOV.B #0x1, W3
105:                   return sta;
0040E0  FB8003     ZE W3, W0
0040E2  EA0000     NEG W0, W0
0040E4  DE004F     LSR W0, #15, W0
106:               }
0040E6  060000     RETURN
107:               
108:               void HL6528_Close(void) {
0040E8  FA0020     LNK #0x20
0040EA  BE9F88     MOV.D W8, [W15++]
109:                   uint8_t tmp[20];
110:                   StrCmp stcp;
111:                   ClearBuffer(BufferRead_UART2);
0040EC  243A40     MOV #0x43A4, W0
0040EE  0701E2     RCALL ClearBuffer
112:                   do {
113:                       DSR = 1; //AT
0040F0  A822DC     BSET LATD, #1
114:                       OSTimeDlyHMSM(0, 0, 1, 0); //1s
0040F2  EB0180     CLR W3
0040F4  200012     MOV #0x1, W2
0040F6  B80060     MUL.UU W0, #0, W0
0040F8  070543     RCALL OSTimeDlyHMSM
115:                       DSR = 0; //
0040FA  A922DC     BCLR LATD, #1
116:                       stcp.SourceData = tmp;
0040FC  578078     SUB W15, #0x18, W0
0040FE  9FAFE0     MOV W0, [W15-36]
117:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //mark
004100  780080     MOV W0, W1
004102  243A40     MOV #0x43A4, W0
004104  0701C7     RCALL UARTGetData
004106  9FDFE0     MOV.B W0, [W15-34]
118:                       stcp.CheckData = (uint8_t*) OK;
004108  29C079     MOV #0x9C07, W9
00410A  9FB789     MOV W9, [W15-32]
119:                       stcp.Check_len = 2;
00410C  B3C028     MOV.B #0x2, W8
00410E  9FE7A8     MOV.B W8, [W15-30]
120:                       stcp.GetData = NULL;
004110  EB0000     CLR W0
004112  9FB7A0     MOV W0, [W15-28]
121:                       stcp.Get_len = 0;
004114  9FE7E0     MOV.B W0, [W15-26]
122:                       stcp.Real_len = 0;
004116  9FE7F0     MOV.B W0, [W15-25]
123:                   } while (UARTDataIsRight(&stcp)); //OK
004118  2FFDC0     MOV #0xFFDC, W0
00411A  40000F     ADD W0, W15, W0
00411C  070169     RCALL UARTDataIsRight
00411E  E00400     CP0.B W0
004120  3AFFE7     BRA NZ, 0x40F0
124:                   if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//TCPID
004122  784208     MOV.B W8, W4
004124  784188     MOV.B W8, W3
004126  EB0100     CLR W2
004128  780089     MOV W9, W1
00412A  29CB70     MOV #0x9CB7, W0
00412C  07FF1D     RCALL _HL6528SendCmd
00412E  E00400     CP0.B W0
004130  320006     BRA Z, 0x413E
125:                       HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
004132  784208     MOV.B W8, W4
004134  784184     MOV.B W4, W3
004136  EB0100     CLR W2
004138  780089     MOV W9, W1
00413A  29CCA0     MOV #0x9CCA, W0
00413C  07FF15     RCALL _HL6528SendCmd
126:                   OSTimeDlyHMSM(0, 0, 1, 0); //1s    
00413E  EB0180     CLR W3
004140  200012     MOV #0x1, W2
004142  B80060     MUL.UU W0, #0, W0
004144  07051D     RCALL OSTimeDlyHMSM
127:                   PWR = 0; //
004146  A9E2DC     BCLR LATD, #7
128:                   PWRON = 0; //
004148  A9C2DC     BCLR LATD, #6
129:                   CTS = 0; //
00414A  A9A2DC     BCLR LATD, #5
130:                   RTS = 0; //
00414C  A982DC     BCLR LATD, #4
131:                   DSR = 0; //
00414E  A922DC     BCLR LATD, #1
132:                   DTR = 0; //
004150  A902DC     BCLR LATD, #0
133:                   UART2_Close();
004152  07067F     RCALL UART2_Close
134:               }
004154  BE044F     MOV.D [--W15], W8
135:               
136:               /*ss**/
137:               static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
003F68  FA003E     LNK #0x3E
003F6A  BE9F88     MOV.D W8, [W15++]
003F6C  BE9F8A     MOV.D W10, [W15++]
003F6E  BE9F8C     MOV.D W12, [W15++]
003F70  780580     MOV W0, W11
003F72  780501     MOV W1, W10
003F74  780402     MOV W2, W8
003F76  784483     MOV.B W3, W9
003F78  784684     MOV.B W4, W13
138:                   uint8_t cnt_tmp = 0;
003F7A  EB4600     CLR.B W12
139:                   bool b_sta = false;
003FC8  EB4400     CLR.B W8
003FCA  370001     BRA 0x3FCE
140:                   StrCmp stcp;
141:                   uint8_t tmp[50];
142:                   do {
143:                       cnt_tmp += 1;
003FC2  E8460C     INC.B W12, W12
144:                       UART2_SendString(ss); //AT                               
003F7C  78000B     MOV W11, W0
003F7E  070772     RCALL UART2_SendString
145:                       OSTimeDlyHMSM(0, 0, 3, 0); //1s
003F80  EB0180     CLR W3
003F82  200032     MOV #0x3, W2
003F84  B80060     MUL.UU W0, #0, W0
003F86  0705FC     RCALL OSTimeDlyHMSM
146:                       U2Rx4Byte();
003F88  070790     RCALL U2Rx4Byte
147:                       stcp.SourceData = tmp;
003F8A  2FFB60     MOV #0xFFB6, W0
003F8C  40000F     ADD W0, W15, W0
003F8E  40006C     ADD W0, #0xC, W0
003F90  9F9FB0     MOV W0, [W15-74]
148:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //mark
003F92  2FFC21     MOV #0xFFC2, W1
003F94  40808F     ADD W1, W15, W1
003F96  243A40     MOV #0x43A4, W0
003F98  07027D     RCALL UARTGetData
003F9A  9F7F80     MOV.B W0, [W15-72]
149:                       stcp.CheckData = (uint8_t*) cs;
003F9C  9F9FDA     MOV W10, [W15-70]
150:                       stcp.Check_len = csl;
003F9E  9F7FC9     MOV.B W9, [W15-68]
151:                       stcp.GetData = NULL;
003FA0  EB0000     CLR W0
003FA2  9F9FF0     MOV W0, [W15-66]
152:                       stcp.Get_len = 0;
003FA4  9FC780     MOV.B W0, [W15-64]
153:                       stcp.Real_len = 0;
003FA6  9FC790     MOV.B W0, [W15-63]
154:               
155:                       if (UARTDataIsRight(&stcp)) {
003FA8  2FFB60     MOV #0xFFB6, W0
003FAA  40000F     ADD W0, W15, W0
003FAC  070221     RCALL UARTDataIsRight
003FAE  E00400     CP0.B W0
003FB0  3A000D     BRA NZ, 0x3FCC
156:                           b_sta = true;
157:                           break;
158:                       }
159:               
160:                       if (cs1 != NULL) {//NULL
003FB2  E00008     CP0 W8
003FB4  320006     BRA Z, 0x3FC2
161:                           stcp.CheckData = (uint8_t*) cs1;
003FB6  9F9FD8     MOV W8, [W15-70]
162:                           if (UARTDataIsRight(&stcp)) {
003FB8  2FFB60     MOV #0xFFB6, W0
003FBA  40000F     ADD W0, W15, W0
003FBC  070219     RCALL UARTDataIsRight
003FBE  E00400     CP0.B W0
003FC0  3A0005     BRA NZ, 0x3FCC
163:                               b_sta = true;
003FCC  B3C018     MOV.B #0x1, W8
164:                               break;
165:                           }
166:                       }
167:               
168:                   } while (cnt > cnt_tmp);
003FC4  56CF8C     SUB.B W13, W12, [W15]
003FC6  3EFFDA     BRA GTU, 0x3F7C
169:                   ClearBuffer(BufferRead_UART2);
003FCE  243A40     MOV #0x43A4, W0
003FD0  070271     RCALL ClearBuffer
170:                   return b_sta;
171:               }
003FD2  784008     MOV.B W8, W0
003FD4  BE064F     MOV.D [--W15], W12
003FD6  BE054F     MOV.D [--W15], W10
003FD8  BE044F     MOV.D [--W15], W8
003FDA  FA8000     ULNK
003FDC  060000     RETURN
172:               
173:               //static void HL6528_IOStart(void) {
174:               //    PWR = 1;
175:               //    PWRON = 1;
176:               //    CTS = 0;
177:               //    RTS = 0;
178:               //    DSR = 0;
179:               //    DTR = 0;
180:               //}
181:               //
182:               //static void HL6528_IOClose(void) {
183:               //    PWRON = 0;
184:               //    PWR = 0;
185:               //    CTS = 1;
186:               //    RTS = 1;
187:               //    DSR = 1;
188:               //    DTR = 1;
189:               //}
190:               
191:               static void HL6528_GetIP_Port(void) {
003FDE  FA00AC     LNK #0xAC
003FE0  BE9F88     MOV.D W8, [W15++]
003FE2  BE9F8A     MOV.D W10, [W15++]
192:                   struct WGC_ARG arg_tmp;
193:                   uint8_t str_tmp[5]; //
194:                   uint8_t IP_bytes, Port_bytes;
195:                   //    uint8_t *ptr_tmp = dat;
196:               
197:                   WGC_Get_Arg(&arg_tmp); //WGC
003FE4  2FF520     MOV #0xFF52, W0
003FE6  40000F     ADD W0, W15, W0
003FE8  070901     RCALL WGC_Get_Arg
198:                   IP_bytes = strlen(arg_tmp.Net_arg.IP_Addr); //WGCIP
003FEA  2FF520     MOV #0xFF52, W0
003FEC  40000F     ADD W0, W15, W0
003FEE  40047A     ADD W0, #0x1A, W8
003FF0  780008     MOV W8, W0
003FF2  07E3DD     RCALL 0x7AE
003FF4  780580     MOV W0, W11
199:                   Port_bytes = my_itoa(arg_tmp.Net_arg.Port, str_tmp); //port
003FF6  2FF4C1     MOV #0xFF4C, W1
003FF8  40808F     ADD W1, W15, W1
003FFA  97800F     MOV [W15-128], W0
003FFC  070584     RCALL my_itoa
003FFE  784500     MOV.B W0, W10
200:                   CopyDat(KTCPCFG1, KTCPCFG, 16);
004000  B3C102     MOV.B #0x10, W2
004002  29C711     MOV #0x9C71, W1
004004  21BCA0     MOV #0x1BCA, W0
004006  070562     RCALL CopyDat
201:                   CopyDat(KTCPCFG1 + 16, (const uint8_t*) arg_tmp.Net_arg.IP_Addr, IP_bytes);
004008  78410B     MOV.B W11, W2
00400A  780088     MOV W8, W1
00400C  21BDA0     MOV #0x1BDA, W0
00400E  07055E     RCALL CopyDat
202:                   *(KTCPCFG1 + IP_bytes + 16) = '\"';
004010  FB848B     ZE W11, W9
004012  21BCA8     MOV #0x1BCA, W8
004014  440009     ADD W8, W9, W0
004016  B3C221     MOV.B #0x22, W1
004018  985001     MOV.B W1, [W0+16]
203:                   *(KTCPCFG1 + IP_bytes + 17) = ',';
00401A  40C0EA     ADD.B W1, #0xA, W1
00401C  985011     MOV.B W1, [W0+17]
204:                   CopyDat(KTCPCFG1 + IP_bytes + 18, (const uint8_t*) str_tmp, Port_bytes);
00401E  448072     ADD W9, #0x12, W0
004020  400008     ADD W0, W8, W0
004022  78410A     MOV.B W10, W2
004024  2FF4C1     MOV #0xFF4C, W1
004026  40808F     ADD W1, W15, W1
004028  070551     RCALL CopyDat
205:                   //    for (cnt = 0; cnt < IP_bytes; cnt++)
206:                   //        *(dat + cnt) = *(arg_tmp.Net_arg.IP_Addr + cnt);
207:                   //    for (cnt = 0; cnt < Port_bytes; cnt++)
208:                   //        *(dat + cnt) = *(str_tmp + cnt);
209:                   *(KTCPCFG1 + IP_bytes + Port_bytes + 18) = '\r';
00402A  FB850A     ZE W10, W10
00402C  44848A     ADD W9, W10, W9
00402E  440409     ADD W8, W9, W8
004030  B3C0D0     MOV.B #0xD, W0
004032  985420     MOV.B W0, [W8+18]
210:                   *(KTCPCFG1 + IP_bytes + Port_bytes + 19) = '\n';
004034  B3C0A0     MOV.B #0xA, W0
004036  985430     MOV.B W0, [W8+19]
211:                   *(KTCPCFG1 + IP_bytes + Port_bytes + 20) = '\0';
004038  EB4000     CLR.B W0
00403A  985440     MOV.B W0, [W8+20]
212:                   //                    *(ptr_tmp + cnt + 3) = '\0'; 
213:               }
00403C  BE054F     MOV.D [--W15], W10
00403E  BE044F     MOV.D [--W15], W8
004040  FA8000     ULNK
004042  060000     RETURN
214:               
215:               
216:               
217:               
218:               
219:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/E41.c  --------------------------------------
1:                 #include "E41.h"
2:                 
3:                 #define M0_TRIS TRISEbits.TRISE5
4:                 #define M1_TRIS TRISEbits.TRISE6
5:                 #define M0 LATEbits.LATE5
6:                 #define M1 LATEbits.LATE6
7:                 #define M0_PORT PORTEbits.RE5
8:                 #define M1_PORT PORTEbits.RE6
9:                 #define AUX PORTFbits.RF6
10:                
11:                #define WORK 0
12:                #define WAKE 1
13:                #define LOWPOWER 2
14:                #define SLEEP 3
15:                uint8_t E41_Arg[] = {0xC0, 0xff, 0xff, 0x18, 0x1, 0xfc};
16:                // FF FF 18 01 9C
17:                //static ADDBITS E41_ADD;
18:                //static ARG1BITS E41_ARG1;
19:                //static ARG2BITS E41_ARG2;
20:                
21:                /*
22:                 AUX
23:                AUX 
24:                a)  AUX AUX ?
25:                b)  3 AUX 
26:                c)  AUX  M1M0 2ms 
27:                d)  AUX  M1M0 AUX  2ms 
28:                 */
29:                static void E41_SetMode(uint8_t mode) {
004910  781F88     MOV W8, [W15++]
004912  784400     MOV.B W0, W8
30:                    //
31:                    //    uint8_t now_mode = M0_PORT + (M1_PORT << 1);//mark
32:                    //
33:                    //    switch (mode) {
34:                    //        case SLEEP:
35:                    //        {
36:                    INT0_Close(); //
004914  070446     RCALL INT0_Close
37:                    M0 = 0;
004916  A9A2E4     BCLR LATE, #5
38:                    M1 = 0; //
004918  A9C2E4     BCLR LATE, #6
39:                    OSTimeDlyHMSM(0, 0, 0, 250);
00491A  200FA3     MOV #0xFA, W3
00491C  EB0100     CLR W2
00491E  B80060     MUL.UU W0, #0, W0
004920  07012F     RCALL OSTimeDlyHMSM
40:                    M0 = mode & 0x01;
004922  6400E1     AND W8, #0x1, W1
004924  DD08C5     SL W1, #5, W1
004926  801720     MOV LATE, W0
004928  A15000     BCLR W0, #5
00492A  708000     IOR W1, W0, W0
00492C  881720     MOV W0, LATE
41:                    M1 = (mode >> 1) & 0x01;
00492E  DD4445     SL W8, #5, W8
004930  B20408     AND #0x40, W8
004932  801720     MOV LATE, W0
004934  A16000     BCLR W0, #6
004936  740000     IOR W8, W0, W0
004938  881720     MOV W0, LATE
42:                    OSTimeDlyHMSM(0, 0, 0, 10);
00493A  2000A3     MOV #0xA, W3
00493C  EB0100     CLR W2
00493E  B80060     MUL.UU W0, #0, W0
004940  07011F     RCALL OSTimeDlyHMSM
43:                    INT0_Open();
004942  07042C     RCALL INT0_Open
44:                    //            break;
45:                    //        }
46:                    //        case LOWPOWER:
47:                    //        {
48:                    //            break;
49:                    //        }
50:                    //        case WAKE:
51:                    //        {
52:                    //            break;
53:                    //        }
54:                    //        case WORK:
55:                    //        {
56:                    //            break;
57:                }
004944  78044F     MOV [--W15], W8
004946  060000     RETURN
58:                //            M0 = mode & 0x01;
59:                //            M1 = (mode >> 1) & 0x01;
60:                //}
61:                //}
62:                
63:                void E41_Init(void) {
004948  781F88     MOV W8, [W15++]
64:                    uint8_t cnt;
65:                    M0_TRIS = 0; //
00494A  A9A2E0     BCLR TRISE, #5
66:                    M1_TRIS = 0;
00494C  A9C2E0     BCLR TRISE, #6
67:                    //    uint8_t currentMode = E41_SetGetMode(10);
68:                    E41_SetMode(SLEEP);
00494E  B3C030     MOV.B #0x3, W0
004950  07FFDF     RCALL _E41_SetMode
69:                    OSTimeDlyHMSM(0, 0, 0, 300); // 300ms 
004952  2012C3     MOV #0x12C, W3
004954  EB0100     CLR W2
004956  B80060     MUL.UU W0, #0, W0
004958  070113     RCALL OSTimeDlyHMSM
00495A  B3C038     MOV.B #0x3, W8
70:                    //    UART3_SendChar(0xC0);
71:                    for (cnt = 0; cnt < 3; cnt++) {
00496C  3AFFF7     BRA NZ, 0x495C
72:                        UART3_SendString(E41_Arg, 6);
00495C  B3C061     MOV.B #0x6, W1
00495E  21C480     MOV #0x1C48, W0
004960  0702D6     RCALL UART3_SendString
73:                        //    UART3_SendString(E41_Arg, 6);
74:                        OSTimeDlyHMSM(0, 0, 0, 10);
004962  2000A3     MOV #0xA, W3
004964  EB0100     CLR W2
004966  B80060     MUL.UU W0, #0, W0
004968  07010B     RCALL OSTimeDlyHMSM
00496A  E94408     DEC.B W8, W8
75:                    }
76:                    //    E41_SetMode(LOWPOWER); //
77:                    //    E41_SetMode(WORK); //   
78:                    E41_SetMode(WAKE); //   
00496E  B3C010     MOV.B #0x1, W0
004970  07FFCF     RCALL _E41_SetMode
79:                }
004972  78044F     MOV [--W15], W8
004974  060000     RETURN
80:                
81:                bool E41_PressureIsGet(float* pres) {//01 03 04 3E F4 00 00 B6 2916
004976  FA004C     LNK #0x4C
004978  BE9F88     MOV.D W8, [W15++]
00497A  780480     MOV W0, W9
82:                    //
83:                    uint8_t tmp[10];
84:                    uint8_t Head[3] = {0x1, 0x3, 0x4};
00497C  B3C010     MOV.B #0x1, W0
00497E  9F7780     MOV.B W0, [W15-80]
004980  B3C030     MOV.B #0x3, W0
004982  9F7790     MOV.B W0, [W15-79]
004984  B3C040     MOV.B #0x4, W0
004986  9F77A0     MOV.B W0, [W15-78]
85:                    U3Rx4Byte();
004988  0702D9     RCALL U3Rx4Byte
86:                    StrCmp stcp;
87:                    uint8_t Source_tmp[50]; //
88:                
89:                    stcp.Source_len = UARTGetData(BufferRead_UART3, Source_tmp);
00498A  2FFCA8     MOV #0xFFCA, W8
00498C  44040F     ADD W8, W15, W8
00498E  780088     MOV W8, W1
004990  243CA0     MOV #0x43CA, W0
004992  07FD80     RCALL UARTGetData
004994  9FC780     MOV.B W0, [W15-64]
90:                    if (stcp.Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//505050
004996  B3C321     MOV.B #0x32, W1
004998  504F81     SUB.B W0, W1, [W15]
00499A  360001     BRA LEU, 0x499E
91:                        stcp.Source_len = 50;
00499C  9FC781     MOV.B W1, [W15-64]
92:                    stcp.SourceData = Source_tmp;
00499E  9F9FF8     MOV W8, [W15-66]
93:                    stcp.CheckData = Head;
0049A0  2FFB00     MOV #0xFFB0, W0
0049A2  40000F     ADD W0, W15, W0
0049A4  9FA790     MOV W0, [W15-62]
94:                    stcp.Check_len = 3;
0049A6  B3C030     MOV.B #0x3, W0
0049A8  9FC7C0     MOV.B W0, [W15-60]
95:                    stcp.GetData = tmp;
0049AA  2FFB38     MOV #0xFFB3, W8
0049AC  44040F     ADD W8, W15, W8
0049AE  9FA7B8     MOV W8, [W15-58]
96:                    stcp.Get_len = 8;
0049B0  B3C080     MOV.B #0x8, W0
0049B2  9FCF80     MOV.B W0, [W15-56]
97:                    stcp.Real_len = 0;
0049B4  EB4000     CLR.B W0
0049B6  9FCF90     MOV.B W0, [W15-55]
98:                    UARTDataIsRight(&stcp);
0049B8  2FFBE0     MOV #0xFFBE, W0
0049BA  40000F     ADD W0, W15, W0
0049BC  07FD19     RCALL UARTDataIsRight
99:                    if ((stcp.Real_len == 9) && CRCIsRight(tmp, 7, tmp + 7)) {//
0049C0  97C89F     MOV.B [W15-55], W1
0049C2  50CFE9     SUB.B W1, #0x9, [W15]
0049C4  3A000E     BRA NZ, 0x49E2
0049C6  2FFBA2     MOV #0xFFBA, W2
0049C8  41010F     ADD W2, W15, W2
0049CA  B3C071     MOV.B #0x7, W1
0049CC  780008     MOV W8, W0
0049CE  070336     RCALL CRCIsRight
0049D0  784080     MOV.B W0, W1
0049D4  E00401     CP0.B W1
0049D6  320005     BRA Z, 0x49E2
100:                       CharToFloat(pres, tmp + 3);
0049D8  2FFB61     MOV #0xFFB6, W1
0049DA  40808F     ADD W1, W15, W1
0049DC  780009     MOV W9, W0
0049DE  070030     RCALL CharToFloat
101:                       return true;
0049E0  B3C010     MOV.B #0x1, W0
102:                   }
103:                   return false;
0049BE  EB4000     CLR.B W0
0049D2  EB4000     CLR.B W0
104:               }
0049E2  BE044F     MOV.D [--W15], W8
0049E4  FA8000     ULNK
0049E6  060000     RETURN
105:               
106:               void E41_Active_Send(void) {//01 03 04 3E F4 00 00 B6 2916
0049E8  FA0014     LNK #0x14
107:                   //
108:                   uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34, 0x20, 0x30, 0x42}, cnt;
0049EA  578074     SUB W15, #0x14, W0
0049EC  090009     REPEAT #0x9
0049EE  EB1800     CLR [W0++]
0049F0  B3C010     MOV.B #0x1, W0
0049F2  9FEFD0     MOV.B W0, [W15-19]
0049F4  9FEFE0     MOV.B W0, [W15-18]
0049F6  B3C121     MOV.B #0x12, W1
0049F8  9FEFF1     MOV.B W1, [W15-17]
0049FA  B3C341     MOV.B #0x34, W1
0049FC  9FF781     MOV.B W1, [W15-16]
0049FE  50C0F4     SUB.B W1, #0x14, W1
004A00  9FF791     MOV.B W1, [W15-15]
004A02  40C0F0     ADD.B W1, #0x10, W1
004A04  9FF7A1     MOV.B W1, [W15-14]
004A06  40C0F2     ADD.B W1, #0x12, W1
004A08  9FF7B1     MOV.B W1, [W15-13]
109:                   E41_SetMode(WAKE); //    
004A0A  07FF82     RCALL _E41_SetMode
110:                   OSTimeDlyHMSM(0, 0, 0, 100);
004A0C  200643     MOV #0x64, W3
004A0E  EB0100     CLR W2
004A10  B80060     MUL.UU W0, #0, W0
004A12  0700B6     RCALL OSTimeDlyHMSM
111:                   INT0_Close();
004A14  0703C6     RCALL INT0_Close
112:                   //    for (cnt = 0; cnt < 3; cnt++) {
113:                   UART3_SendString(E41_tmp, 8);
004A16  B3C081     MOV.B #0x8, W1
004A18  578074     SUB W15, #0x14, W0
004A1A  070279     RCALL UART3_SendString
114:                   OSTimeDlyHMSM(0, 0, 0, 10);
004A1C  2000A3     MOV #0xA, W3
004A1E  EB0100     CLR W2
004A20  B80060     MUL.UU W0, #0, W0
004A22  0700AE     RCALL OSTimeDlyHMSM
115:                   //
116:                   //    }
117:                   INT0_Open();
004A24  0703BB     RCALL INT0_Open
118:                   OSTimeDlyHMSM(0, 0, 10, 0);
004A26  EB0180     CLR W3
004A28  2000A2     MOV #0xA, W2
004A2A  B80060     MUL.UU W0, #0, W0
004A2C  0700A9     RCALL OSTimeDlyHMSM
119:                   E41_SetMode(LOWPOWER); //    
004A2E  B3C020     MOV.B #0x2, W0
004A30  07FF6F     RCALL _E41_SetMode
120:                   //    OSTimeDlyHMSM(0, 0, 10, 0);
121:               }
004A32  FA8000     ULNK
122:               
123:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: char
6:                 Input:  4  8  
7:                 Output: 
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
004A36  400164     ADD W0, #0x4, W2
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
13:                
14:                    for (count = 0; count < 4; count++) {
004A3A  510F80     SUB W2, W0, [W15]
004A3C  3AFFFD     BRA NZ, 0x4A38
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
004A38  7858C2     MOV.B [--W2], [W1++]
16:                    }
17:                }
004A3E  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char 
22:                Input:     4  8  
23:                Output: 
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
004A40  408164     ADD W1, #0x4, W2
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
29:                
30:                    for (count = 0; count < 4; count++) {
004A44  510F81     SUB W2, W1, [W15]
004A46  3AFFFD     BRA NZ, 0x4A42
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
004A42  785842     MOV.B [--W2], [W0++]
32:                    }
33:                }
004A48  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: char
38:                Input:  4  8  
39:                Output: 
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
004A4A  400168     ADD W0, #0x8, W2
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
45:                
46:                    for (count = 0; count < 8; count++) {
004A4E  510F80     SUB W2, W0, [W15]
004A50  3AFFFD     BRA NZ, 0x4A4C
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
004A4C  7858C2     MOV.B [--W2], [W1++]
48:                    }
49:                }
004A52  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 1610
54:                Input: 
55:                Output: 
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
58:                    return ((dat >> 4)&0x0f)*10 + (dat & 0x0f);
004A54  FB8100     ZE W0, W2
004A56  DE1144     LSR W2, #4, W2
004A58  B9116A     MUL.SU W2, #10, W2
004A5A  60406F     AND.B W0, #0xF, W0
004A5C  404002     ADD.B W0, W2, W0
59:                }
004A5E  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 1016
64:                Input: 
65:                Output: 
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
004A60  FB8000     ZE W0, W0
004A62  2000A2     MOV #0xA, W2
004A64  090011     REPEAT #0x11
004A66  D88002     DIV.UW W0, W2
004A68  FD0080     EXCH W0, W1
004A6A  780101     MOV W1, W2
004A6C  DD10C4     SL W2, #4, W1
004A6E  704001     IOR.B W0, W1, W0
69:                }
004A70  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x1117-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 
79:                Input: 
80:                Output: 
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
004A78  B3C013     MOV.B #0x1, W3
004A7A  500F82     SUB W0, W2, [W15]
004A7C  310001     BRA C, 0x4A80
004A7E  EB4180     CLR.B W3
83:                    if (dat > max) return false;
004A72  EB4180     CLR.B W3
004A74  500F81     SUB W0, W1, [W15]
004A76  3E0004     BRA GTU, 0x4A80
84:                    else if (dat < min) return false;
85:                    return true;
86:                }
004A80  784003     MOV.B W3, W0
004A82  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 
91:                Input: 
92:                Output: 
93:                 *************************************/
94:                void SetVaildData(uint8_t * dat, const uint32_t max, const uint16_t min) {
95:                    uint16_t tmp = (* dat << 8) + *(dat + 1);
004A84  780200     MOV W0, W4
004A86  FB8354     ZE [++W4], W6
004A88  FB8290     ZE [W0], W5
004A8A  DD2AC8     SL W5, #8, W5
004A8C  430285     ADD W6, W5, W5
96:                
97:                    if (tmp > max) {
004A8E  B82B61     MUL.UU W5, #1, W6
004A90  530F82     SUB W6, W2, [W15]
004A92  5B8F83     SUBB W7, W3, [W15]
004A94  360007     BRA LEU, 0x4AA4
98:                        *dat = max >> 8;
004A96  DE1BC8     LSR W3, #8, W7
004A98  DD18C8     SL W3, #8, W1
004A9A  DE1348     LSR W2, #8, W6
004A9C  708306     IOR W1, W6, W6
004A9E  784806     MOV.B W6, [W0]
99:                        *(dat + 1) = max & 0x00ff;
004AA0  784A02     MOV.B W2, [W4]
004AA2  060000     RETURN
100:                   } else if (tmp < min) {
004AA4  528F81     SUB W5, W1, [W15]
004AA6  310003     BRA C, 0x4AAE
101:                       *dat = min >> 8;
004AA8  DE0948     LSR W1, #8, W2
004AAA  784802     MOV.B W2, [W0]
102:                       *(dat + 1) = min & 0x00ff;
004AAC  784A01     MOV.B W1, [W4]
004AAE  060000     RETURN
103:                   }
104:               }
105:               //
106:               
107:               void DataReverse(uint8_t *dat, const uint8_t byte) {
004AB4  E90102     DEC W2, W2
004AB6  400102     ADD W0, W2, W2
108:                   uint8_t tmp, cnt;
109:               
110:                   for (cnt = 0; cnt < byte / 2; cnt++) {
004AB0  FB8101     ZE W1, W2
004AB2  D10202     LSR W2, W4
004AB8  780180     MOV W0, W3
004ABA  EB4080     CLR.B W1
004ABC  370004     BRA 0x4AC6
004AC4  E84081     INC.B W1, W1
004AC6  50CF84     SUB.B W1, W4, [W15]
004AC8  39FFFA     BRA NC, 0x4ABE
111:                       tmp = dat[cnt];
004ABE  7842B3     MOV.B [W3++], W5
112:                       dat[cnt] = dat[byte - 1 - cnt];
004AC0  785812     MOV.B [W2], [W0++]
113:                       dat[byte - 1 - cnt] = tmp;
004AC2  785105     MOV.B W5, [W2--]
114:                   }
115:               }
004ACA  060000     RETURN
116:               
117:               //8MHz-4Mhz
118:               
119:               //void Delay10ms(char time) {
120:               //    uint16_t i;
121:               //    while (time-- > 0)
122:               //        for (i = 0; i < 6700; i++)
123:               //            asm("Nop()");
124:               //}
125:               
126:               //void Delay100ms(char time) {
127:               //    uint16_t i;
128:               //    while (time-- > 0)
129:               //        for (i = 0; i < 65500; i++)
130:               //            asm("Nop()");
131:               //}
132:               //
133:               //void Delay1s(char time) {
134:               //    uint32_t i; //,j;
135:               //    while (time-- > 0)
136:               //        for (i = 0; i < 365000; i++)
137:               //            asm("Nop()");
138:               //}
139:               
140:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
141:                   uint8_t num;
142:                   for (num = 0; num < bytes; num++)
004ACC  780181     MOV W1, W3
004ACE  370001     BRA 0x4AD2
004AD2  51C201     SUB.B W3, W1, W4
004AD4  524F82     SUB.B W4, W2, [W15]
004AD6  39FFFC     BRA NC, 0x4AD0
143:                       *(output + num) = *(input + num);
004AD0  785833     MOV.B [W3++], [W0++]
144:               }
004AD8  060000     RETURN
145:               
146:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
147:                   uint8_t num;
148:                   for (num = 0; num < bytes; num++)
004ADA  780180     MOV W0, W3
004ADC  370001     BRA 0x4AE0
004AE0  51C200     SUB.B W3, W0, W4
004AE2  524F82     SUB.B W4, W2, [W15]
004AE4  39FFFC     BRA NC, 0x4ADE
149:                       *(output + num) = dat;
004ADE  785981     MOV.B W1, [W3++]
150:               }
004AE6  060000     RETURN
151:               
152:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
153:                   uint8_t cnt;
154:                   for (cnt = 0; cnt < bytes; cnt++)
004AE8  780180     MOV W0, W3
004AEA  370003     BRA 0x4AF2
004AF2  51C200     SUB.B W3, W0, W4
004AF4  524F82     SUB.B W4, W2, [W15]
004AF6  39FFFA     BRA NC, 0x4AEC
155:                       if (*(str1 + cnt) != *(str2 + cnt))
004AEC  784233     MOV.B [W3++], W4
004AEE  524FB1     SUB.B W4, [W1++], [W15]
004AF0  3A0004     BRA NZ, 0x4AFA
156:                           return false;
004AFA  050000     RETLW #0x0, W0
157:                   return true;
004AF8  050010     RETLW #0x1, W0
158:               }
159:               
160:               //
161:               
162:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
163:                   return num - ((num >> mod_num) << mod_num);
004AFC  FB8081     ZE W1, W1
004AFE  DE0101     LSR W0, W1, W2
004B00  DD1081     SL W2, W1, W1
004B02  504001     SUB.B W0, W1, W0
164:               }
004B04  060000     RETURN
165:               
166:               //16
167:               uint8_t my_itoa(uint16_t i,uint8_t *str)
168:               {
004B06  FA0006     LNK #0x6
004B08  780301     MOV W1, W6
169:                  uint8_t buf[6];
170:                  uint8_t cnt=0,len;
004B0A  EB4100     CLR.B W2
171:                  uint16_t tmp=i;
172:               
173:                   while(tmp)
004B0C  37000A     BRA 0x4B22
004B22  E00000     CP0 W0
004B24  3AFFF4     BRA NZ, 0x4B0E
174:                   {
175:                   *(buf+cnt++)=tmp%10+0x30;
004B0E  FB8202     ZE W2, W4
004B10  2000A3     MOV #0xA, W3
004B12  090011     REPEAT #0x11
004B14  D88003     DIV.UW W0, W3
004B16  780181     MOV W1, W3
004B18  B04303     ADD.B #0x30, W3
004B1A  784083     MOV.B W3, W1
004B1C  5782E6     SUB W15, #0x6, W5
004B1E  7A7281     MOV.B W1, [W5+W4]
004B20  E84102     INC.B W2, W2
176:                   tmp/=10;
177:                   }
178:                   len=cnt;
179:                   cnt+=1;
004B26  E84002     INC.B W2, W0
180:                   while(cnt--)
004B28  370007     BRA 0x4B38
004B2A  E94000     DEC.B W0, W0
004B3A  E00400     CP0.B W0
004B3C  3AFFF6     BRA NZ, 0x4B2A
181:                   {
182:                       *(str+cnt-1)=*(buf+len-cnt);
004B2C  FB8200     ZE W0, W4
004B2E  430284     ADD W6, W4, W5
004B30  518184     SUB W3, W4, W3
004B32  5780E6     SUB W15, #0x6, W1
004B34  79C1E1     MOV.B [W1+W3], W3
004B36  9FFAF3     MOV.B W3, [W5-1]
004B38  FB8182     ZE W2, W3
183:                   }
184:                   *(str+len)='\0';
004B3E  79F300     MOV.B W0, [W6+W3]
185:                   return len;
186:               }
004B40  784002     MOV.B W2, W0
187:               
188:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/CheckData.c  --------------------------------
1:                 //#include "user.h"
2:                 #include "CheckData.h"
3:                 
4:                 ///****************************************************************************
5:                 //: CRC16()
6:                 //: CRC16
7:                 //: *CRC_Buf:
8:                 //      CRC_Leni:
9:                 //: CRC
10:                // *****************************************************************************/
11:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, const uint8_t CRC_Leni) {
12:                //    uint16_t i, j;
13:                //    uint16_t CRC_Sumx;
14:                //
15:                //    CRC_Sumx = 0xFFFF;
16:                //    for (i = 0; i < CRC_Leni; i++) {
17:                //        CRC_Sumx ^= *(CRC_Buf + i); //
18:                //        for (j = 0; j < 8; j++) {
19:                //            if (CRC_Sumx & 0x01) {
20:                //                CRC_Sumx >>= 1;
21:                //                CRC_Sumx ^= 0xA001;
22:                //            } else {
23:                //                CRC_Sumx >>= 1;
24:                //            }
25:                //        }
26:                //    }
27:                //    return (CRC_Sumx);
28:                //}
29:                
30:                /*************************************
31:                Function: CheckIsRight  
32:                Description: datfp
33:                Input: fp dat:bytes:
34:                Output: 1  0
35:                 *************************************/
36:                bool CRCIsRight(uint8_t * CRC_Buf, const uint8_t CRC_Leni, const uint8_t* CHC_Dat) {
37:                    uint16_t i, j;
38:                    uint16_t CRC_Sumx;
39:                
40:                    CRC_Sumx = 0xFFFF;
00503C  EB8180     SETM W3
41:                    for (i = 0; i < CRC_Leni; i++) {
00503E  EB0200     CLR W4
005040  37000D     BRA 0x505C
00505A  E80204     INC W4, W4
00505C  FB8281     ZE W1, W5
00505E  520F85     SUB W4, W5, [W15]
005060  39FFF0     BRA NC, 0x5042
42:                        CRC_Sumx ^= *(CRC_Buf + i); //
005042  FB82B0     ZE [W0++], W5
005044  698185     XOR W3, W5, W3
005046  200085     MOV #0x8, W5
005048  D10303     LSR W3, W6
43:                        for (j = 0; j < 8; j++) {
005058  3AFFF7     BRA NZ, 0x5048
44:                            if (CRC_Sumx & 0x01) {
00504A  A30803     BTST.Z W3, #0
00504C  320003     BRA Z, 0x5054
45:                                CRC_Sumx >>= 1;
46:                                CRC_Sumx ^= 0xA001;
00504E  2A0013     MOV #0xA001, W3
005050  6B0183     XOR W6, W3, W3
005052  370001     BRA 0x5056
47:                            } else {
48:                                CRC_Sumx >>= 1;
005054  780186     MOV W6, W3
005056  E90285     DEC W5, W5
49:                            }
50:                        }
51:                    }; //CRC
52:                    return (CRC_Sumx == (*CHC_Dat + (*(CHC_Dat + 1) << 8))); //+CRC
005062  904012     MOV.B [W2+1], W0
005064  DD0048     SL W0, #8, W0
005066  FB8092     ZE [W2], W1
005068  400001     ADD W0, W1, W0
00506A  698180     XOR W3, W0, W3
00506C  A7F003     BTSC W3, #15
00506E  EA0183     NEG W3, W3
005070  E90183     DEC W3, W3
005072  DE184F     LSR W3, #15, W0
53:                }
005074  060000     RETURN
54:                
55:                ///*************************************
56:                //Function: Sum_Check 
57:                //Description: 
58:                //Input: framebytes 
59:                //Output: 
60:                // *************************************/
61:                //uint16_t Sum_Check(uint8_t *frame, const uint8_t bytes) {
62:                //    uint16_t cksum = 0;
63:                //    uint16_t cnt = bytes;
64:                //    while (cnt > 0) {
65:                //        cksum += *frame++;
66:                //        cnt--;
67:                //    }
68:                //    return cksum;
69:                //}
70:                
71:                /*************************************
72:                Function: Sum_Check256
73:                Description: 
74:                Input: framebytes 
75:                Output: 
76:                 *************************************/
77:                bool SumCheckIsRight(uint8_t *frame, const uint16_t bytes, const uint8_t CheckSum) {
78:                    uint32_t ckSum = 0; //
005078  B82260     MUL.UU W4, #0, W4
79:                    uint16_t cnt;
80:                
81:                    for (cnt = 0; cnt < bytes; cnt++)
005076  EB0180     CLR W3
00507A  370005     BRA 0x5086
005084  E80183     INC W3, W3
005086  518F81     SUB W3, W1, [W15]
005088  39FFF9     BRA NC, 0x507C
82:                        ckSum += *frame++;
00507C  FB8330     ZE [W0++], W6
00507E  EB0380     CLR W7
005080  430204     ADD W6, W4, W4
005082  4B8285     ADDC W7, W5, W5
83:                
84:                    return (CheckSum == (ckSum - ((ckSum >> 8) << 8)));
00508A  FB8102     ZE W2, W2
00508C  EB0180     CLR W3
00508E  FB8004     ZE W4, W0
005090  EB0080     CLR W1
005092  690000     XOR W2, W0, W0
005094  698081     XOR W3, W1, W1
005096  708000     IOR W1, W0, W0
005098  A7F000     BTSC W0, #15
00509A  EA0000     NEG W0, W0
00509C  E90000     DEC W0, W0
00509E  DE004F     LSR W0, #15, W0
85:                }
0050A0  060000     RETURN
86:                
87:                
88:                
89:                //bool CheckSrting(uint8_t*dat1, uint8_t*dat2, const uint8_t num) {
90:                //    uint8_t cnt;
91:                //    for (cnt = 0; cnt < num; cnt++) {//EID
92:                //        if (*(dat1 + cnt) != *(dat2 + cnt)) {
93:                //            return false;
94:                //        }
95:                //    }
96:                //    return true;
97:                //}
98:                
99:                ///*************************************
100:               //Function: MD5encrypt  
101:               //Description: 
102:               //Input: 
103:               //Output:
104:               //*************************************/
105:               //void MD5encrypt(uint8_t* input,uint8_t *output)
106:               //{
107:               //    
108:               //}
109:               
110:               
111:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/User/CAT24C512.c  --------------------------------
1:                 #include "CAT24C512.h"
2:                 
3:                 //0x0000-0xffff 512kb
4:                 #define BufferSize 40//
5:                 
6:                 
7:                 uint16_t CAT_OperatID;
8:                 //CAT24Arg CAT24Argbits;
9:                 
10:                void CAT24C512_Init(void) {
11:                    TRISBbits.TRISB12 = 0; //WP    
0050F4  A982C9     BCLR 0x2C9, #4
12:                    LATBbits.LATB12 = 1;//
0050F6  A882CD     BSET 0x2CD, #4
13:                    //    CAT24Argbits.ID = 0; //
14:                    //    CAT24Argbits.data = NULL;
15:                }
0050F8  060000     RETURN
16:                
17:                void CAT24C512_Read(uint16_t id, uint8_t *tmp) {
18:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //cat24c512 0xA8 
19:                    i2c_buf.operatcode = CAT_ADD;
0050FA  B3CA83     MOV.B #0xA8, W3
0050FC  21C3E2     MOV #0x1C3E, W2
0050FE  784903     MOV.B W3, [W2]
20:                    i2c_buf.address = id*BufferSize;
005100  200282     MOV #0x28, W2
005102  B98202     MUL.SS W0, W2, W4
005104  88E204     MOV W4, 0x1C40
21:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
005106  21C420     MOV #0x1C42, W0
005108  784802     MOV.B W2, [W0]
22:                    i2c_buf.pbuffer = tmp;
00510A  88E221     MOV W1, 0x1C44
23:                    i2c_buf.flag.F_IsSelectiveMode = 1;
00510C  80E230     MOV 0x1C46, W0
24:                    i2c_buf.flag.F_WriteOrRead = 1;
25:                    i2c_buf.flag.F_Is16bitsDevice = 1;
00510E  B30070     IOR #0x7, W0
005110  88E230     MOV W0, 0x1C46
26:                    i2c1_state = S_MASTER_IDLE;
005112  EF6844     CLR.B i2c1_state
27:                    IFS1bits.MI2C1IF = 1; //I2C
005114  A82086     BSET IFS1, #1
28:                    //
29:                    //
30:                    while (i2c1_state != S_MASTER_SEND_STOP); //
005116  BFC844     MOV.B i2c1_state, WREG
005118  504FE6     SUB.B W0, #0x6, [W15]
00511A  3AFFFD     BRA NZ, 0x5116
31:                }
00511C  060000     RETURN
32:                
33:                void CAT24C512_Write(uint16_t id, uint8_t *tmp) {
34:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //cat24c512 0xA8 
35:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};
36:                    i2c_buf.operatcode = CAT_ADD;
00511E  B3CA83     MOV.B #0xA8, W3
005120  21C3E2     MOV #0x1C3E, W2
005122  784903     MOV.B W3, [W2]
37:                    i2c_buf.address = id*BufferSize;
005124  200282     MOV #0x28, W2
005126  B98202     MUL.SS W0, W2, W4
005128  88E204     MOV W4, 0x1C40
38:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
00512A  21C420     MOV #0x1C42, W0
00512C  784802     MOV.B W2, [W0]
39:                    i2c_buf.pbuffer = tmp;
00512E  88E221     MOV W1, 0x1C44
40:                    i2c_buf.flag.F_IsSelectiveMode = 1;
005130  80E230     MOV 0x1C46, W0
005132  A00000     BSET W0, #0
41:                    i2c_buf.flag.F_WriteOrRead = 0;
005134  A12000     BCLR W0, #2
42:                    i2c_buf.flag.F_Is16bitsDevice = 1;
005136  A01000     BSET W0, #1
005138  88E230     MOV W0, 0x1C46
43:                    i2c1_state = S_MASTER_IDLE;
00513A  EF6844     CLR.B i2c1_state
44:                    IFS1bits.MI2C1IF = 1;
00513C  A82086     BSET IFS1, #1
45:                    while (i2c1_state != S_MASTER_SEND_STOP); //
00513E  BFC844     MOV.B i2c1_state, WREG
005140  504FE6     SUB.B W0, #0x6, [W15]
005142  3AFFFD     BRA NZ, 0x513E
46:                    //
47:                }
005144  060000     RETURN
48:                
49:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/bsp_a.s  -------------------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                         (c) Copyright 2002, Jean J. Labrosse, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                  dsPIC33FJ Board Support Package
                                                  11:    ;
                                                  12:    ;
                                                  13:    ; File         : bsp_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ;********************************************************************************************************
                                                  16:    ;
                                                  17:    
                                                  18:    ;
                                                  19:    ;********************************************************************************************************
                                                  20:    ;                                                CONSTANTS
                                                  21:    ;********************************************************************************************************
                                                  22:    ;
                                                  23:    ;
                                                  24:    ;********************************************************************************************************
                                                  25:    ;                                                INCLUDES
                                                  26:    ;********************************************************************************************************
                                                  27:    ;
                                                  28:    
                                                  29:    .include "xc.inc"
                                                  30:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  31:    
                                                  32:    ;
                                                  33:    ;********************************************************************************************************
                                                  34:    ;                                             LINKER SPECIFICS
                                                  35:    ;********************************************************************************************************
                                                  36:    ;
                                                  37:    
                                                  38:        .text                                                               ; Locate this file in the text region of the build
                                                  39:    
                                                  40:    ;
                                                  41:    ;********************************************************************************************************
                                                  42:    ;                                                 GLOBALS
                                                  43:    ;********************************************************************************************************
                                                  44:    ;
                                                  45:    
                                                  46:        .global __T2Interrupt
                                                  47:        .global __T4Interrupt
                                                  48:    
                                                  49:    ;
                                                  50:    ;********************************************************************************************************
                                                  51:    ;                                            OS Time Tick ISR Handler
                                                  52:    ;
                                                  53:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #2
                                                  54:    ;
                                                  55:    ; Notes       : All user interrupts should be defined as follows.
                                                  56:    ;********************************************************************************************************
                                                  57:    ;
                                                  58:    
                                                  59:    __T2Interrupt:
004D8C  BE9F80     MOV.D W0, [W15++]              60:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  61:    
004DA8  208111     MOV #0x811, W1                 62:        mov   #_OSIntNesting, w1
004DAA  E84891     INC.B [W1], [W1]               63:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  64:    
004DAC  ED4811     DEC.B 0x811, WREG              65:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
004DAE  3A0002     BRA NZ, 0x4DB4                 66:        bra nz, T2_Cont
004DB0  8040E0     MOV 0x81C, W0                  67:        mov _OSTCBCur, w0
004DB2  78080F     MOV W15, [W0]                  68:        mov w15, [w0]
                                                  69:    
                                                  70:    T2_Cont:
004DB4  024CA8     CALL 0x4CA8                    71:        call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
004DB8  021F82     CALL 0x1F82                    72:        call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  73:    
004DBC  F90044     POP CORCON                     74:        OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  75:    
004DD8  064000     RETFIE                         76:        retfie                                                              ; 7) Return from interrupt
                                                  77:    
                                                  78:    
                                                  79:    ;
                                                  80:    ;********************************************************************************************************
                                                  81:    ;                                            OS Time Tick ISR Handler
                                                  82:    ;
                                                  83:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #4
                                                  84:    ;
                                                  85:    ; Notes       : All user interrupts should be defined as follows.
                                                  86:    ;********************************************************************************************************
                                                  87:    ;
                                                  88:    
                                                  89:    __T4Interrupt:
004DDA  BE9F80     MOV.D W0, [W15++]              90:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  91:    
004DF6  208111     MOV #0x811, W1                 92:        mov   #_OSIntNesting, w1
004DF8  E84891     INC.B [W1], [W1]               93:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  94:    
004DFA  ED4811     DEC.B 0x811, WREG              95:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
004DFC  3A0002     BRA NZ, 0x4E02                 96:        bra nz, T4_Cont
004DFE  8040E0     MOV 0x81C, W0                  97:        mov _OSTCBCur, w0
004E00  78080F     MOV W15, [W0]                  98:        mov w15, [w0]
                                                  99:    
                                                  100:   T4_Cont:
004E02  024CA8     CALL 0x4CA8                    101:       call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
004E06  021F82     CALL 0x1F82                    102:       call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  103:   
004E0A  F90044     POP CORCON                     104:       OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  105:   
004E26  064000     RETFIE                         106:       retfie                                                              ; 7) Return from interrupt
                                                  107:   
                                                  108:   
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                #include "HL6528.h"
18:                #include "E41.h"
19:                //#include <p24F32KA302.h>
20:                //#include <p24FJ64GA306.h>
21:                
22:                /*
23:                 *********************************************************************************************************
24:                 *                                       MPLAB CONFIGURATION MACROS
25:                 *********************************************************************************************************
26:                 */
27:                //#if defined(__dsPIC33E__)
28:                //// FICD
29:                //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
30:                //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
31:                //
32:                //// FPOR
33:                //#pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
34:                //#pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
35:                //#pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)
36:                //
37:                //// FWDT
38:                //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
39:                //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
40:                //#pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
41:                //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
42:                //#pragma config FWDTEN = ON              // Watchdog Timer Enable bit (Watchdog timer always enabled)
43:                //
44:                //// FOSC
45:                //#pragma config POSCMD = NONE            // Primary Oscillator Mode Select bits (Primary Oscillator disabled)
46:                //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
47:                //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
48:                //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
49:                //
50:                //// FOSCSEL
51:                //#pragma config FNOSC = FRCDIVN          // Oscillator Source Selection (Internal Fast RC (FRC) Oscillator with postscaler)
52:                //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
53:                //
54:                //// FGS
55:                //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
56:                //#pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)
57:                //#elif defined (__PIC24F__)
58:                // CONFIG4
59:                
60:                // CONFIG4
61:                //#pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68719476736 (25.7 Days))
62:                //#pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select (DSWDT uses LPRC as reference clock)
63:                //#pragma config DSBOREN = OFF            // Deep Sleep BOR Enable bit (DSBOR Disabled)
64:                //#pragma config DSWDTEN = OFF            // Deep Sleep Watchdog Timer Enable (DSWDT Disabled)
65:                //#pragma config DSSWEN = OFF             // DSEN Bit Enable (Deep Sleep operation is always disabled)
66:                //
67:                //// CONFIG3
68:                //#pragma config WPFP = WPFP63            // Write Protection Flash Page Segment Boundary (Page 52 (0xFC00))
69:                //#pragma config VBTBOR = ON              // VBAT BOR enable bit (VBAT BOR enabled)
70:                //#pragma config SOSCSEL = OFF            // SOSC Selection bits (Digital (SCLKI) mode)
71:                //#pragma config WDTWIN = PS25_0          // Watch Dog Timer Window Width (Watch Dog Timer Window Width is 25 percent)
72:                //#pragma config BOREN = ON               // Brown-out Reset Enable (Brown-out Reset Enable)
73:                //#pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Disabled)
74:                //#pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Disabled)
75:                //#pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
76:                //
77:                //// CONFIG2
78:                //#pragma config POSCMD = NONE            // Primary Oscillator Select (Primary Oscillator Disabled)
79:                //#pragma config BOREN1 = EN              // BOR Override bit (BOR Enabled [When BOREN=1])
80:                //#pragma config IOL1WAY = ON             // IOLOCK One-Way Set Enable bit (Once set, the IOLOCK bit cannot be cleared)
81:                //#pragma config OSCIOFCN = ON            // OSCO Pin Configuration (OSCO/CLKO/RC15 functions as port I/O (RC15))
82:                //#pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor Configuration bits (Clock switching and Fail-Safe Clock Monitor are disabled)
83:                //#pragma config FNOSC = FRCPLL           // Initial Oscillator Select (Fast RC Oscillator with PLL module (FRCPLL))
84:                //#pragma config ALTVREF = ALT_AV_ALT_CV  // Alternate VREF/CVREF Pins Selection bit (Voltage reference input, ADC =RB0/RB1   Comparator =RB0/RB1)
85:                //#pragma config IESO = ON                // Internal External Switchover (Enabled)
86:                //
87:                //// CONFIG1
88:                //#pragma config WDTPS = PS32768          // Watchdog Timer Postscaler Select (1:32,768)
89:                //#pragma config FWPSA = PR128            // WDT Prescaler Ratio Select (1:128)
90:                //#pragma config FWDTEN = WDT_DIS         // Watchdog Timer Enable (WDT disabled in hardware; SWDTEN bit disabled)
91:                //#pragma config WINDIS = OFF             // Windowed WDT Disable (Standard Watchdog Timer)
92:                //#pragma config ICS = PGx2               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC2/PGED2)
93:                //#pragma config LPCFG = OFF              // Low power regulator control (Disabled)
94:                //#pragma config GWRP = OFF               // General Segment Write Protect (Disabled)
95:                //#pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
96:                //#pragma config JTAGEN = OFF             // JTAG Port Enable (Disabled)
97:                
98:                
99:                //#elif defined (__PIC24E__)
100:               //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
101:               //#pragma config GSS = OFF                // General Segment Code-Protect bit (General Segment Code protect is disabled)
102:               //#pragma config GSSK = OFF               // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
103:               //
104:               //// FOSCSEL
105:               //#pragma config FNOSC = FRC           // Initial Oscillator Source Selection bits (Primary Oscillator (XT, HS, EC) with PLL)
106:               //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
107:               //
108:               //// FOSC
109:               //#pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
110:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
111:               //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
112:               //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
113:               //
114:               //// FWDT
115:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
116:               //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
117:               //#pragma config PLLKEN = ON              // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
118:               //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
119:               //#pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
120:               //
121:               //// FPOR
122:               //#pragma config FPWRT = PWR128           // Power-on Reset Timer Value Select bits (128ms)
123:               //#pragma config BOREN = ON               // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
124:               //#pragma config ALTI2C1 = OFF            // Alternate I2C pins for I2C1 (SDA1/SCK1 pins are selected as the I/O pins for I2C1)
125:               //#pragma config ALTI2C2 = OFF            // Alternate I2C pins for I2C2 (SDA2/SCK2 pins are selected as the I/O pins for I2C2)
126:               //
127:               //// FICD
128:               //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
129:               //#pragma config RSTPRI = PF              // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
130:               //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
131:               //
132:               //// FAS
133:               //#pragma config AWRP = OFF               // Auxiliary Segment Write-protect bit (Aux Flash may be written)
134:               //#pragma config APL = OFF                // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
135:               //#pragma config APLK = OFF               // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
136:               //
137:               //#elif defined(__dsPIC33F__)
138:               //
139:               //// FBS
140:               //#pragma config BWRP = WRPROTECT_OFF     // Boot Segment Write Protect (Boot Segment may be written)
141:               //#pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
142:               //#pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)
143:               //
144:               //// FSS
145:               //#pragma config SWRP = WRPROTECT_OFF     // Secure Segment Program Write Protect (Secure Segment may be written)
146:               //#pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
147:               //#pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)
148:               //
149:               //// FGS
150:               //#pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
151:               //#pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)
152:               //
153:               //// FOSCSEL
154:               //#pragma config FNOSC = LPRCDIVN           // Oscillator Mode (Primary Oscillator (XT, HS, EC) w/ PLL)
155:               //#pragma config IESO = ON                // Two-speed Oscillator Start-Up Enable (Start up with FRC, then switch)
156:               //
157:               //// FOSC
158:               //#pragma config POSCMD = XT              // Primary Oscillator Source (XT Oscillator Mode)
159:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function (OSC2 pin has clock out function)
160:               //#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Both Clock Switching and Fail-Safe Clock Monitor are disabled)
161:               //
162:               //// FWDT
163:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler (1:32,768)
164:               //#pragma config WDTPRE = PR128           // WDT Prescaler (1:128)
165:               //#pragma config WINDIS = OFF             // Watchdog Timer Window (Watchdog Timer in Non-Window mode)
166:               //#pragma config FWDTEN = ON              // Watchdog Timer Enable (Watchdog timer always enabled)
167:               //
168:               //// FPOR
169:               //#pragma config FPWRT = PWR128           // POR Timer Value (128ms)
170:               //
171:               //// FICD
172:               //#pragma config ICS = PGD1               // Comm Channel Select (Communicate on PGC1/EMUC1 and PGD1/EMUD1)
173:               //#pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG is Disabled)
174:               //#endif
175:               /*********************************************************************************************************
176:                *                                              CONSTANTS
177:                *********************************************************************************************************
178:                */
179:               
180:               //#define  LED6   0x40                                                    /* Port A pin 6                                             */
181:               //#define  LED7   0x80                                                    /* Port A pin 7                                             */
182:               
183:               /*
184:                *********************************************************************************************************
185:                *                                              VARIABLES
186:                *********************************************************************************************************
187:                */
188:               
189:               /*
190:                *********************************************************************************************************
191:                *                                              PROTOTYPES
192:                *********************************************************************************************************
193:                */
194:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
195:               static void BSP_PLL_Init(void);
196:               #endif
197:               static void Tmr_TickInit(void);
198:               
199:               /*
200:                *********************************************************************************************************
201:                *                                         BSP INITIALIZATION
202:                *
203:                * Description : This function should be called by your application code before you make use of any of the
204:                *               functions found in this module.
205:                *
206:                * Arguments   : none
207:                *********************************************************************************************************
208:                */
209:               
210:               void BSP_Init(void) {
211:                   RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
004CC2  A9A740     BCLR RCON, #5
212:                   //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
213:                   //    BSP_PLL_Init(); /* Initialize the PLL                                       */
214:                   //#endif
215:                   OSCILLATOR_Initialize(); //
004CC4  07FFF3     RCALL OSCILLATOR_Initialize
216:                   Tmr_TickInit(); //UCOS
004CC6  07FFD1     RCALL _Tmr_TickInit
217:                   LED_Init(); //LED
004CC8  07FFE5     RCALL LED_Init
218:                   RTC_Init(); //
004CCA  07F833     RCALL RTC_Init
219:                   PPSInit(); //
004CCC  0701EA     RCALL PPSInit
220:                   UART2_Init(); //2GPRShl6528
004CCE  0700AC     RCALL UART2_Init
221:                   UART3_Init(); //3433
004CD0  0700F5     RCALL UART3_Init
222:                   RS485_Init(); //1485
004CD2  07017A     RCALL RS485_Init
223:                   I2C_Init(); //i2c,
004CD4  070269     RCALL I2C_Init
224:                   INT0_Init(); //
004CD6  37025B     BRA INT0_Init
225:               //    E41_Init(); //
226:               //    HL6528_Init(); /*Initialize the HL6528*/
227:               ////#ifdef CLOSE_6528
228:               ////    HL6528_Close();// 
229:               ////    UART2_Close();
230:               ////#endif
231:               //    CAT24C512_Init(); //
232:               //    //    PCF8583_Init();//PCF8583
233:               //    //        Close6528Cop(); /*Close UART2 */
234:               }
235:               
236:               /*
237:                *********************************************************************************************************
238:                *                                      BSP_PLL_Init()
239:                *
240:                * Description : This function configures and enables the PLL with the external oscillator
241:                *               selected as the input clock to the PLL.
242:                *
243:                * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
244:                *               2) FIN is the PLL input clock frequency, defined in bsp.h as
245:                *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
246:                *                  oscillator on the Explorer 16 Evaluation Board.
247:                *               3) M is the desired PLL multiplier
248:                *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
249:                *               5) N2 is the PLL output divider (Post-Divider)
250:                *
251:                * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
252:                *                  The processor clock is (1/2) of the PLL output.
253:                *                  Performance = 40 MIPS.
254:                *********************************************************************************************************
255:                */
256:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
257:               
258:               static void BSP_PLL_Init(void) {
259:                   PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
260:                   CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
261:               }
262:               #endif
263:               
264:               /*
265:                *********************************************************************************************************
266:                *                                      BSP_CPU_ClkFrq()
267:               
268:                * Description : This function determines the CPU clock frequency (Fcy)
269:                * Returns     : The CPU frequency in (HZ)
270:                *********************************************************************************************************
271:                */
272:               
273:               CPU_INT32U BSP_CPU_ClkFrq(void) {
274:                   CPU_INT08U Clk_Selected;
275:                   CPU_INT16U FRC_Div;
276:                   CPU_INT32U CPU_Clk_Frq;
277:               
278:               
279:               #if defined (__dsPIC33E__) || defined (__dsPIC33F__)
280:                   CPU_INT08U PLL_n1;
281:                   CPU_INT08U PLL_n2;
282:                   CPU_INT16U PLL_m;
283:                   PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
284:                   PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
285:                   PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
286:                   PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
287:               #endif
288:               
289:                   FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
004C10  803A20     MOV CLKDIV, W0
004C4E  DE0148     LSR W0, #8, W2
004C50  610167     AND W2, #0x7, W2
290:                   FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
004C52  200020     MOV #0x2, W0
004C54  DD0102     SL W0, W2, W2
291:               
292:                   Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
004C12  270002     MOV #0x7000, W2
004C14  803A11     MOV OSCCON, W1
004C16  610101     AND W2, W1, W2
293:               
294:                   switch (Clk_Selected) {
004C18  DE114C     LSR W2, #12, W2
004C1A  FB8102     ZE W2, W2
004C1C  EB0180     CLR W3
004C1E  510161     SUB W2, #0x1, W2
004C20  5981E0     SUBB W3, #0x0, W3
004C22  510FE6     SUB W2, #0x6, [W15]
004C24  598FE0     SUBB W3, #0x0, [W15]
004C26  3E0008     BRA GTU, 0x4C38
004C28  016002     BRA W2
004C2A  37001A     BRA 0x4C60
004C2C  370005     BRA 0x4C38
004C2E  370018     BRA 0x4C60
004C30  370006     BRA 0x4C3E
004C32  370008     BRA 0x4C44
004C34  37000A     BRA 0x4C4A
004C36  37000B     BRA 0x4C4E
295:                       case 0: /* Fast Oscillator (FRC) Selected                           */
296:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
004C38  212000     MOV #0x1200, W0
004C3A  2007A1     MOV #0x7A, W1
004C3C  370013     BRA 0x4C64
297:                           break;
298:               
299:                       case 1:
300:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
301:                           CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
302:                                   (FRC_Div * PLL_n1 * PLL_n2));
303:               #else
304:                           /* Fast Oscillator (FRC) with PLL Selected                  */
305:                           CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
004C60  248000     MOV #0x4800, W0
004C62  201E81     MOV #0x1E8, W1
306:               #endif
307:                           break;
308:               
309:                       case 2: /* Primary External Oscillator Selected                     */
310:                           CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
311:                           break;
312:               
313:                       case 3:
314:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
315:                           CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
316:                                   (PLL_n1 * PLL_n2));
317:               #else
318:                           /* Primary External Oscillator with PLL Selected            */
319:                           CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
320:               #endif
321:                           break;
322:               
323:                       case 4: /* Secondary Oscillator Selected (SOCS)                     */
324:                           CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
004C3E  280000     MOV #0x8000, W0
004C40  200001     MOV #0x0, W1
325:                           break;
004C42  370010     BRA 0x4C64
326:               
327:                       case 5: /* Low Power Oscillator (LPOSC) Selected                    */
328:                           CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
004C44  279180     MOV #0x7918, W0
004C46  200001     MOV #0x0, W1
329:                           break;
004C48  37000D     BRA 0x4C64
330:               
331:                       case 6:
332:                           CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
004C4A  B80060     MUL.UU W0, #0, W0
333:                           break;
004C4C  37000B     BRA 0x4C64
334:               
335:                       case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
336:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
004C56  EB0180     CLR W3
004C58  212000     MOV #0x1200, W0
004C5A  2007A1     MOV #0x7A, W1
004C5C  07DCF0     RCALL 0x63E
337:                           break;
004C5E  370002     BRA 0x4C64
338:               
339:                       default:
340:                           CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
341:                           break;
342:                   }
343:               
344:                   CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
004C64  D10081     LSR W1, W1
004C66  D38000     RRC W0, W0
345:               
346:                   return (CPU_Clk_Frq); /* Return the operating frequency                           */
347:               }
004C68  060000     RETURN
348:               
349:               /*
350:                *********************************************************************************************************
351:                *                                     DISABLE ALL INTERRUPTS
352:                *
353:                * Description : This function disables all interrupts from the interrupt controller.
354:                *
355:                * Arguments   : none
356:                *********************************************************************************************************
357:                */
358:               
359:               void BSP_IntDisAll(void) {
360:               }
004C8A  060000     RETURN
361:               
362:               /*
363:                *********************************************************************************************************
364:                *                                         LED I/O INITIALIZATION
365:                *
366:                * Description : This function initializes the I/O Pins used by the onboard LEDs
367:                *
368:                * Arguments   : none
369:                *
370:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
371:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
372:                *********************************************************************************************************
373:                */
374:               
375:               void LED_Init(void) {
376:                   TRISFbits.TRISF0 = 0;
004C94  A902E8     BCLR TRISF, #0
377:               
378:                   LED_Off(); /* Shut off all LEDs                                        */
004C96  37FFFC     BRA LED_Off
379:               }
380:               
381:               /*
382:                *********************************************************************************************************
383:                *                                             LED ON
384:                *
385:                * Description : This function is used to control any or all the LEDs on the board.
386:                *
387:                * Arguments   : led    is the number of the LED to control
388:                *                      0    indicates that you want ALL the LEDs to be ON
389:                *                      1    turns ON LED1
390:                *                      2    turns ON LED2
391:                *                      ...
392:                *                      8    turns ON LED8
393:                *
394:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
395:                *********************************************************************************************************
396:                */
397:               
398:               void LED_On(void) {
399:                   PORTFbits.RF0 = 1;
004C8C  A802EA     BSET PORTF, #0
400:               }
004C8E  060000     RETURN
401:               
402:               /*
403:                *********************************************************************************************************
404:                *                                             LED OFF
405:                *
406:                * Description : This function is used to control any or all the LEDs on the board.
407:                *
408:                * Arguments   : led    is the number of the LED to turn OFF
409:                *                      0    indicates that you want ALL the LEDs to be OFF
410:                *                      1    turns OFF LED1
411:                *                      2    turns OFF LED2
412:                *                      .
413:                *                      8    turns OFF LED8
414:                *
415:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
416:                *********************************************************************************************************
417:                */
418:               
419:               void LED_Off(void) {
420:                   LATFbits.LATF0 = 0;
004C90  A902EC     BCLR LATF, #0
421:               }
004C92  060000     RETURN
422:               
423:               /*
424:                *********************************************************************************************************
425:                *                                             LED TOGGLE
426:                *
427:                * Description : This function is used to toggle any or all the LEDs on the board.
428:                *
429:                * Arguments   : led    is the number of the LED to control
430:                *                      0    indicates that you want to toggle ALL the LEDs
431:                *                      1    toggles LED1
432:                *                      2    toggles LED2
433:                *                      .
434:                *                      8    toggles LED8
435:                *
436:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
437:                *********************************************************************************************************
438:                */
439:               
440:               void LED_Toggle(void) {
441:                   LATFbits.LATF0 ^= 1;
004C98  801761     MOV LATF, W1
004C9A  EA8081     COM W1, W1
004C9C  6080E1     AND W1, #0x1, W1
004C9E  801760     MOV LATF, W0
004CA0  A10000     BCLR W0, #0
004CA2  708000     IOR W1, W0, W0
004CA4  881760     MOV W0, LATF
442:               }
004CA6  060000     RETURN
443:               
444:               /*
445:                *********************************************************************************************************
446:                *                                   OSProbe_TmrInit()
447:                *
448:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
449:                *               free running timer that is used to make time measurements.
450:                *
451:                * Arguments   : none
452:                *
453:                * Returns     : none
454:                *
455:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
456:                *                  from Tmr_TickInit().
457:                *********************************************************************************************************
458:                */
459:               
460:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
461:               
462:               void OSProbe_TmrInit(void) {
463:               #if OS_PROBE_TIMER_SEL == 3
464:                   T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
465:                   TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
466:                   PR3 = 0xFFFF; /* Set the period register to its maximum value             */
467:                   T3CON |= TON; /* Start the timer                                          */
468:               #endif
469:               
470:               #if OS_PROBE_TIMER_SEL == 5
471:                   T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
472:                   TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
473:                   PR5 = 0xFFFF; /* Set the period register to its maximum value             */
474:                   T5CON |= TON; /* Start the timer                                          */
475:               #endif
476:               }
477:               #endif
478:               
479:               /*
480:                *********************************************************************************************************
481:                *                                   OSProbe_TmrRd()
482:                *
483:                * Description : This function is called to read the current counts of a 16 bit free running timer.
484:                *
485:                * Arguments   : none
486:                *
487:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
488:                *********************************************************************************************************
489:                */
490:               
491:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
492:               
493:               CPU_INT32U OSProbe_TmrRd(void) {
494:               #if OS_PROBE_TIMER_SEL == 3
495:                   return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
496:               #endif
497:               
498:               #if OS_PROBE_TIMER_SEL == 5
499:                   return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
500:               #endif
501:               }
502:               #endif
503:               
504:               /*
505:                *********************************************************************************************************
506:                *                                       TICKER INITIALIZATION
507:                *
508:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
509:                *               interrupts every 1 to 100 mS).
510:                *
511:                * Arguments   : none
512:                *
513:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
514:                *               2) The timer resets to 0 after period register match interrupt is generated
515:                *********************************************************************************************************
516:                */
517:               
518:               static void Tmr_TickInit(void) {
519:                   CPU_INT32U tmr_frq;
520:                   CPU_INT16U cnts;
521:               
522:               
523:                   tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
004C6A  07FFD2     RCALL BSP_CPU_ClkFrq
524:                   cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
004C6C  203E82     MOV #0x3E8, W2
004C6E  200003     MOV #0x0, W3
004C70  07DCF5     RCALL 0x65C
004C72  E90080     DEC W0, W1
525:               
526:               #if BSP_OS_TMR_SEL == 2
527:                   T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
004C74  EF2110     CLR T2CON
528:                   TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
004C76  EF2106     CLR TMR2
529:                   PR2 = cnts; /* Set the period register                                  */
004C78  880861     MOV W1, PR2
530:                   IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
004C7A  28FFF0     MOV #0x8FFF, W0
004C7C  B620A6     AND IPC1
531:                   IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
004C7E  A8C0A7     BSET 0xA7, #6
532:                   IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
004C80  A9E084     BCLR IFS0, #7
533:                   IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
004C82  A8E094     BSET IEC0, #7
534:                   T2CON |= TON; /* Start the timer                                          */
004C84  280000     MOV #0x8000, W0
004C86  B72110     IOR T2CON
535:               #endif
536:               
537:               #if BSP_OS_TMR_SEL == 4
538:                   T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
539:                   TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
540:                   PR4 = cnts; /* Set the period register                                  */
541:                   IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
542:                   IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
543:                   IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
544:                   IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
545:                   T4CON |= TON; /* Start the timer                                          */
546:               #endif
547:               }
004C88  060000     RETURN
548:               
549:               /*
550:                *********************************************************************************************************
551:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
552:                *
553:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
554:                *********************************************************************************************************
555:                */
556:               
557:               void OS_Tick_ISR_Handler(void) {
558:               #if  BSP_OS_TMR_SEL == 2
559:                   IFS0 &= ~T2IF;
004CA8  A9E084     BCLR IFS0, #7
560:               #endif
561:               
562:               #if  BSP_OS_TMR_SEL == 4
563:                   IFS1 &= ~T41F;
564:               #endif
565:               
566:                   OSTimeTick();
004CAA  37E9CD     BRA OSTimeTick
567:               }
568:               
569:               //void OSC_Unlock_Sequence(void) {
570:                   //        //Place the new oscillator selection in W0
571:                   //        //OSCCONH (high byte) Unlock Sequence
572:                   //        asm("MOV #OSCCONH,w1");
573:                   //        asm("MOV #0x78, w2");
574:                   //        asm("MOV #0x9A, w3");
575:                   //        asm("MOV.b w2, [w1]");
576:                   //        asm("MOV.b w3, [w1]");
577:                   //        //Set new oscillator selection
578:                   //        asm("MOV.b WREG, OSCCONH");
579:                   //        //OSCCONL (low byte) unlock sequence
580:                   //        asm("MOV #OSCCONL,w1");
581:                   //        asm("MOV.b #0x01, w0");
582:                   //        asm("MOV #0x46, w2");
583:                   //        asm("MOV #0x57, w3");
584:                   //        asm("MOV.b w2, [w1]");
585:                   //        asm("MOV.b w3, [w1]");
586:                   //        //Start oscillator switch operation
587:                   //        asm("MOV.b w0, [w1]");
588:               //    __builtin_write_OSCCONH(0x03);
589:               //    __builtin_write_OSCCONL(0x02);
590:                   //    OSCCONbits.LOCK = 1;
591:               //    OSCCONbits.OSWEN = 1;
592:               //    OSCCONbits.LOCK = 0;
593:               //}
594:               //
595:               
596:               void OSCILLATOR_Initialize(void) {
597:                   // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
598:                   CLKDIV = 0x3000;
004CAC  230000     MOV #0x3000, W0
004CAE  883A20     MOV W0, CLKDIV
599:               
600:                   // Set the secondary oscillator    
601:                   OSCCONbits.SOSCEN = 1; //
004CB0  A82742     BSET OSCCON, #1
602:                   __builtin_write_OSCCONL(0x02);
004CB2  200571     MOV #0x57, W1
004CB4  200022     MOV #0x2, W2
004CB6  200460     MOV #0x46, W0
004CB8  207423     MOV #0x742, W3
004CBA  784980     MOV.B W0, [W3]
004CBC  784981     MOV.B W1, [W3]
004CBE  784982     MOV.B W2, [W3]
603:                   //    OSCCONbits.OSWEN = 1;
604:                   //    OSC_Unlock_Sequence(); //
605:               }
004CC0  060000     RETURN
606:               
607:               
608:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/UART3.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
6:                     TRISGbits.TRISG8 = 1; //
004EBC  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //
004EBE  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //
004EC0  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
004EC2  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1;//
004EC4  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //
12:                    //    TRISDbits.TRISD2 = 0; //
13:                
14:                    U3MODEbits.BRGH = 0; //1:16
004EC6  A96250     BCLR U3MODE, #3
15:                    U3BRG = 103; //19200 103; //16000000/9600/16-1
004EC8  200670     MOV #0x67, W0
004ECA  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //
004ECC  2FFF90     MOV #0xFFF9, W0
004ECE  B62250     AND U3MODE
17:                    U3MODEbits.STSEL = 0; //1
004ED0  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //
004ED2  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; // 4  1
004ED4  200C00     MOV #0xC0, W0
004ED6  B72252     IOR U3STA
22:                    IFS5bits.U3RXIF = 0; //  
004ED8  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
004EDA  2F8FF1     MOV #0xF8FF, W1
004EDC  800660     MOV IPC20, W0
004EDE  608080     AND W1, W0, W1
004EE0  206000     MOV #0x600, W0
004EE2  700001     IOR W0, W1, W0
004EE4  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //
004EE6  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
004EE8  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
004EEA  200700     MOV #0x70, W0
004EEC  B720CC     IOR IPC20
27:                    IEC5bits.U3ERIE = 1;
004EEE  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //  
004EF0  A84253     BSET 0x253, #2
29:                }
004EF2  060000     RETURN
30:                
31:                void UART3_Open(void) {
32:                    U3MODEbits.UARTEN = 1; //
004EF4  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //  
004EF6  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
004EF8  A8409E     BSET IEC5, #2
36:                }
004EFA  060000     RETURN
37:                
38:                void UART3_Close(void) {
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
004EFC  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //  
004EFE  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //    
004F00  A9E251     BCLR 0x251, #7
43:                }
004F02  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
46:                    U3TXREG = ch;
004F04  FB8000     ZE W0, W0
004F06  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
004F08  AB0253     BTST 0x253, #0
004F0A  32FFFE     BRA Z, 0x4F08
48:                }
004F0C  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
004F0E  BE9F88     MOV.D W8, [W15++]
004F10  781F8A     MOV W10, [W15++]
004F12  780400     MOV W0, W8
004F14  784501     MOV.B W1, W10
51:                    uint8_t bytes = 0;
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
004F16  780488     MOV W8, W9
004F18  370002     BRA 0x4F1E
004F1E  54C008     SUB.B W9, W8, W0
004F20  504F8A     SUB.B W0, W10, [W15]
004F22  39FFFB     BRA NC, 0x4F1A
53:                        UART3_SendChar(*(str + bytes));
004F1A  784039     MOV.B [W9++], W0
004F1C  07FFF3     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
57:                }
004F24  78400A     MOV.B W10, W0
004F26  78054F     MOV [--W15], W10
004F28  BE044F     MOV.D [--W15], W8
004F2A  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
004F2C  780080     MOV W0, W1
60:                    if (U3STAbits.URXDA) {
004F30  AB0252     BTST U3STA, #0
004F32  320003     BRA Z, 0x4F3A
61:                        *ch = U3RXREG;
004F34  8012B0     MOV U3RXREG, W0
004F36  784880     MOV.B W0, [W1]
62:                        return true;
004F38  B3C010     MOV.B #0x1, W0
63:                    } else
64:                        return false;
004F2E  EB4000     CLR.B W0
65:                }
004F3A  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//4
004F3C  781F88     MOV W8, [W15++]
004F3E  B3C048     MOV.B #0x4, W8
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//
004F48  3AFFFB     BRA NZ, 0x4F40
70:                        if (U3STAbits.URXDA) //
004F40  AB0252     BTST U3STA, #0
004F42  320001     BRA Z, 0x4F46
71:                            BufferWrite_UART3();
004F44  07FA0E     RCALL BufferWrite_UART3
004F46  E94408     DEC.B W8, W8
72:                }
004F4A  78044F     MOV [--W15], W8
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/UART2.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART2.h"
3:                 
4:                 void UART2_Init(void) {
5:                     //
6:                     TRISDbits.TRISD2 = 1; //
004E28  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //
004E2A  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //
9:                     //    TRISDbits.TRISD2 = 0; //
10:                
11:                    U2MODEbits.BRGH = 0; //1:16
004E2C  A96230     BCLR U2MODE, #3
12:                    U2BRG = 51; //19200 103; //16000000/9600/16-1
004E2E  200330     MOV #0x33, W0
004E30  8811C0     MOV W0, U2BRG
13:                    U2MODEbits.PDSEL = 00; //
004E32  2FFF90     MOV #0xFFF9, W0
004E34  B62230     AND U2MODE
14:                    U2MODEbits.STSEL = 0; //1
004E36  A90230     BCLR U2MODE, #0
15:                
16:                    U2MODEbits.UARTEN = 1; //
004E38  A8E231     BSET 0x231, #7
17:                
18:                    U2STAbits.UTXEN = 1; //  
004E3A  A84233     BSET 0x233, #2
19:                    U2STAbits.URXISEL = 3; // 4  1
004E3C  200C00     MOV #0xC0, W0
004E3E  B72232     IOR U2STA
20:                    IEC1bits.U2RXIE = 1; //
004E40  A8C097     BSET 0x97, #6
21:                    IFS1bits.U2RXIF = 0; //
004E42  A9C087     BCLR 0x87, #6
22:                    IEC4bits.U2ERIE = 1;
004E44  A8409C     BSET IEC4, #2
23:                    IFS4bits.U2ERIF = 0;
004E46  A9408C     BCLR IFS4, #2
24:                }
004E48  060000     RETURN
25:                
26:                void UART2_Open(void) {
27:                    U2MODEbits.UARTEN = 1; //
004E4A  A8E231     BSET 0x231, #7
28:                    U2STAbits.UTXEN = 1; //  
004E4C  A84233     BSET 0x233, #2
29:                    // IEC1bits.U2TXIE=1;
30:                    IEC1bits.U2RXIE = 1;
004E4E  A8C097     BSET 0x97, #6
31:                }
004E50  060000     RETURN
32:                
33:                void UART2_Close(void) {
34:                    // IEC1bits.U2TXIE=0;
35:                    IEC1bits.U2RXIE = 0;
004E52  A9C097     BCLR 0x97, #6
36:                    U2STAbits.UTXEN = 1; //  
004E54  A84233     BSET 0x233, #2
37:                    U2MODEbits.UARTEN = 0; //    
004E56  A9E231     BCLR 0x231, #7
38:                }
004E58  060000     RETURN
39:                
40:                void UART2_SendChar(uint8_t ch) {
41:                    U2TXREG = ch;
004E5A  FB8000     ZE W0, W0
004E5C  8811A0     MOV W0, U2TXREG
42:                    while (!U2STAbits.TRMT);
004E5E  AB0233     BTST 0x233, #0
004E60  32FFFE     BRA Z, 0x4E5E
43:                }
004E62  060000     RETURN
44:                
45:                uint8_t UART2_SendString(const uint8_t *str) {
004E64  BE9F88     MOV.D W8, [W15++]
004E66  780480     MOV W0, W9
46:                    uint8_t bytes = 0;
47:                    while (*str != '\0') {
004E68  780409     MOV W9, W8
004E6A  370001     BRA 0x4E6E
004E70  784038     MOV.B [W8++], W0
004E72  E00400     CP0.B W0
004E74  3AFFFB     BRA NZ, 0x4E6C
48:                        UART2_SendChar(*str++);
004E6C  07FFF6     RCALL UART2_SendChar
004E6E  544089     SUB.B W8, W9, W1
49:                        bytes++;
50:                    }
51:                    return bytes;
52:                }
004E76  784001     MOV.B W1, W0
004E78  BE044F     MOV.D [--W15], W8
004E7A  060000     RETURN
53:                
54:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
004E7C  BE9F88     MOV.D W8, [W15++]
004E7E  781F8A     MOV W10, [W15++]
004E80  780400     MOV W0, W8
004E82  784501     MOV.B W1, W10
55:                    uint8_t bytes = 0;
56:                    while (bytes < len) {
004E84  780488     MOV W8, W9
004E86  370002     BRA 0x4E8C
004E8C  54C008     SUB.B W9, W8, W0
004E8E  504F8A     SUB.B W0, W10, [W15]
004E90  39FFFB     BRA NC, 0x4E88
57:                        UART2_SendChar(*str++);
004E88  784039     MOV.B [W9++], W0
004E8A  07FFE7     RCALL UART2_SendChar
58:                        bytes++;
59:                    }
60:                    return bytes;
61:                }
004E92  78400A     MOV.B W10, W0
004E94  78054F     MOV [--W15], W10
004E96  BE044F     MOV.D [--W15], W8
004E98  060000     RETURN
62:                
63:                bool UART2_ReceiveChar(uint8_t * ch) {
004E9A  780080     MOV W0, W1
64:                    if (U2STAbits.URXDA) {
004E9E  AB0232     BTST U2STA, #0
004EA0  320003     BRA Z, 0x4EA8
65:                        *ch = U2RXREG;
004EA2  8011B0     MOV U2RXREG, W0
004EA4  784880     MOV.B W0, [W1]
66:                        return true;
004EA6  B3C010     MOV.B #0x1, W0
67:                    } else
68:                        return false;
004E9C  EB4000     CLR.B W0
69:                }
004EA8  060000     RETURN
70:                
71:                void U2Rx4Byte(void) {//4
004EAA  781F88     MOV W8, [W15++]
004EAC  B3C048     MOV.B #0x4, W8
72:                    uint8_t cnt;
73:                    for (cnt = 0; cnt < 4; cnt++)//
004EB6  3AFFFB     BRA NZ, 0x4EAE
74:                        if (U2STAbits.URXDA) //
004EAE  AB0232     BTST U2STA, #0
004EB0  320001     BRA Z, 0x4EB4
75:                            BufferWrite_UART2();
004EB2  07FA46     RCALL BufferWrite_UART2
004EB4  E94408     DEC.B W8, W8
76:                }
004EB8  78044F     MOV [--W15], W8
77:                
78:                
79:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/RTCC.c  --------------------------------------
1:                 #include "RTCC.h"
2:                 #include <xc.h>
3:                 
4:                 /*************************************
5:                 Function: RTC_Configuration 
6:                 Description: 
7:                 Input: 
8:                 Output: 
9:                  *************************************/
10:                void RTC_Init(void) {
003D32  FA0008     LNK #0x8
11:                    uint8_t rtcc_tmp[7] = {0x20, 0x17, 0x10, 0x6, 0x12, 0x30, 0x07};
003D34  5780E8     SUB W15, #0x8, W1
003D36  29E622     MOV #0x9E62, W2
003D38  090006     REPEAT #0x6
003D3A  7858B2     MOV.B [W2++], [W1++]
12:                    // Set the RTCWREN bit
13:                    __builtin_write_RTCWEN(); //unlock sequence
003D3C  200550     MOV #0x55, W0
003D3E  883B30     MOV W0, NVMKEY
003D40  200AA0     MOV #0xAA, W0
003D42  883B30     MOV W0, NVMKEY
003D44  A8A627     BSET 0x627, #5
14:                
15:                    RCFGCALbits.RTCPTR = 3; //RTCC 
003D46  203000     MOV #0x300, W0
003D48  B72626     IOR RCFGCAL
16:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
003D4A  97F81F     MOV.B [W15-7], W0
003D4C  FB8000     ZE W0, W0
003D4E  883120     MOV W0, RTCVAL
17:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
003D50  97F8AF     MOV.B [W15-6], W1
003D52  DD08C8     SL W1, #8, W1
003D54  97F83F     MOV.B [W15-5], W0
003D56  FB8000     ZE W0, W0
003D58  408000     ADD W1, W0, W0
003D5A  883120     MOV W0, RTCVAL
18:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
003D5C  97F84F     MOV.B [W15-4], W0
003D5E  FB8000     ZE W0, W0
003D60  883120     MOV W0, RTCVAL
19:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //  
003D62  97F8DF     MOV.B [W15-3], W1
003D64  DD08C8     SL W1, #8, W1
003D66  97F86F     MOV.B [W15-2], W0
003D68  FB8000     ZE W0, W0
003D6A  408000     ADD W1, W0, W0
003D6C  883120     MOV W0, RTCVAL
20:                
21:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
22:                    //    RTCPWC = 0x0000;
23:                
24:                    //    ALCFGRPTbits.AMASK = 0b0110; ////0b0011; -1s  0x11
25:                    //    ALCFGRPTbits.CHIME = 1; //1 =  ARPT<7:0>  00h  FFh
26:                    ALCFGRPTbits.ALRMEN = 0; //
003D6E  A9E623     BCLR 0x623, #7
27:                    ALCFGRPTbits.ALRMPTR = 2; //
003D70  2FCFF0     MOV #0xFCFF, W0
003D72  B60622     AND ALCFGRPT, WREG
003D74  A09000     BSET W0, #9
003D76  883110     MOV W0, ALCFGRPT
28:                    //        ALRMVAL = 0x0000; //none       
29:                    ALRMVAL = 0x0000; //month day 0001
003D78  EF2620     CLR ALRMVAL
30:                    ALRMVAL = 0x0000; //week hour
003D7A  EF2620     CLR ALRMVAL
31:                    ALRMVAL = 0x0000; //minute second  0000
003D7C  EF2620     CLR ALRMVAL
32:                    //    ALRMVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
33:                    //    ALRMVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
34:                    //    ALRMVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
35:                    //    ALRMVAL = (rtcc_tmp[5] << 8) + 0x25; //rtcc_tmp[6] ; //0x3050; //  
36:                    //    ALCFGRPTbits.ARPT=0;
37:                    //    ALCFGRPTbits.ALRMEN = 1; //  ARPT<7:0> = 00  CHIME = 0     
38:                
39:                    // ALRMEN enabled; ARPT 0; AMASK Every Second; CHIME enabled; ALRMPTR MIN_SEC; 
40:                    ALCFGRPT = 0xD800; //    every day once 
003D7E  2D8000     MOV #0xD800, W0
003D80  883110     MOV W0, ALCFGRPT
41:                    //    ALCFGRPT = 0xC800;
42:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
43:                    RTCPWC = 0x0000;
003D82  EF2628     CLR RTCPWC
44:                    IPC15bits.RTCIP = 6;
003D84  2F8FF1     MOV #0xF8FF, W1
003D86  800610     MOV IPC15, W0
003D88  608080     AND W1, W0, W1
003D8A  206000     MOV #0x600, W0
003D8C  700001     IOR W0, W1, W0
003D8E  880610     MOV W0, IPC15
45:                    IFS3bits.RTCIF = 0; //
003D90  A9C08B     BCLR 0x8B, #6
46:                    IEC3bits.RTCIE = 1; // =1
003D92  A8C09B     BSET 0x9B, #6
47:                
48:                    RCFGCALbits.RTCEN = 1; // RTCC 
003D94  A8E627     BSET 0x627, #7
49:                    RCFGCALbits.RTCWREN = 0; //RTCC
003D96  A9A627     BCLR 0x627, #5
50:                }
003D98  FA8000     ULNK
003D9A  060000     RETURN
51:                
52:                void RTC_Set_Alarm(struct tm initialTime) {
003D9C  FA0000     LNK #0x0
003D9E  781F88     MOV W8, [W15++]
53:                    // ALRMEN = 0RTCSYNC = 0  ALCFGRPT  CHIME 
54:                //    __builtin_write_RTCWEN(); //unlock sequence
55:                    ALCFGRPTbits.ALRMEN = 0; //
003DA0  A9E623     BCLR 0x623, #7
56:                    while (RCFGCALbits.RTCSYNC); //
003DA2  AB8627     BTST 0x627, #4
003DA4  3AFFFE     BRA NZ, 0x3DA2
57:                    ALCFGRPTbits.ALRMPTR = 2; //
003DA6  2FCFF0     MOV #0xFCFF, W0
003DA8  B60622     AND ALCFGRPT, WREG
003DAA  A09000     BSET W0, #9
003DAC  883110     MOV W0, ALCFGRPT
58:                    ALRMVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday);
003DAE  97B07F     MOV [W15-18], W0
003DB0  070657     RCALL DCH
003DB2  780400     MOV W0, W8
003DB4  97B06F     MOV [W15-20], W0
003DB6  070654     RCALL DCH
003DB8  DD4448     SL W8, #8, W8
003DBA  440400     ADD W8, W0, W8
003DBC  883108     MOV W8, ALRMVAL
59:                    ALRMVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour);
003DBE  97B81F     MOV [W15-14], W0
003DC0  07064F     RCALL DCH
003DC2  780400     MOV W0, W8
003DC4  97B05F     MOV [W15-22], W0
003DC6  07064C     RCALL DCH
003DC8  DD4448     SL W8, #8, W8
003DCA  440400     ADD W8, W0, W8
003DCC  883108     MOV W8, ALRMVAL
60:                    ALRMVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec);
003DCE  97B04F     MOV [W15-24], W0
003DD0  070647     RCALL DCH
003DD2  780400     MOV W0, W8
003DD4  97B03F     MOV [W15-26], W0
003DD6  070644     RCALL DCH
003DD8  DD4448     SL W8, #8, W8
003DDA  440400     ADD W8, W0, W8
003DDC  883108     MOV W8, ALRMVAL
61:                    ALCFGRPTbits.ALRMEN = 1; //
003DDE  A8E623     BSET 0x623, #7
62:                //    RCFGCALbits.RTCWREN = 0; //RTCC
63:                }
003DE0  78044F     MOV [--W15], W8
003DE2  FA8000     ULNK
003DE4  060000     RETURN
64:                
65:                /*************************************
66:                Function: RTC_ReadTime 
67:                Description: 
68:                Input: 4u16 
69:                Output: 
70:                 *************************************/
71:                bool RTC_Read_Time(struct tm*currentTime) {
003DE6  780300     MOV W0, W6
72:                    uint16_t time_tmp;
73:                    if (RCFGCALbits.RTCSYNC)//
003DEA  AB8627     BTST 0x627, #4
003DEC  3A0045     BRA NZ, 0x3E78
74:                        return false;
003DE8  EB4080     CLR.B W1
75:                
76:                    __builtin_write_RTCWEN(); // Set the RTCWREN bit
003DEE  200551     MOV #0x55, W1
003DF0  883B31     MOV W1, NVMKEY
003DF2  200AA1     MOV #0xAA, W1
003DF4  883B31     MOV W1, NVMKEY
003DF6  A8A627     BSET 0x627, #5
77:                
78:                    RCFGCALbits.RTCPTR = 3; //RTCC 
003DF8  203000     MOV #0x300, W0
003DFA  B72626     IOR RCFGCAL
79:                    time_tmp = RTCVAL; // 
003DFC  803121     MOV RTCVAL, W1
80:                    currentTime->tm_year = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
003DFE  780101     MOV W1, W2
003E00  B20F02     AND #0xF0, W2
003E02  DE1144     LSR W2, #4, W2
003E04  B9116A     MUL.SU W2, #10, W2
003E06  6080EF     AND W1, #0xF, W1
003E08  408082     ADD W1, W2, W1
003E0A  980351     MOV W1, [W6+10]
81:                    RCFGCALbits.RTCPTR = 2;
003E0C  2FCFF2     MOV #0xFCFF, W2
003E0E  803130     MOV RCFGCAL, W0
003E10  610080     AND W2, W0, W1
003E12  A09001     BSET W1, #9
003E14  883131     MOV W1, RCFGCAL
82:                    time_tmp = RTCVAL; //
003E16  803121     MOV RTCVAL, W1
83:                    currentTime->tm_mon = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
003E18  DE09C8     LSR W1, #8, W3
003E1A  6181EF     AND W3, #0xF, W3
003E1C  DE0A4C     LSR W1, #12, W4
003E1E  B9226A     MUL.SU W4, #10, W4
003E20  418184     ADD W3, W4, W3
003E22  980343     MOV W3, [W6+8]
84:                    currentTime->tm_mday = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
003E24  780201     MOV W1, W4
003E26  B20F04     AND #0xF0, W4
003E28  DE2244     LSR W4, #4, W4
003E2A  B9226A     MUL.SU W4, #10, W4
003E2C  6080EF     AND W1, #0xF, W1
003E2E  408084     ADD W1, W4, W1
003E30  980331     MOV W1, [W6+6]
85:                    RCFGCALbits.RTCPTR = 1;
003E32  803130     MOV RCFGCAL, W0
003E34  610080     AND W2, W0, W1
003E36  A08001     BSET W1, #8
003E38  883131     MOV W1, RCFGCAL
86:                    time_tmp = RTCVAL; //
003E3A  803121     MOV RTCVAL, W1
87:                    currentTime->tm_wday = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
003E3C  DE09C8     LSR W1, #8, W3
003E3E  6181EF     AND W3, #0xF, W3
003E40  DE0A4C     LSR W1, #12, W4
003E42  B9226A     MUL.SU W4, #10, W4
003E44  418184     ADD W3, W4, W3
003E46  980363     MOV W3, [W6+12]
88:                    currentTime->tm_hour = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
003E48  780201     MOV W1, W4
003E4A  B20F04     AND #0xF0, W4
003E4C  DE2244     LSR W4, #4, W4
003E4E  B9226A     MUL.SU W4, #10, W4
003E50  6080EF     AND W1, #0xF, W1
003E52  408084     ADD W1, W4, W1
003E54  980321     MOV W1, [W6+4]
89:                    RCFGCALbits.RTCPTR = 0;
003E56  206260     MOV #0x626, W0
003E58  610810     AND W2, [W0], [W0]
90:                    time_tmp = RTCVAL; //
003E5A  803121     MOV RTCVAL, W1
91:                    currentTime->tm_min = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
003E5C  DE0A48     LSR W1, #8, W4
003E5E  62026F     AND W4, #0xF, W4
003E60  DE094C     LSR W1, #12, W2
003E62  B9116A     MUL.SU W2, #10, W2
003E64  420102     ADD W4, W2, W2
003E66  980312     MOV W2, [W6+2]
92:                    currentTime->tm_sec = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
003E68  780101     MOV W1, W2
003E6A  B20F02     AND #0xF0, W2
003E6C  DE1144     LSR W2, #4, W2
003E6E  B9116A     MUL.SU W2, #10, W2
003E70  6080EF     AND W1, #0xF, W1
003E72  408B02     ADD W1, W2, [W6]
93:                    RCFGCALbits.RTCWREN = 0;
003E74  A9A627     BCLR 0x627, #5
94:                
95:                    return true;
003E76  B3C011     MOV.B #0x1, W1
96:                }
003E78  784001     MOV.B W1, W0
003E7A  060000     RETURN
97:                
98:                /*************************************
99:                Function: Check_RTCC 
100:               Description:  RTCC
101:               Input: 6u8
102:               Output: 
103:                *************************************/
104:               void RTC_Set_Time(struct tm initialTime) {
003E7C  FA0000     LNK #0x0
003E7E  781F88     MOV W8, [W15++]
105:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
003E80  200550     MOV #0x55, W0
003E82  883B30     MOV W0, NVMKEY
003E84  200AA0     MOV #0xAA, W0
003E86  883B30     MOV W0, NVMKEY
003E88  A8A627     BSET 0x627, #5
106:                   RCFGCALbits.RTCEN = 0; //Close RTCC
003E8A  A9E627     BCLR 0x627, #7
107:               
108:                   IFS3bits.RTCIF = false;
003E8C  A9C08B     BCLR 0x8B, #6
109:                   IEC3bits.RTCIE = 0;
003E8E  A9C09B     BCLR 0x9B, #6
110:               
111:                   // set RTCC initial time
112:                   RCFGCALbits.RTCPTR = 3; // start the sequence
003E90  203000     MOV #0x300, W0
003E92  B72626     IOR RCFGCAL
113:                   RTCVAL = DCH(initialTime.tm_year); // YEAR
003E94  97B80F     MOV [W15-16], W0
003E96  0705E4     RCALL DCH
003E98  883120     MOV W0, RTCVAL
114:                   RTCVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday); // MONTH-1/DAY-1
003E9A  97B07F     MOV [W15-18], W0
003E9C  0705E1     RCALL DCH
003E9E  780400     MOV W0, W8
003EA0  97B06F     MOV [W15-20], W0
003EA2  0705DE     RCALL DCH
003EA4  DD4448     SL W8, #8, W8
003EA6  440400     ADD W8, W0, W8
003EA8  883128     MOV W8, RTCVAL
115:                   RTCVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour); // WEEKDAY/HOURS
003EAA  97B81F     MOV [W15-14], W0
003EAC  0705D9     RCALL DCH
003EAE  780400     MOV W0, W8
003EB0  97B05F     MOV [W15-22], W0
003EB2  0705D6     RCALL DCH
003EB4  DD4448     SL W8, #8, W8
003EB6  440400     ADD W8, W0, W8
003EB8  883128     MOV W8, RTCVAL
116:                   RTCVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec); // MINUTES/SECONDS   
003EBA  97B04F     MOV [W15-24], W0
003EBC  0705D1     RCALL DCH
003EBE  780400     MOV W0, W8
003EC0  97B03F     MOV [W15-26], W0
003EC2  0705CE     RCALL DCH
003EC4  DD4448     SL W8, #8, W8
003EC6  440400     ADD W8, W0, W8
003EC8  883128     MOV W8, RTCVAL
117:               
118:                   // Enable RTCC, clear RTCWREN         
119:                   RCFGCALbits.RTCEN = 1;
003ECA  A8E627     BSET 0x627, #7
120:                   RCFGCALbits.RTCWREN = 0;
003ECC  A9A627     BCLR 0x627, #5
121:               
122:                   IEC3bits.RTCIE = 1;
003ECE  A8C09B     BSET 0x9B, #6
123:               }
003ED0  78044F     MOV [--W15], W8
003ED2  FA8000     ULNK
003ED4  060000     RETURN
124:               
125:               /*************************************
126:               Function: StartRTCC 
127:               Description: 
128:               Input: 
129:               Output: 
130:                *************************************/
131:               //void StartRTCC(void) {
132:               //
133:               //    IEC3bits.RTCIE = 1; //
134:               //    ALCFGRPTbits.ALRMEN = 1;
135:               //    RCFGCALbits.RTCEN = 1; //RTCC
136:               //}
137:               
138:               /*************************************
139:               Function: StopRTCC 
140:               Description: 
141:               Input: 
142:               Output: 
143:                *************************************/
144:               //void StopRTCC(void) {
145:               //    IEC3bits.RTCIE = 0; // 
146:               //    ALCFGRPTbits.ALRMEN = 0;
147:               //    RCFGCALbits.RTCEN = 0; // RTCC 
148:               //}
149:               
150:               void PrintTime(void) {
003ED6  FA0026     LNK #0x26
151:                   struct tm time1;
152:                   uint8_t sendstr[20] = {"1234578901234567890"};
003ED8  29E4E0     MOV #0x9E4E, W0
003EDA  5780F4     SUB W15, #0x14, W1
003EDC  090013     REPEAT #0x13
003EDE  7858B0     MOV.B [W0++], [W1++]
003EE0  B10140     SUB #0x14, W0
153:                   if (RTC_Read_Time(&time1)) {
003EE2  2FFDA0     MOV #0xFFDA, W0
003EE4  40000F     ADD W0, W15, W0
003EE6  07FF7F     RCALL RTC_Read_Time
003EE8  E00400     CP0.B W0
003EEA  32003C     BRA Z, 0x3F64
154:                       sendstr[0] = time1.tm_year / 10 + 0x30;
003EEC  97B02F     MOV [W15-28], W0
003EEE  2000A2     MOV #0xA, W2
003EF0  090011     REPEAT #0x11
003EF2  D80002     DIV.SW W0, W2
003EF4  B04300     ADD.B #0x30, W0
003EF6  9FEFC0     MOV.B W0, [W15-20]
155:                       sendstr[1] = time1.tm_year % 10 + 0x30;
003EF8  B3C303     MOV.B #0x30, W3
003EFA  40C003     ADD.B W1, W3, W0
003EFC  9FEFD0     MOV.B W0, [W15-19]
156:                       sendstr[2] = '/';
003EFE  B3C2F4     MOV.B #0x2F, W4
003F00  9FEFE4     MOV.B W4, [W15-18]
157:                       sendstr[3] = time1.tm_mon / 10 + 0x30;
003F02  97B09F     MOV [W15-30], W1
003F04  090011     REPEAT #0x11
003F06  D80082     DIV.SW W1, W2
003F08  780180     MOV W0, W3
003F0A  B04303     ADD.B #0x30, W3
003F0C  9FEFF3     MOV.B W3, [W15-17]
158:                       sendstr[4] = time1.tm_mon % 10 + 0x30;
003F0E  B04301     ADD.B #0x30, W1
003F10  9FF781     MOV.B W1, [W15-16]
159:                       sendstr[5] = '/';
003F12  9FF794     MOV.B W4, [W15-15]
160:                       sendstr[6] = time1.tm_mday / 10 + 0x30;
003F14  97B00F     MOV [W15-32], W0
003F16  090011     REPEAT #0x11
003F18  D80002     DIV.SW W0, W2
003F1A  B04300     ADD.B #0x30, W0
003F1C  9FF7A0     MOV.B W0, [W15-14]
161:                       sendstr[7] = time1.tm_mday % 10 + 0x30;
003F1E  B3C303     MOV.B #0x30, W3
003F20  40C003     ADD.B W1, W3, W0
003F22  9FF7B0     MOV.B W0, [W15-13]
162:                       sendstr[8] = '-';
003F24  B3C2D0     MOV.B #0x2D, W0
003F26  9FF7C0     MOV.B W0, [W15-12]
163:                       sendstr[9] = time1.tm_hour / 10 + 0x30;
003F28  97A87F     MOV [W15-34], W0
003F2A  090011     REPEAT #0x11
003F2C  D80002     DIV.SW W0, W2
003F2E  404003     ADD.B W0, W3, W0
003F30  9FF7D0     MOV.B W0, [W15-11]
164:                       sendstr[10] = time1.tm_hour % 10 + 0x30;
003F32  40C003     ADD.B W1, W3, W0
003F34  9FF7E0     MOV.B W0, [W15-10]
165:                       sendstr[11] = ':';
003F36  42426B     ADD.B W4, #0xB, W4
003F38  9FF7F4     MOV.B W4, [W15-9]
166:                       sendstr[12] = time1.tm_min / 10 + 0x30;
003F3A  97A8EF     MOV [W15-36], W1
003F3C  090011     REPEAT #0x11
003F3E  D80082     DIV.SW W1, W2
003F40  780180     MOV W0, W3
003F42  B04303     ADD.B #0x30, W3
003F44  9FFF83     MOV.B W3, [W15-8]
167:                       sendstr[13] = time1.tm_min % 10 + 0x30;
003F46  B04301     ADD.B #0x30, W1
003F48  9FFF91     MOV.B W1, [W15-7]
168:                       sendstr[14] = ':';
003F4A  9FFFA4     MOV.B W4, [W15-6]
169:                       sendstr[15] = time1.tm_sec / 10 + 0x30;
003F4C  97A85F     MOV [W15-38], W0
003F4E  090011     REPEAT #0x11
003F50  D80002     DIV.SW W0, W2
003F52  B04300     ADD.B #0x30, W0
003F54  9FFFB0     MOV.B W0, [W15-5]
170:                       sendstr[16] = time1.tm_sec % 10 + 0x30;
003F56  B3C303     MOV.B #0x30, W3
003F58  40C003     ADD.B W1, W3, W0
003F5A  9FFFC0     MOV.B W0, [W15-4]
171:                       sendstr[17] = '\n';
003F5C  9FFFD2     MOV.B W2, [W15-3]
172:                       //        sendstr[18] = '\n';
173:                       //        sendstr[18] = '\0';
174:                       RS485SendString(sendstr, 18);
003F5E  B3C121     MOV.B #0x12, W1
003F60  578074     SUB W15, #0x14, W0
003F62  07084A     RCALL RS485SendString
175:                       //        OSTimeDlyHMSM();
176:                   }
177:               }
003F64  FA8000     ULNK
178:               
179:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485
13:                Input:  
14:                Output: 
15:                 *************************************/
16:                void RS485_Init(void) {
17:                    RS485_TRIS = 0; // 485_CON
004FC8  A942C9     BCLR 0x2C9, #2
18:                    RS485_IN_TRIS = 1; ///
004FCA  A802C9     BSET 0x2C9, #0
19:                    RS485_OUT_TRIS = 0; //
004FCC  A922C9     BCLR 0x2C9, #1
20:                    ANSBbits.ANSB8 = 1; //
004FCE  A804E3     BSET 0x4E3, #0
21:                    //    ANSBbits.ANSB9 = 1;
22:                
23:                    U1MODEbits.BRGH = 0; //16
004FD0  A96220     BCLR U1MODE, #3
24:                    U1BRG = 103; //16000000/9600/16-1
004FD2  200670     MOV #0x67, W0
004FD4  881140     MOV W0, U1BRG
25:                
26:                    U1MODEbits.PDSEL = 00; //
004FD6  2FFF90     MOV #0xFFF9, W0
004FD8  B62220     AND U1MODE
27:                    U1MODEbits.STSEL = 0; //1
004FDA  A90220     BCLR U1MODE, #0
28:                    U1MODEbits.UARTEN = 1; //
004FDC  A8E221     BSET 0x221, #7
29:                
30:                    U1STAbits.UTXEN = 1; //  
004FDE  A84223     BSET 0x223, #2
31:                    //    U1STAbits.URXISEL = 3; // 4  1
32:                    //    IEC0bits.U1RXIE = 1; //
33:                    //    IFS0bits.U1RXIF = 0; //
34:                    //    IEC4bits.U1ERIE = 1; //
35:                    //    IFS4bits.U1ERIF = 0; //
36:                }
004FE0  060000     RETURN
37:                
38:                //void OpenAwake485(void) {//CN6
39:                //    RS485_RX_IN;
40:                //    CNEN1bits.CN6IE = 1; //RX1
41:                //}
42:                
43:                //void CloseAwake485(void) {
44:                //    CNEN1bits.CN6IE = 0;
45:                //}
46:                
47:                /*************************************
48:                Function: RS485_Send  
49:                Description: 485
50:                Input:  
51:                Output: 1:
52:                 *************************************/
53:                void RS485SendChar(const uint8_t dat) {
54:                    RS485_CON = 1; //
004FE2  A842CD     BSET 0x2CD, #2
55:                    //    OSTimeDlyHMSM(0, 0, 0, 30);
56:                    U1TXREG = dat;
004FE4  FB8000     ZE W0, W0
004FE6  881120     MOV W0, U1TXREG
57:                    while (!U1STAbits.TRMT); //while (!U2STAbits.TRMT);
004FE8  AB0223     BTST 0x223, #0
004FEA  32FFFE     BRA Z, 0x4FE8
58:                    OSTimeDlyHMSM(0, 0, 0, 10);
004FEC  2000A3     MOV #0xA, W3
004FEE  EB0100     CLR W2
004FF0  B80060     MUL.UU W0, #0, W0
004FF2  07FDC6     RCALL OSTimeDlyHMSM
59:                    RS485_CON = 0; //
004FF4  A942CD     BCLR 0x2CD, #2
60:                    //    OSTimeDlyHMSM(0, 0, 0, 1);
61:                }
004FF6  060000     RETURN
62:                
63:                /*************************************
64:                Function: RS485_SendString 
65:                Description: 485
66:                Input:   
67:                Output: 
68:                 *************************************/
69:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
004FF8  BE9F88     MOV.D W8, [W15++]
004FFA  780400     MOV W0, W8
004FFC  784481     MOV.B W1, W9
70:                    uint8_t count = 0;
71:                
72:                    RS485_CON = 1; //    
004FFE  A842CD     BSET 0x2CD, #2
73:                    OSTimeDlyHMSM(0, 0, 0, 100);
005000  200643     MOV #0x64, W3
005002  EB0100     CLR W2
005004  B80060     MUL.UU W0, #0, W0
005006  07FDBC     RCALL OSTimeDlyHMSM
74:                    while (count < bytes) {
005008  780008     MOV W8, W0
00500A  370004     BRA 0x5014
005014  504088     SUB.B W0, W8, W1
005016  50CF89     SUB.B W1, W9, [W15]
005018  39FFF9     BRA NC, 0x500C
75:                        U1TXREG = *(dat + count);
00500C  FB80B0     ZE [W0++], W1
00500E  881121     MOV W1, U1TXREG
76:                        while (!U1STAbits.TRMT);
005010  AB0223     BTST 0x223, #0
005012  32FFFE     BRA Z, 0x5010
77:                        count++;
78:                    }
79:                    OSTimeDlyHMSM(0, 0, 0, 100);
00501A  200643     MOV #0x64, W3
00501C  EB0100     CLR W2
00501E  B80060     MUL.UU W0, #0, W0
005020  07FDAF     RCALL OSTimeDlyHMSM
80:                    RS485_CON = 0; //
005022  A942CD     BCLR 0x2CD, #2
81:                    OSTimeDlyHMSM(0, 0, 0, 1);
005024  200013     MOV #0x1, W3
005026  EB0100     CLR W2
005028  B80060     MUL.UU W0, #0, W0
00502A  07FDAA     RCALL OSTimeDlyHMSM
82:                }
00502C  BE044F     MOV.D [--W15], W8
00502E  060000     RETURN
83:                
84:                /*************************************
85:                Function: OpenRS485 
86:                Description: 485
87:                Input:   
88:                Output: 
89:                 *************************************/
90:                void OpenRS485(void) {
91:                    IEC0bits.U1RXIE = 1;
005030  A86095     BSET 0x95, #3
92:                    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled ??????????
005032  A84223     BSET 0x223, #2
93:                }
005034  060000     RETURN
94:                
95:                /*************************************
96:                Function: RS485_SendString 
97:                Description: 485
98:                Input:   
99:                Output: 
100:                *************************************/
101:               void CloseRS485(void) {
102:                   IEC0bits.U1RXIE = 0;
005036  A96095     BCLR 0x95, #3
103:                   U1STAbits.UTXEN = 0; //UARTx transmitter is enabled ??????????
005038  A94223     BCLR 0x223, #2
104:               }
00503A  060000     RETURN
105:               /*************************************
106:               Function: RS485_test 
107:               Description: 485
108:               Input:  
109:               Output: 
110:                *************************************/
111:               //void RS485test(void)
112:               //{
113:               //    uint8_t dat='6';
114:               
115:               //RS485Send('T');
116:               //    if(!RS485Receive(&dat))
117:               //    {
118:               //        RS485Send(dat);
119:               //        RS485Send('T');
120:               //    }
121:               //}
122:               
123:               /*************************************
124:               Function: RS485_Receive  
125:               Description: 485
126:               Input:  
127:               Output: 1
128:                ************************************
129:               bool RS485Receive(uint8_t* dat) {
130:               
131:                   bool b = true;
132:               //    uint8_t timeCount;
133:                   
134:               //    RS485_CON = 0; //
135:               
136:                   if (U1STAbits.OERR)
137:                       U1STAbits.OERR = 0;
138:                   
139:               //    gT23Count=0;
140:               //    T2CONbits.TON = 1;// 
141:                  
142:                   while (!U1STAbits.URXDA) //
143:                   {
144:               //        timeCount = gT23Count;
145:               //        if( T100msIsOver(timeCount,10) ) {//1s
146:               //            b = false;
147:               //            break;
148:               //        }
149:                   }
150:               //    T2CONbits.TON = 0;//
151:               //    gT23Count=0;           //
152:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
153:               //    TMR2 = 0x0000;
154:                   
155:               //    if(b)
156:               //        *dat = U1RXREG;
157:               
158:                   return b;
159:               }*/
160:               
161:               
162:               
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/PPS.c  ---------------------------------------
1:                 /* 
2:                  * File:   PPS.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 2017620, 1:52
6:                  */
7:                 #include <xc.h>
8:                 
9:                 void PPSInit(void) {
10:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
0050A2  200BF0     MOV #0xBF, W0
0050A4  B60742     AND OSCCON, WREG
0050A6  200462     MOV #0x46, W2
0050A8  200573     MOV #0x57, W3
0050AA  207421     MOV #0x742, W1
0050AC  784882     MOV.B W2, [W1]
0050AE  784883     MOV.B W3, [W1]
0050B0  784880     MOV.B W0, [W1]
11:                    //    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
12:                    //    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
13:                    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
0050B2  2C0FF4     MOV #0xC0FF, W4
0050B4  803641     MOV RPOR4, W1
0050B6  620001     AND W4, W1, W0
0050B8  B33000     IOR #0x300, W0
0050BA  883640     MOV W0, RPOR4
14:                    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
0050BC  2FFC00     MOV #0xFFC0, W0
0050BE  803525     MOV RPINR18, W5
0050C0  600085     AND W0, W5, W1
0050C2  A03001     BSET W1, #3
0050C4  883521     MOV W1, RPINR18
15:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
0050C6  8036B5     MOV RPOR11, W5
0050C8  600085     AND W0, W5, W1
0050CA  B30051     IOR #0x5, W1
0050CC  8836B1     MOV W1, RPOR11
16:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX 
0050CE  803535     MOV RPINR19, W5
0050D0  600085     AND W0, W5, W1
0050D2  B30171     IOR #0x17, W1
0050D4  883531     MOV W1, RPINR19
17:                    RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
0050D6  B606DA     AND RPOR13, WREG
0050D8  B301C0     IOR #0x1C, W0
0050DA  8836D0     MOV W0, RPOR13
18:                    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
0050DC  803510     MOV RPINR17, W0
0050DE  620200     AND W4, W0, W4
0050E0  213000     MOV #0x1300, W0
0050E2  700004     IOR W0, W4, W0
0050E4  883510     MOV W0, RPINR17
19:                    //    RPINR3bits.
20:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
21:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
22:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
0050E6  803A10     MOV OSCCON, W0
0050E8  A06000     BSET W0, #6
0050EA  207421     MOV #0x742, W1
0050EC  784882     MOV.B W2, [W1]
0050EE  784883     MOV.B W3, [W1]
0050F0  784880     MOV.B W0, [W1]
23:                }
0050F2  060000     RETURN
24:                
25:                //RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
26:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX
27:                
28:                
29:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 201666, 8:48
6:                  */
7:                 //#include "UART2.h"
8:                 //#include "RS485.h"
9:                 //#include "UART3.h"
10:                #include "SerialBuffer.h"
11:                #include "includes.h"
12:                #include "stdbool.h"
13:                #include "stdio.h"
14:                #include "RTCC.h"
15:                
16:                extern OS_EVENT *sem_receive_pressure, *sem_set_alarm;
17:                extern volatile uint8_t i2c1_state;
18:                extern I2C1_Buffer i2c_buf;
19:                //extern OS_FLAG_GRP *sem_F;
20:                ///*************************************
21:                //Function:  
22:                //Description: 
23:                //Input:  
24:                //Output: 
25:                // *************************************/
26:                //void __attribute__((__interrupt__, __auto_psv__)) _RTCCInterrupt(void) {
27:                //    OSCChange(0x00);
28:                //    gTimeCount.timeAlarm++; //
29:                //    gTimeCount.timeGprs++;
30:                //    gTimeCount.timeMp++;
31:                //
32:                //    if ((gTimeCount.timeMp >= miotArgs.timemp - SettingSampleTime)&&(!FLagArgbits.PulseTimeFlag)) {//16
33:                //        FLagArgbits.T1CountFlag = 1;
34:                //        T1CONbits.TON = 1;
35:                //    }
36:                //
37:                //    if (gTimeCount.timeMp >= miotArgs.timemp) {//FRAM
38:                //        gTimeCount.timeMp = 0;
39:                //        FLagArgbits.PulseTimeFlag = 0;
40:                //        FLagArgbits.T1CountFlag = 0; //
41:                //        T1CONbits.TON = 0; //1
42:                //        StartTime4();
43:                //        IFS1bits.T4IF = 1; //T4CONbits.TON = 1;
44:                //    }
45:                //
46:                //    if (gTimeCount.timeGprs >= miotArgs.timegprs) {//GPRS
47:                //        gTimeCount.timeGprs = 0;
48:                //        FLagArgbits.tgprsFlag = 1;
49:                //    }
50:                //
51:                //    //    FLagArgbits.LowPowerFlag = !BAT_DEC; //
52:                //    if (gTimeCount.timeAlarm >= miotArgs.timealarm) {
53:                //        float getvoltage = 0;
54:                //        gTimeCount.timeAlarm = 0;
55:                //        GetVoltage(&getvoltage);
56:                //        if (miotArgs.AlarmVoltage > getvoltage) {
57:                //            FLagArgbits.LowPoweralarmFlag = 1; 
58:                //        }
59:                //    }
60:                //    if (FLagArgbits.tgprsFlag || FLagArgbits.LowPoweralarmFlag)
61:                //        FLagArgbits.SleepExitFlag = 1;
62:                //    else
63:                //        FLagArgbits.SleepExitFlag = 0;
64:                //    IFS3bits.RTCIF = 0; //clear RTC      
65:                //}
66:                
67:                /* Function:
68:                    void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
69:                
70:                  Summary:
71:                    Interrupt Service Routine for the RTCC Peripheral
72:                
73:                  Description:
74:                    This is the interrupt service routine for the RTCC peripheral. Add in code if 
75:                    required in the ISR. 
76:                 */
77:                
78:                void __attribute__((interrupt, no_auto_psv)) _ISR _RTCCInterrupt(void) {
00032C  F80036     PUSH RCOUNT
00032E  BE9F80     MOV.D W0, [W15++]
000330  BE9F82     MOV.D W2, [W15++]
000332  BE9F84     MOV.D W4, [W15++]
000334  BE9F86     MOV.D W6, [W15++]
79:                    /* TODO : Add interrupt handling code */
80:                    OSIntEnter();
000336  070E1C     RCALL OSIntEnter
81:                    //    //    OSSemPost(sem_set_alarm);//notes :sem can't find here
82:                    IFS3bits.RTCIF = false;
000338  A9C08B     BCLR 0x8B, #6
83:                    OSIntExit();
00033A  070E23     RCALL OSIntExit
84:                    OSSemPost(sem_set_alarm);
00033C  804190     MOV sem_set_alarm, W0
00033E  071B7C     RCALL OSSemPost
85:                }
000340  BE034F     MOV.D [--W15], W6
000342  BE024F     MOV.D [--W15], W4
000344  BE014F     MOV.D [--W15], W2
000346  BE004F     MOV.D [--W15], W0
000348  F90036     POP RCOUNT
00034A  064000     RETFIE
86:                
87:                /*************************************
88:                Function: 0
89:                Description: 
90:                Input:  
91:                Output: 
92:                 *************************************/
93:                void __attribute__((interrupt, no_auto_psv))_ISR _INT0Interrupt(void) {
00034C  F80036     PUSH RCOUNT
00034E  BE9F80     MOV.D W0, [W15++]
000350  BE9F82     MOV.D W2, [W15++]
000352  BE9F84     MOV.D W4, [W15++]
000354  BE9F86     MOV.D W6, [W15++]
94:                    OSIntEnter();
000356  070E0C     RCALL OSIntEnter
95:                    IFS0bits.INT0IF = 0;
000358  A90084     BCLR IFS0, #0
96:                    OSIntExit();
00035A  070E13     RCALL OSIntExit
97:                    OSSemPost(sem_receive_pressure);
00035C  8041C0     MOV sem_receive_pressure, W0
00035E  071B6C     RCALL OSSemPost
98:                }
000360  BE034F     MOV.D [--W15], W6
000362  BE024F     MOV.D [--W15], W4
000364  BE014F     MOV.D [--W15], W2
000366  BE004F     MOV.D [--W15], W0
000368  F90036     POP RCOUNT
00036A  064000     RETFIE
99:                /*************************************
100:               Function:  
101:               Description: GPRS
102:               Input:  
103:               Output: 
104:                *************************************/
105:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
106:               //    gT3Count++;
107:               //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
108:               //}
109:               
110:               /*************************************
111:               Function:  
112:               Description: 485
113:               Input:  
114:               Output: 
115:                *************************************/
116:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
117:               //    while (!U1STAbits.RIDLE);
118:               //    PC_Cop();
119:               //    T2CONbits.TON = 0;
120:               //    TMR2 = 0;
121:               //    FLagArgbits.TestFlag = 0; //
122:               //    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
123:               //}
124:               
125:               /*************************************
126:               Function:  
127:               Description: 
128:               Input:  
129:               Output: 
130:                *************************************/
131:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
132:               //    gT1Count++;
133:               //    IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
134:               //}
135:               
136:               /*************************************
137:               Function: t4 
138:               Description: 
139:               Input:  
140:               Output: 
141:                *************************************/
142:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
143:               //    if (FLagArgbits.LowPowerGetDataFlag) {
144:               //        FLagArgbits.LowPowerGetDataFlag = 0;
145:               //        GetValueTask(LowPowerData); //
146:               //    } else if (FLagArgbits.TestGetDataFlag) {
147:               //        FLagArgbits.TestGetDataFlag = 0;
148:               //        GetValueTask(TestData); //
149:               //    } else
150:               //        GetValueTask(SampleData); //
151:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
152:               //
153:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
154:               //    CloseTime4();
155:               //}
156:               
157:               /*************************************
158:               Function:  
159:               Description: 
160:               Input:  
161:               Output: 
162:                *************************************/
163:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //
164:               //    if (S1) {//
165:               //        gPulseCount++; //+1
166:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//T1
167:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //ms
168:               //            if (gPulseTime < 2000)//2s
169:               //                gPulseTime = 0;
170:               //            else {
171:               //                FLagArgbits.PulseTimeFlag = 1; // 
172:               //                FLagArgbits.T1CountFlag = 0;
173:               //                T1CONbits.TON = 0;
174:               //            }
175:               //        }
176:               //        TMR1 = 0;
177:               //        gT1Count = 0;
178:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //FLagArgbits.T1CountLastFlag
179:               //    }
180:               //    IFS1bits.CNIF = 0;
181:               //}
182:               
183:               /*************************************
184:               Function: UART1
185:               Description: 485
186:               Input:  
187:               Output: 
188:                *************************************/
189:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
00036C  F80036     PUSH RCOUNT
00036E  BE9F80     MOV.D W0, [W15++]
000370  BE9F82     MOV.D W2, [W15++]
000372  BE9F84     MOV.D W4, [W15++]
000374  BE9F86     MOV.D W6, [W15++]
000376  781F88     MOV W8, [W15++]
000378  F80032     PUSH DSRPAG
00037A  F80034     PUSH DSWPAG
00037C  200010     MOV #0x1, W0
00037E  8801A0     MOV W0, DSWPAG
000380  202000     MOV #0x200, W0
000382  880190     MOV W0, DSRPAG
190:                   OSIntEnter();
000384  070DF5     RCALL OSIntEnter
000386  B3C048     MOV.B #0x4, W8
191:                   uint8_t cnt = 0;
192:                   for (cnt = 0; cnt < 4; cnt++)
000390  3AFFFB     BRA NZ, 0x388
193:                       if (U1STAbits.URXDA == 1) //
000388  AB0222     BTST U1STA, #0
00038A  320001     BRA Z, 0x38E
194:                           BufferWrite_UART1();
00038C  071FC8     RCALL BufferWrite_UART1
00038E  E94408     DEC.B W8, W8
195:                   IFS0bits.U1RXIF = 0;
000392  A96085     BCLR 0x85, #3
196:                   OSIntExit();
000394  070DF6     RCALL OSIntExit
197:               }
000396  F90034     POP DSWPAG
000398  F90032     POP DSRPAG
00039A  78044F     MOV [--W15], W8
00039C  BE034F     MOV.D [--W15], W6
00039E  BE024F     MOV.D [--W15], W4
0003A0  BE014F     MOV.D [--W15], W2
0003A2  BE004F     MOV.D [--W15], W0
0003A4  F90036     POP RCOUNT
0003A6  064000     RETFIE
198:               
199:               /*************************************
200:               Function: UART2
201:               Description: GPRS
202:               Input:  
203:               Output: 
204:                *************************************/
205:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
0003A8  F80036     PUSH RCOUNT
0003AA  BE9F80     MOV.D W0, [W15++]
0003AC  BE9F82     MOV.D W2, [W15++]
0003AE  BE9F84     MOV.D W4, [W15++]
0003B0  BE9F86     MOV.D W6, [W15++]
0003B2  781F88     MOV W8, [W15++]
0003B4  F80032     PUSH DSRPAG
0003B6  F80034     PUSH DSWPAG
0003B8  200010     MOV #0x1, W0
0003BA  8801A0     MOV W0, DSWPAG
0003BC  202000     MOV #0x200, W0
0003BE  880190     MOV W0, DSRPAG
206:                   OSIntEnter();
0003C0  070DD7     RCALL OSIntEnter
0003C2  B3C048     MOV.B #0x4, W8
207:                   uint8_t cnt = 0;
208:                   for (cnt = 0; cnt < 4; cnt++)
0003CC  3AFFFB     BRA NZ, 0x3C4
209:                       if (U2STAbits.URXDA == 1) //        
0003C4  AB0232     BTST U2STA, #0
0003C6  320001     BRA Z, 0x3CA
210:                           BufferWrite_UART2();
0003C8  071FBB     RCALL BufferWrite_UART2
0003CA  E94408     DEC.B W8, W8
211:                   IFS1bits.U2RXIF = 0;
0003CE  A9C087     BCLR 0x87, #6
212:                   OSIntExit();
0003D0  070DD8     RCALL OSIntExit
213:               }
0003D2  F90034     POP DSWPAG
0003D4  F90032     POP DSRPAG
0003D6  78044F     MOV [--W15], W8
0003D8  BE034F     MOV.D [--W15], W6
0003DA  BE024F     MOV.D [--W15], W4
0003DC  BE014F     MOV.D [--W15], W2
0003DE  BE004F     MOV.D [--W15], W0
0003E0  F90036     POP RCOUNT
0003E2  064000     RETFIE
214:               
215:               /*************************************
216:               Function: UART2
217:               Description: GPRS
218:               Input:  
219:               Output: 
220:                *************************************/
221:               void __attribute__((__interrupt__, __auto_psv__)) _U3RXInterrupt(void) {
0003E4  F80036     PUSH RCOUNT
0003E6  BE9F80     MOV.D W0, [W15++]
0003E8  BE9F82     MOV.D W2, [W15++]
0003EA  BE9F84     MOV.D W4, [W15++]
0003EC  BE9F86     MOV.D W6, [W15++]
0003EE  781F88     MOV W8, [W15++]
0003F0  F80032     PUSH DSRPAG
0003F2  F80034     PUSH DSWPAG
0003F4  200010     MOV #0x1, W0
0003F6  8801A0     MOV W0, DSWPAG
0003F8  202000     MOV #0x200, W0
0003FA  880190     MOV W0, DSRPAG
222:                   OSIntEnter();
0003FC  070DB9     RCALL OSIntEnter
0003FE  B3C048     MOV.B #0x4, W8
223:                   uint8_t cnt = 0;
224:                   for (cnt = 0; cnt < 4; cnt++)
000408  3AFFFB     BRA NZ, 0x400
225:                       if (U3STAbits.URXDA == 1) //        
000400  AB0252     BTST U3STA, #0
000402  320001     BRA Z, 0x406
226:                           BufferWrite_UART3();
000404  071FAE     RCALL BufferWrite_UART3
000406  E94408     DEC.B W8, W8
227:                   IFS5bits.U3RXIF = 0;
00040A  A9408E     BCLR IFS5, #2
228:                   OSIntExit();
00040C  070DBA     RCALL OSIntExit
229:               }
00040E  F90034     POP DSWPAG
000410  F90032     POP DSRPAG
000412  78044F     MOV [--W15], W8
000414  BE034F     MOV.D [--W15], W6
000416  BE024F     MOV.D [--W15], W4
000418  BE014F     MOV.D [--W15], W2
00041A  BE004F     MOV.D [--W15], W0
00041C  F90036     POP RCOUNT
00041E  064000     RETFIE
230:               
231:               /*************************************
232:               Function: UART2
233:               Description: GPRS
234:               Input:  
235:               Output: 
236:                *************************************/
237:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
238:               //    u8 cnt = 0;
239:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
240:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //
241:               //
242:               //        while (!U2STAbits.TRMT);
243:               //        cnt++;
244:               //    }
245:               //    IFS1bits.U2TXIF = 0;
246:               //}
247:               
248:               /*************************************
249:               Function: UART1
250:               Description: 
251:               Input:  
252:               Output: 
253:                *************************************/
254:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
000420  F80036     PUSH RCOUNT
000422  BE9F80     MOV.D W0, [W15++]
000424  BE9F82     MOV.D W2, [W15++]
000426  BE9F84     MOV.D W4, [W15++]
000428  BE9F86     MOV.D W6, [W15++]
255:                   OSIntEnter();
00042A  070DA2     RCALL OSIntEnter
256:                   if (U1STAbits.OERR == 1)
00042C  AB2222     BTST U1STA, #1
00042E  320001     BRA Z, 0x432
257:                       U1STAbits.OERR = 0;
000430  A92222     BCLR U1STA, #1
258:                   IFS4bits.U1ERIF = 0;
000432  A9208C     BCLR IFS4, #1
259:                   OSIntExit();
000434  070DA6     RCALL OSIntExit
260:               }
000436  BE034F     MOV.D [--W15], W6
000438  BE024F     MOV.D [--W15], W4
00043A  BE014F     MOV.D [--W15], W2
00043C  BE004F     MOV.D [--W15], W0
00043E  F90036     POP RCOUNT
000440  064000     RETFIE
261:               
262:               /*************************************
263:               Function: UART2
264:               Description: 
265:               Input:  
266:               Output: 
267:                *************************************/
268:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
000442  F80036     PUSH RCOUNT
000444  BE9F80     MOV.D W0, [W15++]
000446  BE9F82     MOV.D W2, [W15++]
000448  BE9F84     MOV.D W4, [W15++]
00044A  BE9F86     MOV.D W6, [W15++]
269:                   OSIntEnter();
00044C  070D91     RCALL OSIntEnter
270:                   if (U2STAbits.OERR == 1)
00044E  AB2232     BTST U2STA, #1
000450  320001     BRA Z, 0x454
271:                       U2STAbits.OERR = 0;
000452  A92232     BCLR U2STA, #1
272:                   IFS4bits.U2ERIF = 0;
000454  A9408C     BCLR IFS4, #2
273:                   OSIntExit();
000456  070D95     RCALL OSIntExit
274:               }
000458  BE034F     MOV.D [--W15], W6
00045A  BE024F     MOV.D [--W15], W4
00045C  BE014F     MOV.D [--W15], W2
00045E  BE004F     MOV.D [--W15], W0
000460  F90036     POP RCOUNT
000462  064000     RETFIE
275:               
276:               /*************************************
277:               Function: UART2
278:               Description: 
279:               Input:  
280:               Output: 
281:                *************************************/
282:               void __attribute__((interrupt, no_auto_psv)) _U3ErrInterrupt(void) {
000464  F80036     PUSH RCOUNT
000466  BE9F80     MOV.D W0, [W15++]
000468  BE9F82     MOV.D W2, [W15++]
00046A  BE9F84     MOV.D W4, [W15++]
00046C  BE9F86     MOV.D W6, [W15++]
283:                   OSIntEnter();
00046E  070D80     RCALL OSIntEnter
284:                   if (U3STAbits.OERR == 1)
000470  AB2252     BTST U3STA, #1
000472  320001     BRA Z, 0x476
285:                       U3STAbits.OERR = 0;
000474  A92252     BCLR U3STA, #1
286:                   IFS5bits.U3ERIF = 0;
000476  A9208E     BCLR IFS5, #1
287:                   OSIntExit();
000478  070D84     RCALL OSIntExit
288:               }
00047A  BE034F     MOV.D [--W15], W6
00047C  BE024F     MOV.D [--W15], W4
00047E  BE014F     MOV.D [--W15], W2
000480  BE004F     MOV.D [--W15], W0
000482  F90036     POP RCOUNT
000484  064000     RETFIE
289:               
290:               /*************************************
291:               Function: 
292:               Description: 
293:               Input:  
294:               Output: 
295:                *************************************/
296:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
297:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
000486  AB4080     BTST INTCON1, #2
000488  320001     BRA Z, 0x48C
00048A  A94080     BCLR INTCON1, #2
298:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
00048C  AB6080     BTST INTCON1, #3
00048E  320001     BRA Z, 0x492
000490  A96080     BCLR INTCON1, #3
299:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
000492  AB8080     BTST INTCON1, #4
000494  320001     BRA Z, 0x498
000496  A98080     BCLR INTCON1, #4
300:                   asm("GOTO __reset");
000498  040200     GOTO 0x200
00049A  000000     NOP
301:               }
00049C  064000     RETFIE
302:               
303:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
00049E  F80036     PUSH RCOUNT
0004A0  BE9F80     MOV.D W0, [W15++]
0004A2  BE9F82     MOV.D W2, [W15++]
0004A4  BE9F84     MOV.D W4, [W15++]
0004A6  BE9F86     MOV.D W6, [W15++]
304:                   OSIntEnter();
0004A8  070D63     RCALL OSIntEnter
305:                   static uint16_t i2c_operatcode;
306:                   static uint8_t* pi2c_buf_ptr;
307:                   static uint16_t i2c_address;
308:                   static uint8_t i2c_bytes_left;
309:                   static I2C_Flag i2c_flag;
310:                   static bool i2c_IsResart; //
311:               
312:                   IFS1bits.MI2C1IF = 0; //
0004AA  A92086     BCLR IFS1, #1
313:                   if (I2C1STATbits.IWCOL) {//1
0004AC  ABE208     BTST I2C1STAT, #7
0004AE  320002     BRA Z, 0x4B4
314:                       I2C1STATbits.IWCOL = 0;
0004B0  A9E208     BCLR I2C1STAT, #7
315:                       //        i2c_address_restart = 0;
316:                       //
317:                       return;
0004B2  37009C     BRA 0x5EC
318:                   }
319:                   /* Handle the correct i2c state */
320:                   switch (i2c1_state) {
0004B4  BFC844     MOV.B i2c1_state, WREG
0004B6  FB8000     ZE W0, W0
0004B8  EB0080     CLR W1
0004BA  500FED     SUB W0, #0xD, [W15]
0004BC  588FE0     SUBB W1, #0x0, [W15]
0004BE  3E0095     BRA GTU, 0x5EA
0004C0  016000     BRA W0
0004C2  37000D     BRA 0x4DE
0004C4  370020     BRA 0x506
0004C6  370026     BRA 0x514
0004C8  370051     BRA 0x56C
0004CA  370038     BRA 0x53C
0004CC  37008E     BRA 0x5EA
0004CE  370082     BRA 0x5D4
0004D0  370063     BRA 0x598
0004D2  37006C     BRA 0x5AC
0004D4  37007E     BRA 0x5D2
0004D6  37006E     BRA 0x5B4
0004D8  370088     BRA 0x5EA
0004DA  370087     BRA 0x5EA
0004DC  37007E     BRA 0x5DA
321:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
322:                       {
323:                           if (i2c_bytes_left == 0) {//0
0004DE  E24829     CP0.B i2c_bytes_left
0004E0  3A0084     BRA NZ, 0x5EA
324:                               //                I2C1CONbits.SEN = 1; // 
325:                               //            } else {
326:                               I2C1CONbits.SEN = 1; // 
0004E2  A80206     BSET I2C1CON, #0
327:                               i2c_operatcode = i2c_buf.operatcode; //
0004E4  21C3E0     MOV #0x1C3E, W0
0004E6  FB8010     ZE [W0], W0
0004E8  884170     MOV W0, i2c_operatcode
328:                               i2c_address = i2c_buf.address; //
0004EA  80E200     MOV 0x1C40, W0
0004EC  884150     MOV W0, i2c_address
329:                               i2c_bytes_left = i2c_buf.length; //
0004EE  21C420     MOV #0x1C42, W0
0004F0  784110     MOV.B [W0], W2
0004F2  208291     MOV #0x829, W1
0004F4  784882     MOV.B W2, [W1]
330:                               pi2c_buf_ptr = i2c_buf.pbuffer; //
0004F6  80E223     MOV 0x1C44, W3
0004F8  884163     MOV W3, pi2c_buf_ptr
331:                               i2c_flag = i2c_buf.flag; //
0004FA  400064     ADD W0, #0x4, W0
0004FC  784110     MOV.B [W0], W2
0004FE  208281     MOV #0x828, W1
000500  784882     MOV.B W2, [W1]
332:                               i2c_IsResart = 0;
000502  EF6826     CLR.B i2c_IsResart
000504  370005     BRA 0x510
333:                               i2c1_state = S_MASTER_SEND_ADDR; //
334:                           }
335:                           break;
336:                       }
337:                       case S_MASTER_RESTART:
338:                       {
339:                           I2C1CONbits.RSEN = 1; // 
000506  A82206     BSET I2C1CON, #1
340:                           i2c_bytes_left = i2c_buf.length; //
000508  21C420     MOV #0x1C42, W0
00050A  784090     MOV.B [W0], W1
00050C  208293     MOV #0x829, W3
00050E  784981     MOV.B W1, [W3]
341:                           i2c1_state = S_MASTER_SEND_ADDR; //
000510  B3C020     MOV.B #0x2, W0
000512  370008     BRA 0x524
342:                           break;
343:                       }
344:                       case S_MASTER_SEND_ADDR:
345:                       {
346:                           if (!i2c_flag.F_IsSelectiveMode) {// && i2c_IsResart) {
000514  208281     MOV #0x828, W1
000516  784091     MOV.B [W1], W1
000518  804170     MOV i2c_operatcode, W0
00051A  A30801     BTST.Z W1, #0
00051C  3A0005     BRA NZ, 0x528
00051E  370008     BRA 0x530
347:                               if (i2c_flag.F_WriteOrRead) {//=1ACK
348:                                   I2C1TRN = i2c_operatcode | 0x01;
349:                                   i2c1_state = S_MASTER_ACK_ADDR; //
350:                               } else {
351:                                   I2C1TRN = i2c_operatcode;
000520  881010     MOV W0, I2C1TRN
352:                                   i2c1_state = S_MASTER_SEND_DATA; //
000522  B3C030     MOV.B #0x3, W0
000524  B7E844     MOV.B WREG, i2c1_state
000526  370061     BRA 0x5EA
353:                               }
354:                           } else if (!i2c_IsResart) {//,
000528  E24826     CP0.B i2c_IsResart
00052A  3A0002     BRA NZ, 0x530
355:                               I2C1TRN = i2c_operatcode;
00052C  881010     MOV W0, I2C1TRN
00052E  370014     BRA 0x558
356:                               i2c1_state = S_MASTER_SEND_ADDR_16BIT;
357:                           } else {//
358:                               if (i2c_flag.F_WriteOrRead) {//=1ACK
000530  A32801     BTST.Z W1, #2
000532  32FFF6     BRA Z, 0x520
359:                                   I2C1TRN = i2c_operatcode | 0x01;
000534  A00000     BSET W0, #0
000536  881010     MOV W0, I2C1TRN
360:                                   i2c1_state = S_MASTER_ACK_ADDR; //                    
000538  B3C070     MOV.B #0x7, W0
00053A  37FFF4     BRA 0x524
361:                               } else {
362:                                   I2C1TRN = i2c_operatcode;
363:                                   i2c1_state = S_MASTER_SEND_DATA; //
364:                               }
365:                           }
366:                           break;
367:                       }
368:                       case S_MASTER_SEND_ADDR_16BIT:
369:                       {
370:                           if (I2C1STATbits.ACKSTAT) {//NACK
00053C  E20208     CP0 I2C1STAT
00053E  3D0005     BRA GE, 0x54A
371:                               I2C1STATbits.ACKSTAT = 0; //ACK
000540  A9E209     BCLR 0x209, #7
372:                               I2C1CONbits.PEN = 1; //  
000542  A84206     BSET I2C1CON, #2
373:                               IFS1bits.MI2C1IF = 0; //
000544  A92086     BCLR IFS1, #1
374:                               i2c1_state = S_MASTER_IDLE; //
000546  EF6844     CLR.B i2c1_state
000548  370050     BRA 0x5EA
375:                           } else {
376:                               if (i2c_flag.F_Is16bitsDevice) {
00054A  BFC828     MOV.B i2c_flag, WREG
00054C  804151     MOV i2c_address, W1
00054E  A31800     BTST.Z W0, #1
000550  320005     BRA Z, 0x55C
377:                                   i2c_flag.F_Is16bitsDevice = 0;
000552  A92828     BCLR i2c_flag, #1
378:                                   I2C1TRN = (uint8_t) (i2c_address >> 8); //16 
000554  DE08C8     LSR W1, #8, W1
000556  881011     MOV W1, I2C1TRN
379:                                   i2c1_state = S_MASTER_SEND_ADDR_16BIT;
000558  B3C040     MOV.B #0x4, W0
00055A  37FFE4     BRA 0x524
380:                                   //                    break;
381:                               } else {
382:                                   I2C1TRN = (uint8_t) (i2c_address & 0x00FF); //16 
00055C  FB8081     ZE W1, W1
00055E  881011     MOV W1, I2C1TRN
383:                                   if (i2c_flag.F_WriteOrRead)//
000560  A32800     BTST.Z W0, #2
000562  32FFDF     BRA Z, 0x522
384:                                   {
385:                                       i2c_IsResart = 1;
000564  B3C010     MOV.B #0x1, W0
000566  B7E826     MOV.B WREG, i2c_IsResart
386:                                       //                        I2C1CONbits.RSEN = 1; // 
387:                                       i2c_operatcode |= 0x01; //
000568  A8082E     BSET i2c_operatcode, #0
00056A  37FFDC     BRA 0x524
388:                                       i2c1_state = S_MASTER_RESTART;
389:                                   } else
390:                                       i2c1_state = S_MASTER_SEND_DATA;
391:                               }
392:                           }
393:                           break;
394:                       }
395:                       case S_MASTER_SEND_DATA:
396:                       {
397:                           if (I2C1STATbits.ACKSTAT) {//NACK
00056C  E20208     CP0 I2C1STAT
00056E  3D0005     BRA GE, 0x57A
398:                               I2C1STATbits.ACKSTAT = 0; //ACK
000570  A9E209     BCLR 0x209, #7
399:                               I2C1CONbits.PEN = 1; //  
000572  A84206     BSET I2C1CON, #2
400:                               IFS1bits.MI2C1IF = 0; //
000574  A92086     BCLR IFS1, #1
401:                               i2c1_state = S_MASTER_IDLE; //
000576  EF6844     CLR.B i2c1_state
000578  37000F     BRA 0x598
402:                           } else {
403:                               if (i2c_bytes_left-- == 0U) {//
00057A  BFC829     MOV.B i2c_bytes_left, WREG
00057C  E94080     DEC.B W0, W1
00057E  208292     MOV #0x829, W2
000580  784901     MOV.B W1, [W2]
000582  E00400     CP0.B W0
000584  3A0004     BRA NZ, 0x58E
404:                                   I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000586  A84206     BSET I2C1CON, #2
405:                                   IFS1bits.MI2C1IF = 0; //
000588  A92086     BCLR IFS1, #1
406:                                   i2c1_state = S_MASTER_SEND_STOP; //
00058A  B3C060     MOV.B #0x6, W0
00058C  37FFCB     BRA 0x524
407:                               } else {
408:                                   I2C1TRN = *pi2c_buf_ptr++; //
00058E  804160     MOV pi2c_buf_ptr, W0
000590  FB80B0     ZE [W0++], W1
000592  881011     MOV W1, I2C1TRN
000594  884160     MOV W0, pi2c_buf_ptr
000596  370029     BRA 0x5EA
409:                               }
410:                               break;
411:                           }
412:                       }
413:                       case S_MASTER_ACK_ADDR://
414:                       {
415:                           if (I2C1STATbits.ACKSTAT) { //NACK
000598  E20208     CP0 I2C1STAT
00059A  3D0005     BRA GE, 0x5A6
416:                               I2C1CONbits.PEN = 1; //
00059C  A84206     BSET I2C1CON, #2
417:                               IFS1bits.MI2C1IF = 0; //
00059E  A92086     BCLR IFS1, #1
418:                               i2c1_state = S_MASTER_IDLE;
0005A0  EF6844     CLR.B i2c1_state
419:                               I2C1STATbits.ACKSTAT = 0; //ACK
0005A2  A9E209     BCLR 0x209, #7
0005A4  370022     BRA 0x5EA
420:                           } else {
421:                               I2C1CONbits.RCEN = 1; //
0005A6  A86206     BSET I2C1CON, #3
422:                               i2c1_state = S_MASTER_ACK_RCV_DATA; //
0005A8  B3C0A0     MOV.B #0xA, W0
0005AA  37FFBC     BRA 0x524
423:                           }
424:                           break;
425:                       }
426:                       case S_MASTER_RCV_DATA:
427:                       {
428:                           i2c1_state = S_MASTER_ACK_RCV_DATA; //ACK
0005AC  B3C0A0     MOV.B #0xA, W0
0005AE  B7E844     MOV.B WREG, i2c1_state
429:                           I2C1CONbits.RCEN = 1; //
0005B0  A86206     BSET I2C1CON, #3
430:                           break;
0005B2  37001B     BRA 0x5EA
431:                       }
432:                       case S_MASTER_ACK_RCV_DATA:
433:                       {
434:                           *pi2c_buf_ptr++ = I2C1RCV; //
0005B4  801001     MOV I2C1RCV, W1
0005B6  804160     MOV pi2c_buf_ptr, W0
0005B8  785801     MOV.B W1, [W0++]
0005BA  884160     MOV W0, pi2c_buf_ptr
435:                           if (--i2c_bytes_left) {
0005BC  ED4829     DEC.B i2c_bytes_left, WREG
0005BE  B7E829     MOV.B WREG, i2c_bytes_left
0005C0  320003     BRA Z, 0x5C8
436:                               I2C1CONbits.ACKDT = 0; //ACK
0005C2  A9A206     BCLR I2C1CON, #5
437:                               i2c1_state = S_MASTER_RCV_DATA; //
0005C4  B3C080     MOV.B #0x8, W0
0005C6  370002     BRA 0x5CC
438:                           } else {
439:               
440:                               // Yes, it's the last byte.  Don't ack it
441:                               // Flag that we will nak the data
442:                               I2C1CONbits.ACKDT = 1; // I2C ACK data control bit.
0005C8  A8A206     BSET I2C1CON, #5
443:               
444:                               //            I2C1_FunctionComplete();
445:                               i2c1_state = S_MASTER_RCV_STOP;
0005CA  B3C090     MOV.B #0x9, W0
0005CC  B7E844     MOV.B WREG, i2c1_state
446:                               //                break; //
447:                           }
448:               
449:                           // Initiate the acknowledge
450:                           I2C1CONbits.ACKEN = 1; // I2C ACK .
0005CE  A88206     BSET I2C1CON, #4
451:                           break;
0005D0  37000C     BRA 0x5EA
452:                       }
453:                       case S_MASTER_RCV_STOP:
454:                       {
455:                           I2C1CONbits.ACKDT = 0;
0005D2  A9A206     BCLR I2C1CON, #5
456:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
457:                           //            IFS1bits.MI2C1IF = 0; // 
458:                           i2c1_state = S_MASTER_Finish;
459:                           break;
460:                       }
461:                       case S_MASTER_SEND_STOP:
462:                       {
463:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
0005D4  A84206     BSET I2C1CON, #2
464:                           //            IFS1bits.MI2C1IF = 0; // 
465:                           i2c1_state = S_MASTER_Finish;
0005D6  B3C0D0     MOV.B #0xD, W0
0005D8  37FFA5     BRA 0x524
466:                           break;
467:                       }
468:                       case S_MASTER_Finish:
469:                       {
470:                           i2c_operatcode = 0;
0005DA  EF282E     CLR i2c_operatcode
471:                           pi2c_buf_ptr = NULL;
0005DC  EF282C     CLR pi2c_buf_ptr
472:                           i2c_address = 0;
0005DE  EF282A     CLR i2c_address
473:                           i2c_bytes_left = 0;
0005E0  EF6829     CLR.B i2c_bytes_left
474:                           i2c_flag.F_Is16bitsDevice = i2c_flag.F_IsSelectiveMode = i2c_flag.F_WriteOrRead = 0;
0005E2  A94828     BCLR i2c_flag, #2
0005E4  A90828     BCLR i2c_flag, #0
0005E6  A92828     BCLR i2c_flag, #1
475:                           i2c_IsResart = 0; //
0005E8  EF6826     CLR.B i2c_IsResart
476:                           break;
477:                       }
478:               
479:                           //        default:
480:                           //
481:                           //            // This case should not happen, if it does then
482:                           //            // terminate the transfer
483:                           //            //    i2c1_object.i2cErrors++;
484:                           //        {
485:                           //            I2C1CONbits.PEN = 1; // I2C STOP control bit.  
486:                           //            //            IFS1bits.MI2C1IF = 0; //
487:                           //            //            i2c1_state = S_MASTER_IDLE;
488:                           //            break;
489:                           //        }
490:                   }
491:                   OSIntExit();
0005EA  070CCB     RCALL OSIntExit
492:               }
0005EC  BE034F     MOV.D [--W15], W6
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/INT.c  ---------------------------------------
1:                 #include "INT.h"
2:                 
3:                 void INT0_Init(void) {
4:                     TRISFbits.TRISF6 = 1; //
00518E  A8C2E8     BSET TRISF, #6
5:                     INTCON2bits.INT0EP = 1; //  1 =   0 = 
005190  A80082     BSET INTCON2, #0
6:                     IPC0bits.INT0IP = 7; //2
005192  200070     MOV #0x7, W0
005194  B720A4     IOR IPC0
7:                     IFS0bits.INT0IF = 0; //
005196  A90084     BCLR IFS0, #0
8:                     IEC0bits.INT0IE = 1; //
005198  A80094     BSET IEC0, #0
9:                 }
00519A  060000     RETURN
10:                
11:                void INT0_Open(void) {
12:                    IFS0bits.INT0IF = 0; //
00519C  A90084     BCLR IFS0, #0
13:                    IEC0bits.INT0IE = 1;
00519E  A80094     BSET IEC0, #0
14:                }
0051A0  060000     RETURN
15:                
16:                void INT0_Close(void) {
17:                    IFS0bits.INT0IF = 0; //
0051A2  A90084     BCLR IFS0, #0
18:                    IEC0bits.INT0IE = 0;
0051A4  A90094     BCLR IEC0, #0
19:                }
0051A6  060000     RETURN
20:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/I2C.c  ---------------------------------------
1:                 #include "I2C.h"
2:                 
3:                 volatile uint8_t i2c1_state;
4:                 I2C1_Buffer i2c_buf;
5:                 
6:                 void I2C_Init(void) {
7:                     TRISGbits.TRISG2 = 0; //SCL1
0051A8  A942F0     BCLR TRISG, #2
8:                     TRISGbits.TRISG3 = 0; //SCK1
0051AA  A962F0     BCLR TRISG, #3
9:                     I2C1BRG = 0x9D; //100kHz Fcy=16000000
0051AC  2009D0     MOV #0x9D, W0
0051AE  881020     MOV W0, I2C1BRG
10:                    I2C1CONbits.I2CEN = 1; //I2C1
0051B0  A8E207     BSET 0x207, #7
11:                    I2C1CONbits.I2CSIDL = 0; //
0051B2  A9A207     BCLR 0x207, #5
12:                    I2C1CONbits.IPMIEN = 0; //IPMI
0051B4  A96207     BCLR 0x207, #3
13:                    I2C1CONbits.A10M = 0; //7
0051B6  A94207     BCLR 0x207, #2
14:                    IEC1bits.MI2C1IE = 1; //Master
0051B8  A82096     BSET IEC1, #1
15:                    IFS1bits.MI2C1IF = 0; //Master
0051BA  A92086     BCLR IFS1, #1
16:                    //    IEC1bits.SI2C1IE = 1;//Slave
17:                    //    IFS1bits.SI2C1IF = 0;//Slave
18:                    //    I2C1CONbits.I2CEN = 0; //I2C1
19:                }
0051BC  060000     RETURN
20:                
21:                void Start_I2C(void) {
22:                    //    IEC4bits.
23:                    //    I2C1CONbits.I2CEN = 1;
24:                    IFS1bits.MI2C1IF = 1;
0051BE  A82086     BSET IFS1, #1
25:                }
0051C0  060000     RETURN
26:                
27:                //void Stop_I2C(void) {
28:                //    IFS1bits.MI2C1IF = 0;
29:                //    I2C1CONbits.I2CEN = 0;
30:                //}
31:                
32:                //void Check_I2C(void) {
33:                //    if (I2C1STATbits.IWCOL) {//1
34:                //        I2C1STATbits.IWCOL = 0;
35:                //    }
36:                //}
37:                
38:                //void Clear_I2C_Sta(void) {
39:                //    i2c1_state = S_MASTER_IDLE;
40:                //}
41:                
42:                //void Send_I2C_Data(I2C1_Buffer* buf)
43:                //{
44:                //    buf
45:                //}
46:                
---  C:/Users/Administrator/Desktop/V1_1_2WCGfor6528.X/BSP/DeepSleep.c  ---------------------------------
1:                 #include <DeepSleep.h>
2:                 #include <xc.h>
3:                 #include <stdint.h>
4:                 
5:                 /************
6:                  * /
7:                 LPCFGCW1<10>
8:                  RETEN RCON<12> LPCFG
9:                  0  RETEN  1
10:                 ************************************************/
11:                void DeepSleep(void) {
12:                    //    uint8_t Result;
13:                    //    if (RCONbits.WDTO) {
14:                    //        Result = 3;
15:                    //        RCONbits.WDTO = 0;
16:                    //        DSCONbits.RELEASE = 0;
17:                    //    } else if (RCONbits.EXTR) {
18:                    //        Result = 2;
19:                    //        RCONbits.EXTR = 0;
20:                    //        DSCONbits.RELEASE = 0;
21:                    //    } else if (RCONbits.DPSLP) {
22:                    //        Result = 1;
23:                    //        RCONbits.DPSLP = 0;
24:                    //        DSCONbits.RELEASE = 0;
25:                    //        if (DSWAKEbits.DSWDT) DSGPR0 = DSGPR0 + 1; /* count when wake from DSWDT */
26:                    //        if (DSWAKEbits.DSINT0) DSGPR1 = DSGPR1 + 1; /* count when wake from INT0  */
27:                    //    } else {
28:                    //        Result = 0; /* assume we are a Power On reset */
29:                    //        RCONbits.POR = 0;
30:                    //        DSGPR0 = 0;
31:                    //        DSGPR1 = 0;
32:                    //    }
33:                    //    if (Result == 0) {
34:                    RCONbits.RETEN = 1; // CONFIG1  #pragma config LPCFG = ON    // Low power regulator control->Disabled
0051C2  A88741     BSET 0x741, #4
35:                    //    while (!RCONbits.RETEN)
36:                    //        RCONbits.RETEN = 1;
37:                    //    asm("disi #4");
38:                    //    asm("bset DSCON, #15");
39:                    //    asm("nop");
40:                    //    asm("nop");
41:                    //    asm("btss INTTREG, #15");
42:                    //    asm("pwrsav #0");
43:                    RCONbits.DPSLP = 0; /* clear all previous deep sleep wake flags */
0051C4  A94741     BCLR 0x741, #2
44:                    DSWAKE = 0; /* clear all previous deep sleep wake flags */
0051C6  EF275A     CLR DSWAKE
45:                    /* enter deep sleep code cut and paste from data sheet */
46:                    asm("disi #4");
0051C8  FC0004     DISI #0x4
47:                    asm("bset  DSCON, #15");
0051CA  A8E759     BSET 0x759, #7
48:                    asm("nop");
0051CC  000000     NOP
49:                    asm("nop");
0051CE  000000     NOP
50:                    asm("nop");    
0051D0  000000     NOP
51:                //    asm("bset  DSCON, #15");
52:                    asm("pwrsav #0");
0051D2  FE4000     PWRSAV #0
53:                    //    }
54:                }
0051D4  060000     RETURN
55:                
56:                
57:                
