Disassembly Listing for V1_1_4WCGforkjxm
Generated From:
C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/dist/default/debug/V1_1_4WCGforkjxm.X.debug.elf
2017-10-12 15:27:16

---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Source/os_time.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             TIME MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TIME.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*
31:                *********************************************************************************************************
32:                *                                        DELAY TASK 'n' TICKS
33:                *
34:                * Description: This function is called to delay execution of the currently running task until the
35:                *              specified number of system ticks expires.  This, of course, directly equates to delaying
36:                *              the current task for some time to expire.  No delay will result If the specified delay is
37:                *              0.  If the specified delay is greater than 0 then, a context switch will result.
38:                *
39:                * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
40:                *                        Note that by specifying 0, the task will not be delayed.
41:                *
42:                * Returns    : none
43:                *********************************************************************************************************
44:                */
45:                
46:                void  OSTimeDly (INT32U ticks)
47:                {
0071F4  FA0008     LNK #0x8
0071F6  980720     MOV W0, [W14+4]
0071F8  980731     MOV W1, [W14+6]
48:                    INT8U      y;
49:                #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
50:                    OS_CPU_SR  cpu_sr = 0u;
0071FA  EB0000     CLR W0
0071FC  780F00     MOV W0, [W14]
51:                #endif
52:                
53:                
54:                
55:                    if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0071FE  BFC861     MOV.B OSIntNesting, WREG
007200  E00400     CP0.B W0
007202  3A0032     BRA NZ, 0x7268
56:                        return;
007268  000000     NOP
00726A  370001     BRA 0x726E
57:                    }
58:                    if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
007204  BFC862     MOV.B OSLockNesting, WREG
007206  E00400     CP0.B W0
007208  3A0031     BRA NZ, 0x726C
59:                        return;
00726C  000000     NOP
60:                    }
61:                    if (ticks > 0u) {                            /* 0 means no delay!                                  */
00720A  90002E     MOV [W14+4], W0
00720C  9000BE     MOV [W14+6], W1
00720E  500FE0     SUB W0, #0x0, [W15]
007210  588FE0     SUBB W1, #0x0, [W15]
007212  32002D     BRA Z, 0x726E
62:                        OS_ENTER_CRITICAL();
007214  800211     MOV SR, W1
007216  780F01     MOV W1, [W14]
007218  800211     MOV SR, W1
00721A  200E00     MOV #0xE0, W0
00721C  700001     IOR W0, W1, W0
00721E  880210     MOV W0, SR
63:                        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
007220  804360     MOV OSTCBCur, W0
007222  905960     MOV.B [W0+30], W2
007224  984722     MOV.B W2, [W14+2]
64:                        OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
007226  90402E     MOV.B [W14+2], W0
007228  FB8000     ZE W0, W0
00722A  9040AE     MOV.B [W14+2], W1
00722C  FB8081     ZE W1, W1
00722E  2187E2     MOV #0x187E, W2
007230  78C162     MOV.B [W2+W1], W2
007232  804361     MOV OSTCBCur, W1
007234  9058F1     MOV.B [W1+31], W1
007236  EAC081     COM.B W1, W1
007238  614101     AND.B W2, W1, W2
00723A  2187E1     MOV #0x187E, W1
00723C  787082     MOV.B W2, [W1+W0]
65:                        if (OSRdyTbl[y] == 0u) {
00723E  90402E     MOV.B [W14+2], W0
007240  FB8000     ZE W0, W0
007242  2187E1     MOV #0x187E, W1
007244  784061     MOV.B [W1+W0], W0
007246  E00400     CP0.B W0
007248  3A0006     BRA NZ, 0x7256
66:                            OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00724A  804360     MOV OSTCBCur, W0
00724C  906000     MOV.B [W0+32], W0
00724E  EAC080     COM.B W0, W1
007250  BFC865     MOV.B OSRdyGrp, WREG
007252  60C000     AND.B W1, W0, W0
007254  B7E865     MOV.B WREG, OSRdyGrp
67:                        }
68:                        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
007256  804360     MOV OSTCBCur, W0
007258  90012E     MOV [W14+4], W2
00725A  9001BE     MOV [W14+6], W3
00725C  980832     MOV W2, [W0+22]
00725E  980843     MOV W3, [W0+24]
69:                        OS_EXIT_CRITICAL();
007260  78019E     MOV [W14], W3
007262  880213     MOV W3, SR
70:                        OS_Sched();                              /* Find next task to run!                             */
007264  07DBD3     RCALL OS_Sched
007266  370003     BRA 0x726E
71:                    }
72:                }
00726E  FA8000     ULNK
007270  060000     RETURN
73:                /*$PAGE*/
74:                /*
75:                *********************************************************************************************************
76:                *                                    DELAY TASK FOR SPECIFIED TIME
77:                *
78:                * Description: This function is called to delay execution of the currently running task until some time
79:                *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
80:                *              MILLISECONDS instead of ticks.
81:                *
82:                * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
83:                *              minutes   specifies the number of minutes (max. 59)
84:                *              seconds   specifies the number of seconds (max. 59)
85:                *              ms        specifies the number of milliseconds (max. 999)
86:                *
87:                * Returns    : OS_ERR_NONE
88:                *              OS_ERR_TIME_INVALID_MINUTES
89:                *              OS_ERR_TIME_INVALID_SECONDS
90:                *              OS_ERR_TIME_INVALID_MS
91:                *              OS_ERR_TIME_ZERO_DLY
92:                *              OS_ERR_TIME_DLY_ISR
93:                *
94:                * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
95:                *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
96:                *              set to 0.  The actual delay is rounded to the nearest tick.
97:                *********************************************************************************************************
98:                */
99:                
100:               #if OS_TIME_DLY_HMSM_EN > 0u
101:               INT8U  OSTimeDlyHMSM (INT8U   hours,
102:                                     INT8U   minutes,
103:                                     INT8U   seconds,
104:                                     INT16U  ms)
105:               {
007272  FA000A     LNK #0xA
007274  BE9F88     MOV.D W8, [W15++]
007276  984740     MOV.B W0, [W14+4]
007278  984751     MOV.B W1, [W14+5]
00727A  984762     MOV.B W2, [W14+6]
00727C  980743     MOV W3, [W14+8]
106:                   INT32U ticks;
107:               
108:               
109:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00727E  BFC861     MOV.B OSIntNesting, WREG
007280  E00400     CP0.B W0
007282  320002     BRA Z, 0x7288
110:                       return (OS_ERR_TIME_DLY_ISR);
007284  B3C550     MOV.B #0x55, W0
007286  370064     BRA 0x7350
111:                   }
112:                   if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
007288  BFC862     MOV.B OSLockNesting, WREG
00728A  E00400     CP0.B W0
00728C  320002     BRA Z, 0x7292
113:                       return (OS_ERR_SCHED_LOCKED);
00728E  B3C320     MOV.B #0x32, W0
007290  37005F     BRA 0x7350
114:                   }
115:               #if OS_ARG_CHK_EN > 0u
116:                   if (hours == 0u) {
007292  90404E     MOV.B [W14+4], W0
007294  E00400     CP0.B W0
007296  3A000B     BRA NZ, 0x72AE
117:                       if (minutes == 0u) {
007298  90405E     MOV.B [W14+5], W0
00729A  E00400     CP0.B W0
00729C  3A0008     BRA NZ, 0x72AE
118:                           if (seconds == 0u) {
00729E  90406E     MOV.B [W14+6], W0
0072A0  E00400     CP0.B W0
0072A2  3A0005     BRA NZ, 0x72AE
119:                               if (ms == 0u) {
0072A4  90004E     MOV [W14+8], W0
0072A6  E00000     CP0 W0
0072A8  3A0002     BRA NZ, 0x72AE
120:                                   return (OS_ERR_TIME_ZERO_DLY);
0072AA  B3C540     MOV.B #0x54, W0
0072AC  370051     BRA 0x7350
121:                               }
122:                           }
123:                       }
124:                   }
125:                   if (minutes > 59u) {
0072AE  9040DE     MOV.B [W14+5], W1
0072B0  B3C3B0     MOV.B #0x3B, W0
0072B2  50CF80     SUB.B W1, W0, [W15]
0072B4  360002     BRA LEU, 0x72BA
126:                       return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
0072B6  B3C510     MOV.B #0x51, W0
0072B8  37004B     BRA 0x7350
127:                   }
128:                   if (seconds > 59u) {
0072BA  9040EE     MOV.B [W14+6], W1
0072BC  B3C3B0     MOV.B #0x3B, W0
0072BE  50CF80     SUB.B W1, W0, [W15]
0072C0  360002     BRA LEU, 0x72C6
129:                       return (OS_ERR_TIME_INVALID_SECONDS);
0072C2  B3C520     MOV.B #0x52, W0
0072C4  370045     BRA 0x7350
130:                   }
131:                   if (ms > 999u) {
0072C6  9000CE     MOV [W14+8], W1
0072C8  203E70     MOV #0x3E7, W0
0072CA  508F80     SUB W1, W0, [W15]
0072CC  360002     BRA LEU, 0x72D2
132:                       return (OS_ERR_TIME_INVALID_MS);
0072CE  B3C530     MOV.B #0x53, W0
0072D0  37003F     BRA 0x7350
133:                   }
134:               #endif
135:                                                                /* Compute the total number of clock ticks required.. */
136:                                                                /* .. (rounded to the nearest tick)                   */
137:                   ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
0072D2  90404E     MOV.B [W14+4], W0
0072D4  FB8000     ZE W0, W0
0072D6  EB0080     CLR W1
0072D8  20E102     MOV #0xE10, W2
0072DA  B98902     MUL.SS W1, W2, W2
0072DC  780202     MOV W2, W4
0072DE  B90160     MUL.SU W0, #0, W2
0072E0  780102     MOV W2, W2
0072E2  420202     ADD W4, W2, W4
0072E4  20E102     MOV #0xE10, W2
0072E6  B80102     MUL.UU W0, W2, W2
0072E8  420203     ADD W4, W3, W4
0072EA  780184     MOV W4, W3
0072EC  90405E     MOV.B [W14+5], W0
0072EE  FB8000     ZE W0, W0
0072F0  EB0080     CLR W1
0072F2  2003C4     MOV #0x3C, W4
0072F4  B98A04     MUL.SS W1, W4, W4
0072F6  780204     MOV W4, W4
0072F8  B90360     MUL.SU W0, #0, W6
0072FA  780286     MOV W6, W5
0072FC  420205     ADD W4, W5, W4
0072FE  2003C5     MOV #0x3C, W5
007300  B80005     MUL.UU W0, W5, W0
007302  420201     ADD W4, W1, W4
007304  780084     MOV W4, W1
007306  400102     ADD W0, W2, W2
007308  488183     ADDC W1, W3, W3
00730A  90406E     MOV.B [W14+6], W0
00730C  FB8000     ZE W0, W0
00730E  EB0080     CLR W1
007310  400002     ADD W0, W2, W0
007312  488083     ADDC W1, W3, W1
007314  203E82     MOV #0x3E8, W2
007316  B98902     MUL.SS W1, W2, W2
007318  780102     MOV W2, W2
00731A  B90260     MUL.SU W0, #0, W4
00731C  780184     MOV W4, W3
00731E  410103     ADD W2, W3, W2
007320  203E83     MOV #0x3E8, W3
007322  B80403     MUL.UU W0, W3, W8
007324  410109     ADD W2, W9, W2
007326  780482     MOV W2, W9
007346  441F00     ADD W8, W0, [W14++]
007348  4C9701     ADDC W9, W1, [W14--]
138:                         + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
007328  90004E     MOV [W14+8], W0
00732A  EB0080     CLR W1
00732C  203E82     MOV #0x3E8, W2
00732E  B98902     MUL.SS W1, W2, W2
007330  780102     MOV W2, W2
007332  B90260     MUL.SU W0, #0, W4
007334  780184     MOV W4, W3
007336  410103     ADD W2, W3, W2
007338  203E83     MOV #0x3E8, W3
00733A  B80003     MUL.UU W0, W3, W0
00733C  410101     ADD W2, W1, W2
00733E  780082     MOV W2, W1
007340  203E82     MOV #0x3E8, W2
007342  200003     MOV #0x0, W3
007344  07C9F2     RCALL 0x72A
139:                   OSTimeDly(ticks);
00734A  BE001E     MOV.D [W14], W0
00734C  07FF53     RCALL OSTimeDly
140:                   return (OS_ERR_NONE);
00734E  EB4000     CLR.B W0
141:               }
007350  BE044F     MOV.D [--W15], W8
142:               #endif
143:               /*$PAGE*/
144:               /*
145:               *********************************************************************************************************
146:               *                                        RESUME A DELAYED TASK
147:               *
148:               * Description: This function is used resume a task that has been delayed through a call to either
149:               *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
150:               *              task that is waiting for an event with timeout.  This would make the task look
151:               *              like a timeout occurred.
152:               *
153:               * Arguments  : prio                      specifies the priority of the task to resume
154:               *
155:               * Returns    : OS_ERR_NONE               Task has been resumed
156:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
157:               *                                        (i.e. >= OS_LOWEST_PRIO)
158:               *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
159:               *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
160:               *********************************************************************************************************
161:               */
162:               
163:               #if OS_TIME_DLY_RESUME_EN > 0u
164:               INT8U  OSTimeDlyResume (INT8U prio)
165:               {
166:                   OS_TCB    *ptcb;
167:               #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
168:                   OS_CPU_SR  cpu_sr = 0u;
169:               #endif
170:               
171:               
172:               
173:                   if (prio >= OS_LOWEST_PRIO) {
174:                       return (OS_ERR_PRIO_INVALID);
175:                   }
176:                   OS_ENTER_CRITICAL();
177:                   ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
178:                   if (ptcb == (OS_TCB *)0) {
179:                       OS_EXIT_CRITICAL();
180:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
181:                   }
182:                   if (ptcb == OS_TCB_RESERVED) {
183:                       OS_EXIT_CRITICAL();
184:                       return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
185:                   }
186:                   if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
187:                       OS_EXIT_CRITICAL();
188:                       return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
189:                   }
190:               
191:                   ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
192:                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
193:                       ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
194:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
195:                   } else {
196:                       ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
197:                   }
198:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
199:                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
200:                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
201:                       OS_EXIT_CRITICAL();
202:                       OS_Sched();                                            /* See if this is new highest priority  */
203:                   } else {
204:                       OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
205:                   }
206:                   return (OS_ERR_NONE);
207:               }
208:               #endif
209:               /*$PAGE*/
210:               /*
211:               *********************************************************************************************************
212:               *                                       GET CURRENT SYSTEM TIME
213:               *
214:               * Description: This function is used by your application to obtain the current value of the 32-bit
215:               *              counter which keeps track of the number of clock ticks.
216:               *
217:               * Arguments  : none
218:               *
219:               * Returns    : The current value of OSTime
220:               *********************************************************************************************************
221:               */
222:               
223:               #if OS_TIME_GET_SET_EN > 0u
224:               INT32U  OSTimeGet (void)
225:               {
226:                   INT32U     ticks;
227:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
228:                   OS_CPU_SR  cpu_sr = 0u;
229:               #endif
230:               
231:               
232:               
233:                   OS_ENTER_CRITICAL();
234:                   ticks = OSTime;
235:                   OS_EXIT_CRITICAL();
236:                   return (ticks);
237:               }
238:               #endif
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                          SET SYSTEM CLOCK
243:               *
244:               * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
245:               *
246:               * Arguments  : ticks      specifies the new value that OSTime needs to take.
247:               *
248:               * Returns    : none
249:               *********************************************************************************************************
250:               */
251:               
252:               #if OS_TIME_GET_SET_EN > 0u
253:               void  OSTimeSet (INT32U ticks)
254:               {
255:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
256:                   OS_CPU_SR  cpu_sr = 0u;
257:               #endif
258:               
259:               
260:               
261:                   OS_ENTER_CRITICAL();
262:                   OSTime = ticks;
263:                   OS_EXIT_CRITICAL();
264:               }
265:               #endif
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Source/os_task.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                            TASK MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_TASK.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                /*$PAGE*/
31:                /*
32:                *********************************************************************************************************
33:                *                                      CHANGE PRIORITY OF A TASK
34:                *
35:                * Description: This function allows you to change the priority of a task dynamically.  Note that the new
36:                *              priority MUST be available.
37:                *
38:                * Arguments  : oldp     is the old priority
39:                *
40:                *              newp     is the new priority
41:                *
42:                * Returns    : OS_ERR_NONE            is the call was successful
43:                *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
44:                *                                     (i.e. >= OS_LOWEST_PRIO)
45:                *              OS_ERR_PRIO_EXIST      if the new priority already exist.
46:                *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
47:                *                                     not exist.
48:                *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
49:                *********************************************************************************************************
50:                */
51:                
52:                #if OS_TASK_CHANGE_PRIO_EN > 0u
53:                INT8U  OSTaskChangePrio (INT8U  oldprio,
54:                                         INT8U  newprio)
55:                {
00464A  FA0012     LNK #0x12
00464C  985700     MOV.B W0, [W14+16]
00464E  985711     MOV.B W1, [W14+17]
56:                #if (OS_EVENT_EN)
57:                    OS_EVENT  *pevent;
58:                #if (OS_EVENT_MULTI_EN > 0u)
59:                    OS_EVENT **pevents;
60:                #endif
61:                #endif
62:                    OS_TCB    *ptcb;
63:                    INT8U      y_new;
64:                    INT8U      x_new;
65:                    INT8U      y_old;
66:                    OS_PRIO    bity_new;
67:                    OS_PRIO    bitx_new;
68:                    OS_PRIO    bity_old;
69:                    OS_PRIO    bitx_old;
70:                #if OS_CRITICAL_METHOD == 3u
71:                    OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
004650  EB0000     CLR W0
004652  980720     MOV W0, [W14+4]
72:                #endif
73:                
74:                
75:                /*$PAGE*/
76:                #if OS_ARG_CHK_EN > 0u
77:                    if (oldprio >= OS_LOWEST_PRIO) {
004654  90500E     MOV.B [W14+16], W0
004656  504FE9     SUB.B W0, #0x9, [W15]
004658  360005     BRA LEU, 0x4664
78:                        if (oldprio != OS_PRIO_SELF) {
00465A  90500E     MOV.B [W14+16], W0
00465C  404FE1     ADD.B W0, #0x1, [W15]
00465E  320002     BRA Z, 0x4664
79:                            return (OS_ERR_PRIO_INVALID);
004660  B3C2A0     MOV.B #0x2A, W0
004662  370121     BRA 0x48A6
80:                        }
81:                    }
82:                    if (newprio >= OS_LOWEST_PRIO) {
004664  90501E     MOV.B [W14+17], W0
004666  504FE9     SUB.B W0, #0x9, [W15]
004668  360002     BRA LEU, 0x466E
83:                        return (OS_ERR_PRIO_INVALID);
00466A  B3C2A0     MOV.B #0x2A, W0
00466C  37011C     BRA 0x48A6
84:                    }
85:                #endif
86:                    OS_ENTER_CRITICAL();
00466E  800211     MOV SR, W1
004670  980721     MOV W1, [W14+4]
004672  800211     MOV SR, W1
004674  200E00     MOV #0xE0, W0
004676  700001     IOR W0, W1, W0
004678  880210     MOV W0, SR
87:                    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
00467A  90501E     MOV.B [W14+17], W0
00467C  FB8000     ZE W0, W0
00467E  400080     ADD W0, W0, W1
004680  219000     MOV #0x1900, W0
004682  408000     ADD W1, W0, W0
004684  780010     MOV [W0], W0
004686  E00000     CP0 W0
004688  320004     BRA Z, 0x4692
88:                        OS_EXIT_CRITICAL();
00468A  9001AE     MOV [W14+4], W3
00468C  880213     MOV W3, SR
89:                        return (OS_ERR_PRIO_EXIST);
00468E  B3C280     MOV.B #0x28, W0
004690  37010A     BRA 0x48A6
90:                    }
91:                    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
004692  90500E     MOV.B [W14+16], W0
004694  404FE1     ADD.B W0, #0x1, [W15]
004696  3A0003     BRA NZ, 0x469E
92:                        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
004698  804360     MOV OSTCBCur, W0
00469A  9058C0     MOV.B [W0+28], W1
00469C  985701     MOV.B W1, [W14+16]
93:                    }
94:                    ptcb = OSTCBPrioTbl[oldprio];
00469E  90500E     MOV.B [W14+16], W0
0046A0  FB8000     ZE W0, W0
0046A2  400080     ADD W0, W0, W1
0046A4  219000     MOV #0x1900, W0
0046A6  408000     ADD W1, W0, W0
0046A8  780190     MOV [W0], W3
0046AA  980733     MOV W3, [W14+6]
95:                    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
0046AC  90003E     MOV [W14+6], W0
0046AE  E00000     CP0 W0
0046B0  3A0004     BRA NZ, 0x46BA
96:                        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
0046B2  9000AE     MOV [W14+4], W1
0046B4  880211     MOV W1, SR
97:                        return (OS_ERR_PRIO);
0046B6  B3C290     MOV.B #0x29, W0
0046B8  3700F6     BRA 0x48A6
98:                    }
99:                    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
0046BA  90003E     MOV [W14+6], W0
0046BC  500FE1     SUB W0, #0x1, [W15]
0046BE  3A0004     BRA NZ, 0x46C8
100:                       OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
0046C0  9001AE     MOV [W14+4], W3
0046C2  880213     MOV W3, SR
101:                       return (OS_ERR_TASK_NOT_EXIST);
0046C4  B3C430     MOV.B #0x43, W0
0046C6  3700EF     BRA 0x48A6
102:                   }
103:               #if OS_LOWEST_PRIO <= 63u
104:                   y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
0046C8  90501E     MOV.B [W14+17], W0
0046CA  FB8000     ZE W0, W0
0046CC  DE0043     LSR W0, #3, W0
0046CE  984F00     MOV.B W0, [W14+8]
105:                   x_new                 = (INT8U)(newprio & 0x07u);
0046D0  90501E     MOV.B [W14+17], W0
0046D2  604067     AND.B W0, #0x7, W0
0046D4  984F10     MOV.B W0, [W14+9]
106:               #else
107:                   y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
108:                   x_new                 = (INT8U)(newprio & 0x0Fu);
109:               #endif
110:                   bity_new              = (OS_PRIO)(1uL << y_new);
0046D6  90480E     MOV.B [W14+8], W0
0046D8  FB8100     ZE W0, W2
0046DA  200010     MOV #0x1, W0
0046DC  200001     MOV #0x0, W1
0046DE  780182     MOV W2, W3
0046E0  E90183     DEC W3, W3
0046E2  330003     BRA N, 0x46EA
0046E4  400000     ADD W0, W0, W0
0046E6  488081     ADDC W1, W1, W1
0046E8  37FFFB     BRA 0x46E0
0046EA  984F20     MOV.B W0, [W14+10]
111:                   bitx_new              = (OS_PRIO)(1uL << x_new);
0046EC  90481E     MOV.B [W14+9], W0
0046EE  FB8100     ZE W0, W2
0046F0  200010     MOV #0x1, W0
0046F2  200001     MOV #0x0, W1
0046F4  780182     MOV W2, W3
0046F6  E90183     DEC W3, W3
0046F8  330003     BRA N, 0x4700
0046FA  400000     ADD W0, W0, W0
0046FC  488081     ADDC W1, W1, W1
0046FE  37FFFB     BRA 0x46F6
004700  984F30     MOV.B W0, [W14+11]
112:               
113:                   OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
004702  90500E     MOV.B [W14+16], W0
004704  FB8000     ZE W0, W0
004706  400080     ADD W0, W0, W1
004708  219000     MOV #0x1900, W0
00470A  408000     ADD W1, W0, W0
00470C  EB0080     CLR W1
00470E  780801     MOV W1, [W0]
114:                   OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
004710  90501E     MOV.B [W14+17], W0
004712  FB8000     ZE W0, W0
004714  400080     ADD W0, W0, W1
004716  219000     MOV #0x1900, W0
004718  408000     ADD W1, W0, W0
00471A  9000BE     MOV [W14+6], W1
00471C  780801     MOV W1, [W0]
115:                   y_old                 =  ptcb->OSTCBY;
00471E  90003E     MOV [W14+6], W0
004720  9059E0     MOV.B [W0+30], W3
004722  984F43     MOV.B W3, [W14+12]
116:                   bity_old              =  ptcb->OSTCBBitY;
004724  90003E     MOV [W14+6], W0
004726  906080     MOV.B [W0+32], W1
004728  984F51     MOV.B W1, [W14+13]
117:                   bitx_old              =  ptcb->OSTCBBitX;
00472A  90003E     MOV [W14+6], W0
00472C  9059F0     MOV.B [W0+31], W3
00472E  984F63     MOV.B W3, [W14+14]
118:                   if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
004730  90484E     MOV.B [W14+12], W0
004732  FB8000     ZE W0, W0
004734  2187E1     MOV #0x187E, W1
004736  7840E1     MOV.B [W1+W0], W1
004738  90486E     MOV.B [W14+14], W0
00473A  60C000     AND.B W1, W0, W0
00473C  E00400     CP0.B W0
00473E  320025     BRA Z, 0x478A
119:                        OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
004740  90484E     MOV.B [W14+12], W0
004742  FB8000     ZE W0, W0
004744  9048CE     MOV.B [W14+12], W1
004746  FB8081     ZE W1, W1
004748  2187E2     MOV #0x187E, W2
00474A  78C162     MOV.B [W2+W1], W2
00474C  9048EE     MOV.B [W14+14], W1
00474E  EAC081     COM.B W1, W1
004750  614101     AND.B W2, W1, W2
004752  2187E1     MOV #0x187E, W1
004754  787082     MOV.B W2, [W1+W0]
120:                        if (OSRdyTbl[y_old] == 0u) {
004756  90484E     MOV.B [W14+12], W0
004758  FB8000     ZE W0, W0
00475A  2187E1     MOV #0x187E, W1
00475C  784061     MOV.B [W1+W0], W0
00475E  E00400     CP0.B W0
004760  3A0005     BRA NZ, 0x476C
121:                            OSRdyGrp &= (OS_PRIO)~bity_old;
004762  90485E     MOV.B [W14+13], W0
004764  EAC080     COM.B W0, W1
004766  BFC865     MOV.B OSRdyGrp, WREG
004768  60C000     AND.B W1, W0, W0
00476A  B7E865     MOV.B WREG, OSRdyGrp
122:                        }
123:                        OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
00476C  208651     MOV #0x865, W1
00476E  784091     MOV.B [W1], W1
004770  90482E     MOV.B [W14+10], W0
004772  70C000     IOR.B W1, W0, W0
004774  B7E865     MOV.B WREG, OSRdyGrp
124:                        OSRdyTbl[y_new] |= bitx_new;
004776  90480E     MOV.B [W14+8], W0
004778  FB8000     ZE W0, W0
00477A  90488E     MOV.B [W14+8], W1
00477C  FB8081     ZE W1, W1
00477E  2187E2     MOV #0x187E, W2
004780  78C162     MOV.B [W2+W1], W2
004782  9048BE     MOV.B [W14+11], W1
004784  714101     IOR.B W2, W1, W2
004786  2187E1     MOV #0x187E, W1
004788  787082     MOV.B W2, [W1+W0]
125:                   }
126:               
127:               #if (OS_EVENT_EN)
128:                   pevent = ptcb->OSTCBEventPtr;
00478A  90003E     MOV [W14+6], W0
00478C  900890     MOV [W0+18], W1
00478E  780F01     MOV W1, [W14]
129:                   if (pevent != (OS_EVENT *)0) {
004790  78001E     MOV [W14], W0
004792  E00000     CP0 W0
004794  320030     BRA Z, 0x47F6
130:                       pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
004796  90484E     MOV.B [W14+12], W0
004798  FB8000     ZE W0, W0
00479A  9048CE     MOV.B [W14+12], W1
00479C  FB8081     ZE W1, W1
00479E  78011E     MOV [W14], W2
0047A0  4080E6     ADD W1, #0x6, W1
0047A2  410081     ADD W2, W1, W1
0047A4  904111     MOV.B [W1+1], W2
0047A6  9048EE     MOV.B [W14+14], W1
0047A8  EAC081     COM.B W1, W1
0047AA  614081     AND.B W2, W1, W1
0047AC  78011E     MOV [W14], W2
0047AE  410000     ADD W2, W0, W0
0047B0  984071     MOV.B W1, [W0+7]
131:                       if (pevent->OSEventTbl[y_old] == 0u) {
0047B2  90484E     MOV.B [W14+12], W0
0047B4  FB8000     ZE W0, W0
0047B6  78009E     MOV [W14], W1
0047B8  400066     ADD W0, #0x6, W0
0047BA  408000     ADD W1, W0, W0
0047BC  904010     MOV.B [W0+1], W0
0047BE  E00400     CP0.B W0
0047C0  3A0007     BRA NZ, 0x47D0
132:                           pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0047C2  78001E     MOV [W14], W0
0047C4  9040E0     MOV.B [W0+6], W1
0047C6  90485E     MOV.B [W14+13], W0
0047C8  EAC000     COM.B W0, W0
0047CA  60C080     AND.B W1, W0, W1
0047CC  78001E     MOV [W14], W0
0047CE  984061     MOV.B W1, [W0+6]
133:                       }
134:                       pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
0047D0  78001E     MOV [W14], W0
0047D2  9040E0     MOV.B [W0+6], W1
0047D4  90482E     MOV.B [W14+10], W0
0047D6  70C080     IOR.B W1, W0, W1
0047D8  78001E     MOV [W14], W0
0047DA  984061     MOV.B W1, [W0+6]
135:                       pevent->OSEventTbl[y_new] |= bitx_new;
0047DC  90480E     MOV.B [W14+8], W0
0047DE  FB8000     ZE W0, W0
0047E0  90488E     MOV.B [W14+8], W1
0047E2  FB8081     ZE W1, W1
0047E4  78011E     MOV [W14], W2
0047E6  4080E6     ADD W1, #0x6, W1
0047E8  410081     ADD W2, W1, W1
0047EA  904111     MOV.B [W1+1], W2
0047EC  9048BE     MOV.B [W14+11], W1
0047EE  714081     IOR.B W2, W1, W1
0047F0  78011E     MOV [W14], W2
0047F2  410000     ADD W2, W0, W0
0047F4  984071     MOV.B W1, [W0+7]
136:                   }
137:               #if (OS_EVENT_MULTI_EN > 0u)
138:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
0047F6  90003E     MOV [W14+6], W0
0047F8  900820     MOV [W0+20], W0
0047FA  E00000     CP0 W0
0047FC  32003E     BRA Z, 0x487A
139:                       pevents =  ptcb->OSTCBEventMultiPtr;
0047FE  90003E     MOV [W14+6], W0
004800  9009A0     MOV [W0+20], W3
004802  980713     MOV W3, [W14+2]
140:                       pevent  = *pevents;
004804  90001E     MOV [W14+2], W0
004806  780F10     MOV [W0], [W14]
141:                       while (pevent != (OS_EVENT *)0) {
004808  370035     BRA 0x4874
004874  78001E     MOV [W14], W0
004876  E00000     CP0 W0
004878  3AFFC8     BRA NZ, 0x480A
142:                           pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
00480A  90484E     MOV.B [W14+12], W0
00480C  FB8000     ZE W0, W0
00480E  9048CE     MOV.B [W14+12], W1
004810  FB8081     ZE W1, W1
004812  78011E     MOV [W14], W2
004814  4080E6     ADD W1, #0x6, W1
004816  410081     ADD W2, W1, W1
004818  904111     MOV.B [W1+1], W2
00481A  9048EE     MOV.B [W14+14], W1
00481C  EAC081     COM.B W1, W1
00481E  614081     AND.B W2, W1, W1
004820  78011E     MOV [W14], W2
004822  410000     ADD W2, W0, W0
004824  984071     MOV.B W1, [W0+7]
143:                           if (pevent->OSEventTbl[y_old] == 0u) {
004826  90484E     MOV.B [W14+12], W0
004828  FB8000     ZE W0, W0
00482A  78009E     MOV [W14], W1
00482C  400066     ADD W0, #0x6, W0
00482E  408000     ADD W1, W0, W0
004830  904010     MOV.B [W0+1], W0
004832  E00400     CP0.B W0
004834  3A0007     BRA NZ, 0x4844
144:                               pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
004836  78001E     MOV [W14], W0
004838  9040E0     MOV.B [W0+6], W1
00483A  90485E     MOV.B [W14+13], W0
00483C  EAC000     COM.B W0, W0
00483E  60C080     AND.B W1, W0, W1
004840  78001E     MOV [W14], W0
004842  984061     MOV.B W1, [W0+6]
145:                           }
146:                           pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
004844  78001E     MOV [W14], W0
004846  9040E0     MOV.B [W0+6], W1
004848  90482E     MOV.B [W14+10], W0
00484A  70C080     IOR.B W1, W0, W1
00484C  78001E     MOV [W14], W0
00484E  984061     MOV.B W1, [W0+6]
147:                           pevent->OSEventTbl[y_new] |= bitx_new;
004850  90480E     MOV.B [W14+8], W0
004852  FB8000     ZE W0, W0
004854  90488E     MOV.B [W14+8], W1
004856  FB8081     ZE W1, W1
004858  78011E     MOV [W14], W2
00485A  4080E6     ADD W1, #0x6, W1
00485C  410081     ADD W2, W1, W1
00485E  904111     MOV.B [W1+1], W2
004860  9048BE     MOV.B [W14+11], W1
004862  714081     IOR.B W2, W1, W1
004864  78011E     MOV [W14], W2
004866  410000     ADD W2, W0, W0
004868  984071     MOV.B W1, [W0+7]
148:                           pevents++;
00486A  90001E     MOV [W14+2], W0
00486C  E88000     INC2 W0, W0
00486E  980710     MOV W0, [W14+2]
149:                           pevent                     = *pevents;
004870  90001E     MOV [W14+2], W0
004872  780F10     MOV [W0], [W14]
150:                       }
151:                   }
152:               #endif
153:               #endif
154:               
155:                   ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
00487A  90003E     MOV [W14+6], W0
00487C  90509E     MOV.B [W14+17], W1
00487E  985841     MOV.B W1, [W0+28]
156:                   ptcb->OSTCBY    = y_new;
004880  90003E     MOV [W14+6], W0
004882  90498E     MOV.B [W14+8], W3
004884  985863     MOV.B W3, [W0+30]
157:                   ptcb->OSTCBX    = x_new;
004886  90003E     MOV [W14+6], W0
004888  90489E     MOV.B [W14+9], W1
00488A  985851     MOV.B W1, [W0+29]
158:                   ptcb->OSTCBBitY = bity_new;
00488C  90003E     MOV [W14+6], W0
00488E  9049AE     MOV.B [W14+10], W3
004890  986003     MOV.B W3, [W0+32]
159:                   ptcb->OSTCBBitX = bitx_new;
004892  90003E     MOV [W14+6], W0
004894  9048BE     MOV.B [W14+11], W1
004896  985871     MOV.B W1, [W0+31]
160:                   OS_EXIT_CRITICAL();
004898  9001AE     MOV [W14+4], W3
00489A  880213     MOV W3, SR
161:                   if (OSRunning == OS_TRUE) {
00489C  BFC866     MOV.B OSRunning, WREG
00489E  504FE1     SUB.B W0, #0x1, [W15]
0048A0  3A0001     BRA NZ, 0x48A4
162:                       OS_Sched();                                         /* Find new highest priority task          */
0048A2  07F0B4     RCALL OS_Sched
163:                   }
164:                   return (OS_ERR_NONE);
0048A4  EB4000     CLR.B W0
165:               }
0048A6  FA8000     ULNK
0048A8  060000     RETURN
166:               #endif
167:               /*$PAGE*/
168:               /*
169:               *********************************************************************************************************
170:               *                                            CREATE A TASK
171:               *
172:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
173:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
174:               *              created by an ISR.
175:               *
176:               * Arguments  : task     is a pointer to the task's code
177:               *
178:               *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
179:               *                       the task when the task first executes.  Where the task is concerned it thinks
180:               *                       it was invoked and passed the argument 'p_arg' as follows:
181:               *
182:               *                           void Task (void *p_arg)
183:               *                           {
184:               *                               for (;;) {
185:               *                                   Task code;
186:               *                               }
187:               *                           }
188:               *
189:               *              ptos     is a pointer to the task's top of stack.  If the configuration constant
190:               *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
191:               *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
192:               *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
193:               *                       lowest memory location of the stack and the stack will grow with increasing
194:               *                       memory locations.
195:               *
196:               *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
197:               *                       lower the number, the higher the priority.
198:               *
199:               * Returns    : OS_ERR_NONE                      if the function was successful.
200:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
201:               *                                               (each task MUST have a unique priority).
202:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
203:               *                                               allowed (i.e. >= OS_LOWEST_PRIO)
204:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
205:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
206:               *                                               operation started.
207:               *********************************************************************************************************
208:               */
209:               
210:               #if OS_TASK_CREATE_EN > 0u
211:               INT8U  OSTaskCreate (void   (*task)(void *p_arg),
212:                                    void    *p_arg,
213:                                    OS_STK  *ptos,
214:                                    INT8U    prio)
215:               {
0048AA  FA000E     LNK #0xE
0048AC  980730     MOV W0, [W14+6]
0048AE  980741     MOV W1, [W14+8]
0048B0  980752     MOV W2, [W14+10]
0048B2  984F43     MOV.B W3, [W14+12]
216:                   OS_STK     *psp;
217:                   INT8U       err;
218:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
219:                   OS_CPU_SR   cpu_sr = 0u;
0048B4  EB0000     CLR W0
0048B6  780F00     MOV W0, [W14]
220:               #endif
221:               
222:               
223:               
224:               #ifdef OS_SAFETY_CRITICAL_IEC61508
225:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
226:                       OS_SAFETY_CRITICAL_EXCEPTION();
227:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
228:                   }
229:               #endif
230:               
231:               #if OS_ARG_CHK_EN > 0u
232:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
0048B8  90484E     MOV.B [W14+12], W0
0048BA  504FEA     SUB.B W0, #0xA, [W15]
0048BC  360002     BRA LEU, 0x48C2
233:                       return (OS_ERR_PRIO_INVALID);
0048BE  B3C2A0     MOV.B #0x2A, W0
0048C0  370049     BRA 0x4954
234:                   }
235:               #endif
236:                   OS_ENTER_CRITICAL();
0048C2  800211     MOV SR, W1
0048C4  780F01     MOV W1, [W14]
0048C6  800211     MOV SR, W1
0048C8  200E00     MOV #0xE0, W0
0048CA  700001     IOR W0, W1, W0
0048CC  880210     MOV W0, SR
237:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0048CE  BFC861     MOV.B OSIntNesting, WREG
0048D0  E00400     CP0.B W0
0048D2  320004     BRA Z, 0x48DC
238:                       OS_EXIT_CRITICAL();
0048D4  78009E     MOV [W14], W1
0048D6  880211     MOV W1, SR
239:                       return (OS_ERR_TASK_CREATE_ISR);
0048D8  B3C3C0     MOV.B #0x3C, W0
0048DA  37003C     BRA 0x4954
240:                   }
241:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
0048DC  90484E     MOV.B [W14+12], W0
0048DE  FB8000     ZE W0, W0
0048E0  400080     ADD W0, W0, W1
0048E2  219000     MOV #0x1900, W0
0048E4  408000     ADD W1, W0, W0
0048E6  780010     MOV [W0], W0
0048E8  E00000     CP0 W0
0048EA  3A0031     BRA NZ, 0x494E
242:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
0048EC  90484E     MOV.B [W14+12], W0
0048EE  FB8000     ZE W0, W0
0048F0  400080     ADD W0, W0, W1
0048F2  219000     MOV #0x1900, W0
0048F4  408000     ADD W1, W0, W0
0048F6  200011     MOV #0x1, W1
0048F8  780801     MOV W1, [W0]
243:                                                            /* ... the same thing until task is created.              */
244:                       OS_EXIT_CRITICAL();
0048FA  78009E     MOV [W14], W1
0048FC  880211     MOV W1, SR
245:                       psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
0048FE  EB0180     CLR W3
004900  90015E     MOV [W14+10], W2
004902  9000CE     MOV [W14+8], W1
004904  90003E     MOV [W14+6], W0
004906  071318     RCALL OSTaskStkInit
004908  980710     MOV W0, [W14+2]
246:                       err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00490A  EB0380     CLR W7
00490C  EB0300     CLR W6
00490E  B82260     MUL.UU W4, #0, W4
004910  EB0180     CLR W3
004912  EB0100     CLR W2
004914  90009E     MOV [W14+2], W1
004916  90484E     MOV.B [W14+12], W0
004918  07F15F     RCALL OS_TCBInit
00491A  984740     MOV.B W0, [W14+4]
247:                       if (err == OS_ERR_NONE) {
00491C  90404E     MOV.B [W14+4], W0
00491E  E00400     CP0.B W0
004920  3A0005     BRA NZ, 0x492C
248:                           if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
004922  BFC866     MOV.B OSRunning, WREG
004924  504FE1     SUB.B W0, #0x1, [W15]
004926  3A0011     BRA NZ, 0x494A
249:                               OS_Sched();
004928  07F071     RCALL OS_Sched
00492A  37000F     BRA 0x494A
250:                           }
251:                       } else {
252:                           OS_ENTER_CRITICAL();
00492C  800211     MOV SR, W1
00492E  780F01     MOV W1, [W14]
004930  800211     MOV SR, W1
004932  200E00     MOV #0xE0, W0
004934  700001     IOR W0, W1, W0
004936  880210     MOV W0, SR
253:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
004938  90484E     MOV.B [W14+12], W0
00493A  FB8000     ZE W0, W0
00493C  400080     ADD W0, W0, W1
00493E  219000     MOV #0x1900, W0
004940  408000     ADD W1, W0, W0
004942  EB0080     CLR W1
004944  780801     MOV W1, [W0]
254:                           OS_EXIT_CRITICAL();
004946  78009E     MOV [W14], W1
004948  880211     MOV W1, SR
255:                       }
256:                       return (err);
00494A  90404E     MOV.B [W14+4], W0
00494C  370003     BRA 0x4954
257:                   }
258:                   OS_EXIT_CRITICAL();
00494E  78009E     MOV [W14], W1
004950  880211     MOV W1, SR
259:                   return (OS_ERR_PRIO_EXIST);
004952  B3C280     MOV.B #0x28, W0
260:               }
004954  FA8000     ULNK
004956  060000     RETURN
261:               #endif
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                  CREATE A TASK (Extended Version)
266:               *
267:               * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
268:               *              be created prior to the start of multitasking or by a running task.  A task cannot be
269:               *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
270:               *              additional information about a task to be specified.
271:               *
272:               * Arguments  : task      is a pointer to the task's code
273:               *
274:               *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
275:               *                        the task when the task first executes.  Where the task is concerned it thinks
276:               *                        it was invoked and passed the argument 'p_arg' as follows:
277:               *
278:               *                            void Task (void *p_arg)
279:               *                            {
280:               *                                for (;;) {
281:               *                                    Task code;
282:               *                                }
283:               *                            }
284:               *
285:               *              ptos      is a pointer to the task's top of stack.  If the configuration constant
286:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
287:               *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
288:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
289:               *                        lowest memory location of the stack and the stack will grow with increasing
290:               *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
291:               *
292:               *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
293:               *                        lower the number, the higher the priority.
294:               *
295:               *              id        is the task's ID (0..65535)
296:               *
297:               *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
298:               *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
299:               *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
300:               *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
301:               *                        HIGHEST memory location of the stack and the stack will grow with increasing
302:               *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
303:               *
304:               *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
305:               *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
306:               *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
307:               *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
308:               *                        available on the stack.
309:               *
310:               *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
311:               *                        For example, this user memory can hold the contents of floating-point registers
312:               *                        during a context switch, the time each task takes to execute, the number of times
313:               *                        the task has been switched-in, etc.
314:               *
315:               *              opt       contains additional information (or options) about the behavior of the task.  The
316:               *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
317:               *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
318:               *
319:               *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
320:               *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
321:               *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
322:               *                                                 during a context switch.
323:               *
324:               * Returns    : OS_ERR_NONE                      if the function was successful.
325:               *              OS_ERR_PRIO_EXIST                if the task priority already exist
326:               *                                               (each task MUST have a unique priority).
327:               *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
328:               *                                               allowed (i.e. > OS_LOWEST_PRIO)
329:               *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
330:               *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
331:               *                                               operation started.
332:               *********************************************************************************************************
333:               */
334:               /*$PAGE*/
335:               #if OS_TASK_CREATE_EXT_EN > 0u
336:               INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
337:                                       void    *p_arg,
338:                                       OS_STK  *ptos,
339:                                       INT8U    prio,
340:                                       INT16U   id,
341:                                       OS_STK  *pbos,
342:                                       INT32U   stk_size,
343:                                       void    *pext,
344:                                       INT16U   opt)
345:               {
004958  FA0016     LNK #0x16
00495A  980730     MOV W0, [W14+6]
00495C  980741     MOV W1, [W14+8]
00495E  980752     MOV W2, [W14+10]
004960  984F43     MOV.B W3, [W14+12]
004962  980774     MOV W4, [W14+14]
004964  980F05     MOV W5, [W14+16]
004966  980F16     MOV W6, [W14+18]
004968  980F27     MOV W7, [W14+20]
346:                   OS_STK     *psp;
347:                   INT8U       err;
348:               #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
349:                   OS_CPU_SR   cpu_sr = 0u;
00496A  EB0000     CLR W0
00496C  780F00     MOV W0, [W14]
350:               #endif
351:               
352:               
353:               
354:               #ifdef OS_SAFETY_CRITICAL_IEC61508
355:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
356:                       OS_SAFETY_CRITICAL_EXCEPTION();
357:                       return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
358:                   }
359:               #endif
360:               
361:               #if OS_ARG_CHK_EN > 0u
362:                   if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
00496E  90484E     MOV.B [W14+12], W0
004970  504FEA     SUB.B W0, #0xA, [W15]
004972  360002     BRA LEU, 0x4978
363:                       return (OS_ERR_PRIO_INVALID);
004974  B3C2A0     MOV.B #0x2A, W0
004976  37004F     BRA 0x4A16
364:                   }
365:               #endif
366:                   OS_ENTER_CRITICAL();
004978  800211     MOV SR, W1
00497A  780F01     MOV W1, [W14]
00497C  800211     MOV SR, W1
00497E  200E00     MOV #0xE0, W0
004980  700001     IOR W0, W1, W0
004982  880210     MOV W0, SR
367:                   if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
004984  BFC861     MOV.B OSIntNesting, WREG
004986  E00400     CP0.B W0
004988  320004     BRA Z, 0x4992
368:                       OS_EXIT_CRITICAL();
00498A  78009E     MOV [W14], W1
00498C  880211     MOV W1, SR
369:                       return (OS_ERR_TASK_CREATE_ISR);
00498E  B3C3C0     MOV.B #0x3C, W0
004990  370042     BRA 0x4A16
370:                   }
371:                   if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
004992  90484E     MOV.B [W14+12], W0
004994  FB8000     ZE W0, W0
004996  400080     ADD W0, W0, W1
004998  219000     MOV #0x1900, W0
00499A  408000     ADD W1, W0, W0
00499C  780010     MOV [W0], W0
00499E  E00000     CP0 W0
0049A0  3A0037     BRA NZ, 0x4A10
372:                       OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
0049A2  90484E     MOV.B [W14+12], W0
0049A4  FB8000     ZE W0, W0
0049A6  400080     ADD W0, W0, W1
0049A8  219000     MOV #0x1900, W0
0049AA  408000     ADD W1, W0, W0
0049AC  200011     MOV #0x1, W1
0049AE  780801     MOV W1, [W0]
373:                                                            /* ... the same thing until task is created.              */
374:                       OS_EXIT_CRITICAL();
0049B0  78009E     MOV [W14], W1
0049B2  880211     MOV W1, SR
375:               
376:               #if (OS_TASK_STAT_STK_CHK_EN > 0u)
377:                       OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
0049B4  97B8BE     MOV [W14-10], W1
0049B6  90091E     MOV [W14+18], W2
0049B8  9009AE     MOV [W14+20], W3
0049BA  90080E     MOV [W14+16], W0
0049BC  0703E6     RCALL OS_TaskStkClr
378:               #endif
379:               
380:                       psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
0049BE  97B9BE     MOV [W14-10], W3
0049C0  90015E     MOV [W14+10], W2
0049C2  9000CE     MOV [W14+8], W1
0049C4  90003E     MOV [W14+6], W0
0049C6  0712B8     RCALL OSTaskStkInit
0049C8  980710     MOV W0, [W14+2]
381:                       err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
0049CA  97BBBE     MOV [W14-10], W7
0049CC  97BB4E     MOV [W14-8], W6
0049CE  900A1E     MOV [W14+18], W4
0049D0  900AAE     MOV [W14+20], W5
0049D2  9001FE     MOV [W14+14], W3
0049D4  90090E     MOV [W14+16], W2
0049D6  90009E     MOV [W14+2], W1
0049D8  90484E     MOV.B [W14+12], W0
0049DA  07F0FE     RCALL OS_TCBInit
0049DC  984740     MOV.B W0, [W14+4]
382:                       if (err == OS_ERR_NONE) {
0049DE  90404E     MOV.B [W14+4], W0
0049E0  E00400     CP0.B W0
0049E2  3A0005     BRA NZ, 0x49EE
383:                           if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
0049E4  BFC866     MOV.B OSRunning, WREG
0049E6  504FE1     SUB.B W0, #0x1, [W15]
0049E8  3A0011     BRA NZ, 0x4A0C
384:                               OS_Sched();
0049EA  07F010     RCALL OS_Sched
0049EC  37000F     BRA 0x4A0C
385:                           }
386:                       } else {
387:                           OS_ENTER_CRITICAL();
0049EE  800211     MOV SR, W1
0049F0  780F01     MOV W1, [W14]
0049F2  800211     MOV SR, W1
0049F4  200E00     MOV #0xE0, W0
0049F6  700001     IOR W0, W1, W0
0049F8  880210     MOV W0, SR
388:                           OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
0049FA  90484E     MOV.B [W14+12], W0
0049FC  FB8000     ZE W0, W0
0049FE  400080     ADD W0, W0, W1
004A00  219000     MOV #0x1900, W0
004A02  408000     ADD W1, W0, W0
004A04  EB0080     CLR W1
004A06  780801     MOV W1, [W0]
389:                           OS_EXIT_CRITICAL();
004A08  78009E     MOV [W14], W1
004A0A  880211     MOV W1, SR
390:                       }
391:                       return (err);
004A0C  90404E     MOV.B [W14+4], W0
004A0E  370003     BRA 0x4A16
392:                   }
393:                   OS_EXIT_CRITICAL();
004A10  78009E     MOV [W14], W1
004A12  880211     MOV W1, SR
394:                   return (OS_ERR_PRIO_EXIST);
004A14  B3C280     MOV.B #0x28, W0
395:               }
004A16  FA8000     ULNK
004A18  060000     RETURN
396:               #endif
397:               /*$PAGE*/
398:               /*
399:               *********************************************************************************************************
400:               *                                            DELETE A TASK
401:               *
402:               * Description: This function allows you to delete a task.  The calling task can delete itself by
403:               *              its own priority number.  The deleted task is returned to the dormant state and can be
404:               *              re-activated by creating the deleted task again.
405:               *
406:               * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
407:               *                      the current task without knowing its priority level by setting 'prio' to
408:               *                      OS_PRIO_SELF.
409:               *
410:               * Returns    : OS_ERR_NONE             if the call is successful
411:               *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
412:               *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
413:               *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
414:               *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
415:               *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
416:               *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
417:               *
418:               * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
419:               *                    a) by making it not ready
420:               *                    b) by removing it from any wait lists
421:               *                    c) by preventing OSTimeTick() from making the task ready to run.
422:               *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
423:               *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
424:               *                 the next instruction following the enable interrupt instruction is ignored.
425:               *              3) An ISR cannot delete a task.
426:               *              4) The lock nesting counter is incremented because, for a brief instant, if the current
427:               *                 task is being deleted, the current task would not be able to be rescheduled because it
428:               *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
429:               *                 from being schedule.  This means that an ISR would return to the current task which is
430:               *                 being deleted.  The rest of the deletion would thus be able to be completed.
431:               *********************************************************************************************************
432:               */
433:               
434:               #if OS_TASK_DEL_EN > 0u
435:               INT8U  OSTaskDel (INT8U prio)
436:               {
004A1A  FA0006     LNK #0x6
004A1C  984740     MOV.B W0, [W14+4]
437:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
438:                   OS_FLAG_NODE *pnode;
439:               #endif
440:                   OS_TCB       *ptcb;
441:               #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
442:                   OS_CPU_SR     cpu_sr = 0u;
004A1E  EB0000     CLR W0
004A20  780F00     MOV W0, [W14]
443:               #endif
444:               
445:               
446:               
447:                   if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
004A22  BFC861     MOV.B OSIntNesting, WREG
004A24  E00400     CP0.B W0
004A26  320002     BRA Z, 0x4A2C
448:                       return (OS_ERR_TASK_DEL_ISR);
004A28  B3C400     MOV.B #0x40, W0
004A2A  3700AB     BRA 0x4B82
449:                   }
450:                   if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
004A2C  90404E     MOV.B [W14+4], W0
004A2E  504FEA     SUB.B W0, #0xA, [W15]
004A30  3A0002     BRA NZ, 0x4A36
451:                       return (OS_ERR_TASK_DEL_IDLE);
004A32  B3C3E0     MOV.B #0x3E, W0
004A34  3700A6     BRA 0x4B82
452:                   }
453:               #if OS_ARG_CHK_EN > 0u
454:                   if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
004A36  90404E     MOV.B [W14+4], W0
004A38  504FE9     SUB.B W0, #0x9, [W15]
004A3A  360005     BRA LEU, 0x4A46
455:                       if (prio != OS_PRIO_SELF) {
004A3C  90404E     MOV.B [W14+4], W0
004A3E  404FE1     ADD.B W0, #0x1, [W15]
004A40  320002     BRA Z, 0x4A46
456:                           return (OS_ERR_PRIO_INVALID);
004A42  B3C2A0     MOV.B #0x2A, W0
004A44  37009E     BRA 0x4B82
457:                       }
458:                   }
459:               #endif
460:               
461:               /*$PAGE*/
462:                   OS_ENTER_CRITICAL();
004A46  800211     MOV SR, W1
004A48  780F01     MOV W1, [W14]
004A4A  800211     MOV SR, W1
004A4C  200E00     MOV #0xE0, W0
004A4E  700001     IOR W0, W1, W0
004A50  880210     MOV W0, SR
463:                   if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
004A52  90404E     MOV.B [W14+4], W0
004A54  404FE1     ADD.B W0, #0x1, [W15]
004A56  3A0003     BRA NZ, 0x4A5E
464:                       prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
004A58  804360     MOV OSTCBCur, W0
004A5A  9058C0     MOV.B [W0+28], W1
004A5C  984741     MOV.B W1, [W14+4]
465:                   }
466:                   ptcb = OSTCBPrioTbl[prio];
004A5E  90404E     MOV.B [W14+4], W0
004A60  FB8000     ZE W0, W0
004A62  400080     ADD W0, W0, W1
004A64  219000     MOV #0x1900, W0
004A66  408000     ADD W1, W0, W0
004A68  780090     MOV [W0], W1
004A6A  980711     MOV W1, [W14+2]
467:                   if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
004A6C  90001E     MOV [W14+2], W0
004A6E  E00000     CP0 W0
004A70  3A0004     BRA NZ, 0x4A7A
468:                       OS_EXIT_CRITICAL();
004A72  78009E     MOV [W14], W1
004A74  880211     MOV W1, SR
469:                       return (OS_ERR_TASK_NOT_EXIST);
004A76  B3C430     MOV.B #0x43, W0
004A78  370084     BRA 0x4B82
470:                   }
471:                   if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
004A7A  90001E     MOV [W14+2], W0
004A7C  500FE1     SUB W0, #0x1, [W15]
004A7E  3A0004     BRA NZ, 0x4A88
472:                       OS_EXIT_CRITICAL();
004A80  78009E     MOV [W14], W1
004A82  880211     MOV W1, SR
473:                       return (OS_ERR_TASK_DEL);
004A84  B3C3D0     MOV.B #0x3D, W0
004A86  37007D     BRA 0x4B82
474:                   }
475:               
476:                   OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
004A88  90001E     MOV [W14+2], W0
004A8A  905860     MOV.B [W0+30], W0
004A8C  FB8000     ZE W0, W0
004A8E  90009E     MOV [W14+2], W1
004A90  9058E1     MOV.B [W1+30], W1
004A92  FB8081     ZE W1, W1
004A94  2187E2     MOV #0x187E, W2
004A96  78C162     MOV.B [W2+W1], W2
004A98  90009E     MOV [W14+2], W1
004A9A  9058F1     MOV.B [W1+31], W1
004A9C  EAC081     COM.B W1, W1
004A9E  614101     AND.B W2, W1, W2
004AA0  2187E1     MOV #0x187E, W1
004AA2  787082     MOV.B W2, [W1+W0]
477:                   if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
004AA4  90001E     MOV [W14+2], W0
004AA6  905860     MOV.B [W0+30], W0
004AA8  FB8000     ZE W0, W0
004AAA  2187E1     MOV #0x187E, W1
004AAC  784061     MOV.B [W1+W0], W0
004AAE  E00400     CP0.B W0
004AB0  3A0006     BRA NZ, 0x4ABE
478:                       OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
004AB2  90001E     MOV [W14+2], W0
004AB4  906000     MOV.B [W0+32], W0
004AB6  EAC080     COM.B W0, W1
004AB8  BFC865     MOV.B OSRdyGrp, WREG
004ABA  60C000     AND.B W1, W0, W0
004ABC  B7E865     MOV.B WREG, OSRdyGrp
479:                   }
480:               
481:               #if (OS_EVENT_EN)
482:                   if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
004ABE  90001E     MOV [W14+2], W0
004AC0  900810     MOV [W0+18], W0
004AC2  E00000     CP0 W0
004AC4  320005     BRA Z, 0x4AD0
483:                       OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
004AC6  90001E     MOV [W14+2], W0
004AC8  900810     MOV [W0+18], W0
004ACA  780080     MOV W0, W1
004ACC  90001E     MOV [W14+2], W0
004ACE  07EE4B     RCALL OS_EventTaskRemove
484:                   }
485:               #if (OS_EVENT_MULTI_EN > 0u)
486:                   if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
004AD0  90001E     MOV [W14+2], W0
004AD2  900820     MOV [W0+20], W0
004AD4  E00000     CP0 W0
004AD6  320005     BRA Z, 0x4AE2
487:                       OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
004AD8  90001E     MOV [W14+2], W0
004ADA  900820     MOV [W0+20], W0
004ADC  780080     MOV W0, W1
004ADE  90001E     MOV [W14+2], W0
004AE0  07EE69     RCALL OS_EventTaskRemoveMulti
488:                   }
489:               #endif
490:               #endif
491:               
492:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
493:                   pnode = ptcb->OSTCBFlagNode;
494:                   if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
495:                       OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
496:                   }
497:               #endif
498:               
499:                   ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
004AE2  90011E     MOV [W14+2], W2
004AE4  B80060     MUL.UU W0, #0, W0
004AE6  980930     MOV W0, [W2+22]
004AE8  980941     MOV W1, [W2+24]
500:                   ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
004AEA  90001E     MOV [W14+2], W0
004AEC  EB4080     CLR.B W1
004AEE  985821     MOV.B W1, [W0+26]
501:                   ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
004AF0  90001E     MOV [W14+2], W0
004AF2  EB4080     CLR.B W1
004AF4  985831     MOV.B W1, [W0+27]
502:                   if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
004AF6  BFC862     MOV.B OSLockNesting, WREG
004AF8  404FE1     ADD.B W0, #0x1, [W15]
004AFA  320003     BRA Z, 0x4B02
503:                       OSLockNesting++;
004AFC  BFC862     MOV.B OSLockNesting, WREG
004AFE  E84000     INC.B W0, W0
004B00  B7E862     MOV.B WREG, OSLockNesting
504:                   }
505:                   OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
004B02  78009E     MOV [W14], W1
004B04  880211     MOV W1, SR
506:                   OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
004B06  07ED59     RCALL OS_Dummy
507:                   OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
004B08  800211     MOV SR, W1
004B0A  780F01     MOV W1, [W14]
004B0C  800211     MOV SR, W1
004B0E  200E00     MOV #0xE0, W0
004B10  700001     IOR W0, W1, W0
004B12  880210     MOV W0, SR
508:                   if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
004B14  BFC862     MOV.B OSLockNesting, WREG
004B16  E00400     CP0.B W0
004B18  320003     BRA Z, 0x4B20
509:                       OSLockNesting--;
004B1A  BFC862     MOV.B OSLockNesting, WREG
004B1C  E94000     DEC.B W0, W0
004B1E  B7E862     MOV.B WREG, OSLockNesting
510:                   }
511:                   OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
004B20  90001E     MOV [W14+2], W0
004B22  0711F5     RCALL OSTaskDelHook
512:               
513:               #if OS_TASK_CREATE_EXT_EN > 0u
514:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
515:                   OS_TLS_TaskDel(ptcb);                               /* Call TLS hook                               */
516:               #endif
517:               #endif
518:               
519:                   OSTaskCtr--;                                        /* One less task being managed                 */
004B24  BFC867     MOV.B OSTaskCtr, WREG
004B26  E94000     DEC.B W0, W0
004B28  B7E867     MOV.B WREG, OSTaskCtr
520:                   OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
004B2A  90404E     MOV.B [W14+4], W0
004B2C  FB8000     ZE W0, W0
004B2E  400080     ADD W0, W0, W1
004B30  219000     MOV #0x1900, W0
004B32  408000     ADD W1, W0, W0
004B34  EB0080     CLR W1
004B36  780801     MOV W1, [W0]
521:                   if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
004B38  90001E     MOV [W14+2], W0
004B3A  900800     MOV [W0+16], W0
004B3C  E00000     CP0 W0
004B3E  3A0008     BRA NZ, 0x4B50
522:                       ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
004B40  90001E     MOV [W14+2], W0
004B42  900070     MOV [W0+14], W0
004B44  EB0080     CLR W1
004B46  980801     MOV W1, [W0+16]
523:                       OSTCBList                  = ptcb->OSTCBNext;
004B48  90001E     MOV [W14+2], W0
004B4A  900070     MOV [W0+14], W0
004B4C  884390     MOV W0, OSTCBList
004B4E  37000A     BRA 0x4B64
524:                   } else {
525:                       ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
004B50  90001E     MOV [W14+2], W0
004B52  900800     MOV [W0+16], W0
004B54  90009E     MOV [W14+2], W1
004B56  9000F1     MOV [W1+14], W1
004B58  980071     MOV W1, [W0+14]
526:                       ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
004B5A  90001E     MOV [W14+2], W0
004B5C  900070     MOV [W0+14], W0
004B5E  90009E     MOV [W14+2], W1
004B60  900881     MOV [W1+16], W1
004B62  980801     MOV W1, [W0+16]
527:                   }
528:                   ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
004B64  804371     MOV OSTCBFreeList, W1
004B66  90001E     MOV [W14+2], W0
004B68  980071     MOV W1, [W0+14]
529:                   OSTCBFreeList       = ptcb;
004B6A  90009E     MOV [W14+2], W1
004B6C  884371     MOV W1, OSTCBFreeList
530:               #if OS_TASK_NAME_EN > 0u
531:                   ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
004B6E  29FF81     MOV #0x9FF8, W1
004B70  90001E     MOV [W14+2], W0
004B72  981821     MOV W1, [W0+52]
532:               #endif
533:                   OS_EXIT_CRITICAL();
004B74  78009E     MOV [W14], W1
004B76  880211     MOV W1, SR
534:                   if (OSRunning == OS_TRUE) {
004B78  BFC866     MOV.B OSRunning, WREG
004B7A  504FE1     SUB.B W0, #0x1, [W15]
004B7C  3A0001     BRA NZ, 0x4B80
535:                       OS_Sched();                                     /* Find new highest priority task              */
004B7E  07EF46     RCALL OS_Sched
536:                   }
537:                   return (OS_ERR_NONE);
004B80  EB4000     CLR.B W0
538:               }
004B82  FA8000     ULNK
004B84  060000     RETURN
539:               #endif
540:               /*$PAGE*/
541:               /*
542:               *********************************************************************************************************
543:               *                                  REQUEST THAT A TASK DELETE ITSELF
544:               *
545:               * Description: This function is used to:
546:               *                   a) notify a task to delete itself.
547:               *                   b) to see if a task requested that the current task delete itself.
548:               *              This function is a little tricky to understand.  Basically, you have a task that needs
549:               *              to be deleted however, this task has resources that it has allocated (memory buffers,
550:               *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
551:               *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
552:               *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
553:               *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
554:               *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
555:               *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
556:               *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
557:               *              this:
558:               *
559:               *                   void Task(void *p_arg)
560:               *                   {
561:               *                       .
562:               *                       .
563:               *                       while (1) {
564:               *                           OSTimeDly(1);
565:               *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
566:               *                               Release any owned resources;
567:               *                               De-allocate any dynamic memory;
568:               *                               OSTaskDel(OS_PRIO_SELF);
569:               *                           }
570:               *                       }
571:               *                   }
572:               *
573:               * Arguments  : prio    is the priority of the task to request the delete from
574:               *
575:               * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
576:               *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
577:               *                                     the request has been executed.
578:               *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
579:               *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
580:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
581:               *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
582:               *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
583:               *                                     deleted.
584:               *********************************************************************************************************
585:               */
586:               /*$PAGE*/
587:               #if OS_TASK_DEL_EN > 0u
588:               INT8U  OSTaskDelReq (INT8U prio)
589:               {
004B86  FA0008     LNK #0x8
004B88  984760     MOV.B W0, [W14+6]
590:                   INT8U      stat;
591:                   OS_TCB    *ptcb;
592:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
593:                   OS_CPU_SR  cpu_sr = 0u;
004B8A  EB0000     CLR W0
004B8C  780F00     MOV W0, [W14]
594:               #endif
595:               
596:               
597:               
598:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
004B8E  90406E     MOV.B [W14+6], W0
004B90  504FEA     SUB.B W0, #0xA, [W15]
004B92  3A0002     BRA NZ, 0x4B98
599:                       return (OS_ERR_TASK_DEL_IDLE);
004B94  B3C3E0     MOV.B #0x3E, W0
004B96  370039     BRA 0x4C0A
600:                   }
601:               #if OS_ARG_CHK_EN > 0u
602:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
004B98  90406E     MOV.B [W14+6], W0
004B9A  504FE9     SUB.B W0, #0x9, [W15]
004B9C  360005     BRA LEU, 0x4BA8
603:                       if (prio != OS_PRIO_SELF) {
004B9E  90406E     MOV.B [W14+6], W0
004BA0  404FE1     ADD.B W0, #0x1, [W15]
004BA2  320002     BRA Z, 0x4BA8
604:                           return (OS_ERR_PRIO_INVALID);
004BA4  B3C2A0     MOV.B #0x2A, W0
004BA6  370031     BRA 0x4C0A
605:                       }
606:                   }
607:               #endif
608:                   if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
004BA8  90406E     MOV.B [W14+6], W0
004BAA  404FE1     ADD.B W0, #0x1, [W15]
004BAC  3A000D     BRA NZ, 0x4BC8
609:                       OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
004BAE  800211     MOV SR, W1
004BB0  780F01     MOV W1, [W14]
004BB2  800211     MOV SR, W1
004BB4  200E00     MOV #0xE0, W0
004BB6  700001     IOR W0, W1, W0
004BB8  880210     MOV W0, SR
610:                       stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
004BBA  804360     MOV OSTCBCur, W0
004BBC  906090     MOV.B [W0+33], W1
004BBE  984721     MOV.B W1, [W14+2]
611:                       OS_EXIT_CRITICAL();
004BC0  78009E     MOV [W14], W1
004BC2  880211     MOV W1, SR
612:                       return (stat);
004BC4  90402E     MOV.B [W14+2], W0
004BC6  370021     BRA 0x4C0A
613:                   }
614:                   OS_ENTER_CRITICAL();
004BC8  800211     MOV SR, W1
004BCA  780F01     MOV W1, [W14]
004BCC  800211     MOV SR, W1
004BCE  200E00     MOV #0xE0, W0
004BD0  700001     IOR W0, W1, W0
004BD2  880210     MOV W0, SR
615:                   ptcb = OSTCBPrioTbl[prio];
004BD4  90406E     MOV.B [W14+6], W0
004BD6  FB8000     ZE W0, W0
004BD8  400080     ADD W0, W0, W1
004BDA  219000     MOV #0x1900, W0
004BDC  408000     ADD W1, W0, W0
004BDE  780090     MOV [W0], W1
004BE0  980721     MOV W1, [W14+4]
616:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
004BE2  90002E     MOV [W14+4], W0
004BE4  E00000     CP0 W0
004BE6  3A0004     BRA NZ, 0x4BF0
617:                       OS_EXIT_CRITICAL();
004BE8  78009E     MOV [W14], W1
004BEA  880211     MOV W1, SR
618:                       return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
004BEC  B3C430     MOV.B #0x43, W0
004BEE  37000D     BRA 0x4C0A
619:                   }
620:                   if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
004BF0  90002E     MOV [W14+4], W0
004BF2  500FE1     SUB W0, #0x1, [W15]
004BF4  3A0004     BRA NZ, 0x4BFE
621:                       OS_EXIT_CRITICAL();
004BF6  78009E     MOV [W14], W1
004BF8  880211     MOV W1, SR
622:                       return (OS_ERR_TASK_DEL);
004BFA  B3C3D0     MOV.B #0x3D, W0
004BFC  370006     BRA 0x4C0A
623:                   }
624:                   ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
004BFE  90002E     MOV [W14+4], W0
004C00  B3C3F1     MOV.B #0x3F, W1
004C02  986011     MOV.B W1, [W0+33]
625:                   OS_EXIT_CRITICAL();
004C04  78009E     MOV [W14], W1
004C06  880211     MOV W1, SR
626:                   return (OS_ERR_NONE);
004C08  EB4000     CLR.B W0
627:               }
004C0A  FA8000     ULNK
004C0C  060000     RETURN
628:               #endif
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                       GET THE NAME OF A TASK
633:               *
634:               * Description: This function is called to obtain the name of a task.
635:               *
636:               * Arguments  : prio      is the priority of the task that you want to obtain the name from.
637:               *
638:               *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
639:               *
640:               *              perr      is a pointer to an error code that can contain one of the following values:
641:               *
642:               *                        OS_ERR_NONE                if the requested task is resumed
643:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
644:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
645:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
646:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
647:               *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
648:               *
649:               *
650:               * Returns    : The length of the string or 0 if the task does not exist.
651:               *********************************************************************************************************
652:               */
653:               
654:               #if OS_TASK_NAME_EN > 0u
655:               INT8U  OSTaskNameGet (INT8U    prio,
656:                                     INT8U  **pname,
657:                                     INT8U   *perr)
658:               {
004C0E  FA000C     LNK #0xC
004C10  984760     MOV.B W0, [W14+6]
004C12  980741     MOV W1, [W14+8]
004C14  980752     MOV W2, [W14+10]
659:                   OS_TCB    *ptcb;
660:                   INT8U      len;
661:               #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
662:                   OS_CPU_SR  cpu_sr = 0u;
004C16  EB0000     CLR W0
004C18  780F00     MOV W0, [W14]
663:               #endif
664:               
665:               
666:               
667:               #ifdef OS_SAFETY_CRITICAL
668:                   if (perr == (INT8U *)0) {
669:                       OS_SAFETY_CRITICAL_EXCEPTION();
670:                       return (0u);
671:                   }
672:               #endif
673:               
674:               #if OS_ARG_CHK_EN > 0u
675:                   if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
004C1A  90406E     MOV.B [W14+6], W0
004C1C  504FEA     SUB.B W0, #0xA, [W15]
004C1E  360008     BRA LEU, 0x4C30
676:                       if (prio != OS_PRIO_SELF) {
004C20  90406E     MOV.B [W14+6], W0
004C22  404FE1     ADD.B W0, #0x1, [W15]
004C24  320005     BRA Z, 0x4C30
677:                           *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
004C26  90005E     MOV [W14+10], W0
004C28  B3C2A1     MOV.B #0x2A, W1
004C2A  784801     MOV.B W1, [W0]
678:                           return (0u);
004C2C  EB4000     CLR.B W0
004C2E  370045     BRA 0x4CBA
679:                       }
680:                   }
681:                   if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
004C30  90004E     MOV [W14+8], W0
004C32  E00000     CP0 W0
004C34  3A0005     BRA NZ, 0x4C40
682:                       *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
004C36  90005E     MOV [W14+10], W0
004C38  B3C0C1     MOV.B #0xC, W1
004C3A  784801     MOV.B W1, [W0]
683:                       return (0u);
004C3C  EB4000     CLR.B W0
004C3E  37003D     BRA 0x4CBA
684:                   }
685:               #endif
686:                   if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
004C40  BFC861     MOV.B OSIntNesting, WREG
004C42  E00400     CP0.B W0
004C44  320005     BRA Z, 0x4C50
687:                       *perr = OS_ERR_NAME_GET_ISR;
004C46  90005E     MOV [W14+10], W0
004C48  B3C111     MOV.B #0x11, W1
004C4A  784801     MOV.B W1, [W0]
688:                       return (0u);
004C4C  EB4000     CLR.B W0
004C4E  370035     BRA 0x4CBA
689:                   }
690:                   OS_ENTER_CRITICAL();
004C50  800211     MOV SR, W1
004C52  780F01     MOV W1, [W14]
004C54  800211     MOV SR, W1
004C56  200E00     MOV #0xE0, W0
004C58  700001     IOR W0, W1, W0
004C5A  880210     MOV W0, SR
691:                   if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
004C5C  90406E     MOV.B [W14+6], W0
004C5E  404FE1     ADD.B W0, #0x1, [W15]
004C60  3A0003     BRA NZ, 0x4C68
692:                       prio = OSTCBCur->OSTCBPrio;
004C62  804360     MOV OSTCBCur, W0
004C64  9058C0     MOV.B [W0+28], W1
004C66  984761     MOV.B W1, [W14+6]
693:                   }
694:                   ptcb = OSTCBPrioTbl[prio];
004C68  90406E     MOV.B [W14+6], W0
004C6A  FB8000     ZE W0, W0
004C6C  400080     ADD W0, W0, W1
004C6E  219000     MOV #0x1900, W0
004C70  408000     ADD W1, W0, W0
004C72  780090     MOV [W0], W1
004C74  980711     MOV W1, [W14+2]
695:                   if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
004C76  90001E     MOV [W14+2], W0
004C78  E00000     CP0 W0
004C7A  3A0007     BRA NZ, 0x4C8A
696:                       OS_EXIT_CRITICAL();                              /* No                                         */
004C7C  78009E     MOV [W14], W1
004C7E  880211     MOV W1, SR
697:                       *perr = OS_ERR_TASK_NOT_EXIST;
004C80  90005E     MOV [W14+10], W0
004C82  B3C431     MOV.B #0x43, W1
004C84  784801     MOV.B W1, [W0]
698:                       return (0u);
004C86  EB4000     CLR.B W0
004C88  370018     BRA 0x4CBA
699:                   }
700:                   if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
004C8A  90001E     MOV [W14+2], W0
004C8C  500FE1     SUB W0, #0x1, [W15]
004C8E  3A0007     BRA NZ, 0x4C9E
701:                       OS_EXIT_CRITICAL();                              /* Yes                                        */
004C90  78009E     MOV [W14], W1
004C92  880211     MOV W1, SR
702:                       *perr = OS_ERR_TASK_NOT_EXIST;
004C94  90005E     MOV [W14+10], W0
004C96  B3C431     MOV.B #0x43, W1
004C98  784801     MOV.B W1, [W0]
703:                       return (0u);
004C9A  EB4000     CLR.B W0
004C9C  37000E     BRA 0x4CBA
704:                   }
705:                   *pname = ptcb->OSTCBTaskName;
004C9E  90001E     MOV [W14+2], W0
004CA0  9018A0     MOV [W0+52], W1
004CA2  90004E     MOV [W14+8], W0
004CA4  780801     MOV W1, [W0]
706:                   len    = OS_StrLen(*pname);
004CA6  90004E     MOV [W14+8], W0
004CA8  780010     MOV [W0], W0
004CAA  07EEF0     RCALL OS_StrLen
004CAC  984740     MOV.B W0, [W14+4]
707:                   OS_EXIT_CRITICAL();
004CAE  78009E     MOV [W14], W1
004CB0  880211     MOV W1, SR
708:                   *perr  = OS_ERR_NONE;
004CB2  90005E     MOV [W14+10], W0
004CB4  EB4080     CLR.B W1
004CB6  784801     MOV.B W1, [W0]
709:                   return (len);
004CB8  90404E     MOV.B [W14+4], W0
710:               }
004CBA  FA8000     ULNK
004CBC  060000     RETURN
711:               #endif
712:               
713:               /*$PAGE*/
714:               /*
715:               *********************************************************************************************************
716:               *                                       ASSIGN A NAME TO A TASK
717:               *
718:               * Description: This function is used to set the name of a task.
719:               *
720:               * Arguments  : prio      is the priority of the task that you want the assign a name to.
721:               *
722:               *              pname     is a pointer to an ASCII string that contains the name of the task.
723:               *
724:               *              perr       is a pointer to an error code that can contain one of the following values:
725:               *
726:               *                        OS_ERR_NONE                if the requested task is resumed
727:               *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
728:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
729:               *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
730:               *                                                   A higher value than the idle task or not OS_PRIO_SELF.
731:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
732:               *
733:               * Returns    : None
734:               *********************************************************************************************************
735:               */
736:               #if OS_TASK_NAME_EN > 0u
737:               void  OSTaskNameSet (INT8U   prio,
738:                                    INT8U  *pname,
739:                                    INT8U  *perr)
740:               {
004CBE  FA000A     LNK #0xA
004CC0  984740     MOV.B W0, [W14+4]
004CC2  980731     MOV W1, [W14+6]
004CC4  980742     MOV W2, [W14+8]
741:                   OS_TCB    *ptcb;
742:               #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
743:                   OS_CPU_SR  cpu_sr = 0u;
004CC6  EB0000     CLR W0
004CC8  780F00     MOV W0, [W14]
744:               #endif
745:               
746:               
747:               
748:               #ifdef OS_SAFETY_CRITICAL
749:                   if (perr == (INT8U *)0) {
750:                       OS_SAFETY_CRITICAL_EXCEPTION();
751:                       return;
752:                   }
753:               #endif
754:               
755:               #if OS_ARG_CHK_EN > 0u
756:                   if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
004CCA  90404E     MOV.B [W14+4], W0
004CCC  504FEA     SUB.B W0, #0xA, [W15]
004CCE  360007     BRA LEU, 0x4CDE
757:                       if (prio != OS_PRIO_SELF) {
004CD0  90404E     MOV.B [W14+4], W0
004CD2  404FE1     ADD.B W0, #0x1, [W15]
004CD4  320004     BRA Z, 0x4CDE
758:                           *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
004CD6  90004E     MOV [W14+8], W0
004CD8  B3C2A1     MOV.B #0x2A, W1
004CDA  784801     MOV.B W1, [W0]
759:                           return;
004CDC  37003B     BRA 0x4D54
760:                       }
761:                   }
762:                   if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
004CDE  90003E     MOV [W14+6], W0
004CE0  E00000     CP0 W0
004CE2  3A0004     BRA NZ, 0x4CEC
763:                       *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
004CE4  90004E     MOV [W14+8], W0
004CE6  B3C0C1     MOV.B #0xC, W1
004CE8  784801     MOV.B W1, [W0]
764:                       return;
004CEA  370034     BRA 0x4D54
765:                   }
766:               #endif
767:                   if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
004CEC  BFC861     MOV.B OSIntNesting, WREG
004CEE  E00400     CP0.B W0
004CF0  320004     BRA Z, 0x4CFA
768:                       *perr = OS_ERR_NAME_SET_ISR;
004CF2  90004E     MOV [W14+8], W0
004CF4  B3C121     MOV.B #0x12, W1
004CF6  784801     MOV.B W1, [W0]
769:                       return;
004CF8  37002D     BRA 0x4D54
770:                   }
771:                   OS_ENTER_CRITICAL();
004CFA  800211     MOV SR, W1
004CFC  780F01     MOV W1, [W14]
004CFE  800211     MOV SR, W1
004D00  200E00     MOV #0xE0, W0
004D02  700001     IOR W0, W1, W0
004D04  880210     MOV W0, SR
772:                   if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
004D06  90404E     MOV.B [W14+4], W0
004D08  404FE1     ADD.B W0, #0x1, [W15]
004D0A  3A0003     BRA NZ, 0x4D12
773:                       prio = OSTCBCur->OSTCBPrio;
004D0C  804360     MOV OSTCBCur, W0
004D0E  9058C0     MOV.B [W0+28], W1
004D10  984741     MOV.B W1, [W14+4]
774:                   }
775:                   ptcb = OSTCBPrioTbl[prio];
004D12  90404E     MOV.B [W14+4], W0
004D14  FB8000     ZE W0, W0
004D16  400080     ADD W0, W0, W1
004D18  219000     MOV #0x1900, W0
004D1A  408000     ADD W1, W0, W0
004D1C  780090     MOV [W0], W1
004D1E  980711     MOV W1, [W14+2]
776:                   if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
004D20  90001E     MOV [W14+2], W0
004D22  E00000     CP0 W0
004D24  3A0006     BRA NZ, 0x4D32
777:                       OS_EXIT_CRITICAL();                          /* No                                             */
004D26  78009E     MOV [W14], W1
004D28  880211     MOV W1, SR
778:                       *perr = OS_ERR_TASK_NOT_EXIST;
004D2A  90004E     MOV [W14+8], W0
004D2C  B3C431     MOV.B #0x43, W1
004D2E  784801     MOV.B W1, [W0]
779:                       return;
004D30  370011     BRA 0x4D54
780:                   }
781:                   if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
004D32  90001E     MOV [W14+2], W0
004D34  500FE1     SUB W0, #0x1, [W15]
004D36  3A0006     BRA NZ, 0x4D44
782:                       OS_EXIT_CRITICAL();                          /* Yes                                            */
004D38  78009E     MOV [W14], W1
004D3A  880211     MOV W1, SR
783:                       *perr = OS_ERR_TASK_NOT_EXIST;
004D3C  90004E     MOV [W14+8], W0
004D3E  B3C431     MOV.B #0x43, W1
004D40  784801     MOV.B W1, [W0]
784:                       return;
004D42  370008     BRA 0x4D54
785:                   }
786:                   ptcb->OSTCBTaskName = pname;
004D44  90001E     MOV [W14+2], W0
004D46  9000BE     MOV [W14+6], W1
004D48  981821     MOV W1, [W0+52]
787:                   OS_EXIT_CRITICAL();
004D4A  78009E     MOV [W14], W1
004D4C  880211     MOV W1, SR
788:                   *perr               = OS_ERR_NONE;
004D4E  90004E     MOV [W14+8], W0
004D50  EB4080     CLR.B W1
004D52  784801     MOV.B W1, [W0]
789:               }
004D54  FA8000     ULNK
004D56  060000     RETURN
790:               #endif
791:               
792:               /*$PAGE*/
793:               /*
794:               *********************************************************************************************************
795:               *                                       RESUME A SUSPENDED TASK
796:               *
797:               * Description: This function is called to resume a previously suspended task.  This is the only call that
798:               *              will remove an explicit task suspension.
799:               *
800:               * Arguments  : prio     is the priority of the task to resume.
801:               *
802:               * Returns    : OS_ERR_NONE                if the requested task is resumed
803:               *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
804:               *                                         (i.e. >= OS_LOWEST_PRIO)
805:               *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
806:               *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
807:               *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
808:               *********************************************************************************************************
809:               */
810:               
811:               #if OS_TASK_SUSPEND_EN > 0u
812:               INT8U  OSTaskResume (INT8U prio)
813:               {
004D58  FA0006     LNK #0x6
004D5A  984740     MOV.B W0, [W14+4]
814:                   OS_TCB    *ptcb;
815:               #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
816:                   OS_CPU_SR  cpu_sr = 0u;
004D5C  EB0000     CLR W0
004D5E  780F00     MOV W0, [W14]
817:               #endif
818:               
819:               
820:               
821:               #if OS_ARG_CHK_EN > 0u
822:                   if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
004D60  90404E     MOV.B [W14+4], W0
004D62  504FE9     SUB.B W0, #0x9, [W15]
004D64  360002     BRA LEU, 0x4D6A
823:                       return (OS_ERR_PRIO_INVALID);
004D66  B3C2A0     MOV.B #0x2A, W0
004D68  370057     BRA 0x4E18
824:                   }
825:               #endif
826:                   OS_ENTER_CRITICAL();
004D6A  800211     MOV SR, W1
004D6C  780F01     MOV W1, [W14]
004D6E  800211     MOV SR, W1
004D70  200E00     MOV #0xE0, W0
004D72  700001     IOR W0, W1, W0
004D74  880210     MOV W0, SR
827:                   ptcb = OSTCBPrioTbl[prio];
004D76  90404E     MOV.B [W14+4], W0
004D78  FB8000     ZE W0, W0
004D7A  400080     ADD W0, W0, W1
004D7C  219000     MOV #0x1900, W0
004D7E  408000     ADD W1, W0, W0
004D80  780090     MOV [W0], W1
004D82  980711     MOV W1, [W14+2]
828:                   if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
004D84  90001E     MOV [W14+2], W0
004D86  E00000     CP0 W0
004D88  3A0004     BRA NZ, 0x4D92
829:                       OS_EXIT_CRITICAL();
004D8A  78009E     MOV [W14], W1
004D8C  880211     MOV W1, SR
830:                       return (OS_ERR_TASK_RESUME_PRIO);
004D8E  B3C460     MOV.B #0x46, W0
004D90  370043     BRA 0x4E18
831:                   }
832:                   if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
004D92  90001E     MOV [W14+2], W0
004D94  500FE1     SUB W0, #0x1, [W15]
004D96  3A0004     BRA NZ, 0x4DA0
833:                       OS_EXIT_CRITICAL();
004D98  78009E     MOV [W14], W1
004D9A  880211     MOV W1, SR
834:                       return (OS_ERR_TASK_NOT_EXIST);
004D9C  B3C430     MOV.B #0x43, W0
004D9E  37003C     BRA 0x4E18
835:                   }
836:                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
004DA0  90001E     MOV [W14+2], W0
004DA2  905820     MOV.B [W0+26], W0
004DA4  FB8000     ZE W0, W0
004DA6  600068     AND W0, #0x8, W0
004DA8  E00000     CP0 W0
004DAA  320033     BRA Z, 0x4E12
837:                       ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
004DAC  90001E     MOV [W14+2], W0
004DAE  905820     MOV.B [W0+26], W0
004DB0  784080     MOV.B W0, W1
004DB2  A13401     BCLR.B W1, #3
004DB4  90001E     MOV [W14+2], W0
004DB6  985821     MOV.B W1, [W0+26]
838:                       if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) == OS_STAT_RDY) { /* See if task is now ready         */
004DB8  90001E     MOV [W14+2], W0
004DBA  905820     MOV.B [W0+26], W0
004DBC  FB8080     ZE W0, W1
004DBE  200370     MOV #0x37, W0
004DC0  608000     AND W1, W0, W0
004DC2  E00000     CP0 W0
004DC4  3A0022     BRA NZ, 0x4E0A
839:                           if (ptcb->OSTCBDly == 0u) {
004DC6  90001E     MOV [W14+2], W0
004DC8  9008C0     MOV [W0+24], W1
004DCA  900830     MOV [W0+22], W0
004DCC  500FE0     SUB W0, #0x0, [W15]
004DCE  588FE0     SUBB W1, #0x0, [W15]
004DD0  3A0019     BRA NZ, 0x4E04
840:                               OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
004DD2  90001E     MOV [W14+2], W0
004DD4  906080     MOV.B [W0+32], W1
004DD6  BFC865     MOV.B OSRdyGrp, WREG
004DD8  70C000     IOR.B W1, W0, W0
004DDA  B7E865     MOV.B WREG, OSRdyGrp
841:                               OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
004DDC  90001E     MOV [W14+2], W0
004DDE  905860     MOV.B [W0+30], W0
004DE0  FB8000     ZE W0, W0
004DE2  90009E     MOV [W14+2], W1
004DE4  9058E1     MOV.B [W1+30], W1
004DE6  FB8081     ZE W1, W1
004DE8  2187E2     MOV #0x187E, W2
004DEA  78C162     MOV.B [W2+W1], W2
004DEC  90009E     MOV [W14+2], W1
004DEE  9058F1     MOV.B [W1+31], W1
004DF0  714101     IOR.B W2, W1, W2
004DF2  2187E1     MOV #0x187E, W1
004DF4  787082     MOV.B W2, [W1+W0]
842:                               OS_EXIT_CRITICAL();
004DF6  78009E     MOV [W14], W1
004DF8  880211     MOV W1, SR
843:                               if (OSRunning == OS_TRUE) {
004DFA  BFC866     MOV.B OSRunning, WREG
004DFC  504FE1     SUB.B W0, #0x1, [W15]
004DFE  3A0007     BRA NZ, 0x4E0E
844:                                   OS_Sched();                               /* Find new highest priority task        */
004E00  07EE05     RCALL OS_Sched
004E02  370005     BRA 0x4E0E
845:                               }
846:                           } else {
847:                               OS_EXIT_CRITICAL();
004E04  78009E     MOV [W14], W1
004E06  880211     MOV W1, SR
004E08  370002     BRA 0x4E0E
848:                           }
849:                       } else {                                              /* Must be pending on event              */
850:                           OS_EXIT_CRITICAL();
004E0A  78009E     MOV [W14], W1
004E0C  880211     MOV W1, SR
851:                       }
852:                       return (OS_ERR_NONE);
004E0E  EB4000     CLR.B W0
004E10  370003     BRA 0x4E18
853:                   }
854:                   OS_EXIT_CRITICAL();
004E12  78009E     MOV [W14], W1
004E14  880211     MOV W1, SR
855:                   return (OS_ERR_TASK_NOT_SUSPENDED);
004E16  B3C440     MOV.B #0x44, W0
856:               }
004E18  FA8000     ULNK
004E1A  060000     RETURN
857:               #endif
858:               /*$PAGE*/
859:               /*
860:               *********************************************************************************************************
861:               *                                           STACK CHECKING
862:               *
863:               * Description: This function is called to check the amount of free memory left on the specified task's
864:               *              stack.
865:               *
866:               * Arguments  : prio          is the task priority
867:               *
868:               *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
869:               *
870:               * Returns    : OS_ERR_NONE            upon success
871:               *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
872:               *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
873:               *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
874:               *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
875:               *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
876:               *********************************************************************************************************
877:               */
878:               #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
879:               INT8U  OSTaskStkChk (INT8U         prio,
880:                                    OS_STK_DATA  *p_stk_data)
881:               {
004E1C  FA0012     LNK #0x12
004E1E  984F60     MOV.B W0, [W14+14]
004E20  980F01     MOV W1, [W14+16]
882:                   OS_TCB    *ptcb;
883:                   OS_STK    *pchk;
884:                   INT32U     nfree;
885:                   INT32U     size;
886:               #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
887:                   OS_CPU_SR  cpu_sr = 0u;
004E22  EB0000     CLR W0
004E24  980730     MOV W0, [W14+6]
888:               #endif
889:               
890:               
891:               
892:               #if OS_ARG_CHK_EN > 0u
893:                   if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
004E26  90486E     MOV.B [W14+14], W0
004E28  504FEA     SUB.B W0, #0xA, [W15]
004E2A  360005     BRA LEU, 0x4E36
894:                       if (prio != OS_PRIO_SELF) {
004E2C  90486E     MOV.B [W14+14], W0
004E2E  404FE1     ADD.B W0, #0x1, [W15]
004E30  320002     BRA Z, 0x4E36
895:                           return (OS_ERR_PRIO_INVALID);
004E32  B3C2A0     MOV.B #0x2A, W0
004E34  370062     BRA 0x4EFA
896:                       }
897:                   }
898:                   if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
004E36  90080E     MOV [W14+16], W0
004E38  E00000     CP0 W0
004E3A  3A0002     BRA NZ, 0x4E40
899:                       return (OS_ERR_PDATA_NULL);
004E3C  B3C090     MOV.B #0x9, W0
004E3E  37005D     BRA 0x4EFA
900:                   }
901:               #endif
902:                   p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
004E40  90090E     MOV [W14+16], W2
004E42  B80060     MUL.UU W0, #0, W0
004E44  BE8900     MOV.D W0, [W2]
903:                   p_stk_data->OSUsed = 0u;
004E46  90090E     MOV [W14+16], W2
004E48  B80060     MUL.UU W0, #0, W0
004E4A  980120     MOV W0, [W2+4]
004E4C  980131     MOV W1, [W2+6]
904:                   OS_ENTER_CRITICAL();
004E4E  800211     MOV SR, W1
004E50  980731     MOV W1, [W14+6]
004E52  800211     MOV SR, W1
004E54  200E00     MOV #0xE0, W0
004E56  700001     IOR W0, W1, W0
004E58  880210     MOV W0, SR
905:                   if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
004E5A  90486E     MOV.B [W14+14], W0
004E5C  404FE1     ADD.B W0, #0x1, [W15]
004E5E  3A0003     BRA NZ, 0x4E66
906:                       prio = OSTCBCur->OSTCBPrio;
004E60  804360     MOV OSTCBCur, W0
004E62  905940     MOV.B [W0+28], W2
004E64  984F62     MOV.B W2, [W14+14]
907:                   }
908:                   ptcb = OSTCBPrioTbl[prio];
004E66  90486E     MOV.B [W14+14], W0
004E68  FB8000     ZE W0, W0
004E6A  400080     ADD W0, W0, W1
004E6C  219000     MOV #0x1900, W0
004E6E  408000     ADD W1, W0, W0
004E70  780190     MOV [W0], W3
004E72  980743     MOV W3, [W14+8]
909:                   if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
004E74  90004E     MOV [W14+8], W0
004E76  E00000     CP0 W0
004E78  3A0004     BRA NZ, 0x4E82
910:                       OS_EXIT_CRITICAL();
004E7A  9000BE     MOV [W14+6], W1
004E7C  880211     MOV W1, SR
911:                       return (OS_ERR_TASK_NOT_EXIST);
004E7E  B3C430     MOV.B #0x43, W0
004E80  37003C     BRA 0x4EFA
912:                   }
913:                   if (ptcb == OS_TCB_RESERVED) {
004E82  90004E     MOV [W14+8], W0
004E84  500FE1     SUB W0, #0x1, [W15]
004E86  3A0004     BRA NZ, 0x4E90
914:                       OS_EXIT_CRITICAL();
004E88  90013E     MOV [W14+6], W2
004E8A  880212     MOV W2, SR
915:                       return (OS_ERR_TASK_NOT_EXIST);
004E8C  B3C430     MOV.B #0x43, W0
004E8E  370035     BRA 0x4EFA
916:                   }
917:                   if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
004E90  90004E     MOV [W14+8], W0
004E92  900050     MOV [W0+10], W0
004E94  600061     AND W0, #0x1, W0
004E96  E00000     CP0 W0
004E98  3A0004     BRA NZ, 0x4EA2
918:                       OS_EXIT_CRITICAL();
004E9A  9001BE     MOV [W14+6], W3
004E9C  880213     MOV W3, SR
919:                       return (OS_ERR_TASK_OPT);
004E9E  B3C450     MOV.B #0x45, W0
004EA0  37002C     BRA 0x4EFA
920:                   }
921:                   nfree = 0u;
004EA2  B80060     MUL.UU W0, #0, W0
004EA4  980710     MOV W0, [W14+2]
004EA6  980721     MOV W1, [W14+4]
922:                   size  = ptcb->OSTCBStkSize;
004EA8  90004E     MOV [W14+8], W0
004EAA  900130     MOV [W0+6], W2
004EAC  9001C0     MOV [W0+8], W3
004EAE  980752     MOV W2, [W14+10]
004EB0  980763     MOV W3, [W14+12]
923:                   pchk  = ptcb->OSTCBStkBottom;
004EB2  90004E     MOV [W14+8], W0
004EB4  9001A0     MOV [W0+4], W3
004EB6  780F03     MOV W3, [W14]
924:                   OS_EXIT_CRITICAL();
004EB8  9000BE     MOV [W14+6], W1
004EBA  880211     MOV W1, SR
925:               #if OS_STK_GROWTH == 1u
926:                   while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
927:                       nfree++;
928:                   }
929:               #else
930:                   while (*pchk-- == (OS_STK)0) {
004EBC  370006     BRA 0x4ECA
004ECA  78001E     MOV [W14], W0
004ECC  780010     MOV [W0], W0
004ECE  A7F000     BTSC W0, #15
004ED0  EA0000     NEG W0, W0
004ED2  E90000     DEC W0, W0
004ED4  DE004F     LSR W0, #15, W0
004ED6  784000     MOV.B W0, W0
004ED8  E98F1E     DEC2 [W14], [W14]
004EDA  E00400     CP0.B W0
004EDC  3AFFF0     BRA NZ, 0x4EBE
931:                       nfree++;
004EBE  90001E     MOV [W14+2], W0
004EC0  9000AE     MOV [W14+4], W1
004EC2  400061     ADD W0, #0x1, W0
004EC4  4880E0     ADDC W1, #0x0, W1
004EC6  980710     MOV W0, [W14+2]
004EC8  980721     MOV W1, [W14+4]
932:                   }
933:               #endif
934:                   p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
004EDE  90080E     MOV [W14+16], W0
004EE0  90011E     MOV [W14+2], W2
004EE2  9001AE     MOV [W14+4], W3
004EE4  BE8802     MOV.D W2, [W0]
935:                   p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
004EE6  90015E     MOV [W14+10], W2
004EE8  9001EE     MOV [W14+12], W3
004EEA  90001E     MOV [W14+2], W0
004EEC  9000AE     MOV [W14+4], W1
004EEE  510000     SUB W2, W0, W0
004EF0  598081     SUBB W3, W1, W1
004EF2  90090E     MOV [W14+16], W2
004EF4  980120     MOV W0, [W2+4]
004EF6  980131     MOV W1, [W2+6]
936:                   return (OS_ERR_NONE);
004EF8  EB4000     CLR.B W0
937:               }
004EFA  FA8000     ULNK
004EFC  060000     RETURN
938:               #endif
939:               /*$PAGE*/
940:               /*
941:               *********************************************************************************************************
942:               *                                           SUSPEND A TASK
943:               *
944:               * Description: This function is called to suspend a task.  The task can be the calling task if the
945:               *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
946:               *
947:               * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
948:               *                       calling task will suspend itself and rescheduling will occur.
949:               *
950:               * Returns    : OS_ERR_NONE               if the requested task is suspended
951:               *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
952:               *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
953:               *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
954:               *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
955:               *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
956:               *
957:               * Note       : You should use this function with great care.  If you suspend a task that is waiting for
958:               *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
959:               *              running when the event arrives.
960:               *********************************************************************************************************
961:               */
962:               
963:               #if OS_TASK_SUSPEND_EN > 0u
964:               INT8U  OSTaskSuspend (INT8U prio)
965:               {
004EFE  FA000A     LNK #0xA
004F00  984F00     MOV.B W0, [W14+8]
966:                   BOOLEAN    self;
967:                   OS_TCB    *ptcb;
968:                   INT8U      y;
969:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
970:                   OS_CPU_SR  cpu_sr = 0u;
004F02  EB0000     CLR W0
004F04  980710     MOV W0, [W14+2]
971:               #endif
972:               
973:               
974:               
975:               #if OS_ARG_CHK_EN > 0u
976:                   if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
004F06  90480E     MOV.B [W14+8], W0
004F08  504FEA     SUB.B W0, #0xA, [W15]
004F0A  3A0002     BRA NZ, 0x4F10
977:                       return (OS_ERR_TASK_SUSPEND_IDLE);
004F0C  B3C470     MOV.B #0x47, W0
004F0E  37005E     BRA 0x4FCC
978:                   }
979:                   if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
004F10  90480E     MOV.B [W14+8], W0
004F12  504FE9     SUB.B W0, #0x9, [W15]
004F14  360005     BRA LEU, 0x4F20
980:                       if (prio != OS_PRIO_SELF) {
004F16  90480E     MOV.B [W14+8], W0
004F18  404FE1     ADD.B W0, #0x1, [W15]
004F1A  320002     BRA Z, 0x4F20
981:                           return (OS_ERR_PRIO_INVALID);
004F1C  B3C2A0     MOV.B #0x2A, W0
004F1E  370056     BRA 0x4FCC
982:                       }
983:                   }
984:               #endif
985:                   OS_ENTER_CRITICAL();
004F20  800211     MOV SR, W1
004F22  980711     MOV W1, [W14+2]
004F24  800211     MOV SR, W1
004F26  200E00     MOV #0xE0, W0
004F28  700001     IOR W0, W1, W0
004F2A  880210     MOV W0, SR
986:                   if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
004F2C  90480E     MOV.B [W14+8], W0
004F2E  404FE1     ADD.B W0, #0x1, [W15]
004F30  3A0006     BRA NZ, 0x4F3E
987:                       prio = OSTCBCur->OSTCBPrio;
004F32  804360     MOV OSTCBCur, W0
004F34  9058C0     MOV.B [W0+28], W1
004F36  984F01     MOV.B W1, [W14+8]
988:                       self = OS_TRUE;
004F38  B3C010     MOV.B #0x1, W0
004F3A  784F00     MOV.B W0, [W14]
004F3C  37000A     BRA 0x4F52
989:                   } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
004F3E  804360     MOV OSTCBCur, W0
004F40  9058C0     MOV.B [W0+28], W1
004F42  90480E     MOV.B [W14+8], W0
004F44  50CF80     SUB.B W1, W0, [W15]
004F46  3A0003     BRA NZ, 0x4F4E
990:                       self = OS_TRUE;
004F48  B3C010     MOV.B #0x1, W0
004F4A  784F00     MOV.B W0, [W14]
004F4C  370002     BRA 0x4F52
991:                   } else {
992:                       self = OS_FALSE;                                        /* No suspending another task          */
004F4E  EB4000     CLR.B W0
004F50  784F00     MOV.B W0, [W14]
993:                   }
994:                   ptcb = OSTCBPrioTbl[prio];
004F52  90480E     MOV.B [W14+8], W0
004F54  FB8000     ZE W0, W0
004F56  400080     ADD W0, W0, W1
004F58  219000     MOV #0x1900, W0
004F5A  408000     ADD W1, W0, W0
004F5C  780090     MOV [W0], W1
004F5E  980721     MOV W1, [W14+4]
995:                   if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
004F60  90002E     MOV [W14+4], W0
004F62  E00000     CP0 W0
004F64  3A0004     BRA NZ, 0x4F6E
996:                       OS_EXIT_CRITICAL();
004F66  90009E     MOV [W14+2], W1
004F68  880211     MOV W1, SR
997:                       return (OS_ERR_TASK_SUSPEND_PRIO);
004F6A  B3C480     MOV.B #0x48, W0
004F6C  37002F     BRA 0x4FCC
998:                   }
999:                   if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
004F6E  90002E     MOV [W14+4], W0
004F70  500FE1     SUB W0, #0x1, [W15]
004F72  3A0004     BRA NZ, 0x4F7C
1000:                      OS_EXIT_CRITICAL();
004F74  90009E     MOV [W14+2], W1
004F76  880211     MOV W1, SR
1001:                      return (OS_ERR_TASK_NOT_EXIST);
004F78  B3C430     MOV.B #0x43, W0
004F7A  370028     BRA 0x4FCC
1002:                  }
1003:                  y            = ptcb->OSTCBY;
004F7C  90002E     MOV [W14+4], W0
004F7E  9058E0     MOV.B [W0+30], W1
004F80  984761     MOV.B W1, [W14+6]
1004:                  OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
004F82  90406E     MOV.B [W14+6], W0
004F84  FB8000     ZE W0, W0
004F86  9040EE     MOV.B [W14+6], W1
004F88  FB8081     ZE W1, W1
004F8A  2187E2     MOV #0x187E, W2
004F8C  78C162     MOV.B [W2+W1], W2
004F8E  9000AE     MOV [W14+4], W1
004F90  9058F1     MOV.B [W1+31], W1
004F92  EAC081     COM.B W1, W1
004F94  614101     AND.B W2, W1, W2
004F96  2187E1     MOV #0x187E, W1
004F98  787082     MOV.B W2, [W1+W0]
1005:                  if (OSRdyTbl[y] == 0u) {
004F9A  90406E     MOV.B [W14+6], W0
004F9C  FB8000     ZE W0, W0
004F9E  2187E1     MOV #0x187E, W1
004FA0  784061     MOV.B [W1+W0], W0
004FA2  E00400     CP0.B W0
004FA4  3A0006     BRA NZ, 0x4FB2
1006:                      OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
004FA6  90002E     MOV [W14+4], W0
004FA8  906000     MOV.B [W0+32], W0
004FAA  EAC080     COM.B W0, W1
004FAC  BFC865     MOV.B OSRdyGrp, WREG
004FAE  60C000     AND.B W1, W0, W0
004FB0  B7E865     MOV.B WREG, OSRdyGrp
1007:                  }
1008:                  ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
004FB2  90002E     MOV [W14+4], W0
004FB4  905820     MOV.B [W0+26], W0
004FB6  784080     MOV.B W0, W1
004FB8  A03401     BSET.B W1, #3
004FBA  90002E     MOV [W14+4], W0
004FBC  985821     MOV.B W1, [W0+26]
1009:                  OS_EXIT_CRITICAL();
004FBE  90009E     MOV [W14+2], W1
004FC0  880211     MOV W1, SR
1010:                  if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
004FC2  78401E     MOV.B [W14], W0
004FC4  504FE1     SUB.B W0, #0x1, [W15]
004FC6  3A0001     BRA NZ, 0x4FCA
1011:                      OS_Sched();                                             /* Find new highest priority task      */
004FC8  07ED21     RCALL OS_Sched
1012:                  }
1013:                  return (OS_ERR_NONE);
004FCA  EB4000     CLR.B W0
1014:              }
004FCC  FA8000     ULNK
004FCE  060000     RETURN
1015:              #endif
1016:              /*$PAGE*/
1017:              /*
1018:              *********************************************************************************************************
1019:              *                                            QUERY A TASK
1020:              *
1021:              * Description: This function is called to obtain a copy of the desired task's TCB.
1022:              *
1023:              * Arguments  : prio         is the priority of the task to obtain information from.
1024:              *
1025:              *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
1026:              *
1027:              * Returns    : OS_ERR_NONE            if the requested task is suspended
1028:              *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
1029:              *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
1030:              *              OS_ERR_PRIO            if the desired task has not been created
1031:              *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
1032:              *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
1033:              *********************************************************************************************************
1034:              */
1035:              
1036:              #if OS_TASK_QUERY_EN > 0u
1037:              INT8U  OSTaskQuery (INT8U    prio,
1038:                                  OS_TCB  *p_task_data)
1039:              {
004FD0  FA0008     LNK #0x8
004FD2  984740     MOV.B W0, [W14+4]
004FD4  980731     MOV W1, [W14+6]
1040:                  OS_TCB    *ptcb;
1041:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1042:                  OS_CPU_SR  cpu_sr = 0u;
004FD6  EB0000     CLR W0
004FD8  780F00     MOV W0, [W14]
1043:              #endif
1044:              
1045:              
1046:              
1047:              #if OS_ARG_CHK_EN > 0u
1048:                  if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
004FDA  90404E     MOV.B [W14+4], W0
004FDC  504FEA     SUB.B W0, #0xA, [W15]
004FDE  360005     BRA LEU, 0x4FEA
1049:                      if (prio != OS_PRIO_SELF) {
004FE0  90404E     MOV.B [W14+4], W0
004FE2  404FE1     ADD.B W0, #0x1, [W15]
004FE4  320002     BRA Z, 0x4FEA
1050:                          return (OS_ERR_PRIO_INVALID);
004FE6  B3C2A0     MOV.B #0x2A, W0
004FE8  37002D     BRA 0x5044
1051:                      }
1052:                  }
1053:                  if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
004FEA  90003E     MOV [W14+6], W0
004FEC  E00000     CP0 W0
004FEE  3A0002     BRA NZ, 0x4FF4
1054:                      return (OS_ERR_PDATA_NULL);
004FF0  B3C090     MOV.B #0x9, W0
004FF2  370028     BRA 0x5044
1055:                  }
1056:              #endif
1057:                  OS_ENTER_CRITICAL();
004FF4  800211     MOV SR, W1
004FF6  780F01     MOV W1, [W14]
004FF8  800211     MOV SR, W1
004FFA  200E00     MOV #0xE0, W0
004FFC  700001     IOR W0, W1, W0
004FFE  880210     MOV W0, SR
1058:                  if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
005000  90404E     MOV.B [W14+4], W0
005002  404FE1     ADD.B W0, #0x1, [W15]
005004  3A0003     BRA NZ, 0x500C
1059:                      prio = OSTCBCur->OSTCBPrio;
005006  804360     MOV OSTCBCur, W0
005008  9058C0     MOV.B [W0+28], W1
00500A  984741     MOV.B W1, [W14+4]
1060:                  }
1061:                  ptcb = OSTCBPrioTbl[prio];
00500C  90404E     MOV.B [W14+4], W0
00500E  FB8000     ZE W0, W0
005010  400080     ADD W0, W0, W1
005012  219000     MOV #0x1900, W0
005014  408000     ADD W1, W0, W0
005016  780090     MOV [W0], W1
005018  980711     MOV W1, [W14+2]
1062:                  if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00501A  90001E     MOV [W14+2], W0
00501C  E00000     CP0 W0
00501E  3A0004     BRA NZ, 0x5028
1063:                      OS_EXIT_CRITICAL();
005020  78009E     MOV [W14], W1
005022  880211     MOV W1, SR
1064:                      return (OS_ERR_PRIO);
005024  B3C290     MOV.B #0x29, W0
005026  37000E     BRA 0x5044
1065:                  }
1066:                  if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
005028  90001E     MOV [W14+2], W0
00502A  500FE1     SUB W0, #0x1, [W15]
00502C  3A0004     BRA NZ, 0x5036
1067:                      OS_EXIT_CRITICAL();
00502E  78009E     MOV [W14], W1
005030  880211     MOV W1, SR
1068:                      return (OS_ERR_TASK_NOT_EXIST);
005032  B3C430     MOV.B #0x43, W0
005034  370007     BRA 0x5044
1069:                  }
1070:                                                               /* Copy TCB into user storage area                    */
1071:                  OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
005036  90009E     MOV [W14+2], W1
005038  90003E     MOV [W14+6], W0
00503A  2003A2     MOV #0x3A, W2
00503C  07ECD2     RCALL OS_MemCopy
1072:                  OS_EXIT_CRITICAL();
00503E  78009E     MOV [W14], W1
005040  880211     MOV W1, SR
1073:                  return (OS_ERR_NONE);
005042  EB4000     CLR.B W0
1074:              }
005044  FA8000     ULNK
005046  060000     RETURN
1075:              #endif
1076:              /*$PAGE*/
1077:              /*
1078:              *********************************************************************************************************
1079:              *                              GET THE CURRENT VALUE OF A TASK REGISTER
1080:              *
1081:              * Description: This function is called to obtain the current value of a task register.  Task registers
1082:              *              are application specific and can be used to store task specific values such as 'error
1083:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1084:              *
1085:              * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
1086:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1087:              *
1088:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1089:              *                        than OS_TASK_REG_TBL_SIZE
1090:              *
1091:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1092:              *
1093:              *                        OS_ERR_NONE            if the call was successful
1094:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1095:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1096:              *
1097:              * Returns    : The current value of the task's register or 0 if an error is detected.
1098:              *
1099:              * Note(s)    : The maximum number of task variables is 254
1100:              *********************************************************************************************************
1101:              */
1102:              
1103:              #if OS_TASK_REG_TBL_SIZE > 0u
1104:              INT32U  OSTaskRegGet (INT8U   prio,
1105:                                    INT8U   id,
1106:                                    INT8U  *perr)
1107:              {
005048  FA000C     LNK #0xC
00504A  984F00     MOV.B W0, [W14+8]
00504C  984F11     MOV.B W1, [W14+9]
00504E  980752     MOV W2, [W14+10]
1108:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1109:                  OS_CPU_SR  cpu_sr = 0u;
005050  EB0000     CLR W0
005052  980710     MOV W0, [W14+2]
1110:              #endif
1111:                  INT32U     value;
1112:                  OS_TCB    *ptcb;
1113:              
1114:              
1115:              
1116:              #ifdef OS_SAFETY_CRITICAL
1117:                  if (perr == (INT8U *)0) {
1118:                      OS_SAFETY_CRITICAL_EXCEPTION();
1119:                      return (0u);
1120:                  }
1121:              #endif
1122:              
1123:              #if OS_ARG_CHK_EN > 0u
1124:                  if (prio >= OS_LOWEST_PRIO) {
005054  90480E     MOV.B [W14+8], W0
005056  504FE9     SUB.B W0, #0x9, [W15]
005058  360008     BRA LEU, 0x506A
1125:                      if (prio != OS_PRIO_SELF) {
00505A  90480E     MOV.B [W14+8], W0
00505C  404FE1     ADD.B W0, #0x1, [W15]
00505E  320005     BRA Z, 0x506A
1126:                          *perr = OS_ERR_PRIO_INVALID;
005060  90005E     MOV [W14+10], W0
005062  B3C2A1     MOV.B #0x2A, W1
005064  784801     MOV.B W1, [W0]
1127:                          return (0u);
005066  B80060     MUL.UU W0, #0, W0
005068  37002A     BRA 0x50BE
1128:                      }
1129:                  }
1130:                  if (id >= OS_TASK_REG_TBL_SIZE) {
00506A  90481E     MOV.B [W14+9], W0
00506C  E00400     CP0.B W0
00506E  320005     BRA Z, 0x507A
1131:                      *perr = OS_ERR_ID_INVALID;
005070  90005E     MOV [W14+10], W0
005072  B3C081     MOV.B #0x8, W1
005074  784801     MOV.B W1, [W0]
1132:                      return (0u);
005076  B80060     MUL.UU W0, #0, W0
005078  370022     BRA 0x50BE
1133:                  }
1134:              #endif
1135:                  OS_ENTER_CRITICAL();
00507A  800211     MOV SR, W1
00507C  980711     MOV W1, [W14+2]
00507E  800211     MOV SR, W1
005080  200E00     MOV #0xE0, W0
005082  700001     IOR W0, W1, W0
005084  880210     MOV W0, SR
1136:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
005086  90480E     MOV.B [W14+8], W0
005088  404FE1     ADD.B W0, #0x1, [W15]
00508A  3A0003     BRA NZ, 0x5092
1137:                      ptcb = OSTCBCur;
00508C  804362     MOV OSTCBCur, W2
00508E  780F02     MOV W2, [W14]
005090  370006     BRA 0x509E
1138:                  } else {
1139:                      ptcb = OSTCBPrioTbl[prio];
005092  90480E     MOV.B [W14+8], W0
005094  FB8000     ZE W0, W0
005096  400080     ADD W0, W0, W1
005098  219000     MOV #0x1900, W0
00509A  408000     ADD W1, W0, W0
00509C  780F10     MOV [W0], [W14]
1140:                  }
1141:                  value = ptcb->OSTCBRegTbl[id];
00509E  90481E     MOV.B [W14+9], W0
0050A0  FB8000     ZE W0, W0
0050A2  78009E     MOV [W14], W1
0050A4  DD0042     SL W0, #2, W0
0050A6  B00360     ADD #0x36, W0
0050A8  408000     ADD W1, W0, W0
0050AA  BE0110     MOV.D [W0], W2
0050AC  980722     MOV W2, [W14+4]
0050AE  980733     MOV W3, [W14+6]
1142:                  OS_EXIT_CRITICAL();
0050B0  90019E     MOV [W14+2], W3
0050B2  880213     MOV W3, SR
1143:                  *perr = OS_ERR_NONE;
0050B4  90005E     MOV [W14+10], W0
0050B6  EB4080     CLR.B W1
0050B8  784801     MOV.B W1, [W0]
1144:                  return (value);
0050BA  90002E     MOV [W14+4], W0
0050BC  9000BE     MOV [W14+6], W1
1145:              }
0050BE  FA8000     ULNK
0050C0  060000     RETURN
1146:              #endif
1147:              
1148:              /*$PAGE*/
1149:              /*
1150:              ************************************************************************************************************************
1151:              *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
1152:              *
1153:              * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
1154:              *              allocated dynamically instead of statically.
1155:              *
1156:              * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
1157:              *
1158:              *                            OS_ERR_NONE               if the call was successful
1159:              *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
1160:              *                                                           have available through OS_TASK_REG_TBL_SIZE.
1161:              *
1162:              * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
1163:              ************************************************************************************************************************
1164:              */
1165:              
1166:              #if OS_TASK_REG_TBL_SIZE > 0u
1167:              INT8U  OSTaskRegGetID (INT8U  *perr)
1168:              {
0050C2  FA0006     LNK #0x6
0050C4  980720     MOV W0, [W14+4]
1169:              #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
1170:                  OS_CPU_SR  cpu_sr = 0u;
0050C6  EB0000     CLR W0
0050C8  780F00     MOV W0, [W14]
1171:              #endif
1172:                  INT8U      id;
1173:              
1174:              
1175:              #ifdef OS_SAFETY_CRITICAL
1176:                  if (perr == (INT8U *)0) {
1177:                      OS_SAFETY_CRITICAL_EXCEPTION();
1178:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
1179:                  }
1180:              #endif
1181:              
1182:                  OS_ENTER_CRITICAL();
0050CA  800211     MOV SR, W1
0050CC  780F01     MOV W1, [W14]
0050CE  800211     MOV SR, W1
0050D0  200E00     MOV #0xE0, W0
0050D2  700001     IOR W0, W1, W0
0050D4  880210     MOV W0, SR
1183:                  if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
0050D6  BFC875     MOV.B OSTaskRegNextAvailID, WREG
0050D8  E00400     CP0.B W0
0050DA  320007     BRA Z, 0x50EA
1184:                     *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
0050DC  90002E     MOV [W14+4], W0
0050DE  B3C961     MOV.B #0x96, W1
0050E0  784801     MOV.B W1, [W0]
1185:                      OS_EXIT_CRITICAL();
0050E2  78009E     MOV [W14], W1
0050E4  880211     MOV W1, SR
1186:                      return ((INT8U)OS_TASK_REG_TBL_SIZE);
0050E6  B3C010     MOV.B #0x1, W0
0050E8  37000C     BRA 0x5102
1187:                  }
1188:                   
1189:                  id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
0050EA  208751     MOV #0x875, W1
0050EC  784091     MOV.B [W1], W1
0050EE  984721     MOV.B W1, [W14+2]
1190:                  OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
0050F0  BFC875     MOV.B OSTaskRegNextAvailID, WREG
0050F2  E84000     INC.B W0, W0
0050F4  B7E875     MOV.B WREG, OSTaskRegNextAvailID
1191:                  OS_EXIT_CRITICAL();
0050F6  78009E     MOV [W14], W1
0050F8  880211     MOV W1, SR
1192:                 *perr = OS_ERR_NONE;
0050FA  90002E     MOV [W14+4], W0
0050FC  EB4080     CLR.B W1
0050FE  784801     MOV.B W1, [W0]
1193:                  return (id);
005100  90402E     MOV.B [W14+2], W0
1194:              }
005102  FA8000     ULNK
005104  060000     RETURN
1195:              #endif
1196:              
1197:              /*$PAGE*/
1198:              /*
1199:              *********************************************************************************************************
1200:              *                              SET THE CURRENT VALUE OF A TASK VARIABLE
1201:              *
1202:              * Description: This function is called to change the current value of a task register.  Task registers
1203:              *              are application specific and can be used to store task specific values such as 'error
1204:              *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
1205:              *
1206:              * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
1207:              *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
1208:              *
1209:              *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
1210:              *                        than OS_TASK_REG_TBL_SIZE
1211:              *
1212:              *              value     is the desired value for the task register.
1213:              *
1214:              *              perr      is a pointer to a variable that will hold an error code related to this call.
1215:              *
1216:              *                        OS_ERR_NONE            if the call was successful
1217:              *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
1218:              *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
1219:              *
1220:              * Returns    : The current value of the task's variable or 0 if an error is detected.
1221:              *
1222:              * Note(s)    : The maximum number of task variables is 254
1223:              *********************************************************************************************************
1224:              */
1225:              
1226:              #if OS_TASK_REG_TBL_SIZE > 0u
1227:              void  OSTaskRegSet (INT8U    prio,
1228:                                  INT8U    id,
1229:                                  INT32U   value,
1230:                                  INT8U   *perr)
1231:              {
005106  FA000C     LNK #0xC
005108  984740     MOV.B W0, [W14+4]
00510A  984751     MOV.B W1, [W14+5]
00510C  980732     MOV W2, [W14+6]
00510E  980743     MOV W3, [W14+8]
005110  980754     MOV W4, [W14+10]
1232:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1233:                  OS_CPU_SR  cpu_sr = 0u;
005112  EB0000     CLR W0
005114  980710     MOV W0, [W14+2]
1234:              #endif
1235:                  OS_TCB    *ptcb;
1236:              
1237:              
1238:              #ifdef OS_SAFETY_CRITICAL
1239:                  if (perr == (INT8U *)0) {
1240:                      OS_SAFETY_CRITICAL_EXCEPTION();
1241:                      return;
1242:                  }
1243:              #endif
1244:              
1245:              #if OS_ARG_CHK_EN > 0u
1246:                  if (prio >= OS_LOWEST_PRIO) {
005116  90404E     MOV.B [W14+4], W0
005118  504FE9     SUB.B W0, #0x9, [W15]
00511A  360007     BRA LEU, 0x512A
1247:                      if (prio != OS_PRIO_SELF) {
00511C  90404E     MOV.B [W14+4], W0
00511E  404FE1     ADD.B W0, #0x1, [W15]
005120  320004     BRA Z, 0x512A
1248:                          *perr = OS_ERR_PRIO_INVALID;
005122  90005E     MOV [W14+10], W0
005124  B3C2A1     MOV.B #0x2A, W1
005126  784801     MOV.B W1, [W0]
1249:                          return;
005128  370027     BRA 0x5178
1250:                      }
1251:                  }
1252:                  if (id >= OS_TASK_REG_TBL_SIZE) {
00512A  90405E     MOV.B [W14+5], W0
00512C  E00400     CP0.B W0
00512E  320004     BRA Z, 0x5138
1253:                      *perr = OS_ERR_ID_INVALID;
005130  90005E     MOV [W14+10], W0
005132  B3C081     MOV.B #0x8, W1
005134  784801     MOV.B W1, [W0]
1254:                      return;
005136  370020     BRA 0x5178
1255:                  }
1256:              #endif
1257:                  OS_ENTER_CRITICAL();
005138  800211     MOV SR, W1
00513A  980711     MOV W1, [W14+2]
00513C  800211     MOV SR, W1
00513E  200E00     MOV #0xE0, W0
005140  700001     IOR W0, W1, W0
005142  880210     MOV W0, SR
1258:                  if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
005144  90404E     MOV.B [W14+4], W0
005146  404FE1     ADD.B W0, #0x1, [W15]
005148  3A0003     BRA NZ, 0x5150
1259:                      ptcb = OSTCBCur;
00514A  804362     MOV OSTCBCur, W2
00514C  780F02     MOV W2, [W14]
00514E  370006     BRA 0x515C
1260:                  } else {
1261:                      ptcb = OSTCBPrioTbl[prio];
005150  90404E     MOV.B [W14+4], W0
005152  FB8000     ZE W0, W0
005154  400080     ADD W0, W0, W1
005156  219000     MOV #0x1900, W0
005158  408000     ADD W1, W0, W0
00515A  780F10     MOV [W0], [W14]
1262:                  }
1263:                  ptcb->OSTCBRegTbl[id] = value;
00515C  90405E     MOV.B [W14+5], W0
00515E  FB8000     ZE W0, W0
005160  78009E     MOV [W14], W1
005162  DD0042     SL W0, #2, W0
005164  408000     ADD W1, W0, W0
005166  B00360     ADD #0x36, W0
005168  90013E     MOV [W14+6], W2
00516A  9001CE     MOV [W14+8], W3
00516C  BE8802     MOV.D W2, [W0]
1264:                  OS_EXIT_CRITICAL();
00516E  90019E     MOV [W14+2], W3
005170  880213     MOV W3, SR
1265:                  *perr                 = OS_ERR_NONE;
005172  90005E     MOV [W14+10], W0
005174  EB4080     CLR.B W1
005176  784801     MOV.B W1, [W0]
1266:              }
005178  FA8000     ULNK
00517A  060000     RETURN
1267:              #endif
1268:              
1269:              /*$PAGE*/
1270:              /*
1271:              *********************************************************************************************************
1272:              *                                    CATCH ACCIDENTAL TASK RETURN
1273:              *
1274:              * Description: This function is called if a task accidentally returns without deleting itself.  In other
1275:              *              words, a task should either be an infinite loop or delete itself if it's done.
1276:              *
1277:              * Arguments  : none
1278:              *
1279:              * Returns    : none
1280:              *
1281:              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
1282:              *********************************************************************************************************
1283:              */
1284:              
1285:              void  OS_TaskReturn (void)
1286:              {
00517C  FA0000     LNK #0x0
1287:                  OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
00517E  804360     MOV OSTCBCur, W0
005180  070ECD     RCALL OSTaskReturnHook
1288:              
1289:              #if OS_TASK_DEL_EN > 0u
1290:                  (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
005182  EBC000     SETM.B W0
005184  07FC4A     RCALL OSTaskDel
1291:              #else
1292:                  for (;;) {
1293:                      OSTimeDly(OS_TICKS_PER_SEC);
1294:                  }
1295:              #endif
1296:              }
005186  FA8000     ULNK
005188  060000     RETURN
1297:              
1298:              /*$PAGE*/
1299:              /*
1300:              *********************************************************************************************************
1301:              *                                          CLEAR TASK STACK
1302:              *
1303:              * Description: This function is used to clear the stack of a task (i.e. write all zeros)
1304:              *
1305:              * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
1306:              *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
1307:              *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
1308:              *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
1309:              *                       highest memory location of the stack and the stack will grow with increasing
1310:              *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
1311:              *
1312:              *              size     is the number of 'stack elements' to clear.
1313:              *
1314:              *              opt      contains additional information (or options) about the behavior of the task.  The
1315:              *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
1316:              *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
1317:              *
1318:              * Returns    : none
1319:              *********************************************************************************************************
1320:              */
1321:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1322:              void  OS_TaskStkClr (OS_STK  *pbos,
1323:                                   INT32U   size,
1324:                                   INT16U   opt)
1325:              {
00518A  FA0008     LNK #0x8
00518C  780F00     MOV W0, [W14]
00518E  980712     MOV W2, [W14+2]
005190  980723     MOV W3, [W14+4]
005192  980731     MOV W1, [W14+6]
1326:                  if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
005194  90003E     MOV [W14+6], W0
005196  600061     AND W0, #0x1, W0
005198  784000     MOV.B W0, W0
00519A  E00400     CP0.B W0
00519C  320014     BRA Z, 0x51C6
1327:                      if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
00519E  90003E     MOV [W14+6], W0
0051A0  600062     AND W0, #0x2, W0
0051A2  E00000     CP0 W0
0051A4  320010     BRA Z, 0x51C6
1328:              #if OS_STK_GROWTH == 1u
1329:                          while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
1330:                              size--;
1331:                              *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
1332:                          }
1333:              #else
1334:                          while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
0051A6  37000A     BRA 0x51BC
0051BC  90001E     MOV [W14+2], W0
0051BE  9000AE     MOV [W14+4], W1
0051C0  500FE0     SUB W0, #0x0, [W15]
0051C2  588FE0     SUBB W1, #0x0, [W15]
0051C4  3AFFF1     BRA NZ, 0x51A8
1335:                              size--;
0051A8  90001E     MOV [W14+2], W0
0051AA  9000AE     MOV [W14+4], W1
0051AC  500061     SUB W0, #0x1, W0
0051AE  5880E0     SUBB W1, #0x0, W1
0051B0  980710     MOV W0, [W14+2]
0051B2  980721     MOV W1, [W14+4]
1336:                              *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
0051B4  78001E     MOV [W14], W0
0051B6  EB0080     CLR W1
0051B8  780801     MOV W1, [W0]
0051BA  E98F1E     DEC2 [W14], [W14]
1337:                          }
1338:              #endif
1339:                      }
1340:                  }
1341:              }
0051C6  FA8000     ULNK
1342:              
1343:              #endif
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Source/os_sem.c  -------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                          SEMAPHORE MANAGEMENT
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_SEM.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.11
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #include <ucos_ii.h>
28:                #endif
29:                
30:                #if OS_SEM_EN > 0u
31:                /*$PAGE*/
32:                /*
33:                *********************************************************************************************************
34:                *                                          ACCEPT SEMAPHORE
35:                *
36:                * Description: This function checks the semaphore to see if a resource is available or, if an event
37:                *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
38:                *              resource is not available or the event did not occur.
39:                *
40:                * Arguments  : pevent     is a pointer to the event control block
41:                *
42:                * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
43:                *                         decremented to obtain the resource.
44:                *              == 0       if the resource is not available or the event did not occur or,
45:                *                         if 'pevent' is a NULL pointer or,
46:                *                         if you didn't pass a pointer to a semaphore
47:                *********************************************************************************************************
48:                */
49:                
50:                #if OS_SEM_ACCEPT_EN > 0u
51:                INT16U  OSSemAccept (OS_EVENT *pevent)
52:                {
0051CA  FA0006     LNK #0x6
0051CC  980720     MOV W0, [W14+4]
53:                    INT16U     cnt;
54:                #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
55:                    OS_CPU_SR  cpu_sr = 0u;
0051CE  EB0000     CLR W0
0051D0  780F00     MOV W0, [W14]
56:                #endif
57:                
58:                
59:                
60:                #if OS_ARG_CHK_EN > 0u
61:                    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0051D2  90002E     MOV [W14+4], W0
0051D4  E00000     CP0 W0
0051D6  3A0002     BRA NZ, 0x51DC
62:                        return (0u);
0051D8  EB0000     CLR W0
0051DA  37001A     BRA 0x5210
63:                    }
64:                #endif
65:                    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
0051DC  90002E     MOV [W14+4], W0
0051DE  784010     MOV.B [W0], W0
0051E0  504FE3     SUB.B W0, #0x3, [W15]
0051E2  320002     BRA Z, 0x51E8
66:                        return (0u);
0051E4  EB0000     CLR W0
0051E6  370014     BRA 0x5210
67:                    }
68:                    OS_ENTER_CRITICAL();
0051E8  800211     MOV SR, W1
0051EA  780F01     MOV W1, [W14]
0051EC  800211     MOV SR, W1
0051EE  200E00     MOV #0xE0, W0
0051F0  700001     IOR W0, W1, W0
0051F2  880210     MOV W0, SR
69:                    cnt = pevent->OSEventCnt;
0051F4  90002E     MOV [W14+4], W0
0051F6  9000A0     MOV [W0+4], W1
0051F8  980711     MOV W1, [W14+2]
70:                    if (cnt > 0u) {                                   /* See if resource is available                  */
0051FA  90001E     MOV [W14+2], W0
0051FC  E00000     CP0 W0
0051FE  320005     BRA Z, 0x520A
71:                        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
005200  90002E     MOV [W14+4], W0
005202  900020     MOV [W0+4], W0
005204  E90080     DEC W0, W1
005206  90002E     MOV [W14+4], W0
005208  980021     MOV W1, [W0+4]
72:                    }
73:                    OS_EXIT_CRITICAL();
00520A  78009E     MOV [W14], W1
00520C  880211     MOV W1, SR
74:                    return (cnt);                                     /* Return semaphore count                        */
00520E  90001E     MOV [W14+2], W0
75:                }
005210  FA8000     ULNK
005212  060000     RETURN
76:                #endif
77:                
78:                /*$PAGE*/
79:                /*
80:                *********************************************************************************************************
81:                *                                         CREATE A SEMAPHORE
82:                *
83:                * Description: This function creates a semaphore.
84:                *
85:                * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
86:                *                            available (or no event has occurred).  You initialize the semaphore to a
87:                *                            non-zero value to specify how many resources are available (e.g. if you have
88:                *                            10 resources, you would initialize the semaphore to 10).
89:                *
90:                * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
91:                *                            created semaphore
92:                *              == (void *)0  if no event control blocks were available
93:                *********************************************************************************************************
94:                */
95:                
96:                OS_EVENT  *OSSemCreate (INT16U cnt)
97:                {
005214  FA0006     LNK #0x6
005216  980720     MOV W0, [W14+4]
98:                    OS_EVENT  *pevent;
99:                #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
100:                   OS_CPU_SR  cpu_sr = 0u;
005218  EB0000     CLR W0
00521A  780F00     MOV W0, [W14]
101:               #endif
102:               
103:               
104:               
105:               #ifdef OS_SAFETY_CRITICAL_IEC61508
106:                   if (OSSafetyCriticalStartFlag == OS_TRUE) {
107:                       OS_SAFETY_CRITICAL_EXCEPTION();
108:                       return ((OS_EVENT *)0);
109:                   }
110:               #endif
111:               
112:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00521C  BFC861     MOV.B OSIntNesting, WREG
00521E  E00400     CP0.B W0
005220  320002     BRA Z, 0x5226
113:                       return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
005222  EB0000     CLR W0
005224  370022     BRA 0x526A
114:                   }
115:                   OS_ENTER_CRITICAL();
005226  800211     MOV SR, W1
005228  780F01     MOV W1, [W14]
00522A  800211     MOV SR, W1
00522C  200E00     MOV #0xE0, W0
00522E  700001     IOR W0, W1, W0
005230  880210     MOV W0, SR
116:                   pevent = OSEventFreeList;                              /* Get next free event control block        */
005232  8042A1     MOV OSEventFreeList, W1
005234  980711     MOV W1, [W14+2]
117:                   if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
005236  8042A0     MOV OSEventFreeList, W0
005238  E00000     CP0 W0
00523A  320003     BRA Z, 0x5242
118:                       OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00523C  8042A0     MOV OSEventFreeList, W0
00523E  900010     MOV [W0+2], W0
005240  8842A0     MOV W0, OSEventFreeList
119:                   }
120:                   OS_EXIT_CRITICAL();
005242  78009E     MOV [W14], W1
005244  880211     MOV W1, SR
121:                   if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
005246  90001E     MOV [W14+2], W0
005248  E00000     CP0 W0
00524A  32000E     BRA Z, 0x5268
122:                       pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00524C  90001E     MOV [W14+2], W0
00524E  B3C031     MOV.B #0x3, W1
005250  784801     MOV.B W1, [W0]
123:                       pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
005252  90001E     MOV [W14+2], W0
005254  9000AE     MOV [W14+4], W1
005256  980021     MOV W1, [W0+4]
124:                       pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
005258  90001E     MOV [W14+2], W0
00525A  EB0080     CLR W1
00525C  980011     MOV W1, [W0+2]
125:               #if OS_EVENT_NAME_EN > 0u
126:                       pevent->OSEventName    = (INT8U *)(void *)"?";
00525E  29FF61     MOV #0x9FF6, W1
005260  90001E     MOV [W14+2], W0
005262  980051     MOV W1, [W0+10]
127:               #endif
128:                       OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
005264  90001E     MOV [W14+2], W0
005266  07EADE     RCALL OS_EventWaitListInit
129:                   }
130:                   return (pevent);
005268  90001E     MOV [W14+2], W0
131:               }
00526A  FA8000     ULNK
00526C  060000     RETURN
132:               
133:               /*$PAGE*/
134:               /*
135:               *********************************************************************************************************
136:               *                                         DELETE A SEMAPHORE
137:               *
138:               * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
139:               *
140:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
141:               *                            semaphore.
142:               *
143:               *              opt           determines delete options as follows:
144:               *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
145:               *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
146:               *                                                    In this case, all the tasks pending will be readied.
147:               *
148:               *              perr          is a pointer to an error code that can contain one of the following values:
149:               *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
150:               *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
151:               *                            OS_ERR_INVALID_OPT      An invalid option was specified
152:               *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
153:               *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
154:               *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
155:               *
156:               * Returns    : pevent        upon error
157:               *              (OS_EVENT *)0 if the semaphore was successfully deleted.
158:               *
159:               * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
160:               *                 the semaphore MUST check the return code of OSSemPend().
161:               *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
162:               *                 they check 'pevent' to see that it's a NULL pointer.
163:               *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
164:               *                 time is directly proportional to the number of tasks waiting on the semaphore.
165:               *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
166:               *                 applications where the semaphore is used for mutual exclusion because the resource(s)
167:               *                 will no longer be guarded by the semaphore.
168:               *              5) All tasks that were waiting for the semaphore will be readied and returned an 
169:               *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
170:               *********************************************************************************************************
171:               */
172:               
173:               #if OS_SEM_DEL_EN > 0u
174:               OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
175:                                    INT8U      opt,
176:                                    INT8U     *perr)
177:               {
00526E  FA000C     LNK #0xC
005270  980730     MOV W0, [W14+6]
005272  984F01     MOV.B W1, [W14+8]
005274  980752     MOV W2, [W14+10]
178:                   BOOLEAN    tasks_waiting;
179:                   OS_EVENT  *pevent_return;
180:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
181:                   OS_CPU_SR  cpu_sr = 0u;
005276  EB0000     CLR W0
005278  980720     MOV W0, [W14+4]
182:               #endif
183:               
184:               
185:               
186:               #ifdef OS_SAFETY_CRITICAL
187:                   if (perr == (INT8U *)0) {
188:                       OS_SAFETY_CRITICAL_EXCEPTION();
189:                       return ((OS_EVENT *)0);
190:                   }
191:               #endif
192:               
193:               #if OS_ARG_CHK_EN > 0u
194:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
00527A  90003E     MOV [W14+6], W0
00527C  E00000     CP0 W0
00527E  3A0005     BRA NZ, 0x528A
195:                       *perr = OS_ERR_PEVENT_NULL;
005280  90005E     MOV [W14+10], W0
005282  B3C041     MOV.B #0x4, W1
005284  784801     MOV.B W1, [W0]
196:                       return (pevent);
005286  90003E     MOV [W14+6], W0
005288  370076     BRA 0x5376
197:                   }
198:               #endif
199:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00528A  90003E     MOV [W14+6], W0
00528C  784010     MOV.B [W0], W0
00528E  504FE3     SUB.B W0, #0x3, [W15]
005290  320005     BRA Z, 0x529C
200:                       *perr = OS_ERR_EVENT_TYPE;
005292  90005E     MOV [W14+10], W0
005294  B3C011     MOV.B #0x1, W1
005296  784801     MOV.B W1, [W0]
201:                       return (pevent);
005298  90003E     MOV [W14+6], W0
00529A  37006D     BRA 0x5376
202:                   }
203:                   if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00529C  BFC861     MOV.B OSIntNesting, WREG
00529E  E00400     CP0.B W0
0052A0  320005     BRA Z, 0x52AC
204:                       *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0052A2  90005E     MOV [W14+10], W0
0052A4  B3C0F1     MOV.B #0xF, W1
0052A6  784801     MOV.B W1, [W0]
205:                       return (pevent);
0052A8  90003E     MOV [W14+6], W0
0052AA  370065     BRA 0x5376
206:                   }
207:                   OS_ENTER_CRITICAL();
0052AC  800211     MOV SR, W1
0052AE  980721     MOV W1, [W14+4]
0052B0  800211     MOV SR, W1
0052B2  200E00     MOV #0xE0, W0
0052B4  700001     IOR W0, W1, W0
0052B6  880210     MOV W0, SR
208:                   if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
0052B8  90003E     MOV [W14+6], W0
0052BA  904060     MOV.B [W0+6], W0
0052BC  E00400     CP0.B W0
0052BE  320003     BRA Z, 0x52C6
209:                       tasks_waiting = OS_TRUE;                           /* Yes                                      */
0052C0  B3C010     MOV.B #0x1, W0
0052C2  784F00     MOV.B W0, [W14]
0052C4  370002     BRA 0x52CA
210:                   } else {
211:                       tasks_waiting = OS_FALSE;                          /* No                                       */
0052C6  EB4000     CLR.B W0
0052C8  784F00     MOV.B W0, [W14]
212:                   }
213:                   switch (opt) {
0052CA  90480E     MOV.B [W14+8], W0
0052CC  FB8000     ZE W0, W0
0052CE  E00000     CP0 W0
0052D0  320003     BRA Z, 0x52D8
0052D2  500FE1     SUB W0, #0x1, [W15]
0052D4  320028     BRA Z, 0x5326
0052D6  370046     BRA 0x5364
214:                       case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
215:                            if (tasks_waiting == OS_FALSE) {
0052D8  78401E     MOV.B [W14], W0
0052DA  E00400     CP0.B W0
0052DC  3A0016     BRA NZ, 0x530A
216:               #if OS_EVENT_NAME_EN > 0u
217:                                pevent->OSEventName    = (INT8U *)(void *)"?";
0052DE  29FF61     MOV #0x9FF6, W1
0052E0  90003E     MOV [W14+6], W0
0052E2  980051     MOV W1, [W0+10]
218:               #endif
219:                                pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0052E4  90003E     MOV [W14+6], W0
0052E6  EB4080     CLR.B W1
0052E8  784801     MOV.B W1, [W0]
220:                                pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
0052EA  8042A1     MOV OSEventFreeList, W1
0052EC  90003E     MOV [W14+6], W0
0052EE  980011     MOV W1, [W0+2]
221:                                pevent->OSEventCnt     = 0u;
0052F0  90003E     MOV [W14+6], W0
0052F2  EB0080     CLR W1
0052F4  980021     MOV W1, [W0+4]
222:                                OSEventFreeList        = pevent;          /* Get next free event control block        */
0052F6  9000BE     MOV [W14+6], W1
0052F8  8842A1     MOV W1, OSEventFreeList
223:                                OS_EXIT_CRITICAL();
0052FA  9000AE     MOV [W14+4], W1
0052FC  880211     MOV W1, SR
224:                                *perr                  = OS_ERR_NONE;
0052FE  90005E     MOV [W14+10], W0
005300  EB4080     CLR.B W1
005302  784801     MOV.B W1, [W0]
225:                                pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
005304  EB0000     CLR W0
005306  980710     MOV W0, [W14+2]
226:                            } else {
227:                                OS_EXIT_CRITICAL();
00530A  9000AE     MOV [W14+4], W1
00530C  880211     MOV W1, SR
228:                                *perr                  = OS_ERR_TASK_WAITING;
00530E  90005E     MOV [W14+10], W0
005310  B3C491     MOV.B #0x49, W1
005312  784801     MOV.B W1, [W0]
229:                                pevent_return          = pevent;
005314  9000BE     MOV [W14+6], W1
005316  980711     MOV W1, [W14+2]
230:                            }
231:                            break;
005308  370035     BRA 0x5374
005318  37002D     BRA 0x5374
232:               
233:                       case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
234:                            while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
005326  000000     NOP
005328  90003E     MOV [W14+6], W0
00532A  904060     MOV.B [W0+6], W0
00532C  E00400     CP0.B W0
00532E  3AFFF5     BRA NZ, 0x531A
235:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00531A  B3C023     MOV.B #0x2, W3
00531C  B3C012     MOV.B #0x1, W2
00531E  EB0080     CLR W1
005320  90003E     MOV [W14+6], W0
005322  07E94E     RCALL OS_EventTaskRdy
005324  370001     BRA 0x5328
236:                            }
237:               #if OS_EVENT_NAME_EN > 0u
238:                            pevent->OSEventName    = (INT8U *)(void *)"?";
005330  29FF61     MOV #0x9FF6, W1
005332  90003E     MOV [W14+6], W0
005334  980051     MOV W1, [W0+10]
239:               #endif
240:                            pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
005336  90003E     MOV [W14+6], W0
005338  EB4080     CLR.B W1
00533A  784801     MOV.B W1, [W0]
241:                            pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00533C  8042A1     MOV OSEventFreeList, W1
00533E  90003E     MOV [W14+6], W0
005340  980011     MOV W1, [W0+2]
242:                            pevent->OSEventCnt     = 0u;
005342  90003E     MOV [W14+6], W0
005344  EB0080     CLR W1
005346  980021     MOV W1, [W0+4]
243:                            OSEventFreeList        = pevent;              /* Get next free event control block        */
005348  9000BE     MOV [W14+6], W1
00534A  8842A1     MOV W1, OSEventFreeList
244:                            OS_EXIT_CRITICAL();
00534C  9000AE     MOV [W14+4], W1
00534E  880211     MOV W1, SR
245:                            if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
005350  78401E     MOV.B [W14], W0
005352  504FE1     SUB.B W0, #0x1, [W15]
005354  3A0001     BRA NZ, 0x5358
246:                                OS_Sched();                               /* Find highest priority task ready to run  */
005356  07EB5A     RCALL OS_Sched
247:                            }
248:                            *perr                  = OS_ERR_NONE;
005358  90005E     MOV [W14+10], W0
00535A  EB4080     CLR.B W1
00535C  784801     MOV.B W1, [W0]
249:                            pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00535E  EB0000     CLR W0
005360  980710     MOV W0, [W14+2]
250:                            break;
005362  370008     BRA 0x5374
251:               
252:                       default:
253:                            OS_EXIT_CRITICAL();
005364  9000AE     MOV [W14+4], W1
005366  880211     MOV W1, SR
254:                            *perr                  = OS_ERR_INVALID_OPT;
005368  90005E     MOV [W14+10], W0
00536A  B3C071     MOV.B #0x7, W1
00536C  784801     MOV.B W1, [W0]
255:                            pevent_return          = pevent;
00536E  9000BE     MOV [W14+6], W1
005370  980711     MOV W1, [W14+2]
256:                            break;
005372  000000     NOP
257:                   }
258:                   return (pevent_return);
005374  90001E     MOV [W14+2], W0
259:               }
005376  FA8000     ULNK
005378  060000     RETURN
260:               #endif
261:               
262:               /*$PAGE*/
263:               /*
264:               *********************************************************************************************************
265:               *                                          PEND ON SEMAPHORE
266:               *
267:               * Description: This function waits for a semaphore.
268:               *
269:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
270:               *                            semaphore.
271:               *
272:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
273:               *                            wait for the resource up to the amount of time specified by this argument.
274:               *                            If you specify 0, however, your task will wait forever at the specified
275:               *                            semaphore or, until the resource becomes available (or the event occurs).
276:               *
277:               *              perr          is a pointer to where an error message will be deposited.  Possible error
278:               *                            messages are:
279:               *
280:               *                            OS_ERR_NONE         The call was successful and your task owns the resource
281:               *                                                or, the event you are waiting for occurred.
282:               *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
283:               *                                                'timeout'.
284:               *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
285:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
286:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
287:               *                                                would lead to a suspension.
288:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
289:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
290:               *
291:               * Returns    : none
292:               *********************************************************************************************************
293:               */
294:               /*$PAGE*/
295:               void  OSSemPend (OS_EVENT  *pevent,
296:                                INT32U     timeout,
297:                                INT8U     *perr)
298:               {
00537A  FA000A     LNK #0xA
00537C  980710     MOV W0, [W14+2]
00537E  980722     MOV W2, [W14+4]
005380  980733     MOV W3, [W14+6]
005382  980741     MOV W1, [W14+8]
299:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
300:                   OS_CPU_SR  cpu_sr = 0u;
005384  EB0000     CLR W0
005386  780F00     MOV W0, [W14]
301:               #endif
302:               
303:               
304:               
305:               #ifdef OS_SAFETY_CRITICAL
306:                   if (perr == (INT8U *)0) {
307:                       OS_SAFETY_CRITICAL_EXCEPTION();
308:                       return;
309:                   }
310:               #endif
311:               
312:               #if OS_ARG_CHK_EN > 0u
313:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005388  90001E     MOV [W14+2], W0
00538A  E00000     CP0 W0
00538C  3A0004     BRA NZ, 0x5396
314:                       *perr = OS_ERR_PEVENT_NULL;
00538E  90004E     MOV [W14+8], W0
005390  B3C041     MOV.B #0x4, W1
005392  784801     MOV.B W1, [W0]
315:                       return;
005394  370068     BRA 0x5466
316:                   }
317:               #endif
318:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005396  90001E     MOV [W14+2], W0
005398  784010     MOV.B [W0], W0
00539A  504FE3     SUB.B W0, #0x3, [W15]
00539C  320004     BRA Z, 0x53A6
319:                       *perr = OS_ERR_EVENT_TYPE;
00539E  90004E     MOV [W14+8], W0
0053A0  B3C011     MOV.B #0x1, W1
0053A2  784801     MOV.B W1, [W0]
320:                       return;
0053A4  370060     BRA 0x5466
321:                   }
322:                   if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0053A6  BFC861     MOV.B OSIntNesting, WREG
0053A8  E00400     CP0.B W0
0053AA  320004     BRA Z, 0x53B4
323:                       *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
0053AC  90004E     MOV [W14+8], W0
0053AE  B3C021     MOV.B #0x2, W1
0053B0  784801     MOV.B W1, [W0]
324:                       return;
0053B2  370059     BRA 0x5466
325:                   }
326:                   if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
0053B4  BFC862     MOV.B OSLockNesting, WREG
0053B6  E00400     CP0.B W0
0053B8  320004     BRA Z, 0x53C2
327:                       *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
0053BA  90004E     MOV [W14+8], W0
0053BC  B3C0D1     MOV.B #0xD, W1
0053BE  784801     MOV.B W1, [W0]
328:                       return;
0053C0  370052     BRA 0x5466
329:                   }
330:                   OS_ENTER_CRITICAL();
0053C2  800211     MOV SR, W1
0053C4  780F01     MOV W1, [W14]
0053C6  800211     MOV SR, W1
0053C8  200E00     MOV #0xE0, W0
0053CA  700001     IOR W0, W1, W0
0053CC  880210     MOV W0, SR
331:                   if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
0053CE  90001E     MOV [W14+2], W0
0053D0  900020     MOV [W0+4], W0
0053D2  E00000     CP0 W0
0053D4  32000B     BRA Z, 0x53EC
332:                       pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
0053D6  90001E     MOV [W14+2], W0
0053D8  900020     MOV [W0+4], W0
0053DA  E90080     DEC W0, W1
0053DC  90001E     MOV [W14+2], W0
0053DE  980021     MOV W1, [W0+4]
333:                       OS_EXIT_CRITICAL();
0053E0  78011E     MOV [W14], W2
0053E2  880212     MOV W2, SR
334:                       *perr = OS_ERR_NONE;
0053E4  90004E     MOV [W14+8], W0
0053E6  EB4080     CLR.B W1
0053E8  784801     MOV.B W1, [W0]
335:                       return;
0053EA  37003D     BRA 0x5466
336:                   }
337:                                                                     /* Otherwise, must wait until event occurs       */
338:                   OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
0053EC  804360     MOV OSTCBCur, W0
0053EE  804361     MOV OSTCBCur, W1
0053F0  9058A1     MOV.B [W1+26], W1
0053F2  A00401     BSET.B W1, #0
0053F4  985821     MOV.B W1, [W0+26]
339:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
0053F6  804360     MOV OSTCBCur, W0
0053F8  EB4080     CLR.B W1
0053FA  985831     MOV.B W1, [W0+27]
340:                   OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
0053FC  804360     MOV OSTCBCur, W0
0053FE  90012E     MOV [W14+4], W2
005400  9001BE     MOV [W14+6], W3
005402  980832     MOV W2, [W0+22]
005404  980843     MOV W3, [W0+24]
341:                   OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
005406  90001E     MOV [W14+2], W0
005408  07E92F     RCALL OS_EventTaskWait
342:                   OS_EXIT_CRITICAL();
00540A  78019E     MOV [W14], W3
00540C  880213     MOV W3, SR
343:                   OS_Sched();                                       /* Find next highest priority task ready         */
00540E  07EAFE     RCALL OS_Sched
344:                   OS_ENTER_CRITICAL();
005410  800211     MOV SR, W1
005412  780F01     MOV W1, [W14]
005414  800211     MOV SR, W1
005416  200E00     MOV #0xE0, W0
005418  700001     IOR W0, W1, W0
00541A  880210     MOV W0, SR
345:                   switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00541C  804360     MOV OSTCBCur, W0
00541E  905830     MOV.B [W0+27], W0
005420  FB8000     ZE W0, W0
005422  E00000     CP0 W0
005424  320003     BRA Z, 0x542C
005426  500FE2     SUB W0, #0x2, [W15]
005428  320005     BRA Z, 0x5434
00542A  370008     BRA 0x543C
346:                       case OS_STAT_PEND_OK:
347:                            *perr = OS_ERR_NONE;
00542C  90004E     MOV [W14+8], W0
00542E  EB4080     CLR.B W1
005430  784801     MOV.B W1, [W0]
348:                            break;
005432  37000B     BRA 0x544A
349:               
350:                       case OS_STAT_PEND_ABORT:
351:                            *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
005434  90004E     MOV [W14+8], W0
005436  B3C0E1     MOV.B #0xE, W1
005438  784801     MOV.B W1, [W0]
352:                            break;
00543A  370007     BRA 0x544A
353:               
354:                       case OS_STAT_PEND_TO:
355:                       default:
356:                            OS_EventTaskRemove(OSTCBCur, pevent);
00543C  804360     MOV OSTCBCur, W0
00543E  90009E     MOV [W14+2], W1
005440  07E992     RCALL OS_EventTaskRemove
357:                            *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
005442  90004E     MOV [W14+8], W0
005444  B3C0A1     MOV.B #0xA, W1
005446  784801     MOV.B W1, [W0]
358:                            break;
005448  000000     NOP
359:                   }
360:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00544A  804360     MOV OSTCBCur, W0
00544C  EB4080     CLR.B W1
00544E  985821     MOV.B W1, [W0+26]
361:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
005450  804360     MOV OSTCBCur, W0
005452  EB4080     CLR.B W1
005454  985831     MOV.B W1, [W0+27]
362:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
005456  804360     MOV OSTCBCur, W0
005458  EB0080     CLR W1
00545A  980811     MOV W1, [W0+18]
363:               #if (OS_EVENT_MULTI_EN > 0u)
364:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00545C  804360     MOV OSTCBCur, W0
00545E  EB0080     CLR W1
005460  980821     MOV W1, [W0+20]
365:               #endif
366:                   OS_EXIT_CRITICAL();
005462  78011E     MOV [W14], W2
005464  880212     MOV W2, SR
367:               }
005466  FA8000     ULNK
005468  060000     RETURN
368:               
369:               /*$PAGE*/
370:               /*
371:               *********************************************************************************************************
372:               *                                    ABORT WAITING ON A SEMAPHORE
373:               *
374:               * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
375:               *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
376:               *              the semaphore via OSSemPost().
377:               *
378:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
379:               *                            semaphore.
380:               *
381:               *              opt           determines the type of ABORT performed:
382:               *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
383:               *                                                     semaphore
384:               *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
385:               *                                                     semaphore
386:               *
387:               *              perr          is a pointer to where an error message will be deposited.  Possible error
388:               *                            messages are:
389:               *
390:               *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
391:               *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
392:               *                                                and informed of the aborted wait; check return value
393:               *                                                for the number of tasks whose wait on the semaphore
394:               *                                                was aborted.
395:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
396:               *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
397:               *
398:               * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
399:               *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
400:               *********************************************************************************************************
401:               */
402:               
403:               #if OS_SEM_PEND_ABORT_EN > 0u
404:               INT8U  OSSemPendAbort (OS_EVENT  *pevent,
405:                                      INT8U      opt,
406:                                      INT8U     *perr)
407:               {
00546A  FA000A     LNK #0xA
00546C  980720     MOV W0, [W14+4]
00546E  984761     MOV.B W1, [W14+6]
005470  980742     MOV W2, [W14+8]
408:                   INT8U      nbr_tasks;
409:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
410:                   OS_CPU_SR  cpu_sr = 0u;
005472  EB0000     CLR W0
005474  980710     MOV W0, [W14+2]
411:               #endif
412:               
413:               
414:               
415:               #ifdef OS_SAFETY_CRITICAL
416:                   if (perr == (INT8U *)0) {
417:                       OS_SAFETY_CRITICAL_EXCEPTION();
418:                       return (0u);
419:                   }
420:               #endif
421:               
422:               #if OS_ARG_CHK_EN > 0u
423:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
005476  90002E     MOV [W14+4], W0
005478  E00000     CP0 W0
00547A  3A0005     BRA NZ, 0x5486
424:                       *perr = OS_ERR_PEVENT_NULL;
00547C  90004E     MOV [W14+8], W0
00547E  B3C041     MOV.B #0x4, W1
005480  784801     MOV.B W1, [W0]
425:                       return (0u);
005482  EB4000     CLR.B W0
005484  37003C     BRA 0x54FE
426:                   }
427:               #endif
428:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005486  90002E     MOV [W14+4], W0
005488  784010     MOV.B [W0], W0
00548A  504FE3     SUB.B W0, #0x3, [W15]
00548C  320005     BRA Z, 0x5498
429:                       *perr = OS_ERR_EVENT_TYPE;
00548E  90004E     MOV [W14+8], W0
005490  B3C011     MOV.B #0x1, W1
005492  784801     MOV.B W1, [W0]
430:                       return (0u);
005494  EB4000     CLR.B W0
005496  370033     BRA 0x54FE
431:                   }
432:                   OS_ENTER_CRITICAL();
005498  800211     MOV SR, W1
00549A  980711     MOV W1, [W14+2]
00549C  800211     MOV SR, W1
00549E  200E00     MOV #0xE0, W0
0054A0  700001     IOR W0, W1, W0
0054A2  880210     MOV W0, SR
433:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
0054A4  90002E     MOV [W14+4], W0
0054A6  904060     MOV.B [W0+6], W0
0054A8  E00400     CP0.B W0
0054AA  320023     BRA Z, 0x54F2
434:                       nbr_tasks = 0u;
0054AC  EB4000     CLR.B W0
0054AE  784F00     MOV.B W0, [W14]
435:                       switch (opt) {
0054B0  90406E     MOV.B [W14+6], W0
0054B2  FB8000     ZE W0, W0
0054B4  500FE1     SUB W0, #0x1, [W15]
0054B6  320008     BRA Z, 0x54C8
0054B8  37000D     BRA 0x54D4
436:                           case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
437:                                while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
0054C8  000000     NOP
0054CA  90002E     MOV [W14+4], W0
0054CC  904060     MOV.B [W0+6], W0
0054CE  E00400     CP0.B W0
0054D0  3AFFF4     BRA NZ, 0x54BA
438:                                    (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0054BA  B3C023     MOV.B #0x2, W3
0054BC  B3C012     MOV.B #0x1, W2
0054BE  EB0080     CLR W1
0054C0  90002E     MOV [W14+4], W0
0054C2  07E87E     RCALL OS_EventTaskRdy
439:                                    nbr_tasks++;
0054C4  E84F1E     INC.B [W14], [W14]
0054C6  370001     BRA 0x54CA
440:                                }
441:                                break;
0054D2  370007     BRA 0x54E2
442:               
443:                           case OS_PEND_OPT_NONE:
444:                           default:                                  /* No,  ready HPT       waiting on semaphore     */
445:                                (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
0054D4  B3C023     MOV.B #0x2, W3
0054D6  B3C012     MOV.B #0x1, W2
0054D8  EB0080     CLR W1
0054DA  90002E     MOV [W14+4], W0
0054DC  07E871     RCALL OS_EventTaskRdy
446:                                nbr_tasks++;
0054DE  E84F1E     INC.B [W14], [W14]
447:                                break;
0054E0  000000     NOP
448:                       }
449:                       OS_EXIT_CRITICAL();
0054E2  90009E     MOV [W14+2], W1
0054E4  880211     MOV W1, SR
450:                       OS_Sched();                                   /* Find HPT ready to run                         */
0054E6  07EA92     RCALL OS_Sched
451:                       *perr = OS_ERR_PEND_ABORT;
0054E8  90004E     MOV [W14+8], W0
0054EA  B3C0E1     MOV.B #0xE, W1
0054EC  784801     MOV.B W1, [W0]
452:                       return (nbr_tasks);
0054EE  78401E     MOV.B [W14], W0
0054F0  370006     BRA 0x54FE
453:                   }
454:                   OS_EXIT_CRITICAL();
0054F2  90009E     MOV [W14+2], W1
0054F4  880211     MOV W1, SR
455:                   *perr = OS_ERR_NONE;
0054F6  90004E     MOV [W14+8], W0
0054F8  EB4080     CLR.B W1
0054FA  784801     MOV.B W1, [W0]
456:                   return (0u);                                      /* No tasks waiting on semaphore                 */
0054FC  EB4000     CLR.B W0
457:               }
0054FE  FA8000     ULNK
005500  060000     RETURN
458:               #endif
459:               
460:               /*$PAGE*/
461:               /*
462:               *********************************************************************************************************
463:               *                                         POST TO A SEMAPHORE
464:               *
465:               * Description: This function signals a semaphore
466:               *
467:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
468:               *                            semaphore.
469:               *
470:               * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
471:               *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
472:               *                                  signaled the semaphore more often than you waited on it with either
473:               *                                  OSSemAccept() or OSSemPend().
474:               *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
475:               *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
476:               *********************************************************************************************************
477:               */
478:               
479:               INT8U  OSSemPost (OS_EVENT *pevent)
480:               {
005502  FA0004     LNK #0x4
005504  980710     MOV W0, [W14+2]
481:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
482:                   OS_CPU_SR  cpu_sr = 0u;
005506  EB0000     CLR W0
005508  780F00     MOV W0, [W14]
483:               #endif
484:               
485:               
486:               
487:               #if OS_ARG_CHK_EN > 0u
488:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00550A  90001E     MOV [W14+2], W0
00550C  E00000     CP0 W0
00550E  3A0002     BRA NZ, 0x5514
489:                       return (OS_ERR_PEVENT_NULL);
005510  B3C040     MOV.B #0x4, W0
005512  37002A     BRA 0x5568
490:                   }
491:               #endif
492:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005514  90001E     MOV [W14+2], W0
005516  784010     MOV.B [W0], W0
005518  504FE3     SUB.B W0, #0x3, [W15]
00551A  320002     BRA Z, 0x5520
493:                       return (OS_ERR_EVENT_TYPE);
00551C  B3C010     MOV.B #0x1, W0
00551E  370024     BRA 0x5568
494:                   }
495:                   OS_ENTER_CRITICAL();
005520  800211     MOV SR, W1
005522  780F01     MOV W1, [W14]
005524  800211     MOV SR, W1
005526  200E00     MOV #0xE0, W0
005528  700001     IOR W0, W1, W0
00552A  880210     MOV W0, SR
496:                   if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
00552C  90001E     MOV [W14+2], W0
00552E  904060     MOV.B [W0+6], W0
005530  E00400     CP0.B W0
005532  32000A     BRA Z, 0x5548
497:                                                                     /* Ready HPT waiting on event                    */
498:                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
005534  EB4180     CLR.B W3
005536  B3C012     MOV.B #0x1, W2
005538  EB0080     CLR W1
00553A  90001E     MOV [W14+2], W0
00553C  07E841     RCALL OS_EventTaskRdy
499:                       OS_EXIT_CRITICAL();
00553E  78009E     MOV [W14], W1
005540  880211     MOV W1, SR
500:                       OS_Sched();                                   /* Find HPT ready to run                         */
005542  07EA64     RCALL OS_Sched
501:                       return (OS_ERR_NONE);
005544  EB4000     CLR.B W0
005546  370010     BRA 0x5568
502:                   }
503:                   if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
005548  90001E     MOV [W14+2], W0
00554A  900020     MOV [W0+4], W0
00554C  400FE1     ADD W0, #0x1, [W15]
00554E  320009     BRA Z, 0x5562
504:                       pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
005550  90001E     MOV [W14+2], W0
005552  900020     MOV [W0+4], W0
005554  E80080     INC W0, W1
005556  90001E     MOV [W14+2], W0
005558  980021     MOV W1, [W0+4]
505:                       OS_EXIT_CRITICAL();
00555A  78009E     MOV [W14], W1
00555C  880211     MOV W1, SR
506:                       return (OS_ERR_NONE);
00555E  EB4000     CLR.B W0
005560  370003     BRA 0x5568
507:                   }
508:                   OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
005562  78009E     MOV [W14], W1
005564  880211     MOV W1, SR
509:                   return (OS_ERR_SEM_OVF);
005566  B3C330     MOV.B #0x33, W0
510:               }
005568  FA8000     ULNK
00556A  060000     RETURN
511:               
512:               /*$PAGE*/
513:               /*
514:               *********************************************************************************************************
515:               *                                          QUERY A SEMAPHORE
516:               *
517:               * Description: This function obtains information about a semaphore
518:               *
519:               * Arguments  : pevent        is a pointer to the event control block associated with the desired
520:               *                            semaphore
521:               *
522:               *              p_sem_data    is a pointer to a structure that will contain information about the
523:               *                            semaphore.
524:               *
525:               * Returns    : OS_ERR_NONE         The call was successful and the message was sent
526:               *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
527:               *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
528:               *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
529:               *********************************************************************************************************
530:               */
531:               
532:               #if OS_SEM_QUERY_EN > 0u
533:               INT8U  OSSemQuery (OS_EVENT     *pevent,
534:                                  OS_SEM_DATA  *p_sem_data)
535:               {
00556C  FA000C     LNK #0xC
00556E  980740     MOV W0, [W14+8]
005570  980751     MOV W1, [W14+10]
536:                   INT8U       i;
537:                   OS_PRIO    *psrc;
538:                   OS_PRIO    *pdest;
539:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
540:                   OS_CPU_SR   cpu_sr = 0u;
005572  EB0000     CLR W0
005574  980730     MOV W0, [W14+6]
541:               #endif
542:               
543:               
544:               
545:               #if OS_ARG_CHK_EN > 0u
546:                   if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
005576  90004E     MOV [W14+8], W0
005578  E00000     CP0 W0
00557A  3A0002     BRA NZ, 0x5580
547:                       return (OS_ERR_PEVENT_NULL);
00557C  B3C040     MOV.B #0x4, W0
00557E  370033     BRA 0x55E6
548:                   }
549:                   if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
005580  90005E     MOV [W14+10], W0
005582  E00000     CP0 W0
005584  3A0002     BRA NZ, 0x558A
550:                       return (OS_ERR_PDATA_NULL);
005586  B3C090     MOV.B #0x9, W0
005588  37002E     BRA 0x55E6
551:                   }
552:               #endif
553:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00558A  90004E     MOV [W14+8], W0
00558C  784010     MOV.B [W0], W0
00558E  504FE3     SUB.B W0, #0x3, [W15]
005590  320002     BRA Z, 0x5596
554:                       return (OS_ERR_EVENT_TYPE);
005592  B3C010     MOV.B #0x1, W0
005594  370028     BRA 0x55E6
555:                   }
556:                   OS_ENTER_CRITICAL();
005596  800211     MOV SR, W1
005598  980731     MOV W1, [W14+6]
00559A  800211     MOV SR, W1
00559C  200E00     MOV #0xE0, W0
00559E  700001     IOR W0, W1, W0
0055A0  880210     MOV W0, SR
557:                   p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
0055A2  90004E     MOV [W14+8], W0
0055A4  9040E0     MOV.B [W0+6], W1
0055A6  90005E     MOV [W14+10], W0
0055A8  984041     MOV.B W1, [W0+4]
558:                   psrc                   = &pevent->OSEventTbl[0];
0055AA  90004E     MOV [W14+8], W0
0055AC  400067     ADD W0, #0x7, W0
0055AE  980710     MOV W0, [W14+2]
559:                   pdest                  = &p_sem_data->OSEventTbl[0];
0055B0  90005E     MOV [W14+10], W0
0055B2  E88000     INC2 W0, W0
0055B4  980720     MOV W0, [W14+4]
560:                   for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0055B6  EB4000     CLR.B W0
0055B8  784F00     MOV.B W0, [W14]
0055BA  37000B     BRA 0x55D2
0055D0  E84F1E     INC.B [W14], [W14]
0055D2  78401E     MOV.B [W14], W0
0055D4  504FE1     SUB.B W0, #0x1, [W15]
0055D6  36FFF2     BRA LEU, 0x55BC
561:                       *pdest++ = *psrc++;
0055BC  90001E     MOV [W14+2], W0
0055BE  784090     MOV.B [W0], W1
0055C0  90002E     MOV [W14+4], W0
0055C2  784801     MOV.B W1, [W0]
0055C4  90002E     MOV [W14+4], W0
0055C6  E80000     INC W0, W0
0055C8  980720     MOV W0, [W14+4]
0055CA  90001E     MOV [W14+2], W0
0055CC  E80000     INC W0, W0
0055CE  980710     MOV W0, [W14+2]
562:                   }
563:                   p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
0055D8  90004E     MOV [W14+8], W0
0055DA  9000A0     MOV [W0+4], W1
0055DC  90005E     MOV [W14+10], W0
0055DE  780801     MOV W1, [W0]
564:                   OS_EXIT_CRITICAL();
0055E0  9000BE     MOV [W14+6], W1
0055E2  880211     MOV W1, SR
565:                   return (OS_ERR_NONE);
0055E4  EB4000     CLR.B W0
566:               }
0055E6  FA8000     ULNK
0055E8  060000     RETURN
567:               #endif                                                     /* OS_SEM_QUERY_EN                          */
568:               
569:               /*$PAGE*/
570:               /*
571:               *********************************************************************************************************
572:               *                                            SET SEMAPHORE
573:               *
574:               * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
575:               *              this value would be 0.
576:               *
577:               *              You would typically use this function when a semaphore is used as a signaling mechanism
578:               *              and, you want to reset the count value.
579:               *
580:               * Arguments  : pevent     is a pointer to the event control block
581:               *
582:               *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
583:               *                         semaphore count.
584:               *
585:               *              perr       is a pointer to an error code returned by the function as follows:
586:               *
587:               *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
588:               *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
589:               *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
590:               *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
591:               *********************************************************************************************************
592:               */
593:               
594:               #if OS_SEM_SET_EN > 0u
595:               void  OSSemSet (OS_EVENT  *pevent,
596:                               INT16U     cnt,
597:                               INT8U     *perr)
598:               {
0055EA  FA0008     LNK #0x8
0055EC  980710     MOV W0, [W14+2]
0055EE  980721     MOV W1, [W14+4]
0055F0  980732     MOV W2, [W14+6]
599:               #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
600:                   OS_CPU_SR  cpu_sr = 0u;
0055F2  EB0000     CLR W0
0055F4  780F00     MOV W0, [W14]
601:               #endif
602:               
603:               
604:               
605:               #ifdef OS_SAFETY_CRITICAL
606:                   if (perr == (INT8U *)0) {
607:                       OS_SAFETY_CRITICAL_EXCEPTION();
608:                       return;
609:                   }
610:               #endif
611:               
612:               #if OS_ARG_CHK_EN > 0u
613:                   if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
0055F6  90001E     MOV [W14+2], W0
0055F8  E00000     CP0 W0
0055FA  3A0004     BRA NZ, 0x5604
614:                       *perr = OS_ERR_PEVENT_NULL;
0055FC  90003E     MOV [W14+6], W0
0055FE  B3C041     MOV.B #0x4, W1
005600  784801     MOV.B W1, [W0]
615:                       return;
005602  370026     BRA 0x5650
616:                   }
617:               #endif
618:                   if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
005604  90001E     MOV [W14+2], W0
005606  784010     MOV.B [W0], W0
005608  504FE3     SUB.B W0, #0x3, [W15]
00560A  320004     BRA Z, 0x5614
619:                       *perr = OS_ERR_EVENT_TYPE;
00560C  90003E     MOV [W14+6], W0
00560E  B3C011     MOV.B #0x1, W1
005610  784801     MOV.B W1, [W0]
620:                       return;
005612  37001E     BRA 0x5650
621:                   }
622:                   OS_ENTER_CRITICAL();
005614  800211     MOV SR, W1
005616  780F01     MOV W1, [W14]
005618  800211     MOV SR, W1
00561A  200E00     MOV #0xE0, W0
00561C  700001     IOR W0, W1, W0
00561E  880210     MOV W0, SR
623:                   *perr = OS_ERR_NONE;
005620  90003E     MOV [W14+6], W0
005622  EB4080     CLR.B W1
005624  784801     MOV.B W1, [W0]
624:                   if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
005626  90001E     MOV [W14+2], W0
005628  900020     MOV [W0+4], W0
00562A  E00000     CP0 W0
00562C  320004     BRA Z, 0x5636
625:                       pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
00562E  90001E     MOV [W14+2], W0
005630  9000AE     MOV [W14+4], W1
005632  980021     MOV W1, [W0+4]
005634  37000B     BRA 0x564C
626:                   } else {                                          /* No                                            */
627:                       if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
005636  90001E     MOV [W14+2], W0
005638  904060     MOV.B [W0+6], W0
00563A  E00400     CP0.B W0
00563C  3A0004     BRA NZ, 0x5646
628:                           pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
00563E  90001E     MOV [W14+2], W0
005640  9000AE     MOV [W14+4], W1
005642  980021     MOV W1, [W0+4]
005644  370003     BRA 0x564C
629:                       } else {
630:                           *perr              = OS_ERR_TASK_WAITING;
005646  90003E     MOV [W14+6], W0
005648  B3C491     MOV.B #0x49, W1
00564A  784801     MOV.B W1, [W0]
631:                       }
632:                   }
633:                   OS_EXIT_CRITICAL();
00564C  78009E     MOV [W14], W1
00564E  880211     MOV W1, SR
634:               }
005650  FA8000     ULNK
635:               #endif
636:               
637:               #endif                                                /* OS_SEM_EN                                     */
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Source/os_core.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/OS-II
4:                 *                                          The Real-Time Kernel
5:                 *                                             CORE FUNCTIONS
6:                 *
7:                 *                              (c) Copyright 1992-2013, Micrium, Weston, FL
8:                 *                                           All Rights Reserved
9:                 *
10:                * File    : OS_CORE.C
11:                * By      : Jean J. Labrosse
12:                * Version : V2.92.10
13:                *
14:                * LICENSING TERMS:
15:                * ---------------
16:                *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
17:                * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
18:                * its use in your product. We provide ALL the source code for your convenience and to help you experience
19:                * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
20:                * licensing fee.
21:                *********************************************************************************************************
22:                */
23:                
24:                #define  MICRIUM_SOURCE
25:                
26:                #ifndef  OS_MASTER_FILE
27:                #define  OS_GLOBALS
28:                #include <ucos_ii.h>
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                      PRIORITY RESOLUTION TABLE
34:                *
35:                * Note: Index into table is bit pattern to resolve highest priority
36:                *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
37:                *********************************************************************************************************
38:                */
39:                
40:                INT8U  const  OSUnMapTbl[256] = {
41:                    0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
42:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
43:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
44:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
45:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
46:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
47:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
48:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
49:                    7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
50:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
51:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
52:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
53:                    6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
54:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
55:                    5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
56:                    4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
57:                };
58:                
59:                /*$PAGE*/
60:                /*
61:                *********************************************************************************************************
62:                *                                         FUNCTION PROTOTYPES
63:                *********************************************************************************************************
64:                */
65:                
66:                static  void  OS_InitEventList(void);
67:                
68:                static  void  OS_InitMisc(void);
69:                
70:                static  void  OS_InitRdyList(void);
71:                
72:                static  void  OS_InitTaskIdle(void);
73:                
74:                #if OS_TASK_STAT_EN > 0u
75:                static  void  OS_InitTaskStat(void);
76:                #endif
77:                
78:                static  void  OS_InitTCBList(void);
79:                
80:                static  void  OS_SchedNew(void);
81:                
82:                /*$PAGE*/
83:                /*
84:                *********************************************************************************************************
85:                *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
86:                *
87:                * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
88:                *
89:                * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
90:                *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
91:                *                        type is irrelevant.
92:                *
93:                *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
94:                *                        mutex, mailbox or queue.
95:                *
96:                *              perr      is a pointer to an error code that can contain one of the following values:
97:                *
98:                *                        OS_ERR_NONE                if the name was copied to 'pname'
99:                *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
100:               *                                                   control block type.
101:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
102:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
103:               *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
104:               *
105:               * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
106:               *********************************************************************************************************
107:               */
108:               
109:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
110:               INT8U  OSEventNameGet (OS_EVENT   *pevent,
111:                                      INT8U     **pname,
112:                                      INT8U      *perr)
113:               {
001FFA  FA000A     LNK #0xA
001FFC  980720     MOV W0, [W14+4]
001FFE  980731     MOV W1, [W14+6]
002000  980742     MOV W2, [W14+8]
114:                   INT8U      len;
115:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
116:                   OS_CPU_SR  cpu_sr = 0u;
002002  EB0000     CLR W0
002004  780F00     MOV W0, [W14]
117:               #endif
118:               
119:               
120:               
121:               #ifdef OS_SAFETY_CRITICAL
122:                   if (perr == (INT8U *)0) {
123:                       OS_SAFETY_CRITICAL_EXCEPTION();
124:                       return (0u);
125:                   }
126:               #endif
127:               
128:               #if OS_ARG_CHK_EN > 0u
129:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
002006  90002E     MOV [W14+4], W0
002008  E00000     CP0 W0
00200A  3A0005     BRA NZ, 0x2016
130:                       *perr = OS_ERR_PEVENT_NULL;
00200C  90004E     MOV [W14+8], W0
00200E  B3C041     MOV.B #0x4, W1
002010  784801     MOV.B W1, [W0]
131:                       return (0u);
002012  EB4000     CLR.B W0
002014  37002F     BRA 0x2074
132:                   }
133:                   if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
002016  90003E     MOV [W14+6], W0
002018  E00000     CP0 W0
00201A  3A0005     BRA NZ, 0x2026
134:                       *perr = OS_ERR_PNAME_NULL;
00201C  90004E     MOV [W14+8], W0
00201E  B3C0C1     MOV.B #0xC, W1
002020  784801     MOV.B W1, [W0]
135:                       return (0u);
002022  EB4000     CLR.B W0
002024  370027     BRA 0x2074
136:                   }
137:               #endif
138:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
002026  BFC861     MOV.B OSIntNesting, WREG
002028  E00400     CP0.B W0
00202A  320005     BRA Z, 0x2036
139:                       *perr  = OS_ERR_NAME_GET_ISR;
00202C  90004E     MOV [W14+8], W0
00202E  B3C111     MOV.B #0x11, W1
002030  784801     MOV.B W1, [W0]
140:                       return (0u);
002032  EB4000     CLR.B W0
002034  37001F     BRA 0x2074
141:                   }
142:                   switch (pevent->OSEventType) {
002036  90002E     MOV [W14+4], W0
002038  784010     MOV.B [W0], W0
00203A  FB8000     ZE W0, W0
00203C  E90000     DEC W0, W0
00203E  500FE3     SUB W0, #0x3, [W15]
002040  3E0015     BRA GTU, 0x206C
143:                       case OS_EVENT_TYPE_SEM:
144:                       case OS_EVENT_TYPE_MUTEX:
145:                       case OS_EVENT_TYPE_MBOX:
146:                       case OS_EVENT_TYPE_Q:
147:                            break;
148:               
149:                       default:
150:                            *perr = OS_ERR_EVENT_TYPE;
00206C  90004E     MOV [W14+8], W0
00206E  B3C011     MOV.B #0x1, W1
002070  784801     MOV.B W1, [W0]
151:                            return (0u);
002072  EB4000     CLR.B W0
152:                   }
153:                   OS_ENTER_CRITICAL();
002042  800211     MOV SR, W1
002044  780F01     MOV W1, [W14]
002046  800211     MOV SR, W1
002048  200E00     MOV #0xE0, W0
00204A  700001     IOR W0, W1, W0
00204C  880210     MOV W0, SR
154:                   *pname = pevent->OSEventName;
00204E  90002E     MOV [W14+4], W0
002050  9000D0     MOV [W0+10], W1
002052  90003E     MOV [W14+6], W0
002054  780801     MOV W1, [W0]
155:                   len    = OS_StrLen(*pname);
002056  90003E     MOV [W14+6], W0
002058  780010     MOV [W0], W0
00205A  070518     RCALL OS_StrLen
00205C  984720     MOV.B W0, [W14+2]
156:                   OS_EXIT_CRITICAL();
00205E  78009E     MOV [W14], W1
002060  880211     MOV W1, SR
157:                   *perr  = OS_ERR_NONE;
002062  90004E     MOV [W14+8], W0
002064  EB4080     CLR.B W1
002066  784801     MOV.B W1, [W0]
158:                   return (len);
002068  90402E     MOV.B [W14+2], W0
00206A  370004     BRA 0x2074
159:               }
002074  FA8000     ULNK
002076  060000     RETURN
160:               #endif
161:               
162:               /*$PAGE*/
163:               /*
164:               *********************************************************************************************************
165:               *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
166:               *
167:               * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
168:               *
169:               * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
170:               *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
171:               *                        matter the actual type.
172:               *
173:               *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
174:               *                        mutex, mailbox or queue.
175:               *
176:               *              perr      is a pointer to an error code that can contain one of the following values:
177:               *
178:               *                        OS_ERR_NONE                if the requested task is resumed
179:               *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
180:               *                                                   control block type.
181:               *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
182:               *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
183:               *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
184:               *
185:               * Returns    : None
186:               *********************************************************************************************************
187:               */
188:               
189:               #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
190:               void  OSEventNameSet (OS_EVENT  *pevent,
191:                                     INT8U     *pname,
192:                                     INT8U     *perr)
193:               {
002078  FA0008     LNK #0x8
00207A  980710     MOV W0, [W14+2]
00207C  980721     MOV W1, [W14+4]
00207E  980732     MOV W2, [W14+6]
194:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
195:                   OS_CPU_SR  cpu_sr = 0u;
002080  EB0000     CLR W0
002082  780F00     MOV W0, [W14]
196:               #endif
197:               
198:               
199:               
200:               #ifdef OS_SAFETY_CRITICAL
201:                   if (perr == (INT8U *)0) {
202:                       OS_SAFETY_CRITICAL_EXCEPTION();
203:                       return;
204:                   }
205:               #endif
206:               
207:               #if OS_ARG_CHK_EN > 0u
208:                   if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
002084  90001E     MOV [W14+2], W0
002086  E00000     CP0 W0
002088  3A0004     BRA NZ, 0x2092
209:                       *perr = OS_ERR_PEVENT_NULL;
00208A  90003E     MOV [W14+6], W0
00208C  B3C041     MOV.B #0x4, W1
00208E  784801     MOV.B W1, [W0]
210:                       return;
002090  370027     BRA 0x20E0
211:                   }
212:                   if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
002092  90002E     MOV [W14+4], W0
002094  E00000     CP0 W0
002096  3A0004     BRA NZ, 0x20A0
213:                       *perr = OS_ERR_PNAME_NULL;
002098  90003E     MOV [W14+6], W0
00209A  B3C0C1     MOV.B #0xC, W1
00209C  784801     MOV.B W1, [W0]
214:                       return;
00209E  370020     BRA 0x20E0
215:                   }
216:               #endif
217:                   if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
0020A0  BFC861     MOV.B OSIntNesting, WREG
0020A2  E00400     CP0.B W0
0020A4  320004     BRA Z, 0x20AE
218:                       *perr = OS_ERR_NAME_SET_ISR;
0020A6  90003E     MOV [W14+6], W0
0020A8  B3C121     MOV.B #0x12, W1
0020AA  784801     MOV.B W1, [W0]
219:                       return;
0020AC  370019     BRA 0x20E0
220:                   }
221:                   switch (pevent->OSEventType) {
0020AE  90001E     MOV [W14+2], W0
0020B0  784010     MOV.B [W0], W0
0020B2  FB8000     ZE W0, W0
0020B4  E90000     DEC W0, W0
0020B6  500FE3     SUB W0, #0x3, [W15]
0020B8  3E000F     BRA GTU, 0x20D8
222:                       case OS_EVENT_TYPE_SEM:
223:                       case OS_EVENT_TYPE_MUTEX:
224:                       case OS_EVENT_TYPE_MBOX:
225:                       case OS_EVENT_TYPE_Q:
226:                            break;
227:               
228:                       default:
229:                            *perr = OS_ERR_EVENT_TYPE;
0020D8  90003E     MOV [W14+6], W0
0020DA  B3C011     MOV.B #0x1, W1
0020DC  784801     MOV.B W1, [W0]
230:                            return;
0020DE  000000     NOP
231:                   }
232:                   OS_ENTER_CRITICAL();
0020BA  800211     MOV SR, W1
0020BC  780F01     MOV W1, [W14]
0020BE  800211     MOV SR, W1
0020C0  200E00     MOV #0xE0, W0
0020C2  700001     IOR W0, W1, W0
0020C4  880210     MOV W0, SR
233:                   pevent->OSEventName = pname;
0020C6  90001E     MOV [W14+2], W0
0020C8  9000AE     MOV [W14+4], W1
0020CA  980051     MOV W1, [W0+10]
234:                   OS_EXIT_CRITICAL();
0020CC  78009E     MOV [W14], W1
0020CE  880211     MOV W1, SR
235:                   *perr = OS_ERR_NONE;
0020D0  90003E     MOV [W14+6], W0
0020D2  EB4080     CLR.B W1
0020D4  784801     MOV.B W1, [W0]
0020D6  370004     BRA 0x20E0
236:               }
0020E0  FA8000     ULNK
0020E2  060000     RETURN
237:               #endif
238:               
239:               /*$PAGE*/
240:               /*
241:               *********************************************************************************************************
242:               *                                       PEND ON MULTIPLE EVENTS
243:               *
244:               * Description: This function waits for multiple events.  If multiple events are ready at the start of the
245:               *              pend call, then all available events are returned as ready.  If the task must pend on the
246:               *              multiple events, then only the first posted or aborted event is returned as ready.
247:               *
248:               * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
249:               *
250:               *              pevents_rdy   is a pointer to an array to return which event control blocks are available
251:               *                            or ready.  The size of the array MUST be greater than or equal to the size
252:               *                            of the 'pevents_pend' array, including terminating NULL.
253:               *
254:               *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
255:               *                            events.  The size of the array MUST be greater than or equal to the size of
256:               *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
257:               *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
258:               *                            every available message-type event returns its messages in the 'pmsgs_rdy'
259:               *                            array at the same index as the event is returned in the 'pevents_rdy' array.
260:               *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
261:               *
262:               *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
263:               *                            wait for the resources up to the amount of time specified by this argument.
264:               *                            If you specify 0, however, your task will wait forever for the specified
265:               *                            events or, until the resources becomes available (or the events occur).
266:               *
267:               *              perr          is a pointer to where an error message will be deposited.  Possible error
268:               *                            messages are:
269:               *
270:               *                            OS_ERR_NONE         The call was successful and your task owns the resources
271:               *                                                or, the events you are waiting for occurred; check the
272:               *                                                'pevents_rdy' array for which events are available.
273:               *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
274:               *                                                'pevents_rdy' array for which events were aborted.
275:               *                            OS_ERR_TIMEOUT      The events were not received within the specified
276:               *                                                'timeout'.
277:               *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
278:               *                                                NULL pointer.
279:               *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
280:               *                                                mailboxes, and/or queues.
281:               *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
282:               *                                                would lead to a suspension.
283:               *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
284:               *
285:               * Returns    : >  0          the number of events returned as ready or aborted.
286:               *              == 0          if no events are returned as ready because of timeout or upon error.
287:               *
288:               * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
289:               *
290:               *                        semaphores, mailboxes, queues
291:               *
292:               *                 b. Return ALL available events and messages, if any
293:               *
294:               *                 c. Add    current task priority as pending to   each events's wait list
295:               *                      Performed in OS_EventTaskWaitMulti()
296:               *
297:               *                 d. Wait on any of multiple events
298:               *
299:               *                 e. Remove current task priority as pending from each events's wait list
300:               *                      Performed in OS_EventTaskRdy(), if events posted or aborted
301:               *
302:               *                 f. Return any event posted or aborted, if any
303:               *                      else
304:               *                    Return timeout
305:               *
306:               *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
307:               *                 case of any error(s).
308:               *********************************************************************************************************
309:               */
310:               /*$PAGE*/
311:               #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
312:               INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
313:                                         OS_EVENT  **pevents_rdy,
314:                                         void      **pmsgs_rdy,
315:                                         INT32U      timeout,
316:                                         INT8U      *perr)
317:               {
0020E4  FA0018     LNK #0x18
0020E6  980760     MOV W0, [W14+12]
0020E8  980771     MOV W1, [W14+14]
0020EA  980F02     MOV W2, [W14+16]
0020EC  980F14     MOV W4, [W14+18]
0020EE  980F25     MOV W5, [W14+20]
0020F0  980F33     MOV W3, [W14+22]
318:                   OS_EVENT  **pevents;
319:                   OS_EVENT   *pevent;
320:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
321:                   OS_Q       *pq;
322:               #endif
323:                   BOOLEAN     events_rdy;
324:                   INT16U      events_rdy_nbr;
325:                   INT8U       events_stat;
326:               #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
327:                   OS_CPU_SR   cpu_sr = 0u;
0020F2  EB0000     CLR W0
0020F4  980750     MOV W0, [W14+10]
328:               #endif
329:               
330:               
331:               
332:               #ifdef OS_SAFETY_CRITICAL
333:                   if (perr == (INT8U *)0) {
334:                       OS_SAFETY_CRITICAL_EXCEPTION();
335:                       return (0u);
336:                   }
337:               #endif
338:               
339:               #if (OS_ARG_CHK_EN > 0u)
340:                   if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
0020F6  90006E     MOV [W14+12], W0
0020F8  E00000     CP0 W0
0020FA  3A0005     BRA NZ, 0x2106
341:                      *perr =  OS_ERR_PEVENT_NULL;
0020FC  90083E     MOV [W14+22], W0
0020FE  B3C041     MOV.B #0x4, W1
002100  784801     MOV.B W1, [W0]
342:                       return (0u);
002102  EB0000     CLR W0
002104  37011B     BRA 0x233C
343:                   }
344:                   if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
002106  90006E     MOV [W14+12], W0
002108  780010     MOV [W0], W0
00210A  E00000     CP0 W0
00210C  3A0005     BRA NZ, 0x2118
345:                      *perr =  OS_ERR_PEVENT_NULL;
00210E  90083E     MOV [W14+22], W0
002110  B3C041     MOV.B #0x4, W1
002112  784801     MOV.B W1, [W0]
346:                       return (0u);
002114  EB0000     CLR W0
002116  370112     BRA 0x233C
347:                   }
348:                   if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
002118  90007E     MOV [W14+14], W0
00211A  E00000     CP0 W0
00211C  3A0005     BRA NZ, 0x2128
349:                      *perr =  OS_ERR_PEVENT_NULL;
00211E  90083E     MOV [W14+22], W0
002120  B3C041     MOV.B #0x4, W1
002122  784801     MOV.B W1, [W0]
350:                       return (0u);
002124  EB0000     CLR W0
002126  37010A     BRA 0x233C
351:                   }
352:                   if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
002128  90080E     MOV [W14+16], W0
00212A  E00000     CP0 W0
00212C  3A0005     BRA NZ, 0x2138
353:                      *perr =  OS_ERR_PEVENT_NULL;
00212E  90083E     MOV [W14+22], W0
002130  B3C041     MOV.B #0x4, W1
002132  784801     MOV.B W1, [W0]
354:                       return (0u);
002134  EB0000     CLR W0
002136  370102     BRA 0x233C
355:                   }
356:               #endif
357:               
358:                  *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
002138  90007E     MOV [W14+14], W0
00213A  EB0080     CLR W1
00213C  780801     MOV W1, [W0]
359:               
360:                   pevents     =  pevents_pend;
00213E  9000EE     MOV [W14+12], W1
002140  780F01     MOV W1, [W14]
361:                   pevent      = *pevents;
002142  78001E     MOV [W14], W0
002144  780110     MOV [W0], W2
002146  980712     MOV W2, [W14+2]
362:                   while  (pevent != (OS_EVENT *)0) {
002148  37000F     BRA 0x2168
002168  90001E     MOV [W14+2], W0
00216A  E00000     CP0 W0
00216C  3AFFEE     BRA NZ, 0x214A
363:                       switch (pevent->OSEventType) {                  /* Validate event block types                  */
00214A  90001E     MOV [W14+2], W0
00214C  784010     MOV.B [W0], W0
00214E  FB8000     ZE W0, W0
002150  500FE3     SUB W0, #0x3, [W15]
002152  3A0005     BRA NZ, 0x215E
364:               #if (OS_SEM_EN  > 0u)
365:                           case OS_EVENT_TYPE_SEM:
366:                                break;
367:               #endif
368:               #if (OS_MBOX_EN > 0u)
369:                           case OS_EVENT_TYPE_MBOX:
370:                                break;
371:               #endif
372:               #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
373:                           case OS_EVENT_TYPE_Q:
374:                                break;
375:               #endif
376:               
377:                           case OS_EVENT_TYPE_MUTEX:
378:                           case OS_EVENT_TYPE_FLAG:
379:                           default:
380:                               *perr = OS_ERR_EVENT_TYPE;
00215E  90083E     MOV [W14+22], W0
002160  B3C011     MOV.B #0x1, W1
002162  784801     MOV.B W1, [W0]
381:                                return (0u);
002164  EB0000     CLR W0
002166  3700EA     BRA 0x233C
382:                       }
383:                       pevents++;
002154  E88F1E     INC2 [W14], [W14]
384:                       pevent = *pevents;
002156  78001E     MOV [W14], W0
002158  780190     MOV [W0], W3
00215A  980713     MOV W3, [W14+2]
00215C  370005     BRA 0x2168
385:                   }
386:               
387:                   if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
00216E  BFC861     MOV.B OSIntNesting, WREG
002170  E00400     CP0.B W0
002172  320005     BRA Z, 0x217E
388:                      *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
002174  90083E     MOV [W14+22], W0
002176  B3C021     MOV.B #0x2, W1
002178  784801     MOV.B W1, [W0]
389:                       return (0u);
00217A  EB0000     CLR W0
00217C  3700DF     BRA 0x233C
390:                   }
391:                   if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
00217E  BFC862     MOV.B OSLockNesting, WREG
002180  E00400     CP0.B W0
002182  320005     BRA Z, 0x218E
392:                      *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
002184  90083E     MOV [W14+22], W0
002186  B3C0D1     MOV.B #0xD, W1
002188  784801     MOV.B W1, [W0]
393:                       return (0u);
00218A  EB0000     CLR W0
00218C  3700D7     BRA 0x233C
394:                   }
395:               
396:               /*$PAGE*/
397:                   events_rdy     =  OS_FALSE;
00218E  EB4000     CLR.B W0
002190  984740     MOV.B W0, [W14+4]
398:                   events_rdy_nbr =  0u;
002192  EB0000     CLR W0
002194  980730     MOV W0, [W14+6]
399:                   events_stat    =  OS_STAT_RDY;
002196  EB4000     CLR.B W0
002198  984F00     MOV.B W0, [W14+8]
400:                   pevents        =  pevents_pend;
00219A  9000EE     MOV [W14+12], W1
00219C  780F01     MOV W1, [W14]
401:                   pevent         = *pevents;
00219E  78001E     MOV [W14], W0
0021A0  780110     MOV [W0], W2
0021A2  980712     MOV W2, [W14+2]
402:                   OS_ENTER_CRITICAL();
0021A4  800213     MOV SR, W3
0021A6  980753     MOV W3, [W14+10]
0021A8  800211     MOV SR, W1
0021AA  200E00     MOV #0xE0, W0
0021AC  700001     IOR W0, W1, W0
0021AE  880210     MOV W0, SR
403:                   while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
0021B0  370032     BRA 0x2216
002216  90001E     MOV [W14+2], W0
002218  E00000     CP0 W0
00221A  3AFFCB     BRA NZ, 0x21B2
404:                       switch (pevent->OSEventType) {
0021B2  90001E     MOV [W14+2], W0
0021B4  784010     MOV.B [W0], W0
0021B6  FB8000     ZE W0, W0
0021B8  500FE3     SUB W0, #0x3, [W15]
0021BA  3A0023     BRA NZ, 0x2202
405:               #if (OS_SEM_EN > 0u)
406:                           case OS_EVENT_TYPE_SEM:
407:                                if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
0021BC  90001E     MOV [W14+2], W0
0021BE  900020     MOV [W0+4], W0
0021C0  E00000     CP0 W0
0021C2  320017     BRA Z, 0x21F2
408:                                    pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
0021C4  90001E     MOV [W14+2], W0
0021C6  900020     MOV [W0+4], W0
0021C8  E90080     DEC W0, W1
0021CA  90001E     MOV [W14+2], W0
0021CC  980021     MOV W1, [W0+4]
409:                                   *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
0021CE  90007E     MOV [W14+14], W0
0021D0  90009E     MOV [W14+2], W1
0021D2  780801     MOV W1, [W0]
0021D4  90007E     MOV [W14+14], W0
0021D6  E88000     INC2 W0, W0
0021D8  980770     MOV W0, [W14+14]
410:                                     events_rdy   =  OS_TRUE;
0021DA  B3C010     MOV.B #0x1, W0
0021DC  984740     MOV.B W0, [W14+4]
411:                                   *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
0021DE  90080E     MOV [W14+16], W0
0021E0  EB0080     CLR W1
0021E2  780801     MOV W1, [W0]
0021E4  90080E     MOV [W14+16], W0
0021E6  E88000     INC2 W0, W0
0021E8  980F00     MOV W0, [W14+16]
412:                                     events_rdy_nbr++;
0021EA  90003E     MOV [W14+6], W0
0021EC  E80000     INC W0, W0
0021EE  980730     MOV W0, [W14+6]
0021F0  370003     BRA 0x21F8
413:               
414:                                } else {
415:                                     events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
0021F2  90480E     MOV.B [W14+8], W0
0021F4  A00400     BSET.B W0, #0
0021F6  984F00     MOV.B W0, [W14+8]
416:                                }
417:                                break;
418:               #endif
419:               
420:               #if (OS_MBOX_EN > 0u)
421:                           case OS_EVENT_TYPE_MBOX:
422:                                if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
423:                                                                       /* ... return available message,           ... */
424:                                   *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
425:                                    pevent->OSEventPtr  = (void *)0;
426:                                   *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
427:                                     events_rdy         =  OS_TRUE;
428:                                     events_rdy_nbr++;
429:               
430:                                } else {
431:                                     events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
432:                                }
433:                                break;
434:               #endif
435:               
436:               #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
437:                           case OS_EVENT_TYPE_Q:
438:                                pq = (OS_Q *)pevent->OSEventPtr;
439:                                if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
440:                                                                       /* ... return available message,           ... */
441:                                   *pmsgs_rdy++ = (void *)*pq->OSQOut++;
442:                                    if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
443:                                        pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
444:                                    }
445:                                    pq->OSQEntries--;                  /* Update number of queue entries              */
446:                                   *pevents_rdy++ = pevent;            /* ... and return available queue event        */
447:                                     events_rdy   = OS_TRUE;
448:                                     events_rdy_nbr++;
449:               
450:                                } else {
451:                                     events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
452:                                }
453:                                break;
454:               #endif
455:               
456:                           case OS_EVENT_TYPE_MUTEX:
457:                           case OS_EVENT_TYPE_FLAG:
458:                           default:
459:                                OS_EXIT_CRITICAL();
002202  9001DE     MOV [W14+10], W3
002204  880213     MOV W3, SR
460:                               *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
002206  90007E     MOV [W14+14], W0
002208  EB0080     CLR W1
00220A  780801     MOV W1, [W0]
461:                               *perr        =  OS_ERR_EVENT_TYPE;
00220C  90083E     MOV [W14+22], W0
00220E  B3C011     MOV.B #0x1, W1
002210  784801     MOV.B W1, [W0]
462:                                return (events_rdy_nbr);
002212  90003E     MOV [W14+6], W0
002214  370093     BRA 0x233C
463:                       }
464:                       pevents++;
0021F8  E88F1E     INC2 [W14], [W14]
465:                       pevent = *pevents;
0021FA  78001E     MOV [W14], W0
0021FC  780110     MOV [W0], W2
0021FE  980712     MOV W2, [W14+2]
002200  37000A     BRA 0x2216
466:                   }
467:               
468:                   if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
00221C  90404E     MOV.B [W14+4], W0
00221E  504FE1     SUB.B W0, #0x1, [W15]
002220  3A000A     BRA NZ, 0x2236
469:                      *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
002222  90007E     MOV [W14+14], W0
002224  EB0080     CLR W1
002226  780801     MOV W1, [W0]
470:                       OS_EXIT_CRITICAL();
002228  9000DE     MOV [W14+10], W1
00222A  880211     MOV W1, SR
471:                      *perr        =  OS_ERR_NONE;
00222C  90083E     MOV [W14+22], W0
00222E  EB4080     CLR.B W1
002230  784801     MOV.B W1, [W0]
472:                       return (events_rdy_nbr);
002232  90003E     MOV [W14+6], W0
002234  370083     BRA 0x233C
473:                   }
474:               /*$PAGE*/
475:                                                                       /* Otherwise, must wait until any event occurs */
476:                   OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
002236  804360     MOV OSTCBCur, W0
002238  804361     MOV OSTCBCur, W1
00223A  905921     MOV.B [W1+26], W2
00223C  90488E     MOV.B [W14+8], W1
00223E  714101     IOR.B W2, W1, W2
002240  B3C801     MOV.B #0x80, W1
002242  714081     IOR.B W2, W1, W1
002244  985821     MOV.B W1, [W0+26]
477:                                              OS_STAT_MULTI;           /* ... pend on multiple events                 */
478:                   OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
002246  804360     MOV OSTCBCur, W0
002248  EB4080     CLR.B W1
00224A  985831     MOV.B W1, [W0+27]
479:                   OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00224C  804360     MOV OSTCBCur, W0
00224E  90091E     MOV [W14+18], W2
002250  9009AE     MOV [W14+20], W3
002252  980832     MOV W2, [W0+22]
002254  980843     MOV W3, [W0+24]
480:                   OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
002256  90006E     MOV [W14+12], W0
002258  07023D     RCALL OS_EventTaskWaitMulti
481:               
482:                   OS_EXIT_CRITICAL();
00225A  9001DE     MOV [W14+10], W3
00225C  880213     MOV W3, SR
483:                   OS_Sched();                                         /* Find next highest priority task ready       */
00225E  0703D6     RCALL OS_Sched
484:                   OS_ENTER_CRITICAL();
002260  800211     MOV SR, W1
002262  980751     MOV W1, [W14+10]
002264  800211     MOV SR, W1
002266  200E00     MOV #0xE0, W0
002268  700001     IOR W0, W1, W0
00226A  880210     MOV W0, SR
485:               
486:                   switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00226C  804360     MOV OSTCBCur, W0
00226E  905830     MOV.B [W0+27], W0
002270  FB8000     ZE W0, W0
002272  E00000     CP0 W0
002274  320002     BRA Z, 0x227A
002276  500FE2     SUB W0, #0x2, [W15]
002278  3A0019     BRA NZ, 0x22AC
487:                       case OS_STAT_PEND_OK:
488:                       case OS_STAT_PEND_ABORT:
489:                            pevent = OSTCBCur->OSTCBEventPtr;
00227A  804360     MOV OSTCBCur, W0
00227C  900910     MOV [W0+18], W2
00227E  980712     MOV W2, [W14+2]
490:                            if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
002280  90001E     MOV [W14+2], W0
002282  E00000     CP0 W0
002284  32000C     BRA Z, 0x229E
491:                               *pevents_rdy++   =  pevent;             /* ... return available event ...              */
002286  90007E     MOV [W14+14], W0
002288  90019E     MOV [W14+2], W3
00228A  780803     MOV W3, [W0]
00228C  90007E     MOV [W14+14], W0
00228E  E88000     INC2 W0, W0
002290  980770     MOV W0, [W14+14]
492:                               *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
002292  90007E     MOV [W14+14], W0
002294  EB0080     CLR W1
002296  780801     MOV W1, [W0]
493:                                 events_rdy_nbr =  1;
002298  200010     MOV #0x1, W0
00229A  980730     MOV W0, [W14+6]
494:               
495:                            } else {                                   /* Else NO event available, handle as timeout  */
496:                                OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00229E  804360     MOV OSTCBCur, W0
0022A0  B3C011     MOV.B #0x1, W1
0022A2  985831     MOV.B W1, [W0+27]
497:                                OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
0022A4  804360     MOV OSTCBCur, W0
0022A6  9000EE     MOV [W14+12], W1
0022A8  070285     RCALL OS_EventTaskRemoveMulti
498:                            }
499:                            break;
00229C  37000B     BRA 0x22B4
0022AA  370004     BRA 0x22B4
500:               
501:                       case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
502:                       default:                                        /* ... remove task from events' wait lists     */
503:                            OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
0022AC  804360     MOV OSTCBCur, W0
0022AE  9000EE     MOV [W14+12], W1
0022B0  070281     RCALL OS_EventTaskRemoveMulti
504:                            break;
0022B2  000000     NOP
505:                   }
506:               
507:                   switch (OSTCBCur->OSTCBStatPend) {
0022B4  804360     MOV OSTCBCur, W0
0022B6  905830     MOV.B [W0+27], W0
0022B8  FB8000     ZE W0, W0
0022BA  E00000     CP0 W0
0022BC  320003     BRA Z, 0x22C4
0022BE  500FE2     SUB W0, #0x2, [W15]
0022C0  32001A     BRA Z, 0x22F6
0022C2  370023     BRA 0x230A
508:                       case OS_STAT_PEND_OK:
509:                            switch (pevent->OSEventType) {             /* Return event's message                      */
0022C4  90001E     MOV [W14+2], W0
0022C6  784010     MOV.B [W0], W0
0022C8  FB8000     ZE W0, W0
0022CA  500FE3     SUB W0, #0x3, [W15]
0022CC  3A000A     BRA NZ, 0x22E2
510:               #if (OS_SEM_EN > 0u)
511:                                case OS_EVENT_TYPE_SEM:
512:                                    *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
0022CE  90080E     MOV [W14+16], W0
0022D0  EB0080     CLR W1
0022D2  780801     MOV W1, [W0]
0022D4  90080E     MOV [W14+16], W0
0022D6  E88000     INC2 W0, W0
0022D8  980F00     MOV W0, [W14+16]
513:                                     break;
514:               #endif
515:               
516:               #if ((OS_MBOX_EN > 0u) ||                 \
517:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
518:                                case OS_EVENT_TYPE_MBOX:
519:                                case OS_EVENT_TYPE_Q:
520:                                    *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
521:                                     break;
522:               #endif
523:               
524:                                case OS_EVENT_TYPE_MUTEX:
525:                                case OS_EVENT_TYPE_FLAG:
526:                                default:
527:                                     OS_EXIT_CRITICAL();
0022E2  9000DE     MOV [W14+10], W1
0022E4  880211     MOV W1, SR
528:                                    *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
0022E6  90007E     MOV [W14+14], W0
0022E8  EB0080     CLR W1
0022EA  780801     MOV W1, [W0]
529:                                    *perr        =  OS_ERR_EVENT_TYPE;
0022EC  90083E     MOV [W14+22], W0
0022EE  B3C011     MOV.B #0x1, W1
0022F0  784801     MOV.B W1, [W0]
530:                                     return (events_rdy_nbr);
0022F2  90003E     MOV [W14+6], W0
0022F4  370023     BRA 0x233C
531:                            }
532:                           *perr = OS_ERR_NONE;
0022DA  90083E     MOV [W14+22], W0
0022DC  EB4080     CLR.B W1
0022DE  784801     MOV.B W1, [W0]
533:                            break;
0022E0  37001E     BRA 0x231E
534:               
535:                       case OS_STAT_PEND_ABORT:
536:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
0022F6  90080E     MOV [W14+16], W0
0022F8  EB0080     CLR W1
0022FA  780801     MOV W1, [W0]
0022FC  90080E     MOV [W14+16], W0
0022FE  E88000     INC2 W0, W0
002300  980F00     MOV W0, [W14+16]
537:                           *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
002302  90083E     MOV [W14+22], W0
002304  B3C0E1     MOV.B #0xE, W1
002306  784801     MOV.B W1, [W0]
538:                            break;
002308  37000A     BRA 0x231E
539:               
540:                       case OS_STAT_PEND_TO:
541:                       default:
542:                           *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00230A  90080E     MOV [W14+16], W0
00230C  EB0080     CLR W1
00230E  780801     MOV W1, [W0]
002310  90080E     MOV [W14+16], W0
002312  E88000     INC2 W0, W0
002314  980F00     MOV W0, [W14+16]
543:                           *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
002316  90083E     MOV [W14+22], W0
002318  B3C0A1     MOV.B #0xA, W1
00231A  784801     MOV.B W1, [W0]
544:                            break;
00231C  000000     NOP
545:                   }
546:               
547:                   OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00231E  804360     MOV OSTCBCur, W0
002320  EB4080     CLR.B W1
002322  985821     MOV.B W1, [W0+26]
548:                   OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
002324  804360     MOV OSTCBCur, W0
002326  EB4080     CLR.B W1
002328  985831     MOV.B W1, [W0+27]
549:                   OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00232A  804360     MOV OSTCBCur, W0
00232C  EB0080     CLR W1
00232E  980811     MOV W1, [W0+18]
550:                   OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
002330  804360     MOV OSTCBCur, W0
002332  EB0080     CLR W1
002334  980821     MOV W1, [W0+20]
551:               #if ((OS_MBOX_EN > 0u) ||                 \
552:                   ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
553:                   OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
554:               #endif
555:                   OS_EXIT_CRITICAL();
002336  90015E     MOV [W14+10], W2
002338  880212     MOV W2, SR
556:               
557:                   return (events_rdy_nbr);
00233A  90003E     MOV [W14+6], W0
558:               }
00233C  FA8000     ULNK
00233E  060000     RETURN
559:               #endif
560:               
561:               /*$PAGE*/
562:               /*
563:               *********************************************************************************************************
564:               *                                           INITIALIZATION
565:               *
566:               * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
567:               *              creating any uC/OS-II object and, prior to calling OSStart().
568:               *
569:               * Arguments  : none
570:               *
571:               * Returns    : none
572:               *********************************************************************************************************
573:               */
574:               
575:               void  OSInit (void)
576:               {
002340  FA0000     LNK #0x0
577:               #if OS_TASK_CREATE_EXT_EN > 0u
578:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
579:                   INT8U  err;
580:               #endif
581:               #endif
582:               
583:                   OSInitHookBegin();                                           /* Call port specific initialization code   */
002342  0725D9     RCALL OSInitHookBegin
584:               
585:                   OS_InitMisc();                                               /* Initialize miscellaneous variables       */
002344  0702B7     RCALL _OS_InitMisc
586:               
587:                   OS_InitRdyList();                                            /* Initialize the Ready List                */
002346  0702C7     RCALL _OS_InitRdyList
588:               
589:                   OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
002348  070305     RCALL _OS_InitTCBList
590:               
591:                   OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00234A  07027F     RCALL _OS_InitEventList
592:               
593:               #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
594:                   OS_FlagInit();                                               /* Initialize the event flag structures     */
595:               #endif
596:               
597:               #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
598:                   OS_MemInit();                                                /* Initialize the memory manager            */
599:               #endif
600:               
601:               #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
602:                   OS_QInit();                                                  /* Initialize the message queue structures  */
603:               #endif
604:               
605:               #if OS_TASK_CREATE_EXT_EN > 0u
606:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
607:                   OS_TLS_Init(&err);                                           /* Initialize TLS, before creating tasks    */
608:                   if (err != OS_ERR_NONE) {
609:                       return;
610:                   }
611:               #endif
612:               #endif
613:               
614:                   OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00234C  0702D7     RCALL _OS_InitTaskIdle
615:               #if OS_TASK_STAT_EN > 0u
616:                   OS_InitTaskStat();                                           /* Create the Statistic Task                */
00234E  0702EC     RCALL _OS_InitTaskStat
617:               #endif
618:               
619:               #if OS_TMR_EN > 0u
620:                   OSTmr_Init();                                                /* Initialize the Timer Manager             */
621:               #endif
622:               
623:                   OSInitHookEnd();                                             /* Call port specific init. code            */
002350  0725D7     RCALL OSInitHookEnd
624:               
625:               #if OS_DEBUG_EN > 0u
626:                   OSDebugInit();
627:               #endif
628:               }
002352  FA8000     ULNK
002354  060000     RETURN
629:               /*$PAGE*/
630:               /*
631:               *********************************************************************************************************
632:               *                                              ENTER ISR
633:               *
634:               * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
635:               *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
636:               *              only perform rescheduling at the last nested ISR.
637:               *
638:               * Arguments  : none
639:               *
640:               * Returns    : none
641:               *
642:               * Notes      : 1) This function should be called with interrupts already disabled
643:               *              2) Your ISR can directly increment OSIntNesting without calling this function because
644:               *                 OSIntNesting has been declared 'global'.
645:               *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
646:               *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
647:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
648:               *                 end of the ISR.
649:               *              5) You are allowed to nest interrupts up to 255 levels deep.
650:               *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
651:               *                 OSIntEnter() is always called with interrupts disabled.
652:               *********************************************************************************************************
653:               */
654:               
655:               void  OSIntEnter (void)
656:               {
002356  FA0000     LNK #0x0
657:                   if (OSRunning == OS_TRUE) {
002358  BFC866     MOV.B OSRunning, WREG
00235A  504FE1     SUB.B W0, #0x1, [W15]
00235C  3A0006     BRA NZ, 0x236A
658:                       if (OSIntNesting < 255u) {
00235E  BFC861     MOV.B OSIntNesting, WREG
002360  404FE1     ADD.B W0, #0x1, [W15]
002362  320003     BRA Z, 0x236A
659:                           OSIntNesting++;                      /* Increment ISR nesting level                        */
002364  BFC861     MOV.B OSIntNesting, WREG
002366  E84000     INC.B W0, W0
002368  B7E861     MOV.B WREG, OSIntNesting
660:                       }
661:                   }
662:               }
00236A  FA8000     ULNK
00236C  060000     RETURN
663:               /*$PAGE*/
664:               /*
665:               *********************************************************************************************************
666:               *                                              EXIT ISR
667:               *
668:               * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
669:               *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
670:               *              a new, high-priority task, is ready to run.
671:               *
672:               * Arguments  : none
673:               *
674:               * Returns    : none
675:               *
676:               * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
677:               *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
678:               *                 end of the ISR.
679:               *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
680:               *********************************************************************************************************
681:               */
682:               
683:               void  OSIntExit (void)
684:               {
00236E  FA0002     LNK #0x2
685:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
686:                   OS_CPU_SR  cpu_sr = 0u;
002370  EB0000     CLR W0
002372  780F00     MOV W0, [W14]
687:               #endif
688:               
689:               
690:               
691:                   if (OSRunning == OS_TRUE) {
002374  BFC866     MOV.B OSRunning, WREG
002376  504FE1     SUB.B W0, #0x1, [W15]
002378  3A002F     BRA NZ, 0x23D8
692:                       OS_ENTER_CRITICAL();
00237A  800211     MOV SR, W1
00237C  780F01     MOV W1, [W14]
00237E  800211     MOV SR, W1
002380  200E00     MOV #0xE0, W0
002382  700001     IOR W0, W1, W0
002384  880210     MOV W0, SR
693:                       if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
002386  BFC861     MOV.B OSIntNesting, WREG
002388  E00400     CP0.B W0
00238A  320003     BRA Z, 0x2392
694:                           OSIntNesting--;
00238C  BFC861     MOV.B OSIntNesting, WREG
00238E  E94000     DEC.B W0, W0
002390  B7E861     MOV.B WREG, OSIntNesting
695:                       }
696:                       if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
002392  BFC861     MOV.B OSIntNesting, WREG
002394  E00400     CP0.B W0
002396  3A001E     BRA NZ, 0x23D4
697:                           if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
002398  BFC862     MOV.B OSLockNesting, WREG
00239A  E00400     CP0.B W0
00239C  3A001B     BRA NZ, 0x23D4
698:                               OS_SchedNew();
00239E  070364     RCALL _OS_SchedNew
699:                               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0023A0  BFC864     MOV.B OSPrioHighRdy, WREG
0023A2  FB8000     ZE W0, W0
0023A4  400080     ADD W0, W0, W1
0023A6  219000     MOV #0x1900, W0
0023A8  408000     ADD W1, W0, W0
0023AA  780010     MOV [W0], W0
0023AC  884380     MOV W0, OSTCBHighRdy
700:                               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
0023AE  208641     MOV #0x864, W1
0023B0  784091     MOV.B [W1], W1
0023B2  BFC863     MOV.B OSPrioCur, WREG
0023B4  50CF80     SUB.B W1, W0, [W15]
0023B6  32000E     BRA Z, 0x23D4
701:               #if OS_TASK_PROFILE_EN > 0u
702:                                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
0023B8  804382     MOV OSTCBHighRdy, W2
0023BA  901012     MOV [W2+34], W0
0023BC  9010A2     MOV [W2+36], W1
0023BE  400061     ADD W0, #0x1, W0
0023C0  4880E0     ADDC W1, #0x0, W1
0023C2  981110     MOV W0, [W2+34]
0023C4  981121     MOV W1, [W2+36]
703:               #endif
704:                                   OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
0023C6  804280     MOV OSCtxSwCtr, W0
0023C8  804291     MOV 0x852, W1
0023CA  400061     ADD W0, #0x1, W0
0023CC  4880E0     ADDC W1, #0x0, W1
0023CE  884280     MOV W0, OSCtxSwCtr
0023D0  884291     MOV W1, 0x852
705:               
706:               #if OS_TASK_CREATE_EXT_EN > 0u
707:               #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
708:                                   OS_TLS_TaskSw();
709:               #endif
710:               #endif
711:               
712:                                   OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
0023D2  072AF1     RCALL 0x79B6
713:                               }
714:                           }
715:                       }
716:                       OS_EXIT_CRITICAL();
0023D4  78009E     MOV [W14], W1
0023D6  880211     MOV W1, SR
717:                   }
718:               }
0023D8  FA8000     ULNK
0023DA  060000     RETURN
719:               /*$PAGE*/
720:               /*
721:               *********************************************************************************************************
722:               *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
723:               *
724:               * Description: This function is called by the application code to indicate that all initialization has
725:               *              been completed and that kernel objects are no longer allowed to be created.
726:               *
727:               * Arguments  : none
728:               *
729:               * Returns    : none
730:               *
731:               * Note(s)    : 1) You should call this function when you no longer want to allow application code to
732:               *                 create kernel objects.
733:               *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
734:               *********************************************************************************************************
735:               */
736:               
737:               #ifdef OS_SAFETY_CRITICAL_IEC61508
738:               void  OSSafetyCriticalStart (void)
739:               {
740:                   OSSafetyCriticalStartFlag = OS_TRUE;
741:               }
742:               
743:               #endif
744:               
745:               /*$PAGE*/
746:               /*
747:               *********************************************************************************************************
748:               *                                         PREVENT SCHEDULING
749:               *
750:               * Description: This function is used to prevent rescheduling to take place.  This allows your application
751:               *              to prevent context switches until you are ready to permit context switching.
752:               *
753:               * Arguments  : none
754:               *
755:               * Returns    : none
756:               *
757:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
758:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
759:               *********************************************************************************************************
760:               */
761:               
762:               #if OS_SCHED_LOCK_EN > 0u
763:               void  OSSchedLock (void)
764:               {
0023DC  FA0002     LNK #0x2
765:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
766:                   OS_CPU_SR  cpu_sr = 0u;
0023DE  EB0000     CLR W0
0023E0  780F00     MOV W0, [W14]
767:               #endif
768:               
769:               
770:               
771:                   if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0023E2  BFC866     MOV.B OSRunning, WREG
0023E4  504FE1     SUB.B W0, #0x1, [W15]
0023E6  3A0011     BRA NZ, 0x240A
772:                       OS_ENTER_CRITICAL();
0023E8  800211     MOV SR, W1
0023EA  780F01     MOV W1, [W14]
0023EC  800211     MOV SR, W1
0023EE  200E00     MOV #0xE0, W0
0023F0  700001     IOR W0, W1, W0
0023F2  880210     MOV W0, SR
773:                       if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
0023F4  BFC861     MOV.B OSIntNesting, WREG
0023F6  E00400     CP0.B W0
0023F8  3A0006     BRA NZ, 0x2406
774:                           if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
0023FA  BFC862     MOV.B OSLockNesting, WREG
0023FC  404FE1     ADD.B W0, #0x1, [W15]
0023FE  320003     BRA Z, 0x2406
775:                               OSLockNesting++;                 /* Increment lock nesting level                       */
002400  BFC862     MOV.B OSLockNesting, WREG
002402  E84000     INC.B W0, W0
002404  B7E862     MOV.B WREG, OSLockNesting
776:                           }
777:                       }
778:                       OS_EXIT_CRITICAL();
002406  78009E     MOV [W14], W1
002408  880211     MOV W1, SR
779:                   }
780:               }
00240A  FA8000     ULNK
00240C  060000     RETURN
781:               #endif
782:               
783:               /*$PAGE*/
784:               /*
785:               *********************************************************************************************************
786:               *                                          ENABLE SCHEDULING
787:               *
788:               * Description: This function is used to re-allow rescheduling.
789:               *
790:               * Arguments  : none
791:               *
792:               * Returns    : none
793:               *
794:               * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
795:               *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
796:               *********************************************************************************************************
797:               */
798:               
799:               #if OS_SCHED_LOCK_EN > 0u
800:               void  OSSchedUnlock (void)
801:               {
00240E  FA0002     LNK #0x2
802:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
803:                   OS_CPU_SR  cpu_sr = 0u;
002410  EB0000     CLR W0
002412  780F00     MOV W0, [W14]
804:               #endif
805:               
806:               
807:               
808:                   if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
002414  BFC866     MOV.B OSRunning, WREG
002416  504FE1     SUB.B W0, #0x1, [W15]
002418  3A001E     BRA NZ, 0x2456
809:                       OS_ENTER_CRITICAL();
00241A  800211     MOV SR, W1
00241C  780F01     MOV W1, [W14]
00241E  800211     MOV SR, W1
002420  200E00     MOV #0xE0, W0
002422  700001     IOR W0, W1, W0
002424  880210     MOV W0, SR
810:                       if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
002426  BFC861     MOV.B OSIntNesting, WREG
002428  E00400     CP0.B W0
00242A  3A0013     BRA NZ, 0x2452
811:                           if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
00242C  BFC862     MOV.B OSLockNesting, WREG
00242E  E00400     CP0.B W0
002430  32000D     BRA Z, 0x244C
812:                               OSLockNesting--;                           /* Decrement lock nesting level             */
002432  BFC862     MOV.B OSLockNesting, WREG
002434  E94000     DEC.B W0, W0
002436  B7E862     MOV.B WREG, OSLockNesting
813:                               if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
002438  BFC862     MOV.B OSLockNesting, WREG
00243A  E00400     CP0.B W0
00243C  3A0004     BRA NZ, 0x2446
814:                                   OS_EXIT_CRITICAL();
00243E  78009E     MOV [W14], W1
002440  880211     MOV W1, SR
815:                                   OS_Sched();                            /* See if a HPT is ready                    */
002442  0702E4     RCALL OS_Sched
002444  370008     BRA 0x2456
816:                               } else {
817:                                   OS_EXIT_CRITICAL();
002446  78009E     MOV [W14], W1
002448  880211     MOV W1, SR
00244A  370005     BRA 0x2456
818:                               }
819:                           } else {
820:                               OS_EXIT_CRITICAL();
00244C  78009E     MOV [W14], W1
00244E  880211     MOV W1, SR
002450  370002     BRA 0x2456
821:                           }
822:                       } else {
823:                           OS_EXIT_CRITICAL();
002452  78009E     MOV [W14], W1
002454  880211     MOV W1, SR
824:                       }
825:                   }
826:               }
002456  FA8000     ULNK
002458  060000     RETURN
827:               #endif
828:               
829:               /*$PAGE*/
830:               /*
831:               *********************************************************************************************************
832:               *                                         START MULTITASKING
833:               *
834:               * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
835:               *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
836:               *              and you MUST have created at least one task.
837:               *
838:               * Arguments  : none
839:               *
840:               * Returns    : none
841:               *
842:               * Note       : OSStartHighRdy() MUST:
843:               *                 a) Call OSTaskSwHook() then,
844:               *                 b) Set OSRunning to OS_TRUE.
845:               *                 c) Load the context of the task pointed to by OSTCBHighRdy.
846:               *                 d_ Execute the task.
847:               *********************************************************************************************************
848:               */
849:               
850:               void  OSStart (void)
851:               {
00245A  FA0000     LNK #0x0
852:                   if (OSRunning == OS_FALSE) {
00245C  BFC866     MOV.B OSRunning, WREG
00245E  E00400     CP0.B W0
002460  3A000D     BRA NZ, 0x247C
853:                       OS_SchedNew();                               /* Find highest priority's task priority number   */
002462  070302     RCALL _OS_SchedNew
854:                       OSPrioCur     = OSPrioHighRdy;
002464  BFC864     MOV.B OSPrioHighRdy, WREG
002466  B7E863     MOV.B WREG, OSPrioCur
855:                       OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
002468  BFC864     MOV.B OSPrioHighRdy, WREG
00246A  FB8000     ZE W0, W0
00246C  400080     ADD W0, W0, W1
00246E  219000     MOV #0x1900, W0
002470  408000     ADD W1, W0, W0
002472  780010     MOV [W0], W0
002474  884380     MOV W0, OSTCBHighRdy
856:                       OSTCBCur      = OSTCBHighRdy;
002476  804380     MOV OSTCBHighRdy, W0
002478  884360     MOV W0, OSTCBCur
857:                       OSStartHighRdy();                            /* Execute target specific code to start task     */
00247A  072A5A     RCALL 0x7930
858:                   }
859:               }
00247C  FA8000     ULNK
00247E  060000     RETURN
860:               /*$PAGE*/
861:               /*
862:               *********************************************************************************************************
863:               *                                      STATISTICS INITIALIZATION
864:               *
865:               * Description: This function is called by your application to establish CPU usage by first determining
866:               *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
867:               *              during that time.  CPU usage is then determined by a low priority task which keeps track
868:               *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
869:               *              determined by:
870:               *
871:               *                                             OSIdleCtr
872:               *                 CPU Usage (%) = 100 * (1 - ------------)
873:               *                                            OSIdleCtrMax
874:               *
875:               * Arguments  : none
876:               *
877:               * Returns    : none
878:               *********************************************************************************************************
879:               */
880:               
881:               #if OS_TASK_STAT_EN > 0u
882:               void  OSStatInit (void)
883:               {
002480  FA0002     LNK #0x2
884:               #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
885:                   OS_CPU_SR  cpu_sr = 0u;
002482  EB0000     CLR W0
002484  780F00     MOV W0, [W14]
886:               #endif
887:               
888:               
889:               
890:                   OSTimeDly(2u);                               /* Synchronize with clock tick                        */
002486  200020     MOV #0x2, W0
002488  200001     MOV #0x0, W1
00248A  0726B4     RCALL OSTimeDly
891:                   OS_ENTER_CRITICAL();
00248C  800211     MOV SR, W1
00248E  780F01     MOV W1, [W14]
002490  800211     MOV SR, W1
002492  200E00     MOV #0xE0, W0
002494  700001     IOR W0, W1, W0
002496  880210     MOV W0, SR
892:                   OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
002498  EF2868     CLR OSIdleCtr
00249A  EF286A     CLR 0x86A
893:                   OS_EXIT_CRITICAL();
00249C  78009E     MOV [W14], W1
00249E  880211     MOV W1, SR
894:                   OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
0024A0  200640     MOV #0x64, W0
0024A2  200001     MOV #0x0, W1
0024A4  0726A7     RCALL OSTimeDly
895:                   OS_ENTER_CRITICAL();
0024A6  800211     MOV SR, W1
0024A8  780F01     MOV W1, [W14]
0024AA  800211     MOV SR, W1
0024AC  200E00     MOV #0xE0, W0
0024AE  700001     IOR W0, W1, W0
0024B0  880210     MOV W0, SR
896:                   OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0024B2  804340     MOV OSIdleCtr, W0
0024B4  804351     MOV 0x86A, W1
0024B6  8842C0     MOV W0, OSIdleCtrMax
0024B8  8842D1     MOV W1, 0x85A
897:                   OSStatRdy    = OS_TRUE;
0024BA  B3C010     MOV.B #0x1, W0
0024BC  B7E860     MOV.B WREG, OSStatRdy
898:                   OS_EXIT_CRITICAL();
0024BE  78009E     MOV [W14], W1
0024C0  880211     MOV W1, SR
899:               }
0024C2  FA8000     ULNK
0024C4  060000     RETURN
900:               #endif
901:               /*$PAGE*/
902:               /*
903:               *********************************************************************************************************
904:               *                                         PROCESS SYSTEM TICK
905:               *
906:               * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
907:               *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
908:               *              called by a high priority task.
909:               *
910:               * Arguments  : none
911:               *
912:               * Returns    : none
913:               *********************************************************************************************************
914:               */
915:               
916:               void  OSTimeTick (void)
917:               {
0024C6  FA0006     LNK #0x6
918:                   OS_TCB    *ptcb;
919:               #if OS_TICK_STEP_EN > 0u
920:                   BOOLEAN    step;
921:               #endif
922:               #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
923:                   OS_CPU_SR  cpu_sr = 0u;
0024C8  EB0000     CLR W0
0024CA  980720     MOV W0, [W14+4]
924:               #endif
925:               
926:               
927:               
928:               #if OS_TIME_TICK_HOOK_EN > 0u
929:                   OSTimeTickHook();                                      /* Call user definable hook                     */
930:               #endif
931:               #if OS_TIME_GET_SET_EN > 0u
932:                   OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
933:                   OSTime++;
934:                   OS_EXIT_CRITICAL();
935:               #endif
936:                   if (OSRunning == OS_TRUE) {
0024CC  BFC866     MOV.B OSRunning, WREG
0024CE  504FE1     SUB.B W0, #0x1, [W15]
0024D0  3A006E     BRA NZ, 0x25AE
937:               #if OS_TICK_STEP_EN > 0u
938:                       switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
0024D2  BFC874     MOV.B OSTickStepState, WREG
0024D4  FB8000     ZE W0, W0
0024D6  500FE1     SUB W0, #0x1, [W15]
0024D8  320007     BRA Z, 0x24E8
0024DA  500FE2     SUB W0, #0x2, [W15]
0024DC  320008     BRA Z, 0x24EE
0024DE  E00000     CP0 W0
0024E0  3A000B     BRA NZ, 0x24F8
939:                           case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
940:                                step = OS_TRUE;
0024E2  B3C010     MOV.B #0x1, W0
0024E4  984720     MOV.B W0, [W14+2]
941:                                break;
0024E6  37000C     BRA 0x2500
942:               
943:                           case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
944:                                step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
0024E8  EB4000     CLR.B W0
0024EA  984720     MOV.B W0, [W14+2]
945:                                break;
0024EC  370009     BRA 0x2500
946:               
947:                           case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
948:                                step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
0024EE  B3C010     MOV.B #0x1, W0
0024F0  984720     MOV.B W0, [W14+2]
949:                                OSTickStepState = OS_TICK_STEP_WAIT;
0024F2  B3C010     MOV.B #0x1, W0
0024F4  B7E874     MOV.B WREG, OSTickStepState
950:                                break;
0024F6  370004     BRA 0x2500
951:               
952:                           default:                                       /* Invalid case, correct situation              */
953:                                step            = OS_TRUE;
0024F8  B3C010     MOV.B #0x1, W0
0024FA  984720     MOV.B W0, [W14+2]
954:                                OSTickStepState = OS_TICK_STEP_DIS;
0024FC  EF6874     CLR.B OSTickStepState
955:                                break;
0024FE  000000     NOP
956:                       }
957:                       if (step == OS_FALSE) {                            /* Return if waiting for step command           */
002500  90402E     MOV.B [W14+2], W0
002502  E00400     CP0.B W0
002504  320053     BRA Z, 0x25AC
958:                           return;
0025AC  000000     NOP
959:                       }
960:               #endif
961:                       ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
002506  804391     MOV OSTCBList, W1
002508  780F01     MOV W1, [W14]
962:                       while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
00250A  37004B     BRA 0x25A2
0025A2  78001E     MOV [W14], W0
0025A4  905840     MOV.B [W0+28], W0
0025A6  504FEA     SUB.B W0, #0xA, [W15]
0025A8  3AFFB1     BRA NZ, 0x250C
0025AA  370001     BRA 0x25AE
963:                           OS_ENTER_CRITICAL();
00250C  800211     MOV SR, W1
00250E  980721     MOV W1, [W14+4]
002510  800211     MOV SR, W1
002512  200E00     MOV #0xE0, W0
002514  700001     IOR W0, W1, W0
002516  880210     MOV W0, SR
964:                           if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
002518  78001E     MOV [W14], W0
00251A  9008C0     MOV [W0+24], W1
00251C  900830     MOV [W0+22], W0
00251E  500FE0     SUB W0, #0x0, [W15]
002520  588FE0     SUBB W1, #0x0, [W15]
002522  32003A     BRA Z, 0x2598
965:                               ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
002524  78001E     MOV [W14], W0
002526  9008C0     MOV [W0+24], W1
002528  900830     MOV [W0+22], W0
00252A  500061     SUB W0, #0x1, W0
00252C  5880E0     SUBB W1, #0x0, W1
00252E  78011E     MOV [W14], W2
002530  980930     MOV W0, [W2+22]
002532  980941     MOV W1, [W2+24]
966:                               if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
002534  78001E     MOV [W14], W0
002536  9008C0     MOV [W0+24], W1
002538  900830     MOV [W0+22], W0
00253A  500FE0     SUB W0, #0x0, [W15]
00253C  588FE0     SUBB W1, #0x0, [W15]
00253E  3A002C     BRA NZ, 0x2598
967:               
968:                                   if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
002540  78001E     MOV [W14], W0
002542  905820     MOV.B [W0+26], W0
002544  FB8080     ZE W0, W1
002546  200370     MOV #0x37, W0
002548  608000     AND W1, W0, W0
00254A  E00000     CP0 W0
00254C  32000A     BRA Z, 0x2562
969:                                       ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
00254E  78001E     MOV [W14], W0
002550  9058A0     MOV.B [W0+26], W1
002552  B3CC80     MOV.B #0xC8, W0
002554  60C080     AND.B W1, W0, W1
002556  78001E     MOV [W14], W0
002558  985821     MOV.B W1, [W0+26]
970:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
00255A  78001E     MOV [W14], W0
00255C  B3C011     MOV.B #0x1, W1
00255E  985831     MOV.B W1, [W0+27]
002560  370003     BRA 0x2568
971:                                   } else {
972:                                       ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
002562  78001E     MOV [W14], W0
002564  EB4080     CLR.B W1
002566  985831     MOV.B W1, [W0+27]
973:                                   }
974:               
975:                                   if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
002568  78001E     MOV [W14], W0
00256A  905820     MOV.B [W0+26], W0
00256C  FB8000     ZE W0, W0
00256E  600068     AND W0, #0x8, W0
002570  E00000     CP0 W0
002572  3A0012     BRA NZ, 0x2598
976:                                       OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
002574  78001E     MOV [W14], W0
002576  906080     MOV.B [W0+32], W1
002578  BFC865     MOV.B OSRdyGrp, WREG
00257A  70C000     IOR.B W1, W0, W0
00257C  B7E865     MOV.B WREG, OSRdyGrp
977:                                       OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00257E  78001E     MOV [W14], W0
002580  905860     MOV.B [W0+30], W0
002582  FB8000     ZE W0, W0
002584  78009E     MOV [W14], W1
002586  9058E1     MOV.B [W1+30], W1
002588  FB8081     ZE W1, W1
00258A  2187E2     MOV #0x187E, W2
00258C  78C162     MOV.B [W2+W1], W2
00258E  78009E     MOV [W14], W1
002590  9058F1     MOV.B [W1+31], W1
002592  714101     IOR.B W2, W1, W2
002594  2187E1     MOV #0x187E, W1
002596  787082     MOV.B W2, [W1+W0]
978:                                   }
979:                               }
980:                           }
981:                           ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
002598  78001E     MOV [W14], W0
00259A  9000F0     MOV [W0+14], W1
00259C  780F01     MOV W1, [W14]
982:                           OS_EXIT_CRITICAL();
00259E  9000AE     MOV [W14+4], W1
0025A0  880211     MOV W1, SR
983:                       }
984:                   }
985:               }
0025AE  FA8000     ULNK
0025B0  060000     RETURN
986:               
987:               /*$PAGE*/
988:               /*
989:               *********************************************************************************************************
990:               *                                             GET VERSION
991:               *
992:               * Description: This function is used to return the version number of uC/OS-II.  The returned value 
993:               *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
994:               *              2.01.00 would be returned as 20100.
995:               *
996:               * Arguments  : none
997:               *
998:               * Returns    : The version number of uC/OS-II multiplied by 10000.
999:               *********************************************************************************************************
1000:              */
1001:              
1002:              INT16U  OSVersion (void)
1003:              {
0025B2  FA0000     LNK #0x0
1004:                  return (OS_VERSION);
0025B4  2721B0     MOV #0x721B, W0
1005:              }
0025B6  FA8000     ULNK
0025B8  060000     RETURN
1006:              
1007:              /*$PAGE*/
1008:              /*
1009:              *********************************************************************************************************
1010:              *                                           DUMMY FUNCTION
1011:              *
1012:              * Description: This function doesn't do anything.  It is called by OSTaskDel().
1013:              *
1014:              * Arguments  : none
1015:              *
1016:              * Returns    : none
1017:              *********************************************************************************************************
1018:              */
1019:              
1020:              #if OS_TASK_DEL_EN > 0u
1021:              void  OS_Dummy (void)
1022:              {
0025BA  FA0000     LNK #0x0
1023:              }
0025BC  FA8000     ULNK
0025BE  060000     RETURN
1024:              #endif
1025:              
1026:              /*$PAGE*/
1027:              /*
1028:              *********************************************************************************************************
1029:              *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
1030:              *
1031:              * Description: This function is called by other uC/OS-II services and is used to ready a task that was
1032:              *              waiting for an event to occur.
1033:              *
1034:              * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
1035:              *
1036:              *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
1037:              *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
1038:              *                          service functions.
1039:              *
1040:              *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
1041:              *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
1042:              *
1043:              *              pend_stat   is used to indicate the readied task's pending status:
1044:              *
1045:              *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
1046:              *                                               an abort.
1047:              *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
1048:              *
1049:              * Returns    : none
1050:              *
1051:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1052:              *********************************************************************************************************
1053:              */
1054:              #if (OS_EVENT_EN)
1055:              INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
1056:                                      void      *pmsg,
1057:                                      INT8U      msk,
1058:                                      INT8U      pend_stat)
1059:              {
0025C0  FA000C     LNK #0xC
0025C2  980730     MOV W0, [W14+6]
0025C4  980741     MOV W1, [W14+8]
0025C6  984F22     MOV.B W2, [W14+10]
0025C8  984F33     MOV.B W3, [W14+11]
1060:                  OS_TCB   *ptcb;
1061:                  INT8U     y;
1062:                  INT8U     x;
1063:                  INT8U     prio;
1064:              #if OS_LOWEST_PRIO > 63u
1065:                  OS_PRIO  *ptbl;
1066:              #endif
1067:              
1068:              
1069:              #if OS_LOWEST_PRIO <= 63u
1070:                  y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
0025CA  90003E     MOV [W14+6], W0
0025CC  904060     MOV.B [W0+6], W0
0025CE  FB8000     ZE W0, W0
0025D0  29BEC1     MOV #0x9BEC, W1
0025D2  784F61     MOV.B [W1+W0], [W14]
1071:                  x    = OSUnMapTbl[pevent->OSEventTbl[y]];
0025D4  FB801E     ZE [W14], W0
0025D6  9000BE     MOV [W14+6], W1
0025D8  400066     ADD W0, #0x6, W0
0025DA  408000     ADD W1, W0, W0
0025DC  904010     MOV.B [W0+1], W0
0025DE  FB8000     ZE W0, W0
0025E0  29BEC1     MOV #0x9BEC, W1
0025E2  784161     MOV.B [W1+W0], W2
0025E4  984712     MOV.B W2, [W14+1]
1072:                  prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
0025E6  78409E     MOV.B [W14], W1
0025E8  200030     MOV #0x3, W0
0025EA  DD0880     SL W1, W0, W1
0025EC  90401E     MOV.B [W14+1], W0
0025EE  40C000     ADD.B W1, W0, W0
0025F0  984720     MOV.B W0, [W14+2]
1073:              #else
1074:                  if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
1075:                      y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
1076:                  } else {
1077:                      y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
1078:                  }
1079:                  ptbl = &pevent->OSEventTbl[y];
1080:                  if ((*ptbl & 0xFFu) != 0u) {
1081:                      x = OSUnMapTbl[*ptbl & 0xFFu];
1082:                  } else {
1083:                      x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
1084:                  }
1085:                  prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
1086:              #endif
1087:              
1088:                  ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0025F2  90402E     MOV.B [W14+2], W0
0025F4  FB8000     ZE W0, W0
0025F6  400080     ADD W0, W0, W1
0025F8  219000     MOV #0x1900, W0
0025FA  408000     ADD W1, W0, W0
0025FC  780090     MOV [W0], W1
0025FE  980721     MOV W1, [W14+4]
1089:                  ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
002600  90012E     MOV [W14+4], W2
002602  B80060     MUL.UU W0, #0, W0
002604  980930     MOV W0, [W2+22]
002606  980941     MOV W1, [W2+24]
1090:              #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
1091:                  ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
1092:              #else
1093:                  pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
1094:              #endif
1095:                  ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
002608  90002E     MOV [W14+4], W0
00260A  9058A0     MOV.B [W0+26], W1
00260C  90482E     MOV.B [W14+10], W0
00260E  EAC000     COM.B W0, W0
002610  60C080     AND.B W1, W0, W1
002612  90002E     MOV [W14+4], W0
002614  985821     MOV.B W1, [W0+26]
1096:                  ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
002616  90002E     MOV [W14+4], W0
002618  90493E     MOV.B [W14+11], W2
00261A  985832     MOV.B W2, [W0+27]
1097:                                                                      /* See if task is ready (could be susp'd)      */
1098:                  if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00261C  90002E     MOV [W14+4], W0
00261E  905820     MOV.B [W0+26], W0
002620  FB8000     ZE W0, W0
002622  600068     AND W0, #0x8, W0
002624  E00000     CP0 W0
002626  3A000E     BRA NZ, 0x2644
1099:                      OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
002628  90002E     MOV [W14+4], W0
00262A  906080     MOV.B [W0+32], W1
00262C  BFC865     MOV.B OSRdyGrp, WREG
00262E  70C000     IOR.B W1, W0, W0
002630  B7E865     MOV.B WREG, OSRdyGrp
1100:                      OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
002632  FB801E     ZE [W14], W0
002634  FB809E     ZE [W14], W1
002636  2187E2     MOV #0x187E, W2
002638  78C162     MOV.B [W2+W1], W2
00263A  9000AE     MOV [W14+4], W1
00263C  9058F1     MOV.B [W1+31], W1
00263E  714101     IOR.B W2, W1, W2
002640  2187E1     MOV #0x187E, W1
002642  787082     MOV.B W2, [W1+W0]
1101:                  }
1102:              
1103:                  OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
002644  9000BE     MOV [W14+6], W1
002646  90002E     MOV [W14+4], W0
002648  07008E     RCALL OS_EventTaskRemove
1104:              #if (OS_EVENT_MULTI_EN > 0u)
1105:                  if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
00264A  90002E     MOV [W14+4], W0
00264C  900820     MOV [W0+20], W0
00264E  E00000     CP0 W0
002650  320008     BRA Z, 0x2662
1106:                      OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
002652  90002E     MOV [W14+4], W0
002654  900820     MOV [W0+20], W0
002656  780080     MOV W0, W1
002658  90002E     MOV [W14+4], W0
00265A  0700AC     RCALL OS_EventTaskRemoveMulti
1107:                      ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
00265C  90002E     MOV [W14+4], W0
00265E  9000BE     MOV [W14+6], W1
002660  980811     MOV W1, [W0+18]
1108:                  }
1109:              #endif
1110:              
1111:                  return (prio);
002662  90402E     MOV.B [W14+2], W0
1112:              }
002664  FA8000     ULNK
002666  060000     RETURN
1113:              #endif
1114:              /*$PAGE*/
1115:              /*
1116:              *********************************************************************************************************
1117:              *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
1118:              *
1119:              * Description: This function is called by other uC/OS-II services to suspend a task because an event has
1120:              *              not occurred.
1121:              *
1122:              * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
1123:              *
1124:              * Returns    : none
1125:              *
1126:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1127:              *********************************************************************************************************
1128:              */
1129:              #if (OS_EVENT_EN)
1130:              void  OS_EventTaskWait (OS_EVENT *pevent)
1131:              {
002668  FA0004     LNK #0x4
00266A  980710     MOV W0, [W14+2]
1132:                  INT8U  y;
1133:              
1134:              
1135:                  OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
00266C  804360     MOV OSTCBCur, W0
00266E  90009E     MOV [W14+2], W1
002670  980811     MOV W1, [W0+18]
1136:              
1137:                  pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
002672  804360     MOV OSTCBCur, W0
002674  905860     MOV.B [W0+30], W0
002676  FB8000     ZE W0, W0
002678  804361     MOV OSTCBCur, W1
00267A  9058E1     MOV.B [W1+30], W1
00267C  FB8081     ZE W1, W1
00267E  90011E     MOV [W14+2], W2
002680  4080E6     ADD W1, #0x6, W1
002682  410081     ADD W2, W1, W1
002684  904111     MOV.B [W1+1], W2
002686  804361     MOV OSTCBCur, W1
002688  9058F1     MOV.B [W1+31], W1
00268A  714081     IOR.B W2, W1, W1
00268C  90011E     MOV [W14+2], W2
00268E  410000     ADD W2, W0, W0
002690  984071     MOV.B W1, [W0+7]
1138:                  pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
002692  90001E     MOV [W14+2], W0
002694  9040E0     MOV.B [W0+6], W1
002696  804360     MOV OSTCBCur, W0
002698  906000     MOV.B [W0+32], W0
00269A  70C080     IOR.B W1, W0, W1
00269C  90001E     MOV [W14+2], W0
00269E  984061     MOV.B W1, [W0+6]
1139:              
1140:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0026A0  804360     MOV OSTCBCur, W0
0026A2  9058E0     MOV.B [W0+30], W1
0026A4  784F01     MOV.B W1, [W14]
1141:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
0026A6  FB801E     ZE [W14], W0
0026A8  FB809E     ZE [W14], W1
0026AA  2187E2     MOV #0x187E, W2
0026AC  78C162     MOV.B [W2+W1], W2
0026AE  804361     MOV OSTCBCur, W1
0026B0  9058F1     MOV.B [W1+31], W1
0026B2  EAC081     COM.B W1, W1
0026B4  614101     AND.B W2, W1, W2
0026B6  2187E1     MOV #0x187E, W1
0026B8  787082     MOV.B W2, [W1+W0]
1142:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
0026BA  FB801E     ZE [W14], W0
0026BC  2187E1     MOV #0x187E, W1
0026BE  784061     MOV.B [W1+W0], W0
0026C0  E00400     CP0.B W0
0026C2  3A0006     BRA NZ, 0x26D0
1143:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
0026C4  804360     MOV OSTCBCur, W0
0026C6  906000     MOV.B [W0+32], W0
0026C8  EAC080     COM.B W0, W1
0026CA  BFC865     MOV.B OSRdyGrp, WREG
0026CC  60C000     AND.B W1, W0, W0
0026CE  B7E865     MOV.B WREG, OSRdyGrp
1144:                  }
1145:              }
0026D0  FA8000     ULNK
0026D2  060000     RETURN
1146:              #endif
1147:              /*$PAGE*/
1148:              /*
1149:              *********************************************************************************************************
1150:              *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
1151:              *
1152:              * Description: This function is called by other uC/OS-II services to suspend a task because any one of
1153:              *              multiple events has not occurred.
1154:              *
1155:              * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
1156:              *                               which the task will be waiting for.
1157:              *
1158:              * Returns    : none.
1159:              *
1160:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1161:              *********************************************************************************************************
1162:              */
1163:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1164:              void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
1165:              {
0026D4  FA0008     LNK #0x8
0026D6  980730     MOV W0, [W14+6]
1166:                  OS_EVENT **pevents;
1167:                  OS_EVENT  *pevent;
1168:                  INT8U      y;
1169:              
1170:              
1171:                  OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
0026D8  804360     MOV OSTCBCur, W0
0026DA  EB0080     CLR W1
0026DC  980811     MOV W1, [W0+18]
1172:                  OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
0026DE  804360     MOV OSTCBCur, W0
0026E0  9000BE     MOV [W14+6], W1
0026E2  980821     MOV W1, [W0+20]
1173:              
1174:                  pevents =  pevents_wait;
0026E4  9000BE     MOV [W14+6], W1
0026E6  780F01     MOV W1, [W14]
1175:                  pevent  = *pevents;
0026E8  78001E     MOV [W14], W0
0026EA  780090     MOV [W0], W1
0026EC  980711     MOV W1, [W14+2]
1176:                  while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
0026EE  37001B     BRA 0x2726
002726  90001E     MOV [W14+2], W0
002728  E00000     CP0 W0
00272A  3AFFE2     BRA NZ, 0x26F0
1177:                      pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
0026F0  804360     MOV OSTCBCur, W0
0026F2  905860     MOV.B [W0+30], W0
0026F4  FB8000     ZE W0, W0
0026F6  804361     MOV OSTCBCur, W1
0026F8  9058E1     MOV.B [W1+30], W1
0026FA  FB8081     ZE W1, W1
0026FC  90011E     MOV [W14+2], W2
0026FE  4080E6     ADD W1, #0x6, W1
002700  410081     ADD W2, W1, W1
002702  904111     MOV.B [W1+1], W2
002704  804361     MOV OSTCBCur, W1
002706  9058F1     MOV.B [W1+31], W1
002708  714081     IOR.B W2, W1, W1
00270A  90011E     MOV [W14+2], W2
00270C  410000     ADD W2, W0, W0
00270E  984071     MOV.B W1, [W0+7]
1178:                      pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
002710  90001E     MOV [W14+2], W0
002712  9040E0     MOV.B [W0+6], W1
002714  804360     MOV OSTCBCur, W0
002716  906000     MOV.B [W0+32], W0
002718  70C080     IOR.B W1, W0, W1
00271A  90001E     MOV [W14+2], W0
00271C  984061     MOV.B W1, [W0+6]
1179:                      pevents++;
00271E  E88F1E     INC2 [W14], [W14]
1180:                      pevent = *pevents;
002720  78001E     MOV [W14], W0
002722  780090     MOV [W0], W1
002724  980711     MOV W1, [W14+2]
1181:                  }
1182:              
1183:                  y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00272C  804360     MOV OSTCBCur, W0
00272E  9058E0     MOV.B [W0+30], W1
002730  984741     MOV.B W1, [W14+4]
1184:                  OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
002732  90404E     MOV.B [W14+4], W0
002734  FB8000     ZE W0, W0
002736  9040CE     MOV.B [W14+4], W1
002738  FB8081     ZE W1, W1
00273A  2187E2     MOV #0x187E, W2
00273C  78C162     MOV.B [W2+W1], W2
00273E  804361     MOV OSTCBCur, W1
002740  9058F1     MOV.B [W1+31], W1
002742  EAC081     COM.B W1, W1
002744  614101     AND.B W2, W1, W2
002746  2187E1     MOV #0x187E, W1
002748  787082     MOV.B W2, [W1+W0]
1185:                  if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00274A  90404E     MOV.B [W14+4], W0
00274C  FB8000     ZE W0, W0
00274E  2187E1     MOV #0x187E, W1
002750  784061     MOV.B [W1+W0], W0
002752  E00400     CP0.B W0
002754  3A0006     BRA NZ, 0x2762
1186:                      OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
002756  804360     MOV OSTCBCur, W0
002758  906000     MOV.B [W0+32], W0
00275A  EAC080     COM.B W0, W1
00275C  BFC865     MOV.B OSRdyGrp, WREG
00275E  60C000     AND.B W1, W0, W0
002760  B7E865     MOV.B WREG, OSRdyGrp
1187:                  }
1188:              }
002762  FA8000     ULNK
002764  060000     RETURN
1189:              #endif
1190:              /*$PAGE*/
1191:              /*
1192:              *********************************************************************************************************
1193:              *                                  REMOVE TASK FROM EVENT WAIT LIST
1194:              *
1195:              * Description: Remove a task from an event's wait list.
1196:              *
1197:              * Arguments  : ptcb     is a pointer to the task to remove.
1198:              *
1199:              *              pevent   is a pointer to the event control block.
1200:              *
1201:              * Returns    : none
1202:              *
1203:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1204:              *********************************************************************************************************
1205:              */
1206:              #if (OS_EVENT_EN)
1207:              void  OS_EventTaskRemove (OS_TCB   *ptcb,
1208:                                        OS_EVENT *pevent)
1209:              {
002766  FA0006     LNK #0x6
002768  980710     MOV W0, [W14+2]
00276A  980721     MOV W1, [W14+4]
1210:                  INT8U  y;
1211:              
1212:              
1213:                  y                       =  ptcb->OSTCBY;
00276C  90001E     MOV [W14+2], W0
00276E  9058E0     MOV.B [W0+30], W1
002770  784F01     MOV.B W1, [W14]
1214:                  pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
002772  FB801E     ZE [W14], W0
002774  FB809E     ZE [W14], W1
002776  90012E     MOV [W14+4], W2
002778  4080E6     ADD W1, #0x6, W1
00277A  410081     ADD W2, W1, W1
00277C  904111     MOV.B [W1+1], W2
00277E  90009E     MOV [W14+2], W1
002780  9058F1     MOV.B [W1+31], W1
002782  EAC081     COM.B W1, W1
002784  614081     AND.B W2, W1, W1
002786  90012E     MOV [W14+4], W2
002788  410000     ADD W2, W0, W0
00278A  984071     MOV.B W1, [W0+7]
1215:                  if (pevent->OSEventTbl[y] == 0u) {
00278C  FB801E     ZE [W14], W0
00278E  9000AE     MOV [W14+4], W1
002790  400066     ADD W0, #0x6, W0
002792  408000     ADD W1, W0, W0
002794  904010     MOV.B [W0+1], W0
002796  E00400     CP0.B W0
002798  3A0008     BRA NZ, 0x27AA
1216:                      pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00279A  90002E     MOV [W14+4], W0
00279C  9040E0     MOV.B [W0+6], W1
00279E  90001E     MOV [W14+2], W0
0027A0  906000     MOV.B [W0+32], W0
0027A2  EAC000     COM.B W0, W0
0027A4  60C080     AND.B W1, W0, W1
0027A6  90002E     MOV [W14+4], W0
0027A8  984061     MOV.B W1, [W0+6]
1217:                  }
1218:                  ptcb->OSTCBEventPtr     = (OS_EVENT  *)0;               /* Unlink OS_EVENT from OS_TCB             */
0027AA  90001E     MOV [W14+2], W0
0027AC  EB0080     CLR W1
0027AE  980811     MOV W1, [W0+18]
1219:              }
0027B0  FA8000     ULNK
0027B2  060000     RETURN
1220:              #endif
1221:              /*$PAGE*/
1222:              /*
1223:              *********************************************************************************************************
1224:              *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
1225:              *
1226:              * Description: Remove a task from multiple events' wait lists.
1227:              *
1228:              * Arguments  : ptcb             is a pointer to the task to remove.
1229:              *
1230:              *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
1231:              *
1232:              * Returns    : none
1233:              *
1234:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1235:              *********************************************************************************************************
1236:              */
1237:              #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
1238:              void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
1239:                                             OS_EVENT **pevents_multi)
1240:              {
0027B4  FA000C     LNK #0xC
0027B6  980740     MOV W0, [W14+8]
0027B8  980751     MOV W1, [W14+10]
1241:                  OS_EVENT **pevents;
1242:                  OS_EVENT  *pevent;
1243:                  INT8U      y;
1244:                  OS_PRIO    bity;
1245:                  OS_PRIO    bitx;
1246:              
1247:              
1248:                  y       =  ptcb->OSTCBY;
0027BA  90004E     MOV [W14+8], W0
0027BC  9058E0     MOV.B [W0+30], W1
0027BE  984741     MOV.B W1, [W14+4]
1249:                  bity    =  ptcb->OSTCBBitY;
0027C0  90004E     MOV [W14+8], W0
0027C2  906080     MOV.B [W0+32], W1
0027C4  984751     MOV.B W1, [W14+5]
1250:                  bitx    =  ptcb->OSTCBBitX;
0027C6  90004E     MOV [W14+8], W0
0027C8  9058F0     MOV.B [W0+31], W1
0027CA  984761     MOV.B W1, [W14+6]
1251:                  pevents =  pevents_multi;
0027CC  9000DE     MOV [W14+10], W1
0027CE  780F01     MOV W1, [W14]
1252:                  pevent  = *pevents;
0027D0  78001E     MOV [W14], W0
0027D2  780090     MOV [W0], W1
0027D4  980711     MOV W1, [W14+2]
1253:                  while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
0027D6  370021     BRA 0x281A
00281A  90001E     MOV [W14+2], W0
00281C  E00000     CP0 W0
00281E  3AFFDC     BRA NZ, 0x27D8
1254:                      pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
0027D8  90404E     MOV.B [W14+4], W0
0027DA  FB8000     ZE W0, W0
0027DC  9040CE     MOV.B [W14+4], W1
0027DE  FB8081     ZE W1, W1
0027E0  90011E     MOV [W14+2], W2
0027E2  4080E6     ADD W1, #0x6, W1
0027E4  410081     ADD W2, W1, W1
0027E6  904111     MOV.B [W1+1], W2
0027E8  9040EE     MOV.B [W14+6], W1
0027EA  EAC081     COM.B W1, W1
0027EC  614081     AND.B W2, W1, W1
0027EE  90011E     MOV [W14+2], W2
0027F0  410000     ADD W2, W0, W0
0027F2  984071     MOV.B W1, [W0+7]
1255:                      if (pevent->OSEventTbl[y] == 0u) {
0027F4  90404E     MOV.B [W14+4], W0
0027F6  FB8000     ZE W0, W0
0027F8  90009E     MOV [W14+2], W1
0027FA  400066     ADD W0, #0x6, W0
0027FC  408000     ADD W1, W0, W0
0027FE  904010     MOV.B [W0+1], W0
002800  E00400     CP0.B W0
002802  3A0007     BRA NZ, 0x2812
1256:                          pevent->OSEventGrp &= (OS_PRIO)~bity;
002804  90001E     MOV [W14+2], W0
002806  9040E0     MOV.B [W0+6], W1
002808  90405E     MOV.B [W14+5], W0
00280A  EAC000     COM.B W0, W0
00280C  60C080     AND.B W1, W0, W1
00280E  90001E     MOV [W14+2], W0
002810  984061     MOV.B W1, [W0+6]
1257:                      }
1258:                      pevents++;
002812  E88F1E     INC2 [W14], [W14]
1259:                      pevent = *pevents;
002814  78001E     MOV [W14], W0
002816  780090     MOV [W0], W1
002818  980711     MOV W1, [W14+2]
1260:                  }
1261:              }
002820  FA8000     ULNK
002822  060000     RETURN
1262:              #endif
1263:              /*$PAGE*/
1264:              /*
1265:              *********************************************************************************************************
1266:              *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
1267:              *
1268:              * Description: This function is called by other uC/OS-II services to initialize the event wait list.
1269:              *
1270:              * Arguments  : pevent    is a pointer to the event control block allocated to the event.
1271:              *
1272:              * Returns    : none
1273:              *
1274:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1275:              *********************************************************************************************************
1276:              */
1277:              #if (OS_EVENT_EN)
1278:              void  OS_EventWaitListInit (OS_EVENT *pevent)
1279:              {
002824  FA0004     LNK #0x4
002826  980710     MOV W0, [W14+2]
1280:                  INT8U  i;
1281:              
1282:              
1283:                  pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
002828  90001E     MOV [W14+2], W0
00282A  EB4080     CLR.B W1
00282C  984061     MOV.B W1, [W0+6]
1284:                  for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00282E  EB4000     CLR.B W0
002830  784F00     MOV.B W0, [W14]
002832  370006     BRA 0x2840
00283E  E84F1E     INC.B [W14], [W14]
002840  78401E     MOV.B [W14], W0
002842  504FE1     SUB.B W0, #0x1, [W15]
002844  36FFF7     BRA LEU, 0x2834
1285:                      pevent->OSEventTbl[i] = 0u;
002834  FB801E     ZE [W14], W0
002836  90009E     MOV [W14+2], W1
002838  408000     ADD W1, W0, W0
00283A  EB4080     CLR.B W1
00283C  984071     MOV.B W1, [W0+7]
1286:                  }
1287:              }
002846  FA8000     ULNK
002848  060000     RETURN
1288:              #endif
1289:              /*$PAGE*/
1290:              /*
1291:              *********************************************************************************************************
1292:              *                                             INITIALIZATION
1293:              *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
1294:              *
1295:              * Description: This function is called by OSInit() to initialize the free list of event control blocks.
1296:              *
1297:              * Arguments  : none
1298:              *
1299:              * Returns    : none
1300:              *********************************************************************************************************
1301:              */
1302:              
1303:              static  void  OS_InitEventList (void)
1304:              {
00284A  FA0008     LNK #0x8
1305:              #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
1306:              #if (OS_MAX_EVENTS > 1u)
1307:                  INT16U     ix;
1308:                  INT16U     ix_next;
1309:                  OS_EVENT  *pevent1;
1310:                  OS_EVENT  *pevent2;
1311:              
1312:              
1313:                  OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
00284C  217B60     MOV #0x17B6, W0
00284E  200481     MOV #0x48, W1
002850  0700B8     RCALL OS_MemClr
1314:                  for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
002852  EB0000     CLR W0
002854  780F00     MOV W0, [W14]
002856  370018     BRA 0x2888
002886  E80F1E     INC [W14], [W14]
002888  78001E     MOV [W14], W0
00288A  500FE4     SUB W0, #0x4, [W15]
00288C  36FFE5     BRA LEU, 0x2858
1315:                      ix_next = ix + 1u;
002858  E8001E     INC [W14], W0
00285A  980710     MOV W0, [W14+2]
1316:                      pevent1 = &OSEventTbl[ix];
00285C  78001E     MOV [W14], W0
00285E  B9006C     MUL.SU W0, #12, W0
002860  780080     MOV W0, W1
002862  217B60     MOV #0x17B6, W0
002864  408000     ADD W1, W0, W0
002866  980720     MOV W0, [W14+4]
1317:                      pevent2 = &OSEventTbl[ix_next];
002868  90001E     MOV [W14+2], W0
00286A  B9006C     MUL.SU W0, #12, W0
00286C  780080     MOV W0, W1
00286E  217B60     MOV #0x17B6, W0
002870  408000     ADD W1, W0, W0
002872  980730     MOV W0, [W14+6]
1318:                      pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
002874  90002E     MOV [W14+4], W0
002876  EB4080     CLR.B W1
002878  784801     MOV.B W1, [W0]
1319:                      pevent1->OSEventPtr     = pevent2;
00287A  90002E     MOV [W14+4], W0
00287C  9000BE     MOV [W14+6], W1
00287E  980011     MOV W1, [W0+2]
1320:              #if OS_EVENT_NAME_EN > 0u
1321:                      pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
002880  29CEC1     MOV #0x9CEC, W1
002882  90002E     MOV [W14+4], W0
002884  980051     MOV W1, [W0+10]
1322:              #endif
1323:                  }
1324:                  pevent1                         = &OSEventTbl[ix];
00288E  78001E     MOV [W14], W0
002890  B9006C     MUL.SU W0, #12, W0
002892  780080     MOV W0, W1
002894  217B60     MOV #0x17B6, W0
002896  408000     ADD W1, W0, W0
002898  980720     MOV W0, [W14+4]
1325:                  pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00289A  90002E     MOV [W14+4], W0
00289C  EB4080     CLR.B W1
00289E  784801     MOV.B W1, [W0]
1326:                  pevent1->OSEventPtr             = (OS_EVENT *)0;
0028A0  90002E     MOV [W14+4], W0
0028A2  EB0080     CLR W1
0028A4  980011     MOV W1, [W0+2]
1327:              #if OS_EVENT_NAME_EN > 0u
1328:                  pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
0028A6  29CEC1     MOV #0x9CEC, W1
0028A8  90002E     MOV [W14+4], W0
0028AA  980051     MOV W1, [W0+10]
1329:              #endif
1330:                  OSEventFreeList                 = &OSEventTbl[0];
0028AC  217B60     MOV #0x17B6, W0
0028AE  8842A0     MOV W0, OSEventFreeList
1331:              #else
1332:                  OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
1333:                  OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
1334:                  OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
1335:              #if OS_EVENT_NAME_EN > 0u
1336:                  OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
1337:              #endif
1338:              #endif
1339:              #endif
1340:              }
0028B0  FA8000     ULNK
0028B2  060000     RETURN
1341:              /*$PAGE*/
1342:              /*
1343:              *********************************************************************************************************
1344:              *                                             INITIALIZATION
1345:              *                                    INITIALIZE MISCELLANEOUS VARIABLES
1346:              *
1347:              * Description: This function is called by OSInit() to initialize miscellaneous variables.
1348:              *
1349:              * Arguments  : none
1350:              *
1351:              * Returns    : none
1352:              *********************************************************************************************************
1353:              */
1354:              
1355:              static  void  OS_InitMisc (void)
1356:              {
0028B4  FA0000     LNK #0x0
1357:              #if OS_TIME_GET_SET_EN > 0u
1358:                  OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
1359:              #endif
1360:              
1361:                  OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
0028B6  EF6861     CLR.B OSIntNesting
1362:                  OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
0028B8  EF6862     CLR.B OSLockNesting
1363:              
1364:                  OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
0028BA  EF6867     CLR.B OSTaskCtr
1365:              
1366:                  OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
0028BC  EF6866     CLR.B OSRunning
1367:              
1368:                  OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
0028BE  EF2850     CLR OSCtxSwCtr
0028C0  EF2852     CLR 0x852
1369:                  OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
0028C2  EF2868     CLR OSIdleCtr
0028C4  EF286A     CLR 0x86A
1370:              
1371:              #if OS_TASK_STAT_EN > 0u
1372:                  OSIdleCtrRun              = 0uL;
0028C6  EF285C     CLR OSIdleCtrRun
0028C8  EF285E     CLR 0x85E
1373:                  OSIdleCtrMax              = 0uL;
0028CA  EF2858     CLR OSIdleCtrMax
0028CC  EF285A     CLR 0x85A
1374:                  OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
0028CE  EF6860     CLR.B OSStatRdy
1375:              #endif
1376:              
1377:              #ifdef OS_SAFETY_CRITICAL_IEC61508
1378:                  OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
1379:              #endif
1380:              
1381:              #if OS_TASK_REG_TBL_SIZE > 0u
1382:                  OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
0028D0  EF6875     CLR.B OSTaskRegNextAvailID
1383:              #endif
1384:              }
0028D2  FA8000     ULNK
0028D4  060000     RETURN
1385:              /*$PAGE*/
1386:              /*
1387:              *********************************************************************************************************
1388:              *                                             INITIALIZATION
1389:              *                                       INITIALIZE THE READY LIST
1390:              *
1391:              * Description: This function is called by OSInit() to initialize the Ready List.
1392:              *
1393:              * Arguments  : none
1394:              *
1395:              * Returns    : none
1396:              *********************************************************************************************************
1397:              */
1398:              
1399:              static  void  OS_InitRdyList (void)
1400:              {
0028D6  FA0002     LNK #0x2
1401:                  INT8U  i;
1402:              
1403:              
1404:                  OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
0028D8  EF6865     CLR.B OSRdyGrp
1405:                  for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
0028DA  EB4000     CLR.B W0
0028DC  784F00     MOV.B W0, [W14]
0028DE  370005     BRA 0x28EA
0028E8  E84F1E     INC.B [W14], [W14]
0028EA  78401E     MOV.B [W14], W0
0028EC  504FE1     SUB.B W0, #0x1, [W15]
0028EE  36FFF8     BRA LEU, 0x28E0
1406:                      OSRdyTbl[i] = 0u;
0028E0  FB801E     ZE [W14], W0
0028E2  2187E1     MOV #0x187E, W1
0028E4  EB4100     CLR.B W2
0028E6  787082     MOV.B W2, [W1+W0]
1407:                  }
1408:              
1409:                  OSPrioCur     = 0u;
0028F0  EF6863     CLR.B OSPrioCur
1410:                  OSPrioHighRdy = 0u;
0028F2  EF6864     CLR.B OSPrioHighRdy
1411:              
1412:                  OSTCBHighRdy  = (OS_TCB *)0;
0028F4  EF2870     CLR OSTCBHighRdy
1413:                  OSTCBCur      = (OS_TCB *)0;
0028F6  EF286C     CLR OSTCBCur
1414:              }
0028F8  FA8000     ULNK
0028FA  060000     RETURN
1415:              
1416:              /*$PAGE*/
1417:              /*
1418:              *********************************************************************************************************
1419:              *                                             INITIALIZATION
1420:              *                                         CREATING THE IDLE TASK
1421:              *
1422:              * Description: This function creates the Idle Task.
1423:              *
1424:              * Arguments  : none
1425:              *
1426:              * Returns    : none
1427:              *********************************************************************************************************
1428:              */
1429:              
1430:              static  void  OS_InitTaskIdle (void)
1431:              {
0028FC  FA0002     LNK #0x2
1432:              #if OS_TASK_NAME_EN > 0u
1433:                  INT8U  err;
1434:              #endif
1435:              
1436:              
1437:              #if OS_TASK_CREATE_EXT_EN > 0u
1438:                  #if OS_STK_GROWTH == 1u
1439:                  (void)OSTaskCreateExt(OS_TaskIdle,
1440:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1441:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
1442:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1443:                                        OS_TASK_IDLE_ID,
1444:                                        &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
1445:                                        OS_TASK_IDLE_STK_SIZE,
1446:                                        (void *)0,                                 /* No TCB extension                     */
1447:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1448:                  #else
1449:                  (void)OSTaskCreateExt(OS_TaskIdle,
0028FE  200030     MOV #0x3, W0
002900  781F80     MOV W0, [W15++]
002902  EB0000     CLR W0
002904  781F80     MOV W0, [W15++]
002906  200406     MOV #0x40, W6
002908  200007     MOV #0x0, W7
00290A  218FE5     MOV #0x18FE, W5
00290C  EB8200     SETM W4
00290E  B3C0A3     MOV.B #0xA, W3
002910  218802     MOV #0x1880, W2
002912  EB0080     CLR W1
002914  22AB60     MOV #0x2AB6, W0
002916  071020     RCALL OSTaskCreateExt
002918  5787E4     SUB W15, #0x4, W15
1450:                                        (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
1451:                                        &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
1452:                                        OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
1453:                                        OS_TASK_IDLE_ID,
1454:                                        &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
1455:                                        OS_TASK_IDLE_STK_SIZE,
1456:                                        (void *)0,                                 /* No TCB extension                     */
1457:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
1458:                  #endif
1459:              #else
1460:                  #if OS_STK_GROWTH == 1u
1461:                  (void)OSTaskCreate(OS_TaskIdle,
1462:                                     (void *)0,
1463:                                     &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
1464:                                     OS_TASK_IDLE_PRIO);
1465:                  #else
1466:                  (void)OSTaskCreate(OS_TaskIdle,
1467:                                     (void *)0,
1468:                                     &OSTaskIdleStk[0],
1469:                                     OS_TASK_IDLE_PRIO);
1470:                  #endif
1471:              #endif
1472:              
1473:              #if OS_TASK_NAME_EN > 0u
1474:                  OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
00291A  29CEE0     MOV #0x9CEE, W0
00291C  78010E     MOV W14, W2
00291E  780080     MOV W0, W1
002920  B3C0A0     MOV.B #0xA, W0
002922  0711CD     RCALL OSTaskNameSet
1475:              #endif
1476:              }
002924  FA8000     ULNK
002926  060000     RETURN
1477:              /*$PAGE*/
1478:              /*
1479:              *********************************************************************************************************
1480:              *                                             INITIALIZATION
1481:              *                                      CREATING THE STATISTIC TASK
1482:              *
1483:              * Description: This function creates the Statistic Task.
1484:              *
1485:              * Arguments  : none
1486:              *
1487:              * Returns    : none
1488:              *********************************************************************************************************
1489:              */
1490:              
1491:              #if OS_TASK_STAT_EN > 0u
1492:              static  void  OS_InitTaskStat (void)
1493:              {
002928  FA0002     LNK #0x2
1494:              #if OS_TASK_NAME_EN > 0u
1495:                  INT8U  err;
1496:              #endif
1497:              
1498:              
1499:              #if OS_TASK_CREATE_EXT_EN > 0u
1500:                  #if OS_STK_GROWTH == 1u
1501:                  (void)OSTaskCreateExt(OS_TaskStat,
1502:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1503:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
1504:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1505:                                        OS_TASK_STAT_ID,
1506:                                        &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
1507:                                        OS_TASK_STAT_STK_SIZE,
1508:                                        (void *)0,                                   /* No TCB extension               */
1509:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1510:                  #else
1511:                  (void)OSTaskCreateExt(OS_TaskStat,
00292A  200030     MOV #0x3, W0
00292C  781F80     MOV W0, [W15++]
00292E  EB0000     CLR W0
002930  781F80     MOV W0, [W15++]
002932  200406     MOV #0x40, W6
002934  200007     MOV #0x0, W7
002936  2187C5     MOV #0x187C, W5
002938  2FFFE4     MOV #0xFFFE, W4
00293A  B3C093     MOV.B #0x9, W3
00293C  217FE2     MOV #0x17FE, W2
00293E  EB0080     CLR W1
002940  22ADE0     MOV #0x2ADE, W0
002942  07100A     RCALL OSTaskCreateExt
002944  5787E4     SUB W15, #0x4, W15
1512:                                        (void *)0,                                   /* No args passed to OS_TaskStat()*/
1513:                                        &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
1514:                                        OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
1515:                                        OS_TASK_STAT_ID,
1516:                                        &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
1517:                                        OS_TASK_STAT_STK_SIZE,
1518:                                        (void *)0,                                   /* No TCB extension               */
1519:                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
1520:                  #endif
1521:              #else
1522:                  #if OS_STK_GROWTH == 1u
1523:                  (void)OSTaskCreate(OS_TaskStat,
1524:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1525:                                     &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
1526:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1527:                  #else
1528:                  (void)OSTaskCreate(OS_TaskStat,
1529:                                     (void *)0,                                      /* No args passed to OS_TaskStat()*/
1530:                                     &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
1531:                                     OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
1532:                  #endif
1533:              #endif
1534:              
1535:              #if OS_TASK_NAME_EN > 0u
1536:                  OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
002946  29CFC0     MOV #0x9CFC, W0
002948  78010E     MOV W14, W2
00294A  780080     MOV W0, W1
00294C  B3C090     MOV.B #0x9, W0
00294E  0711B7     RCALL OSTaskNameSet
1537:              #endif
1538:              }
002950  FA8000     ULNK
002952  060000     RETURN
1539:              #endif
1540:              /*$PAGE*/
1541:              /*
1542:              *********************************************************************************************************
1543:              *                                             INITIALIZATION
1544:              *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
1545:              *
1546:              * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
1547:              *
1548:              * Arguments  : none
1549:              *
1550:              * Returns    : none
1551:              *********************************************************************************************************
1552:              */
1553:              
1554:              static  void  OS_InitTCBList (void)
1555:              {
002954  FA0006     LNK #0x6
1556:                  INT8U    ix;
1557:                  INT8U    ix_next;
1558:                  OS_TCB  *ptcb1;
1559:                  OS_TCB  *ptcb2;
1560:              
1561:              
1562:                  OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
002956  219160     MOV #0x1916, W0
002958  202441     MOV #0x244, W1
00295A  070033     RCALL OS_MemClr
1563:                  OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00295C  219000     MOV #0x1900, W0
00295E  200161     MOV #0x16, W1
002960  070030     RCALL OS_MemClr
1564:                  for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
002962  EB4000     CLR.B W0
002964  784F00     MOV.B W0, [W14]
002966  370018     BRA 0x2998
002996  E84F1E     INC.B [W14], [W14]
002998  78401E     MOV.B [W14], W0
00299A  504FE8     SUB.B W0, #0x8, [W15]
00299C  36FFE5     BRA LEU, 0x2968
1565:                      ix_next =  ix + 1u;
002968  E8401E     INC.B [W14], W0
00296A  984710     MOV.B W0, [W14+1]
1566:                      ptcb1   = &OSTCBTbl[ix];
00296C  FB809E     ZE [W14], W1
00296E  2003A0     MOV #0x3A, W0
002970  B98800     MUL.SS W1, W0, W0
002972  780080     MOV W0, W1
002974  219160     MOV #0x1916, W0
002976  408000     ADD W1, W0, W0
002978  980710     MOV W0, [W14+2]
1567:                      ptcb2   = &OSTCBTbl[ix_next];
00297A  90401E     MOV.B [W14+1], W0
00297C  FB8080     ZE W0, W1
00297E  2003A0     MOV #0x3A, W0
002980  B98800     MUL.SS W1, W0, W0
002982  780080     MOV W0, W1
002984  219160     MOV #0x1916, W0
002986  408000     ADD W1, W0, W0
002988  980720     MOV W0, [W14+4]
1568:                      ptcb1->OSTCBNext = ptcb2;
00298A  90001E     MOV [W14+2], W0
00298C  9000AE     MOV [W14+4], W1
00298E  980071     MOV W1, [W0+14]
1569:              #if OS_TASK_NAME_EN > 0u
1570:                      ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
002990  29CEC1     MOV #0x9CEC, W1
002992  90001E     MOV [W14+2], W0
002994  981821     MOV W1, [W0+52]
1571:              #endif
1572:                  }
1573:                  ptcb1                   = &OSTCBTbl[ix];
00299E  FB809E     ZE [W14], W1
0029A0  2003A0     MOV #0x3A, W0
0029A2  B98800     MUL.SS W1, W0, W0
0029A4  780080     MOV W0, W1
0029A6  219160     MOV #0x1916, W0
0029A8  408000     ADD W1, W0, W0
0029AA  980710     MOV W0, [W14+2]
1574:                  ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
0029AC  90001E     MOV [W14+2], W0
0029AE  EB0080     CLR W1
0029B0  980071     MOV W1, [W0+14]
1575:              #if OS_TASK_NAME_EN > 0u
1576:                  ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
0029B2  29CEC1     MOV #0x9CEC, W1
0029B4  90001E     MOV [W14+2], W0
0029B6  981821     MOV W1, [W0+52]
1577:              #endif
1578:                  OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
0029B8  EF2872     CLR OSTCBList
1579:                  OSTCBFreeList           = &OSTCBTbl[0];
0029BA  219160     MOV #0x1916, W0
0029BC  884370     MOV W0, OSTCBFreeList
1580:              }
0029BE  FA8000     ULNK
0029C0  060000     RETURN
1581:              /*$PAGE*/
1582:              /*
1583:              *********************************************************************************************************
1584:              *                                      CLEAR A SECTION OF MEMORY
1585:              *
1586:              * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
1587:              *
1588:              * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
1589:              *
1590:              *              size     is the number of bytes to clear.
1591:              *
1592:              * Returns    : none
1593:              *
1594:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1595:              *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
1596:              *                 of the uses of this function gets close to this limit.
1597:              *              3) The clear is done one byte at a time since this will work on any processor irrespective
1598:              *                 of the alignment of the destination.
1599:              *********************************************************************************************************
1600:              */
1601:              
1602:              void  OS_MemClr (INT8U  *pdest,
1603:                               INT16U  size)
1604:              {
0029C2  FA0004     LNK #0x4
0029C4  780F00     MOV W0, [W14]
0029C6  980711     MOV W1, [W14+2]
1605:                  while (size > 0u) {
0029C8  370007     BRA 0x29D8
0029D8  90001E     MOV [W14+2], W0
0029DA  E00000     CP0 W0
0029DC  3AFFF6     BRA NZ, 0x29CA
1606:                      *pdest++ = (INT8U)0;
0029CA  78001E     MOV [W14], W0
0029CC  EB4080     CLR.B W1
0029CE  784801     MOV.B W1, [W0]
0029D0  E80F1E     INC [W14], [W14]
1607:                      size--;
0029D2  90001E     MOV [W14+2], W0
0029D4  E90000     DEC W0, W0
0029D6  980710     MOV W0, [W14+2]
1608:                  }
1609:              }
0029DE  FA8000     ULNK
0029E0  060000     RETURN
1610:              /*$PAGE*/
1611:              /*
1612:              *********************************************************************************************************
1613:              *                                       COPY A BLOCK OF MEMORY
1614:              *
1615:              * Description: This function is called by other uC/OS-II services to copy a block of memory from one
1616:              *              location to another.
1617:              *
1618:              * Arguments  : pdest    is a pointer to the 'destination' memory block
1619:              *
1620:              *              psrc     is a pointer to the 'source'      memory block
1621:              *
1622:              *              size     is the number of bytes to copy.
1623:              *
1624:              * Returns    : none
1625:              *
1626:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
1627:              *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
1628:              *                 is not a situation that will happen.
1629:              *              2) Note that we can only copy up to 64K bytes of RAM
1630:              *              3) The copy is done one byte at a time since this will work on any processor irrespective
1631:              *                 of the alignment of the source and destination.
1632:              *********************************************************************************************************
1633:              */
1634:              
1635:              void  OS_MemCopy (INT8U  *pdest,
1636:                                INT8U  *psrc,
1637:                                INT16U  size)
1638:              {
0029E2  FA0006     LNK #0x6
0029E4  780F00     MOV W0, [W14]
0029E6  980711     MOV W1, [W14+2]
0029E8  980722     MOV W2, [W14+4]
1639:                  while (size > 0u) {
0029EA  37000B     BRA 0x2A02
002A02  90002E     MOV [W14+4], W0
002A04  E00000     CP0 W0
002A06  3AFFF2     BRA NZ, 0x29EC
1640:                      *pdest++ = *psrc++;
0029EC  90001E     MOV [W14+2], W0
0029EE  784090     MOV.B [W0], W1
0029F0  78001E     MOV [W14], W0
0029F2  784801     MOV.B W1, [W0]
0029F4  E80F1E     INC [W14], [W14]
0029F6  90001E     MOV [W14+2], W0
0029F8  E80000     INC W0, W0
0029FA  980710     MOV W0, [W14+2]
1641:                      size--;
0029FC  90002E     MOV [W14+4], W0
0029FE  E90000     DEC W0, W0
002A00  980720     MOV W0, [W14+4]
1642:                  }
1643:              }
002A08  FA8000     ULNK
002A0A  060000     RETURN
1644:              /*$PAGE*/
1645:              /*
1646:              *********************************************************************************************************
1647:              *                                              SCHEDULER
1648:              *
1649:              * Description: This function is called by other uC/OS-II services to determine whether a new, high
1650:              *              priority task has been made ready to run.  This function is invoked by TASK level code
1651:              *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
1652:              *
1653:              * Arguments  : none
1654:              *
1655:              * Returns    : none
1656:              *
1657:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1658:              *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
1659:              *********************************************************************************************************
1660:              */
1661:              
1662:              void  OS_Sched (void)
1663:              {
002A0C  FA0002     LNK #0x2
1664:              #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
1665:                  OS_CPU_SR  cpu_sr = 0u;
002A0E  EB0000     CLR W0
002A10  780F00     MOV W0, [W14]
1666:              #endif
1667:              
1668:              
1669:              
1670:                  OS_ENTER_CRITICAL();
002A12  800211     MOV SR, W1
002A14  780F01     MOV W1, [W14]
002A16  800211     MOV SR, W1
002A18  200E00     MOV #0xE0, W0
002A1A  700001     IOR W0, W1, W0
002A1C  880210     MOV W0, SR
1671:                  if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
002A1E  BFC861     MOV.B OSIntNesting, WREG
002A20  E00400     CP0.B W0
002A22  3A001E     BRA NZ, 0x2A60
1672:                      if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
002A24  BFC862     MOV.B OSLockNesting, WREG
002A26  E00400     CP0.B W0
002A28  3A001B     BRA NZ, 0x2A60
1673:                          OS_SchedNew();
002A2A  07001E     RCALL _OS_SchedNew
1674:                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
002A2C  BFC864     MOV.B OSPrioHighRdy, WREG
002A2E  FB8000     ZE W0, W0
002A30  400080     ADD W0, W0, W1
002A32  219000     MOV #0x1900, W0
002A34  408000     ADD W1, W0, W0
002A36  780010     MOV [W0], W0
002A38  884380     MOV W0, OSTCBHighRdy
1675:                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
002A3A  208641     MOV #0x864, W1
002A3C  784091     MOV.B [W1], W1
002A3E  BFC863     MOV.B OSPrioCur, WREG
002A40  50CF80     SUB.B W1, W0, [W15]
002A42  32000E     BRA Z, 0x2A60
1676:              #if OS_TASK_PROFILE_EN > 0u
1677:                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
002A44  804382     MOV OSTCBHighRdy, W2
002A46  901012     MOV [W2+34], W0
002A48  9010A2     MOV [W2+36], W1
002A4A  400061     ADD W0, #0x1, W0
002A4C  4880E0     ADDC W1, #0x0, W1
002A4E  981110     MOV W0, [W2+34]
002A50  981121     MOV W1, [W2+36]
1678:              #endif
1679:                              OSCtxSwCtr++;                          /* Increment context switch counter             */
002A52  804280     MOV OSCtxSwCtr, W0
002A54  804291     MOV 0x852, W1
002A56  400061     ADD W0, #0x1, W0
002A58  4880E0     ADDC W1, #0x0, W1
002A5A  884280     MOV W0, OSCtxSwCtr
002A5C  884291     MOV W1, 0x852
1680:              
1681:              #if OS_TASK_CREATE_EXT_EN > 0u
1682:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1683:                              OS_TLS_TaskSw();
1684:              #endif
1685:              #endif
1686:              
1687:                              OS_TASK_SW();                          /* Perform a context switch                     */
002A5E  07277E     RCALL 0x795C
1688:                          }
1689:                      }
1690:                  }
1691:                  OS_EXIT_CRITICAL();
002A60  78009E     MOV [W14], W1
002A62  880211     MOV W1, SR
1692:              }
002A64  FA8000     ULNK
002A66  060000     RETURN
1693:              
1694:              
1695:              /*
1696:              *********************************************************************************************************
1697:              *                               FIND HIGHEST PRIORITY TASK READY TO RUN
1698:              *
1699:              * Description: This function is called by other uC/OS-II services to determine the highest priority task
1700:              *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
1701:              *
1702:              * Arguments  : none
1703:              *
1704:              * Returns    : none
1705:              *
1706:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1707:              *              2) Interrupts are assumed to be disabled when this function is called.
1708:              *********************************************************************************************************
1709:              */
1710:              
1711:              static  void  OS_SchedNew (void)
1712:              {
002A68  FA0002     LNK #0x2
1713:              #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
1714:                  INT8U   y;
1715:              
1716:              
1717:                  y             = OSUnMapTbl[OSRdyGrp];
002A6A  BFC865     MOV.B OSRdyGrp, WREG
002A6C  FB8000     ZE W0, W0
002A6E  29BEC1     MOV #0x9BEC, W1
002A70  784F61     MOV.B [W1+W0], [W14]
1718:                  OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
002A72  78409E     MOV.B [W14], W1
002A74  200030     MOV #0x3, W0
002A76  DD0880     SL W1, W0, W1
002A78  FB801E     ZE [W14], W0
002A7A  2187E2     MOV #0x187E, W2
002A7C  784062     MOV.B [W2+W0], W0
002A7E  FB8000     ZE W0, W0
002A80  29BEC2     MOV #0x9BEC, W2
002A82  784062     MOV.B [W2+W0], W0
002A84  40C000     ADD.B W1, W0, W0
002A86  B7E864     MOV.B WREG, OSPrioHighRdy
1719:              #else                                            /* We support up to 256 tasks                         */
1720:                  INT8U     y;
1721:                  OS_PRIO  *ptbl;
1722:              
1723:              
1724:                  if ((OSRdyGrp & 0xFFu) != 0u) {
1725:                      y = OSUnMapTbl[OSRdyGrp & 0xFFu];
1726:                  } else {
1727:                      y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
1728:                  }
1729:                  ptbl = &OSRdyTbl[y];
1730:                  if ((*ptbl & 0xFFu) != 0u) {
1731:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
1732:                  } else {
1733:                      OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
1734:                  }
1735:              #endif
1736:              }
002A88  FA8000     ULNK
002A8A  060000     RETURN
1737:              
1738:              /*$PAGE*/
1739:              /*
1740:              *********************************************************************************************************
1741:              *                               DETERMINE THE LENGTH OF AN ASCII STRING
1742:              *
1743:              * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
1744:              *              (excluding the NUL character).
1745:              *
1746:              * Arguments  : psrc     is a pointer to the string for which we need to know the size.
1747:              *
1748:              * Returns    : The size of the string (excluding the NUL terminating character)
1749:              *
1750:              * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
1751:              *              2) The string to check must be less than 255 characters long.
1752:              *********************************************************************************************************
1753:              */
1754:              
1755:              #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
1756:              INT8U  OS_StrLen (INT8U *psrc)
1757:              {
002A8C  FA0004     LNK #0x4
002A8E  980710     MOV W0, [W14+2]
1758:                  INT8U  len;
1759:              
1760:              
1761:              #if OS_ARG_CHK_EN > 0u
1762:                  if (psrc == (INT8U *)0) {
002A90  90001E     MOV [W14+2], W0
002A92  E00000     CP0 W0
002A94  3A0002     BRA NZ, 0x2A9A
1763:                      return (0u);
002A96  EB4000     CLR.B W0
002A98  37000C     BRA 0x2AB2
1764:                  }
1765:              #endif
1766:              
1767:                  len = 0u;
002A9A  EB4000     CLR.B W0
002A9C  784F00     MOV.B W0, [W14]
1768:                  while (*psrc != OS_ASCII_NUL) {
002A9E  370004     BRA 0x2AA8
002AA8  90001E     MOV [W14+2], W0
002AAA  784010     MOV.B [W0], W0
002AAC  E00400     CP0.B W0
002AAE  3AFFF8     BRA NZ, 0x2AA0
1769:                      psrc++;
002AA0  90001E     MOV [W14+2], W0
002AA2  E80000     INC W0, W0
002AA4  980710     MOV W0, [W14+2]
1770:                      len++;
002AA6  E84F1E     INC.B [W14], [W14]
1771:                  }
1772:                  return (len);
002AB0  78401E     MOV.B [W14], W0
1773:              }
002AB2  FA8000     ULNK
002AB4  060000     RETURN
1774:              #endif
1775:              /*$PAGE*/
1776:              /*
1777:              *********************************************************************************************************
1778:              *                                              IDLE TASK
1779:              *
1780:              * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
1781:              *              executes because they are ALL waiting for event(s) to occur.
1782:              *
1783:              * Arguments  : none
1784:              *
1785:              * Returns    : none
1786:              *
1787:              * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
1788:              *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
1789:              *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
1790:              *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
1791:              *                 interrupts.
1792:              *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
1793:              *                 power.
1794:              *********************************************************************************************************
1795:              */
1796:              
1797:              void  OS_TaskIdle (void *p_arg)
1798:              {
002AB6  FA0004     LNK #0x4
002AB8  980710     MOV W0, [W14+2]
1799:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1800:                  OS_CPU_SR  cpu_sr = 0u;
002ABA  EB0000     CLR W0
002ABC  780F00     MOV W0, [W14]
1801:              #endif
1802:              
1803:              
1804:              
1805:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1806:                  for (;;) {
1807:                      OS_ENTER_CRITICAL();
002ABE  800211     MOV SR, W1
002AC0  780F01     MOV W1, [W14]
002AC2  800211     MOV SR, W1
002AC4  200E00     MOV #0xE0, W0
002AC6  700001     IOR W0, W1, W0
002AC8  880210     MOV W0, SR
1808:                      OSIdleCtr++;
002ACA  804340     MOV OSIdleCtr, W0
002ACC  804351     MOV 0x86A, W1
002ACE  400061     ADD W0, #0x1, W0
002AD0  4880E0     ADDC W1, #0x0, W1
002AD2  884340     MOV W0, OSIdleCtr
002AD4  884351     MOV W1, 0x86A
1809:                      OS_EXIT_CRITICAL();
002AD6  78009E     MOV [W14], W1
002AD8  880211     MOV W1, SR
1810:                      OSTaskIdleHook();                        /* Call user definable HOOK                           */
002ADA  07221D     RCALL OSTaskIdleHook
1811:                  }
002ADC  37FFF0     BRA 0x2ABE
1812:              }
1813:              /*$PAGE*/
1814:              /*
1815:              *********************************************************************************************************
1816:              *                                           STATISTICS TASK
1817:              *
1818:              * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
1819:              *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
1820:              *              CPU usage is determined by:
1821:              *
1822:              *                                          OSIdleCtr
1823:              *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
1824:              *                                         OSIdleCtrMax
1825:              *
1826:              * Arguments  : parg     this pointer is not used at this time.
1827:              *
1828:              * Returns    : none
1829:              *
1830:              * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
1831:              *                 next higher priority, OS_TASK_IDLE_PRIO-1.
1832:              *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
1833:              *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
1834:              *                 maximum value for the idle counter.
1835:              *********************************************************************************************************
1836:              */
1837:              
1838:              #if OS_TASK_STAT_EN > 0u
1839:              void  OS_TaskStat (void *p_arg)
1840:              {
002ADE  FA0004     LNK #0x4
002AE0  980710     MOV W0, [W14+2]
1841:              #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
1842:                  OS_CPU_SR  cpu_sr = 0u;
002AE2  EB0000     CLR W0
002AE4  780F00     MOV W0, [W14]
1843:              #endif
1844:              
1845:              
1846:              
1847:                  p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
1848:                  while (OSStatRdy == OS_FALSE) {
002AE6  370003     BRA 0x2AEE
002AEE  BFC860     MOV.B OSStatRdy, WREG
002AF0  E00400     CP0.B W0
002AF2  32FFFA     BRA Z, 0x2AE8
1849:                      OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
002AE8  200C80     MOV #0xC8, W0
002AEA  200001     MOV #0x0, W1
002AEC  072383     RCALL OSTimeDly
1850:                  }
1851:                  OSIdleCtrMax /= 100uL;
002AF4  8042C0     MOV OSIdleCtrMax, W0
002AF6  8042D1     MOV 0x85A, W1
002AF8  200642     MOV #0x64, W2
002AFA  200003     MOV #0x0, W3
002AFC  07EE16     RCALL 0x72A
002AFE  8842C0     MOV W0, OSIdleCtrMax
002B00  8842D1     MOV W1, 0x85A
1852:                  if (OSIdleCtrMax == 0uL) {
002B02  8042C0     MOV OSIdleCtrMax, W0
002B04  8042D1     MOV 0x85A, W1
002B06  500FE0     SUB W0, #0x0, [W15]
002B08  588FE0     SUBB W1, #0x0, [W15]
002B0A  3A0003     BRA NZ, 0x2B12
1853:                      OSCPUUsage = 0u;
002B0C  EF6856     CLR.B OSCPUUsage
1854:              #if OS_TASK_SUSPEND_EN > 0u
1855:                      (void)OSTaskSuspend(OS_PRIO_SELF);
002B0E  EBC000     SETM.B W0
002B10  0711F6     RCALL OSTaskSuspend
1856:              #else
1857:                      for (;;) {
1858:                          OSTimeDly(OS_TICKS_PER_SEC);
1859:                      }
1860:              #endif
1861:                  }
1862:                  OS_ENTER_CRITICAL();
002B12  800211     MOV SR, W1
002B14  780F01     MOV W1, [W14]
002B16  800211     MOV SR, W1
002B18  200E00     MOV #0xE0, W0
002B1A  700001     IOR W0, W1, W0
002B1C  880210     MOV W0, SR
1863:                  OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
002B1E  8042C0     MOV OSIdleCtrMax, W0
002B20  8042D1     MOV 0x85A, W1
002B22  200642     MOV #0x64, W2
002B24  B98902     MUL.SS W1, W2, W2
002B26  780102     MOV W2, W2
002B28  B90260     MUL.SU W0, #0, W4
002B2A  780184     MOV W4, W3
002B2C  410103     ADD W2, W3, W2
002B2E  200643     MOV #0x64, W3
002B30  B80003     MUL.UU W0, W3, W0
002B32  410101     ADD W2, W1, W2
002B34  780082     MOV W2, W1
002B36  884340     MOV W0, OSIdleCtr
002B38  884351     MOV W1, 0x86A
1864:                  OS_EXIT_CRITICAL();
002B3A  78009E     MOV [W14], W1
002B3C  880211     MOV W1, SR
1865:                  for (;;) {
1866:                      OS_ENTER_CRITICAL();
002B3E  800211     MOV SR, W1
002B40  780F01     MOV W1, [W14]
002B42  800211     MOV SR, W1
002B44  200E00     MOV #0xE0, W0
002B46  700001     IOR W0, W1, W0
002B48  880210     MOV W0, SR
1867:                      OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
002B4A  804340     MOV OSIdleCtr, W0
002B4C  804351     MOV 0x86A, W1
002B4E  8842E0     MOV W0, OSIdleCtrRun
002B50  8842F1     MOV W1, 0x85E
1868:                      OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
002B52  EF2868     CLR OSIdleCtr
002B54  EF286A     CLR 0x86A
1869:                      OS_EXIT_CRITICAL();
002B56  78009E     MOV [W14], W1
002B58  880211     MOV W1, SR
1870:                      OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
002B5A  8042E4     MOV OSIdleCtrRun, W4
002B5C  8042F5     MOV 0x85E, W5
002B5E  8042C0     MOV OSIdleCtrMax, W0
002B60  8042D1     MOV 0x85A, W1
002B62  BE0100     MOV.D W0, W2
002B64  BE0004     MOV.D W4, W0
002B66  07EDE1     RCALL 0x72A
002B68  784000     MOV.B W0, W0
002B6A  B3C641     MOV.B #0x64, W1
002B6C  50C000     SUB.B W1, W0, W0
002B6E  B7E856     MOV.B WREG, OSCPUUsage
1871:                      OSTaskStatHook();                        /* Invoke user definable hook                         */
002B70  0721D9     RCALL OSTaskStatHook
1872:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1873:                      OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
002B72  070004     RCALL OS_TaskStatStkChk
1874:              #endif
1875:                      OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
002B74  200640     MOV #0x64, W0
002B76  200001     MOV #0x0, W1
002B78  07233D     RCALL OSTimeDly
1876:                  }
002B7A  37FFE1     BRA 0x2B3E
1877:              }
1878:              #endif
1879:              /*$PAGE*/
1880:              /*
1881:              *********************************************************************************************************
1882:              *                                        CHECK ALL TASK STACKS
1883:              *
1884:              * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
1885:              *
1886:              * Arguments  : none
1887:              *
1888:              * Returns    : none
1889:              *********************************************************************************************************
1890:              */
1891:              
1892:              #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
1893:              void  OS_TaskStatStkChk (void)
1894:              {
002B7C  FA000C     LNK #0xC
1895:                  OS_TCB      *ptcb;
1896:                  OS_STK_DATA  stk_data;
1897:                  INT8U        err;
1898:                  INT8U        prio;
1899:              
1900:              
1901:                  for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
002B7E  EB4000     CLR.B W0
002B80  784F00     MOV.B W0, [W14]
002B82  370025     BRA 0x2BCE
002BCC  E84F1E     INC.B [W14], [W14]
002BCE  78401E     MOV.B [W14], W0
002BD0  504FEA     SUB.B W0, #0xA, [W15]
002BD2  36FFD8     BRA LEU, 0x2B84
1902:                      err = OSTaskStkChk(prio, &stk_data);
002B84  470064     ADD W14, #0x4, W0
002B86  780080     MOV W0, W1
002B88  78401E     MOV.B [W14], W0
002B8A  071148     RCALL OSTaskStkChk
002B8C  984710     MOV.B W0, [W14+1]
1903:                      if (err == OS_ERR_NONE) {
002B8E  90401E     MOV.B [W14+1], W0
002B90  E00400     CP0.B W0
002B92  3A001C     BRA NZ, 0x2BCC
1904:                          ptcb = OSTCBPrioTbl[prio];
002B94  FB801E     ZE [W14], W0
002B96  400080     ADD W0, W0, W1
002B98  219000     MOV #0x1900, W0
002B9A  408000     ADD W1, W0, W0
002B9C  780090     MOV [W0], W1
002B9E  980711     MOV W1, [W14+2]
1905:                          if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
002BA0  90001E     MOV [W14+2], W0
002BA2  E00000     CP0 W0
002BA4  320013     BRA Z, 0x2BCC
1906:                              if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
002BA6  90001E     MOV [W14+2], W0
002BA8  500FE1     SUB W0, #0x1, [W15]
002BAA  320010     BRA Z, 0x2BCC
1907:              #if OS_TASK_PROFILE_EN > 0u
1908:                                  #if OS_STK_GROWTH == 1u
1909:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
1910:                                  #else
1911:                                  ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
002BAC  90001E     MOV [W14+2], W0
002BAE  900120     MOV [W0+4], W2
002BB0  90001E     MOV [W14+2], W0
002BB2  9000C0     MOV [W0+8], W1
002BB4  900030     MOV [W0+6], W0
002BB6  780000     MOV W0, W0
002BB8  400000     ADD W0, W0, W0
002BBA  EA0000     NEG W0, W0
002BBC  410080     ADD W2, W0, W1
002BBE  90001E     MOV [W14+2], W0
002BC0  981071     MOV W1, [W0+46]
1912:                                  #endif
1913:                                  ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
002BC2  90004E     MOV [W14+8], W0
002BC4  9000DE     MOV [W14+10], W1
002BC6  90011E     MOV [W14+2], W2
002BC8  981900     MOV W0, [W2+48]
002BCA  981911     MOV W1, [W2+50]
1914:              #endif
1915:                              }
1916:                          }
1917:                      }
1918:                  }
1919:              }
002BD4  FA8000     ULNK
002BD6  060000     RETURN
1920:              #endif
1921:              /*$PAGE*/
1922:              /*
1923:              *********************************************************************************************************
1924:              *                                           INITIALIZE TCB
1925:              *
1926:              * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
1927:              *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
1928:              *
1929:              * Arguments  : prio          is the priority of the task being created
1930:              *
1931:              *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
1932:              *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
1933:              *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
1934:              *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
1935:              *                            specific.
1936:              *
1937:              *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
1938:              *                            'OSTaskCreate()'.
1939:              *
1940:              *              id            is the task's ID (0..65535)
1941:              *
1942:              *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
1943:              *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
1944:              *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
1945:              *                            units are established by the #define constant OS_STK which is CPU
1946:              *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
1947:              *
1948:              *              pext          is a pointer to a user supplied memory area that is used to extend the task
1949:              *                            control block.  This allows you to store the contents of floating-point
1950:              *                            registers, MMU registers or anything else you could find useful during a
1951:              *                            context switch.  You can even assign a name to each task and store this name
1952:              *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
1953:              *
1954:              *              opt           options as passed to 'OSTaskCreateExt()' or,
1955:              *                            0 if called from 'OSTaskCreate()'.
1956:              *
1957:              * Returns    : OS_ERR_NONE              if the call was successful
1958:              *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task
1959:              *                                       cannot be created.
1960:              *
1961:              * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
1962:              *********************************************************************************************************
1963:              */
1964:              
1965:              INT8U  OS_TCBInit (INT8U    prio,
1966:                                 OS_STK  *ptos,
1967:                                 OS_STK  *pbos,
1968:                                 INT16U   id,
1969:                                 INT32U   stk_size,
1970:                                 void    *pext,
1971:                                 INT16U   opt)
1972:              {
002BD8  FA0016     LNK #0x16
002BDA  984760     MOV.B W0, [W14+6]
002BDC  980741     MOV W1, [W14+8]
002BDE  980752     MOV W2, [W14+10]
002BE0  980763     MOV W3, [W14+12]
002BE2  980774     MOV W4, [W14+14]
002BE4  980F05     MOV W5, [W14+16]
002BE6  980F16     MOV W6, [W14+18]
002BE8  980F27     MOV W7, [W14+20]
1973:                  OS_TCB    *ptcb;
1974:              #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
1975:                  OS_CPU_SR  cpu_sr = 0u;
002BEA  EB0000     CLR W0
002BEC  980710     MOV W0, [W14+2]
1976:              #endif
1977:              #if OS_TASK_REG_TBL_SIZE > 0u
1978:                  INT8U      i;
1979:              #endif
1980:              #if OS_TASK_CREATE_EXT_EN > 0u
1981:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
1982:                  INT8U      j;
1983:              #endif
1984:              #endif
1985:              
1986:              
1987:                  OS_ENTER_CRITICAL();
002BEE  800211     MOV SR, W1
002BF0  980711     MOV W1, [W14+2]
002BF2  800211     MOV SR, W1
002BF4  200E00     MOV #0xE0, W0
002BF6  700001     IOR W0, W1, W0
002BF8  880210     MOV W0, SR
1988:                  ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
002BFA  804372     MOV OSTCBFreeList, W2
002BFC  980722     MOV W2, [W14+4]
1989:                  if (ptcb != (OS_TCB *)0) {
002BFE  90002E     MOV [W14+4], W0
002C00  E00000     CP0 W0
002C02  3200BA     BRA Z, 0x2D78
1990:                      OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
002C04  90002E     MOV [W14+4], W0
002C06  900070     MOV [W0+14], W0
002C08  884370     MOV W0, OSTCBFreeList
1991:                      OS_EXIT_CRITICAL();
002C0A  90019E     MOV [W14+2], W3
002C0C  880213     MOV W3, SR
1992:                      ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
002C0E  90002E     MOV [W14+4], W0
002C10  9000CE     MOV [W14+8], W1
002C12  780801     MOV W1, [W0]
1993:                      ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
002C14  90002E     MOV [W14+4], W0
002C16  90416E     MOV.B [W14+6], W2
002C18  985842     MOV.B W2, [W0+28]
1994:                      ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
002C1A  90002E     MOV [W14+4], W0
002C1C  EB4080     CLR.B W1
002C1E  985821     MOV.B W1, [W0+26]
1995:                      ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
002C20  90002E     MOV [W14+4], W0
002C22  EB4080     CLR.B W1
002C24  985831     MOV.B W1, [W0+27]
1996:                      ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
002C26  90012E     MOV [W14+4], W2
002C28  B80060     MUL.UU W0, #0, W0
002C2A  980930     MOV W0, [W2+22]
002C2C  980941     MOV W1, [W2+24]
1997:              
1998:              #if OS_TASK_CREATE_EXT_EN > 0u
1999:                      ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
002C2E  90002E     MOV [W14+4], W0
002C30  90099E     MOV [W14+18], W3
002C32  980013     MOV W3, [W0+2]
2000:                      ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
002C34  90002E     MOV [W14+4], W0
002C36  90017E     MOV [W14+14], W2
002C38  90098E     MOV [W14+16], W3
002C3A  980032     MOV W2, [W0+6]
002C3C  980043     MOV W3, [W0+8]
2001:                      ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
002C3E  90002E     MOV [W14+4], W0
002C40  9001DE     MOV [W14+10], W3
002C42  980023     MOV W3, [W0+4]
2002:                      ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
002C44  90002E     MOV [W14+4], W0
002C46  9008AE     MOV [W14+20], W1
002C48  980051     MOV W1, [W0+10]
2003:                      ptcb->OSTCBId            = id;                     /* Store task ID                            */
002C4A  90002E     MOV [W14+4], W0
002C4C  90016E     MOV [W14+12], W2
002C4E  980062     MOV W2, [W0+12]
2004:              #else
2005:                      pext                     = pext;                   /* Prevent compiler warning if not used     */
2006:                      stk_size                 = stk_size;
2007:                      pbos                     = pbos;
2008:                      opt                      = opt;
2009:                      id                       = id;
2010:              #endif
2011:              
2012:              #if OS_TASK_DEL_EN > 0u
2013:                      ptcb->OSTCBDelReq        = OS_ERR_NONE;
002C50  90002E     MOV [W14+4], W0
002C52  EB4080     CLR.B W1
002C54  986011     MOV.B W1, [W0+33]
2014:              #endif
2015:              
2016:              #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
2017:                      ptcb->OSTCBY             = (INT8U)(prio >> 3u);
002C56  90406E     MOV.B [W14+6], W0
002C58  FB8000     ZE W0, W0
002C5A  DE0043     LSR W0, #3, W0
002C5C  784080     MOV.B W0, W1
002C5E  90002E     MOV [W14+4], W0
002C60  985861     MOV.B W1, [W0+30]
2018:                      ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
002C62  90406E     MOV.B [W14+6], W0
002C64  6040E7     AND.B W0, #0x7, W1
002C66  90002E     MOV [W14+4], W0
002C68  985851     MOV.B W1, [W0+29]
2019:              #else                                                             /* Pre-compute X, Y                  */
2020:                      ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
2021:                      ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
2022:              #endif
2023:                                                                                /* Pre-compute BitX and BitY         */
2024:                      ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
002C6A  90002E     MOV [W14+4], W0
002C6C  905860     MOV.B [W0+30], W0
002C6E  FB8100     ZE W0, W2
002C70  200010     MOV #0x1, W0
002C72  200001     MOV #0x0, W1
002C74  780182     MOV W2, W3
002C76  E90183     DEC W3, W3
002C78  330003     BRA N, 0x2C80
002C7A  400000     ADD W0, W0, W0
002C7C  488081     ADDC W1, W1, W1
002C7E  37FFFB     BRA 0x2C76
002C80  784080     MOV.B W0, W1
002C82  90002E     MOV [W14+4], W0
002C84  986001     MOV.B W1, [W0+32]
2025:                      ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
002C86  90002E     MOV [W14+4], W0
002C88  905850     MOV.B [W0+29], W0
002C8A  FB8100     ZE W0, W2
002C8C  200010     MOV #0x1, W0
002C8E  200001     MOV #0x0, W1
002C90  780182     MOV W2, W3
002C92  E90183     DEC W3, W3
002C94  330003     BRA N, 0x2C9C
002C96  400000     ADD W0, W0, W0
002C98  488081     ADDC W1, W1, W1
002C9A  37FFFB     BRA 0x2C92
002C9C  784080     MOV.B W0, W1
002C9E  90002E     MOV [W14+4], W0
002CA0  985871     MOV.B W1, [W0+31]
2026:              
2027:              #if (OS_EVENT_EN)
2028:                      ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
002CA2  90002E     MOV [W14+4], W0
002CA4  EB0080     CLR W1
002CA6  980811     MOV W1, [W0+18]
2029:              #if (OS_EVENT_MULTI_EN > 0u)
2030:                      ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
002CA8  90002E     MOV [W14+4], W0
002CAA  EB0080     CLR W1
002CAC  980821     MOV W1, [W0+20]
2031:              #endif
2032:              #endif
2033:              
2034:              #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
2035:                      ptcb->OSTCBFlagNode      = (OS_FLAG_NODE *)0;      /* Task is not pending on an event flag     */
2036:              #endif
2037:              
2038:              #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
2039:                      ptcb->OSTCBMsg           = (void *)0;              /* No message received                      */
2040:              #endif
2041:              
2042:              #if OS_TASK_PROFILE_EN > 0u
2043:                      ptcb->OSTCBCtxSwCtr      = 0uL;                    /* Initialize profiling variables           */
002CAE  90012E     MOV [W14+4], W2
002CB0  B80060     MUL.UU W0, #0, W0
002CB2  981110     MOV W0, [W2+34]
002CB4  981121     MOV W1, [W2+36]
2044:                      ptcb->OSTCBCyclesStart   = 0uL;
002CB6  90012E     MOV [W14+4], W2
002CB8  B80060     MUL.UU W0, #0, W0
002CBA  981150     MOV W0, [W2+42]
002CBC  981161     MOV W1, [W2+44]
2045:                      ptcb->OSTCBCyclesTot     = 0uL;
002CBE  90012E     MOV [W14+4], W2
002CC0  B80060     MUL.UU W0, #0, W0
002CC2  981130     MOV W0, [W2+38]
002CC4  981141     MOV W1, [W2+40]
2046:                      ptcb->OSTCBStkBase       = (OS_STK *)0;
002CC6  90002E     MOV [W14+4], W0
002CC8  EB0080     CLR W1
002CCA  981071     MOV W1, [W0+46]
2047:                      ptcb->OSTCBStkUsed       = 0uL;
002CCC  90012E     MOV [W14+4], W2
002CCE  B80060     MUL.UU W0, #0, W0
002CD0  981900     MOV W0, [W2+48]
002CD2  981911     MOV W1, [W2+50]
2048:              #endif
2049:              
2050:              #if OS_TASK_NAME_EN > 0u
2051:                      ptcb->OSTCBTaskName      = (INT8U *)(void *)"?";
002CD4  29CEC1     MOV #0x9CEC, W1
002CD6  90002E     MOV [W14+4], W0
002CD8  981821     MOV W1, [W0+52]
2052:              #endif
2053:              
2054:              #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
2055:                      for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
002CDA  EB4000     CLR.B W0
002CDC  784F00     MOV.B W0, [W14]
002CDE  370009     BRA 0x2CF2
002CF0  E84F1E     INC.B [W14], [W14]
002CF2  78401E     MOV.B [W14], W0
002CF4  E00400     CP0.B W0
002CF6  32FFF4     BRA Z, 0x2CE0
2056:                          ptcb->OSTCBRegTbl[i] = 0u;
002CE0  FB801E     ZE [W14], W0
002CE2  9000AE     MOV [W14+4], W1
002CE4  DD0042     SL W0, #2, W0
002CE6  408000     ADD W1, W0, W0
002CE8  200362     MOV #0x36, W2
002CEA  410100     ADD W2, W0, W2
002CEC  B80060     MUL.UU W0, #0, W0
002CEE  BE8900     MOV.D W0, [W2]
2057:                      }
2058:              #endif
2059:              
2060:                      OSTCBInitHook(ptcb);
002CF8  90002E     MOV [W14+4], W0
002CFA  07211A     RCALL OSTCBInitHook
2061:              
2062:                      OS_ENTER_CRITICAL();
002CFC  800211     MOV SR, W1
002CFE  980711     MOV W1, [W14+2]
002D00  800211     MOV SR, W1
002D02  200E00     MOV #0xE0, W0
002D04  700001     IOR W0, W1, W0
002D06  880210     MOV W0, SR
2063:                      OSTCBPrioTbl[prio] = ptcb;
002D08  90406E     MOV.B [W14+6], W0
002D0A  FB8000     ZE W0, W0
002D0C  400080     ADD W0, W0, W1
002D0E  219000     MOV #0x1900, W0
002D10  408000     ADD W1, W0, W0
002D12  90012E     MOV [W14+4], W2
002D14  780802     MOV W2, [W0]
2064:                      OS_EXIT_CRITICAL();
002D16  90019E     MOV [W14+2], W3
002D18  880213     MOV W3, SR
2065:              
2066:                      OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
002D1A  90002E     MOV [W14+4], W0
002D1C  0720F4     RCALL OSTaskCreateHook
2067:              
2068:              #if OS_TASK_CREATE_EXT_EN > 0u
2069:              #if defined(OS_TLS_TBL_SIZE) && (OS_TLS_TBL_SIZE > 0u)
2070:                      for (j = 0u; j < OS_TLS_TBL_SIZE; j++) {
2071:                          ptcb->OSTCBTLSTbl[j] = (OS_TLS)0;
2072:                      }
2073:                      OS_TLS_TaskCreate(ptcb);                           /* Call TLS hook                            */
2074:              #endif
2075:              #endif
2076:              
2077:                      OS_ENTER_CRITICAL();
002D1E  800211     MOV SR, W1
002D20  980711     MOV W1, [W14+2]
002D22  800211     MOV SR, W1
002D24  200E00     MOV #0xE0, W0
002D26  700001     IOR W0, W1, W0
002D28  880210     MOV W0, SR
2078:                      ptcb->OSTCBNext = OSTCBList;                       /* Link into TCB chain                      */
002D2A  804391     MOV OSTCBList, W1
002D2C  90002E     MOV [W14+4], W0
002D2E  980071     MOV W1, [W0+14]
2079:                      ptcb->OSTCBPrev = (OS_TCB *)0;         
002D30  90002E     MOV [W14+4], W0
002D32  EB0080     CLR W1
002D34  980801     MOV W1, [W0+16]
2080:                      if (OSTCBList != (OS_TCB *)0) {
002D36  804390     MOV OSTCBList, W0
002D38  E00000     CP0 W0
002D3A  320003     BRA Z, 0x2D42
2081:                          OSTCBList->OSTCBPrev = ptcb;
002D3C  804390     MOV OSTCBList, W0
002D3E  90012E     MOV [W14+4], W2
002D40  980802     MOV W2, [W0+16]
2082:                      }
2083:                      OSTCBList               = ptcb;
002D42  9001AE     MOV [W14+4], W3
002D44  884393     MOV W3, OSTCBList
2084:                      OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
002D46  90002E     MOV [W14+4], W0
002D48  906080     MOV.B [W0+32], W1
002D4A  BFC865     MOV.B OSRdyGrp, WREG
002D4C  70C000     IOR.B W1, W0, W0
002D4E  B7E865     MOV.B WREG, OSRdyGrp
2085:                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
002D50  90002E     MOV [W14+4], W0
002D52  905860     MOV.B [W0+30], W0
002D54  FB8000     ZE W0, W0
002D56  9000AE     MOV [W14+4], W1
002D58  9058E1     MOV.B [W1+30], W1
002D5A  FB8081     ZE W1, W1
002D5C  2187E2     MOV #0x187E, W2
002D5E  78C162     MOV.B [W2+W1], W2
002D60  9000AE     MOV [W14+4], W1
002D62  9058F1     MOV.B [W1+31], W1
002D64  714101     IOR.B W2, W1, W2
002D66  2187E1     MOV #0x187E, W1
002D68  787082     MOV.B W2, [W1+W0]
2086:                      OSTaskCtr++;                                       /* Increment the #tasks counter             */
002D6A  BFC867     MOV.B OSTaskCtr, WREG
002D6C  E84000     INC.B W0, W0
002D6E  B7E867     MOV.B WREG, OSTaskCtr
2087:                      OS_EXIT_CRITICAL();
002D70  90009E     MOV [W14+2], W1
002D72  880211     MOV W1, SR
2088:                      return (OS_ERR_NONE);
002D74  EB4000     CLR.B W0
002D76  370003     BRA 0x2D7E
2089:                  }
2090:                  OS_EXIT_CRITICAL();
002D78  90011E     MOV [W14+2], W2
002D7A  880212     MOV W2, SR
2091:                  return (OS_ERR_TASK_NO_MORE_TCB);
002D7C  B3C420     MOV.B #0x42, W0
2092:              }
002D7E  FA8000     ULNK
2093:              
2094:              
2095:              
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Ports/os_cpu_c.c  ------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                               uC/OS-II
4:                 *                                         The Real-Time Kernel
5:                 *
6:                 *                               (c) Copyright 2006, Micrium, Weston, FL
7:                 *                                          All Rights Reserved
8:                 *
9:                 *
10:                *                                          dsPIC33/PIC24 MPLab Port
11:                *
12:                *
13:                * File         : OS_CPU_C.C
14:                * By           : Eric Shufro
15:                * Port Version : V2.81 (and higher)
16:                *********************************************************************************************************
17:                */
18:                
19:                #include  "uCOS_II.H"
20:                
21:                /*
22:                *********************************************************************************************************
23:                *                                             LOCALS
24:                *********************************************************************************************************
25:                */
26:                
27:                #if OS_TMR_EN > 0
28:                static  INT16U  OSTmrCtr;
29:                #endif
30:                
31:                /*
32:                *********************************************************************************************************
33:                *                                       OS INITIALIZATION HOOK
34:                *                                            (BEGINNING)
35:                *
36:                * Description: This function is called by OSInit() at the beginning of OSInit().
37:                *
38:                * Arguments  : none
39:                *
40:                * Note(s)    : 1) Interrupts should be disabled during this call.
41:                *********************************************************************************************************
42:                */
43:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
44:                void  OSInitHookBegin (void)
45:                {
006EF6  FA0000     LNK #0x0
46:                #if OS_TMR_EN > 0
47:                    OSTmrCtr =      0;
48:                #endif
49:                
50:                    SPLIM    = 0xFFFE;                                                  /* Initialize the stack pointer limit register to a maximum */
006EF8  2FFFE0     MOV #0xFFFE, W0
006EFA  880100     MOV W0, SPLIM
51:                }                                                                       /* address thus effectively disabling stack checking        */
006EFC  FA8000     ULNK
006EFE  060000     RETURN
52:                #endif
53:                
54:                /*
55:                *********************************************************************************************************
56:                *                                       OS INITIALIZATION HOOK
57:                *                                               (END)
58:                *
59:                * Description: This function is called by OSInit() at the end of OSInit().
60:                *
61:                * Arguments  : none
62:                *
63:                * Note(s)    : 1) Interrupts should be disabled during this call.
64:                *********************************************************************************************************
65:                */
66:                #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
67:                void  OSInitHookEnd (void)
68:                {
006F00  FA0000     LNK #0x0
69:                #if OS_CPU_INT_DIS_MEAS_EN > 0
70:                    OS_CPU_IntDisMeasInit();
71:                #endif
72:                }
006F02  FA8000     ULNK
006F04  060000     RETURN
73:                #endif
74:                
75:                /*$PAGE*/
76:                /*
77:                *********************************************************************************************************
78:                *                                          TASK CREATION HOOK
79:                *
80:                * Description: This function is called when a task is created.
81:                *
82:                * Arguments  : ptcb   is a pointer to the task control block of the task being created.
83:                *
84:                * Note(s)    : 1) Interrupts are disabled during this call.
85:                *********************************************************************************************************
86:                */
87:                #if OS_CPU_HOOKS_EN > 0
88:                void  OSTaskCreateHook (OS_TCB *ptcb)
89:                {
006F06  FA0002     LNK #0x2
006F08  780F00     MOV W0, [W14]
90:                #if OS_APP_HOOKS_EN > 0
91:                    App_TaskCreateHook(ptcb);
92:                #else
93:                    (void)ptcb;                                                         /* Prevent compiler warning                                 */
94:                #endif
95:                }
006F0A  FA8000     ULNK
006F0C  060000     RETURN
96:                #endif
97:                
98:                /*
99:                *********************************************************************************************************
100:               *                                           TASK DELETION HOOK
101:               *
102:               * Description: This function is called when a task is deleted.
103:               *
104:               * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
105:               *
106:               * Note(s)    : 1) Interrupts are disabled during this call.
107:               *********************************************************************************************************
108:               */
109:               #if OS_CPU_HOOKS_EN > 0
110:               void  OSTaskDelHook (OS_TCB *ptcb)
111:               {
006F0E  FA0002     LNK #0x2
006F10  780F00     MOV W0, [W14]
112:               #if OS_APP_HOOKS_EN > 0
113:                   App_TaskDelHook(ptcb);
114:               #else
115:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
116:               #endif
117:               }
006F12  FA8000     ULNK
006F14  060000     RETURN
118:               #endif
119:               
120:               /*
121:               *********************************************************************************************************
122:               *                                             IDLE TASK HOOK
123:               *
124:               * Description: This function is called by the idle task.  This hook has been added to allow you to do
125:               *              such things as STOP the CPU to conserve power.
126:               *
127:               * Arguments  : none
128:               *
129:               * Note(s)    : 1) Interrupts are enabled during this call.
130:               *********************************************************************************************************
131:               */
132:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
133:               void  OSTaskIdleHook (void)
134:               {
006F16  FA0000     LNK #0x0
135:               #if OS_APP_HOOKS_EN > 0
136:                   App_TaskIdleHook();
137:               #endif
138:               }
006F18  FA8000     ULNK
006F1A  060000     RETURN
139:               #endif
140:               
141:               /*
142:               *********************************************************************************************************
143:               *                                            TASK RETURN HOOK
144:               *
145:               * Description: This function is called if a task accidentally returns.  In other words, a task should
146:               *              either be an infinite loop or delete itself when done.
147:               *
148:               * Arguments  : ptcb      is a pointer to the task control block of the task that is returning.
149:               *
150:               * Note(s)    : none
151:               *********************************************************************************************************
152:               */
153:               
154:               #if OS_CPU_HOOKS_EN > 0u
155:               void  OSTaskReturnHook (OS_TCB  *ptcb)
156:               {
006F1C  FA0002     LNK #0x2
006F1E  780F00     MOV W0, [W14]
157:               #if OS_APP_HOOKS_EN > 0u
158:                   App_TaskReturnHook(ptcb);
159:               #else
160:                   (void)ptcb;
161:               #endif
162:               }
006F20  FA8000     ULNK
006F22  060000     RETURN
163:               #endif
164:               /*
165:               *********************************************************************************************************
166:               *                                           STATISTIC TASK HOOK
167:               *
168:               * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
169:               *              application to add functionality to the statistics task.
170:               *
171:               * Arguments  : none
172:               *********************************************************************************************************
173:               */
174:               
175:               #if OS_CPU_HOOKS_EN > 0
176:               void  OSTaskStatHook (void)
177:               {
006F24  FA0000     LNK #0x0
178:               #if OS_APP_HOOKS_EN > 0
179:                   App_TaskStatHook();
180:               #endif
181:               }
006F26  FA8000     ULNK
006F28  060000     RETURN
182:               #endif
183:               
184:               /*$PAGE*/
185:               /*
186:               *********************************************************************************************************
187:               *                                           TASK SWITCH HOOK
188:               *
189:               * Description: This function is called when a task switch is performed.  This allows you to perform other
190:               *              operations during a context switch.
191:               *
192:               * Arguments  : none
193:               *
194:               * Note(s)    : 1) Interrupts are disabled during this call.
195:               *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
196:               *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
197:               *                 task being switched out (i.e. the preempted task).
198:               *********************************************************************************************************
199:               */
200:               #if OS_CPU_HOOKS_EN > 0
201:               void  OSTaskSwHook (void)
202:               {
006F2A  FA0000     LNK #0x0
203:               #if OS_APP_HOOKS_EN > 0
204:                   App_TaskSwHook();
205:               #endif
206:               }
006F2C  FA8000     ULNK
006F2E  060000     RETURN
207:               #endif
208:               
209:               /*
210:               *********************************************************************************************************
211:               *                                           OSTCBInit() HOOK
212:               *
213:               * Description: This function is called by OS_TCBInit() after setting up most of the TCB.
214:               *
215:               * Arguments  : ptcb    is a pointer to the TCB of the task being created.
216:               *
217:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
218:               *********************************************************************************************************
219:               */
220:               #if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
221:               void  OSTCBInitHook (OS_TCB *ptcb)
222:               {
006F30  FA0002     LNK #0x2
006F32  780F00     MOV W0, [W14]
223:               #if OS_APP_HOOKS_EN > 0
224:                   App_TCBInitHook(ptcb);
225:               #else
226:                   (void)ptcb;                                                         /* Prevent compiler warning                                 */
227:               #endif
228:               }
006F34  FA8000     ULNK
006F36  060000     RETURN
229:               #endif
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                               TICK HOOK
234:               *
235:               * Description: This function is called every tick.
236:               *
237:               * Arguments  : none
238:               *
239:               * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
240:               *********************************************************************************************************
241:               */
242:               #if (OS_CPU_HOOKS_EN > 0) && (OS_TIME_TICK_HOOK_EN > 0)
243:               void  OSTimeTickHook (void)
244:               {
245:               #if OS_APP_HOOKS_EN > 0
246:                   App_TimeTickHook();
247:               #endif
248:               
249:               #if OS_TMR_EN > 0
250:                   OSTmrCtr++;
251:                   if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
252:                       OSTmrCtr = 0;
253:                       OSTmrSignal();
254:                   }
255:               #endif
256:               }
257:               #endif
258:               
259:               /*
260:               *********************************************************************************************************
261:               *                             INTERRUPT DISABLE TIME MEASUREMENT, START
262:               *********************************************************************************************************
263:               */
264:               
265:               #if OS_CPU_INT_DIS_MEAS_EN > 0u
266:               void  OS_CPU_IntDisMeasInit (void)
267:               {
268:                   OS_CPU_IntDisMeasNestingCtr = 0u;
269:                   OS_CPU_IntDisMeasCntsEnter  = 0u;
270:                   OS_CPU_IntDisMeasCntsExit   = 0u;
271:                   OS_CPU_IntDisMeasCntsMax    = 0u;
272:                   OS_CPU_IntDisMeasCntsDelta  = 0u;
273:                   OS_CPU_IntDisMeasCntsOvrhd  = 0u;
274:                   OS_CPU_IntDisMeasStart();                              /* Measure the overhead of the functions    */
275:                   OS_CPU_IntDisMeasStop();
276:                   OS_CPU_IntDisMeasCntsOvrhd  = OS_CPU_IntDisMeasCntsDelta;
277:               }
278:               
279:               
280:               void  OS_CPU_IntDisMeasStart (void)
281:               {
282:                   OS_CPU_IntDisMeasNestingCtr++;
283:                   if (OS_CPU_IntDisMeasNestingCtr == 1u) {               /* Only measure at the first nested level   */
284:                       OS_CPU_IntDisMeasCntsEnter = OS_CPU_IntDisMeasTmrRd();
285:                   }
286:               }
287:               
288:               
289:               void  OS_CPU_IntDisMeasStop (void)
290:               {
291:                   OS_CPU_IntDisMeasNestingCtr--;                                      /* Decrement nesting ctr       */
292:                   if (OS_CPU_IntDisMeasNestingCtr == 0u) {
293:                       OS_CPU_IntDisMeasCntsExit  = OS_CPU_IntDisMeasTmrRd();
294:                       OS_CPU_IntDisMeasCntsDelta = OS_CPU_IntDisMeasCntsExit - OS_CPU_IntDisMeasCntsEnter;
295:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsOvrhd) {  /* Ensure overhead < delta     */
296:                           OS_CPU_IntDisMeasCntsDelta -= OS_CPU_IntDisMeasCntsOvrhd;
297:                       } else {
298:                           OS_CPU_IntDisMeasCntsDelta  = OS_CPU_IntDisMeasCntsOvrhd;
299:                       }
300:                       if (OS_CPU_IntDisMeasCntsDelta > OS_CPU_IntDisMeasCntsMax) {    /* Track MAXIMUM               */
301:                           OS_CPU_IntDisMeasCntsMax = OS_CPU_IntDisMeasCntsDelta;
302:                       }
303:                   }
304:               }
305:               #endif
306:               /*$PAGE*/
307:               /*
308:               *********************************************************************************************************
309:               *                                        INITIALIZE A TASK'S STACK
310:               *
311:               * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
312:               *              stack frame of the task being created.  This function is highly processor specific.
313:               *
314:               * Arguments  : task          is a pointer to the task code
315:               *
316:               *              p_arg         is a pointer to a user supplied data area that will be passed to the task
317:               *                            when the task first executes.
318:               *
319:               *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
320:               *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
321:               *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
322:               *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
323:               *                            of the stack.
324:               *
325:               *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
326:               *                            (see uCOS_II.H for OS_TASK_OPT_???).
327:               *
328:               * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
329:               *              been placed on the stack in the proper order.
330:               *
331:               * Note(s)    : 1) You may pass a task creation parameters through the opt variable. You MUST only use the
332:               *                 upper 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make
333:               *                 changes to the code below, you will need to ensure that it doesn't affect the behaviour
334:               *                 of OSTaskIdle() and OSTaskStat().
335:               *              2) Registers are initialized to make them easy to differentiate with a debugger.
336:               *
337:               *              3) Setup the stack frame of the task:
338:               *
339:               *                        ptos -  0  ->
340:               *                        ptos -  2  ->  CORCON
341:               *                        ptos -  4  ->  SR (initialized to 0)
342:               *                        ptos -  6  ->  DOENDH
343:               *                        ptos -  8  ->  DOENDL
344:               *                        ptos - 10  ->  DOSTARTH
345:               *                        ptos - 12  ->  DOSTARTL
346:               *                        ptos - 14  ->  DCOUNT
347:               *                        ptos - 16  ->  RCOUNT
348:               *                        ptos - 18  ->  PSVPAG
349:               *                        ptos - 20  ->  TBLPAG
350:               *                        ptos - 22  ->  ACCBU
351:               *                        ptos - 24  ->  ACCBH
352:               *                        ptos - 26  ->  ACCBL
353:               *                        ptos - 28  ->  ACCAU
354:               *                        ptos - 30  ->  ACCAH
355:               *                        ptos - 32  ->  ACCAL
356:               *                        ptos - 34  ->  W14
357:               *                        ptos - 36  ->  W13
358:               *                        ptos - 38  ->  W12
359:               *                        ptos - 40  ->  W11
360:               *                        ptos - 42  ->  W10
361:               *                        ptos - 44  ->  W9
362:               *                        ptos - 46  ->  W8
363:               *                        ptos - 48  ->  W7
364:               *                        ptos - 50  ->  W6
365:               *                        ptos - 52  ->  W5
366:               *                        ptos - 54  ->  W4
367:               *                        ptos - 56  ->  W3
368:               *                        ptos - 58  ->  W2
369:               *                        ptos - 60  ->  W1
370:               *                        ptos - 62  ->  p_arg
371:               *                        ptos - 64  ->   0 (15..8) | CORCON.7 | PC (22..16)      Simulate ISR
372:               *                        ptos - 66  ->  PC (15..0)
373:               *                        ptos - 68  ->  PC (22..16)                              Simulate function call
374:               *                        ptos - 70  ->  PC (15..0)
375:               *********************************************************************************************************
376:               */
377:               
378:               OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
379:               {
006F38  FA000C     LNK #0xC
006F3A  980720     MOV W0, [W14+4]
006F3C  980731     MOV W1, [W14+6]
006F3E  980742     MOV W2, [W14+8]
006F40  980753     MOV W3, [W14+10]
380:                   INT16U  x;
381:                   INT16U   pc_high;
382:               
383:               
384:               	pc_high =   0;                                                      /* Upper byte of PC always 0. Pointers are 16 bit unsigned  */
006F42  EB0000     CLR W0
006F44  980710     MOV W0, [W14+2]
385:               
386:                  *ptos++  =  (OS_STK)task;                                            /* Simulate a call to the task by putting 32 bits of data   */
006F46  9000AE     MOV [W14+4], W1
006F48  90004E     MOV [W14+8], W0
006F4A  780801     MOV W1, [W0]
006F4C  90004E     MOV [W14+8], W0
006F4E  E88000     INC2 W0, W0
006F50  980740     MOV W0, [W14+8]
387:                  *ptos++  =  (OS_STK)pc_high;                                         /* data on the stack.                                       */
006F52  90004E     MOV [W14+8], W0
006F54  90009E     MOV [W14+2], W1
006F56  780801     MOV W1, [W0]
006F58  90004E     MOV [W14+8], W0
006F5A  E88000     INC2 W0, W0
006F5C  980740     MOV W0, [W14+8]
388:               
389:                                                                                       /* Simulate an interrupt                                    */
390:                  *ptos++  =  (OS_STK)task;                                            /* Put the address of this task on the stack (PC)           */
006F5E  9000AE     MOV [W14+4], W1
006F60  90004E     MOV [W14+8], W0
006F62  780801     MOV W1, [W0]
006F64  90004E     MOV [W14+8], W0
006F66  E88000     INC2 W0, W0
006F68  980740     MOV W0, [W14+8]
391:               
392:                   x       =  0;                                                       /* Set the SR to enable ALL interrupts                      */
006F6A  EB0000     CLR W0
006F6C  780F00     MOV W0, [W14]
393:                   if (CORCONbits.IPL3) {                                              /* Check the CPU's current interrupt level 3 bit            */
006F6E  800220     MOV CORCON, W0
006F70  600068     AND W0, #0x8, W0
006F72  E00000     CP0 W0
006F74  320001     BRA Z, 0x6F78
394:                       x  |= 0x0080;                                                   /* If set, then save the priority level bit in x bit [7]    */
006F76  A0701E     BSET [W14], #7
395:                   }
396:                  *ptos++  = (OS_STK)(x | (INT16U)pc_high);                            /* Push the SR Low, CORCON IPL3 and PC (22..16)             */
006F78  90001E     MOV [W14+2], W0
006F7A  70009E     IOR W0, [W14], W1
006F7C  90004E     MOV [W14+8], W0
006F7E  780801     MOV W1, [W0]
006F80  90004E     MOV [W14+8], W0
006F82  E88000     INC2 W0, W0
006F84  980740     MOV W0, [W14+8]
397:               
398:                                                                                       /* Push all of the registers to stack                       */
399:                  *ptos++  = (OS_STK)p_arg;                                            /* Register W0 holds data passed to the task when started   */
006F86  9000BE     MOV [W14+6], W1
006F88  90004E     MOV [W14+8], W0
006F8A  780801     MOV W1, [W0]
006F8C  90004E     MOV [W14+8], W0
006F8E  E88000     INC2 W0, W0
006F90  980740     MOV W0, [W14+8]
400:                  *ptos++  = 0x1111;                                                   /* Initialize register W1                                   */
006F92  90004E     MOV [W14+8], W0
006F94  211111     MOV #0x1111, W1
006F96  780801     MOV W1, [W0]
006F98  90004E     MOV [W14+8], W0
006F9A  E88000     INC2 W0, W0
006F9C  980740     MOV W0, [W14+8]
401:                  *ptos++  = 0x2222;                                                   /* Initialize register W2                                   */
006F9E  90004E     MOV [W14+8], W0
006FA0  222221     MOV #0x2222, W1
006FA2  780801     MOV W1, [W0]
006FA4  90004E     MOV [W14+8], W0
006FA6  E88000     INC2 W0, W0
006FA8  980740     MOV W0, [W14+8]
402:                  *ptos++  = 0x3333;                                                   /* Initialize register W3                                   */
006FAA  90004E     MOV [W14+8], W0
006FAC  233331     MOV #0x3333, W1
006FAE  780801     MOV W1, [W0]
006FB0  90004E     MOV [W14+8], W0
006FB2  E88000     INC2 W0, W0
006FB4  980740     MOV W0, [W14+8]
403:                  *ptos++  = 0x4444;                                                   /* Initialize register W4                                   */
006FB6  90004E     MOV [W14+8], W0
006FB8  244441     MOV #0x4444, W1
006FBA  780801     MOV W1, [W0]
006FBC  90004E     MOV [W14+8], W0
006FBE  E88000     INC2 W0, W0
006FC0  980740     MOV W0, [W14+8]
404:                  *ptos++  = 0x5555;                                                   /* Initialize register W5                                   */
006FC2  90004E     MOV [W14+8], W0
006FC4  255551     MOV #0x5555, W1
006FC6  780801     MOV W1, [W0]
006FC8  90004E     MOV [W14+8], W0
006FCA  E88000     INC2 W0, W0
006FCC  980740     MOV W0, [W14+8]
405:                  *ptos++  = 0x6666;                                                   /* Initialize register W6                                   */
006FCE  90004E     MOV [W14+8], W0
006FD0  266661     MOV #0x6666, W1
006FD2  780801     MOV W1, [W0]
006FD4  90004E     MOV [W14+8], W0
006FD6  E88000     INC2 W0, W0
006FD8  980740     MOV W0, [W14+8]
406:                  *ptos++  = 0x7777;                                                   /* Initialize register W7                                   */
006FDA  90004E     MOV [W14+8], W0
006FDC  277771     MOV #0x7777, W1
006FDE  780801     MOV W1, [W0]
006FE0  90004E     MOV [W14+8], W0
006FE2  E88000     INC2 W0, W0
006FE4  980740     MOV W0, [W14+8]
407:                  *ptos++  = 0x8888;                                                   /* Initialize register W8                                   */
006FE6  90004E     MOV [W14+8], W0
006FE8  288881     MOV #0x8888, W1
006FEA  780801     MOV W1, [W0]
006FEC  90004E     MOV [W14+8], W0
006FEE  E88000     INC2 W0, W0
006FF0  980740     MOV W0, [W14+8]
408:                  *ptos++  = 0x9999;                                                   /* Initialize register W9                                   */
006FF2  90004E     MOV [W14+8], W0
006FF4  299991     MOV #0x9999, W1
006FF6  780801     MOV W1, [W0]
006FF8  90004E     MOV [W14+8], W0
006FFA  E88000     INC2 W0, W0
006FFC  980740     MOV W0, [W14+8]
409:                  *ptos++  = 0xAAAA;                                                   /* Initialize register W10                                  */
006FFE  90004E     MOV [W14+8], W0
007000  2AAAA1     MOV #0xAAAA, W1
007002  780801     MOV W1, [W0]
007004  90004E     MOV [W14+8], W0
007006  E88000     INC2 W0, W0
007008  980740     MOV W0, [W14+8]
410:                  *ptos++  = 0xBBBB;                                                   /* Initialize register W11                                  */
00700A  90004E     MOV [W14+8], W0
00700C  2BBBB1     MOV #0xBBBB, W1
00700E  780801     MOV W1, [W0]
007010  90004E     MOV [W14+8], W0
007012  E88000     INC2 W0, W0
007014  980740     MOV W0, [W14+8]
411:                  *ptos++  = 0xCCCC;                                                   /* Initialize register W12                                  */
007016  90004E     MOV [W14+8], W0
007018  2CCCC1     MOV #0xCCCC, W1
00701A  780801     MOV W1, [W0]
00701C  90004E     MOV [W14+8], W0
00701E  E88000     INC2 W0, W0
007020  980740     MOV W0, [W14+8]
412:                  *ptos++  = 0xDDDD;                                                   /* Initialize register W13                                  */
007022  90004E     MOV [W14+8], W0
007024  2DDDD1     MOV #0xDDDD, W1
007026  780801     MOV W1, [W0]
007028  90004E     MOV [W14+8], W0
00702A  E88000     INC2 W0, W0
00702C  980740     MOV W0, [W14+8]
413:                  *ptos++  = 0xEEEE;                                                   /* Initialize register W14                                  */
00702E  90004E     MOV [W14+8], W0
007030  2EEEE1     MOV #0xEEEE, W1
007032  780801     MOV W1, [W0]
007034  90004E     MOV [W14+8], W0
007036  E88000     INC2 W0, W0
007038  980740     MOV W0, [W14+8]
414:               
415:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
416:                  *ptos++  = ACCAL;                                                    /* Push Accumulator A onto the stack                        */
417:                  *ptos++  = ACCAH;                                                    /* Push Accumulator A onto the stack                        */
418:                  *ptos++  = ACCAU;                                                    /* Push Accumulator A onto the stack                        */
419:                  *ptos++  = ACCBL;                                                    /* Push Accumulator B onto the stack                        */
420:                  *ptos++  = ACCBH;                                                    /* Push Accumulator B onto the stack                        */
421:                  *ptos++  = ACCBU;                                                    /* Push Accumulator B onto the stack                        */
422:               #endif
423:                  *ptos++  = TBLPAG;                                                   /* Push the Data Table Page Address onto the stack          */
00703A  8002A1     MOV TBLPAG, W1
00703C  90004E     MOV [W14+8], W0
00703E  780801     MOV W1, [W0]
007040  90004E     MOV [W14+8], W0
007042  E88000     INC2 W0, W0
007044  980740     MOV W0, [W14+8]
424:               #if defined(__dsPIC33E__)
425:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
426:                  *ptos++  = DSWPAG;
427:               #elif defined (__dsPIC33F__) || defined(__PIC24F__)
428:                  *ptos++  = DSRPAG;                                                   /* Push the Program Space Visability Register on the stack  */
007046  800191     MOV DSRPAG, W1
007048  90004E     MOV [W14+8], W0
00704A  780801     MOV W1, [W0]
00704C  90004E     MOV [W14+8], W0
00704E  E88000     INC2 W0, W0
007050  980740     MOV W0, [W14+8]
429:                  *ptos++  = DSWPAG;
007052  8001A1     MOV DSWPAG, W1
007054  90004E     MOV [W14+8], W0
007056  780801     MOV W1, [W0]
007058  90004E     MOV [W14+8], W0
00705A  E88000     INC2 W0, W0
00705C  980740     MOV W0, [W14+8]
430:               //   *ptos++  = PSVPAG;
431:               #endif
432:                  *ptos++  = RCOUNT;                                                   /* Push the Repeat Loop Counter Register onto the stack     */
00705E  8001B1     MOV RCOUNT, W1
007060  90004E     MOV [W14+8], W0
007062  780801     MOV W1, [W0]
007064  90004E     MOV [W14+8], W0
007066  E88000     INC2 W0, W0
007068  980740     MOV W0, [W14+8]
433:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
434:                  *ptos++  = DCOUNT;                                                   /* Push the Do Loop     Counter Register onto the stack     */
435:                  *ptos++  = DOSTARTL;                                                 /* Push the Do Loop Start Address Register onto the stack   */
436:                  *ptos++  = DOSTARTH;                                                 /* Push the Do Loop Start Address Register onto the stack   */
437:                  *ptos++  = DOENDL;                                                   /* Push the Do Loop End   Address Register onto the stack   */
438:                  *ptos++  = DOENDH;                                                   /* Push the Do Loop End   Address Register onto the stack   */
439:               #endif
440:                  *ptos++  = 0;                                                        /* Force the SR to enable all interrupt, clear flags        */
00706A  90004E     MOV [W14+8], W0
00706C  EB0080     CLR W1
00706E  780801     MOV W1, [W0]
007070  90004E     MOV [W14+8], W0
007072  E88000     INC2 W0, W0
007074  980740     MOV W0, [W14+8]
441:                  *ptos++  = CORCON;                                                   /* Push the Core Control Register on to the stack           */
007076  800221     MOV CORCON, W1
007078  90004E     MOV [W14+8], W0
00707A  780801     MOV W1, [W0]
00707C  90004E     MOV [W14+8], W0
00707E  E88000     INC2 W0, W0
007080  980740     MOV W0, [W14+8]
442:               
443:                   return (ptos);                                                      /* Return the stack pointer to the new tasks stack          */
007082  90004E     MOV [W14+8], W0
444:               }
007084  FA8000     ULNK
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uCOS-II/Ports/os_cpu_a.s  ------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                                (c) Copyright 2006, Micrium, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                          dsPIC33/PIC24 MPLab Port
                                                  11:    ;                                                 
                                                  12:    ;
                                                  13:    ; File         : os_cpu_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ; Port Version : V2.81 (and higher)
                                                  16:    ;********************************************************************************************************
                                                  17:    ;
                                                  18:    
                                                  19:    ;
                                                  20:    ;********************************************************************************************************
                                                  21:    ;                                                CONSTANTS
                                                  22:    ;********************************************************************************************************
                                                  23:    ;
                                                  24:     
                                                  25:    ;
                                                  26:    ;********************************************************************************************************
                                                  27:    ;                                                INCLUDES
                                                  28:    ;********************************************************************************************************
                                                  29:    ;
                                                  30:    
                                                  31:    .include "xc.inc"
                                                  32:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  33:    
                                                  34:    ;
                                                  35:    ;********************************************************************************************************
                                                  36:    ;                                             LINKER SPECIFICS
                                                  37:    ;********************************************************************************************************
                                                  38:    ;
                                                  39:    
                                                  40:        .text                                         ; Locate this file in the text region of the build
                                                  41:    
                                                  42:    ;
                                                  43:    ;********************************************************************************************************
                                                  44:    ;                                                 GLOBALS
                                                  45:    ;********************************************************************************************************
                                                  46:    ;
                                                  47:    
                                                  48:        .global  _OSStartHighRdy
                                                  49:        .global  _OSCtxSw
                                                  50:        .global  _OSIntCtxSw
                                                  51:    
                                                  52:    ;
                                                  53:    ;********************************************************************************************************
                                                  54:    ;                                            OSStartHighRdy
                                                  55:    ;
                                                  56:    ; Description : This function determines the highest priority task that is ready to run after
                                                  57:    ;               OSInit() is called.
                                                  58:    ;********************************************************************************************************
                                                  59:    ;
                                                  60:    
                                                  61:    _OSStartHighRdy:
007930  026F2A     CALL 0x6F2A                    62:        call   _OSTaskSwHook                          ; Call user defined task switch hook
                                                  63:    
007934  200010     MOV #0x1, W0                   64:        mov    #0x0001, w0                            ; Set OSRunning to TRUE
007936  208661     MOV #0x866, W1                 65:        mov    #_OSRunning, w1
007938  784880     MOV.B W0, [W1]                 66:        mov.b  w0, [w1]                               ; Set OSRunning to TRUE
                                                  67:    
                                                  68:                                                      ; Get stack pointer of the task to resume
00793A  804380     MOV 0x870, W0                  69:        mov    _OSTCBHighRdy, w0                      ; Get the pointer to the stack to resume
00793C  780790     MOV [W0], W15                  70:        mov    [w0], w15                              ; Dereference the pointer and store the data (the new stack address) W15, the stack pointer register
                                                  71:    
00793E  F90044     POP CORCON                     72:        OS_REGS_RESTORE                               ; Restore all of this tasks registers from the stack
                                                  73:        
00795A  064000     RETFIE                         74:        retfie                                        ; Return from the interrupt, the task is now ready to run
                                                  75:    
                                                  76:    ;
                                                  77:    ;********************************************************************************************************
                                                  78:    ;                                            OSCtxSw
                                                  79:    ;
                                                  80:    ; Description : TThe code to perform a 'task level' context switch.  OSCtxSw() is called 
                                                  81:    ;               when a higher priority task is made ready to run by another task or, 
                                                  82:    ;               when the current task can no longer execute (e.g. it calls OSTimeDly(), 
                                                  83:    ;               OSSemPend() and the semaphore is not available, etc.). 
                                                  84:    ;********************************************************************************************************
                                                  85:    ;
                                                  86:        
                                                  87:    _OSCtxSw:
                                                  88:                                                      ; TRAP (interrupt) should bring us here, not 'call'.
                                                  89:                                                      ; Since dsPIC has no TRAP, it is necessary to correct the stack to simulate an interrupt
                                                  90:                                                      ; In other words, this function must also save SR and IPL3 to the stack, not just the PC.
                                                  91:    
00795C  BFC042     MOV.B SR, WREG                 92:        mov.b  SRL, wreg                              ; Load SRL
00795E  DD0048     SL W0, #8, W0                  93:        sl w0, #8, w0                                 ; Shift left by 8
007960  AF6044     BTSC CORCON, #3                94:        btsc   CORCON, #IPL3                          ; Test IPL3 bit, skip if clear
007962  A07000     BSET W0, #7                    95:        bset   w0, #7;                                ; Copy IPL3 to bit7 of w0
                                                  96:        
007964  70004F     IOR W0, [--W15], W0            97:        ior    w0, [--w15], w0                        ; Merge bits
007966  781F80     MOV W0, [W15++]                98:        mov    w0, [w15++]                            ; Write back
                                                  99:    
007968  BE9F80     MOV.D W0, [W15++]              100:       OS_REGS_SAVE                                  ; Save processor registers
                                                  101:   
                                                  102:                                                     ; Save current task's stack pointer into the currect tasks TCB
007984  804360     MOV 0x86C, W0                  103:       mov    _OSTCBCur, w0                          ; Get the address of the location in this tasks TCB to store the stack pointer
007986  78080F     MOV W15, [W0]                  104:       mov    w15, [w0]                              ; Store the stack pointer in this tasks TCB        
                                                  105:   
007988  026F2A     CALL 0x6F2A                    106:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  107:   
00798C  804381     MOV 0x870, W1                  108:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
00798E  884361     MOV W1, 0x86C                  109:       mov    w1, _OSTCBCur
007990  208640     MOV #0x864, W0                 110:       mov    #_OSPrioHighRdy, w0
007992  208632     MOV #0x863, W2                 111:       mov    #_OSPrioCur, w2
007994  784910     MOV.B [W0], [W2]               112:       mov.b  [w0], [w2]
                                                  113:           
007996  780791     MOV [W1], W15                  114:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  115:   
007998  F90044     POP CORCON                     116:       OS_REGS_RESTORE                               ; Restore registers
                                                  117:       
0079B4  064000     RETFIE                         118:       retfie                                        ; Return from interrupt
                                                  119:   
                                                  120:   ;
                                                  121:   ;********************************************************************************************************
                                                  122:   ;                                            OSIntCtxSw
                                                  123:   ;
                                                  124:   ; Description : When an ISR (Interrupt Service Routine) completes, OSIntExit() is called to 
                                                  125:   ;               determine whether a more important task than the interrupted task needs to 
                                                  126:   ;               execute.  If that's the case, OSIntExit() determines which task to run next 
                                                  127:   ;               and calls OSIntCtxSw() to perform the actual context switch to that task.  
                                                  128:   ;********************************************************************************************************
                                                  129:   ;
                                                  130:   
                                                  131:   _OSIntCtxSw:
0079B6  026F2A     CALL 0x6F2A                    132:       call   _OSTaskSwHook                          ; Call the user defined task switch hook
                                                  133:   
0079BA  804381     MOV 0x870, W1                  134:       mov    _OSTCBHighRdy, w1                      ; Set the current running TCB to the TCB of the highest priority task ready to run
0079BC  884361     MOV W1, 0x86C                  135:       mov    w1, _OSTCBCur
0079BE  208640     MOV #0x864, W0                 136:       mov    #_OSPrioHighRdy, w0
0079C0  208632     MOV #0x863, W2                 137:       mov    #_OSPrioCur, w2
0079C2  784910     MOV.B [W0], [W2]               138:       mov.b  [w0], [w2]
                                                  139:           
0079C4  780791     MOV [W1], W15                  140:       mov    [w1], w15                              ; Load W15 with the stack pointer from the task that is ready to run
                                                  141:   
0079C6  F90044     POP CORCON                     142:       OS_REGS_RESTORE                               ; Restore registers
                                                  143:       
0079E2  064000     RETFIE                         144:       retfie                                        ; Return from interrupt
                                                  145:   
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uC-LIB/lib_str.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                       ASCII STRING MANAGEMENT
29:                *
30:                * Filename      : lib_str.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 BAN
34:                *                 JDH
35:                *********************************************************************************************************
36:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
37:                *
38:                *                     (a) ALL standard library functions are implemented in the custom library modules :
39:                *
40:                *                         (1) \<Custom Library Directory>\lib_*.*
41:                *
42:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
43:                *
44:                *                               where
45:                *                                       <Custom Library Directory>      directory path for custom library software
46:                *                                       <cpu>                           directory name for specific processor (CPU)
47:                *                                       <compiler>                      directory name for specific compiler
48:                *
49:                *                     (b) Product-specific library functions are implemented in individual products.
50:                *
51:                *********************************************************************************************************
52:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
53:                *                     us permission to reprint portions of their documentation.  Portions of this text are
54:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
55:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
56:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
57:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
58:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
59:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
60:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
61:                *********************************************************************************************************
62:                */
63:                
64:                
65:                /*
66:                *********************************************************************************************************
67:                *                                            INCLUDE FILES
68:                *********************************************************************************************************
69:                */
70:                
71:                #define    MICRIUM_SOURCE
72:                #define    LIB_STR_MODULE
73:                #include  <lib_str.h>
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                            LOCAL DEFINES
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                           LOCAL CONSTANTS
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                          LOCAL DATA TYPES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                            LOCAL TABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
104:                  (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
105:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
106:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
107:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
108:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
109:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
110:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
111:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
112:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
113:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
114:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
115:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
116:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
117:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
118:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
119:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
120:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
121:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
122:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
123:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
124:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
125:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
126:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
127:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
128:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
129:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
130:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
131:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
132:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
133:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
134:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
135:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
136:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
137:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
138:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
139:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
140:                  (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
141:               };
142:               
143:               
144:               /*
145:               *********************************************************************************************************
146:               *                                       LOCAL GLOBAL VARIABLES
147:               *********************************************************************************************************
148:               */
149:               
150:               
151:               /*
152:               *********************************************************************************************************
153:               *                                      LOCAL FUNCTION PROTOTYPES
154:               *********************************************************************************************************
155:               */
156:               
157:               static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
158:                                                              CPU_INT08U     nbr_dig,
159:                                                              CPU_INT08U     nbr_base,
160:                                                              CPU_BOOLEAN    nbr_neg,
161:                                                              CPU_CHAR       lead_char,
162:                                                              CPU_BOOLEAN    lower_case,
163:                                                              CPU_BOOLEAN    nul,
164:                                                              CPU_CHAR      *pstr);
165:               
166:               static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
167:                                                              CPU_CHAR     **pstr_next,
168:                                                              CPU_INT08U     nbr_base,
169:                                                              CPU_BOOLEAN    nbr_signed,
170:                                                              CPU_BOOLEAN   *pnbr_neg);
171:               
172:               
173:               /*
174:               *********************************************************************************************************
175:               *                                     LOCAL CONFIGURATION ERRORS
176:               *********************************************************************************************************
177:               */
178:               
179:               
180:               /*
181:               *********************************************************************************************************
182:               *                                              Str_Len()
183:               *
184:               * Description : Calculate length of a string.
185:               *
186:               * Argument(s) : pstr        Pointer to string (see Note #1).
187:               *
188:               * Return(s)   : Length of string; number of characters in string before terminating NULL character
189:               *                   (see Note #2b1).
190:               *
191:               * Caller(s)   : Application.
192:               *
193:               * Note(s)     : (1) String buffer NOT modified.
194:               *
195:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
196:               *
197:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
198:               *                            which 's' ('pstr') points," ...
199:               *                       (2) "not including the terminating null byte."
200:               *
201:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
202:               *
203:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
204:               *                       (2) "no return value shall be reserved to indicate an error."
205:               *
206:               *               (3) String length calculation terminates when :
207:               *
208:               *                   (a) String pointer points to NULL.
209:               *                       (1) String buffer overlaps with NULL address.
210:               *                       (2) String length calculated for string up to but NOT beyond or including
211:               *                           the NULL address.
212:               *
213:               *                   (b) Terminating NULL character found.
214:               *                       (1) String length calculated for string up to but NOT           including
215:               *                           the NULL character (see Note #2a2).
216:               *********************************************************************************************************
217:               */
218:               
219:               CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
220:               {
003A30  FA0004     LNK #0x4
003A32  980710     MOV W0, [W14+2]
221:                   CPU_SIZE_T  len;
222:               
223:               
224:                   len = Str_Len_N(pstr,
003A34  EB8080     SETM W1
003A36  90001E     MOV [W14+2], W0
003A38  070004     RCALL Str_Len_N
003A3A  780F00     MOV W0, [W14]
225:                                   DEF_INT_CPU_U_MAX_VAL);
226:               
227:                   return (len);
003A3C  78001E     MOV [W14], W0
228:               }
003A3E  FA8000     ULNK
003A40  060000     RETURN
229:               
230:               
231:               /*
232:               *********************************************************************************************************
233:               *                                             Str_Len_N()
234:               *
235:               * Description : Calculate length of a string, up to a maximum number of characters.
236:               *
237:               * Argument(s) : pstr        Pointer to string (see Note #1).
238:               *
239:               *               len_max     Maximum number of characters to search (see Note #3c).
240:               *
241:               * Return(s)   : Length of string; number of characters in string before terminating NULL character,
242:               *                   if terminating NULL character     found (see Note #2b1).
243:               *
244:               *               Requested maximum number of characters to search,
245:               *                   if terminating NULL character NOT found (see Note #3c).
246:               *
247:               * Caller(s)   : Application.
248:               *
249:               * Note(s)     : (1) String buffer NOT modified.
250:               *
251:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
252:               *
253:               *                       (1) "The strlen() function shall compute the number of bytes in the string to
254:               *                            which 's' ('pstr') points," ...
255:               *                       (2) "not including the terminating null byte."
256:               *
257:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
258:               *
259:               *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
260:               *                       (2) "no return value shall be reserved to indicate an error."
261:               *
262:               *               (3) String length calculation terminates when :
263:               *
264:               *                   (a) String pointer points to NULL.
265:               *                       (1) String buffer overlaps with NULL address.
266:               *                       (2) String length calculated for string up to but NOT beyond or including
267:               *                           the NULL address.
268:               *
269:               *                   (b) Terminating NULL character found.
270:               *                       (1) String length calculated for string up to but NOT           including
271:               *                           the NULL character (see Note #2a2).
272:               *
273:               *                   (c) 'len_max' number of characters searched.
274:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
275:               *********************************************************************************************************
276:               */
277:               
278:               CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
279:                                             CPU_SIZE_T   len_max)
280:               {
003A42  FA0008     LNK #0x8
003A44  980720     MOV W0, [W14+4]
003A46  980731     MOV W1, [W14+6]
281:                   const  CPU_CHAR    *pstr_len;
282:                          CPU_SIZE_T   len;
283:               
284:               
285:                   pstr_len = pstr;
003A48  9000AE     MOV [W14+4], W1
003A4A  780F01     MOV W1, [W14]
286:                   len      = 0u;
003A4C  EB0000     CLR W0
003A4E  980710     MOV W0, [W14+2]
287:                   while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
003A50  370004     BRA 0x3A5A
003A5A  78001E     MOV [W14], W0
003A5C  E00000     CP0 W0
003A5E  320008     BRA Z, 0x3A70
003A64  E00400     CP0.B W0
003A66  320004     BRA Z, 0x3A70
288:                          (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
003A60  78001E     MOV [W14], W0
003A62  784010     MOV.B [W0], W0
003A68  90009E     MOV [W14+2], W1
003A6A  90003E     MOV [W14+6], W0
003A6C  508F80     SUB W1, W0, [W15]
003A6E  39FFF1     BRA NC, 0x3A52
289:                          ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
290:                       pstr_len++;
003A52  E80F1E     INC [W14], [W14]
291:                       len++;
003A54  90001E     MOV [W14+2], W0
003A56  E80000     INC W0, W0
003A58  980710     MOV W0, [W14+2]
292:                   }
293:               
294:                   return (len);                                               /* Rtn str len (see Note #3b1).                         */
003A70  90001E     MOV [W14+2], W0
295:               }
003A72  FA8000     ULNK
003A74  060000     RETURN
296:               
297:               
298:               /*
299:               *********************************************************************************************************
300:               *                                             Str_Copy()
301:               *
302:               * Description : Copy source string to destination string buffer.
303:               *
304:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
305:               *
306:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
307:               *
308:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
309:               *
310:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
311:               *
312:               * Caller(s)   : Application.
313:               *
314:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
315:               *
316:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
317:               *                           string size including the terminating NULL character.
318:               *
319:               *                   (b) Source buffer NOT modified.
320:               *
321:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
322:               *
323:               *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src')
324:               *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
325:               *                       (2) "(including the terminating null byte)."
326:               *
327:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
328:               *
329:               *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
330:               *                       (2) "no return value is reserved to indicate an error."
331:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
332:               *                               NULL for any error(s).
333:               *
334:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
335:               *                       copying takes place between objects that overlap, the behavior is undefined".
336:               *
337:               *               (3) String copy terminates when :
338:               *
339:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
340:               *                       (1) No string copy performed; NULL pointer returned.
341:               *
342:               *                   (b) Destination/Source string pointer(s) point to NULL.
343:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
344:               *
345:               *                   (c) Source string's terminating NULL character found.
346:               *                       (1) Entire source string copied into destination string buffer (see Note #2a).
347:               *********************************************************************************************************
348:               */
349:               
350:               CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
351:                                    const  CPU_CHAR  *pstr_src)
352:               {
003A76  FA0006     LNK #0x6
003A78  980710     MOV W0, [W14+2]
003A7A  980721     MOV W1, [W14+4]
353:                   CPU_CHAR  *pstr_rtn;
354:               
355:               
356:                   pstr_rtn = Str_Copy_N(pstr_dest,
003A7C  EB8100     SETM W2
003A7E  9000AE     MOV [W14+4], W1
003A80  90001E     MOV [W14+2], W0
003A82  070004     RCALL Str_Copy_N
003A84  780F00     MOV W0, [W14]
357:                                         pstr_src,
358:                                         DEF_INT_CPU_U_MAX_VAL);
359:               
360:                   return (pstr_rtn);
003A86  78001E     MOV [W14], W0
361:               }
003A88  FA8000     ULNK
003A8A  060000     RETURN
362:               
363:               
364:               /*
365:               *********************************************************************************************************
366:               *                                            Str_Copy_N()
367:               *
368:               * Description : Copy source string to destination string buffer, up to a maximum number of characters.
369:               *
370:               * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
371:               *
372:               *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
373:               *
374:               *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
375:               *
376:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
377:               *
378:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
379:               *
380:               * Caller(s)   : Application.
381:               *
382:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
383:               *
384:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
385:               *                           string size including the terminating NULL character.
386:               *
387:               *                   (b) Source string buffer NOT modified.
388:               *
389:               *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
390:               *
391:               *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2'
392:               *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
393:               *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
394:               *                           (C)  &   "(bytes that follow a null byte are not copied)".
395:               *
396:               *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that
397:               *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter
398:               *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in
399:               *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes
400:               *                               in all are written."
401:               *
402:               *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy
403:               *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters,
404:               *                                   this requirement is intentionally NOT implemented to avoid appending
405:               *                                   a potentially large number of unnecessary terminating NULL characters.
406:               *
407:               *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also
408:               *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of
409:               *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
410:               *
411:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
412:               *
413:               *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
414:               *                       (2) "no return value is reserved to indicate an error."
415:               *                           (A) #### This requirement is intentionally ignored in order to return NULL
416:               *                               for any error(s).
417:               *
418:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
419:               *                       copying takes place between objects that overlap, the behavior is undefined".
420:               *
421:               *               (3) String copy terminates when :
422:               *
423:               *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
424:               *                       (1) No string copy performed; NULL pointer returned.
425:               *
426:               *                   (b) Destination/Source string pointer(s) point to NULL.
427:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
428:               *
429:               *                   (c) Source string's terminating NULL character found.
430:               *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
431:               *
432:               *                   (d) 'len_max' number of characters copied.
433:               *                       (1) 'len_max' number of characters MAY include the terminating NULL character
434:               *                           (see Note #2a1C).
435:               *                       (2) Null copies allowed (i.e. zero-length copies).
436:               *                           (A) No string copy performed; destination string returned  (see Note #2b1).
437:               *********************************************************************************************************
438:               */
439:               
440:               CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
441:                                      const  CPU_CHAR    *pstr_src,
442:                                             CPU_SIZE_T   len_max)
443:               {
003A8C  FA000C     LNK #0xC
003A8E  980730     MOV W0, [W14+6]
003A90  980741     MOV W1, [W14+8]
003A92  980752     MOV W2, [W14+10]
444:                          CPU_CHAR    *pstr_copy_dest;
445:                   const  CPU_CHAR    *pstr_copy_src;
446:                          CPU_SIZE_T   len_copy;
447:               
448:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
449:                   if (pstr_dest == (CPU_CHAR *)0) {
003A94  90003E     MOV [W14+6], W0
003A96  E00000     CP0 W0
003A98  3A0002     BRA NZ, 0x3A9E
450:                       return ((CPU_CHAR *)0);
003A9A  EB0000     CLR W0
003A9C  370035     BRA 0x3B08
451:                   }
452:                   if (pstr_src  == (const CPU_CHAR *)0) {
003A9E  90004E     MOV [W14+8], W0
003AA0  E00000     CP0 W0
003AA2  3A0002     BRA NZ, 0x3AA8
453:                       return ((CPU_CHAR *)0);
003AA4  EB0000     CLR W0
003AA6  370030     BRA 0x3B08
454:                   }
455:               
456:               
457:                   pstr_copy_dest = pstr_dest;
003AA8  9000BE     MOV [W14+6], W1
003AAA  780F01     MOV W1, [W14]
458:                   pstr_copy_src  = pstr_src;
003AAC  9000CE     MOV [W14+8], W1
003AAE  980711     MOV W1, [W14+2]
459:                   len_copy       = 0u;
003AB0  EB0000     CLR W0
003AB2  980720     MOV W0, [W14+4]
460:               
461:                   while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
003AB4  37000B     BRA 0x3ACC
003ACC  78001E     MOV [W14], W0
003ACE  E00000     CP0 W0
003AD0  32000B     BRA Z, 0x3AE8
003AD2  90001E     MOV [W14+2], W0
003AD4  E00000     CP0 W0
003AD6  320008     BRA Z, 0x3AE8
462:                          ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
003ADC  E00400     CP0.B W0
003ADE  320004     BRA Z, 0x3AE8
463:                          (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
003AD8  90001E     MOV [W14+2], W0
003ADA  784010     MOV.B [W0], W0
003AE0  9000AE     MOV [W14+4], W1
003AE2  90005E     MOV [W14+10], W0
003AE4  508F80     SUB W1, W0, [W15]
003AE6  39FFE7     BRA NC, 0x3AB6
464:                          ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
465:                      *pstr_copy_dest = *pstr_copy_src;
003AB6  90001E     MOV [W14+2], W0
003AB8  784090     MOV.B [W0], W1
003ABA  78001E     MOV [W14], W0
003ABC  784801     MOV.B W1, [W0]
466:                       pstr_copy_dest++;
003ABE  E80F1E     INC [W14], [W14]
467:                       pstr_copy_src++;
003AC0  90001E     MOV [W14+2], W0
003AC2  E80000     INC W0, W0
003AC4  980710     MOV W0, [W14+2]
468:                       len_copy++;
003AC6  90002E     MOV [W14+4], W0
003AC8  E80000     INC W0, W0
003ACA  980720     MOV W0, [W14+4]
469:                   }
470:                                                                               /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
471:                   if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
003AE8  78001E     MOV [W14], W0
003AEA  E00000     CP0 W0
003AEC  320003     BRA Z, 0x3AF4
003AEE  90001E     MOV [W14+2], W0
003AF0  E00000     CP0 W0
003AF2  3A0002     BRA NZ, 0x3AF8
472:                       (pstr_copy_src  == (const CPU_CHAR *)0)) {
473:                        return ((CPU_CHAR *)0);
003AF4  EB0000     CLR W0
003AF6  370008     BRA 0x3B08
474:                   }
475:               
476:                   if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
003AF8  9000AE     MOV [W14+4], W1
003AFA  90005E     MOV [W14+10], W0
003AFC  508F80     SUB W1, W0, [W15]
003AFE  310003     BRA C, 0x3B06
477:                      *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
003B00  78001E     MOV [W14], W0
003B02  EB4080     CLR.B W1
003B04  784801     MOV.B W1, [W0]
478:                   }
479:               
480:               
481:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
003B06  90003E     MOV [W14+6], W0
482:               }
003B08  FA8000     ULNK
003B0A  060000     RETURN
483:               
484:               
485:               /*
486:               *********************************************************************************************************
487:               *                                              Str_Cat()
488:               *
489:               * Description : Append concatenation string to destination string.
490:               *
491:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
492:               *
493:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
494:               *
495:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
496:               *
497:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
498:               *
499:               * Caller(s)   : Application.
500:               *
501:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
502:               *
503:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
504:               *                           concatenated string size including the terminating NULL character.
505:               *
506:               *                   (b) Concatenation string buffer NOT modified.
507:               *
508:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
509:               *
510:               *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2'
511:               *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
512:               *
513:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
514:               *                                end of 's1' ('pstr_dest')."
515:               *                           (B)  A "terminating null byte" is appended at the end of the concatenated
516:               *                                destination strings.
517:               *
518:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
519:               *
520:               *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
521:               *                       (2) "no return value shall be reserved to indicate an error."
522:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
523:               *                               NULL for any error(s).
524:               *
525:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
526:               *                       copying takes place between objects that overlap, the behavior is undefined."
527:               *
528:               *               (3) String concatenation terminates when :
529:               *
530:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
531:               *                       (1) No string concatenation performed; NULL pointer returned.
532:               *
533:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
534:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
535:               *
536:               *                   (c) Concatenation string's terminating NULL character found.
537:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
538:               *********************************************************************************************************
539:               */
540:               
541:               CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
542:                                   const  CPU_CHAR  *pstr_cat)
543:               {
003B0C  FA0006     LNK #0x6
003B0E  980710     MOV W0, [W14+2]
003B10  980721     MOV W1, [W14+4]
544:                   CPU_CHAR  *pstr_rtn;
545:               
546:               
547:                   pstr_rtn = Str_Cat_N(pstr_dest,
003B12  EB8100     SETM W2
003B14  9000AE     MOV [W14+4], W1
003B16  90001E     MOV [W14+2], W0
003B18  070004     RCALL Str_Cat_N
003B1A  780F00     MOV W0, [W14]
548:                                        pstr_cat,
549:                                        DEF_INT_CPU_U_MAX_VAL);
550:               
551:                   return (pstr_rtn);
003B1C  78001E     MOV [W14], W0
552:               }
003B1E  FA8000     ULNK
003B20  060000     RETURN
553:               
554:               
555:               /*
556:               *********************************************************************************************************
557:               *                                             Str_Cat_N()
558:               *
559:               * Description : Append concatenation string to destination string, up to a maximum number of characters.
560:               *
561:               * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
562:               *
563:               *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
564:               *
565:               *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
566:               *
567:               * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
568:               *
569:               *               Pointer to NULL,               otherwise      (see Note #2b2A).
570:               *
571:               * Caller(s)   : Application.
572:               *
573:               * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
574:               *
575:               *                       (1) Destination buffer size MUST be large enough to accommodate the entire
576:               *                           concatenated string size including the terminating NULL character.
577:               *
578:               *                   (b) Concatenation string buffer NOT modified.
579:               *
580:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
581:               *
582:               *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2'
583:               *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
584:               *                           (B)  but "not more than 'n' ('len_max') bytes".
585:               *
586:               *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
587:               *                                end of 's1' ('pstr_dest')."
588:               *                           (B) "(a null byte and bytes that follow it are not appended)."
589:               *                           (C) "A terminating null byte is always appended to the result."
590:               *
591:               *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
592:               *
593:               *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
594:               *                       (2) "no return value shall be reserved to indicate an error."
595:               *                           (A) #### This requirement is intentionally NOT implemented in order to return
596:               *                               NULL for any error(s).
597:               *
598:               *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
599:               *                       copying takes place between objects that overlap, the behavior is undefined."
600:               *
601:               *               (3) String concatenation terminates when :
602:               *
603:               *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
604:               *                       (1) No string concatenation performed; NULL pointer returned.
605:               *
606:               *                   (b) Destination/Concatenation string pointer(s) point to NULL.
607:               *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
608:               *
609:               *                   (c) Concatenation string's terminating NULL character found.
610:               *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
611:               *
612:               *                   (d) 'len_max' number of characters concatenated.
613:               *
614:               *                       (1) 'len_max' number of characters does NOT include the terminating NULL character
615:               *                           (see Note #2a2).
616:               *
617:               *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
618:               *                           (A) No string concatenation performed; destination string returned
619:               *                               (see Note #2b1).
620:               *********************************************************************************************************
621:               */
622:               
623:               CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
624:                                     const  CPU_CHAR    *pstr_cat,
625:                                            CPU_SIZE_T   len_max)
626:               {
003B22  FA000C     LNK #0xC
003B24  980730     MOV W0, [W14+6]
003B26  980741     MOV W1, [W14+8]
003B28  980752     MOV W2, [W14+10]
627:                          CPU_CHAR    *pstr_cat_dest;
628:                   const  CPU_CHAR    *pstr_cat_src;
629:                          CPU_SIZE_T   len_cat;
630:               
631:                                                                               /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
632:                   if (pstr_dest == (CPU_CHAR *)0) {
003B2A  90003E     MOV [W14+6], W0
003B2C  E00000     CP0 W0
003B2E  3A0002     BRA NZ, 0x3B34
633:                       return ((CPU_CHAR *)0);
003B30  EB0000     CLR W0
003B32  370044     BRA 0x3BBC
634:                   }
635:                   if (pstr_cat  == (const CPU_CHAR *)0) {
003B34  90004E     MOV [W14+8], W0
003B36  E00000     CP0 W0
003B38  3A0002     BRA NZ, 0x3B3E
636:                       return ((CPU_CHAR *)0);
003B3A  EB0000     CLR W0
003B3C  37003F     BRA 0x3BBC
637:                   }
638:               
639:                   if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
003B3E  90005E     MOV [W14+10], W0
003B40  E00000     CP0 W0
003B42  3A0002     BRA NZ, 0x3B48
640:                       return ((CPU_CHAR *)pstr_dest);
003B44  90003E     MOV [W14+6], W0
003B46  37003A     BRA 0x3BBC
641:                   }
642:               
643:               
644:                   pstr_cat_dest = pstr_dest;
003B48  9000BE     MOV [W14+6], W1
003B4A  780F01     MOV W1, [W14]
645:                   while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
003B4C  370001     BRA 0x3B50
003B50  78001E     MOV [W14], W0
003B52  E00000     CP0 W0
003B54  320004     BRA Z, 0x3B5E
003B5A  E00400     CP0.B W0
003B5C  3AFFF8     BRA NZ, 0x3B4E
646:                          (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
003B56  78001E     MOV [W14], W0
003B58  784010     MOV.B [W0], W0
647:                       pstr_cat_dest++;
003B4E  E80F1E     INC [W14], [W14]
648:                   }
649:                   if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
003B5E  78001E     MOV [W14], W0
003B60  E00000     CP0 W0
003B62  3A0002     BRA NZ, 0x3B68
650:                       return ((CPU_CHAR *)0);
003B64  EB0000     CLR W0
003B66  37002A     BRA 0x3BBC
651:                   }
652:               
653:                   pstr_cat_src = pstr_cat;
003B68  9000CE     MOV [W14+8], W1
003B6A  980711     MOV W1, [W14+2]
654:                   len_cat      = 0u;
003B6C  EB0000     CLR W0
003B6E  980720     MOV W0, [W14+4]
655:               
656:                   while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
003B70  37000B     BRA 0x3B88
003B88  78001E     MOV [W14], W0
003B8A  E00000     CP0 W0
003B8C  32000B     BRA Z, 0x3BA4
003B8E  90001E     MOV [W14+2], W0
003B90  E00000     CP0 W0
003B92  320008     BRA Z, 0x3BA4
657:                          ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
003B98  E00400     CP0.B W0
003B9A  320004     BRA Z, 0x3BA4
658:                          (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
003B94  90001E     MOV [W14+2], W0
003B96  784010     MOV.B [W0], W0
003B9C  9000AE     MOV [W14+4], W1
003B9E  90005E     MOV [W14+10], W0
003BA0  508F80     SUB W1, W0, [W15]
003BA2  39FFE7     BRA NC, 0x3B72
659:                          ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
660:                      *pstr_cat_dest = *pstr_cat_src;
003B72  90001E     MOV [W14+2], W0
003B74  784090     MOV.B [W0], W1
003B76  78001E     MOV [W14], W0
003B78  784801     MOV.B W1, [W0]
661:                       pstr_cat_dest++;
003B7A  E80F1E     INC [W14], [W14]
662:                       pstr_cat_src++;
003B7C  90001E     MOV [W14+2], W0
003B7E  E80000     INC W0, W0
003B80  980710     MOV W0, [W14+2]
663:                       len_cat++;
003B82  90002E     MOV [W14+4], W0
003B84  E80000     INC W0, W0
003B86  980720     MOV W0, [W14+4]
664:                   }
665:                                                                               /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
666:                   if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
003BA4  78001E     MOV [W14], W0
003BA6  E00000     CP0 W0
003BA8  320003     BRA Z, 0x3BB0
003BAA  90001E     MOV [W14+2], W0
003BAC  E00000     CP0 W0
003BAE  3A0002     BRA NZ, 0x3BB4
667:                       (pstr_cat_src  == (const CPU_CHAR *)0)) {
668:                        return ((CPU_CHAR *)0);
003BB0  EB0000     CLR W0
003BB2  370004     BRA 0x3BBC
669:                   }
670:               
671:                  *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
003BB4  78001E     MOV [W14], W0
003BB6  EB4080     CLR.B W1
003BB8  784801     MOV.B W1, [W0]
672:               
673:               
674:                   return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
003BBA  90003E     MOV [W14+6], W0
675:               }
003BBC  FA8000     ULNK
003BBE  060000     RETURN
676:               
677:               
678:               /*
679:               *********************************************************************************************************
680:               *                                              Str_Cmp()
681:               *
682:               * Description : Determine if two strings are identical.
683:               *
684:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
685:               *
686:               *               p2_str      Pointer to second string (see Note #1).
687:               *
688:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
689:               *
690:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
691:               *
692:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
693:               *
694:               *               See also Note #2b.
695:               *
696:               * Caller(s)   : Application.
697:               *
698:               * Note(s)     : (1) String buffers NOT modified.
699:               *
700:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
701:               *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
702:               *                       string pointed to by 's2' ('p2_str)".
703:               *
704:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
705:               *                          "upon successful completion, strcmp() shall return an integer greater than,
706:               *                           equal to, or less than 0".
707:               *
708:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
709:               *                           sign of a non-zero return value shall be determined by the sign of the difference
710:               *                           between the values of the first pair of bytes ... that differ in the strings
711:               *                           being compared".
712:               *
713:               *               (3) String comparison terminates when :
714:               *
715:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
716:               *                               (1) NULL strings identical; 0 returned.
717:               *
718:               *                           (B) (1) 'p1_str' passed a NULL pointer.
719:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
720:               *
721:               *                               (2) 'p2_str' passed a NULL pointer.
722:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
723:               *
724:               *                       (2) (A) BOTH strings point to NULL.
725:               *                               (1) Strings overlap with NULL address.
726:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
727:               *                                   0 returned.
728:               *
729:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
730:               *                                   (a) 'p1_str' overlaps with NULL address.
731:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
732:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
733:               *
734:               *                               (2) 'p2_str_cmp_next' points to NULL.
735:               *                                   (a) 'p2_str' overlaps with NULL address.
736:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
737:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
738:               *
739:               *                   (b) Terminating NULL character found in both strings.
740:               *                       (1) Strings identical; 0 returned.
741:               *                       (2) Only one NULL character test required in conditional since previous condition
742:               *                           tested character equality.
743:               *
744:               *                   (c) Non-matching characters found.
745:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
746:               *                           from the character pointed to by 'p1_str'.
747:               *
748:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
749:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
750:               *********************************************************************************************************
751:               */
752:               
753:               CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
754:                                    const  CPU_CHAR  *p2_str)
755:               {
003BC0  FA0006     LNK #0x6
003BC2  980710     MOV W0, [W14+2]
003BC4  980721     MOV W1, [W14+4]
756:                   CPU_INT16S  cmp_val;
757:               
758:               
759:                   cmp_val = Str_Cmp_N(p1_str,
003BC6  EB8100     SETM W2
003BC8  9000AE     MOV [W14+4], W1
003BCA  90001E     MOV [W14+2], W0
003BCC  070004     RCALL Str_Cmp_N
003BCE  780F00     MOV W0, [W14]
760:                                       p2_str,
761:                                       DEF_INT_CPU_U_MAX_VAL);
762:               
763:                   return (cmp_val);
003BD0  78001E     MOV [W14], W0
764:               }
003BD2  FA8000     ULNK
003BD4  060000     RETURN
765:               
766:               
767:               /*
768:               *********************************************************************************************************
769:               *                                             Str_Cmp_N()
770:               *
771:               * Description : Determine if two strings are identical for up to a maximum number of characters.
772:               *
773:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
774:               *
775:               *               p2_str      Pointer to second string (see Note #1).
776:               *
777:               *               len_max     Maximum number of characters to compare  (see Note  #3d).
778:               *
779:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
780:               *
781:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
782:               *
783:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
784:               *
785:               *               See also Note #2b.
786:               *
787:               * Caller(s)   : Application.
788:               *
789:               * Note(s)     : (1) String buffers NOT modified.
790:               *
791:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
792:               *
793:               *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str')
794:               *                            to the array pointed to by 's2' ('p2_str)" ...
795:               *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
796:               *
797:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
798:               *                          "upon successful completion, strncmp() shall return an integer greater than,
799:               *                           equal to, or less than 0".
800:               *
801:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
802:               *                          "the sign of a non-zero return value is determined by the sign of the difference
803:               *                           between the values of the first pair of bytes ... that differ in the strings
804:               *                           being compared".
805:               *
806:               *               (3) String comparison terminates when :
807:               *
808:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
809:               *                               (1) NULL strings identical; 0 returned.
810:               *
811:               *                           (B) (1) 'p1_str' passed a NULL pointer.
812:               *                                   (a) Return negative value of character pointed to by 'p2_str'.
813:               *
814:               *                               (2) 'p2_str' passed a NULL pointer.
815:               *                                   (a) Return positive value of character pointed to by 'p1_str'.
816:               *
817:               *                       (2) (A) BOTH strings point to NULL.
818:               *                               (1) Strings overlap with NULL address.
819:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
820:               *                                   0 returned.
821:               *
822:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
823:               *                                   (a) 'p1_str' overlaps with NULL address.
824:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
825:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
826:               *
827:               *                               (2) 'p2_str_cmp_next' points to NULL.
828:               *                                   (a) 'p2_str' overlaps with NULL address.
829:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
830:               *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
831:               *
832:               *                   (b) Terminating NULL character found in both strings.
833:               *                       (1) Strings identical; 0 returned.
834:               *                       (2) Only one NULL character test required in conditional since previous condition
835:               *                           tested character equality.
836:               *
837:               *                   (c) Non-matching characters found.
838:               *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
839:               *                           from the character pointed to by 'p1_str'.
840:               *
841:               *                   (d) (1) 'len_max' passed a zero length.
842:               *                           (A) Zero-length strings identical; 0 returned.
843:               *
844:               *                       (2) First 'len_max' number of characters identical.
845:               *                           (A) Strings identical; 0 returned.
846:               *
847:               *                       See also Note #2a2.
848:               *
849:               *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
850:               *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
851:               *********************************************************************************************************
852:               */
853:               
854:               CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
855:                                      const  CPU_CHAR    *p2_str,
856:                                             CPU_SIZE_T   len_max)
857:               {
003BD6  FA0012     LNK #0x12
003BD8  980760     MOV W0, [W14+12]
003BDA  980771     MOV W1, [W14+14]
003BDC  980F02     MOV W2, [W14+16]
858:                   const  CPU_CHAR    *p1_str_cmp;
859:                   const  CPU_CHAR    *p2_str_cmp;
860:                   const  CPU_CHAR    *p1_str_cmp_next;
861:                   const  CPU_CHAR    *p2_str_cmp_next;
862:                          CPU_INT16S   cmp_val;
863:                          CPU_SIZE_T   cmp_len;
864:               
865:               
866:                   if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
003BDE  90080E     MOV [W14+16], W0
003BE0  E00000     CP0 W0
003BE2  3A0002     BRA NZ, 0x3BE8
867:                       return (0);
003BE4  EB0000     CLR W0
003BE6  37007A     BRA 0x3CDC
868:                   }
869:               
870:                   if (p1_str == (const CPU_CHAR *)0) {
003BE8  90006E     MOV [W14+12], W0
003BEA  E00000     CP0 W0
003BEC  3A000C     BRA NZ, 0x3C06
871:                       if (p2_str == (const CPU_CHAR *)0) {
003BEE  90007E     MOV [W14+14], W0
003BF0  E00000     CP0 W0
003BF2  3A0002     BRA NZ, 0x3BF8
872:                           return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
003BF4  EB0000     CLR W0
003BF6  370072     BRA 0x3CDC
873:                       }
874:                       cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
003BF8  90007E     MOV [W14+14], W0
003BFA  784010     MOV.B [W0], W0
003BFC  FB8000     ZE W0, W0
003BFE  EA0000     NEG W0, W0
003C00  980740     MOV W0, [W14+8]
875:                       return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
003C02  90004E     MOV [W14+8], W0
003C04  37006B     BRA 0x3CDC
876:                   }
877:                   if (p2_str == (const CPU_CHAR *)0) {
003C06  90007E     MOV [W14+14], W0
003C08  E00000     CP0 W0
003C0A  3A0006     BRA NZ, 0x3C18
878:                       cmp_val = (CPU_INT16S)(*p1_str);
003C0C  90006E     MOV [W14+12], W0
003C0E  784010     MOV.B [W0], W0
003C10  FB8000     ZE W0, W0
003C12  980740     MOV W0, [W14+8]
879:                       return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
003C14  90004E     MOV [W14+8], W0
003C16  370062     BRA 0x3CDC
880:                   }
881:               
882:               
883:                   p1_str_cmp      = p1_str;
003C18  9000EE     MOV [W14+12], W1
003C1A  780F01     MOV W1, [W14]
884:                   p2_str_cmp      = p2_str;
003C1C  9000FE     MOV [W14+14], W1
003C1E  980711     MOV W1, [W14+2]
885:                   p1_str_cmp_next = p1_str_cmp;
003C20  78009E     MOV [W14], W1
003C22  980721     MOV W1, [W14+4]
886:                   p2_str_cmp_next = p2_str_cmp;
003C24  90009E     MOV [W14+2], W1
003C26  980731     MOV W1, [W14+6]
887:                   p1_str_cmp_next++;
003C28  90002E     MOV [W14+4], W0
003C2A  E80000     INC W0, W0
003C2C  980720     MOV W0, [W14+4]
888:                   p2_str_cmp_next++;
003C2E  90003E     MOV [W14+6], W0
003C30  E80000     INC W0, W0
003C32  980730     MOV W0, [W14+6]
889:                   cmp_len         = 0u;
003C34  EB0000     CLR W0
003C36  980750     MOV W0, [W14+10]
890:               
891:                   while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
003C38  37000D     BRA 0x3C54
003C54  78001E     MOV [W14], W0
003C56  784090     MOV.B [W0], W1
003C58  90001E     MOV [W14+2], W0
003C5A  784010     MOV.B [W0], W0
003C5C  50CF80     SUB.B W1, W0, [W15]
003C5E  3A000E     BRA NZ, 0x3C7C
003C64  E00400     CP0.B W0
003C66  32000A     BRA Z, 0x3C7C
892:                          (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
003C60  78001E     MOV [W14], W0
003C62  784010     MOV.B [W0], W0
003C68  90002E     MOV [W14+4], W0
003C6A  E00000     CP0 W0
003C6C  320007     BRA Z, 0x3C7C
893:                          ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
003C6E  90003E     MOV [W14+6], W0
003C70  E00000     CP0 W0
003C72  320004     BRA Z, 0x3C7C
894:                          ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
003C74  9000DE     MOV [W14+10], W1
003C76  90080E     MOV [W14+16], W0
003C78  508F80     SUB W1, W0, [W15]
003C7A  39FFDF     BRA NC, 0x3C3A
895:                          ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
896:                       p1_str_cmp++;
003C3A  E80F1E     INC [W14], [W14]
897:                       p2_str_cmp++;
003C3C  90001E     MOV [W14+2], W0
003C3E  E80000     INC W0, W0
003C40  980710     MOV W0, [W14+2]
898:                       p1_str_cmp_next++;
003C42  90002E     MOV [W14+4], W0
003C44  E80000     INC W0, W0
003C46  980720     MOV W0, [W14+4]
899:                       p2_str_cmp_next++;
003C48  90003E     MOV [W14+6], W0
003C4A  E80000     INC W0, W0
003C4C  980730     MOV W0, [W14+6]
900:                       cmp_len++;
003C4E  90005E     MOV [W14+10], W0
003C50  E80000     INC W0, W0
003C52  980750     MOV W0, [W14+10]
901:                   }
902:               
903:               
904:                   if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
003C7C  9000DE     MOV [W14+10], W1
003C7E  90080E     MOV [W14+16], W0
003C80  508F80     SUB W1, W0, [W15]
003C82  3A0002     BRA NZ, 0x3C88
905:                       return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
003C84  EB0000     CLR W0
003C86  37002A     BRA 0x3CDC
906:                   }
907:               
908:                   if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
003C88  78001E     MOV [W14], W0
003C8A  784090     MOV.B [W0], W1
003C8C  90001E     MOV [W14+2], W0
003C8E  784010     MOV.B [W0], W0
003C90  50CF80     SUB.B W1, W0, [W15]
003C92  320009     BRA Z, 0x3CA6
909:                                                                               /* ... calc & rtn char diff  (see Note #3c1).           */
910:                        cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
003C94  78001E     MOV [W14], W0
003C96  784010     MOV.B [W0], W0
003C98  FB8080     ZE W0, W1
003C9A  90001E     MOV [W14+2], W0
003C9C  784010     MOV.B [W0], W0
003C9E  FB8000     ZE W0, W0
003CA0  508000     SUB W1, W0, W0
003CA2  980740     MOV W0, [W14+8]
003CA4  37001A     BRA 0x3CDA
911:               
912:                   } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
003CA6  78001E     MOV [W14], W0
003CA8  784010     MOV.B [W0], W0
003CAA  E00400     CP0.B W0
003CAC  3A0003     BRA NZ, 0x3CB4
913:                        cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
003CAE  EB0000     CLR W0
003CB0  980740     MOV W0, [W14+8]
003CB2  370013     BRA 0x3CDA
914:               
915:                   } else {
916:                       if (p1_str_cmp_next == (const CPU_CHAR *)0) {
003CB4  90002E     MOV [W14+4], W0
003CB6  E00000     CP0 W0
003CB8  3A000C     BRA NZ, 0x3CD2
917:                           if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
003CBA  90003E     MOV [W14+6], W0
003CBC  E00000     CP0 W0
003CBE  3A0003     BRA NZ, 0x3CC6
918:                               cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
003CC0  EB0000     CLR W0
003CC2  980740     MOV W0, [W14+8]
003CC4  37000A     BRA 0x3CDA
919:                           } else {                                            /* If p1_str_cmp_next NULL, ...                         */
920:                                                                               /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
921:                               cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
003CC6  90003E     MOV [W14+6], W0
003CC8  784010     MOV.B [W0], W0
003CCA  FB8000     ZE W0, W0
003CCC  EA0000     NEG W0, W0
003CCE  980740     MOV W0, [W14+8]
003CD0  370004     BRA 0x3CDA
922:                           }
923:                       } else {                                                /* If p2_str_cmp_next NULL, ...                         */
924:                           cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
003CD2  90002E     MOV [W14+4], W0
003CD4  784010     MOV.B [W0], W0
003CD6  FB8000     ZE W0, W0
003CD8  980740     MOV W0, [W14+8]
925:                       }
926:                   }
927:               
928:               
929:                   return (cmp_val);
003CDA  90004E     MOV [W14+8], W0
930:               }
003CDC  FA8000     ULNK
003CDE  060000     RETURN
931:               
932:               
933:               /*
934:               *********************************************************************************************************
935:               *                                         Str_CmpIgnoreCase()
936:               *
937:               * Description : Determine if two strings are identical, ignoring case.
938:               *
939:               * Argument(s) : p1_str      Pointer to first  string (see Note #1).
940:               *
941:               *               p2_str      Pointer to second string (see Note #1).
942:               *
943:               * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
944:               *
945:               *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
946:               *
947:               *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
948:               *
949:               *               See also Note #2b.
950:               *
951:               * Caller(s)   : Application.
952:               *
953:               * Note(s)     : (1) String buffers NOT modified.
954:               *
955:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
956:               *
957:               *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1'
958:               *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
959:               *                           (B) "ignoring differences in case".
960:               *
961:               *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
962:               *                            and then a byte comparison performed."
963:               *
964:               *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
965:               *                          "upon successful completion, strcasecmp() shall return an integer greater than,
966:               *                           equal to, or less than 0".
967:               *
968:               *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
969:               *                           sign of a non-zero return value shall be determined by the sign of the difference
970:               *                           between the values of the first pair of bytes ... that differ in the strings
971:               *                           being compared".
972:               *
973:               *               (3) String comparison terminates when :
974:               *
975:               *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
976:               *                               (1) NULL strings identical; 0 returned.
977:               *
978:               *                           (B) (1) 'p1_str' passed a NULL pointer.
979:               *                                   (a) Return negative value of character pointed to by 'p2_str', converted
980:               *                                       to lower case (see Note #2a2).
981:               *
982:               *                               (2) 'p2_str' passed a NULL pointer.
983:               *                                   (a) Return positive value of character pointed to by 'p1_str', converted
984:               *                                       to lower case (see Note #2a2).
985:               *
986:               *                       (2) (A) BOTH strings point to NULL.
987:               *                               (1) Strings overlap with NULL address.
988:               *                               (2) Strings identical up to but NOT beyond or including the NULL address;
989:               *                                   0 returned.
990:               *
991:               *                           (B) (1) 'p1_str_cmp_next' points to NULL.
992:               *                                   (a) 'p1_str' overlaps with NULL address.
993:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
994:               *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
995:               *                                       converted to lower case (see Note #2a2).
996:               *
997:               *                               (2) 'p2_str_cmp_next' points to NULL.
998:               *                                   (a) 'p2_str' overlaps with NULL address.
999:               *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1000:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1001:              *                                       converted to lower case (see Note #2a2).
1002:              *
1003:              *                   (b) Terminating NULL character found in both strings.
1004:              *                       (1) Strings identical; 0 returned.
1005:              *                       (2) Only one NULL character test required in conditional since previous condition
1006:              *                           tested character equality.
1007:              *
1008:              *                   (c) Non-matching characters found.
1009:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1010:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1011:              *                           to lower case.
1012:              *
1013:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1014:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1015:              *********************************************************************************************************
1016:              */
1017:              
1018:              CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
1019:                                             const  CPU_CHAR  *p2_str)
1020:              {
003CE0  FA0006     LNK #0x6
003CE2  980710     MOV W0, [W14+2]
003CE4  980721     MOV W1, [W14+4]
1021:                  CPU_INT16S  cmp_val;
1022:              
1023:              
1024:                  cmp_val = Str_CmpIgnoreCase_N(p1_str,
003CE6  EB8100     SETM W2
003CE8  9000AE     MOV [W14+4], W1
003CEA  90001E     MOV [W14+2], W0
003CEC  070004     RCALL Str_CmpIgnoreCase_N
003CEE  780F00     MOV W0, [W14]
1025:                                                p2_str,
1026:                                                DEF_INT_CPU_U_MAX_VAL);
1027:              
1028:                  return (cmp_val);
003CF0  78001E     MOV [W14], W0
1029:              }
003CF2  FA8000     ULNK
003CF4  060000     RETURN
1030:              
1031:              
1032:              /*
1033:              *********************************************************************************************************
1034:              *                                        Str_CmpIgnoreCase_N()
1035:              *
1036:              * Description : Determine if two strings are identical for up to a maximum number of characters,
1037:              *                   ignoring case.
1038:              *
1039:              * Argument(s) : p1_str      Pointer to first  string (see Note #1).
1040:              *
1041:              *               p2_str      Pointer to second string (see Note #1).
1042:              *
1043:              *               len_max     Maximum number of characters to compare  (see Note  #3d).
1044:              *
1045:              * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
1046:              *
1047:              *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
1048:              *
1049:              *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
1050:              *
1051:              *               See also Note #2b.
1052:              *
1053:              * Caller(s)   : Application.
1054:              *
1055:              * Note(s)     : (1) String buffers NOT modified.
1056:              *
1057:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
1058:              *
1059:              *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1'
1060:              *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
1061:              *                           (B) "ignoring differences in case"                           ...
1062:              *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
1063:              *
1064:              *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
1065:              *                            and then a byte comparison performed."
1066:              *
1067:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
1068:              *                          "upon successful completion, strncasecmp() shall return an integer greater than,
1069:              *                           equal to, or less than 0".
1070:              *
1071:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
1072:              *                           sign of a non-zero return value shall be determined by the sign of the difference
1073:              *                           between the values of the first pair of bytes ... that differ in the strings
1074:              *                           being compared".
1075:              *
1076:              *               (3) String comparison terminates when :
1077:              *
1078:              *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
1079:              *                               (1) NULL strings identical; 0 returned.
1080:              *
1081:              *                           (B) (1) 'p1_str' passed a NULL pointer.
1082:              *                                   (a) Return negative value of character pointed to by 'p2_str', converted
1083:              *                                       to lower case (see Note #2a2).
1084:              *
1085:              *                               (2) 'p2_str' passed a NULL pointer.
1086:              *                                   (a) Return positive value of character pointed to by 'p1_str', converted
1087:              *                                       to lower case (see Note #2a2).
1088:              *
1089:              *                       (2) (A) BOTH strings point to NULL.
1090:              *                               (1) Strings overlap with NULL address.
1091:              *                               (2) Strings identical up to but NOT beyond or including the NULL address;
1092:              *                                   0 returned.
1093:              *
1094:              *                           (B) (1) 'p1_str_cmp_next' points to NULL.
1095:              *                                   (a) 'p1_str' overlaps with NULL address.
1096:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1097:              *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
1098:              *                                       converted to lower case (see Note #2a2).
1099:              *
1100:              *                               (2) 'p2_str_cmp_next' points to NULL.
1101:              *                                   (a) 'p2_str' overlaps with NULL address.
1102:              *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
1103:              *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
1104:              *                                       converted to lower case (see Note #2a2).
1105:              *
1106:              *                   (b) Terminating NULL character found in both strings.
1107:              *                       (1) Strings identical; 0 returned.
1108:              *                       (2) Only one NULL character test required in conditional since previous condition
1109:              *                           tested character equality.
1110:              *
1111:              *                   (c) Non-matching characters found.
1112:              *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
1113:              *                           converted to lower case, from the character pointed to by 'p1_str', converted
1114:              *                           to lower case.
1115:              *
1116:              *                   (d) (1) 'len_max' passed a zero length.
1117:              *                           (A) Zero-length strings identical; 0 returned.
1118:              *
1119:              *                       (2) First 'len_max' number of characters identical.
1120:              *                           (A) Strings identical; 0 returned.
1121:              *
1122:              *                       See also Note #2a1C.
1123:              *$PAGE*
1124:              *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
1125:              *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
1126:              *********************************************************************************************************
1127:              */
1128:              
1129:              CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
1130:                                               const  CPU_CHAR    *p2_str,
1131:                                                      CPU_SIZE_T   len_max)
1132:              {
003CF6  FA0014     LNK #0x14
003CF8  980770     MOV W0, [W14+14]
003CFA  980F01     MOV W1, [W14+16]
003CFC  980F12     MOV W2, [W14+18]
1133:                  const  CPU_CHAR    *p1_str_cmp;
1134:                  const  CPU_CHAR    *p2_str_cmp;
1135:                  const  CPU_CHAR    *p1_str_cmp_next;
1136:                  const  CPU_CHAR    *p2_str_cmp_next;
1137:                         CPU_CHAR     char_1;
1138:                         CPU_CHAR     char_2;
1139:                         CPU_INT16S   cmp_val;
1140:                         CPU_SIZE_T   cmp_len;
1141:              
1142:              
1143:                  if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
003CFE  90081E     MOV [W14+18], W0
003D00  E00000     CP0 W0
003D02  3A0002     BRA NZ, 0x3D08
1144:                      return (0);
003D04  EB0000     CLR W0
003D06  37008F     BRA 0x3E26
1145:                  }
1146:              
1147:                  if (p1_str == (const CPU_CHAR *)0) {
003D08  90007E     MOV [W14+14], W0
003D0A  E00000     CP0 W0
003D0C  3A000F     BRA NZ, 0x3D2C
1148:                      if (p2_str == (const CPU_CHAR *)0) {
003D0E  90080E     MOV [W14+16], W0
003D10  E00000     CP0 W0
003D12  3A0002     BRA NZ, 0x3D18
1149:                          return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
003D14  EB0000     CLR W0
003D16  370087     BRA 0x3E26
1150:                      }
1151:                      char_2  =  ASCII_ToLower(*p2_str);
003D18  90080E     MOV [W14+16], W0
003D1A  784010     MOV.B [W0], W0
003D1C  071430     RCALL ASCII_ToLower
003D1E  984F10     MOV.B W0, [W14+9]
1152:                      cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
003D20  90481E     MOV.B [W14+9], W0
003D22  FB8000     ZE W0, W0
003D24  EA0000     NEG W0, W0
003D26  980750     MOV W0, [W14+10]
1153:                      return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
003D28  90005E     MOV [W14+10], W0
003D2A  37007D     BRA 0x3E26
1154:                  }
1155:                  if (p2_str == (const CPU_CHAR *)0) {
003D2C  90080E     MOV [W14+16], W0
003D2E  E00000     CP0 W0
003D30  3A0009     BRA NZ, 0x3D44
1156:                      char_1  =  ASCII_ToLower(*p1_str);
003D32  90007E     MOV [W14+14], W0
003D34  784010     MOV.B [W0], W0
003D36  071423     RCALL ASCII_ToLower
003D38  984F00     MOV.B W0, [W14+8]
1157:                      cmp_val = (CPU_INT16S)char_1;
003D3A  90480E     MOV.B [W14+8], W0
003D3C  FB8000     ZE W0, W0
003D3E  980750     MOV W0, [W14+10]
1158:                      return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
003D40  90005E     MOV [W14+10], W0
003D42  370071     BRA 0x3E26
1159:                  }
1160:              
1161:              
1162:                  p1_str_cmp      = p1_str;
003D44  9000FE     MOV [W14+14], W1
003D46  780F01     MOV W1, [W14]
1163:                  p2_str_cmp      = p2_str;
003D48  90088E     MOV [W14+16], W1
003D4A  980711     MOV W1, [W14+2]
1164:                  p1_str_cmp_next = p1_str_cmp;
003D4C  78009E     MOV [W14], W1
003D4E  980721     MOV W1, [W14+4]
1165:                  p2_str_cmp_next = p2_str_cmp;
003D50  90009E     MOV [W14+2], W1
003D52  980731     MOV W1, [W14+6]
1166:                  p1_str_cmp_next++;
003D54  90002E     MOV [W14+4], W0
003D56  E80000     INC W0, W0
003D58  980720     MOV W0, [W14+4]
1167:                  p2_str_cmp_next++;
003D5A  90003E     MOV [W14+6], W0
003D5C  E80000     INC W0, W0
003D5E  980730     MOV W0, [W14+6]
1168:                  char_1          = ASCII_ToLower(*p1_str_cmp);
003D60  78001E     MOV [W14], W0
003D62  784010     MOV.B [W0], W0
003D64  07140C     RCALL ASCII_ToLower
003D66  984F00     MOV.B W0, [W14+8]
1169:                  char_2          = ASCII_ToLower(*p2_str_cmp);
003D68  90001E     MOV [W14+2], W0
003D6A  784010     MOV.B [W0], W0
003D6C  071408     RCALL ASCII_ToLower
003D6E  984F10     MOV.B W0, [W14+9]
1170:                  cmp_len         = 0u;
003D70  EB0000     CLR W0
003D72  980760     MOV W0, [W14+12]
1171:              
1172:                  while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
003D74  370015     BRA 0x3DA0
003DA0  90488E     MOV.B [W14+8], W1
003DA2  90481E     MOV.B [W14+9], W0
003DA4  50CF80     SUB.B W1, W0, [W15]
003DA6  3A000E     BRA NZ, 0x3DC4
003DAC  E00400     CP0.B W0
003DAE  32000A     BRA Z, 0x3DC4
1173:                         (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
003DA8  78001E     MOV [W14], W0
003DAA  784010     MOV.B [W0], W0
003DB0  90002E     MOV [W14+4], W0
003DB2  E00000     CP0 W0
003DB4  320007     BRA Z, 0x3DC4
1174:                         ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
003DB6  90003E     MOV [W14+6], W0
003DB8  E00000     CP0 W0
003DBA  320004     BRA Z, 0x3DC4
1175:                         ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
003DBC  9000EE     MOV [W14+12], W1
003DBE  90081E     MOV [W14+18], W0
003DC0  508F80     SUB W1, W0, [W15]
003DC2  39FFD9     BRA NC, 0x3D76
1176:                         ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
1177:                      p1_str_cmp++;
003D76  E80F1E     INC [W14], [W14]
1178:                      p2_str_cmp++;
003D78  90001E     MOV [W14+2], W0
003D7A  E80000     INC W0, W0
003D7C  980710     MOV W0, [W14+2]
1179:                      p1_str_cmp_next++;
003D7E  90002E     MOV [W14+4], W0
003D80  E80000     INC W0, W0
003D82  980720     MOV W0, [W14+4]
1180:                      p2_str_cmp_next++;
003D84  90003E     MOV [W14+6], W0
003D86  E80000     INC W0, W0
003D88  980730     MOV W0, [W14+6]
1181:                      cmp_len++;
003D8A  90006E     MOV [W14+12], W0
003D8C  E80000     INC W0, W0
003D8E  980760     MOV W0, [W14+12]
1182:                      char_1 = ASCII_ToLower(*p1_str_cmp);
003D90  78001E     MOV [W14], W0
003D92  784010     MOV.B [W0], W0
003D94  0713F4     RCALL ASCII_ToLower
003D96  984F00     MOV.B W0, [W14+8]
1183:                      char_2 = ASCII_ToLower(*p2_str_cmp);
003D98  90001E     MOV [W14+2], W0
003D9A  784010     MOV.B [W0], W0
003D9C  0713F0     RCALL ASCII_ToLower
003D9E  984F10     MOV.B W0, [W14+9]
1184:                  }
1185:              
1186:              
1187:                  if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
003DC4  9000EE     MOV [W14+12], W1
003DC6  90081E     MOV [W14+18], W0
003DC8  508F80     SUB W1, W0, [W15]
003DCA  3A0002     BRA NZ, 0x3DD0
1188:                      return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
003DCC  EB0000     CLR W0
003DCE  37002B     BRA 0x3E26
1189:                  }
1190:              
1191:                  if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
003DD0  90488E     MOV.B [W14+8], W1
003DD2  90481E     MOV.B [W14+9], W0
003DD4  50CF80     SUB.B W1, W0, [W15]
003DD6  320007     BRA Z, 0x3DE6
1192:                                                                              /* ... calc & rtn char diff  (see Note #3c1).           */
1193:                       cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
003DD8  90480E     MOV.B [W14+8], W0
003DDA  FB8080     ZE W0, W1
003DDC  90481E     MOV.B [W14+9], W0
003DDE  FB8000     ZE W0, W0
003DE0  508000     SUB W1, W0, W0
003DE2  980750     MOV W0, [W14+10]
003DE4  37001F     BRA 0x3E24
1194:              
1195:                  } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
003DE6  90480E     MOV.B [W14+8], W0
003DE8  E00400     CP0.B W0
003DEA  3A0003     BRA NZ, 0x3DF2
1196:                       cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
003DEC  EB0000     CLR W0
003DEE  980750     MOV W0, [W14+10]
003DF0  370019     BRA 0x3E24
1197:              
1198:                  } else {
1199:                      if (p1_str_cmp_next == (const CPU_CHAR *)0) {
003DF2  90002E     MOV [W14+4], W0
003DF4  E00000     CP0 W0
003DF6  3A000F     BRA NZ, 0x3E16
1200:                          if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
003DF8  90003E     MOV [W14+6], W0
003DFA  E00000     CP0 W0
003DFC  3A0003     BRA NZ, 0x3E04
1201:                              cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
003DFE  EB0000     CLR W0
003E00  980750     MOV W0, [W14+10]
003E02  370010     BRA 0x3E24
1202:                          } else {                                            /* If p1_str_cmp_next NULL, ...                         */
1203:                              char_2  =  ASCII_ToLower(*p2_str_cmp_next);
003E04  90003E     MOV [W14+6], W0
003E06  784010     MOV.B [W0], W0
003E08  0713BA     RCALL ASCII_ToLower
003E0A  984F10     MOV.B W0, [W14+9]
1204:                                                                              /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
1205:                              cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
003E0C  90481E     MOV.B [W14+9], W0
003E0E  FB8000     ZE W0, W0
003E10  EA0000     NEG W0, W0
003E12  980750     MOV W0, [W14+10]
003E14  370007     BRA 0x3E24
1206:                          }
1207:                      } else {                                                /* If p2_str_cmp_next NULL, ...                         */
1208:                          char_1  =  ASCII_ToLower(*p1_str_cmp_next);
003E16  90002E     MOV [W14+4], W0
003E18  784010     MOV.B [W0], W0
003E1A  0713B1     RCALL ASCII_ToLower
003E1C  984F00     MOV.B W0, [W14+8]
1209:                          cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
003E1E  90480E     MOV.B [W14+8], W0
003E20  FB8000     ZE W0, W0
003E22  980750     MOV W0, [W14+10]
1210:                      }
1211:                  }
1212:              
1213:              
1214:                  return (cmp_val);
003E24  90005E     MOV [W14+10], W0
1215:              }
003E26  FA8000     ULNK
003E28  060000     RETURN
1216:              
1217:              
1218:              /*
1219:              *********************************************************************************************************
1220:              *                                             Str_Char()
1221:              *
1222:              * Description : Search string for first occurrence of specific character.
1223:              *
1224:              * Argument(s) : pstr            Pointer to string (see Note #1).
1225:              *
1226:              *               srch_char       Search character.
1227:              *
1228:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1229:              *
1230:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1231:              *
1232:              * Caller(s)   : Application.
1233:              *
1234:              * Note(s)     : (1) String buffer NOT modified.
1235:              *
1236:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1237:              *
1238:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1239:              *                            ... in the string pointed to by 's' ('pstr')."
1240:              *                       (2) "The terminating null byte is considered to be part of the string."
1241:              *
1242:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1243:              *                       "upon completion, strchr() shall return" :
1244:              *
1245:              *                       (1) "a pointer to the byte," ...
1246:              *                       (2) "or a null pointer if the byte was not found."
1247:              *                           (A) #### Although NO strchr() specification states to return NULL for
1248:              *                               any other reason(s), NULL is also returned for any error(s).
1249:              *
1250:              *               (3) String search terminates when :
1251:              *
1252:              *                   (a) String pointer passed a NULL pointer.
1253:              *                       (1) No string search performed; NULL pointer returned.
1254:              *
1255:              *                   (b) String pointer points to NULL.
1256:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1257:              *
1258:              *                   (c) String's terminating NULL character found.
1259:              *                       (1) Search character NOT found in search string; NULL pointer returned
1260:              *                           (see Note #2b2).
1261:              *                       (2) Applicable even if search character is the terminating NULL character
1262:              *                           (see Note #2a2).
1263:              *
1264:              *                   (d) Search character found.
1265:              *                       (1) Return pointer to first occurrence of search character in search string
1266:              *                           (see Note #2a1).
1267:              *********************************************************************************************************
1268:              */
1269:              
1270:              CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
1271:                                          CPU_CHAR   srch_char)
1272:              {
003E2A  FA0006     LNK #0x6
003E2C  980710     MOV W0, [W14+2]
003E2E  984741     MOV.B W1, [W14+4]
1273:                  CPU_CHAR  *pstr_rtn;
1274:              
1275:              
1276:                  pstr_rtn = Str_Char_N(pstr,
003E30  90414E     MOV.B [W14+4], W2
003E32  EB8080     SETM W1
003E34  90001E     MOV [W14+2], W0
003E36  070004     RCALL Str_Char_N
003E38  780F00     MOV W0, [W14]
1277:                                        DEF_INT_CPU_U_MAX_VAL,
1278:                                        srch_char);
1279:              
1280:                  return (pstr_rtn);
003E3A  78001E     MOV [W14], W0
1281:              }
003E3C  FA8000     ULNK
003E3E  060000     RETURN
1282:              
1283:              
1284:              /*
1285:              *********************************************************************************************************
1286:              *                                            Str_Char_N()
1287:              *
1288:              * Description : Search string for first occurrence of specific character, up to a maximum number
1289:              *                   of characters.
1290:              *
1291:              * Argument(s) : pstr            Pointer to string (see Note #1).
1292:              *
1293:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1294:              *
1295:              *               srch_char       Search character.
1296:              *
1297:              * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
1298:              *
1299:              *               Pointer to NULL,                                           otherwise (see Note #2b2).
1300:              *
1301:              * Caller(s)   : Application.
1302:              *
1303:              * Note(s)     : (1) String buffer NOT modified.
1304:              *
1305:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
1306:              *
1307:              *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
1308:              *                            ... in the string pointed to by 's' ('pstr')."
1309:              *                       (2) "The terminating null byte is considered to be part of the string."
1310:              *
1311:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
1312:              *                       "upon completion, strchr() shall return" :
1313:              *
1314:              *                       (1) "a pointer to the byte," ...
1315:              *                       (2) "or a null pointer if the byte was not found."
1316:              *                           (A) #### Although NO strchr() specification states to return NULL for
1317:              *                               any other reason(s), NULL is also returned for any error(s).
1318:              *
1319:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1320:              *                       argument list for consistency with all other custom string library functions.
1321:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1322:              *                       to comply with most standard library's strnchr() argument list.
1323:              *
1324:              *               (3) String search terminates when :
1325:              *
1326:              *                   (a) String pointer passed a NULL pointer.
1327:              *                       (1) No string search performed; NULL pointer returned.
1328:              *
1329:              *                   (b) String pointer points to NULL.
1330:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1331:              *
1332:              *                   (c) String's terminating NULL character found.
1333:              *                       (1) Search character NOT found in search string; NULL pointer returned
1334:              *                           (see Note #2b2).
1335:              *                       (2) Applicable even if search character is the terminating NULL character
1336:              *                           (see Note #2a2).
1337:              *
1338:              *                   (d) Search character found.
1339:              *                       (1) Return pointer to first occurrence of search character in search string
1340:              *                           (see Note #2a1).
1341:              *
1342:              *                   (e) 'len_max' number of characters searched.
1343:              *                       (1) Search character NOT found in search string within first 'len_max' number
1344:              *                           of characters; NULL pointer returned.
1345:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1346:              *                           (see Note #2a2).
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
1351:                                            CPU_SIZE_T   len_max,
1352:                                            CPU_CHAR     srch_char)
1353:              {
003E40  FA000A     LNK #0xA
003E42  980720     MOV W0, [W14+4]
003E44  980731     MOV W1, [W14+6]
003E46  984F02     MOV.B W2, [W14+8]
1354:                  const  CPU_CHAR    *pstr_char;
1355:                         CPU_SIZE_T   len_srch;
1356:              
1357:              
1358:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
003E48  90002E     MOV [W14+4], W0
003E4A  E00000     CP0 W0
003E4C  3A0002     BRA NZ, 0x3E52
1359:                      return ((CPU_CHAR *)0);
003E4E  EB0000     CLR W0
003E50  370031     BRA 0x3EB4
1360:                  }
1361:              
1362:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
003E52  90003E     MOV [W14+6], W0
003E54  E00000     CP0 W0
003E56  3A0002     BRA NZ, 0x3E5C
1363:                      return ((CPU_CHAR *)0);
003E58  EB0000     CLR W0
003E5A  37002C     BRA 0x3EB4
1364:                  }
1365:              
1366:              
1367:                  pstr_char = pstr;
003E5C  9000AE     MOV [W14+4], W1
003E5E  780F01     MOV W1, [W14]
1368:                  len_srch  = 0u;
003E60  EB0000     CLR W0
003E62  980710     MOV W0, [W14+2]
1369:              
1370:                  while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
003E64  370004     BRA 0x3E6E
003E6E  78001E     MOV [W14], W0
003E70  E00000     CP0 W0
003E72  32000D     BRA Z, 0x3E8E
003E78  E00400     CP0.B W0
003E7A  320009     BRA Z, 0x3E8E
1371:                         (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
003E74  78001E     MOV [W14], W0
003E76  784010     MOV.B [W0], W0
003E80  90480E     MOV.B [W14+8], W0
003E82  50CF80     SUB.B W1, W0, [W15]
003E84  320004     BRA Z, 0x3E8E
1372:                         (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
003E7C  78001E     MOV [W14], W0
003E7E  784090     MOV.B [W0], W1
003E86  90009E     MOV [W14+2], W1
003E88  90003E     MOV [W14+6], W0
003E8A  508F80     SUB W1, W0, [W15]
003E8C  39FFEC     BRA NC, 0x3E66
1373:                         ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
1374:                      pstr_char++;
003E66  E80F1E     INC [W14], [W14]
1375:                      len_srch++;
003E68  90001E     MOV [W14+2], W0
003E6A  E80000     INC W0, W0
003E6C  980710     MOV W0, [W14+2]
1376:                  }
1377:              
1378:              
1379:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
003E8E  78001E     MOV [W14], W0
003E90  E00000     CP0 W0
003E92  3A0002     BRA NZ, 0x3E98
1380:                      return ((CPU_CHAR *)0);
003E94  EB0000     CLR W0
003E96  37000E     BRA 0x3EB4
1381:                  }
1382:              
1383:                  if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
003E98  90009E     MOV [W14+2], W1
003E9A  90003E     MOV [W14+6], W0
003E9C  508F80     SUB W1, W0, [W15]
003E9E  390002     BRA NC, 0x3EA4
1384:                      return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
003EA0  EB0000     CLR W0
003EA2  370008     BRA 0x3EB4
1385:                  }
1386:              
1387:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
003EA4  78001E     MOV [W14], W0
003EA6  784090     MOV.B [W0], W1
003EA8  90480E     MOV.B [W14+8], W0
003EAA  50CF80     SUB.B W1, W0, [W15]
003EAC  320002     BRA Z, 0x3EB2
1388:                       return ((CPU_CHAR *)0);
003EAE  EB0000     CLR W0
003EB0  370001     BRA 0x3EB4
1389:                  }
1390:              
1391:              
1392:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
003EB2  78001E     MOV [W14], W0
1393:              }
003EB4  FA8000     ULNK
003EB6  060000     RETURN
1394:              
1395:              
1396:              /*
1397:              *********************************************************************************************************
1398:              *                                           Str_Char_Last()
1399:              *
1400:              * Description : Search string for last occurrence of specific character.
1401:              *
1402:              * Argument(s) : pstr            Pointer to string (see Note #1).
1403:              *
1404:              *               srch_char       Search character.
1405:              *
1406:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1407:              *
1408:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1409:              *
1410:              * Caller(s)   : Application.
1411:              *
1412:              * Note(s)     : (1) String buffer NOT modified.
1413:              *
1414:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1415:              *
1416:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1417:              *                            ... in the string pointed to by 's' ('pstr')."
1418:              *                       (2) "The terminating null byte is considered to be part of the string."
1419:              *
1420:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1421:              *                       "upon successful completion, strrchr() shall return" :
1422:              *
1423:              *                       (1) "a pointer to the byte" ...
1424:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1425:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1426:              *                               any other reason(s), NULL is also returned for any error(s).
1427:              *
1428:              *               (3) String search terminates when :
1429:              *
1430:              *                   (a) String pointer passed a NULL pointer.
1431:              *                       (1) No string search performed; NULL pointer returned.
1432:              *
1433:              *                   (b) String pointer points to NULL.
1434:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1435:              *
1436:              *                   (c) String searched from end to beginning.
1437:              *                       (1) Search character NOT found in search string; NULL pointer returned.
1438:              *                       (2) Applicable even if search character is the terminating NULL character
1439:              *                           (see Note #2a2).
1440:              *
1441:              *                   (d) Search character found.
1442:              *                       (1) Return pointer to last occurrence of search character in search string
1443:              *                           (see Note #2a1).
1444:              *********************************************************************************************************
1445:              */
1446:              
1447:              CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
1448:                                               CPU_CHAR   srch_char)
1449:              {
003EB8  FA0006     LNK #0x6
003EBA  980710     MOV W0, [W14+2]
003EBC  984741     MOV.B W1, [W14+4]
1450:                  CPU_CHAR  *pstr_rtn;
1451:              
1452:              
1453:                  pstr_rtn = Str_Char_Last_N(pstr,
003EBE  90414E     MOV.B [W14+4], W2
003EC0  EB8080     SETM W1
003EC2  90001E     MOV [W14+2], W0
003EC4  070004     RCALL Str_Char_Last_N
003EC6  780F00     MOV W0, [W14]
1454:                                             DEF_INT_CPU_U_MAX_VAL,
1455:                                             srch_char);
1456:              
1457:                  return (pstr_rtn);
003EC8  78001E     MOV [W14], W0
1458:              }
003ECA  FA8000     ULNK
003ECC  060000     RETURN
1459:              
1460:              
1461:              /*
1462:              *********************************************************************************************************
1463:              *                                          Str_Char_Last_N()
1464:              *
1465:              * Description : Search string for last occurrence of specific character, up to a maximum number
1466:              *                   of characters.
1467:              *
1468:              * Argument(s) : pstr            Pointer to string (see Note #1).
1469:              *
1470:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1471:              *
1472:              *               srch_char       Search character.
1473:              *
1474:              * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
1475:              *
1476:              *               Pointer to NULL,                                          otherwise (see Note #2b2).
1477:              *
1478:              * Caller(s)   : Application.
1479:              *
1480:              * Note(s)     : (1) String buffer NOT modified.
1481:              *
1482:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
1483:              *
1484:              *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
1485:              *                            ... in the string pointed to by 's' ('pstr')."
1486:              *                       (2) "The terminating null byte is considered to be part of the string."
1487:              *
1488:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
1489:              *                       "upon successful completion, strrchr() shall return" :
1490:              *
1491:              *                       (1) "a pointer to the byte" ...
1492:              *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
1493:              *                           (A) #### Although NO strrchr() specification states to return NULL for
1494:              *                               any other reason(s), NULL is also returned for any error(s).
1495:              *
1496:              *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
1497:              *                       argument list for consistency with all other custom string library functions.
1498:              *                       However, the 'len_max' argument is sequentially ordered as the second argument
1499:              *                       to comply with most standard library's strnrchr() argument list.
1500:              *
1501:              *                       See also 'Str_Char_N()  Note #2c'.
1502:              *
1503:              *               (3) String search terminates when :
1504:              *
1505:              *                   (a) String pointer passed a NULL pointer.
1506:              *                       (1) No string search performed; NULL pointer returned.
1507:              *
1508:              *                   (b) String pointer points to NULL.
1509:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1510:              *
1511:              *                   (c) String searched from end to beginning.
1512:              *                       (1) Search character NOT found in search string; NULL pointer returned
1513:              *                           (see Note #2b2).
1514:              *                       (2) Applicable even if search character is the terminating NULL character
1515:              *                           (see Note #2a2).
1516:              *
1517:              *                   (d) Search character found.
1518:              *                       (1) Return pointer to last occurrence of search character in search string
1519:              *                           (see Note #2a1).
1520:              *
1521:              *                   (e) 'len_max' number of characters searched.
1522:              *                       (1) Search character NOT found in search string within last 'len_max' number
1523:              *                           of characters; NULL pointer returned.
1524:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1525:              *                           (see Note #2a2).
1526:              *********************************************************************************************************
1527:              */
1528:              
1529:              CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
1530:                                                 CPU_SIZE_T   len_max,
1531:                                                 CPU_CHAR     srch_char)
1532:              {
003ECE  FA000C     LNK #0xC
003ED0  980730     MOV W0, [W14+6]
003ED2  980741     MOV W1, [W14+8]
003ED4  984F22     MOV.B W2, [W14+10]
1533:                  const  CPU_CHAR    *pstr_char;
1534:                         CPU_SIZE_T   str_len_max;
1535:                         CPU_SIZE_T   str_len;
1536:              
1537:              
1538:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
003ED6  90003E     MOV [W14+6], W0
003ED8  E00000     CP0 W0
003EDA  3A0002     BRA NZ, 0x3EE0
1539:                      return ((CPU_CHAR *)0);
003EDC  EB0000     CLR W0
003EDE  370027     BRA 0x3F2E
1540:                  }
1541:              
1542:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
003EE0  90004E     MOV [W14+8], W0
003EE2  E00000     CP0 W0
003EE4  3A0002     BRA NZ, 0x3EEA
1543:                      return ((CPU_CHAR *)0);
003EE6  EB0000     CLR W0
003EE8  370022     BRA 0x3F2E
1544:                  }
1545:              
1546:              
1547:                  pstr_char    = pstr;
003EEA  9000BE     MOV [W14+6], W1
003EEC  780F01     MOV W1, [W14]
1548:                   str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
003EEE  90004E     MOV [W14+8], W0
003EF0  E90000     DEC W0, W0
003EF2  980710     MOV W0, [W14+2]
1549:                   str_len     = Str_Len_N(pstr_char, str_len_max);
003EF4  90009E     MOV [W14+2], W1
003EF6  78001E     MOV [W14], W0
003EF8  07FDA4     RCALL Str_Len_N
003EFA  980720     MOV W0, [W14+4]
1550:                  pstr_char   += str_len;
003EFC  90002E     MOV [W14+4], W0
003EFE  400F1E     ADD W0, [W14], [W14]
1551:              
1552:                  if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
003F00  78001E     MOV [W14], W0
003F02  E00000     CP0 W0
003F04  3A0003     BRA NZ, 0x3F0C
1553:                      return ((CPU_CHAR *)0);
003F06  EB0000     CLR W0
003F08  370012     BRA 0x3F2E
1554:                  }
1555:              
1556:                  while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
003F0C  90003E     MOV [W14+6], W0
003F0E  78009E     MOV [W14], W1
003F10  508F80     SUB W1, W0, [W15]
003F12  320005     BRA Z, 0x3F1E
003F18  90482E     MOV.B [W14+10], W0
003F1A  50CF80     SUB.B W1, W0, [W15]
003F1C  3AFFF6     BRA NZ, 0x3F0A
1557:                         (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
003F14  78001E     MOV [W14], W0
003F16  784090     MOV.B [W0], W1
1558:                      pstr_char--;
003F0A  E90F1E     DEC [W14], [W14]
1559:                  }
1560:              
1561:              
1562:                  if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
003F1E  78001E     MOV [W14], W0
003F20  784090     MOV.B [W0], W1
003F22  90482E     MOV.B [W14+10], W0
003F24  50CF80     SUB.B W1, W0, [W15]
003F26  320002     BRA Z, 0x3F2C
1563:                       return ((CPU_CHAR *)0);
003F28  EB0000     CLR W0
003F2A  370001     BRA 0x3F2E
1564:                  }
1565:              
1566:              
1567:                  return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
003F2C  78001E     MOV [W14], W0
1568:              }
003F2E  FA8000     ULNK
003F30  060000     RETURN
1569:              
1570:              
1571:              /*
1572:              *********************************************************************************************************
1573:              *                                         Str_Char_Replace()
1574:              *
1575:              * Description : Search string for specific character and replace it by another specific character.
1576:              *
1577:              * Argument(s) : pstr            Pointer to string (see Note #1).
1578:              *
1579:              *               char_srch       Search character.
1580:              *
1581:              *               char_replace    Replace character.
1582:              *
1583:              * Return(s)   : Pointer to string, if NO error(s).
1584:              *
1585:              *               Pointer to NULL,   otherwise.
1586:              *
1587:              * Caller(s)   : Application.
1588:              *
1589:              * Note(s)     : (1) String buffer modified.
1590:              *
1591:              *               (2) String search terminates when :
1592:              *
1593:              *                   (a) String pointer passed a NULL pointer.
1594:              *                       (1) No string search performed; NULL pointer returned.
1595:              *
1596:              *                   (b) String pointer points to NULL.
1597:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1598:              *
1599:              *                   (c) String's terminating NULL character found.
1600:              *                       (1) Search character NOT found in search string; NULL pointer returned
1601:              *                       (2) Applicable even if search character is the terminating NULL character
1602:              *
1603:              *                   (d) Search character found.
1604:              *                       (1) Replace character found by the specified character.
1605:              *********************************************************************************************************
1606:              */
1607:              
1608:              CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
1609:                                           CPU_CHAR   char_srch,
1610:                                           CPU_CHAR   char_replace)
1611:              {
003F32  FA0006     LNK #0x6
003F34  980710     MOV W0, [W14+2]
003F36  984741     MOV.B W1, [W14+4]
003F38  984752     MOV.B W2, [W14+5]
1612:                  CPU_CHAR  *pstr_rtn;
1613:              
1614:              
1615:                  pstr_rtn = Str_Char_Replace_N(pstr,
003F3A  EB8180     SETM W3
003F3C  90415E     MOV.B [W14+5], W2
003F3E  9040CE     MOV.B [W14+4], W1
003F40  90001E     MOV [W14+2], W0
003F42  070004     RCALL Str_Char_Replace_N
003F44  780F00     MOV W0, [W14]
1616:                                                char_srch,
1617:                                                char_replace,
1618:                                                DEF_INT_CPU_U_MAX_VAL);
1619:              
1620:                  return (pstr_rtn);
003F46  78001E     MOV [W14], W0
1621:              }
003F48  FA8000     ULNK
003F4A  060000     RETURN
1622:              
1623:              
1624:              /*
1625:              *********************************************************************************************************
1626:              *                                        Str_Char_Replace_N()
1627:              *
1628:              * Description : Search string for specific character and replace it by another specific character, up to
1629:              *               a maximum number of characters.
1630:              *
1631:              * Argument(s) : pstr            Pointer to string (see Note #1).
1632:              *
1633:              *               char_srch       Search character.
1634:              *
1635:              *               char_replace    Replace character.
1636:              *
1637:              *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
1638:              *
1639:              * Return(s)   : Pointer to string, if NO error(s).
1640:              *
1641:              *               Pointer to NULL,   otherwise.
1642:              *
1643:              * Caller(s)   : Application.
1644:              *
1645:              * Note(s)     : (1) String buffer modified.
1646:              *
1647:              *               (2) String search terminates when :
1648:              *
1649:              *                   (a) String pointer passed a NULL pointer.
1650:              *                       (1) No string search performed; NULL pointer returned.
1651:              *
1652:              *                   (b) String pointer points to NULL.
1653:              *                       (1) String overlaps with NULL address; NULL pointer returned.
1654:              *
1655:              *                   (c) String's terminating NULL character found.
1656:              *                       (1) Search character NOT found in search string; NULL pointer returned
1657:              *                       (2) Applicable even if search character is the terminating NULL character
1658:              *
1659:              *                   (d) Search character found.
1660:              *                       (1) Replace character found by the specified character.
1661:              *
1662:              *                   (e) 'len_max' number of characters searched.
1663:              *                       (1) Search character NOT found in search string within first 'len_max' number
1664:              *                           of characters; NULL pointer returned.
1665:              *                       (2) 'len_max' number of characters MAY include terminating NULL character
1666:              *                           (see Note #2a2).
1667:              *********************************************************************************************************
1668:              */
1669:              
1670:              CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
1671:                                             CPU_CHAR     char_srch,
1672:                                             CPU_CHAR     char_replace,
1673:                                             CPU_SIZE_T   len_max)
1674:              {
003F4C  FA000A     LNK #0xA
003F4E  980720     MOV W0, [W14+4]
003F50  984761     MOV.B W1, [W14+6]
003F52  984772     MOV.B W2, [W14+7]
003F54  980743     MOV W3, [W14+8]
1675:                  CPU_CHAR    *pstr_char;
1676:                  CPU_SIZE_T   len;
1677:              
1678:              
1679:                  if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
003F56  90002E     MOV [W14+4], W0
003F58  E00000     CP0 W0
003F5A  3A0002     BRA NZ, 0x3F60
1680:                      return ((CPU_CHAR *)0);
003F5C  EB0000     CLR W0
003F5E  370021     BRA 0x3FA2
1681:                  }
1682:              
1683:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
003F60  90004E     MOV [W14+8], W0
003F62  E00000     CP0 W0
003F64  3A0002     BRA NZ, 0x3F6A
1684:                      return ((CPU_CHAR *)0);
003F66  EB0000     CLR W0
003F68  37001C     BRA 0x3FA2
1685:                  }
1686:              
1687:                  pstr_char = pstr;
003F6A  9000AE     MOV [W14+4], W1
003F6C  780F01     MOV W1, [W14]
1688:                  len       = len_max;
003F6E  9000CE     MOV [W14+8], W1
003F70  980711     MOV W1, [W14+2]
1689:              
1690:                  while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
003F72  37000C     BRA 0x3F8C
003F8C  78001E     MOV [W14], W0
003F8E  E00000     CP0 W0
003F90  320007     BRA Z, 0x3FA0
003F96  E00400     CP0.B W0
003F98  320003     BRA Z, 0x3FA0
1691:                         (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
003F92  78001E     MOV [W14], W0
003F94  784010     MOV.B [W0], W0
003F9A  90001E     MOV [W14+2], W0
003F9C  E00000     CP0 W0
003F9E  3AFFEA     BRA NZ, 0x3F74
1692:                         ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
1693:              
1694:                      if (*pstr_char == char_srch) {
003F74  78001E     MOV [W14], W0
003F76  784090     MOV.B [W0], W1
003F78  90406E     MOV.B [W14+6], W0
003F7A  50CF80     SUB.B W1, W0, [W15]
003F7C  3A0003     BRA NZ, 0x3F84
1695:                          *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
003F7E  78001E     MOV [W14], W0
003F80  9040FE     MOV.B [W14+7], W1
003F82  784801     MOV.B W1, [W0]
1696:                      }
1697:              
1698:                      pstr_char++;
003F84  E80F1E     INC [W14], [W14]
1699:                      len--;
003F86  90001E     MOV [W14+2], W0
003F88  E90000     DEC W0, W0
003F8A  980710     MOV W0, [W14+2]
1700:                  }
1701:              
1702:                  return (pstr);
003FA0  90002E     MOV [W14+4], W0
1703:              }
003FA2  FA8000     ULNK
003FA4  060000     RETURN
1704:              
1705:              
1706:              /*
1707:              *********************************************************************************************************
1708:              *                                              Str_Str()
1709:              *
1710:              * Description : Search string for first occurence of a specific search string.
1711:              *
1712:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1713:              *
1714:              *               pstr_srch       Pointer to search string (see Note #1).
1715:              *
1716:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1717:              *
1718:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1719:              *
1720:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1721:              *
1722:              * Caller(s)   : Application.
1723:              *
1724:              * Note(s)     : (1) String buffers NOT modified.
1725:              *
1726:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1727:              *
1728:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1729:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1730:              *                            pointed to by 's2' ('pstr_srch')" ...
1731:              *                       (2) "(excluding the terminating null byte)."
1732:              *
1733:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1734:              *
1735:              *                       (1) "Upon successful completion, strstr() shall return" :
1736:              *                           (A) "a pointer to the located string" ...
1737:              *                           (B) "or a null pointer if the string is not found."
1738:              *                               (1) #### Although NO strstr() specification states to return NULL for
1739:              *                                   any other reason(s), NULL is also returned for any error(s).
1740:              *
1741:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1742:              *                            shall return 's1' ('pstr')."
1743:              *
1744:              *               (3) String search terminates when :
1745:              *
1746:              *                   (a) String pointer(s) are passed NULL pointers.
1747:              *                       (1) No string search performed; NULL pointer returned.
1748:              *
1749:              *                   (b) String pointer(s) point to NULL.
1750:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1751:              *
1752:              *                   (c) Search string length equal to zero.
1753:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1754:              *
1755:              *                   (d) Search string length greater than string length.
1756:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1757:              *
1758:              *                   (e) Entire string has been searched.
1759:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1760:              *
1761:              *                   (f) Search string found.
1762:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1763:              *********************************************************************************************************
1764:              */
1765:              
1766:              CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
1767:                                  const  CPU_CHAR  *pstr_srch)
1768:              {
003FA6  FA0006     LNK #0x6
003FA8  980710     MOV W0, [W14+2]
003FAA  980721     MOV W1, [W14+4]
1769:                  CPU_CHAR  *pstr_rtn;
1770:              
1771:              
1772:                  pstr_rtn = Str_Str_N(pstr,
003FAC  EB8100     SETM W2
003FAE  9000AE     MOV [W14+4], W1
003FB0  90001E     MOV [W14+2], W0
003FB2  070004     RCALL Str_Str_N
003FB4  780F00     MOV W0, [W14]
1773:                                       pstr_srch,
1774:                                       DEF_INT_CPU_U_MAX_VAL);
1775:              
1776:                  return (pstr_rtn);
003FB6  78001E     MOV [W14], W0
1777:              }
003FB8  FA8000     ULNK
003FBA  060000     RETURN
1778:              
1779:              
1780:              /*
1781:              *********************************************************************************************************
1782:              *                                             Str_Str_N()
1783:              *
1784:              * Description : Search string for first occurence of a specific search string, up to a maximum number
1785:              *                   of characters.
1786:              *
1787:              * Argument(s) : pstr            Pointer to        string (see Note #1).
1788:              *
1789:              *               pstr_srch       Pointer to search string (see Note #1).
1790:              *
1791:              *               len_max         Maximum number of characters to search (see Note #3g).
1792:              *
1793:              * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
1794:              *
1795:              *               Pointer to string,                                      if NULL search string (see Note #2b2).
1796:              *
1797:              *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
1798:              *
1799:              * Caller(s)   : Application.
1800:              *
1801:              * Note(s)     : (1) String buffers NOT modified.
1802:              *
1803:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
1804:              *
1805:              *                       (1) "The strstr() function shall locate the first occurrence  in the string
1806:              *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
1807:              *                            pointed to by 's2' ('pstr_srch')" ...
1808:              *                       (2) "(excluding the terminating null byte)."
1809:              *
1810:              *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
1811:              *
1812:              *                       (1) "Upon successful completion, strstr() shall return" :
1813:              *                           (A) "a pointer to the located string" ...
1814:              *                           (B) "or a null pointer if the string is not found."
1815:              *                               (1) #### Although NO strstr() specification states to return NULL for
1816:              *                                   any other reason(s), NULL is also returned for any error(s).
1817:              *
1818:              *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
1819:              *                            shall return 's1' ('pstr')."
1820:              *
1821:              *               (3) String search terminates when :
1822:              *
1823:              *                   (a) String pointer(s) are passed NULL pointers.
1824:              *                       (1) No string search performed; NULL pointer returned.
1825:              *
1826:              *                   (b) String pointer(s) point to NULL.
1827:              *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
1828:              *
1829:              *                   (c) Search string length equal to zero.
1830:              *                       (1) No string search performed; string pointer returned (see Note #2b2).
1831:              *
1832:              *                   (d) Search string length greater than string length.
1833:              *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
1834:              *
1835:              *                   (e) Entire string has been searched.
1836:              *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
1837:              *                       (2) Maximum size of the search is defined as the subtraction of the
1838:              *                           search string length from the string length.
1839:              *
1840:              *                   (f) Search string found.
1841:              *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
1842:              *                       (2) Search string found via Str_Cmp_N().
1843:              *
1844:              *                   (g) 'len_max' number of characters searched.
1845:              *                       (1) 'len_max' number of characters does NOT include terminating NULL character
1846:              *                           (see Note #2a2).
1847:              *********************************************************************************************************
1848:              */
1849:              
1850:              CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
1851:                                    const  CPU_CHAR    *pstr_srch,
1852:                                           CPU_SIZE_T   len_max)
1853:              {
003FBC  FA0018     LNK #0x18
003FBE  980F10     MOV W0, [W14+18]
003FC0  980F21     MOV W1, [W14+20]
003FC2  980F32     MOV W2, [W14+22]
1854:                         CPU_SIZE_T    str_len;
1855:                         CPU_SIZE_T    str_len_srch;
1856:                         CPU_SIZE_T    len_max_srch;
1857:                         CPU_SIZE_T    srch_len;
1858:                         CPU_SIZE_T    srch_ix;
1859:                         CPU_BOOLEAN   srch_done;
1860:                         CPU_INT16S    srch_cmp;
1861:                  const  CPU_CHAR     *pstr_str;
1862:                  const  CPU_CHAR     *pstr_srch_ix;
1863:              
1864:                                                                              /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
1865:                  if (pstr == (const CPU_CHAR *)0) {
003FC4  90081E     MOV [W14+18], W0
003FC6  E00000     CP0 W0
003FC8  3A0002     BRA NZ, 0x3FCE
1866:                      return ((CPU_CHAR *)0);
003FCA  EB0000     CLR W0
003FCC  37005C     BRA 0x4086
1867:                  }
1868:                  if (pstr_srch == (const CPU_CHAR *)0) {
003FCE  90082E     MOV [W14+20], W0
003FD0  E00000     CP0 W0
003FD2  3A0002     BRA NZ, 0x3FD8
1869:                      return ((CPU_CHAR *)0);
003FD4  EB0000     CLR W0
003FD6  370057     BRA 0x4086
1870:                  }
1871:              
1872:                  if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
003FD8  90083E     MOV [W14+22], W0
003FDA  E00000     CP0 W0
003FDC  3A0002     BRA NZ, 0x3FE2
1873:                      return ((CPU_CHAR *)0);
003FDE  EB0000     CLR W0
003FE0  370052     BRA 0x4086
1874:                  }
1875:              
1876:                                                                              /* Lim max srch str len (to chk > str len).             */
1877:                  len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
003FF0  980710     MOV W0, [W14+2]
1878:                               ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
003FE2  90083E     MOV [W14+22], W0
003FE4  400FE1     ADD W0, #0x1, [W15]
003FE6  320003     BRA Z, 0x3FEE
003FE8  90083E     MOV [W14+22], W0
003FEA  E80000     INC W0, W0
003FEC  370001     BRA 0x3FF0
003FEE  EB8000     SETM W0
1879:              
1880:                  str_len      = Str_Len_N(pstr,      len_max);
003FF2  9008BE     MOV [W14+22], W1
003FF4  90081E     MOV [W14+18], W0
003FF6  07FD25     RCALL Str_Len_N
003FF8  980720     MOV W0, [W14+4]
1881:                  str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
003FFA  90009E     MOV [W14+2], W1
003FFC  90082E     MOV [W14+20], W0
003FFE  07FD21     RCALL Str_Len_N
004000  980730     MOV W0, [W14+6]
1882:                  if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
004002  90003E     MOV [W14+6], W0
004004  E00000     CP0 W0
004006  3A0002     BRA NZ, 0x400C
1883:                      return ((CPU_CHAR *)pstr);
004008  90081E     MOV [W14+18], W0
00400A  37003D     BRA 0x4086
1884:                  }
1885:                  if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
00400C  9000BE     MOV [W14+6], W1
00400E  90002E     MOV [W14+4], W0
004010  508F80     SUB W1, W0, [W15]
004012  360002     BRA LEU, 0x4018
1886:                      return ((CPU_CHAR *)0);
004014  EB0000     CLR W0
004016  370037     BRA 0x4086
1887:                  }
1888:                                                                              /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
1889:                  pstr_str = pstr      + str_len;
004018  90089E     MOV [W14+18], W1
00401A  90002E     MOV [W14+4], W0
00401C  408000     ADD W1, W0, W0
00401E  980740     MOV W0, [W14+8]
1890:                  if (pstr_str == (const CPU_CHAR *)0) {
004020  90004E     MOV [W14+8], W0
004022  E00000     CP0 W0
004024  3A0002     BRA NZ, 0x402A
1891:                      return ((CPU_CHAR *)0);
004026  EB0000     CLR W0
004028  37002E     BRA 0x4086
1892:                  }
1893:                  pstr_str = pstr_srch + str_len_srch;
00402A  9008AE     MOV [W14+20], W1
00402C  90003E     MOV [W14+6], W0
00402E  408000     ADD W1, W0, W0
004030  980740     MOV W0, [W14+8]
1894:                  if (pstr_str == (const CPU_CHAR *)0) {
004032  90004E     MOV [W14+8], W0
004034  E00000     CP0 W0
004036  3A0002     BRA NZ, 0x403C
1895:                      return ((CPU_CHAR *)0);
004038  EB0000     CLR W0
00403A  370025     BRA 0x4086
1896:                  }
1897:              
1898:              
1899:                  srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
00403C  9000AE     MOV [W14+4], W1
00403E  90003E     MOV [W14+6], W0
004040  508000     SUB W1, W0, W0
004042  980750     MOV W0, [W14+10]
1900:                  srch_ix   = 0u;
004044  EB0000     CLR W0
004046  780F00     MOV W0, [W14]
1901:                  srch_done = DEF_NO;
004048  EB4000     CLR.B W0
00404A  984F40     MOV.B W0, [W14+12]
1902:              
1903:                  do {
1904:                      pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
00404C  90081E     MOV [W14+18], W0
00404E  40001E     ADD W0, [W14], W0
004050  980770     MOV W0, [W14+14]
1905:                      srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
004052  90013E     MOV [W14+6], W2
004054  9008AE     MOV [W14+20], W1
004056  90007E     MOV [W14+14], W0
004058  07FDBE     RCALL Str_Cmp_N
00405A  980F00     MOV W0, [W14+16]
1906:                      srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
00405C  90080E     MOV [W14+16], W0
00405E  E00000     CP0 W0
004060  3A0002     BRA NZ, 0x4066
004062  B3C010     MOV.B #0x1, W0
004064  370001     BRA 0x4068
004066  EB4000     CLR.B W0
004068  984F40     MOV.B W0, [W14+12]
1907:                      srch_ix++;
00406A  E80F1E     INC [W14], [W14]
1908:                  } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
00406C  90484E     MOV.B [W14+12], W0
00406E  E00400     CP0.B W0
004070  3A0004     BRA NZ, 0x407A
004072  90005E     MOV [W14+10], W0
004074  78009E     MOV [W14], W1
004076  508F80     SUB W1, W0, [W15]
004078  36FFE9     BRA LEU, 0x404C
1909:              
1910:              
1911:                  if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
00407A  90080E     MOV [W14+16], W0
00407C  E00000     CP0 W0
00407E  320002     BRA Z, 0x4084
1912:                      return ((CPU_CHAR *)0);
004080  EB0000     CLR W0
004082  370001     BRA 0x4086
1913:                  }
1914:              
1915:                  return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
004084  90007E     MOV [W14+14], W0
1916:              }
004086  FA8000     ULNK
004088  060000     RETURN
1917:              
1918:              
1919:              /*
1920:              *********************************************************************************************************
1921:              *                                         Str_FmtNbr_Int32U()
1922:              *
1923:              * Description : Format 32-bit unsigned integer into a multi-digit character string.
1924:              *
1925:              * Argument(s) : nbr             Number           to format.
1926:              *
1927:              *               nbr_dig         Number of digits to format (see Note #1).
1928:              *
1929:              *                               The following may be used to specify the number of digits to format :
1930:              *
1931:              *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
1932:              *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
1933:              *
1934:              *               nbr_base        Base   of number to format (see Note #2).
1935:              *
1936:              *                               The following may be used to specify the number base :
1937:              *
1938:              *                                   DEF_NBR_BASE_BIN            Base  2
1939:              *                                   DEF_NBR_BASE_OCT            Base  8
1940:              *                                   DEF_NBR_BASE_DEC            Base 10
1941:              *                                   DEF_NBR_BASE_HEX            Base 16
1942:              *
1943:              *               lead_char       Prepend leading character  (see Note #3) :
1944:              *
1945:              *                                   '\0'                    Do NOT prepend leading character to string.
1946:              *                                     Printable character          Prepend leading character to string.
1947:              *                                   Unprintable character   Format invalid string (see Note #6).
1948:              *
1949:              *               lower_case      Format alphabetic characters (if any) in lower case :
1950:              *
1951:              *                                   DEF_NO          Format alphabetic characters in upper case.
1952:              *                                   DEF_YES         Format alphabetic characters in lower case.
1953:              *
1954:              *               nul             Append terminating NULL-character (see Note #4) :
1955:              *
1956:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
1957:              *                                   DEF_YES                Append terminating NULL-character to string.
1958:              *
1959:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
1960:              *
1961:              * Return(s)   : Pointer to formatted string, if NO error(s).
1962:              *
1963:              *               Pointer to NULL,             otherwise.
1964:              *
1965:              * Caller(s)   : Application.
1966:              *
1967:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
1968:              *                       is performed except possible NULL-termination of the string (see Note #4).
1969:              *
1970:              *                           Example :
1971:              *
1972:              *                               nbr      = 23456
1973:              *                               nbr_dig  = 0
1974:              *                               nbr_base = 10
1975:              *
1976:              *                               pstr     = ""                   See Note #6a
1977:              *
1978:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
1979:              *                       significant integer digits of the number to format ('nbr'); then an invalid
1980:              *                       string is formatted instead of truncating any significant integer digits.
1981:              *
1982:              *                           Example :
1983:              *
1984:              *                               nbr      = 23456
1985:              *                               nbr_dig  = 3
1986:              *                               nbr_base = 10
1987:              *
1988:              *                               pstr     = "???"                See Note #6b
1989:              *
1990:              *               (2) The number's base MUST be between 2 & 36, inclusive.
1991:              *$PAGE*
1992:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
1993:              *
1994:              *                   (a) (1) Leading character MUST be a printable ASCII character.
1995:              *
1996:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
1997:              *                           (B) with the exception of '0'.
1998:              *
1999:              *                   (b) The number of leading characters is such that the total number of significant
2000:              *                       integer digits plus the number of leading characters is equal to the requested
2001:              *                       number of integer digits to format ('nbr_dig').
2002:              *
2003:              *                           Example :
2004:              *
2005:              *                               nbr       = 23456
2006:              *                               nbr_dig   = 7
2007:              *                               nbr_base  = 10
2008:              *                               lead_char = ' '
2009:              *
2010:              *                               pstr      = "  23456"
2011:              *
2012:              *                   (c) (1) If the value of the number to format is     zero  ...
2013:              *                       (2) ... & the number of digits to format is non-zero, ...
2014:              *                       (3) ... but NO leading character available;           ...
2015:              *                       (4) ... then one digit of '0' value is formatted.
2016:              *
2017:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2018:              *
2019:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2020:              *                       array formatting.
2021:              *
2022:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2023:              *                       terminate option DISABLED will cause character string run-on.
2024:              *
2025:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2026:              *
2027:              *                   (b) To prevent character buffer overrun :
2028:              *
2029:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2030:              *                                                               1 'NUL' terminator)  characters
2031:              *
2032:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2033:              *                   ('?') will be formatted, where the number of question marks is determined by the
2034:              *                   number of digits to format ('nbr_dig') :
2035:              *
2036:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2037:              *                          number of     =  {
2038:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2039:              *
2040:              *********************************************************************************************************
2041:              */
2042:              
2043:              CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
2044:                                            CPU_INT08U    nbr_dig,
2045:                                            CPU_INT08U    nbr_base,
2046:                                            CPU_CHAR      lead_char,
2047:                                            CPU_BOOLEAN   lower_case,
2048:                                            CPU_BOOLEAN   nul,
2049:                                            CPU_CHAR     *pstr)
2050:              {
00408A  FA000E     LNK #0xE
00408C  980710     MOV W0, [W14+2]
00408E  980721     MOV W1, [W14+4]
004090  984762     MOV.B W2, [W14+6]
004092  984773     MOV.B W3, [W14+7]
004094  984F04     MOV.B W4, [W14+8]
004096  984F15     MOV.B W5, [W14+9]
004098  984F26     MOV.B W6, [W14+10]
00409A  980767     MOV W7, [W14+12]
2051:                  CPU_CHAR  *pstr_fmt;
2052:              
2053:              
2054:                  pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
00409C  9000EE     MOV [W14+12], W1
00409E  781F81     MOV W1, [W15++]
0040A0  904BAE     MOV.B [W14+10], W7
0040A2  904B1E     MOV.B [W14+9], W6
0040A4  904A8E     MOV.B [W14+8], W5
0040A6  EB4200     CLR.B W4
0040A8  9041FE     MOV.B [W14+7], W3
0040AA  90416E     MOV.B [W14+6], W2
0040AC  90001E     MOV [W14+2], W0
0040AE  9000AE     MOV [W14+4], W1
0040B0  070069     RCALL _Str_FmtNbr_Int32
0040B2  E9878F     DEC2 W15, W15
0040B4  780F00     MOV W0, [W14]
2055:                                              nbr_dig,
2056:                                              nbr_base,
2057:                                              DEF_NO,
2058:                                              lead_char,
2059:                                              lower_case,
2060:                                              nul,
2061:                                              pstr);
2062:              
2063:                  return (pstr_fmt);
0040B6  78001E     MOV [W14], W0
2064:              }
0040B8  FA8000     ULNK
0040BA  060000     RETURN
2065:              
2066:              
2067:              /*
2068:              *********************************************************************************************************
2069:              *                                         Str_FmtNbr_Int32S()
2070:              *
2071:              * Description : Format 32-bit signed integer into a multi-digit character string.
2072:              *
2073:              * Argument(s) : nbr             Number           to format.
2074:              *
2075:              *               nbr_dig         Number of digits to format (see Note #1).
2076:              *
2077:              *                               The following may be used to specify the number of digits to format :
2078:              *
2079:              *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
2080:              *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
2081:              *                                                                   (plus 1 digit for possible negative sign)
2082:              *
2083:              *               nbr_base        Base   of number to format (see Note #2).
2084:              *
2085:              *                               The following may be used to specify the number base :
2086:              *
2087:              *                                   DEF_NBR_BASE_BIN            Base  2
2088:              *                                   DEF_NBR_BASE_OCT            Base  8
2089:              *                                   DEF_NBR_BASE_DEC            Base 10
2090:              *                                   DEF_NBR_BASE_HEX            Base 16
2091:              *
2092:              *               lead_char       Prepend leading character  (see Note #3) :
2093:              *
2094:              *                                   '\0'                    Do NOT prepend leading character to string.
2095:              *                                     Printable character          Prepend leading character to string.
2096:              *                                   Unprintable character   Format invalid string (see Note #6).
2097:              *
2098:              *               lower_case      Format alphabetic characters (if any) in lower case :
2099:              *
2100:              *                                   DEF_NO          Format alphabetic characters in upper case.
2101:              *                                   DEF_YES         Format alphabetic characters in lower case.
2102:              *
2103:              *               nul             Append terminating NULL-character (see Note #4) :
2104:              *
2105:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2106:              *                                   DEF_YES                Append terminating NULL-character to string.
2107:              *
2108:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2109:              *
2110:              * Return(s)   : Pointer to formatted string, if NO error(s).
2111:              *
2112:              *               Pointer to NULL,             otherwise.
2113:              *
2114:              * Caller(s)   : Application.
2115:              *
2116:              * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
2117:              *                       is performed except possible NULL-termination of the string (see Note #4).
2118:              *
2119:              *                           Example :
2120:              *
2121:              *                               nbr      = -23456
2122:              *                               nbr_dig  =  0
2123:              *                               nbr_base = 10
2124:              *
2125:              *                               pstr     = ""                   See Note #6a
2126:              *
2127:              *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
2128:              *                       significant integer digits of the number to format ('nbr'); then an invalid
2129:              *                       string is formatted instead of truncating any significant integer digits.
2130:              *
2131:              *                           Example :
2132:              *
2133:              *                               nbr      = 23456
2134:              *                               nbr_dig  = 3
2135:              *                               nbr_base = 10
2136:              *
2137:              *                               pstr     = "???"                See Note #6b
2138:              *
2139:              *                   (c) If the number to format ('nbr') is negative but the number of digits to format
2140:              *                       ('nbr_dig') is equal to the number of significant integer digits of the number
2141:              *                       to format ('nbr'); then an invalid string is formatted instead of truncating
2142:              *                       the negative sign.
2143:              *
2144:              *                           Example :
2145:              *
2146:              *                               nbr      = -23456
2147:              *                               nbr_dig  =  5
2148:              *                               nbr_base = 10
2149:              *
2150:              *                               pstr     = "?????"              See Note #6b
2151:              *
2152:              *               (2) The number's base MUST be between 2 & 36, inclusive.
2153:              *$PAGE*
2154:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2155:              *
2156:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2157:              *
2158:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
2159:              *                           (B) with the exception of '0'.
2160:              *
2161:              *                   (b) (1) The number of leading characters is such that the total number of significant
2162:              *                           integer digits plus the number of leading characters plus possible negative
2163:              *                           sign character is equal to the requested number of integer digits to format
2164:              *                           ('nbr_dig').
2165:              *
2166:              *                               Examples :
2167:              *
2168:              *                                   nbr       = 23456
2169:              *                                   nbr_dig   = 7
2170:              *                                   nbr_base  = 10
2171:              *                                   lead_char = ' '
2172:              *
2173:              *                                   pstr      = "  23456"
2174:              *
2175:              *
2176:              *                                   nbr       = -23456
2177:              *                                   nbr_dig   =  7
2178:              *                                   nbr_base  = 10
2179:              *                                   lead_char = ' '
2180:              *
2181:              *                                   pstr      = " -23456"
2182:              *
2183:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2184:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2185:              *                               prefixes all leading characters prior to the formatted number.
2186:              *
2187:              *                                   Examples :
2188:              *
2189:              *                                       nbr        = -23456
2190:              *                                       nbr_dig    =  8
2191:              *                                       nbr_base   = 10
2192:              *                                       lead_char  = '0'
2193:              *
2194:              *                                       pstr       = "-0023456"
2195:              *
2196:              *
2197:              *                                       nbr        = -43981
2198:              *                                       nbr_dig    =  8
2199:              *                                       nbr_base   = 16
2200:              *                                       lead_char  = '0'
2201:              *                                       lower_case = DEF_NO
2202:              *
2203:              *                                       pstr       = "-000ABCD"
2204:              *
2205:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2206:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2207:              *                               immediately prefixes the most significant digit of the formatted number.
2208:              *
2209:              *                                   Examples :
2210:              *
2211:              *                                       nbr        = -23456
2212:              *                                       nbr_dig    =  8
2213:              *                                       nbr_base   = 10
2214:              *                                       lead_char  = '#'
2215:              *
2216:              *                                       pstr       = "##-23456"
2217:              *
2218:              *
2219:              *                                       nbr        = -43981
2220:              *                                       nbr_dig    =  8
2221:              *                                       nbr_base   = 16
2222:              *                                       lead_char  = '#'
2223:              *                                       lower_case = DEF_YES
2224:              *
2225:              *                                       pstr       = "###-abcd"
2226:              *
2227:              *                   (c) (1) If the value of the number to format is     zero  ...
2228:              *                       (2) ... & the number of digits to format is non-zero, ...
2229:              *                       (3) ... but NO leading character available;           ...
2230:              *                       (4) ... then one digit of '0' value is formatted.
2231:              *
2232:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2233:              *$PAGE*
2234:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2235:              *                       array formatting.
2236:              *
2237:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2238:              *                       terminate option DISABLED will cause character string run-on.
2239:              *
2240:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2241:              *
2242:              *                   (b) To prevent character buffer overrun :
2243:              *
2244:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2245:              *                                                               1 negative sign   +
2246:              *                                                               1 'NUL' terminator)  characters
2247:              *
2248:              *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
2249:              *                   ('?') will be formatted, where the number of question marks is determined by the
2250:              *                   number of digits to format ('nbr_dig') :
2251:              *
2252:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
2253:              *                          number of     =  {
2254:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
2255:              *
2256:              *********************************************************************************************************
2257:              */
2258:              
2259:              CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
2260:                                            CPU_INT08U    nbr_dig,
2261:                                            CPU_INT08U    nbr_base,
2262:                                            CPU_CHAR      lead_char,
2263:                                            CPU_BOOLEAN   lower_case,
2264:                                            CPU_BOOLEAN   nul,
2265:                                            CPU_CHAR     *pstr)
2266:              {
0040BC  FA0014     LNK #0x14
0040BE  980740     MOV W0, [W14+8]
0040C0  980751     MOV W1, [W14+10]
0040C2  984F42     MOV.B W2, [W14+12]
0040C4  984F53     MOV.B W3, [W14+13]
0040C6  984F64     MOV.B W4, [W14+14]
0040C8  984F75     MOV.B W5, [W14+15]
0040CA  985706     MOV.B W6, [W14+16]
0040CC  980F17     MOV W7, [W14+18]
2267:                  CPU_CHAR     *pstr_fmt;
2268:                  CPU_INT32S    nbr_fmt;
2269:                  CPU_BOOLEAN   nbr_neg;
2270:              
2271:              
2272:                  if (nbr < 0) {                                              /* If nbr neg, ...                                      */
0040CE  90004E     MOV [W14+8], W0
0040D0  9000DE     MOV [W14+10], W1
0040D2  500FE0     SUB W0, #0x0, [W15]
0040D4  588FE0     SUBB W1, #0x0, [W15]
0040D6  3D0008     BRA GE, 0x40E8
2273:                      nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
0040D8  90004E     MOV [W14+8], W0
0040DA  9000DE     MOV [W14+10], W1
0040DC  100060     SUBR W0, #0x0, W0
0040DE  1880E0     SUBBR W1, #0x0, W1
0040E0  BE8F00     MOV.D W0, [W14]
2274:                      nbr_neg =  DEF_YES;
0040E2  B3C010     MOV.B #0x1, W0
0040E4  984740     MOV.B W0, [W14+4]
0040E6  370005     BRA 0x40F2
2275:                  } else {
2276:                      nbr_fmt =  nbr;
0040E8  90014E     MOV [W14+8], W2
0040EA  9001DE     MOV [W14+10], W3
0040EC  BE8F02     MOV.D W2, [W14]
2277:                      nbr_neg =  DEF_NO;
0040EE  EB4000     CLR.B W0
0040F0  984740     MOV.B W0, [W14+4]
2278:                  }
2279:              
2280:                  pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
0040F2  BE001E     MOV.D [W14], W0
0040F4  90099E     MOV [W14+18], W3
0040F6  781F83     MOV W3, [W15++]
0040F8  90538E     MOV.B [W14+16], W7
0040FA  904B7E     MOV.B [W14+15], W6
0040FC  904AEE     MOV.B [W14+14], W5
0040FE  90424E     MOV.B [W14+4], W4
004100  9049DE     MOV.B [W14+13], W3
004102  90494E     MOV.B [W14+12], W2
004104  07003F     RCALL _Str_FmtNbr_Int32
004106  E9878F     DEC2 W15, W15
004108  980730     MOV W0, [W14+6]
2281:                                                          nbr_dig,
2282:                                                          nbr_base,
2283:                                                          nbr_neg,
2284:                                                          lead_char,
2285:                                                          lower_case,
2286:                                                          nul,
2287:                                                          pstr);
2288:              
2289:                  return (pstr_fmt);
00410A  90003E     MOV [W14+6], W0
2290:              }
00410C  FA8000     ULNK
00410E  060000     RETURN
2291:              
2292:              
2293:              /*
2294:              *********************************************************************************************************
2295:              *                                           Str_FmtNbr_32()
2296:              *
2297:              * Description : Format number into a multi-digit character string.
2298:              *
2299:              * Argument(s) : nbr             Number                         to format (see Note #1).
2300:              *
2301:              *               nbr_dig         Number of decimal       digits to format (see Note #2).
2302:              *
2303:              *               nbr_dp          Number of decimal point digits to format.
2304:              *
2305:              *               lead_char       Prepend leading character (see Note #3) :
2306:              *
2307:              *                                   '\0'                    Do NOT prepend leading character to string.
2308:              *                                     Printable character          Prepend leading character to string.
2309:              *                                   Unprintable character   Format invalid string (see Note #6d).
2310:              *
2311:              *               nul             Append terminating NULL-character (see Note #4) :
2312:              *
2313:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
2314:              *                                   DEF_YES                Append terminating NULL-character to string.
2315:              *
2316:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
2317:              *
2318:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
2319:              *
2320:              *               Pointer to NULL,             otherwise.
2321:              *
2322:              * Caller(s)   : Application.
2323:              *
2324:              * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
2325:              *
2326:              *
2327:              *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
2328:              *                           32-bit Floating-point Number  =  -----------------------------------------------------
2329:              *                                                                             log [External-Base]
2330:              *
2331:              *                                                             log [2 ^ 24]
2332:              *                                                         =  --------------
2333:              *                                                               log [10]
2334:              *
2335:              *                                                         <  7.225  Base-10 Digits
2336:              *
2337:              *                               where
2338:              *                                       Internal-Base                   Internal number base of floating-
2339:              *                                                                           point numbers (i.e.  2)
2340:              *                                       External-Base                   External number base of floating-
2341:              *                                                                           point numbers (i.e. 10)
2342:              *                                       Number-Internal-Base-Digits     Number of internal number base
2343:              *                                                                           significant digits (i.e. 24)
2344:              *
2345:              *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
2346:              *                       maximum accuracy.
2347:              *$PAGE*
2348:              *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
2349:              *                       formatting is performed except possible NULL-termination of the string (see Note #4).
2350:              *
2351:              *                           Example :
2352:              *
2353:              *                               nbr     = -23456.789
2354:              *                               nbr_dig =  0
2355:              *                               nbr_dp  =  0
2356:              *
2357:              *                               pstr    = ""                        See Note #7a
2358:              *
2359:              *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
2360:              *                           significant integer digits of the number to format ('nbr'); then an invalid
2361:              *                           string is formatted instead of truncating any significant integer digits.
2362:              *
2363:              *                               Example :
2364:              *
2365:              *                                   nbr     = 23456.789
2366:              *                                   nbr_dig = 3
2367:              *                                   nbr_dp  = 2
2368:              *
2369:              *                                   pstr    = "??????"              See Note #7d
2370:              *
2371:              *                       (2) If the number to format ('nbr') is negative but the number of digits to format
2372:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
2373:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
2374:              *                           the negative sign.
2375:              *
2376:              *                               Example :
2377:              *
2378:              *                                   nbr     = -23456.789
2379:              *                                   nbr_dig =  5
2380:              *                                   nbr_dp  =  2
2381:              *
2382:              *                                   pstr    = "????????"            See Note #7d
2383:              *
2384:              *                       (3) If the number to format ('nbr') is negative but the number of significant
2385:              *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one
2386:              *                           but the number of decimal point digits to format ('nbr_dp') is zero; then
2387:              *                           an invalid string is formatted instead of truncating the negative sign.
2388:              *
2389:              *                               Example :
2390:              *
2391:              *                                   nbr     = -0.7895
2392:              *                                   nbr_dig =  1
2393:              *                                   nbr_dp  =  0
2394:              *
2395:              *                                   pstr    = "?"                   See Note #7d
2396:              *
2397:              *                       (4) (A) If the number to format ('nbr') is negative but the number of significant
2398:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2399:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2400:              *                               zero; then the negative sign immediately prefixes the decimal point --
2401:              *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
2402:              *
2403:              *                                   Example :
2404:              *
2405:              *                                       nbr     = -0.7895
2406:              *                                       nbr_dig =  0
2407:              *                                       nbr_dp  =  2
2408:              *
2409:              *                                       pstr    = "-.78"
2410:              *
2411:              *                           (B) If the number to format ('nbr') is positive but the number of significant
2412:              *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
2413:              *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
2414:              *                               zero; then a single decimal digit of '0' prefixes the decimal point.
2415:              *
2416:              *                               This '0' digit is used whenever a negative sign is not formatted (see
2417:              *                               Note #2b4A) so that the formatted string's decimal point is not floating,
2418:              *                               but fixed in the string as the 2nd character.
2419:              *
2420:              *                                   Example :
2421:              *
2422:              *                                       nbr     =  0.7895
2423:              *                                       nbr_dig =  0
2424:              *                                       nbr_dp  =  2
2425:              *
2426:              *                                       pstr    = "0.78"
2427:              *$PAGE*
2428:              *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
2429:              *
2430:              *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point
2431:              *                               numbers, digits following all significantly-accurate digits of the number to
2432:              *                               format ('nbr') will be inaccurate; ...
2433:              *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all
2434:              *                               digits or decimal places following all significantly-accurate digits of the
2435:              *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
2436:              *
2437:              *                                   Example :
2438:              *
2439:              *                                       nbr                            = 123456789.012345
2440:              *                                       nbr_dig                        = 9
2441:              *                                       nbr_dp                         = 6
2442:              *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
2443:              *
2444:              *                                       pstr                           = "123456700.000000"
2445:              *
2446:              *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr')
2447:              *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
2448:              *                           &/or compiler's floating-point implementation.
2449:              *
2450:              *                       See also Note #1.
2451:              *
2452:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
2453:              *
2454:              *                   (a) (1) Leading character MUST be a printable ASCII character.
2455:              *
2456:              *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
2457:              *                           (B) with the exception of '0'.
2458:              *
2459:              *                   (b) (1) The number of leading characters is such that the total number of significant
2460:              *                           integer digits plus the number of leading characters plus possible negative
2461:              *                           sign character is equal to the requested number of integer digits to format
2462:              *                           ('nbr_dig').
2463:              *
2464:              *                               Examples :
2465:              *
2466:              *                                   nbr       = 23456.789
2467:              *                                   nbr_dig   = 7
2468:              *                                   nbr_dp    = 2
2469:              *                                   lead_char = ' '
2470:              *
2471:              *                                   pstr      = "  23456.78"
2472:              *
2473:              *
2474:              *                                   nbr       = -23456.789
2475:              *                                   nbr_dig   =  7
2476:              *                                   nbr_dp    =  2
2477:              *                                   lead_char = ' '
2478:              *
2479:              *                                   pstr      = " -23456.78"
2480:              *
2481:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
2482:              *                               ('lead_char') is     a '0' digit; then the negative sign character
2483:              *                               prefixes all leading characters prior to the formatted number.
2484:              *
2485:              *                                   Example :
2486:              *
2487:              *                                       nbr       = -23456.789
2488:              *                                       nbr_dig   =  8
2489:              *                                       nbr_dp    =  2
2490:              *                                       lead_char = '0'
2491:              *
2492:              *                                       pstr      = "-0023456.78"
2493:              *
2494:              *                           (B) If the number to format ('nbr') is negative AND the leading character
2495:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
2496:              *                               immediately prefixes the most significant digit of the formatted number.
2497:              *
2498:              *                                   Examples :
2499:              *
2500:              *                                       nbr       = -23456.789
2501:              *                                       nbr_dig   =  8
2502:              *                                       nbr_dp    =  2
2503:              *                                       lead_char = '#'
2504:              *
2505:              *                                       pstr      = "##-23456.78"
2506:              *
2507:              *                   (c) (1) If the integer value of the number to format is zero & ...
2508:              *                       (2) ... the number of digits to format is greater than one ...
2509:              *                       (3) ... OR  the number is NOT negative,                    ...
2510:              *                       (4) ... but NO leading character available;                ...
2511:              *                       (5) ... then one digit of '0' value is formatted.
2512:              *
2513:              *                           This is NOT a leading character; but a single integer digit of '0' value.
2514:              *
2515:              *                       See also Note #2b4B.
2516:              *$PAGE*
2517:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
2518:              *                       array formatting.
2519:              *
2520:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
2521:              *                       terminate option DISABLED will cause character string run-on.
2522:              *
2523:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
2524:              *
2525:              *                   (b) To prevent character buffer overrun :
2526:              *
2527:              *                           Character array size MUST be  >=  ('nbr_dig'          +
2528:              *                                                              'nbr_dp'           +
2529:              *                                                               1 negative sign   +
2530:              *                                                               1 decimal point   +
2531:              *                                                               1 'NUL' terminator)  characters
2532:              *
2533:              *               (6) String format terminates when :
2534:              *
2535:              *                   (a) Format string pointer is passed a NULL pointer.
2536:              *                       (1) No      string formatted;                NULL pointer returned.
2537:              *
2538:              *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
2539:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
2540:              *
2541:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
2542:              *                           integer digits of the number to format ('nbr'), including possible
2543:              *                           negative sign.
2544:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2545:              *
2546:              *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
2547:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
2548:              *
2549:              *                   (e) Number successfully formatted into character string array.
2550:              *
2551:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
2552:              *                   ('?') will be formatted, where the number of question marks is determined by the
2553:              *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
2554:              *
2555:              *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
2556:              *                                           {                                        'nbr_dp'  = 0
2557:              *                                           {
2558:              *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
2559:              *                                           {                                        'nbr_dp'  = 0
2560:              *                      Invalid string's     {
2561:              *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
2562:              *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
2563:              *                                           {         1 (for negative sign) ]
2564:              *                                           {
2565:              *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
2566:              *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
2567:              *                                           {         1 (for decimal point) ]
2568:              *
2569:              *********************************************************************************************************
2570:              */
2571:              
2572:              #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
2573:              CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
2574:                                        CPU_INT08U    nbr_dig,
2575:                                        CPU_INT08U    nbr_dp,
2576:                                        CPU_CHAR      lead_char,
2577:                                        CPU_BOOLEAN   nul,
2578:                                        CPU_CHAR     *pstr)
2579:              {
2580:                  CPU_CHAR     *pstr_fmt;
2581:                  CPU_DATA      i;
2582:                  CPU_FP32      nbr_fmt;
2583:                  CPU_FP32      nbr_log;
2584:                  CPU_INT32U    nbr_shiftd;
2585:                  CPU_INT16U    nbr_dig_max;
2586:                  CPU_INT16U    nbr_dig_sig;
2587:                  CPU_INT08U    nbr_neg_sign;
2588:                  CPU_INT08U    dig_val;
2589:                  CPU_FP32      dig_exp;
2590:                  CPU_FP32      dp_exp;
2591:                  CPU_BOOLEAN   lead_char_dig;
2592:                  CPU_BOOLEAN   lead_char_fmtd;
2593:                  CPU_BOOLEAN   lead_char_0;
2594:                  CPU_BOOLEAN   fmt_invalid;
2595:                  CPU_BOOLEAN   print_char;
2596:                  CPU_BOOLEAN   nbr_neg;
2597:                  CPU_BOOLEAN   nbr_neg_fmtd;
2598:              
2599:              
2600:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
2601:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
2602:                      return ((CPU_CHAR *)0);
2603:                  }
2604:              
2605:                  dig_exp     =  1.0f;
2606:                  fmt_invalid =  DEF_NO;
2607:                  lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;        /* Chk if lead char a '0' dig (see Note #3b2).          */
2608:                  nbr_fmt     =  0.0f;
2609:                  nbr_neg     =  DEF_NO;
2610:              
2611:                  if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
2612:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
2613:                  }
2614:              
2615:                  if (lead_char != (CPU_CHAR)'\0') {
2616:                      print_char =  ASCII_IsPrint(lead_char);
2617:                      if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
2618:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
2619:              
2620:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
2621:                          lead_char_dig = ASCII_IsDig(lead_char);
2622:                          if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
2623:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
2624:                          }
2625:                      }
2626:                  }
2627:              
2628:              
2629:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
2630:                  pstr_fmt = pstr;
2631:              
2632:                  if (fmt_invalid == DEF_NO) {
2633:                      if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
2634:                          nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
2635:                          nbr_neg_sign =  1u;
2636:                          nbr_neg      =  DEF_YES;
2637:                      } else {
2638:                          nbr_fmt      =  nbr;
2639:                          nbr_neg_sign =  0u;
2640:                          nbr_neg      =  DEF_NO;
2641:                      }
2642:              
2643:                      nbr_log     = nbr_fmt;
2644:                      nbr_dig_max = 0u;
2645:                      while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
2646:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
2647:                          nbr_log /= 10.0f;
2648:                      }
2649:              
2650:                      if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
2651:                           (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
2652:                          ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
2653:                           (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
2654:                           (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
2655:                                                                              /* .. prepare nbr digs to fmt.                          */
2656:                          for (i = 1u; i < nbr_dig; i++) {
2657:                              dig_exp *= 10.0f;
2658:                          }
2659:              
2660:                          nbr_neg_fmtd   =  DEF_NO;
2661:                          nbr_dig_sig    =  0u;
2662:                          lead_char_fmtd =  DEF_NO;
2663:                      } else {                                                /* Else if nbr trunc'd, ...                             */
2664:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
2665:                      }
2666:                  }
2667:              
2668:              
2669:                                                                              /* ------------------- FMT NBR STR -------------------- */
2670:                  for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
2671:                      if (fmt_invalid == DEF_NO) {
2672:                          if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
2673:                              nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
2674:                              if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
2675:                                  (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
2676:                                                                              /* ... calc & fmt dig val;                     ...      */
2677:                                  if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
2678:                                      (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
2679:              
2680:                                      if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
2681:                                          pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
2682:                                      }
2683:                                     *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
2684:                                      nbr_neg_fmtd = DEF_YES;
2685:                                  }
2686:              
2687:                                  if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
2688:                                      dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
2689:                                     *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
2690:              
2691:                                      nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
2692:              
2693:                                  } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
2694:                                             (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
2695:                                     *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
2696:                                  }
2697:              
2698:                              } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
2699:                                         (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
2700:                                         (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
2701:              
2702:                                 *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
2703:                                  nbr_neg_fmtd = DEF_YES;
2704:              
2705:                              } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
2706:                                 *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
2707:                                  lead_char_fmtd = DEF_YES;
2708:                              }
2709:              
2710:                              dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
2711:              
2712:                          } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
2713:                             *pstr_fmt++ = '0';
2714:                          }
2715:              
2716:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2717:                         *pstr_fmt++ = '?';
2718:                      }
2719:                  }
2720:              
2721:              
2722:                  if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
2723:                      if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
2724:                          if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
2725:                              if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
2726:                                  (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
2727:                                  *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
2728:                              } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
2729:                                  *pstr_fmt++ = '0';
2730:                              }
2731:                          } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
2732:                              *pstr_fmt++ = '?';
2733:                          }
2734:                      }
2735:              
2736:                      if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
2737:                         *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
2738:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
2739:                         *pstr_fmt++ = '?';
2740:                      }
2741:              
2742:                      dp_exp = 10.0f;
2743:                      for (i = 0u; i < nbr_dp; i++) {
2744:                          if (fmt_invalid == DEF_NO) {
2745:                                                                              /* If nbr sig digs < max, fmt str dps;    ...           */
2746:                              if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
2747:                                  nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
2748:                                  dig_val     = (CPU_INT08U)(nbr_shiftd % 10u);
2749:                                 *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
2750:                                  dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
2751:              
2752:                                  if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
2753:                                      (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
2754:                                       nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
2755:                                  }
2756:              
2757:                              } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
2758:                                 *pstr_fmt++ = '0';
2759:                              }
2760:              
2761:                          } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
2762:                             *pstr_fmt++ = '?';
2763:                          }
2764:                      }
2765:                  }
2766:              
2767:              
2768:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
2769:                     *pstr_fmt = (CPU_CHAR)'\0';
2770:                  }
2771:              
2772:              
2773:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
2774:                      return ((CPU_CHAR *)0);
2775:                  }
2776:              
2777:              
2778:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
2779:              }
2780:              #endif
2781:              
2782:              
2783:              /*
2784:              *********************************************************************************************************
2785:              *                                        Str_ParseNbr_Int32U()
2786:              *
2787:              * Description : Parse 32-bit unsigned integer from string.
2788:              *
2789:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
2790:              *
2791:              *               pstr_next   Optional pointer to a variable to ... :
2792:              *
2793:              *                               (a) Return a pointer to first character following the integer string,
2794:              *                                       if NO error(s) [see Note #2a2B2];
2795:              *                               (b) Return a pointer to 'pstr',
2796:              *                                       otherwise      (see Note #2a2A2).
2797:              *
2798:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
2799:              *
2800:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
2801:              *
2802:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
2803:              *
2804:              *               0,                   otherwise                            (see Note #2a3B).
2805:              *
2806:              * Caller(s)   : Application.
2807:              *
2808:              * Note(s)     : (1) String buffer NOT modified.
2809:              *
2810:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
2811:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
2812:              *                       to a type unsigned long ... representation" :
2813:              *
2814:              *                       (1) "First, they decompose the input string into three parts" :
2815:              *
2816:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
2817:              *                                by isspace()]."
2818:              *
2819:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
2820:              *                                    input string, starting with the first non-white-space character that is of
2821:              *                                    the expected form.  The subject sequence shall contain no characters if the
2822:              *                                    input string is empty or consists entirely of white-space characters."
2823:              *
2824:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
2825:              *                                    determined by the value of 'base' ('nbr_base')" :
2826:              *
2827:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
2828:              *                                        subject sequence is that of a decimal constant, octal constant, or
2829:              *                                        hexadecimal constant" :
2830:              *
2831:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
2832:              *                                            sequence of decimal digits."
2833:              *
2834:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
2835:              *                                            a sequence of the digits '0' to '7' only."
2836:              *
2837:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
2838:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
2839:              *                                            (or 'F') with values 10 to 15 respectively."
2840:              *
2841:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
2842:              *                                        of the subject sequence is a sequence of letters and digits representing
2843:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
2844:              *
2845:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
2846:              *                                                ascribed the values 10 to 35"; ...
2847:              *                                           (B) "only letters whose ascribed values are less than that of base
2848:              *                                                are permitted."
2849:              *
2850:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
2851:              *                                                '0X' may optionally precede the sequence of letters and digits."
2852:              *
2853:              *                                           (B) Although NO specification states that "if the value of 'base'
2854:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
2855:              *                                               the sequence of letters and digits"; it seems reasonable to
2856:              *                                               allow the '0' character to be optionally parsed.
2857:              *
2858:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
2859:              *
2860:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
2861:              *                                       integer string into an unsigned integer.
2862:              *
2863:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
2864:              *                                   (b) "including the terminating null byte of the input string" ...
2865:              *                               (2) "other than a sign or a permissible letter or digit."
2866:              *$PAGE*
2867:              *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
2868:              *
2869:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
2870:              *
2871:              *                               (1) "no conversion [is] performed"; ...
2872:              *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr'
2873:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
2874:              *
2875:              *                           (B) "If the subject sequence has the expected form" :
2876:              *
2877:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
2878:              *                                        starting with the first digit shall be interpreted as an integer constant."
2879:              *
2880:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
2881:              *                                        used as the base for conversion, ascribing to each letter its value as
2882:              *                                        given above" (see Note #2a1B1b1A).
2883:              *
2884:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
2885:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
2886:              *                                   pointer."
2887:              *
2888:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
2889:              *
2890:              *                           (A) "Upon successful completion, these functions shall return the converted value."
2891:              *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
2892:              *                                    ... shall be returned."
2893:              *
2894:              *                           (B) "If no conversion could be performed, 0 shall be returned."
2895:              *
2896:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2897:              *                           shall fail if" :
2898:              *
2899:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
2900:              *
2901:              *                           (B) "[ERANGE] - The value to be returned is not representable."
2902:              *
2903:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
2904:              *                           may fail if" :
2905:              *
2906:              *                           (A) "[EINVAL] - No conversion could be performed."
2907:              *
2908:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
2909:              *
2910:              *                   (a) Valid parse string integer :
2911:              *
2912:              *                           pstr      = "     ABCDE xyz"
2913:              *                           nbr_base  = 16
2914:              *
2915:              *                           nbr       = 703710
2916:              *                           pstr_next = " xyz"
2917:              *
2918:              *
2919:              *                   (b) Invalid parse string integer :
2920:              *
2921:              *                           pstr      = "     ABCDE"
2922:              *                           nbr_base  = 10
2923:              *
2924:              *                           nbr       =  0
2925:              *                           pstr_next = pstr = "     ABCDE"
2926:              *
2927:              *
2928:              *                   (c) Valid hexadecimal parse string integer :
2929:              *
2930:              *                           pstr      = "     0xGABCDE"
2931:              *                           nbr_base  = 16
2932:              *
2933:              *                           nbr       =  0
2934:              *                           pstr_next = "xGABCDE"
2935:              *
2936:              *
2937:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
2938:              *                               following invalid hexadecimal characters) :
2939:              *
2940:              *                           pstr      = "     0xGABCDE"
2941:              *                           nbr_base  =  0
2942:              *
2943:              *                           nbr       =  0
2944:              *                           pstr_next = "xGABCDE"
2945:              *
2946:              *
2947:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
2948:              *                               following invalid octal       characters) :
2949:              *
2950:              *                           pstr      = "     0GABCDE"
2951:              *                           nbr_base  =  0
2952:              *
2953:              *                           nbr       =  0
2954:              *                           pstr_next = "GABCDE"
2955:              *
2956:              *$PAGE*
2957:              *                   (f) Parse string integer overflow :
2958:              *
2959:              *                           pstr      = "   12345678901234567890*123456"
2960:              *                           nbr_base  = 10
2961:              *
2962:              *                           nbr       = DEF_INT_32U_MAX_VAL
2963:              *                           pstr_next = "*123456"
2964:              *
2965:              *
2966:              *                   (g) Invalid negative unsigned parse string :
2967:              *
2968:              *                           pstr      = "  -12345678901234567890*123456"
2969:              *                           nbr_base  = 10
2970:              *
2971:              *                           nbr       = 0
2972:              *                           pstr_next = pstr = "  -12345678901234567890*123456"
2973:              *
2974:              *********************************************************************************************************
2975:              */
2976:              
2977:              CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
2978:                                                      CPU_CHAR    **pstr_next,
2979:                                                      CPU_INT08U    nbr_base)
2980:              {
004110  FA000A     LNK #0xA
004112  980720     MOV W0, [W14+4]
004114  980731     MOV W1, [W14+6]
004116  984F02     MOV.B W2, [W14+8]
2981:                  CPU_INT32U  nbr;
2982:              
2983:              
2984:                  nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
004118  EB0200     CLR W4
00411A  EB4180     CLR.B W3
00411C  90490E     MOV.B [W14+8], W2
00411E  9000BE     MOV [W14+6], W1
004120  90002E     MOV [W14+4], W0
004122  07016C     RCALL _Str_ParseNbr_Int32
004124  BE8F00     MOV.D W0, [W14]
2985:                                                          pstr_next,
2986:                                                          nbr_base,
2987:                                                          DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
2988:                                           (CPU_BOOLEAN *)0);
2989:              
2990:                  return (nbr);
004126  BE001E     MOV.D [W14], W0
2991:              }
004128  FA8000     ULNK
00412A  060000     RETURN
2992:              
2993:              
2994:              /*
2995:              *********************************************************************************************************
2996:              *                                        Str_ParseNbr_Int32S()
2997:              *
2998:              * Description : Parse 32-bit signed integer from string.
2999:              *
3000:              * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
3001:              *
3002:              *               pstr_next   Optional pointer to a variable to ... :
3003:              *
3004:              *                               (a) Return a pointer to first character following the integer string,
3005:              *                                       if NO error(s) [see Note #2a2B2];
3006:              *                               (b) Return a pointer to 'pstr',
3007:              *                                       otherwise      (see Note #2a2A2).
3008:              *
3009:              *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
3010:              *
3011:              * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
3012:              *
3013:              *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
3014:              *
3015:              *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
3016:              *
3017:              *               0,                   otherwise                                    (see Note #2a3B).
3018:              *
3019:              * Caller(s)   : Application.
3020:              *
3021:              * Note(s)     : (1) String buffer NOT modified.
3022:              *
3023:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3024:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3025:              *                       to a type long ... representation" :
3026:              *
3027:              *                       (1) "First, they decompose the input string into three parts" :
3028:              *
3029:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3030:              *                                by isspace()]."
3031:              *
3032:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3033:              *                                    input string, starting with the first non-white-space character that is of
3034:              *                                    the expected form.  The subject sequence shall contain no characters if the
3035:              *                                    input string is empty or consists entirely of white-space characters."
3036:              *
3037:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3038:              *                                    determined by the value of 'base' ('nbr_base')" :
3039:              *
3040:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3041:              *                                        subject sequence is that of a decimal constant, octal constant, or
3042:              *                                        hexadecimal constant" :
3043:              *
3044:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3045:              *                                            sequence of decimal digits."
3046:              *
3047:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3048:              *                                            a sequence of the digits '0' to '7' only."
3049:              *
3050:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3051:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3052:              *                                            (or 'F') with values 10 to 15 respectively."
3053:              *
3054:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3055:              *                                        of the subject sequence is a sequence of letters and digits representing
3056:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3057:              *
3058:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3059:              *                                                ascribed the values 10 to 35"; ...
3060:              *                                           (B) "only letters whose ascribed values are less than that of base
3061:              *                                                are permitted."
3062:              *
3063:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3064:              *                                                '0X' may optionally precede the sequence of letters and digits."
3065:              *
3066:              *                                           (B) Although NO specification states that "if the value of 'base'
3067:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3068:              *                                               the sequence of letters and digits"; it seems reasonable to
3069:              *                                               allow the '0' character to be optionally parsed.
3070:              *
3071:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3072:              *
3073:              *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
3074:              *                                       integer string into an unsigned integer.
3075:              *
3076:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3077:              *                                   (b) "including the terminating null byte of the input string" ...
3078:              *                               (2) "other than a sign or a permissible letter or digit."
3079:              *$PAGE*
3080:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3081:              *
3082:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3083:              *
3084:              *                               (1) "no conversion is performed"; ...
3085:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3086:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3087:              *
3088:              *                           (B) "If the subject sequence has the expected form" :
3089:              *
3090:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3091:              *                                        starting with the first digit shall be interpreted as an integer constant."
3092:              *
3093:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3094:              *                                        used as the base for conversion, ascribing to each letter its value as
3095:              *                                        given above" (see Note #2a1B1b1A).
3096:              *
3097:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3098:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3099:              *                                   pointer."
3100:              *
3101:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3102:              *
3103:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3104:              *
3105:              *                               (1) "If the correct value is outside the range of representable values", either
3106:              *                                    of the following "shall be returned" :
3107:              *                                   (a) "{LONG_MIN}" or ...
3108:              *                                   (b) "{LONG_MAX}"
3109:              *
3110:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3111:              *
3112:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3113:              *                           shall fail if" :
3114:              *
3115:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3116:              *
3117:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3118:              *
3119:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3120:              *                           may fail if" :
3121:              *
3122:              *                           (A) "[EINVAL] - No conversion could be performed."
3123:              *
3124:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3125:              *
3126:              *                   (a) Valid parse string integer :
3127:              *
3128:              *                           pstr      = "     ABCDE xyz"
3129:              *                           nbr_base  = 16
3130:              *
3131:              *                           nbr       = 703710
3132:              *                           pstr_next = " xyz"
3133:              *
3134:              *
3135:              *                   (b) Invalid parse string integer :
3136:              *
3137:              *                           pstr      = "     ABCDE"
3138:              *                           nbr_base  = 10
3139:              *
3140:              *                           nbr       =  0
3141:              *                           pstr_next = pstr = "     ABCDE"
3142:              *
3143:              *
3144:              *                   (c) Valid hexadecimal parse string integer :
3145:              *
3146:              *                           pstr      = "     0xGABCDE"
3147:              *                           nbr_base  = 16
3148:              *
3149:              *                           nbr       =  0
3150:              *                           pstr_next = "xGABCDE"
3151:              *
3152:              *
3153:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3154:              *                               following invalid hexadecimal characters) :
3155:              *
3156:              *                           pstr      = "     0xGABCDE"
3157:              *                           nbr_base  =  0
3158:              *
3159:              *                           nbr       =  0
3160:              *                           pstr_next = "xGABCDE"
3161:              *
3162:              *
3163:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3164:              *                               following invalid octal       characters) :
3165:              *
3166:              *                           pstr      = "     0GABCDE"
3167:              *                           nbr_base  =  0
3168:              *
3169:              *                           nbr       =  0
3170:              *                           pstr_next = "GABCDE"
3171:              *
3172:              *$PAGE*
3173:              *                   (f) Parse string integer overflow :
3174:              *
3175:              *                           pstr      = "   12345678901234567890*123456"
3176:              *                           nbr_base  = 10
3177:              *
3178:              *                           nbr       = DEF_INT_32S_MAX_VAL
3179:              *                           pstr_next = "*123456"
3180:              *
3181:              *
3182:              *                   (g) Parse string integer underflow :
3183:              *
3184:              *                           pstr      = "  -12345678901234567890*123456"
3185:              *                           nbr_base  = 10
3186:              *
3187:              *                           nbr       = DEF_INT_32S_MIN_VAL
3188:              *                           pstr_next = "*123456"
3189:              *
3190:              *********************************************************************************************************
3191:              */
3192:              
3193:              CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
3194:                                                      CPU_CHAR    **pstr_next,
3195:                                                      CPU_INT08U    nbr_base)
3196:              {
00412C  FA0010     LNK #0x10
00412E  980750     MOV W0, [W14+10]
004130  980761     MOV W1, [W14+12]
004132  984F62     MOV.B W2, [W14+14]
3197:                  CPU_INT32S   nbr;
3198:                  CPU_INT32U   nbr_abs;
3199:                  CPU_BOOLEAN  nbr_neg;
3200:              
3201:              
3202:                  nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
004134  470068     ADD W14, #0x8, W0
004136  780200     MOV W0, W4
004138  B3C013     MOV.B #0x1, W3
00413A  90496E     MOV.B [W14+14], W2
00413C  9000EE     MOV [W14+12], W1
00413E  90005E     MOV [W14+10], W0
004140  07015D     RCALL _Str_ParseNbr_Int32
004142  980720     MOV W0, [W14+4]
004144  980731     MOV W1, [W14+6]
3203:                                               pstr_next,
3204:                                               nbr_base,
3205:                                               DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
3206:                                              &nbr_neg);
3207:              
3208:                  if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
004146  90480E     MOV.B [W14+8], W0
004148  E00400     CP0.B W0
00414A  3A000C     BRA NZ, 0x4164
3209:                      nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
00414C  90002E     MOV [W14+4], W0
00414E  9000BE     MOV [W14+6], W1
004160  BE8F00     MOV.D W0, [W14]
004162  37000D     BRA 0x417E
3210:                                                                                  :  (CPU_INT32S)nbr_abs;
004150  500FE0     SUB W0, #0x0, [W15]
004152  588FE0     SUBB W1, #0x0, [W15]
004154  350003     BRA LT, 0x415C
004156  90002E     MOV [W14+4], W0
004158  9000BE     MOV [W14+6], W1
00415A  370002     BRA 0x4160
00415C  2FFFF0     MOV #0xFFFF, W0
00415E  27FFF1     MOV #0x7FFF, W1
3211:                  } else {
3212:                      nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
004164  90002E     MOV [W14+4], W0
004166  9000BE     MOV [W14+6], W1
00417C  BE8F00     MOV.D W0, [W14]
3213:                                                                                  : -(CPU_INT32S)nbr_abs;
004168  500FE0     SUB W0, #0x0, [W15]
00416A  588FE0     SUBB W1, #0x0, [W15]
00416C  350005     BRA LT, 0x4178
00416E  90002E     MOV [W14+4], W0
004170  9000BE     MOV [W14+6], W1
004172  100060     SUBR W0, #0x0, W0
004174  1880E0     SUBBR W1, #0x0, W1
004176  370002     BRA 0x417C
004178  200000     MOV #0x0, W0
00417A  280001     MOV #0x8000, W1
3214:                  }
3215:              
3216:                  return (nbr);
00417E  BE001E     MOV.D [W14], W0
3217:              }
004180  FA8000     ULNK
004182  060000     RETURN
3218:              
3219:              
3220:              /*
3221:              *********************************************************************************************************
3222:              *********************************************************************************************************
3223:              *                                           LOCAL FUNCTIONS
3224:              *********************************************************************************************************
3225:              *********************************************************************************************************
3226:              */
3227:              
3228:              /*
3229:              *********************************************************************************************************
3230:              *                                         Str_FmtNbr_Int32()
3231:              *
3232:              * Description : Format 32-bit integer into a multi-digit character string.
3233:              *
3234:              * Argument(s) : nbr             Number           to format.
3235:              *
3236:              *               nbr_dig         Number of digits to format (see Note #1).
3237:              *
3238:              *               nbr_base        Base   of number to format (see Note #2).
3239:              *
3240:              *               nbr_neg         Indicates whether number to format is negative :
3241:              *               -------
3242:              *                                   DEF_NO          Number is non-negative.
3243:              *                                   DEF_YES         Number is     negative.
3244:              *
3245:              *                               Argument validated in Str_FmtNbr_Int32U(),
3246:              *                                                     Str_FmtNbr_Int32S().
3247:              *
3248:              *               lead_char       Prepend leading character  (see Note #3) :
3249:              *
3250:              *                                   '\0'                    Do NOT prepend leading character to string.
3251:              *                                     Printable character          Prepend leading character to string.
3252:              *                                   Unprintable character   Format invalid string (see Note #6e).
3253:              *
3254:              *               lower_case      Format alphabetic characters (if any) in lower case :
3255:              *
3256:              *                                   DEF_NO          Format alphabetic characters in upper case.
3257:              *                                   DEF_YES         Format alphabetic characters in lower case.
3258:              *
3259:              *               nul             Append terminating NULL-character (see Note #4) :
3260:              *
3261:              *                                   DEF_NO          Do NOT append terminating NULL-character to string.
3262:              *                                   DEF_YES                Append terminating NULL-character to string.
3263:              *
3264:              *               pstr            Pointer to character array to return formatted number string (see Note #5).
3265:              *
3266:              * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
3267:              *
3268:              *               Pointer to NULL,             otherwise.
3269:              *
3270:              * Caller(s)   : Str_FmtNbr_Int32U(),
3271:              *               Str_FmtNbr_Int32S().
3272:              *$PAGE*
3273:              * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
3274:              *
3275:              *
3276:              *                               Maximum Number of             [  log (Number)      ]
3277:              *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
3278:              *                                   to Format                 [   log (Base)       ]
3279:              *
3280:              *                               where
3281:              *                                       Number                  Number to format
3282:              *                                       Base            Base of number to format
3283:              *
3284:              *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting
3285:              *                           is performed except possible NULL-termination of the string (see Note #4).
3286:              *
3287:              *                               Example :
3288:              *
3289:              *                                   nbr      = -23456
3290:              *                                   nbr_dig  =  0
3291:              *                                   nbr_base = 10
3292:              *
3293:              *                                   pstr     = ""                   See Note #7a
3294:              *
3295:              *                       (2) If the number of digits to format ('nbr_dig') is less than the number of
3296:              *                           significant integer digits of the number to format ('nbr'); then an invalid
3297:              *                           string is formatted instead of truncating any significant integer digits.
3298:              *
3299:              *                               Example :
3300:              *
3301:              *                                   nbr      = 23456
3302:              *                                   nbr_dig  = 3
3303:              *                                   nbr_base = 10
3304:              *
3305:              *                                   pstr     = "???"                See Note #7b
3306:              *
3307:              *                       (3) If the number to format ('nbr') is negative but the number of digits to format
3308:              *                           ('nbr_dig') is equal to the number of significant integer digits of the number
3309:              *                           to format ('nbr'); then an invalid string is formatted instead of truncating
3310:              *                           the negative sign.
3311:              *
3312:              *                               Example :
3313:              *
3314:              *                                   nbr      = -23456
3315:              *                                   nbr_dig  =  5
3316:              *                                   nbr_base = 10
3317:              *
3318:              *                                   pstr     = "?????"              See Note #7b
3319:              *
3320:              *               (2) The number's base MUST be between 2 & 36, inclusive.
3321:              *$PAGE*
3322:              *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
3323:              *
3324:              *                   (a) (1) Leading character MUST be a printable ASCII character.
3325:              *
3326:              *                       (2) (A) Leading character MUST NOT be a number base digit, ...
3327:              *                           (B) with the exception of '0'.
3328:              *
3329:              *                   (b) (1) The number of leading characters is such that the total number of significant
3330:              *                           integer digits plus the number of leading characters plus possible negative
3331:              *                           sign character is equal to the requested number of integer digits to format
3332:              *                           ('nbr_dig').
3333:              *
3334:              *                               Examples :
3335:              *
3336:              *                                   nbr       = 23456
3337:              *                                   nbr_dig   = 7
3338:              *                                   nbr_base  = 10
3339:              *                                   lead_char = ' '
3340:              *
3341:              *                                   pstr      = "  23456"
3342:              *
3343:              *
3344:              *                                   nbr       = -23456
3345:              *                                   nbr_dig   = 7
3346:              *                                   nbr_base  = 10
3347:              *                                   lead_char = ' '
3348:              *
3349:              *                                   pstr      = " -23456"
3350:              *
3351:              *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
3352:              *                               ('lead_char') is     a '0' digit; then the negative sign character
3353:              *                               prefixes all leading characters prior to the formatted number.
3354:              *
3355:              *                                   Examples :
3356:              *
3357:              *                                       nbr        = -23456
3358:              *                                       nbr_dig    =  8
3359:              *                                       nbr_base   = 10
3360:              *                                       lead_char  = '0'
3361:              *
3362:              *                                       pstr       = "-0023456"
3363:              *
3364:              *
3365:              *                                       nbr        = -43981
3366:              *                                       nbr_dig    =  8
3367:              *                                       nbr_base   = 16
3368:              *                                       lead_char  = '0'
3369:              *                                       lower_case = DEF_NO
3370:              *
3371:              *                                       pstr       = "-000ABCD"
3372:              *
3373:              *                           (B) If the number to format ('nbr') is negative AND the leading character
3374:              *                               ('lead_char') is NOT a '0' digit; then the negative sign character
3375:              *                               immediately prefixes the most significant digit of the formatted number.
3376:              *
3377:              *                                   Examples :
3378:              *
3379:              *                                       nbr        = -23456
3380:              *                                       nbr_dig    =  8
3381:              *                                       nbr_base   = 10
3382:              *                                       lead_char  = '#'
3383:              *
3384:              *                                       pstr       = "##-23456"
3385:              *
3386:              *
3387:              *                                       nbr        = -43981
3388:              *                                       nbr_dig    =  8
3389:              *                                       nbr_base   = 16
3390:              *                                       lead_char  = '#'
3391:              *                                       lower_case = DEF_YES
3392:              *
3393:              *                                       pstr       = "###-abcd"
3394:              *
3395:              *                   (c) (1) If the value of the number to format is     zero  ...
3396:              *                       (2) ... & the number of digits to format is non-zero, ...
3397:              *                       (3) ... but NO leading character available;           ...
3398:              *                       (4) ... then one digit of '0' value is formatted.
3399:              *
3400:              *                           This is NOT a leading character; but a single integer digit of '0' value.
3401:              *$PAGE*
3402:              *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
3403:              *                       array formatting.
3404:              *
3405:              *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
3406:              *                       terminate option DISABLED will cause character string run-on.
3407:              *
3408:              *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
3409:              *
3410:              *                   (b) To prevent character buffer overrun :
3411:              *
3412:              *                           Character array size MUST be  >=  ('nbr_dig'          +
3413:              *                                                               1 negative sign   +
3414:              *                                                               1 'NUL' terminator)  characters
3415:              *
3416:              *               (6) String format terminates when :
3417:              *
3418:              *                   (a) Format string pointer is passed a NULL pointer.
3419:              *                       (1) No      string formatted;                NULL pointer returned.
3420:              *
3421:              *                   (b) Number of digits to format ('nbr_dig') is zero.
3422:              *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
3423:              *
3424:              *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
3425:              *                           integer digits of the number to format ('nbr'), including possible
3426:              *                           negative sign.
3427:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3428:              *
3429:              *                   (d) Base is passed an invalid base (see Note #2).
3430:              *                       (1) Invalid string format performed; NULL pointer returned.
3431:              *
3432:              *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
3433:              *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
3434:              *
3435:              *                   (f) Number successfully formatted into character string array.
3436:              *
3437:              *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
3438:              *                   ('?') will be formatted, where the number of question marks is determined by the
3439:              *                   number of digits to format ('nbr_dig') :
3440:              *
3441:              *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
3442:              *                          number of     =  {
3443:              *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
3444:              *
3445:              *********************************************************************************************************
3446:              */
3447:              
3448:              static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
3449:                                                   CPU_INT08U    nbr_dig,
3450:                                                   CPU_INT08U    nbr_base,
3451:                                                   CPU_BOOLEAN   nbr_neg,
3452:                                                   CPU_CHAR      lead_char,
3453:                                                   CPU_BOOLEAN   lower_case,
3454:                                                   CPU_BOOLEAN   nul,
3455:                                                   CPU_CHAR     *pstr)
3456:              {
004184  FA0024     LNK #0x24
004186  980F50     MOV W0, [W14+26]
004188  980F61     MOV W1, [W14+28]
00418A  985F62     MOV.B W2, [W14+30]
00418C  985F73     MOV.B W3, [W14+31]
00418E  986704     MOV.B W4, [W14+32]
004190  986715     MOV.B W5, [W14+33]
004192  986726     MOV.B W6, [W14+34]
004194  986737     MOV.B W7, [W14+35]
3457:                  CPU_CHAR     *pstr_fmt;
3458:                  CPU_DATA      i;
3459:                  CPU_INT32U    nbr_fmt;
3460:                  CPU_INT32U    nbr_log;
3461:                  CPU_INT08U    nbr_dig_max;
3462:                  CPU_INT08U    nbr_dig_min;
3463:                  CPU_INT08U    nbr_dig_fmtd;
3464:                  CPU_INT08U    nbr_neg_sign;
3465:                  CPU_INT08U    nbr_lead_char;
3466:                  CPU_INT08U    dig_val;
3467:                  CPU_INT08U    lead_char_delta_0;
3468:                  CPU_INT08U    lead_char_delta_a;
3469:                  CPU_BOOLEAN   lead_char_dig;
3470:                  CPU_BOOLEAN   lead_char_0;
3471:                  CPU_BOOLEAN   fmt_invalid;
3472:                  CPU_BOOLEAN   print_char;
3473:                  CPU_BOOLEAN   nbr_neg_fmtd;
3474:              
3475:              
3476:                                                                              /* ---------------- VALIDATE FMT ARGS ----------------- */
3477:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
004196  97B84E     MOV [W14-8], W0
004198  E00000     CP0 W0
00419A  3A0002     BRA NZ, 0x41A0
3478:                      return ((CPU_CHAR *)0);
00419C  EB0000     CLR W0
00419E  37012C     BRA 0x43F8
3479:                  }
3480:              
3481:                  fmt_invalid = DEF_NO;
0041A0  EB4000     CLR.B W0
0041A2  985710     MOV.B W0, [W14+17]
3482:                  lead_char_0 = DEF_NO;
0041A4  EB4000     CLR.B W0
0041A6  985700     MOV.B W0, [W14+16]
3483:              
3484:                  if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
0041A8  90586E     MOV.B [W14+30], W0
0041AA  E00400     CP0.B W0
0041AC  3A0002     BRA NZ, 0x41B2
3485:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
0041AE  B3C010     MOV.B #0x1, W0
0041B0  985710     MOV.B W0, [W14+17]
3486:                  }
3487:                                                                              /* If invalid base, ...                                 */
3488:                  if ((nbr_base <  2u) ||
0041B2  90587E     MOV.B [W14+31], W0
0041B4  504FE1     SUB.B W0, #0x1, [W15]
0041B6  360004     BRA LEU, 0x41C0
0041B8  9058FE     MOV.B [W14+31], W1
0041BA  B3C240     MOV.B #0x24, W0
0041BC  50CF80     SUB.B W1, W0, [W15]
0041BE  360002     BRA LEU, 0x41C4
3489:                      (nbr_base > 36u)) {
3490:                      fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
0041C0  B3C010     MOV.B #0x1, W0
0041C2  985710     MOV.B W0, [W14+17]
3491:                  }
3492:              
3493:                  if (lead_char != (CPU_CHAR)'\0') {
0041C4  90601E     MOV.B [W14+33], W0
0041C6  E00400     CP0.B W0
0041C8  32003A     BRA Z, 0x423E
3494:                      print_char =  ASCII_IsPrint(lead_char);
0041CA  90601E     MOV.B [W14+33], W0
0041CC  071169     RCALL ASCII_IsPrint
0041CE  985730     MOV.B W0, [W14+19]
3495:                      if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
0041D0  90503E     MOV.B [W14+19], W0
0041D2  504FE1     SUB.B W0, #0x1, [W15]
0041D4  320003     BRA Z, 0x41DC
3496:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
0041D6  B3C010     MOV.B #0x1, W0
0041D8  985710     MOV.B W0, [W14+17]
0041DA  370031     BRA 0x423E
3497:              
3498:                      } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
0041DC  90609E     MOV.B [W14+33], W1
0041DE  B3C300     MOV.B #0x30, W0
0041E0  50CF80     SUB.B W1, W0, [W15]
0041E2  32002D     BRA Z, 0x423E
3499:                          lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
0041E4  90609E     MOV.B [W14+33], W1
0041E6  B3CD00     MOV.B #0xD0, W0
0041E8  40C000     ADD.B W1, W0, W0
0041EA  985740     MOV.B W0, [W14+20]
3500:                          if (lower_case != DEF_YES) {
0041EC  90602E     MOV.B [W14+34], W0
0041EE  504FE1     SUB.B W0, #0x1, [W15]
0041F0  320005     BRA Z, 0x41FC
3501:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
0041F2  90609E     MOV.B [W14+33], W1
0041F4  B3CBF0     MOV.B #0xBF, W0
0041F6  40C000     ADD.B W1, W0, W0
0041F8  984F70     MOV.B W0, [W14+15]
0041FA  370004     BRA 0x4204
3502:                          } else {
3503:                              lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
0041FC  90609E     MOV.B [W14+33], W1
0041FE  B3C9F0     MOV.B #0x9F, W0
004200  40C000     ADD.B W1, W0, W0
004202  984F70     MOV.B W0, [W14+15]
3504:                          }
3505:              
3506:                          lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
004204  90587E     MOV.B [W14+31], W0
004206  504FEA     SUB.B W0, #0xA, [W15]
004208  3E0004     BRA GTU, 0x4212
00420A  9050CE     MOV.B [W14+20], W1
00420C  90587E     MOV.B [W14+31], W0
00420E  50CF80     SUB.B W1, W0, [W15]
004210  39000D     BRA NC, 0x422C
004212  90587E     MOV.B [W14+31], W0
004214  504FEA     SUB.B W0, #0xA, [W15]
004216  36000C     BRA LEU, 0x4230
00422C  B3C010     MOV.B #0x1, W0
00422E  370001     BRA 0x4232
004230  EB4000     CLR.B W0
004232  985750     MOV.B W0, [W14+21]
3507:                                           ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
004218  90504E     MOV.B [W14+20], W0
00421A  504FE9     SUB.B W0, #0x9, [W15]
00421C  360007     BRA LEU, 0x422C
004228  508F80     SUB W1, W0, [W15]
00422A  310002     BRA C, 0x4230
3508:                                                                  (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
00421E  90487E     MOV.B [W14+15], W0
004220  FB8080     ZE W0, W1
004222  90587E     MOV.B [W14+31], W0
004224  FB8000     ZE W0, W0
004226  50006A     SUB W0, #0xA, W0
3509:              
3510:                          if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
004234  90505E     MOV.B [W14+21], W0
004236  504FE1     SUB.B W0, #0x1, [W15]
004238  3A0002     BRA NZ, 0x423E
3511:                              fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
00423A  B3C010     MOV.B #0x1, W0
00423C  985710     MOV.B W0, [W14+17]
3512:                          }
3513:                      }
3514:                  }
3515:              
3516:              
3517:                                                                              /* ----------------- PREPARE NBR FMT ------------------ */
3518:                  pstr_fmt    = pstr;
00423E  97B8CE     MOV [W14-8], W1
004240  780F01     MOV W1, [W14]
3519:                  lead_char_0 = DEF_NO;
004242  EB4000     CLR.B W0
004244  985700     MOV.B W0, [W14+16]
3520:              
3521:                  if (fmt_invalid == DEF_NO) {
004246  90501E     MOV.B [W14+17], W0
004248  E00400     CP0.B W0
00424A  3A0057     BRA NZ, 0x42FA
3522:                      nbr_fmt     = nbr;
00424C  90095E     MOV [W14+26], W2
00424E  9009EE     MOV [W14+28], W3
004250  980722     MOV W2, [W14+4]
004252  980733     MOV W3, [W14+6]
3523:                      nbr_log     = nbr;
004254  90095E     MOV [W14+26], W2
004256  9009EE     MOV [W14+28], W3
004258  980742     MOV W2, [W14+8]
00425A  980753     MOV W3, [W14+10]
3524:                      nbr_dig_max = 1u;
00425C  B3C010     MOV.B #0x1, W0
00425E  984F40     MOV.B W0, [W14+12]
3525:                      while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
004260  37000C     BRA 0x427A
00427A  90587E     MOV.B [W14+31], W0
00427C  FB8100     ZE W0, W2
00427E  EB0180     CLR W3
004280  90004E     MOV [W14+8], W0
004282  9000DE     MOV [W14+10], W1
004284  510F80     SUB W2, W0, [W15]
004286  598F81     SUBB W3, W1, [W15]
004288  36FFEC     BRA LEU, 0x4262
3526:                          nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
004262  90484E     MOV.B [W14+12], W0
004264  E84000     INC.B W0, W0
004266  984F40     MOV.B W0, [W14+12]
3527:                          nbr_log /= nbr_base;
004268  90587E     MOV.B [W14+31], W0
00426A  FB8000     ZE W0, W0
00426C  EB0080     CLR W1
00426E  BE0100     MOV.D W0, W2
004270  90004E     MOV [W14+8], W0
004272  9000DE     MOV [W14+10], W1
004274  07E25A     RCALL 0x72A
004276  980740     MOV W0, [W14+8]
004278  980751     MOV W1, [W14+10]
3528:                      }
3529:              
3530:                      nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
00428A  90600E     MOV.B [W14+32], W0
00428C  504FE1     SUB.B W0, #0x1, [W15]
00428E  3A0002     BRA NZ, 0x4294
004290  B3C010     MOV.B #0x1, W0
004292  370001     BRA 0x4296
004294  EB4000     CLR.B W0
004296  985760     MOV.B W0, [W14+22]
3531:                      if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
004298  90586E     MOV.B [W14+30], W0
00429A  FB8080     ZE W0, W1
00429C  90484E     MOV.B [W14+12], W0
00429E  FB8100     ZE W0, W2
0042A0  90506E     MOV.B [W14+22], W0
0042A2  FB8000     ZE W0, W0
0042A4  410000     ADD W2, W0, W0
0042A6  508F80     SUB W1, W0, [W15]
0042A8  350026     BRA LT, 0x42F6
3532:                          nbr_neg_fmtd = DEF_NO;
0042AA  EB4000     CLR.B W0
0042AC  985720     MOV.B W0, [W14+18]
3533:                          nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
0042AE  9048CE     MOV.B [W14+12], W1
0042B0  90586E     MOV.B [W14+30], W0
0042B2  504F81     SUB.B W0, W1, [W15]
0042B4  360001     BRA LEU, 0x42B8
0042B6  784001     MOV.B W1, W0
0042B8  985770     MOV.B W0, [W14+23]
3534:                                                                              /* ... calc nbr digs to fmt & nbr lead chars.           */
3535:                          if (lead_char != (CPU_CHAR)'\0') {
0042BA  90601E     MOV.B [W14+33], W0
0042BC  E00400     CP0.B W0
0042BE  320009     BRA Z, 0x42D2
3536:                              nbr_dig_fmtd  = nbr_dig;
0042C0  9059EE     MOV.B [W14+30], W3
0042C2  984F53     MOV.B W3, [W14+13]
3537:                              nbr_lead_char = nbr_dig     -
0042C4  9058EE     MOV.B [W14+30], W1
0042C6  90507E     MOV.B [W14+23], W0
0042C8  50C080     SUB.B W1, W0, W1
0042CA  90506E     MOV.B [W14+22], W0
0042CC  50C000     SUB.B W1, W0, W0
0042CE  984F60     MOV.B W0, [W14+14]
0042D0  370006     BRA 0x42DE
3538:                                              nbr_dig_min - nbr_neg_sign;
3539:                          } else {
3540:                              nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
0042D2  9050FE     MOV.B [W14+23], W1
0042D4  90506E     MOV.B [W14+22], W0
0042D6  40C000     ADD.B W1, W0, W0
0042D8  984F50     MOV.B W0, [W14+13]
3541:                              nbr_lead_char = 0u;
0042DA  EB4000     CLR.B W0
0042DC  984F60     MOV.B W0, [W14+14]
3542:                          }
3543:              
3544:                          if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
0042DE  90486E     MOV.B [W14+14], W0
0042E0  E00400     CP0.B W0
0042E2  32000B     BRA Z, 0x42FA
3545:                              lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
0042E4  90609E     MOV.B [W14+33], W1
0042E6  B3C300     MOV.B #0x30, W0
0042E8  50CF80     SUB.B W1, W0, [W15]
0042EA  3A0002     BRA NZ, 0x42F0
0042EC  B3C010     MOV.B #0x1, W0
0042EE  370001     BRA 0x42F2
0042F0  EB4000     CLR.B W0
0042F2  985700     MOV.B W0, [W14+16]
0042F4  370002     BRA 0x42FA
3546:                                          ?  DEF_YES : DEF_NO;
3547:                          }
3548:              
3549:                      } else {                                                /* Else if nbr trunc'd, ...                             */
3550:                          fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
0042F6  B3C010     MOV.B #0x1, W0
0042F8  985710     MOV.B W0, [W14+17]
3551:                      }
3552:                  }
3553:              
3554:                  if (fmt_invalid != DEF_NO) {
0042FA  90501E     MOV.B [W14+17], W0
0042FC  E00400     CP0.B W0
0042FE  320002     BRA Z, 0x4304
3555:                      nbr_dig_fmtd = nbr_dig;
004300  9058EE     MOV.B [W14+30], W1
004302  984F51     MOV.B W1, [W14+13]
3556:                  }
3557:              
3558:              
3559:                                                                              /* ------------------- FMT NBR STR -------------------- */
3560:                  pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
004304  90485E     MOV.B [W14+13], W0
004306  FB8000     ZE W0, W0
004308  400F1E     ADD W0, [W14], [W14]
3561:              
3562:                  if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
00430A  90603E     MOV.B [W14+35], W0
00430C  E00400     CP0.B W0
00430E  320003     BRA Z, 0x4316
3563:                     *pstr_fmt = (CPU_CHAR)'\0';
004310  78001E     MOV [W14], W0
004312  EB4080     CLR.B W1
004314  784801     MOV.B W1, [W0]
3564:                  }
3565:                  pstr_fmt--;
004316  E90F1E     DEC [W14], [W14]
3566:              
3567:              
3568:                  for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
004318  EB0000     CLR W0
00431A  980710     MOV W0, [W14+2]
00431C  370062     BRA 0x43E2
0043DC  90001E     MOV [W14+2], W0
0043DE  E80000     INC W0, W0
0043E0  980710     MOV W0, [W14+2]
0043E2  90485E     MOV.B [W14+13], W0
0043E4  FB8080     ZE W0, W1
0043E6  90001E     MOV [W14+2], W0
0043E8  508F80     SUB W1, W0, [W15]
0043EA  3EFF99     BRA GTU, 0x431E
3569:                      if (fmt_invalid == DEF_NO) {
00431E  90501E     MOV.B [W14+17], W0
004320  E00400     CP0.B W0
004322  3A0056     BRA NZ, 0x43D0
3570:                          if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
004324  90002E     MOV [W14+4], W0
004326  9000BE     MOV [W14+6], W1
004328  500FE0     SUB W0, #0x0, [W15]
00432A  588FE0     SUBB W1, #0x0, [W15]
00432C  3A0003     BRA NZ, 0x4334
00432E  90001E     MOV [W14+2], W0
004330  E00000     CP0 W0
004332  3A002D     BRA NZ, 0x438E
3571:                              (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
3572:                                                                              /* ... calc & fmt dig val;                      ...     */
3573:                              dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
004334  90587E     MOV.B [W14+31], W0
004336  FB8000     ZE W0, W0
004338  EB0080     CLR W1
00433A  90022E     MOV [W14+4], W4
00433C  9002BE     MOV [W14+6], W5
00433E  BE0100     MOV.D W0, W2
004340  BE0004     MOV.D W4, W0
004342  07E203     RCALL 0x74A
004344  985F00     MOV.B W0, [W14+24]
3574:                              if (dig_val < 10u) {
004346  90580E     MOV.B [W14+24], W0
004348  504FE9     SUB.B W0, #0x9, [W15]
00434A  3E0007     BRA GTU, 0x435A
3575:                                 *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
00434C  90580E     MOV.B [W14+24], W0
00434E  B3C302     MOV.B #0x30, W2
004350  404082     ADD.B W0, W2, W1
004352  78001E     MOV [W14], W0
004354  784801     MOV.B W1, [W0]
004356  E90F1E     DEC [W14], [W14]
004358  370010     BRA 0x437A
3576:                              } else {
3577:                                  if (lower_case !=  DEF_YES) {
00435A  90602E     MOV.B [W14+34], W0
00435C  504FE1     SUB.B W0, #0x1, [W15]
00435E  320007     BRA Z, 0x436E
3578:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
004360  90580E     MOV.B [W14+24], W0
004362  B3C373     MOV.B #0x37, W3
004364  404083     ADD.B W0, W3, W1
004366  78001E     MOV [W14], W0
004368  784801     MOV.B W1, [W0]
00436A  E90F1E     DEC [W14], [W14]
00436C  370006     BRA 0x437A
3579:                                  } else {
3580:                                     *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
00436E  90580E     MOV.B [W14+24], W0
004370  B3C572     MOV.B #0x57, W2
004372  404082     ADD.B W0, W2, W1
004374  78001E     MOV [W14], W0
004376  784801     MOV.B W1, [W0]
004378  E90F1E     DEC [W14], [W14]
3581:                                  }
3582:                              }
3583:              
3584:                              nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
00437A  90587E     MOV.B [W14+31], W0
00437C  FB8000     ZE W0, W0
00437E  EB0080     CLR W1
004380  BE0100     MOV.D W0, W2
004382  90002E     MOV [W14+4], W0
004384  9000BE     MOV [W14+6], W1
004386  07E1D1     RCALL 0x72A
004388  980720     MOV W0, [W14+4]
00438A  980731     MOV W1, [W14+6]
00438C  370027     BRA 0x43DC
3585:              
3586:                          } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
00438E  90600E     MOV.B [W14+32], W0
004390  504FE1     SUB.B W0, #0x1, [W15]
004392  3A0016     BRA NZ, 0x43C0
004394  90500E     MOV.B [W14+16], W0
004396  E00400     CP0.B W0
004398  3A0003     BRA NZ, 0x43A0
3587:                                   (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
00439A  90502E     MOV.B [W14+18], W0
00439C  E00400     CP0.B W0
00439E  320009     BRA Z, 0x43B2
3588:                                     (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
0043A0  90500E     MOV.B [W14+16], W0
0043A2  E00400     CP0.B W0
0043A4  32000D     BRA Z, 0x43C0
3589:                                    ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
0043AC  90001E     MOV [W14+2], W0
0043AE  508F80     SUB W1, W0, [W15]
0043B0  3A0007     BRA NZ, 0x43C0
3590:                                     (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
0043A6  90485E     MOV.B [W14+13], W0
0043A8  FB8000     ZE W0, W0
0043AA  E90080     DEC W0, W1
3591:              
3592:                             *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
0043B2  78001E     MOV [W14], W0
0043B4  B3C2D1     MOV.B #0x2D, W1
0043B6  784801     MOV.B W1, [W0]
0043B8  E90F1E     DEC [W14], [W14]
3593:                              nbr_neg_fmtd = DEF_YES;
0043BA  B3C010     MOV.B #0x1, W0
0043BC  985720     MOV.B W0, [W14+18]
0043BE  37000E     BRA 0x43DC
3594:              
3595:                          } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
0043C0  90601E     MOV.B [W14+33], W0
0043C2  E00400     CP0.B W0
0043C4  32000A     BRA Z, 0x43DA
3596:                             *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
0043C6  78001E     MOV [W14], W0
0043C8  90619E     MOV.B [W14+33], W3
0043CA  784803     MOV.B W3, [W0]
0043CC  E90F1E     DEC [W14], [W14]
0043CE  370006     BRA 0x43DC
0043DA  000000     NOP
3597:                          }
3598:              
3599:                      } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
3600:                         *pstr_fmt-- = '?';
0043D0  78001E     MOV [W14], W0
0043D2  B3C3F1     MOV.B #0x3F, W1
0043D4  784801     MOV.B W1, [W0]
0043D6  E90F1E     DEC [W14], [W14]
0043D8  370001     BRA 0x43DC
3601:                      }
3602:                  }
3603:              
3604:              
3605:                  if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
0043EC  90501E     MOV.B [W14+17], W0
0043EE  E00400     CP0.B W0
0043F0  320002     BRA Z, 0x43F6
3606:                      return ((CPU_CHAR *)0);
0043F2  EB0000     CLR W0
0043F4  370001     BRA 0x43F8
3607:                  }
3608:              
3609:              
3610:                  return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
0043F6  97B84E     MOV [W14-8], W0
3611:              }
0043F8  FA8000     ULNK
0043FA  060000     RETURN
3612:              
3613:              
3614:              /*
3615:              *********************************************************************************************************
3616:              *                                        Str_ParseNbr_Int32()
3617:              *
3618:              * Description : Parse 32-bit integer from string.
3619:              *
3620:              * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
3621:              *
3622:              *               pstr_next       Optional pointer to a variable to ... :
3623:              *
3624:              *                                   (a) Return a pointer to first character following the integer string,
3625:              *                                           if NO error(s) [see Note #2a2B2];
3626:              *                                   (b) Return a pointer to 'pstr',
3627:              *                                           otherwise      (see Note #2a2A2).
3628:              *
3629:              *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
3630:              *
3631:              *               nbr_signed      Indicates whether number to parse is signed :
3632:              *
3633:              *                                   DEF_NO                  Number is unsigned.
3634:              *                                   DEF_YES                 Number is   signed.
3635:              *
3636:              *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
3637:              *
3638:              *                                   DEF_NO                  Number is non-negative.
3639:              *                                   DEF_YES                 Number is     negative.
3640:              *
3641:              * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
3642:              *
3643:              *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
3644:              *
3645:              *               0,                   otherwise                            (see Note #2a3B).
3646:              *
3647:              * Caller(s)   : Str_ParseNbr_Int32U(),
3648:              *               Str_ParseNbr_Int32S().
3649:              *
3650:              * Note(s)     : (1) String buffer NOT modified.
3651:              *
3652:              *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
3653:              *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
3654:              *                       to a type long ... representation" :
3655:              *
3656:              *                       (1) "First, they decompose the input string into three parts" :
3657:              *
3658:              *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
3659:              *                                by isspace()]."
3660:              *
3661:              *                               (1) "The subject sequence is defined as the longest initial subsequence of the
3662:              *                                    input string, starting with the first non-white-space character that is of
3663:              *                                    the expected form.  The subject sequence shall contain no characters if the
3664:              *                                    input string is empty or consists entirely of white-space characters."
3665:              *
3666:              *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
3667:              *                                    determined by the value of 'base' ('nbr_base')" :
3668:              *
3669:              *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
3670:              *                                        subject sequence is that of a decimal constant, octal constant, or
3671:              *                                        hexadecimal constant" :
3672:              *
3673:              *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
3674:              *                                            sequence of decimal digits."
3675:              *
3676:              *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
3677:              *                                            a sequence of the digits '0' to '7' only."
3678:              *
3679:              *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
3680:              *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
3681:              *                                            (or 'F') with values 10 to 15 respectively."
3682:              *
3683:              *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
3684:              *                                        of the subject sequence is a sequence of letters and digits representing
3685:              *                                        an integer with the radix specified by 'base' ('nbr_base')" :
3686:              *
3687:              *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
3688:              *                                                ascribed the values 10 to 35"; ...
3689:              *                                           (B) "only letters whose ascribed values are less than that of base
3690:              *                                                are permitted."
3691:              *
3692:              *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
3693:              *                                               '0X' may optionally precede the sequence of letters and digits."
3694:              *
3695:              *                                           (B) Although NO specification states that "if the value of 'base'
3696:              *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
3697:              *                                               the sequence of letters and digits"; it seems reasonable to
3698:              *                                               allow the '0' character to be optionally parsed.
3699:              *$PAGE*
3700:              *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
3701:              *
3702:              *                                   (a) It does NOT seem reasonable to parse & convert a negative number
3703:              *                                       integer string into an unsigned integer.  However, a negative sign
3704:              *                                       for an unsigned integer will automatically be parsed as an invalid
3705:              *                                       character (see Note #2aC1).
3706:              *
3707:              *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
3708:              *                                   (b) "including the terminating null byte of the input string" ...
3709:              *                               (2) "other than a sign or a permissible letter or digit."
3710:              *
3711:              *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
3712:              *
3713:              *                           (A) "If the subject sequence is empty or does not have the expected form" :
3714:              *
3715:              *                               (1) "no conversion is performed"; ...
3716:              *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
3717:              *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
3718:              *
3719:              *                           (B) "If the subject sequence has the expected form" :
3720:              *
3721:              *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
3722:              *                                        starting with the first digit shall be interpreted as an integer constant."
3723:              *
3724:              *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
3725:              *                                        used as the base for conversion, ascribing to each letter its value as
3726:              *                                        given above" (see Note #2a1B1b1A).
3727:              *
3728:              *                               (2) "A pointer to the final string shall be stored in the object pointed to by
3729:              *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
3730:              *                                   pointer."
3731:              *
3732:              *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
3733:              *
3734:              *                           (A) "Upon successful completion, these functions shall return the converted value."
3735:              *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
3736:              *                                    [or] {LONG_MAX} ... shall be returned."
3737:              *
3738:              *                           (B) "If no conversion could be performed, 0 shall be returned."
3739:              *
3740:              *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3741:              *                           shall fail if" :
3742:              *
3743:              *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
3744:              *
3745:              *                           (B) "[ERANGE] - The value to be returned is not representable."
3746:              *
3747:              *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
3748:              *                           may fail if" :
3749:              *
3750:              *                           (A) "[EINVAL] - No conversion could be performed."
3751:              *$PAGE*
3752:              *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
3753:              *
3754:              *                   (a) Valid parse string integer :
3755:              *
3756:              *                           pstr      = "     ABCDE xyz"
3757:              *                           nbr_base  = 16
3758:              *
3759:              *                           nbr       = 703710
3760:              *                           pstr_next = " xyz"
3761:              *
3762:              *
3763:              *                   (b) Invalid parse string integer :
3764:              *
3765:              *                           pstr      = "     ABCDE"
3766:              *                           nbr_base  = 10
3767:              *
3768:              *                           nbr       =  0
3769:              *                           pstr_next = pstr = "     ABCDE"
3770:              *
3771:              *
3772:              *                   (c) Valid hexadecimal parse string integer :
3773:              *
3774:              *                           pstr      = "     0xGABCDE"
3775:              *                           nbr_base  = 16
3776:              *
3777:              *                           nbr       =  0
3778:              *                           pstr_next = "xGABCDE"
3779:              *
3780:              *
3781:              *                   (d) Valid decimal parse string integer ('0x' prefix ignored
3782:              *                               following invalid hexadecimal characters) :
3783:              *
3784:              *                           pstr      = "     0xGABCDE"
3785:              *                           nbr_base  =  0
3786:              *
3787:              *                           nbr       =  0
3788:              *                           pstr_next = "xGABCDE"
3789:              *
3790:              *
3791:              *                   (e) Valid decimal parse string integer ('0'  prefix ignored
3792:              *                               following invalid octal       characters) :
3793:              *
3794:              *                           pstr      = "     0GABCDE"
3795:              *                           nbr_base  =  0
3796:              *
3797:              *                           nbr       =  0
3798:              *                           pstr_next = "GABCDE"
3799:              *
3800:              *
3801:              *                   (f) Parse string integer overflow :
3802:              *
3803:              *                           pstr      = "   12345678901234567890*123456"
3804:              *                           nbr_base  = 10
3805:              *
3806:              *                           nbr       = DEF_INT_32U_MAX_VAL
3807:              *                           pstr_next = "*123456"
3808:              *
3809:              *
3810:              *                   (g) Parse string integer underflow :
3811:              *
3812:              *                           pstr      = "  -12345678901234567890*123456"
3813:              *                           nbr_base  = 10
3814:              *
3815:              *                           nbr       = DEF_INT_32S_MIN_VAL
3816:              *                           pstr_next = "*123456"
3817:              *
3818:              *
3819:              *               (4) String parse terminates when :
3820:              *
3821:              *                   (a) Base passed an invalid base (see Note #2a1B1b).
3822:              *                       (1) No conversion performed; 0 returned.
3823:              *
3824:              *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
3825:              *                           (A) No conversion performed; 0 returned.
3826:              *
3827:              *                       (2) Invalid parse string character found (see Note #2a1C).
3828:              *                           (A) Parsed integer returned.
3829:              *                           (B) 'pstr_next' points to invalid character.
3830:              *
3831:              *                       (3) Entire  parse string converted (see Note #2a2B).
3832:              *                           (A) Parsed integer returned.
3833:              *                           (B) 'pstr_next' points to terminating NULL character.
3834:              *
3835:              *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
3836:              *                   validation or function handling in case of any error(s).
3837:              *********************************************************************************************************
3838:              */
3839:              
3840:              static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
3841:                                                             CPU_CHAR     **pstr_next,
3842:                                                             CPU_INT08U     nbr_base,
3843:                                                             CPU_BOOLEAN    nbr_signed,
3844:                                                             CPU_BOOLEAN   *pnbr_neg)
3845:              {
0043FC  FA0020     LNK #0x20
0043FE  980F40     MOV W0, [W14+24]
004400  980F51     MOV W1, [W14+26]
004402  985F42     MOV.B W2, [W14+28]
004404  985F53     MOV.B W3, [W14+29]
004406  980F74     MOV W4, [W14+30]
3846:                  const  CPU_CHAR     *pstr_parse;
3847:                  const  CPU_CHAR     *pstr_parse_nbr;
3848:                         CPU_CHAR     *pstr_parse_unused;
3849:                         CPU_CHAR      parse_char;
3850:                         CPU_INT08U    parse_dig;
3851:                         CPU_INT32U    nbr;
3852:                         CPU_BOOLEAN   nbr_neg_unused;
3853:                         CPU_BOOLEAN   nbr_dig;
3854:                         CPU_BOOLEAN   nbr_alpha;
3855:                         CPU_BOOLEAN   nbr_hex;
3856:                         CPU_BOOLEAN   nbr_hex_lower;
3857:                         CPU_BOOLEAN   whitespace;
3858:                         CPU_BOOLEAN   neg;
3859:                         CPU_BOOLEAN   ovf;
3860:                         CPU_BOOLEAN   done;
3861:              
3862:                                                                              /* --------------- VALIDATE PARSE ARGS ---------------- */
3863:                  if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
004408  90085E     MOV [W14+26], W0
00440A  E00000     CP0 W0
00440C  3A0002     BRA NZ, 0x4412
3864:                      pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
00440E  470074     ADD W14, #0x14, W0
004410  980F50     MOV W0, [W14+26]
3865:                     (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
3866:                  }
3867:                 *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
004412  90085E     MOV [W14+26], W0
004414  9008CE     MOV [W14+24], W1
004416  780801     MOV W1, [W0]
3868:              
3869:                  if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
004418  90087E     MOV [W14+30], W0
00441A  E00000     CP0 W0
00441C  3A0002     BRA NZ, 0x4422
3870:                      pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
00441E  470076     ADD W14, #0x16, W0
004420  980F70     MOV W0, [W14+30]
3871:                     (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
3872:                  }
3873:                 *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
004422  90087E     MOV [W14+30], W0
004424  EB4080     CLR.B W1
004426  784801     MOV.B W1, [W0]
3874:              
3875:              
3876:                  if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
004428  90084E     MOV [W14+24], W0
00442A  E00000     CP0 W0
00442C  3A0002     BRA NZ, 0x4432
3877:                      return (0u);
00442E  B80060     MUL.UU W0, #0, W0
004430  37010A     BRA 0x4646
3878:                  }
3879:                                                                              /* Rtn zero if invalid base (see Note #4a).             */
3880:                  if ((nbr_base == 1u) ||
004432  90584E     MOV.B [W14+28], W0
004434  504FE1     SUB.B W0, #0x1, [W15]
004436  320004     BRA Z, 0x4440
004438  9058CE     MOV.B [W14+28], W1
00443A  B3C240     MOV.B #0x24, W0
00443C  50CF80     SUB.B W1, W0, [W15]
00443E  360002     BRA LEU, 0x4444
3881:                      (nbr_base > 36u)) {
3882:                      return (0u);
004440  B80060     MUL.UU W0, #0, W0
004442  370101     BRA 0x4646
3883:                  }
3884:              
3885:              
3886:                                                                              /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
3887:                  pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
004444  9008CE     MOV [W14+24], W1
004446  780F01     MOV W1, [W14]
3888:              
3889:                  whitespace = ASCII_IsSpace(*pstr_parse);
004448  78001E     MOV [W14], W0
00444A  784010     MOV.B [W0], W0
00444C  07100D     RCALL ASCII_IsSpace
00444E  984F00     MOV.B W0, [W14+8]
3890:                  while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
004450  370005     BRA 0x445C
00445C  90480E     MOV.B [W14+8], W0
00445E  504FE1     SUB.B W0, #0x1, [W15]
004460  32FFF8     BRA Z, 0x4452
3891:                      pstr_parse++;
004452  E80F1E     INC [W14], [W14]
3892:                      whitespace = ASCII_IsSpace(*pstr_parse);
004454  78001E     MOV [W14], W0
004456  784010     MOV.B [W0], W0
004458  071007     RCALL ASCII_IsSpace
00445A  984F00     MOV.B W0, [W14+8]
3893:                  }
3894:              
3895:                  switch (*pstr_parse) {
004462  78001E     MOV [W14], W0
004464  784010     MOV.B [W0], W0
004466  FB8000     ZE W0, W0
004468  2002B1     MOV #0x2B, W1
00446A  500F81     SUB W0, W1, [W15]
00446C  320004     BRA Z, 0x4476
00446E  2002D1     MOV #0x2D, W1
004470  500F81     SUB W0, W1, [W15]
004472  320005     BRA Z, 0x447E
004474  37000B     BRA 0x448C
3896:                      case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
3897:                           pstr_parse++;
004476  E80F1E     INC [W14], [W14]
3898:                           neg = DEF_NO;
004478  EB4000     CLR.B W0
00447A  984F10     MOV.B W0, [W14+9]
3899:                           break;
00447C  37000A     BRA 0x4492
3900:              
3901:              
3902:                      case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
3903:                           if (nbr_signed == DEF_YES) {
00447E  90585E     MOV.B [W14+29], W0
004480  504FE1     SUB.B W0, #0x1, [W15]
004482  3A0001     BRA NZ, 0x4486
3904:                               pstr_parse++;
004484  E80F1E     INC [W14], [W14]
3905:                           }
3906:                           neg = DEF_YES;
004486  B3C010     MOV.B #0x1, W0
004488  984F10     MOV.B W0, [W14+9]
3907:                           break;
00448A  370003     BRA 0x4492
3908:              
3909:              
3910:                      default:
3911:                           neg = DEF_NO;
00448C  EB4000     CLR.B W0
00448E  984F10     MOV.B W0, [W14+9]
3912:                           break;
004490  000000     NOP
3913:                  }
3914:              
3915:              
3916:                                                                              /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
3917:                  pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
004492  78009E     MOV [W14], W1
004494  980761     MOV W1, [W14+12]
3918:              
3919:                  switch (nbr_base) {
004496  90584E     MOV.B [W14+28], W0
004498  FB8000     ZE W0, W0
00449A  500FE8     SUB W0, #0x8, [W15]
00449C  320027     BRA Z, 0x44EC
00449E  500FF0     SUB W0, #0x10, [W15]
0044A0  32002C     BRA Z, 0x44FA
0044A2  E00000     CP0 W0
0044A4  3A0046     BRA NZ, 0x4532
3920:                      case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
3921:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0044A6  78001E     MOV [W14], W0
0044A8  784090     MOV.B [W0], W1
0044AA  B3C300     MOV.B #0x30, W0
0044AC  50CF80     SUB.B W1, W0, [W15]
0044AE  3A001B     BRA NZ, 0x44E6
3922:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
0044B0  E80F1E     INC [W14], [W14]
3923:                                switch (*pstr_parse) {
0044B2  78001E     MOV [W14], W0
0044B4  784010     MOV.B [W0], W0
0044B6  FB8000     ZE W0, W0
0044B8  200581     MOV #0x58, W1
0044BA  500F81     SUB W0, W1, [W15]
0044BC  320003     BRA Z, 0x44C4
0044BE  200781     MOV #0x78, W1
0044C0  500F81     SUB W0, W1, [W15]
0044C2  3A000D     BRA NZ, 0x44DE
3924:                                    case 'x':                                 /* For '0x' prefix, ...                                 */
3925:                                    case 'X':
3926:                                         nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
0044C4  B3C100     MOV.B #0x10, W0
0044C6  985F40     MOV.B W0, [W14+28]
3927:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
0044C8  E8001E     INC [W14], W0
0044CA  784090     MOV.B [W0], W1
0044CC  984F61     MOV.B W1, [W14+14]
3928:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
0044CE  90486E     MOV.B [W14+14], W0
0044D0  070F9A     RCALL ASCII_IsDigHex
0044D2  984F70     MOV.B W0, [W14+15]
3929:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
0044D4  90487E     MOV.B [W14+15], W0
0044D6  504FE1     SUB.B W0, #0x1, [W15]
0044D8  3A0001     BRA NZ, 0x44DC
3930:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
0044DA  E80F1E     INC [W14], [W14]
3931:                                         }
3932:                                         break;
0044DC  370003     BRA 0x44E4
3933:              
3934:              
3935:                                    default:                                  /* For '0'  prefix, ...                                 */
3936:                                         nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
0044DE  B3C080     MOV.B #0x8, W0
0044E0  985F40     MOV.B W0, [W14+28]
3937:                                         break;
0044E2  000000     NOP
3938:                                }
3939:              
3940:                           } else {                                           /* For non-'0' prefix, ...                              */
3941:                               nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
0044E6  B3C0A0     MOV.B #0xA, W0
0044E8  985F40     MOV.B W0, [W14+28]
3942:                           }
3943:                           break;
0044E4  37002B     BRA 0x453C
0044EA  370028     BRA 0x453C
3944:              
3945:              
3946:                      case  8u:                                               /* See Note #2a1B1a2.                                   */
3947:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0044EC  78001E     MOV [W14], W0
0044EE  784090     MOV.B [W0], W1
0044F0  B3C300     MOV.B #0x30, W0
0044F2  50CF80     SUB.B W1, W0, [W15]
0044F4  3A0020     BRA NZ, 0x4536
3948:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
0044F6  E80F1E     INC [W14], [W14]
3949:                           }
3950:                           break;
0044F8  370021     BRA 0x453C
004536  000000     NOP
004538  370001     BRA 0x453C
3951:              
3952:              
3953:                      case 16u:                                               /* See Note #2a1B1a3.                                   */
3954:                           if (*pstr_parse == '0') {                          /* If avail, ...                                        */
0044FA  78001E     MOV [W14], W0
0044FC  784090     MOV.B [W0], W1
0044FE  B3C300     MOV.B #0x30, W0
004500  50CF80     SUB.B W1, W0, [W15]
004502  3A001B     BRA NZ, 0x453A
3955:                                pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
004504  E80F1E     INC [W14], [W14]
3956:                                switch (*pstr_parse) {
004506  78001E     MOV [W14], W0
004508  784010     MOV.B [W0], W0
00450A  FB8000     ZE W0, W0
00450C  200581     MOV #0x58, W1
00450E  500F81     SUB W0, W1, [W15]
004510  320004     BRA Z, 0x451A
004512  200781     MOV #0x78, W1
004514  500F81     SUB W0, W1, [W15]
004516  320001     BRA Z, 0x451A
3957:                                    case 'x':
3958:                                    case 'X':
3959:                                         parse_char = (CPU_CHAR)(*(pstr_parse + 1));
00451A  E8001E     INC [W14], W0
00451C  784090     MOV.B [W0], W1
00451E  984F61     MOV.B W1, [W14+14]
3960:                                         nbr_hex    =  ASCII_IsDigHex(parse_char);
004520  90486E     MOV.B [W14+14], W0
004522  070F71     RCALL ASCII_IsDigHex
004524  984F70     MOV.B W0, [W14+15]
3961:                                         if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
004526  90487E     MOV.B [W14+15], W0
004528  504FE1     SUB.B W0, #0x1, [W15]
00452A  3A0001     BRA NZ, 0x452E
3962:                                             pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
00452C  E80F1E     INC [W14], [W14]
3963:                                         }
3964:                                         break;
00452E  000000     NOP
3965:              
3966:              
3967:                                    default:
3968:                                         break;
004518  37000B     BRA 0x4530
3969:                                }
3970:                           }
3971:                           break;
004530  370005     BRA 0x453C
00453A  000000     NOP
3972:              
3973:              
3974:                      default:                                                /* See Note #2a1B1b.                                    */
3975:                           break;
004532  000000     NOP
004534  370003     BRA 0x453C
3976:                  }
3977:              
3978:              
3979:                                                                              /* ------------------ PARSE INT STR ------------------- */
3980:                  nbr  = 0u;
00453C  B80060     MUL.UU W0, #0, W0
00453E  980720     MOV W0, [W14+4]
004540  980731     MOV W1, [W14+6]
3981:                  ovf  = DEF_NO;
004542  EB4000     CLR.B W0
004544  984F20     MOV.B W0, [W14+10]
3982:                  done = DEF_NO;
004546  EB4000     CLR.B W0
004548  984F30     MOV.B W0, [W14+11]
3983:              
3984:                  while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
00454A  370064     BRA 0x4614
004614  90483E     MOV.B [W14+11], W0
004616  E00400     CP0.B W0
004618  32FF99     BRA Z, 0x454C
3985:                      parse_char = (CPU_CHAR)*pstr_parse;
00454C  78001E     MOV [W14], W0
00454E  784090     MOV.B [W0], W1
004550  984F61     MOV.B W1, [W14+14]
3986:                      nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
004552  90486E     MOV.B [W14+14], W0
004554  070EF3     RCALL ASCII_IsAlphaNum
004556  985700     MOV.B W0, [W14+16]
3987:                      if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
004558  90500E     MOV.B [W14+16], W0
00455A  504FE1     SUB.B W0, #0x1, [W15]
00455C  3A0059     BRA NZ, 0x4610
3988:                                                                              /* ... convert parse char into nbr dig.                 */
3989:                          nbr_dig = ASCII_IsDig(parse_char);
00455E  90486E     MOV.B [W14+14], W0
004560  070F30     RCALL ASCII_IsDig
004562  985710     MOV.B W0, [W14+17]
3990:                          if (nbr_dig == DEF_YES) {
004564  90501E     MOV.B [W14+17], W0
004566  504FE1     SUB.B W0, #0x1, [W15]
004568  3A0005     BRA NZ, 0x4574
3991:                              parse_dig = (CPU_INT08U)(parse_char - '0');
00456A  9048EE     MOV.B [W14+14], W1
00456C  B3CD00     MOV.B #0xD0, W0
00456E  40C000     ADD.B W1, W0, W0
004570  984720     MOV.B W0, [W14+2]
004572  37000F     BRA 0x4592
3992:                          } else {
3993:                              nbr_hex_lower = ASCII_IsLower(parse_char);
004574  90486E     MOV.B [W14+14], W0
004576  070F03     RCALL ASCII_IsLower
004578  985720     MOV.B W0, [W14+18]
3994:                              if (nbr_hex_lower == DEF_YES) {
00457A  90502E     MOV.B [W14+18], W0
00457C  504FE1     SUB.B W0, #0x1, [W15]
00457E  3A0005     BRA NZ, 0x458A
3995:                                  parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
004580  9048EE     MOV.B [W14+14], W1
004582  B3CA90     MOV.B #0xA9, W0
004584  40C000     ADD.B W1, W0, W0
004586  984720     MOV.B W0, [W14+2]
004588  370004     BRA 0x4592
3996:                              } else {
3997:                                  parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
00458A  9048EE     MOV.B [W14+14], W1
00458C  B3CC90     MOV.B #0xC9, W0
00458E  40C000     ADD.B W1, W0, W0
004590  984720     MOV.B W0, [W14+2]
3998:                              }
3999:                          }
4000:              
4001:                          if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
004592  9040AE     MOV.B [W14+2], W1
004594  90584E     MOV.B [W14+28], W0
004596  50CF80     SUB.B W1, W0, [W15]
004598  310038     BRA C, 0x460A
4002:                              if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
00459A  90482E     MOV.B [W14+10], W0
00459C  E00400     CP0.B W0
00459E  3A0033     BRA NZ, 0x4606
4003:                                  if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
0045A0  90584E     MOV.B [W14+28], W0
0045A2  FB8000     ZE W0, W0
0045A4  DD00C2     SL W0, #2, W1
0045A6  29F060     MOV #0x9F06, W0
0045A8  408000     ADD W1, W0, W0
0045AA  BE0110     MOV.D [W0], W2
0045AC  90002E     MOV [W14+4], W0
0045AE  9000BE     MOV [W14+6], W1
0045B0  510F80     SUB W2, W0, [W15]
0045B2  598F81     SUBB W3, W1, [W15]
0045B4  390026     BRA NC, 0x4602
4004:                                                                              /* ... merge parse char dig into nbr.                   */
4005:                                      nbr *= nbr_base;
0045B6  90584E     MOV.B [W14+28], W0
0045B8  FB8000     ZE W0, W0
0045BA  EB0080     CLR W1
0045BC  90013E     MOV [W14+6], W2
0045BE  B99100     MUL.SS W2, W0, W2
0045C0  780102     MOV W2, W2
0045C2  9001AE     MOV [W14+4], W3
0045C4  B99A01     MUL.SS W3, W1, W4
0045C6  780184     MOV W4, W3
0045C8  410103     ADD W2, W3, W2
0045CA  9001AE     MOV [W14+4], W3
0045CC  B81800     MUL.UU W3, W0, W0
0045CE  410101     ADD W2, W1, W2
0045D0  780082     MOV W2, W1
0045D2  980720     MOV W0, [W14+4]
0045D4  980731     MOV W1, [W14+6]
0045D6  980720     MOV W0, [W14+4]
0045D8  980731     MOV W1, [W14+6]
4006:                                      nbr += parse_dig;
0045DA  90402E     MOV.B [W14+2], W0
0045DC  FB8000     ZE W0, W0
0045DE  EB0080     CLR W1
0045E0  90012E     MOV [W14+4], W2
0045E2  9001BE     MOV [W14+6], W3
0045E4  400002     ADD W0, W2, W0
0045E6  488083     ADDC W1, W3, W1
0045E8  980720     MOV W0, [W14+4]
0045EA  980731     MOV W1, [W14+6]
4007:                                      if (nbr < parse_dig) {
0045EC  90402E     MOV.B [W14+2], W0
0045EE  FB8100     ZE W0, W2
0045F0  EB0180     CLR W3
0045F2  90002E     MOV [W14+4], W0
0045F4  9000BE     MOV [W14+6], W1
0045F6  510F80     SUB W2, W0, [W15]
0045F8  598F81     SUBB W3, W1, [W15]
0045FA  360005     BRA LEU, 0x4606
4008:                                          ovf = DEF_YES;
0045FC  B3C010     MOV.B #0x1, W0
0045FE  984F20     MOV.B W0, [W14+10]
004600  370002     BRA 0x4606
4009:                                      }
4010:                                  } else {
4011:                                      ovf = DEF_YES;
004602  B3C010     MOV.B #0x1, W0
004604  984F20     MOV.B W0, [W14+10]
4012:                                  }
4013:                              }
4014:                              pstr_parse++;
004606  E80F1E     INC [W14], [W14]
004608  370005     BRA 0x4614
4015:              
4016:                          } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
4017:                              done = DEF_YES;
00460A  B3C010     MOV.B #0x1, W0
00460C  984F30     MOV.B W0, [W14+11]
00460E  370002     BRA 0x4614
4018:                          }
4019:              
4020:                      } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
4021:                          done = DEF_YES;
004610  B3C010     MOV.B #0x1, W0
004612  984F30     MOV.B W0, [W14+11]
4022:                      }
4023:                  }
4024:              
4025:                  if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
00461A  90482E     MOV.B [W14+10], W0
00461C  504FE1     SUB.B W0, #0x1, [W15]
00461E  3A0004     BRA NZ, 0x4628
4026:                      nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
004620  EB8000     SETM W0
004622  EB8080     SETM W1
004624  980720     MOV W0, [W14+4]
004626  980731     MOV W1, [W14+6]
4027:                  }
4028:              
4029:              
4030:                  if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
004628  90006E     MOV [W14+12], W0
00462A  78009E     MOV [W14], W1
00462C  508F80     SUB W1, W0, [W15]
00462E  320003     BRA Z, 0x4636
4031:                     *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
004630  90085E     MOV [W14+26], W0
004632  78081E     MOV [W14], [W0]
004634  370003     BRA 0x463C
4032:                  } else {
4033:                     *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
004636  90085E     MOV [W14+26], W0
004638  9008CE     MOV [W14+24], W1
00463A  780801     MOV W1, [W0]
4034:                  }
4035:              
4036:                 *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
00463C  90087E     MOV [W14+30], W0
00463E  90489E     MOV.B [W14+9], W1
004640  784801     MOV.B W1, [W0]
4037:              
4038:              
4039:                  return (nbr);
004642  90002E     MOV [W14+4], W0
004644  9000BE     MOV [W14+6], W1
4040:              }
004646  FA8000     ULNK
4041:              
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uC-LIB/lib_mem.c  --------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     STANDARD MEMORY OPERATIONS
29:                *
30:                * Filename      : lib_mem.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : ITJ
33:                *                 FGK
34:                *                 JFD
35:                *                 FBJ
36:                *                 EJ
37:                *********************************************************************************************************
38:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
39:                *
40:                *                     (a) ALL standard library functions are implemented in the custom library modules :
41:                *
42:                *                         (1) \<Custom Library Directory>\lib_*.*
43:                *
44:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
45:                *
46:                *                               where
47:                *                                       <Custom Library Directory>      directory path for custom library software
48:                *                                       <cpu>                           directory name for specific processor (CPU)
49:                *                                       <compiler>                      directory name for specific compiler
50:                *
51:                *                     (b) Product-specific library functions are implemented in individual products.
52:                *********************************************************************************************************
53:                */
54:                
55:                
56:                /*
57:                *********************************************************************************************************
58:                *                                            INCLUDE FILES
59:                *********************************************************************************************************
60:                */
61:                
62:                #define    MICRIUM_SOURCE
63:                #define    LIB_MEM_MODULE
64:                #include  "lib_mem.h"
65:                #include  "lib_math.h"
66:                #include  "lib_str.h"
67:                
68:                
69:                /*
70:                *********************************************************************************************************
71:                *                                            LOCAL DEFINES
72:                *********************************************************************************************************
73:                */
74:                
75:                
76:                /*
77:                *********************************************************************************************************
78:                *                                           LOCAL CONSTANTS
79:                *********************************************************************************************************
80:                */
81:                
82:                
83:                /*
84:                *********************************************************************************************************
85:                *                                          LOCAL DATA TYPES
86:                *********************************************************************************************************
87:                */
88:                
89:                
90:                /*
91:                *********************************************************************************************************
92:                *                                            LOCAL TABLES
93:                *********************************************************************************************************
94:                */
95:                
96:                
97:                /*
98:                *********************************************************************************************************
99:                *                                       LOCAL GLOBAL VARIABLES
100:               *********************************************************************************************************
101:               */
102:               
103:               
104:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
105:               #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
106:               CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
107:               #endif
108:               
109:               MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
110:               #endif
111:               
112:               MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
113:               
114:               
115:               /*
116:               *********************************************************************************************************
117:               *                                      LOCAL FUNCTION PROTOTYPES
118:               *********************************************************************************************************
119:               */
120:               
121:               static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
122:                                                                      MEM_SEG       *p_seg,
123:                                                                      CPU_ADDR       seg_base_addr,
124:                                                                      CPU_SIZE_T     padding_align,
125:                                                                      CPU_SIZE_T     size);
126:               
127:               static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
128:                                                                      CPU_SIZE_T     size,
129:                                                                      LIB_ERR       *p_err);
130:               
131:               static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
132:                                                                      MEM_SEG       *p_seg,
133:                                                                      CPU_SIZE_T     size,
134:                                                                      CPU_SIZE_T     align,
135:                                                                      CPU_SIZE_T     padding_align,
136:                                                                      CPU_SIZE_T    *p_bytes_reqd,
137:                                                                      LIB_ERR       *p_err);
138:               
139:               static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
140:                                                                      CPU_SIZE_T     size,
141:                                                                      CPU_SIZE_T     align,
142:                                                                      CPU_SIZE_T     padding_align,
143:                                                                      CPU_SIZE_T    *p_bytes_reqd,
144:                                                                      LIB_ERR       *p_err);
145:               
146:               static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
147:                                                                      MEM_DYN_POOL  *p_pool,
148:                                                                      MEM_SEG       *p_seg,
149:                                                                      CPU_SIZE_T     blk_size,
150:                                                                      CPU_SIZE_T     blk_align,
151:                                                                      CPU_SIZE_T     blk_padding_align,
152:                                                                      CPU_SIZE_T     blk_qty_init,
153:                                                                      CPU_SIZE_T     blk_qty_max,
154:                                                                      LIB_ERR       *p_err);
155:               
156:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
157:               static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
158:                                                                      MEM_SEG       *p_seg,
159:                                                                      CPU_SIZE_T     size,
160:                                                                      LIB_ERR       *p_err);
161:               #endif
162:               
163:               #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
164:                    (LIB_MEM_CFG_HEAP_SIZE      >  0u))
165:               static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
166:                                                                      void          *p_mem);
167:               #endif
168:               
169:               
170:               /*
171:               *********************************************************************************************************
172:               *                                     LOCAL CONFIGURATION ERRORS
173:               *********************************************************************************************************
174:               */
175:               
176:               /*
177:               *********************************************************************************************************
178:               *********************************************************************************************************
179:               *                                            GLOBAL FUNCTIONS
180:               *********************************************************************************************************
181:               *********************************************************************************************************
182:               */
183:               
184:               /*
185:               *********************************************************************************************************
186:               *                                             Mem_Init()
187:               *
188:               * Description : (1) Initializes Memory Management Module :
189:               *
190:               *                   (a) Initialize heap memory pool
191:               *                   (b) Initialize      memory pool table
192:               *
193:               *
194:               * Argument(s) : none.
195:               *
196:               * Return(s)   : none.
197:               *
198:               * Caller(s)   : Application.
199:               *
200:               * Note(s)     : (2) Mem_Init() MUST be called ... :
201:               *
202:               *                   (a) ONLY ONCE from a product's application; ...
203:               *                   (b) BEFORE product's application calls any memory library module function(s)
204:               *********************************************************************************************************
205:               */
206:               
207:               void  Mem_Init (void)
208:               {
002D82  FA0004     LNK #0x4
209:               
210:                                                                               /* ------------------ INIT SEG LIST ------------------- */
211:                   Mem_SegHeadPtr = DEF_NULL;
002D84  EF28A8     CLR Mem_SegHeadPtr
212:               
213:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
214:                   {
215:                       LIB_ERR   err;
216:                       CPU_ADDR  heap_base_addr;
217:               
218:               
219:                                                                               /* ------------------ INIT HEAP SEG ------------------- */
220:               #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
221:                       heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
222:               #else
223:                       heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
002D86  213AC0     MOV #0x13AC, W0
002D88  780F00     MOV W0, [W14]
224:               #endif
225:               
226:                       Mem_SegCreate("Heap",
002D8A  29F9A0     MOV #0x9F9A, W0
002D8C  E8808E     INC2 W14, W1
002D8E  780281     MOV W1, W5
002D90  200014     MOV #0x1, W4
002D92  204003     MOV #0x400, W3
002D94  78011E     MOV [W14], W2
002D96  217AC1     MOV #0x17AC, W1
002D98  070204     RCALL Mem_SegCreate
227:                                     &Mem_SegHeap,                             /* Create heap seg.                                     */
228:                                      heap_base_addr,
229:                                      LIB_MEM_CFG_HEAP_SIZE,
230:                                      LIB_MEM_PADDING_ALIGN_NONE,
231:                                     &err);
232:                       if (err != LIB_MEM_ERR_NONE) {
002D9A  90009E     MOV [W14+2], W1
002D9C  227100     MOV #0x2710, W0
002D9E  508F80     SUB W1, W0, [W15]
002DA0  320001     BRA Z, 0x2DA4
233:                           CPU_SW_EXCEPTION(;);
002DA2  07145B     RCALL CPU_SW_Exception
234:                       }
235:                   }
236:               #endif
237:               }
002DA4  FA8000     ULNK
002DA6  060000     RETURN
238:               
239:               
240:               /*
241:               *********************************************************************************************************
242:               *                                              Mem_Clr()
243:               *
244:               * Description : Clears data buffer (see Note #2).
245:               *
246:               * Argument(s) : pmem        Pointer to memory buffer to clear.
247:               *
248:               *               size        Number of data buffer octets to clear (see Note #1).
249:               *
250:               * Return(s)   : none.
251:               *
252:               * Caller(s)   : Application.
253:               *
254:               * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
255:               *
256:               *                   See also 'Mem_Set()  Note #1'.
257:               *
258:               *               (2) Clear data by setting each data octet to 0.
259:               *********************************************************************************************************
260:               */
261:               
262:               void  Mem_Clr (void        *pmem,
263:                              CPU_SIZE_T   size)
264:               {
002DA8  FA0004     LNK #0x4
002DAA  780F00     MOV W0, [W14]
002DAC  980711     MOV W1, [W14+2]
265:                   Mem_Set(pmem,
002DAE  90011E     MOV [W14+2], W2
002DB0  EB4080     CLR.B W1
002DB2  78001E     MOV [W14], W0
002DB4  070002     RCALL Mem_Set
266:                           0u,                                                 /* See Note #2.                                         */
267:                           size);
268:               }
002DB6  FA8000     ULNK
002DB8  060000     RETURN
269:               
270:               
271:               /*
272:               *********************************************************************************************************
273:               *                                              Mem_Set()
274:               *
275:               * Description : Fills data buffer with specified data octet.
276:               *
277:               * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
278:               *
279:               *               data_val    Data fill octet value.
280:               *
281:               *               size        Number of data buffer octets to fill (see Note #1).
282:               *
283:               * Return(s)   : none.
284:               *
285:               * Caller(s)   : Application.
286:               *
287:               * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
288:               *
289:               *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
290:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
291:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
292:               *                   addresses.
293:               *
294:               *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
295:               *                   address boundary.
296:               *
297:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
298:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
299:               *                  'mem_align_mod' arithmetic operation.
300:               *********************************************************************************************************
301:               */
302:               
303:               void  Mem_Set (void        *pmem,
304:                              CPU_INT08U   data_val,
305:                              CPU_SIZE_T   size)
306:               {
002DBA  FA0012     LNK #0x12
002DBC  980760     MOV W0, [W14+12]
002DBE  984F61     MOV.B W1, [W14+14]
002DC0  980F02     MOV W2, [W14+16]
307:                   CPU_SIZE_T   size_rem;
308:                   CPU_ALIGN    data_align;
309:                   CPU_ALIGN   *pmem_align;
310:                   CPU_INT08U  *pmem_08;
311:                   CPU_DATA     mem_align_mod;
312:                   CPU_DATA     i;
313:               
314:               
315:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
316:                   if (size < 1) {                                             /* See Note #1.                                         */
317:                       return;
318:                   }
319:                   if (pmem == (void *)0) {
320:                       return;
321:                   }
322:               #endif
323:               
324:               
325:                   data_align = 0u;
002DC2  EB0000     CLR W0
002DC4  980710     MOV W0, [W14+2]
326:                   for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
002DC6  EB0000     CLR W0
002DC8  980740     MOV W0, [W14+8]
002DCA  37000B     BRA 0x2DE2
002DDC  90004E     MOV [W14+8], W0
002DDE  E80000     INC W0, W0
002DE0  980740     MOV W0, [W14+8]
002DE2  90004E     MOV [W14+8], W0
002DE4  500FE1     SUB W0, #0x1, [W15]
002DE6  36FFF2     BRA LEU, 0x2DCC
327:                       data_align <<=  DEF_OCTET_NBR_BITS;
002DCC  90001E     MOV [W14+2], W0
002DCE  DD0048     SL W0, #8, W0
002DD0  980710     MOV W0, [W14+2]
328:                       data_align  |= (CPU_ALIGN)data_val;
002DD2  90486E     MOV.B [W14+14], W0
002DD4  FB8000     ZE W0, W0
002DD6  90009E     MOV [W14+2], W1
002DD8  700001     IOR W0, W1, W0
002DDA  980710     MOV W0, [W14+2]
329:                   }
330:               
331:                   size_rem      =  size;
002DE8  90088E     MOV [W14+16], W1
002DEA  780F01     MOV W1, [W14]
332:                   mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
002DEC  90006E     MOV [W14+12], W0
002DEE  784000     MOV.B W0, W0
002DF0  FB8000     ZE W0, W0
002DF2  600061     AND W0, #0x1, W0
002DF4  980750     MOV W0, [W14+10]
333:               
334:                   pmem_08 = (CPU_INT08U *)pmem;
002DF6  9000EE     MOV [W14+12], W1
002DF8  980731     MOV W1, [W14+6]
335:                   if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
002DFA  90005E     MOV [W14+10], W0
002DFC  E00000     CP0 W0
002DFE  320013     BRA Z, 0x2E26
336:                       i = mem_align_mod;
002E00  9000DE     MOV [W14+10], W1
002E02  980741     MOV W1, [W14+8]
337:                       while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
002E04  37000A     BRA 0x2E1A
002E1A  78001E     MOV [W14], W0
002E1C  E00000     CP0 W0
002E1E  320003     BRA Z, 0x2E26
002E20  90004E     MOV [W14+8], W0
002E22  500FE1     SUB W0, #0x1, [W15]
002E24  36FFF0     BRA LEU, 0x2E06
338:                              (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
339:                          *pmem_08++ = data_val;
002E06  90003E     MOV [W14+6], W0
002E08  9048EE     MOV.B [W14+14], W1
002E0A  784801     MOV.B W1, [W0]
002E0C  90003E     MOV [W14+6], W0
002E0E  E80000     INC W0, W0
002E10  980730     MOV W0, [W14+6]
340:                           size_rem -= sizeof(CPU_INT08U);
002E12  E90F1E     DEC [W14], [W14]
341:                           i++;
002E14  90004E     MOV [W14+8], W0
002E16  E80000     INC W0, W0
002E18  980740     MOV W0, [W14+8]
342:                       }
343:                   }
344:               
345:                   pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
002E26  9000BE     MOV [W14+6], W1
002E28  980721     MOV W1, [W14+4]
346:                   while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
002E2A  370007     BRA 0x2E3A
002E3A  78001E     MOV [W14], W0
002E3C  500FE1     SUB W0, #0x1, [W15]
002E3E  3EFFF6     BRA GTU, 0x2E2C
347:                      *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
002E2C  90002E     MOV [W14+4], W0
002E2E  90009E     MOV [W14+2], W1
002E30  780801     MOV W1, [W0]
002E32  90002E     MOV [W14+4], W0
002E34  E88000     INC2 W0, W0
002E36  980720     MOV W0, [W14+4]
348:                       size_rem    -= sizeof(CPU_ALIGN);
002E38  E98F1E     DEC2 [W14], [W14]
349:                   }
350:               
351:                   pmem_08 = (CPU_INT08U *)pmem_align;
002E40  9000AE     MOV [W14+4], W1
002E42  980731     MOV W1, [W14+6]
352:                   while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
002E44  370007     BRA 0x2E54
002E54  78001E     MOV [W14], W0
002E56  E00000     CP0 W0
002E58  3AFFF6     BRA NZ, 0x2E46
353:                      *pmem_08++   = data_val;
002E46  90003E     MOV [W14+6], W0
002E48  9048EE     MOV.B [W14+14], W1
002E4A  784801     MOV.B W1, [W0]
002E4C  90003E     MOV [W14+6], W0
002E4E  E80000     INC W0, W0
002E50  980730     MOV W0, [W14+6]
354:                       size_rem   -= sizeof(CPU_INT08U);
002E52  E90F1E     DEC [W14], [W14]
355:                   }
356:               }
002E5A  FA8000     ULNK
002E5C  060000     RETURN
357:               
358:               
359:               /*
360:               *********************************************************************************************************
361:               *                                             Mem_Copy()
362:               *
363:               * Description : Copies data octets from one memory buffer to another memory buffer.
364:               *
365:               * Argument(s) : pdest       Pointer to destination memory buffer.
366:               *
367:               *               psrc        Pointer to source      memory buffer.
368:               *
369:               *               size        Number of octets to copy (see Note #1).
370:               *
371:               * Return(s)   : none.
372:               *
373:               * Caller(s)   : Application.
374:               *
375:               * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
376:               *
377:               *               (2) Memory buffers NOT checked for overlapping.
378:               *
379:               *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
380:               *                       copying takes place between objects that overlap, the behavior is undefined".
381:               *
382:               *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
383:               *                       successfully copy to a destination memory buffer at a lower  address value even
384:               *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
385:               *                       word copy overlaps.
386:               *
387:               *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
388:               *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
389:               *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
390:               *                       ever overlap.
391:               *
392:               *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
393:               *                       buffers as long as the source memory buffer is at a higher address value than the
394:               *                       destination memory buffer.
395:               *
396:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
397:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
398:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
399:               *                   addresses.
400:               *
401:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
402:               *                   address boundary.
403:               *
404:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
405:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
406:               *                  'mem_align_mod' arithmetic operation.
407:               *********************************************************************************************************
408:               */
409:               
410:               #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
411:               void  Mem_Copy (       void        *pdest,
412:                               const  void        *psrc,
413:                                      CPU_SIZE_T   size)
414:               {
002E5E  FA001A     LNK #0x1A
002E60  980F20     MOV W0, [W14+20]
002E62  980F31     MOV W1, [W14+22]
002E64  980F42     MOV W2, [W14+24]
415:                          CPU_SIZE_T    size_rem;
416:                          CPU_SIZE_T    mem_gap_octets;
417:                          CPU_ALIGN    *pmem_align_dest;
418:                   const  CPU_ALIGN    *pmem_align_src;
419:                          CPU_INT08U   *pmem_08_dest;
420:                   const  CPU_INT08U   *pmem_08_src;
421:                          CPU_DATA      i;
422:                          CPU_DATA      mem_align_mod_dest;
423:                          CPU_DATA      mem_align_mod_src;
424:                          CPU_BOOLEAN   mem_aligned;
425:               
426:               
427:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
428:                   if (size < 1) {                                             /* See Note #1.                                         */
429:                       return;
430:                   }
431:                   if (pdest == (void *)0) {
432:                       return;
433:                   }
434:                   if (psrc  == (void *)0) {
435:                       return;
436:                   }
437:               #endif
438:               
439:               
440:                   size_rem           =  size;
002E66  9008CE     MOV [W14+24], W1
002E68  780F01     MOV W1, [W14]
441:               
442:                   pmem_08_dest       = (      CPU_INT08U *)pdest;
002E6A  9008AE     MOV [W14+20], W1
002E6C  980731     MOV W1, [W14+6]
443:                   pmem_08_src        = (const CPU_INT08U *)psrc;
002E6E  9008BE     MOV [W14+22], W1
002E70  980741     MOV W1, [W14+8]
444:               
445:                   mem_gap_octets     = pmem_08_src - pmem_08_dest;
002E72  9000CE     MOV [W14+8], W1
002E74  90003E     MOV [W14+6], W0
002E76  508000     SUB W1, W0, W0
002E78  980760     MOV W0, [W14+12]
446:               
447:               
448:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
002E7A  90006E     MOV [W14+12], W0
002E7C  500FE1     SUB W0, #0x1, [W15]
002E7E  360052     BRA LEU, 0x2F24
449:                                                                               /* See Note #4.                                         */
450:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
002E80  90003E     MOV [W14+6], W0
002E82  784000     MOV.B W0, W0
002E84  FB8000     ZE W0, W0
002E86  600061     AND W0, #0x1, W0
002E88  980770     MOV W0, [W14+14]
451:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
002E8A  90004E     MOV [W14+8], W0
002E8C  784000     MOV.B W0, W0
002E8E  FB8000     ZE W0, W0
002E90  600061     AND W0, #0x1, W0
002E92  980F00     MOV W0, [W14+16]
452:               
453:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
002E94  9000FE     MOV [W14+14], W1
002E96  90080E     MOV [W14+16], W0
002E98  508F80     SUB W1, W0, [W15]
002E9A  3A0002     BRA NZ, 0x2EA0
002E9C  B3C010     MOV.B #0x1, W0
002E9E  370001     BRA 0x2EA2
002EA0  EB4000     CLR.B W0
002EA2  985720     MOV.B W0, [W14+18]
454:               
455:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
002EA4  90502E     MOV.B [W14+18], W0
002EA6  504FE1     SUB.B W0, #0x1, [W15]
002EA8  3A003D     BRA NZ, 0x2F24
456:                                                                               /* ... optimize copy for mem buf alignment.             */
457:                           if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
002EAA  90007E     MOV [W14+14], W0
002EAC  E00000     CP0 W0
002EAE  320017     BRA Z, 0x2EDE
458:                               i = mem_align_mod_dest;
002EB0  9000FE     MOV [W14+14], W1
002EB2  980751     MOV W1, [W14+10]
459:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
002EB4  37000E     BRA 0x2ED2
002ED2  78001E     MOV [W14], W0
002ED4  E00000     CP0 W0
002ED6  320003     BRA Z, 0x2EDE
002ED8  90005E     MOV [W14+10], W0
002EDA  500FE1     SUB W0, #0x1, [W15]
002EDC  36FFEC     BRA LEU, 0x2EB6
460:                                      (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
461:                                  *pmem_08_dest++ = *pmem_08_src++;
002EB6  90004E     MOV [W14+8], W0
002EB8  784090     MOV.B [W0], W1
002EBA  90003E     MOV [W14+6], W0
002EBC  784801     MOV.B W1, [W0]
002EBE  90003E     MOV [W14+6], W0
002EC0  E80000     INC W0, W0
002EC2  980730     MOV W0, [W14+6]
002EC4  90004E     MOV [W14+8], W0
002EC6  E80000     INC W0, W0
002EC8  980740     MOV W0, [W14+8]
462:                                   size_rem      -=  sizeof(CPU_INT08U);
002ECA  E90F1E     DEC [W14], [W14]
463:                                   i++;
002ECC  90005E     MOV [W14+10], W0
002ECE  E80000     INC W0, W0
002ED0  980750     MOV W0, [W14+10]
464:                               }
465:                           }
466:               
467:                           pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
002EDE  9000BE     MOV [W14+6], W1
002EE0  980711     MOV W1, [W14+2]
468:                           pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
002EE2  9000CE     MOV [W14+8], W1
002EE4  980721     MOV W1, [W14+4]
469:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
002EE6  37000B     BRA 0x2EFE
002EFE  78001E     MOV [W14], W0
002F00  500FE1     SUB W0, #0x1, [W15]
002F02  3EFFF2     BRA GTU, 0x2EE8
470:                              *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
002EE8  90002E     MOV [W14+4], W0
002EEA  780090     MOV [W0], W1
002EEC  90001E     MOV [W14+2], W0
002EEE  780801     MOV W1, [W0]
002EF0  90001E     MOV [W14+2], W0
002EF2  E88000     INC2 W0, W0
002EF4  980710     MOV W0, [W14+2]
002EF6  90002E     MOV [W14+4], W0
002EF8  E88000     INC2 W0, W0
002EFA  980720     MOV W0, [W14+4]
471:                               size_rem         -=  sizeof(CPU_ALIGN);
002EFC  E98F1E     DEC2 [W14], [W14]
472:                           }
473:               
474:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
002F04  90009E     MOV [W14+2], W1
002F06  980731     MOV W1, [W14+6]
475:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
002F08  9000AE     MOV [W14+4], W1
002F0A  980741     MOV W1, [W14+8]
476:                       }
477:                   }
478:               
479:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
002F0C  37000B     BRA 0x2F24
002F24  78001E     MOV [W14], W0
002F26  E00000     CP0 W0
002F28  3AFFF2     BRA NZ, 0x2F0E
480:                      *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
002F0E  90004E     MOV [W14+8], W0
002F10  784090     MOV.B [W0], W1
002F12  90003E     MOV [W14+6], W0
002F14  784801     MOV.B W1, [W0]
002F16  90003E     MOV [W14+6], W0
002F18  E80000     INC W0, W0
002F1A  980730     MOV W0, [W14+6]
002F1C  90004E     MOV [W14+8], W0
002F1E  E80000     INC W0, W0
002F20  980740     MOV W0, [W14+8]
481:                       size_rem      -=  sizeof(CPU_INT08U);
002F22  E90F1E     DEC [W14], [W14]
482:                   }
483:               }
002F2A  FA8000     ULNK
002F2C  060000     RETURN
484:               #endif
485:               
486:               
487:               /*
488:               *********************************************************************************************************
489:               *                                             Mem_Move()
490:               *
491:               * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
492:               *               memory buffer. Overlapping is correctly handled for all move operations.
493:               *
494:               * Argument(s) : pdest       Pointer to destination memory buffer.
495:               *
496:               *               psrc        Pointer to source      memory buffer.
497:               *
498:               *               size        Number of octets to move (see Note #1).
499:               *
500:               * Return(s)   : none.
501:               *
502:               * Caller(s)   : Application.
503:               *
504:               * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
505:               *
506:               *               (2) Memory buffers checked for overlapping.
507:               *
508:               *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
509:               *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
510:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
511:               *                   addresses.
512:               *
513:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
514:               *                   address boundary.
515:               *
516:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
517:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
518:               *                  'mem_align_mod' arithmetic operation.
519:               *********************************************************************************************************
520:               */
521:               
522:               void  Mem_Move (       void        *pdest,
523:                               const  void        *psrc,
524:                                      CPU_SIZE_T   size)
525:               {
002F2E  FA001A     LNK #0x1A
002F30  980F20     MOV W0, [W14+20]
002F32  980F31     MOV W1, [W14+22]
002F34  980F42     MOV W2, [W14+24]
526:                          CPU_SIZE_T    size_rem;
527:                          CPU_SIZE_T    mem_gap_octets;
528:                          CPU_ALIGN    *pmem_align_dest;
529:                   const  CPU_ALIGN    *pmem_align_src;
530:                          CPU_INT08U   *pmem_08_dest;
531:                   const  CPU_INT08U   *pmem_08_src;
532:                          CPU_INT08S    i;
533:                          CPU_DATA      mem_align_mod_dest;
534:                          CPU_DATA      mem_align_mod_src;
535:                          CPU_BOOLEAN   mem_aligned;
536:               
537:               
538:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
539:                   if (size < 1) {
540:                       return;
541:                   }
542:                   if (pdest == (void *)0) {
543:                       return;
544:                   }
545:                   if (psrc  == (void *)0) {
546:                       return;
547:                   }
548:               #endif
549:               
550:                   pmem_08_src  = (const CPU_INT08U *)psrc;
002F36  9008BE     MOV [W14+22], W1
002F38  980741     MOV W1, [W14+8]
551:                   pmem_08_dest = (      CPU_INT08U *)pdest;
002F3A  9008AE     MOV [W14+20], W1
002F3C  980731     MOV W1, [W14+6]
552:                   if (pmem_08_src > pmem_08_dest) {
002F3E  9000CE     MOV [W14+8], W1
002F40  90003E     MOV [W14+6], W0
002F42  508F80     SUB W1, W0, [W15]
002F44  360005     BRA LEU, 0x2F50
553:                       Mem_Copy(pdest, psrc, size);
002F46  90094E     MOV [W14+24], W2
002F48  9008BE     MOV [W14+22], W1
002F4A  90082E     MOV [W14+20], W0
002F4C  07FF88     RCALL Mem_Copy
554:                       return;
002F4E  37006C     BRA 0x3028
555:                   }
556:               
557:                   size_rem           =  size;
002F50  9008CE     MOV [W14+24], W1
002F52  780F01     MOV W1, [W14]
558:               
559:                   pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
002F54  9008AE     MOV [W14+20], W1
002F56  90084E     MOV [W14+24], W0
002F58  E90000     DEC W0, W0
002F5A  408000     ADD W1, W0, W0
002F5C  980730     MOV W0, [W14+6]
560:                   pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
002F5E  9008BE     MOV [W14+22], W1
002F60  90084E     MOV [W14+24], W0
002F62  E90000     DEC W0, W0
002F64  408000     ADD W1, W0, W0
002F66  980740     MOV W0, [W14+8]
561:               
562:                   mem_gap_octets     = pmem_08_dest - pmem_08_src;
002F68  9000BE     MOV [W14+6], W1
002F6A  90004E     MOV [W14+8], W0
002F6C  508000     SUB W1, W0, W0
002F6E  980760     MOV W0, [W14+12]
563:               
564:               
565:                   if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
002F70  90006E     MOV [W14+12], W0
002F72  500FE1     SUB W0, #0x1, [W15]
002F74  360056     BRA LEU, 0x3022
566:               
567:                                                                               /* See Note #4.                                         */
568:                       mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
002F76  90003E     MOV [W14+6], W0
002F78  784000     MOV.B W0, W0
002F7A  FB8000     ZE W0, W0
002F7C  600061     AND W0, #0x1, W0
002F7E  980770     MOV W0, [W14+14]
569:                       mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
002F80  90004E     MOV [W14+8], W0
002F82  784000     MOV.B W0, W0
002F84  FB8000     ZE W0, W0
002F86  600061     AND W0, #0x1, W0
002F88  980F00     MOV W0, [W14+16]
570:               
571:                       mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
002F8A  9000FE     MOV [W14+14], W1
002F8C  90080E     MOV [W14+16], W0
002F8E  508F80     SUB W1, W0, [W15]
002F90  3A0002     BRA NZ, 0x2F96
002F92  B3C010     MOV.B #0x1, W0
002F94  370001     BRA 0x2F98
002F96  EB4000     CLR.B W0
002F98  985720     MOV.B W0, [W14+18]
572:               
573:                       if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
002F9A  90502E     MOV.B [W14+18], W0
002F9C  504FE1     SUB.B W0, #0x1, [W15]
002F9E  3A0041     BRA NZ, 0x3022
574:                                                                               /* ... optimize copy for mem buf alignment.             */
575:                           if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
002FA0  90007E     MOV [W14+14], W0
002FA2  500FE1     SUB W0, #0x1, [W15]
002FA4  320017     BRA Z, 0x2FD4
576:                               i = mem_align_mod_dest;
002FA6  90007E     MOV [W14+14], W0
002FA8  984F20     MOV.B W0, [W14+10]
577:                               while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
002FAA  37000E     BRA 0x2FC8
002FC8  78001E     MOV [W14], W0
002FCA  E00000     CP0 W0
002FCC  320003     BRA Z, 0x2FD4
002FCE  90482E     MOV.B [W14+10], W0
002FD0  E00400     CP0.B W0
002FD2  3DFFEC     BRA GE, 0x2FAC
578:                                      (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
579:                                  *pmem_08_dest-- = *pmem_08_src--;
002FAC  90004E     MOV [W14+8], W0
002FAE  784090     MOV.B [W0], W1
002FB0  90003E     MOV [W14+6], W0
002FB2  784801     MOV.B W1, [W0]
002FB4  90003E     MOV [W14+6], W0
002FB6  E90000     DEC W0, W0
002FB8  980730     MOV W0, [W14+6]
002FBA  90004E     MOV [W14+8], W0
002FBC  E90000     DEC W0, W0
002FBE  980740     MOV W0, [W14+8]
580:                                   size_rem      -=  sizeof(CPU_INT08U);
002FC0  E90F1E     DEC [W14], [W14]
581:                                   i--;
002FC2  90482E     MOV.B [W14+10], W0
002FC4  E94000     DEC.B W0, W0
002FC6  984F20     MOV.B W0, [W14+10]
582:                               }
583:                           }
584:               
585:                                                                               /* See Note #3.                                         */
586:                           pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
002FD4  90003E     MOV [W14+6], W0
002FD6  E90000     DEC W0, W0
002FD8  980710     MOV W0, [W14+2]
587:                           pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
002FDA  90004E     MOV [W14+8], W0
002FDC  E90000     DEC W0, W0
002FDE  980720     MOV W0, [W14+4]
588:                           while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
002FE0  37000B     BRA 0x2FF8
002FF8  78001E     MOV [W14], W0
002FFA  500FE1     SUB W0, #0x1, [W15]
002FFC  3EFFF2     BRA GTU, 0x2FE2
589:                              *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
002FE2  90002E     MOV [W14+4], W0
002FE4  780090     MOV [W0], W1
002FE6  90001E     MOV [W14+2], W0
002FE8  780801     MOV W1, [W0]
002FEA  90001E     MOV [W14+2], W0
002FEC  E98000     DEC2 W0, W0
002FEE  980710     MOV W0, [W14+2]
002FF0  90002E     MOV [W14+4], W0
002FF2  E98000     DEC2 W0, W0
002FF4  980720     MOV W0, [W14+4]
590:                               size_rem         -=  sizeof(CPU_ALIGN);
002FF6  E98F1E     DEC2 [W14], [W14]
591:                           }
592:               
593:                           pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
002FFE  90001E     MOV [W14+2], W0
003000  E80000     INC W0, W0
003002  980730     MOV W0, [W14+6]
594:                           pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
003004  90002E     MOV [W14+4], W0
003006  E80000     INC W0, W0
003008  980740     MOV W0, [W14+8]
595:               
596:                       }
597:                   }
598:               
599:                   while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
00300A  37000B     BRA 0x3022
003022  78001E     MOV [W14], W0
003024  E00000     CP0 W0
003026  3AFFF2     BRA NZ, 0x300C
600:                      *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
00300C  90004E     MOV [W14+8], W0
00300E  784090     MOV.B [W0], W1
003010  90003E     MOV [W14+6], W0
003012  784801     MOV.B W1, [W0]
003014  90003E     MOV [W14+6], W0
003016  E90000     DEC W0, W0
003018  980730     MOV W0, [W14+6]
00301A  90004E     MOV [W14+8], W0
00301C  E90000     DEC W0, W0
00301E  980740     MOV W0, [W14+8]
601:                       size_rem      -=  sizeof(CPU_INT08U);
003020  E90F1E     DEC [W14], [W14]
602:                   }
603:               }
003028  FA8000     ULNK
00302A  060000     RETURN
604:               
605:               
606:               /*
607:               *********************************************************************************************************
608:               *                                              Mem_Cmp()
609:               *
610:               * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
611:               *
612:               * Argument(s) : p1_mem      Pointer to first  memory buffer.
613:               *
614:               *               p2_mem      Pointer to second memory buffer.
615:               *
616:               *               size        Number of data buffer octets to compare (see Note #1).
617:               *
618:               * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
619:               *
620:               *               DEF_NO,  otherwise.
621:               *
622:               * Caller(s)   : Application.
623:               *
624:               * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
625:               *                   identical null compare.
626:               *
627:               *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
628:               *                   network address buffers.  Consequently, memory buffer comparison is more efficient
629:               *                   if the comparison starts from the end of the memory buffers which will abort sooner
630:               *                   on dissimilar memory buffers that vary only in the least significant octets.
631:               *
632:               *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
633:               *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
634:               *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
635:               *                   addresses.
636:               *
637:               *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
638:               *                   address boundary.
639:               *
640:               *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
641:               *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
642:               *                  'mem_align_mod' arithmetic operation.
643:               *********************************************************************************************************
644:               */
645:               
646:               CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
647:                                     const  void        *p2_mem,
648:                                            CPU_SIZE_T   size)
649:               {
00302C  FA001A     LNK #0x1A
00302E  980F20     MOV W0, [W14+20]
003030  980F31     MOV W1, [W14+22]
003032  980F42     MOV W2, [W14+24]
650:                          CPU_SIZE_T    size_rem;
651:                          CPU_ALIGN    *p1_mem_align;
652:                          CPU_ALIGN    *p2_mem_align;
653:                   const  CPU_INT08U   *p1_mem_08;
654:                   const  CPU_INT08U   *p2_mem_08;
655:                          CPU_DATA      i;
656:                          CPU_DATA      mem_align_mod_1;
657:                          CPU_DATA      mem_align_mod_2;
658:                          CPU_BOOLEAN   mem_aligned;
659:                          CPU_BOOLEAN   mem_cmp;
660:               
661:               
662:                   if (size < 1) {                                             /* See Note #1.                                         */
003034  90084E     MOV [W14+24], W0
003036  E00000     CP0 W0
003038  3A0002     BRA NZ, 0x303E
663:                       return (DEF_YES);
00303A  B3C010     MOV.B #0x1, W0
00303C  370084     BRA 0x3146
664:                   }
665:                   if (p1_mem == (void *)0) {
00303E  90082E     MOV [W14+20], W0
003040  E00000     CP0 W0
003042  3A0002     BRA NZ, 0x3048
666:                       return (DEF_NO);
003044  EB4000     CLR.B W0
003046  37007F     BRA 0x3146
667:                   }
668:                   if (p2_mem == (void *)0) {
003048  90083E     MOV [W14+22], W0
00304A  E00000     CP0 W0
00304C  3A0002     BRA NZ, 0x3052
669:                       return (DEF_NO);
00304E  EB4000     CLR.B W0
003050  37007A     BRA 0x3146
670:                   }
671:               
672:               
673:                   mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
003052  B3C010     MOV.B #0x1, W0
003054  984F40     MOV.B W0, [W14+12]
674:                   size_rem        =  size;
003056  9008CE     MOV [W14+24], W1
003058  780F01     MOV W1, [W14]
675:                                                                               /* Start @ end of mem bufs (see Note #2).               */
676:                   p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
00305A  9008AE     MOV [W14+20], W1
00305C  90084E     MOV [W14+24], W0
00305E  408000     ADD W1, W0, W0
003060  980730     MOV W0, [W14+6]
677:                   p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
003062  9008BE     MOV [W14+22], W1
003064  90084E     MOV [W14+24], W0
003066  408000     ADD W1, W0, W0
003068  980740     MOV W0, [W14+8]
678:                                                                               /* See Note #4.                                         */
679:                   mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
00306A  90003E     MOV [W14+6], W0
00306C  784000     MOV.B W0, W0
00306E  FB8000     ZE W0, W0
003070  600061     AND W0, #0x1, W0
003072  980770     MOV W0, [W14+14]
680:                   mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
003074  90004E     MOV [W14+8], W0
003076  784000     MOV.B W0, W0
003078  FB8000     ZE W0, W0
00307A  600061     AND W0, #0x1, W0
00307C  980F00     MOV W0, [W14+16]
681:               
682:                   mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
00307E  9000FE     MOV [W14+14], W1
003080  90080E     MOV [W14+16], W0
003082  508F80     SUB W1, W0, [W15]
003084  3A0002     BRA NZ, 0x308A
003086  B3C010     MOV.B #0x1, W0
003088  370001     BRA 0x308C
00308A  EB4000     CLR.B W0
00308C  985720     MOV.B W0, [W14+18]
683:               
684:                   if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
00308E  90502E     MOV.B [W14+18], W0
003090  504FE1     SUB.B W0, #0x1, [W15]
003092  3A0052     BRA NZ, 0x3138
685:                                                                               /* ... optimize cmp for mem buf alignment.              */
686:                       if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
003094  90007E     MOV [W14+14], W0
003096  E00000     CP0 W0
003098  32001E     BRA Z, 0x30D6
687:                           i = mem_align_mod_1;
00309A  9000FE     MOV [W14+14], W1
00309C  980751     MOV W1, [W14+10]
688:                           while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
00309E  370012     BRA 0x30C4
0030C4  90484E     MOV.B [W14+12], W0
0030C6  504FE1     SUB.B W0, #0x1, [W15]
0030C8  3A0006     BRA NZ, 0x30D6
0030CA  78001E     MOV [W14], W0
0030CC  E00000     CP0 W0
0030CE  320003     BRA Z, 0x30D6
689:                                  (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
0030D0  90005E     MOV [W14+10], W0
0030D2  E00000     CP0 W0
0030D4  3AFFE5     BRA NZ, 0x30A0
690:                                  (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
691:                               p1_mem_08--;
0030A0  90003E     MOV [W14+6], W0
0030A2  E90000     DEC W0, W0
0030A4  980730     MOV W0, [W14+6]
692:                               p2_mem_08--;
0030A6  90004E     MOV [W14+8], W0
0030A8  E90000     DEC W0, W0
0030AA  980740     MOV W0, [W14+8]
693:                               if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
0030AC  90003E     MOV [W14+6], W0
0030AE  784090     MOV.B [W0], W1
0030B0  90004E     MOV [W14+8], W0
0030B2  784010     MOV.B [W0], W0
0030B4  50CF80     SUB.B W1, W0, [W15]
0030B6  320002     BRA Z, 0x30BC
694:                                    mem_cmp = DEF_NO;
0030B8  EB4000     CLR.B W0
0030BA  984F40     MOV.B W0, [W14+12]
695:                               }
696:                               size_rem -= sizeof(CPU_INT08U);
0030BC  E90F1E     DEC [W14], [W14]
697:                               i--;
0030BE  90005E     MOV [W14+10], W0
0030C0  E90000     DEC W0, W0
0030C2  980750     MOV W0, [W14+10]
698:                           }
699:                       }
700:               
701:                       if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
0030D6  90484E     MOV.B [W14+12], W0
0030D8  504FE1     SUB.B W0, #0x1, [W15]
0030DA  3A002E     BRA NZ, 0x3138
702:                           p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
0030DC  9000BE     MOV [W14+6], W1
0030DE  980711     MOV W1, [W14+2]
703:                           p2_mem_align = (CPU_ALIGN *)p2_mem_08;
0030E0  9000CE     MOV [W14+8], W1
0030E2  980721     MOV W1, [W14+4]
704:               
705:                           while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
0030E4  37000F     BRA 0x3104
003104  90484E     MOV.B [W14+12], W0
003106  504FE1     SUB.B W0, #0x1, [W15]
003108  3A0003     BRA NZ, 0x3110
00310A  78001E     MOV [W14], W0
00310C  500FE1     SUB W0, #0x1, [W15]
00310E  3EFFEB     BRA GTU, 0x30E6
706:                                  (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
707:                               p1_mem_align--;
0030E6  90001E     MOV [W14+2], W0
0030E8  E98000     DEC2 W0, W0
0030EA  980710     MOV W0, [W14+2]
708:                               p2_mem_align--;
0030EC  90002E     MOV [W14+4], W0
0030EE  E98000     DEC2 W0, W0
0030F0  980720     MOV W0, [W14+4]
709:                               if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
0030F2  90001E     MOV [W14+2], W0
0030F4  780090     MOV [W0], W1
0030F6  90002E     MOV [W14+4], W0
0030F8  780010     MOV [W0], W0
0030FA  508F80     SUB W1, W0, [W15]
0030FC  320002     BRA Z, 0x3102
710:                                    mem_cmp = DEF_NO;
0030FE  EB4000     CLR.B W0
003100  984F40     MOV.B W0, [W14+12]
711:                               }
712:                               size_rem -= sizeof(CPU_ALIGN);
003102  E98F1E     DEC2 [W14], [W14]
713:                           }
714:               
715:                           p1_mem_08 = (CPU_INT08U *)p1_mem_align;
003110  90009E     MOV [W14+2], W1
003112  980731     MOV W1, [W14+6]
716:                           p2_mem_08 = (CPU_INT08U *)p2_mem_align;
003114  9000AE     MOV [W14+4], W1
003116  980741     MOV W1, [W14+8]
717:                       }
718:                   }
719:               
720:                   while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
003118  37000F     BRA 0x3138
003138  90484E     MOV.B [W14+12], W0
00313A  504FE1     SUB.B W0, #0x1, [W15]
00313C  3A0003     BRA NZ, 0x3144
00313E  78001E     MOV [W14], W0
003140  E00000     CP0 W0
003142  3AFFEB     BRA NZ, 0x311A
721:                          (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
722:                       p1_mem_08--;
00311A  90003E     MOV [W14+6], W0
00311C  E90000     DEC W0, W0
00311E  980730     MOV W0, [W14+6]
723:                       p2_mem_08--;
003120  90004E     MOV [W14+8], W0
003122  E90000     DEC W0, W0
003124  980740     MOV W0, [W14+8]
724:                       if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
003126  90003E     MOV [W14+6], W0
003128  784090     MOV.B [W0], W1
00312A  90004E     MOV [W14+8], W0
00312C  784010     MOV.B [W0], W0
00312E  50CF80     SUB.B W1, W0, [W15]
003130  320002     BRA Z, 0x3136
725:                            mem_cmp = DEF_NO;
003132  EB4000     CLR.B W0
003134  984F40     MOV.B W0, [W14+12]
726:                       }
727:                       size_rem -= sizeof(CPU_INT08U);
003136  E90F1E     DEC [W14], [W14]
728:                   }
729:               
730:                   return (mem_cmp);
003144  90484E     MOV.B [W14+12], W0
731:               }
003146  FA8000     ULNK
003148  060000     RETURN
732:               
733:               
734:               /*
735:               *********************************************************************************************************
736:               *                                           Mem_HeapAlloc()
737:               *
738:               * Description : Allocates a memory block from the heap memory segment.
739:               *
740:               * Argument(s) : size            Size      of memory block to allocate (in bytes).
741:               *
742:               *               align           Alignment of memory block to specific word boundary (in bytes).
743:               *
744:               *               p_bytes_reqd    Optional pointer to a variable to ... :
745:               *
746:               *                                   (a) Return the number of bytes required to successfully
747:               *                                           allocate the memory block, if any error(s);
748:               *                                   (b) Return 0, otherwise.
749:               *
750:               *               p_err           Pointer to variable that will receive the return error code from this function :
751:               *
752:               *                                   LIB_MEM_ERR_NONE                Operation was successful.
753:               *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
754:               *
755:               *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
756:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
757:               *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
758:               *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
759:               *
760:               * Return(s)   : Pointer to memory block, if NO error(s).
761:               *
762:               *               Pointer to NULL,         otherwise.
763:               *
764:               * Caller(s)   : Application.
765:               *
766:               * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
767:               *                   validation or function handling in case of any error(s).
768:               *
769:               *               (2) This function is DEPRECATED and will be removed in a future version of this product.
770:               *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
771:               *********************************************************************************************************
772:               */
773:               
774:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
775:               void  *Mem_HeapAlloc (CPU_SIZE_T   size,
776:                                     CPU_SIZE_T   align,
777:                                     CPU_SIZE_T  *p_bytes_reqd,
778:                                     LIB_ERR     *p_err)
779:               {
00314A  FA000A     LNK #0xA
00314C  980710     MOV W0, [W14+2]
00314E  980721     MOV W1, [W14+4]
003150  980732     MOV W2, [W14+6]
003152  980743     MOV W3, [W14+8]
780:                   void  *p_mem;
781:               
782:               
783:                   p_mem = Mem_SegAllocInternal(DEF_NULL,
003154  90034E     MOV [W14+8], W6
003156  9002BE     MOV [W14+6], W5
003158  200014     MOV #0x1, W4
00315A  9001AE     MOV [W14+4], W3
00315C  90011E     MOV [W14+2], W2
00315E  217AC1     MOV #0x17AC, W1
003160  EB0000     CLR W0
003162  070370     RCALL _Mem_SegAllocInternal
003164  780F00     MOV W0, [W14]
784:                                               &Mem_SegHeap,
785:                                                size,
786:                                                align,
787:                                                LIB_MEM_CFG_HEAP_PADDING_ALIGN,
788:                                                p_bytes_reqd,
789:                                                p_err);
790:                   if (*p_err == LIB_MEM_ERR_SEG_OVF) {
003166  90004E     MOV [W14+8], W0
003168  780090     MOV [W0], W1
00316A  227D90     MOV #0x27D9, W0
00316C  508F80     SUB W1, W0, [W15]
00316E  3A0003     BRA NZ, 0x3176
791:                      *p_err = LIB_MEM_ERR_HEAP_OVF;
003170  90004E     MOV [W14+8], W0
003172  227E31     MOV #0x27E3, W1
003174  780801     MOV W1, [W0]
792:                   }
793:               
794:                   return (p_mem);
003176  78001E     MOV [W14], W0
795:               }
003178  FA8000     ULNK
00317A  060000     RETURN
796:               #endif
797:               
798:               
799:               /*
800:               *********************************************************************************************************
801:               *                                        Mem_HeapGetSizeRem()
802:               *
803:               * Description : Gets remaining heap memory size available to allocate.
804:               *
805:               * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
806:               *
807:               *               p_err       Pointer to variable that will receive the return error code from this function
808:               *
809:               *                               LIB_MEM_ERR_NONE                Operation was successful.
810:               *
811:               *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
812:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
813:               *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
814:               *
815:               * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
816:               *
817:               *               0,                                     otherwise.
818:               *
819:               * Caller(s)   : Application.
820:               *
821:               * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
822:               *                   Mem_SegRemSizeGet() should be used instead.
823:               *********************************************************************************************************
824:               */
825:               
826:               #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
827:               CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
828:                                               LIB_ERR     *p_err)
829:               {
00317C  FA0006     LNK #0x6
00317E  980710     MOV W0, [W14+2]
003180  980721     MOV W1, [W14+4]
830:                   CPU_SIZE_T  rem_size;
831:               
832:               
833:                   rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
003182  9001AE     MOV [W14+4], W3
003184  EB0100     CLR W2
003186  90009E     MOV [W14+2], W1
003188  217AC0     MOV #0x17AC, W0
00318A  07003D     RCALL Mem_SegRemSizeGet
00318C  780F00     MOV W0, [W14]
834:                                                 align,
835:                                                 DEF_NULL,
836:                                                 p_err);
837:                   if (*p_err != LIB_MEM_ERR_NONE) {
00318E  90002E     MOV [W14+4], W0
003190  780090     MOV [W0], W1
003192  227100     MOV #0x2710, W0
003194  508F80     SUB W1, W0, [W15]
003196  320002     BRA Z, 0x319C
838:                       return (0u);
003198  EB0000     CLR W0
00319A  370001     BRA 0x319E
839:                   }
840:               
841:                   return (rem_size);
00319C  78001E     MOV [W14], W0
842:               }
00319E  FA8000     ULNK
0031A0  060000     RETURN
843:               #endif
844:               
845:               
846:               /*
847:               *********************************************************************************************************
848:               *                                            Mem_SegCreate()
849:               *
850:               * Description : Creates a new memory segment to be used for runtime memory allocation.
851:               *
852:               * Argument(s) : p_name          Pointer to segment name.
853:               *
854:               *               p_seg           Pointer to segment data. Must be allocated by caller.
855:               *
856:               *               seg_base_addr   Address of segment's first byte.
857:               *
858:               *               size            Total size of segment, in bytes.
859:               *
860:               *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
861:               *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
862:               *                               means no padding.
863:               *
864:               *               p_err           Pointer to variable that will receive the return error code from this function :
865:               *
866:               *                                   LIB_MEM_ERR_NONE                    Operation was successful.
867:               *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
868:               *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
869:               *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
870:               *
871:               *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
872:               *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
873:               *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
874:               *
875:               * Return(s)   : None.
876:               *
877:               * Caller(s)   : Application.
878:               *
879:               * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
880:               *                   to be maintained during the whole list search and add procedure to prevent a reentrant
881:               *                   call from creating another segment overlapping with the one being added.
882:               *********************************************************************************************************
883:               */
884:               
885:               void  Mem_SegCreate (const  CPU_CHAR    *p_name,
886:                                           MEM_SEG     *p_seg,
887:                                           CPU_ADDR     seg_base_addr,
888:                                           CPU_SIZE_T   size,
889:                                           CPU_SIZE_T   padding_align,
890:                                           LIB_ERR     *p_err)
891:               {
0031A2  FA000E     LNK #0xE
0031A4  980710     MOV W0, [W14+2]
0031A6  980721     MOV W1, [W14+4]
0031A8  980732     MOV W2, [W14+6]
0031AA  980743     MOV W3, [W14+8]
0031AC  980754     MOV W4, [W14+10]
0031AE  980765     MOV W5, [W14+12]
892:                   CPU_SR_ALLOC();
0031B0  EB0000     CLR W0
0031B2  780F00     MOV W0, [W14]
893:               
894:               
895:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
896:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
897:                       CPU_SW_EXCEPTION(;);
898:                   }
899:               
900:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
901:                      *p_err = LIB_MEM_ERR_NULL_PTR;
902:                       return;
903:                   }
904:               
905:                   if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
906:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
907:                       return;
908:                   }
909:                                                                               /* Chk for addr space ovf.                              */
910:                   if (seg_base_addr + (size - 1u) < seg_base_addr) {
911:                      *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
912:                       return;
913:                   }
914:               
915:                   if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
916:                       (MATH_IS_PWR2(padding_align) != DEF_YES)) {
917:                      *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
918:                       return;
919:                   }
920:               #endif
921:               
922:                   CPU_CRITICAL_ENTER();
0031B4  800211     MOV SR, W1
0031B6  780F01     MOV W1, [W14]
0031B8  800211     MOV SR, W1
0031BA  200E00     MOV #0xE0, W0
0031BC  700001     IOR W0, W1, W0
0031BE  880210     MOV W0, SR
923:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
924:                   (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
925:                                                   size,
926:                                                   p_err);
927:                   if (*p_err != LIB_MEM_ERR_NONE) {
928:                       CPU_CRITICAL_EXIT();
929:                       return;
930:                   }
931:               #endif
932:               
933:                   Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
0031C0  90024E     MOV [W14+8], W4
0031C2  9001DE     MOV [W14+10], W3
0031C4  90013E     MOV [W14+6], W2
0031C6  9000AE     MOV [W14+4], W1
0031C8  90001E     MOV [W14+2], W0
0031CA  0702E0     RCALL _Mem_SegCreateCritical
934:                                         p_seg,
935:                                         seg_base_addr,
936:                                         padding_align,
937:                                         size);
938:                   CPU_CRITICAL_EXIT();
0031CC  78009E     MOV [W14], W1
0031CE  880211     MOV W1, SR
939:               
940:                  *p_err = LIB_MEM_ERR_NONE;
0031D0  90006E     MOV [W14+12], W0
0031D2  227101     MOV #0x2710, W1
0031D4  780801     MOV W1, [W0]
941:               }
0031D6  FA8000     ULNK
0031D8  060000     RETURN
942:               
943:               
944:               /*
945:               *********************************************************************************************************
946:               *                                            Mem_SegClr()
947:               *
948:               * Description : Clears a memory segment.
949:               *
950:               * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
951:               *
952:               *               p_err           Pointer to variable that will receive the return error code from this function :
953:               *
954:               *                               LIB_MEM_ERR_NONE                Operation was successful.
955:               *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
956:               *
957:               * Return(s)   : None.
958:               *
959:               * Caller(s)   : Application.
960:               *
961:               * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
962:               *                   segments that are no longer used.
963:               *
964:               *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
965:               *********************************************************************************************************
966:               */
967:               
968:               #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)
969:               void  Mem_SegClr (MEM_SEG  *p_seg,
970:                                 LIB_ERR  *p_err)
971:               {
0031DA  FA0006     LNK #0x6
0031DC  980710     MOV W0, [W14+2]
0031DE  980721     MOV W1, [W14+4]
972:                   CPU_SR_ALLOC();
0031E0  EB0000     CLR W0
0031E2  780F00     MOV W0, [W14]
973:               
974:               
975:               #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
976:                   if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
977:                       CPU_SW_EXCEPTION(;);
978:                   }
979:               
980:                   if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
981:                      *p_err = LIB_MEM_ERR_NULL_PTR;
982:                       return;
983:                   }
984:               #endif
985:               
986:                   CPU_CRITICAL_ENTER();
0031E4  800211     MOV SR, W1
0031E6  780F01     MOV W1, [W14]
0031E8  800211     MOV SR, W1
0031EA  200E00     MOV #0xE0, W0
0031EC  700001     IOR W0, W1, W0
0031EE  880210     MOV W0, SR
987:                   p_seg->AddrNext = p_seg->AddrBase;
0031F0  90001E     MOV [W14+2], W0
0031F2  780090     MOV [W0], W1
0031F4  90001E     MOV [W14+2], W0
0031F6  980021     MOV W1, [W0+4]
988:                   CPU_CRITICAL_EXIT();
0031F8  78009E     MOV [W14], W1
0031FA  880211     MOV W1, SR
989:               
990:                  *p_err = LIB_MEM_ERR_NONE;
0031FC  90002E     MOV [W14+4], W0
0031FE  227101     MOV #0x2710, W1
003200  780801     MOV W1, [W0]
991:               }
003202  FA8000     ULNK
003204  060000     RETURN
992:               #endif
993:               
994:               
995:               /*
996:               *********************************************************************************************************
997:               *                                         Mem_SegRemSizeGet()
998:               *
999:               * Description : Gets free space of memory segment.
1000:              *
1001:              * Argument(s) : p_seg       Pointer to segment data.
1002:              *
1003:              *               align       Alignment in bytes to assume for calculation of free space.
1004:              *
1005:              *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
1006:              *                           total size, base address and next allocation address).
1007:              *
1008:              *               p_err       Pointer to variable that will receive the return error code from this function :
1009:              *
1010:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1011:              *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
1012:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
1013:              *
1014:              * Return(s)   : Memory segment remaining size in bytes,     if successful.
1015:              *               0,                                          otherwise or if memory segment empty.
1016:              *
1017:              * Caller(s)   : Application,
1018:              *               Mem_HeapGetSizeRem(),
1019:              *               Mem_OutputUsage().
1020:              *
1021:              * Note(s)     : None.
1022:              *********************************************************************************************************
1023:              */
1024:              
1025:              CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
1026:                                             CPU_SIZE_T     align,
1027:                                             MEM_SEG_INFO  *p_seg_info,
1028:                                             LIB_ERR       *p_err)
1029:              {
003206  FA0012     LNK #0x12
003208  980750     MOV W0, [W14+10]
00320A  980761     MOV W1, [W14+12]
00320C  980772     MOV W2, [W14+14]
00320E  980F03     MOV W3, [W14+16]
1030:                  CPU_SIZE_T  rem_size;
1031:                  CPU_SIZE_T  total_size;
1032:                  CPU_SIZE_T  used_size;
1033:                  CPU_ADDR    next_addr_align;
1034:                  CPU_SR_ALLOC();
003210  EB0000     CLR W0
003212  780F00     MOV W0, [W14]
1035:              
1036:              
1037:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1038:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
1039:                      CPU_SW_EXCEPTION(seg_info);
1040:                  }
1041:              
1042:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
1043:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
1044:                      return (0u);
1045:                  }
1046:              #endif
1047:              
1048:                  if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
003214  90005E     MOV [W14+10], W0
003216  E00000     CP0 W0
003218  3A0002     BRA NZ, 0x321E
1049:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1050:                      p_seg = &Mem_SegHeap;
00321A  217AC0     MOV #0x17AC, W0
00321C  980750     MOV W0, [W14+10]
1051:              #else
1052:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1053:                      return (0u);
1054:              #endif
1055:                  }
1056:              
1057:                  CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
00321E  800211     MOV SR, W1
003220  780F01     MOV W1, [W14]
003222  800211     MOV SR, W1
003224  200E00     MOV #0xE0, W0
003226  700001     IOR W0, W1, W0
003228  880210     MOV W0, SR
1058:                  next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
00322A  90005E     MOV [W14+10], W0
00322C  9000A0     MOV [W0+4], W1
00322E  90006E     MOV [W14+12], W0
003230  EA0000     NEG W0, W0
003232  608080     AND W1, W0, W1
003234  90005E     MOV [W14+10], W0
003236  900120     MOV [W0+4], W2
003238  90006E     MOV [W14+12], W0
00323A  E90000     DEC W0, W0
00323C  610000     AND W2, W0, W0
00323E  E00000     CP0 W0
003240  320002     BRA Z, 0x3246
003242  90006E     MOV [W14+12], W0
003244  370001     BRA 0x3248
003246  EB0000     CLR W0
003248  408000     ADD W1, W0, W0
00324A  980710     MOV W0, [W14+2]
1059:                  CPU_CRITICAL_EXIT();
00324C  78009E     MOV [W14], W1
00324E  880211     MOV W1, SR
1060:              
1061:                  total_size = p_seg->AddrEnd  - p_seg->AddrBase + 1u;
003250  90005E     MOV [W14+10], W0
003252  900090     MOV [W0+2], W1
003254  90005E     MOV [W14+10], W0
003256  780010     MOV [W0], W0
003258  508000     SUB W1, W0, W0
00325A  E80000     INC W0, W0
00325C  980720     MOV W0, [W14+4]
1062:                  used_size  = next_addr_align - p_seg->AddrBase;
00325E  90005E     MOV [W14+10], W0
003260  780010     MOV [W0], W0
003262  90009E     MOV [W14+2], W1
003264  508000     SUB W1, W0, W0
003266  980730     MOV W0, [W14+6]
1063:                  rem_size   = total_size      - used_size;
003268  9000AE     MOV [W14+4], W1
00326A  90003E     MOV [W14+6], W0
00326C  508000     SUB W1, W0, W0
00326E  980740     MOV W0, [W14+8]
1064:              
1065:                  if (p_seg_info != DEF_NULL) {
003270  90007E     MOV [W14+14], W0
003272  E00000     CP0 W0
003274  32000D     BRA Z, 0x3290
1066:                      p_seg_info->TotalSize     = total_size;
003276  90007E     MOV [W14+14], W0
003278  9000AE     MOV [W14+4], W1
00327A  980011     MOV W1, [W0+2]
1067:                      p_seg_info->UsedSize      = used_size;
00327C  90007E     MOV [W14+14], W0
00327E  9000BE     MOV [W14+6], W1
003280  780801     MOV W1, [W0]
1068:                      p_seg_info->AddrBase      = p_seg->AddrBase;
003282  90005E     MOV [W14+10], W0
003284  780090     MOV [W0], W1
003286  90007E     MOV [W14+14], W0
003288  980021     MOV W1, [W0+4]
1069:                      p_seg_info->AddrNextAlloc = next_addr_align;
00328A  90007E     MOV [W14+14], W0
00328C  90009E     MOV [W14+2], W1
00328E  980031     MOV W1, [W0+6]
1070:                  }
1071:              
1072:                 *p_err = LIB_MEM_ERR_NONE;
003290  90080E     MOV [W14+16], W0
003292  227101     MOV #0x2710, W1
003294  780801     MOV W1, [W0]
1073:              
1074:                  return (rem_size);
003296  90004E     MOV [W14+8], W0
1075:              }
003298  FA8000     ULNK
00329A  060000     RETURN
1076:              
1077:              
1078:              /*
1079:              *********************************************************************************************************
1080:              *                                            Mem_SegAlloc()
1081:              *
1082:              * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
1083:              *               word boundary.
1084:              *
1085:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1086:              *
1087:              *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
1088:              *                       general-purpose heap if null.
1089:              *
1090:              *               size    Size of memory block to allocate, in bytes.
1091:              *
1092:              *               p_err   Pointer to variable that will receive the return error code from this function :
1093:              *
1094:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1095:              *
1096:              *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1097:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1098:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1099:              *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1100:              *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1101:              *
1102:              * Return(s)   : Pointer to allocated memory block, if successful.
1103:              *
1104:              *               DEF_NULL, otherwise.
1105:              *
1106:              * Caller(s)   : Application.
1107:              *
1108:              * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
1109:              *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
1110:              *                   Mem_SegAllocHW().
1111:              *********************************************************************************************************
1112:              */
1113:              
1114:              void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
1115:                                          MEM_SEG     *p_seg,
1116:                                          CPU_SIZE_T   size,
1117:                                          LIB_ERR     *p_err)
1118:              {
00329C  FA000A     LNK #0xA
00329E  980710     MOV W0, [W14+2]
0032A0  980721     MOV W1, [W14+4]
0032A2  980732     MOV W2, [W14+6]
0032A4  980743     MOV W3, [W14+8]
1119:                  void  *p_blk;
1120:              
1121:              
1122:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
0032A6  90002E     MOV [W14+4], W0
0032A8  E00000     CP0 W0
0032AA  3A0002     BRA NZ, 0x32B0
1123:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1124:                      p_seg = &Mem_SegHeap;
0032AC  217AC0     MOV #0x17AC, W0
0032AE  980720     MOV W0, [W14+4]
1125:              #else
1126:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1127:                      return (DEF_NULL);
1128:              #endif
1129:                  }
1130:              
1131:                  p_blk = Mem_SegAllocInternal(p_name,
0032B0  90034E     MOV [W14+8], W6
0032B2  EB0280     CLR W5
0032B4  200014     MOV #0x1, W4
0032B6  200023     MOV #0x2, W3
0032B8  90013E     MOV [W14+6], W2
0032BA  9000AE     MOV [W14+4], W1
0032BC  90001E     MOV [W14+2], W0
0032BE  0702C2     RCALL _Mem_SegAllocInternal
0032C0  780F00     MOV W0, [W14]
1132:                                               p_seg,
1133:                                               size,
1134:                                               sizeof(CPU_ALIGN),
1135:                                               LIB_MEM_PADDING_ALIGN_NONE,
1136:                                               DEF_NULL,
1137:                                               p_err);
1138:              
1139:                  return (p_blk);
0032C2  78001E     MOV [W14], W0
1140:              }
0032C4  FA8000     ULNK
0032C6  060000     RETURN
1141:              
1142:              
1143:              /*
1144:              *********************************************************************************************************
1145:              *                                           Mem_SegAllocExt()
1146:              *
1147:              * Description : Allocates memory from specified memory segment.
1148:              *
1149:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1150:              *
1151:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1152:              *                               general-purpose heap if null.
1153:              *
1154:              *               size            Size of memory block to allocate, in bytes.
1155:              *
1156:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1157:              *
1158:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1159:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1160:              *
1161:              *               p_err           Pointer to variable that will receive the return error code from this function :
1162:              *
1163:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1164:              *
1165:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1166:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1167:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1168:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1169:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1170:              *
1171:              * Return(s)   : Pointer to allocated memory block, if successful.
1172:              *
1173:              *               DEF_NULL, otherwise.
1174:              *
1175:              * Caller(s)   : Application.
1176:              *
1177:              * Note(s)     : none.
1178:              *********************************************************************************************************
1179:              */
1180:              
1181:              void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
1182:                                             MEM_SEG     *p_seg,
1183:                                             CPU_SIZE_T   size,
1184:                                             CPU_SIZE_T   align,
1185:                                             CPU_SIZE_T  *p_bytes_reqd,
1186:                                             LIB_ERR     *p_err)
1187:              {
0032C8  FA000E     LNK #0xE
0032CA  980710     MOV W0, [W14+2]
0032CC  980721     MOV W1, [W14+4]
0032CE  980732     MOV W2, [W14+6]
0032D0  980743     MOV W3, [W14+8]
0032D2  980754     MOV W4, [W14+10]
0032D4  980765     MOV W5, [W14+12]
1188:                  void  *p_blk;
1189:              
1190:              
1191:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
0032D6  90002E     MOV [W14+4], W0
0032D8  E00000     CP0 W0
0032DA  3A0002     BRA NZ, 0x32E0
1192:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1193:                      p_seg = &Mem_SegHeap;
0032DC  217AC0     MOV #0x17AC, W0
0032DE  980720     MOV W0, [W14+4]
1194:              #else
1195:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1196:                      return (DEF_NULL);
1197:              #endif
1198:                  }
1199:              
1200:                  p_blk = Mem_SegAllocInternal(p_name,
0032E0  90036E     MOV [W14+12], W6
0032E2  9002DE     MOV [W14+10], W5
0032E4  200014     MOV #0x1, W4
0032E6  9001CE     MOV [W14+8], W3
0032E8  90013E     MOV [W14+6], W2
0032EA  9000AE     MOV [W14+4], W1
0032EC  90001E     MOV [W14+2], W0
0032EE  0702AA     RCALL _Mem_SegAllocInternal
0032F0  780F00     MOV W0, [W14]
1201:                                               p_seg,
1202:                                               size,
1203:                                               align,
1204:                                               LIB_MEM_PADDING_ALIGN_NONE,
1205:                                               p_bytes_reqd,
1206:                                               p_err);
1207:              
1208:                  return (p_blk);
0032F2  78001E     MOV [W14], W0
1209:              }
0032F4  FA8000     ULNK
0032F6  060000     RETURN
1210:              
1211:              
1212:              /*
1213:              *********************************************************************************************************
1214:              *                                          Mem_SegAllocHW()
1215:              *
1216:              * Description : Allocates memory from specified segment. The returned buffer will be padded in function
1217:              *               of memory segment's properties.
1218:              *
1219:              * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
1220:              *
1221:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1222:              *                               general-purpose heap if null.
1223:              *
1224:              *               size            Size of memory block to allocate, in bytes.
1225:              *
1226:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
1227:              *
1228:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
1229:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
1230:              *
1231:              *               p_err           Pointer to variable that will receive the return error code from this function :
1232:              *
1233:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1234:              *
1235:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1236:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1237:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1238:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1239:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1240:              *
1241:              * Return(s)   : Pointer to allocated memory block, if successful.
1242:              *
1243:              *               DEF_NULL, otherwise.
1244:              *
1245:              * Caller(s)   : Application.
1246:              *
1247:              * Note(s)     : none.
1248:              *********************************************************************************************************
1249:              */
1250:              
1251:              void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
1252:                                            MEM_SEG     *p_seg,
1253:                                            CPU_SIZE_T   size,
1254:                                            CPU_SIZE_T   align,
1255:                                            CPU_SIZE_T  *p_bytes_reqd,
1256:                                            LIB_ERR     *p_err)
1257:              {
0032F8  FA000E     LNK #0xE
0032FA  980710     MOV W0, [W14+2]
0032FC  980721     MOV W1, [W14+4]
0032FE  980732     MOV W2, [W14+6]
003300  980743     MOV W3, [W14+8]
003302  980754     MOV W4, [W14+10]
003304  980765     MOV W5, [W14+12]
1258:                  void  *p_blk;
1259:              
1260:              
1261:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
003306  90002E     MOV [W14+4], W0
003308  E00000     CP0 W0
00330A  3A0002     BRA NZ, 0x3310
1262:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1263:                      p_seg = &Mem_SegHeap;
00330C  217AC0     MOV #0x17AC, W0
00330E  980720     MOV W0, [W14+4]
1264:              #else
1265:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1266:                      return (DEF_NULL);
1267:              #endif
1268:                  }
1269:              
1270:                  p_blk = Mem_SegAllocInternal(p_name,
003312  900040     MOV [W0+8], W0
003314  90036E     MOV [W14+12], W6
003316  9002DE     MOV [W14+10], W5
003318  780200     MOV W0, W4
00331A  9001CE     MOV [W14+8], W3
00331C  90013E     MOV [W14+6], W2
00331E  9000AE     MOV [W14+4], W1
003320  90001E     MOV [W14+2], W0
003322  070290     RCALL _Mem_SegAllocInternal
003324  780F00     MOV W0, [W14]
1271:                                               p_seg,
1272:                                               size,
1273:                                               align,
1274:                                               p_seg->PaddingAlign,
003310  90002E     MOV [W14+4], W0
1275:                                               p_bytes_reqd,
1276:                                               p_err);
1277:              
1278:                  return (p_blk);
003326  78001E     MOV [W14], W0
1279:              }
003328  FA8000     ULNK
00332A  060000     RETURN
1280:              
1281:              
1282:              /*
1283:              *********************************************************************************************************
1284:              *                                          Mem_PoolCreate()
1285:              *
1286:              * Description : (1) Creates a memory pool :
1287:              *
1288:              *                   (a) Create    memory pool from heap or dedicated memory
1289:              *                   (b) Allocate  memory pool memory blocks
1290:              *                   (c) Configure memory pool
1291:              *
1292:              *
1293:              * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
1294:              *
1295:              *               p_mem_base      Memory pool segment base address :
1296:              *
1297:              *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
1298:              *                                       (b) Non-null address    Memory pool allocated from dedicated memory
1299:              *                                                                   specified by its base address.
1300:              *
1301:              *               mem_size        Size      of memory pool segment          (in bytes).
1302:              *
1303:              *               blk_nbr         Number    of memory pool blocks to create.
1304:              *
1305:              *               blk_size        Size      of memory pool blocks to create (in bytes).
1306:              *
1307:              *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
1308:              *
1309:              *               p_bytes_reqd    Optional pointer to a variable to ... :
1310:              *
1311:              *                                   (a) Return the number of bytes required to successfully
1312:              *                                               allocate the memory pool, if any error(s);
1313:              *                                       (b) Return 0, otherwise.
1314:              *
1315:              *               p_err           Pointer to variable that will receive the return error code from this function :
1316:              *
1317:              *                                   LIB_MEM_ERR_NONE                    Operation was successful.
1318:              *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
1319:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
1320:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
1321:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
1322:              *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
1323:              *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
1324:              *
1325:              *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
1326:              *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
1327:              *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
1328:              *
1329:              *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
1330:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1331:              *
1332:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
1333:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1334:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1335:              *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1336:              *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1337:              *
1338:              *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
1339:              *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
1340:              *
1341:              * Return(s)   : none.
1342:              *
1343:              * Caller(s)   : Application.
1344:              *
1345:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1346:              *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
1347:              *********************************************************************************************************
1348:              */
1349:              
1350:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1351:              void  Mem_PoolCreate (MEM_POOL          *p_pool,
1352:                                    void              *p_mem_base,
1353:                                    CPU_SIZE_T         mem_size,
1354:                                    MEM_POOL_BLK_QTY   blk_nbr,
1355:                                    CPU_SIZE_T         blk_size,
1356:                                    CPU_SIZE_T         blk_align,
1357:                                    CPU_SIZE_T        *p_bytes_reqd,
1358:                                    LIB_ERR           *p_err)
1359:              {
00332C  FA0020     LNK #0x20
00332E  980F00     MOV W0, [W14+16]
003330  980F11     MOV W1, [W14+18]
003332  980F22     MOV W2, [W14+20]
003334  980F33     MOV W3, [W14+22]
003336  980F44     MOV W4, [W14+24]
003338  980F55     MOV W5, [W14+26]
00333A  980F66     MOV W6, [W14+28]
00333C  980F77     MOV W7, [W14+30]
1360:                  MEM_SEG           *p_seg;
1361:                  void              *p_pool_mem;
1362:                  CPU_SIZE_T         pool_size;
1363:                  CPU_SIZE_T         blk_size_align;
1364:                  CPU_ADDR           pool_addr_end;
1365:                  MEM_POOL_BLK_QTY   blk_ix;
1366:                  CPU_INT08U        *p_blk;
1367:                  CPU_SR_ALLOC();
00333E  EB0000     CLR W0
003340  980730     MOV W0, [W14+6]
1368:              
1369:              
1370:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
1371:                  if (p_err == DEF_NULL) {
1372:                      CPU_SW_EXCEPTION(;);
1373:                  }
1374:              
1375:                                                                              /* ------------- VALIDATE MEM POOL CREATE ------------- */
1376:                  if (p_pool == DEF_NULL) {
1377:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1378:                      return;
1379:                  }
1380:              
1381:                  if (p_mem_base != DEF_NULL) {
1382:                      if (mem_size < 1u) {
1383:                         *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
1384:                          return;
1385:                      }
1386:                  }
1387:              
1388:                  if (blk_nbr < 1u) {
1389:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
1390:                      return;
1391:                  }
1392:              
1393:                  if (blk_size < 1u) {
1394:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1395:                      return;
1396:                  }
1397:              
1398:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
1399:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
1400:                      return;
1401:                  }
1402:              #endif
1403:              
1404:                  Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
003342  9008FE     MOV [W14+30], W1
003344  90080E     MOV [W14+16], W0
003346  0700A5     RCALL Mem_PoolClr
1405:                  if (*p_err != LIB_MEM_ERR_NONE) {
003348  90087E     MOV [W14+30], W0
00334A  780090     MOV [W0], W1
00334C  227100     MOV #0x2710, W0
00334E  508F80     SUB W1, W0, [W15]
003350  3A0099     BRA NZ, 0x3484
1406:                       return;
003484  000000     NOP
003486  370003     BRA 0x348E
1407:                  }
1408:              
1409:                                                                              /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
1410:                  if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
003352  90081E     MOV [W14+18], W0
003354  E00000     CP0 W0
003356  3A0003     BRA NZ, 0x335E
1411:                      p_seg = &Mem_SegHeap;
003358  217AC0     MOV #0x17AC, W0
00335A  780F00     MOV W0, [W14]
00335C  370032     BRA 0x33C2
1412:                  } else {                                                    /* Use other seg.                                       */
1413:                      CPU_CRITICAL_ENTER();
00335E  800211     MOV SR, W1
003360  980731     MOV W1, [W14+6]
003362  800211     MOV SR, W1
003364  200E00     MOV #0xE0, W0
003366  700001     IOR W0, W1, W0
003368  880210     MOV W0, SR
1414:                      p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
00336A  90081E     MOV [W14+18], W0
00336C  90097E     MOV [W14+30], W2
00336E  9008AE     MOV [W14+20], W1
003370  070229     RCALL _Mem_SegOverlapChkCritical
003372  780F00     MOV W0, [W14]
1415:                                                                  mem_size,
1416:                                                                  p_err);
1417:                      switch (*p_err) {
003374  90087E     MOV [W14+30], W0
003376  780010     MOV [W0], W0
003378  227101     MOV #0x2710, W1
00337A  500F81     SUB W0, W1, [W15]
00337C  320004     BRA Z, 0x3386
00337E  227801     MOV #0x2780, W1
003380  500F81     SUB W0, W1, [W15]
003382  32001C     BRA Z, 0x33BC
003384  370018     BRA 0x33B6
1418:                          case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
1419:                               break;
0033BC  000000     NOP
1420:              
1421:                          case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
1422:                               p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
003386  900AFE     MOV [W14+30], W5
003388  900A6E     MOV [W14+28], W4
00338A  200013     MOV #0x1, W3
00338C  200022     MOV #0x2, W2
00338E  2000A1     MOV #0xA, W1
003390  217AC0     MOV #0x17AC, W0
003392  07027E     RCALL _Mem_SegAllocExtCritical
003394  780F00     MOV W0, [W14]
1423:                                                                           sizeof(MEM_SEG),
1424:                                                                           sizeof(CPU_ALIGN),
1425:                                                                           LIB_MEM_PADDING_ALIGN_NONE,
1426:                                                                           p_bytes_reqd,
1427:                                                                           p_err);
1428:                               if (*p_err != LIB_MEM_ERR_NONE) {
003396  90087E     MOV [W14+30], W0
003398  780090     MOV [W0], W1
00339A  227100     MOV #0x2710, W0
00339C  508F80     SUB W1, W0, [W15]
00339E  320003     BRA Z, 0x33A6
1429:                                   CPU_CRITICAL_EXIT();
0033A0  9000BE     MOV [W14+6], W1
0033A2  880211     MOV W1, SR
1430:                                   return;
0033A4  370074     BRA 0x348E
1431:                               }
1432:              
1433:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
1434:                               Mem_SegAllocTrackCritical("Unknown segment data",
1435:                                                         &Mem_SegHeap,
1436:                                                          sizeof(MEM_SEG),
1437:                                                          p_err);
1438:                               if (*p_err != LIB_MEM_ERR_NONE) {
1439:                                   CPU_CRITICAL_EXIT();
1440:                                   return;
1441:                               }
1442:              #endif
1443:              
1444:                               Mem_SegCreateCritical(          DEF_NULL,
0033A6  90081E     MOV [W14+18], W0
0033A8  900A2E     MOV [W14+20], W4
0033AA  200013     MOV #0x1, W3
0033AC  780100     MOV W0, W2
0033AE  78009E     MOV [W14], W1
0033B0  EB0000     CLR W0
0033B2  0701EC     RCALL _Mem_SegCreateCritical
1445:                                                               p_seg,
1446:                                                     (CPU_ADDR)p_mem_base,
1447:                                                               LIB_MEM_PADDING_ALIGN_NONE,
1448:                                                               mem_size);
1449:                               break;
0033B4  370004     BRA 0x33BE
1450:              
1451:              
1452:                          case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
1453:                          default:
1454:                               CPU_CRITICAL_EXIT();
0033B6  9000BE     MOV [W14+6], W1
0033B8  880211     MOV W1, SR
1455:                               return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
0033BA  370069     BRA 0x348E
1456:                      }
1457:              
1458:                      CPU_CRITICAL_EXIT();
0033BE  9000BE     MOV [W14+6], W1
0033C0  880211     MOV W1, SR
1459:                  }
1460:              
1461:              
1462:                                                                              /* ---------------- ALLOC MEM FOR POOL ---------------- */
1463:                                                                              /* Calc blk size with align.                            */
1464:                  blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
0033C2  90085E     MOV [W14+26], W0
0033C4  EA0080     NEG W0, W1
0033C6  90084E     MOV [W14+24], W0
0033C8  608080     AND W1, W0, W1
0033CA  90085E     MOV [W14+26], W0
0033CC  E90100     DEC W0, W2
0033CE  90084E     MOV [W14+24], W0
0033D0  610000     AND W2, W0, W0
0033D2  E00000     CP0 W0
0033D4  320002     BRA Z, 0x33DA
0033D6  90085E     MOV [W14+26], W0
0033D8  370001     BRA 0x33DC
0033DA  EB0000     CLR W0
0033DC  408000     ADD W1, W0, W0
0033DE  980740     MOV W0, [W14+8]
1465:                  pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
0033E0  9000CE     MOV [W14+8], W1
0033E2  90083E     MOV [W14+22], W0
0033E4  B98800     MUL.SS W1, W0, W0
0033E6  780000     MOV W0, W0
0033E8  980750     MOV W0, [W14+10]
1466:              
1467:                                                                              /* Alloc mem for pool.                                  */
1468:                  p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
0033EA  29F9F0     MOV #0x9F9F, W0
0033EC  900B7E     MOV [W14+30], W6
0033EE  900AEE     MOV [W14+28], W5
0033F0  200014     MOV #0x1, W4
0033F2  9009DE     MOV [W14+26], W3
0033F4  90015E     MOV [W14+10], W2
0033F6  78009E     MOV [W14], W1
0033F8  070225     RCALL _Mem_SegAllocInternal
0033FA  980760     MOV W0, [W14+12]
1469:                                                             p_seg,
1470:                                                             pool_size,
1471:                                                             blk_align,
1472:                                                             LIB_MEM_PADDING_ALIGN_NONE,
1473:                                                             p_bytes_reqd,
1474:                                                             p_err);
1475:                  if (*p_err != LIB_MEM_ERR_NONE) {
0033FC  90087E     MOV [W14+30], W0
0033FE  780090     MOV [W0], W1
003400  227100     MOV #0x2710, W0
003402  508F80     SUB W1, W0, [W15]
003404  3A0041     BRA NZ, 0x3488
1476:                      return;
003488  000000     NOP
00348A  370001     BRA 0x348E
1477:                  }
1478:              
1479:                                                                              /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
1480:                  p_pool->BlkFreeTbl = (void *)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
003406  90083E     MOV [W14+22], W0
003408  400000     ADD W0, W0, W0
00340A  780080     MOV W0, W1
00340C  29FB30     MOV #0x9FB3, W0
00340E  900B7E     MOV [W14+30], W6
003410  900AEE     MOV [W14+28], W5
003412  200014     MOV #0x1, W4
003414  200023     MOV #0x2, W3
003416  780101     MOV W1, W2
003418  217AC1     MOV #0x17AC, W1
00341A  070214     RCALL _Mem_SegAllocInternal
00341C  780080     MOV W0, W1
00341E  90080E     MOV [W14+16], W0
003420  980041     MOV W1, [W0+8]
1481:                                                                    &Mem_SegHeap,
1482:                                                                     blk_nbr * sizeof(void *),
1483:                                                                     sizeof(CPU_ALIGN),
1484:                                                                     LIB_MEM_PADDING_ALIGN_NONE,
1485:                                                                     p_bytes_reqd,
1486:                                                                     p_err);
1487:                  if (*p_err != LIB_MEM_ERR_NONE) {
003422  90087E     MOV [W14+30], W0
003424  780090     MOV [W0], W1
003426  227100     MOV #0x2710, W0
003428  508F80     SUB W1, W0, [W15]
00342A  3A0030     BRA NZ, 0x348C
1488:                      return;
00348C  000000     NOP
1489:                  }
1490:              
1491:                                                                              /* ------------------ INIT BLK LIST ------------------- */
1492:                  p_blk = (CPU_INT08U *)p_pool_mem;
00342C  9000EE     MOV [W14+12], W1
00342E  980721     MOV W1, [W14+4]
1493:                  for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
003430  EB0000     CLR W0
003432  980710     MOV W0, [W14+2]
003434  37000E     BRA 0x3452
00344C  90001E     MOV [W14+2], W0
00344E  E80000     INC W0, W0
003450  980710     MOV W0, [W14+2]
003452  90009E     MOV [W14+2], W1
003454  90083E     MOV [W14+22], W0
003456  508F80     SUB W1, W0, [W15]
003458  39FFEE     BRA NC, 0x3436
1494:                      p_pool->BlkFreeTbl[blk_ix]  = p_blk;
003436  90080E     MOV [W14+16], W0
003438  9000C0     MOV [W0+8], W1
00343A  90001E     MOV [W14+2], W0
00343C  400000     ADD W0, W0, W0
00343E  408000     ADD W1, W0, W0
003440  9000AE     MOV [W14+4], W1
003442  780801     MOV W1, [W0]
1495:                      p_blk                      += blk_size_align;
003444  9000AE     MOV [W14+4], W1
003446  90004E     MOV [W14+8], W0
003448  408000     ADD W1, W0, W0
00344A  980720     MOV W0, [W14+4]
1496:                  }
1497:              
1498:              
1499:                                                                              /* ------------------ INIT POOL DATA ------------------ */
1500:                  pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
00345A  9000EE     MOV [W14+12], W1
00345C  90005E     MOV [W14+10], W0
00345E  408000     ADD W1, W0, W0
003460  E90000     DEC W0, W0
003462  980770     MOV W0, [W14+14]
1501:                  p_pool->PoolAddrStart =  p_pool_mem;
003464  90080E     MOV [W14+16], W0
003466  9000EE     MOV [W14+12], W1
003468  780801     MOV W1, [W0]
1502:                  p_pool->PoolAddrEnd   = (void *)pool_addr_end;
00346A  9000FE     MOV [W14+14], W1
00346C  90080E     MOV [W14+16], W0
00346E  980011     MOV W1, [W0+2]
1503:                  p_pool->BlkNbr        =  blk_nbr;
003470  90080E     MOV [W14+16], W0
003472  9008BE     MOV [W14+22], W1
003474  980021     MOV W1, [W0+4]
1504:                  p_pool->BlkSize       =  blk_size_align;
003476  90080E     MOV [W14+16], W0
003478  9000CE     MOV [W14+8], W1
00347A  980031     MOV W1, [W0+6]
1505:                  p_pool->BlkFreeTblIx  =  blk_nbr;
00347C  90080E     MOV [W14+16], W0
00347E  9008BE     MOV [W14+22], W1
003480  980051     MOV W1, [W0+10]
003482  370005     BRA 0x348E
1506:              }
00348E  FA8000     ULNK
003490  060000     RETURN
1507:              #endif
1508:              
1509:              
1510:              /*
1511:              *********************************************************************************************************
1512:              *                                            Mem_PoolClr()
1513:              *
1514:              * Description : Clears a memory pool (see Note #1).
1515:              *
1516:              * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
1517:              *
1518:              *               p_err        Pointer to variable that will receive the return error code from this function :
1519:              *
1520:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1521:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1522:              *
1523:              * Return(s)   : none.
1524:              *
1525:              * Caller(s)   : Application,
1526:              *               Mem_PoolCreate().
1527:              *
1528:              * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
1529:              *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
1530:              *
1531:              *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
1532:              *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
1533:              *                       this will likely corrupt the memory pool management.
1534:              *
1535:              *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
1536:              *
1537:              *               (3) This function is DEPRECATED and will be removed in a future version of this product.
1538:              *********************************************************************************************************
1539:              */
1540:              
1541:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1542:              void  Mem_PoolClr (MEM_POOL  *p_pool,
1543:                                 LIB_ERR   *p_err)
1544:              {
003492  FA0004     LNK #0x4
003494  780F00     MOV W0, [W14]
003496  980711     MOV W1, [W14+2]
1545:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
1546:                  if (p_err == DEF_NULL) {
1547:                      CPU_SW_EXCEPTION(;);
1548:                  }
1549:              
1550:                                                                              /* -------------- VALIDATE MEM POOL PTR --------------- */
1551:                  if (p_pool == DEF_NULL) {
1552:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1553:                      return;
1554:                  }
1555:              #endif
1556:              
1557:                  p_pool->PoolAddrStart = DEF_NULL;
003498  78001E     MOV [W14], W0
00349A  EB0080     CLR W1
00349C  780801     MOV W1, [W0]
1558:                  p_pool->PoolAddrEnd   = DEF_NULL;
00349E  78001E     MOV [W14], W0
0034A0  EB0080     CLR W1
0034A2  980011     MOV W1, [W0+2]
1559:                  p_pool->BlkSize       = 0u;
0034A4  78001E     MOV [W14], W0
0034A6  EB0080     CLR W1
0034A8  980031     MOV W1, [W0+6]
1560:                  p_pool->BlkNbr        = 0u;
0034AA  78001E     MOV [W14], W0
0034AC  EB0080     CLR W1
0034AE  980021     MOV W1, [W0+4]
1561:                  p_pool->BlkFreeTbl    = DEF_NULL;
0034B0  78001E     MOV [W14], W0
0034B2  EB0080     CLR W1
0034B4  980041     MOV W1, [W0+8]
1562:                  p_pool->BlkFreeTblIx  = 0u;
0034B6  78001E     MOV [W14], W0
0034B8  EB0080     CLR W1
0034BA  980051     MOV W1, [W0+10]
1563:              
1564:                 *p_err = LIB_MEM_ERR_NONE;
0034BC  90001E     MOV [W14+2], W0
0034BE  227101     MOV #0x2710, W1
0034C0  780801     MOV W1, [W0]
1565:              }
0034C2  FA8000     ULNK
0034C4  060000     RETURN
1566:              #endif
1567:              
1568:              
1569:              /*
1570:              *********************************************************************************************************
1571:              *                                          Mem_PoolBlkGet()
1572:              *
1573:              * Description : Gets a memory block from memory pool.
1574:              *
1575:              * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
1576:              *
1577:              *               size    Size of requested memory (in bytes).
1578:              *
1579:              *               p_err   Pointer to variable that will receive the return error code from this function :
1580:              *
1581:              *                           LIB_MEM_ERR_NONE                Operation was successful.
1582:              *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
1583:              *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1584:              *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
1585:              *
1586:              * Return(s)   : Pointer to memory block, if NO error(s).
1587:              *
1588:              *               Pointer to NULL,         otherwise.
1589:              *
1590:              * Caller(s)   : Application.
1591:              *
1592:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1593:              *                   Mem_DynPoolBlkGet() should be used instead.
1594:              *********************************************************************************************************
1595:              */
1596:              
1597:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1598:              void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
1599:                                     CPU_SIZE_T   size,
1600:                                     LIB_ERR     *p_err)
1601:              {
0034C6  FA000A     LNK #0xA
0034C8  980720     MOV W0, [W14+4]
0034CA  980731     MOV W1, [W14+6]
0034CC  980742     MOV W2, [W14+8]
1602:                  CPU_INT08U  *p_blk;
1603:                  CPU_SR_ALLOC();
0034CE  EB0000     CLR W0
0034D0  980710     MOV W0, [W14+2]
1604:              
1605:              
1606:                 (void)&size;                                                 /* Prevent possible 'variable unused' warning.          */
1607:              
1608:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
1609:                  if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
1610:                      CPU_SW_EXCEPTION(DEF_NULL);
1611:                  }
1612:              
1613:                  if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
1614:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1615:                      return (DEF_NULL);
1616:                  }
1617:              
1618:                  if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
1619:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1620:                      return (DEF_NULL);
1621:                  }
1622:              
1623:                  if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
1624:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
1625:                      return (DEF_NULL);
1626:                  }
1627:              #endif
1628:              
1629:              
1630:                                                                              /* -------------- GET MEM BLK FROM POOL --------------- */
1631:                  p_blk = DEF_NULL;
0034D2  EB0000     CLR W0
0034D4  780F00     MOV W0, [W14]
1632:                  CPU_CRITICAL_ENTER();
0034D6  800211     MOV SR, W1
0034D8  980711     MOV W1, [W14+2]
0034DA  800211     MOV SR, W1
0034DC  200E00     MOV #0xE0, W0
0034DE  700001     IOR W0, W1, W0
0034E0  880210     MOV W0, SR
1633:                  if (p_pool->BlkFreeTblIx > 0u) {
0034E2  90002E     MOV [W14+4], W0
0034E4  900050     MOV [W0+10], W0
0034E6  E00000     CP0 W0
0034E8  320015     BRA Z, 0x3514
1634:                      p_pool->BlkFreeTblIx                     -= 1u;
0034EA  90002E     MOV [W14+4], W0
0034EC  900050     MOV [W0+10], W0
0034EE  E90080     DEC W0, W1
0034F0  90002E     MOV [W14+4], W0
0034F2  980051     MOV W1, [W0+10]
1635:                      p_blk                                     = p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
0034F4  90002E     MOV [W14+4], W0
0034F6  9000C0     MOV [W0+8], W1
0034F8  90002E     MOV [W14+4], W0
0034FA  900050     MOV [W0+10], W0
0034FC  400000     ADD W0, W0, W0
0034FE  408000     ADD W1, W0, W0
003500  780010     MOV [W0], W0
003502  780F00     MOV W0, [W14]
1636:                      p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = DEF_NULL;
003504  90002E     MOV [W14+4], W0
003506  9000C0     MOV [W0+8], W1
003508  90002E     MOV [W14+4], W0
00350A  900050     MOV [W0+10], W0
00350C  400000     ADD W0, W0, W0
00350E  408000     ADD W1, W0, W0
003510  EB0080     CLR W1
003512  780801     MOV W1, [W0]
1637:                  }
1638:                  CPU_CRITICAL_EXIT();
003514  90009E     MOV [W14+2], W1
003516  880211     MOV W1, SR
1639:              
1640:                  if (p_blk == DEF_NULL) {
003518  78001E     MOV [W14], W0
00351A  E00000     CP0 W0
00351C  3A0004     BRA NZ, 0x3526
1641:                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
00351E  90004E     MOV [W14+8], W0
003520  227DE1     MOV #0x27DE, W1
003522  780801     MOV W1, [W0]
003524  370003     BRA 0x352C
1642:                  } else {
1643:                     *p_err = LIB_MEM_ERR_NONE;
003526  90004E     MOV [W14+8], W0
003528  227101     MOV #0x2710, W1
00352A  780801     MOV W1, [W0]
1644:                  }
1645:              
1646:                  return (p_blk);
00352C  78001E     MOV [W14], W0
1647:              }
00352E  FA8000     ULNK
003530  060000     RETURN
1648:              #endif
1649:              
1650:              
1651:              /*
1652:              *********************************************************************************************************
1653:              *                                          Mem_PoolBlkFree()
1654:              *
1655:              * Description : Free a memory block to memory pool.
1656:              *
1657:              * Argument(s) : p_pool  Pointer to memory pool to free memory block.
1658:              *
1659:              *               p_blk   Pointer to memory block address to free.
1660:              *
1661:              *               p_err   Pointer to variable that will receive the return error code from this function :
1662:              *
1663:              *                           LIB_MEM_ERR_NONE                        Operation was successful.
1664:              *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
1665:              *                                                                       a NULL pointer.
1666:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
1667:              *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
1668:              *                                                                        in memory pool.
1669:              *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
1670:              *
1671:              * Return(s)   : none.
1672:              *
1673:              * Caller(s)   : Application.
1674:              *
1675:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1676:              *                   Mem_DynPoolBlkFree() should be used instead.
1677:              *********************************************************************************************************
1678:              */
1679:              
1680:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1681:              void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
1682:                                     void      *p_blk,
1683:                                     LIB_ERR   *p_err)
1684:              {
003532  FA0008     LNK #0x8
003534  980710     MOV W0, [W14+2]
003536  980721     MOV W1, [W14+4]
003538  980732     MOV W2, [W14+6]
1685:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1686:                  CPU_SIZE_T   tbl_ix;
1687:                  CPU_BOOLEAN  addr_valid;
1688:              #endif
1689:                  CPU_SR_ALLOC();
00353A  EB0000     CLR W0
00353C  780F00     MOV W0, [W14]
1690:              
1691:              
1692:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
1693:                  if (p_err == DEF_NULL) {
1694:                      CPU_SW_EXCEPTION(;);
1695:                  }
1696:              
1697:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
1698:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1699:                      return;
1700:                  }
1701:              
1702:                  if (p_blk == DEF_NULL) {
1703:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1704:                      return;
1705:                  }
1706:              
1707:                  addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
1708:                  if (addr_valid != DEF_OK) {
1709:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
1710:                      return;
1711:                  }
1712:              
1713:                  CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
1714:                  for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
1715:                      if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
1716:                          CPU_CRITICAL_EXIT();
1717:                         *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
1718:                          return;
1719:                      }
1720:                  }
1721:              #else                                                           /* Double-free possibility if not in critical section.  */
1722:                  CPU_CRITICAL_ENTER();
00353E  800211     MOV SR, W1
003540  780F01     MOV W1, [W14]
003542  800211     MOV SR, W1
003544  200E00     MOV #0xE0, W0
003546  700001     IOR W0, W1, W0
003548  880210     MOV W0, SR
1723:              #endif
1724:                                                                              /* --------------- FREE MEM BLK TO POOL --------------- */
1725:                  if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
00354A  90001E     MOV [W14+2], W0
00354C  9000D0     MOV [W0+10], W1
00354E  90001E     MOV [W14+2], W0
003550  900020     MOV [W0+4], W0
003552  508F80     SUB W1, W0, [W15]
003554  390006     BRA NC, 0x3562
1726:                      CPU_CRITICAL_EXIT();
003556  78009E     MOV [W14], W1
003558  880211     MOV W1, SR
1727:                     *p_err = LIB_MEM_ERR_POOL_FULL;
00355A  90003E     MOV [W14+6], W0
00355C  227DD1     MOV #0x27DD, W1
00355E  780801     MOV W1, [W0]
1728:                      return;
003560  370012     BRA 0x3586
1729:                  }
1730:              
1731:                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
003562  90001E     MOV [W14+2], W0
003564  9000C0     MOV [W0+8], W1
003566  90001E     MOV [W14+2], W0
003568  900050     MOV [W0+10], W0
00356A  400000     ADD W0, W0, W0
00356C  408000     ADD W1, W0, W0
00356E  9000AE     MOV [W14+4], W1
003570  780801     MOV W1, [W0]
1732:                  p_pool->BlkFreeTblIx                     += 1u;
003572  90001E     MOV [W14+2], W0
003574  900050     MOV [W0+10], W0
003576  E80080     INC W0, W1
003578  90001E     MOV [W14+2], W0
00357A  980051     MOV W1, [W0+10]
1733:                  CPU_CRITICAL_EXIT();
00357C  78009E     MOV [W14], W1
00357E  880211     MOV W1, SR
1734:              
1735:                 *p_err = LIB_MEM_ERR_NONE;
003580  90003E     MOV [W14+6], W0
003582  227101     MOV #0x2710, W1
003584  780801     MOV W1, [W0]
1736:              }
003586  FA8000     ULNK
003588  060000     RETURN
1737:              #endif
1738:              
1739:              
1740:              /*
1741:              *********************************************************************************************************
1742:              *                                      Mem_PoolBlkGetNbrAvail()
1743:              *
1744:              * Description : Get memory pool's remaining number of blocks available to allocate.
1745:              *
1746:              * Argument(s) : p_pool   Pointer to a memory pool structure.
1747:              *
1748:              *               p_err    Pointer to variable that will receive the return error code from this function :
1749:              *
1750:              *                               LIB_MEM_ERR_NONE                Operation was successful.
1751:              *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
1752:              *
1753:              * Return(s)   : Remaining memory pool blocks,   if NO error(s).
1754:              *
1755:              *               0,                              otherwise.
1756:              *
1757:              * Caller(s)   : Application.
1758:              *
1759:              * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
1760:              *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
1761:              *********************************************************************************************************
1762:              */
1763:              
1764:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1765:              MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
1766:                                                        LIB_ERR   *p_err)
1767:              {
00358A  FA0008     LNK #0x8
00358C  980720     MOV W0, [W14+4]
00358E  980731     MOV W1, [W14+6]
1768:                  CPU_SIZE_T  nbr_avail;
1769:                  CPU_SR_ALLOC();
003590  EB0000     CLR W0
003592  780F00     MOV W0, [W14]
1770:              
1771:              
1772:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1773:                                                                              /* --------------- VALIDATE RTN ERR PTR --------------- */
1774:                  if (p_err == DEF_NULL) {
1775:                      CPU_SW_EXCEPTION(0u);
1776:                  }
1777:                                                                              /* ---------------- VALIDATE MEM POOL ----------------- */
1778:                  if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
1779:                     *p_err =  LIB_MEM_ERR_NULL_PTR;
1780:                      return (0u);
1781:                  }
1782:              #endif
1783:              
1784:                  CPU_CRITICAL_ENTER();
003594  800211     MOV SR, W1
003596  780F01     MOV W1, [W14]
003598  800211     MOV SR, W1
00359A  200E00     MOV #0xE0, W0
00359C  700001     IOR W0, W1, W0
00359E  880210     MOV W0, SR
1785:                  nbr_avail = p_pool->BlkFreeTblIx;
0035A0  90002E     MOV [W14+4], W0
0035A2  9000D0     MOV [W0+10], W1
0035A4  980711     MOV W1, [W14+2]
1786:                  CPU_CRITICAL_EXIT();
0035A6  78009E     MOV [W14], W1
0035A8  880211     MOV W1, SR
1787:              
1788:                 *p_err = LIB_MEM_ERR_NONE;
0035AA  90003E     MOV [W14+6], W0
0035AC  227101     MOV #0x2710, W1
0035AE  780801     MOV W1, [W0]
1789:              
1790:                  return (nbr_avail);
0035B0  90001E     MOV [W14+2], W0
1791:              }
0035B2  FA8000     ULNK
0035B4  060000     RETURN
1792:              #endif
1793:              
1794:              
1795:              /*
1796:              *********************************************************************************************************
1797:              *                                          Mem_DynPoolCreate()
1798:              *
1799:              * Description : Creates a dynamic memory pool.
1800:              *
1801:              * Argument(s) : p_name          Pointer to pool name.
1802:              *
1803:              *               p_pool          Pointer to pool data.
1804:              *
1805:              *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
1806:              *                               general-purpose heap if null.
1807:              *
1808:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1809:              *
1810:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1811:              *
1812:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1813:              *
1814:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1815:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1816:              *
1817:              *               p_err           Pointer to variable that will receive the return error code from this function :
1818:              *
1819:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1820:              *
1821:              *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1822:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
1823:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
1824:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
1825:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
1826:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1827:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1828:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1829:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1830:              *
1831:              * Return(s)   : None.
1832:              *
1833:              * Caller(s)   : Application.
1834:              *
1835:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1836:              *                   block is stored in the block itself (only when free/unused).
1837:              *********************************************************************************************************
1838:              */
1839:              
1840:              void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
1841:                                              MEM_DYN_POOL  *p_pool,
1842:                                              MEM_SEG       *p_seg,
1843:                                              CPU_SIZE_T     blk_size,
1844:                                              CPU_SIZE_T     blk_align,
1845:                                              CPU_SIZE_T     blk_qty_init,
1846:                                              CPU_SIZE_T     blk_qty_max,
1847:                                              LIB_ERR       *p_err)
1848:              {
0035B6  FA0010     LNK #0x10
0035B8  780F00     MOV W0, [W14]
0035BA  980711     MOV W1, [W14+2]
0035BC  980722     MOV W2, [W14+4]
0035BE  980733     MOV W3, [W14+6]
0035C0  980744     MOV W4, [W14+8]
0035C2  980755     MOV W5, [W14+10]
0035C4  980766     MOV W6, [W14+12]
0035C6  980777     MOV W7, [W14+14]
1849:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
0035C8  90002E     MOV [W14+4], W0
0035CA  E00000     CP0 W0
0035CC  3A0002     BRA NZ, 0x35D2
1850:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1851:                      p_seg = &Mem_SegHeap;
0035CE  217AC0     MOV #0x17AC, W0
0035D0  980720     MOV W0, [W14+4]
1852:              #else
1853:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1854:                      return (DEF_NULL);
1855:              #endif
1856:                  }
1857:              
1858:                  Mem_DynPoolCreateInternal(p_name,
0035D2  9000FE     MOV [W14+14], W1
0035D4  781F81     MOV W1, [W15++]
0035D6  9003EE     MOV [W14+12], W7
0035D8  90035E     MOV [W14+10], W6
0035DA  200015     MOV #0x1, W5
0035DC  90024E     MOV [W14+8], W4
0035DE  9001BE     MOV [W14+6], W3
0035E0  90012E     MOV [W14+4], W2
0035E2  90009E     MOV [W14+2], W1
0035E4  78001E     MOV [W14], W0
0035E6  0701A9     RCALL _Mem_DynPoolCreateInternal
0035E8  E9878F     DEC2 W15, W15
1859:                                            p_pool,
1860:                                            p_seg,
1861:                                            blk_size,
1862:                                            blk_align,
1863:                                            LIB_MEM_PADDING_ALIGN_NONE,
1864:                                            blk_qty_init,
1865:                                            blk_qty_max,
1866:                                            p_err);
1867:              }
0035EA  FA8000     ULNK
0035EC  060000     RETURN
1868:              
1869:              
1870:              /*
1871:              *********************************************************************************************************
1872:              *                                        Mem_DynPoolCreateHW()
1873:              *
1874:              * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
1875:              *               properties.
1876:              *
1877:              * Argument(s) : p_name          Pointer to pool name.
1878:              *
1879:              *               p_pool          Pointer to pool data.
1880:              *
1881:              *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
1882:              *                               general-purpose heap if null.
1883:              *
1884:              *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
1885:              *
1886:              *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
1887:              *
1888:              *               blk_qty_init    Initial number of elements to be allocated in pool.
1889:              *
1890:              *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
1891:              *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
1892:              *
1893:              *               p_err           Pointer to variable that will receive the return error code from this function :
1894:              *
1895:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
1896:              *
1897:              *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
1898:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
1899:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
1900:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
1901:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
1902:              *
1903:              * Return(s)   : None.
1904:              *
1905:              * Caller(s)   : Application.
1906:              *
1907:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
1908:              *                   block is stored in the block itself (only when free/unused).
1909:              *********************************************************************************************************
1910:              */
1911:              
1912:              void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
1913:                                                MEM_DYN_POOL  *p_pool,
1914:                                                MEM_SEG       *p_seg,
1915:                                                CPU_SIZE_T     blk_size,
1916:                                                CPU_SIZE_T     blk_align,
1917:                                                CPU_SIZE_T     blk_qty_init,
1918:                                                CPU_SIZE_T     blk_qty_max,
1919:                                                LIB_ERR       *p_err)
1920:              {
0035EE  FA0010     LNK #0x10
0035F0  780F00     MOV W0, [W14]
0035F2  980711     MOV W1, [W14+2]
0035F4  980722     MOV W2, [W14+4]
0035F6  980733     MOV W3, [W14+6]
0035F8  980744     MOV W4, [W14+8]
0035FA  980755     MOV W5, [W14+10]
0035FC  980766     MOV W6, [W14+12]
0035FE  980777     MOV W7, [W14+14]
1921:                  if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
003600  90002E     MOV [W14+4], W0
003602  E00000     CP0 W0
003604  3A0002     BRA NZ, 0x360A
1922:              #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
1923:                      p_seg = &Mem_SegHeap;
003606  217AC0     MOV #0x17AC, W0
003608  980720     MOV W0, [W14+4]
1924:              #else
1925:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1926:                      return (DEF_NULL);
1927:              #endif
1928:                  }
1929:              
1930:                  Mem_DynPoolCreateInternal(p_name,
00360C  900040     MOV [W0+8], W0
00360E  9000FE     MOV [W14+14], W1
003610  781F81     MOV W1, [W15++]
003612  9003EE     MOV [W14+12], W7
003614  90035E     MOV [W14+10], W6
003616  780280     MOV W0, W5
003618  90024E     MOV [W14+8], W4
00361A  9001BE     MOV [W14+6], W3
00361C  90012E     MOV [W14+4], W2
00361E  90009E     MOV [W14+2], W1
003620  78001E     MOV [W14], W0
003622  07018B     RCALL _Mem_DynPoolCreateInternal
003624  E9878F     DEC2 W15, W15
1931:                                            p_pool,
1932:                                            p_seg,
1933:                                            blk_size,
1934:                                            blk_align,
1935:                                            p_seg->PaddingAlign,
00360A  90002E     MOV [W14+4], W0
1936:                                            blk_qty_init,
1937:                                            blk_qty_max,
1938:                                            p_err);
1939:              }
003626  FA8000     ULNK
003628  060000     RETURN
1940:              
1941:              
1942:              /*
1943:              *********************************************************************************************************
1944:              *                                          Mem_DynPoolBlkGet()
1945:              *
1946:              * Description : Gets a memory block from specified pool, growing it if needed.
1947:              *
1948:              * Argument(s) : p_pool  Pointer to pool data.
1949:              *
1950:              *               p_err   Pointer to variable that will receive the return error code from this function :
1951:              *
1952:              *                           LIB_MEM_ERR_NONE                    Operation was successful.
1953:              *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
1954:              *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
1955:              *
1956:              *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
1957:              *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
1958:              *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
1959:              *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
1960:              *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
1961:              *
1962:              * Return(s)   : Pointer to memory block, if successful.
1963:              *
1964:              *               DEF_NULL, otherwise.
1965:              *
1966:              * Caller(s)   : Application.
1967:              *
1968:              * Note(s)     : none.
1969:              *********************************************************************************************************
1970:              */
1971:              
1972:              void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
1973:                                        LIB_ERR       *p_err)
1974:              {
00362A  FA000A     LNK #0xA
00362C  980730     MOV W0, [W14+6]
00362E  980741     MOV W1, [W14+8]
1975:                         void      *p_blk;
1976:                  const  CPU_CHAR  *p_pool_name;
1977:                  CPU_SR_ALLOC();
003630  EB0000     CLR W0
003632  780F00     MOV W0, [W14]
1978:              
1979:              
1980:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
1981:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
1982:                      CPU_SW_EXCEPTION(DEF_NULL);
1983:                  }
1984:              
1985:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
1986:                     *p_err = LIB_MEM_ERR_NULL_PTR;
1987:                      return (DEF_NULL);
1988:                  }
1989:              #endif
1990:              
1991:                                                                              /* Ensure pool is not empty if qty is limited.          */
1992:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
003634  90003E     MOV [W14+6], W0
003636  900050     MOV [W0+10], W0
003638  E00000     CP0 W0
00363A  32001A     BRA Z, 0x3670
1993:                      CPU_CRITICAL_ENTER();
00363C  800211     MOV SR, W1
00363E  780F01     MOV W1, [W14]
003640  800211     MOV SR, W1
003642  200E00     MOV #0xE0, W0
003644  700001     IOR W0, W1, W0
003646  880210     MOV W0, SR
1994:                      if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
003648  90003E     MOV [W14+6], W0
00364A  9000E0     MOV [W0+12], W1
00364C  90003E     MOV [W14+6], W0
00364E  900050     MOV [W0+10], W0
003650  508F80     SUB W1, W0, [W15]
003652  390007     BRA NC, 0x3662
1995:                          CPU_CRITICAL_EXIT();
003654  78009E     MOV [W14], W1
003656  880211     MOV W1, SR
1996:              
1997:                         *p_err = LIB_MEM_ERR_POOL_EMPTY;
003658  90004E     MOV [W14+8], W0
00365A  227DE1     MOV #0x27DE, W1
00365C  780801     MOV W1, [W0]
1998:                          return (DEF_NULL);
00365E  EB0000     CLR W0
003660  37003C     BRA 0x36DA
1999:                      }
2000:              
2001:                      p_pool->BlkAllocCnt++;
003662  90003E     MOV [W14+6], W0
003664  900060     MOV [W0+12], W0
003666  E80080     INC W0, W1
003668  90003E     MOV [W14+6], W0
00366A  980061     MOV W1, [W0+12]
2002:                      CPU_CRITICAL_EXIT();
00366C  78009E     MOV [W14], W1
00366E  880211     MOV W1, SR
2003:                  }
2004:              
2005:                                                                              /* --------------- ALLOC FROM FREE LIST --------------- */
2006:                  CPU_CRITICAL_ENTER();
003670  800211     MOV SR, W1
003672  780F01     MOV W1, [W14]
003674  800211     MOV SR, W1
003676  200E00     MOV #0xE0, W0
003678  700001     IOR W0, W1, W0
00367A  880210     MOV W0, SR
2007:                  if (p_pool->BlkFreePtr != DEF_NULL) {
00367C  90003E     MOV [W14+6], W0
00367E  900040     MOV [W0+8], W0
003680  E00000     CP0 W0
003682  32000E     BRA Z, 0x36A0
2008:                      p_blk              = p_pool->BlkFreePtr;
003684  90003E     MOV [W14+6], W0
003686  9000C0     MOV [W0+8], W1
003688  980711     MOV W1, [W14+2]
2009:                      p_pool->BlkFreePtr = *((void **)p_blk);
00368A  90001E     MOV [W14+2], W0
00368C  780090     MOV [W0], W1
00368E  90003E     MOV [W14+6], W0
003690  980041     MOV W1, [W0+8]
2010:                      CPU_CRITICAL_EXIT();
003692  78009E     MOV [W14], W1
003694  880211     MOV W1, SR
2011:              
2012:                     *p_err = LIB_MEM_ERR_NONE;
003696  90004E     MOV [W14+8], W0
003698  227101     MOV #0x2710, W1
00369A  780801     MOV W1, [W0]
2013:              
2014:                      return (p_blk);
00369C  90001E     MOV [W14+2], W0
00369E  37001D     BRA 0x36DA
2015:                  }
2016:                  CPU_CRITICAL_EXIT();
0036A0  78009E     MOV [W14], W1
0036A2  880211     MOV W1, SR
2017:              
2018:                                                                              /* ------------------ ALLOC NEW BLK ------------------- */
2019:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2020:                  p_pool_name = p_pool->NamePtr;
2021:              #else
2022:                  p_pool_name = DEF_NULL;
0036A4  EB0000     CLR W0
0036A6  980720     MOV W0, [W14+4]
2023:              #endif
2024:                  p_blk = Mem_SegAllocInternal(p_pool_name,
0036AA  9001B0     MOV [W0+6], W3
0036AE  900120     MOV [W0+4], W2
0036B2  900090     MOV [W0+2], W1
0036B6  780010     MOV [W0], W0
0036B8  90034E     MOV [W14+8], W6
0036BA  EB0280     CLR W5
0036BC  780203     MOV W3, W4
0036BE  780182     MOV W2, W3
0036C0  780101     MOV W1, W2
0036C2  780080     MOV W0, W1
0036C4  90002E     MOV [W14+4], W0
0036C6  0700BE     RCALL _Mem_SegAllocInternal
0036C8  980710     MOV W0, [W14+2]
2025:                                               p_pool->PoolSegPtr,
0036B4  90003E     MOV [W14+6], W0
2026:                                               p_pool->BlkSize,
0036B0  90003E     MOV [W14+6], W0
2027:                                               p_pool->BlkAlign,
0036AC  90003E     MOV [W14+6], W0
2028:                                               p_pool->BlkPaddingAlign,
0036A8  90003E     MOV [W14+6], W0
2029:                                               DEF_NULL,
2030:                                               p_err);
2031:                  if (*p_err != LIB_MEM_ERR_NONE) {
0036CA  90004E     MOV [W14+8], W0
0036CC  780090     MOV [W0], W1
0036CE  227100     MOV #0x2710, W0
0036D0  508F80     SUB W1, W0, [W15]
0036D2  320002     BRA Z, 0x36D8
2032:                      return (DEF_NULL);
0036D4  EB0000     CLR W0
0036D6  370001     BRA 0x36DA
2033:                  }
2034:              
2035:                  return (p_blk);
0036D8  90001E     MOV [W14+2], W0
2036:              }
0036DA  FA8000     ULNK
0036DC  060000     RETURN
2037:              
2038:              
2039:              /*
2040:              *********************************************************************************************************
2041:              *                                         Mem_DynPoolBlkFree()
2042:              *
2043:              * Description : Frees memory block, making it available for future use.
2044:              *
2045:              * Argument(s) : p_pool  Pointer to pool data.
2046:              *
2047:              *               p_blk   Pointer to first byte of memory block.
2048:              *
2049:              *               p_err   Pointer to variable that will receive the return error code from this function :
2050:              *
2051:              *                           LIB_MEM_ERR_NONE        Operation was successful.
2052:              *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
2053:              *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
2054:              *
2055:              * Return(s)   : none.
2056:              *
2057:              * Caller(s)   : Application.
2058:              *
2059:              * Note(s)     : none.
2060:              *********************************************************************************************************
2061:              */
2062:              
2063:              void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
2064:                                        void          *p_blk,
2065:                                        LIB_ERR       *p_err)
2066:              {
0036DE  FA0008     LNK #0x8
0036E0  980710     MOV W0, [W14+2]
0036E2  980721     MOV W1, [W14+4]
0036E4  980732     MOV W2, [W14+6]
2067:                  CPU_SR_ALLOC();
0036E6  EB0000     CLR W0
0036E8  780F00     MOV W0, [W14]
2068:              
2069:              
2070:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2071:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2072:                      CPU_SW_EXCEPTION(;);
2073:                  }
2074:              
2075:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2076:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2077:                      return;
2078:                  }
2079:              
2080:                  if (p_blk == DEF_NULL) {
2081:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2082:                      return;
2083:                  }
2084:              #endif
2085:              
2086:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
0036EA  90001E     MOV [W14+2], W0
0036EC  900050     MOV [W0+10], W0
0036EE  E00000     CP0 W0
0036F0  320017     BRA Z, 0x3720
2087:                      CPU_CRITICAL_ENTER();
0036F2  800211     MOV SR, W1
0036F4  780F01     MOV W1, [W14]
0036F6  800211     MOV SR, W1
0036F8  200E00     MOV #0xE0, W0
0036FA  700001     IOR W0, W1, W0
0036FC  880210     MOV W0, SR
2088:                      if (p_pool->BlkAllocCnt == 0u) {
0036FE  90001E     MOV [W14+2], W0
003700  900060     MOV [W0+12], W0
003702  E00000     CP0 W0
003704  3A0006     BRA NZ, 0x3712
2089:                          CPU_CRITICAL_EXIT();
003706  78009E     MOV [W14], W1
003708  880211     MOV W1, SR
2090:              
2091:                         *p_err = LIB_MEM_ERR_POOL_FULL;
00370A  90003E     MOV [W14+6], W0
00370C  227DD1     MOV #0x27DD, W1
00370E  780801     MOV W1, [W0]
2092:                          return;
003710  370019     BRA 0x3744
2093:                      }
2094:              
2095:                      p_pool->BlkAllocCnt--;
003712  90001E     MOV [W14+2], W0
003714  900060     MOV [W0+12], W0
003716  E90080     DEC W0, W1
003718  90001E     MOV [W14+2], W0
00371A  980061     MOV W1, [W0+12]
2096:                      CPU_CRITICAL_EXIT();
00371C  78009E     MOV [W14], W1
00371E  880211     MOV W1, SR
2097:                  }
2098:              
2099:                  CPU_CRITICAL_ENTER();
003720  800211     MOV SR, W1
003722  780F01     MOV W1, [W14]
003724  800211     MOV SR, W1
003726  200E00     MOV #0xE0, W0
003728  700001     IOR W0, W1, W0
00372A  880210     MOV W0, SR
2100:                 *((void **)p_blk)   = p_pool->BlkFreePtr;
00372C  90002E     MOV [W14+4], W0
00372E  90009E     MOV [W14+2], W1
003730  9000C1     MOV [W1+8], W1
003732  780801     MOV W1, [W0]
2101:                  p_pool->BlkFreePtr = p_blk;
003734  90001E     MOV [W14+2], W0
003736  9000AE     MOV [W14+4], W1
003738  980041     MOV W1, [W0+8]
2102:                  CPU_CRITICAL_EXIT();
00373A  78009E     MOV [W14], W1
00373C  880211     MOV W1, SR
2103:              
2104:                 *p_err = LIB_MEM_ERR_NONE;
00373E  90003E     MOV [W14+6], W0
003740  227101     MOV #0x2710, W1
003742  780801     MOV W1, [W0]
2105:              }
003744  FA8000     ULNK
003746  060000     RETURN
2106:              
2107:              
2108:              /*
2109:              *********************************************************************************************************
2110:              *                                     Mem_DynPoolBlkNbrAvailGet()
2111:              *
2112:              * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
2113:              *               dynamic memory pool for which no limit was set at creation.
2114:              *
2115:              * Argument(s) : p_pool  Pointer to pool data.
2116:              *
2117:              *               p_err   Pointer to variable that will receive the return error code from this function :
2118:              *
2119:              *                           LIB_MEM_ERR_NONE                Operation was successful.
2120:              *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
2121:              *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
2122:              *
2123:              * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
2124:              *
2125:              *               0, if pool is empty or if an error occurred.
2126:              *
2127:              * Caller(s)   : Application.
2128:              *
2129:              * Note(s)     : None.
2130:              *********************************************************************************************************
2131:              */
2132:              
2133:              CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
2134:                                                     LIB_ERR       *p_err)
2135:              {
003748  FA0008     LNK #0x8
00374A  980720     MOV W0, [W14+4]
00374C  980731     MOV W1, [W14+6]
2136:                  CPU_SIZE_T  blk_nbr_avail;
2137:                  CPU_SR_ALLOC();
00374E  EB0000     CLR W0
003750  980710     MOV W0, [W14+2]
2138:              
2139:              
2140:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2141:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2142:                      CPU_SW_EXCEPTION(;);
2143:                  }
2144:              
2145:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2146:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2147:                      return (0u);
2148:                  }
2149:              #endif
2150:              
2151:                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
003752  90002E     MOV [W14+4], W0
003754  900050     MOV [W0+10], W0
003756  E00000     CP0 W0
003758  320011     BRA Z, 0x377C
2152:                      CPU_CRITICAL_ENTER();
00375A  800211     MOV SR, W1
00375C  980711     MOV W1, [W14+2]
00375E  800211     MOV SR, W1
003760  200E00     MOV #0xE0, W0
003762  700001     IOR W0, W1, W0
003764  880210     MOV W0, SR
2153:                      blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
003766  90002E     MOV [W14+4], W0
003768  9000D0     MOV [W0+10], W1
00376A  90002E     MOV [W14+4], W0
00376C  900060     MOV [W0+12], W0
00376E  508F00     SUB W1, W0, [W14]
2154:                      CPU_CRITICAL_EXIT();
003770  90009E     MOV [W14+2], W1
003772  880211     MOV W1, SR
2155:              
2156:                     *p_err = LIB_MEM_ERR_NONE;
003774  90003E     MOV [W14+6], W0
003776  227101     MOV #0x2710, W1
003778  780801     MOV W1, [W0]
00377A  370005     BRA 0x3786
2157:                  } else {
2158:                      blk_nbr_avail = 0u;
00377C  EB0000     CLR W0
00377E  780F00     MOV W0, [W14]
2159:                     *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
003780  90003E     MOV [W14+6], W0
003782  227DF1     MOV #0x27DF, W1
003784  780801     MOV W1, [W0]
2160:                  }
2161:              
2162:                  return (blk_nbr_avail);
003786  78001E     MOV [W14], W0
2163:              }
003788  FA8000     ULNK
00378A  060000     RETURN
2164:              
2165:              
2166:              /*
2167:              *********************************************************************************************************
2168:              *                                           Mem_OutputUsage()
2169:              *
2170:              * Description : Outputs memory usage report through 'out_fnct'.
2171:              *
2172:              * Argument(s) : out_fnct        Pointer to output function.
2173:              *
2174:              *               print_details   DEF_YES, if the size of each allocation should be printed.
2175:              *                               DEF_NO,  otherwise.
2176:              *
2177:              *               p_err           Pointer to variable that will receive the return error code from this function :
2178:              *
2179:              *                                   LIB_MEM_ERR_NONE                Operation was successful.
2180:              *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
2181:              *
2182:              *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
2183:              *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
2184:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
2185:              *
2186:              * Return(s)   : None.
2187:              *
2188:              * Caller(s)   : Application.
2189:              *
2190:              * Note(s)     : none.
2191:              *********************************************************************************************************
2192:              */
2193:              
2194:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2195:              void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
2196:                                    LIB_ERR   *p_err)
2197:              {
2198:                  CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
2199:                  MEM_SEG   *p_seg;
2200:                  CPU_SR_ALLOC();
2201:              
2202:              
2203:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2204:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2205:                      CPU_SW_EXCEPTION(;);
2206:                  }
2207:              
2208:                  if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
2209:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2210:                      return;
2211:                  }
2212:              #endif
2213:              
2214:                  out_fnct("---------------- Memory allocation info ----------------\r\n");
2215:                  out_fnct("| Type    | Size       | Free size  | Name\r\n");
2216:                  out_fnct("|---------|------------|------------|-------------------\r\n");
2217:              
2218:                  CPU_CRITICAL_ENTER();
2219:                  p_seg = Mem_SegHeadPtr;
2220:                  while (p_seg != DEF_NULL) {
2221:                      CPU_SIZE_T       rem_size;
2222:                      MEM_SEG_INFO     seg_info;
2223:                      MEM_ALLOC_INFO  *p_alloc;
2224:              
2225:              
2226:                      rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
2227:                      if (*p_err != LIB_MEM_ERR_NONE) {
2228:                          return;
2229:                      }
2230:              
2231:                      out_fnct("| Section | ");
2232:              
2233:                      (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
2234:                                              10u,
2235:                                              DEF_NBR_BASE_DEC,
2236:                                              ' ',
2237:                                              DEF_NO,
2238:                                              DEF_YES,
2239:                                             &str[0u]);
2240:              
2241:                      out_fnct(str);
2242:                      out_fnct(" | ");
2243:              
2244:                      (void)Str_FmtNbr_Int32U(rem_size,
2245:                                              10u,
2246:                                              DEF_NBR_BASE_DEC,
2247:                                              ' ',
2248:                                              DEF_NO,
2249:                                              DEF_YES,
2250:                                             &str[0u]);
2251:              
2252:                      out_fnct(str);
2253:                      out_fnct(" | ");
2254:                      out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
2255:                      out_fnct("\r\n");
2256:              
2257:                      p_alloc = p_seg->AllocInfoHeadPtr;
2258:                      while (p_alloc != DEF_NULL) {
2259:                          out_fnct("| -> Obj  | ");
2260:              
2261:                          (void)Str_FmtNbr_Int32U(p_alloc->Size,
2262:                                                  10u,
2263:                                                  DEF_NBR_BASE_DEC,
2264:                                                  ' ',
2265:                                                  DEF_NO,
2266:                                                  DEF_YES,
2267:                                                 &str[0u]);
2268:              
2269:                          out_fnct(str);
2270:                          out_fnct(" |            | ");
2271:              
2272:                          out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
2273:                          out_fnct("\r\n");
2274:              
2275:                          p_alloc = p_alloc->NextPtr;
2276:                      }
2277:              
2278:                      p_seg = p_seg->NextPtr;
2279:                  }
2280:                  CPU_CRITICAL_EXIT();
2281:              
2282:                 *p_err = LIB_MEM_ERR_NONE;
2283:              }
2284:              #endif
2285:              
2286:              
2287:              /*
2288:              *********************************************************************************************************
2289:              *********************************************************************************************************
2290:              *                                           LOCAL FUNCTIONS
2291:              *********************************************************************************************************
2292:              *********************************************************************************************************
2293:              */
2294:              
2295:              /*
2296:              *********************************************************************************************************
2297:              *                                       Mem_SegCreateCritical()
2298:              *
2299:              * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
2300:              *
2301:              * Argument(s) : p_name          Pointer to segment name.
2302:              *
2303:              *               p_seg           Pointer to segment data. Must be allocated by caller.
2304:              *               -----           Argument validated by caller.
2305:              *
2306:              *               seg_base_addr   Segment's first byte address.
2307:              *
2308:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
2309:              *                               from this memory segment. MUST be a power of 2.
2310:              *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
2311:              *               -------------   Argument validated by caller.
2312:              *
2313:              *               size            Total size of segment, in bytes.
2314:              *               ----            Argument validated by caller.
2315:              *
2316:              * Return(s)   : Pointer to segment data, if successful.
2317:              *
2318:              *               DEF_NULL, otherwise.
2319:              *
2320:              * Caller(s)   : Mem_PoolCreate(),
2321:              *               Mem_SegCreate().
2322:              *
2323:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2324:              *********************************************************************************************************
2325:              */
2326:              
2327:              static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
2328:                                                         MEM_SEG     *p_seg,
2329:                                                         CPU_ADDR     seg_base_addr,
2330:                                                         CPU_SIZE_T   padding_align,
2331:                                                         CPU_SIZE_T   size)
2332:              {
00378C  FA000A     LNK #0xA
00378E  780F00     MOV W0, [W14]
003790  980711     MOV W1, [W14+2]
003792  980722     MOV W2, [W14+4]
003794  980733     MOV W3, [W14+6]
003796  980744     MOV W4, [W14+8]
2333:                  p_seg->AddrBase         =  seg_base_addr;
003798  90001E     MOV [W14+2], W0
00379A  9000AE     MOV [W14+4], W1
00379C  780801     MOV W1, [W0]
2334:                  p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
00379E  9000CE     MOV [W14+8], W1
0037A0  90002E     MOV [W14+4], W0
0037A2  408000     ADD W1, W0, W0
0037A4  E90080     DEC W0, W1
0037A6  90001E     MOV [W14+2], W0
0037A8  980011     MOV W1, [W0+2]
2335:                  p_seg->AddrNext         =  seg_base_addr;
0037AA  90001E     MOV [W14+2], W0
0037AC  9000AE     MOV [W14+4], W1
0037AE  980021     MOV W1, [W0+4]
2336:                  p_seg->NextPtr          =  Mem_SegHeadPtr;
0037B0  804541     MOV Mem_SegHeadPtr, W1
0037B2  90001E     MOV [W14+2], W0
0037B4  980031     MOV W1, [W0+6]
2337:                  p_seg->PaddingAlign     =  padding_align;
0037B6  90001E     MOV [W14+2], W0
0037B8  9000BE     MOV [W14+6], W1
0037BA  980041     MOV W1, [W0+8]
2338:              
2339:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2340:                  p_seg->NamePtr          = p_name;
2341:                  p_seg->AllocInfoHeadPtr = DEF_NULL;
2342:              #else
2343:                  (void)&p_name;
2344:              #endif
2345:              
2346:                  Mem_SegHeadPtr = p_seg;
0037BC  90009E     MOV [W14+2], W1
0037BE  884541     MOV W1, Mem_SegHeadPtr
2347:              }
0037C0  FA8000     ULNK
0037C2  060000     RETURN
2348:              
2349:              
2350:              /*
2351:              *********************************************************************************************************
2352:              *                                      Mem_SegOverlapChkCritical()
2353:              *
2354:              * Description : Checks if existing memory segment exists or overlaps with specified memory area.
2355:              *
2356:              * Argument(s) : seg_base_addr   Address of first byte of memory area.
2357:              *
2358:              *               size            Size of memory area, in bytes.
2359:              *
2360:              *               p_err       Pointer to variable that will receive the return error code from this function :
2361:              *
2362:              *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
2363:              *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
2364:              *
2365:              * Return(s)   : Pointer to memory segment that overlaps.
2366:              *
2367:              *               DEF_NULL, otherwise.
2368:              *
2369:              * Caller(s)   : Mem_PoolCreate(),
2370:              *               Mem_SegCreate().
2371:              *
2372:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2373:              *********************************************************************************************************
2374:              */
2375:              
2376:              static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
2377:                                                           CPU_SIZE_T   size,
2378:                                                           LIB_ERR     *p_err)
2379:              {
0037C4  FA000E     LNK #0xE
0037C6  980740     MOV W0, [W14+8]
0037C8  980751     MOV W1, [W14+10]
0037CA  980762     MOV W2, [W14+12]
2380:                  MEM_SEG   *p_seg_chk;
2381:                  CPU_ADDR   seg_new_end;
2382:                  CPU_ADDR   seg_chk_start;
2383:                  CPU_ADDR   seg_chk_end;
2384:              
2385:              
2386:                  seg_new_end = seg_base_addr + (size - 1u);
0037CC  9000DE     MOV [W14+10], W1
0037CE  90004E     MOV [W14+8], W0
0037D0  408000     ADD W1, W0, W0
0037D2  E90000     DEC W0, W0
0037D4  980710     MOV W0, [W14+2]
2387:                  p_seg_chk   = Mem_SegHeadPtr;
0037D6  804541     MOV Mem_SegHeadPtr, W1
0037D8  780F01     MOV W1, [W14]
2388:              
2389:                  while (p_seg_chk != DEF_NULL) {
0037DA  37002B     BRA 0x3832
003832  78001E     MOV [W14], W0
003834  E00000     CP0 W0
003836  3AFFD2     BRA NZ, 0x37DC
2390:                      seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
0037DC  78001E     MOV [W14], W0
0037DE  780090     MOV [W0], W1
0037E0  980721     MOV W1, [W14+4]
2391:                      seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
0037E2  78001E     MOV [W14], W0
0037E4  900090     MOV [W0+2], W1
0037E6  980731     MOV W1, [W14+6]
2392:              
2393:                      if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
0037E8  9000CE     MOV [W14+8], W1
0037EA  90002E     MOV [W14+4], W0
0037EC  508F80     SUB W1, W0, [W15]
0037EE  3A0009     BRA NZ, 0x3802
0037F0  90009E     MOV [W14+2], W1
0037F2  90003E     MOV [W14+6], W0
0037F4  508F80     SUB W1, W0, [W15]
0037F6  3A0005     BRA NZ, 0x3802
2394:                         *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
0037F8  90006E     MOV [W14+12], W0
0037FA  227801     MOV #0x2780, W1
0037FC  780801     MOV W1, [W0]
2395:                          return (p_seg_chk);
0037FE  78001E     MOV [W14], W0
003800  37001F     BRA 0x3840
2396:                      } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
003802  9000CE     MOV [W14+8], W1
003804  90002E     MOV [W14+4], W0
003806  508F80     SUB W1, W0, [W15]
003808  390004     BRA NC, 0x3812
00380A  9000CE     MOV [W14+8], W1
00380C  90003E     MOV [W14+6], W0
00380E  508F80     SUB W1, W0, [W15]
003810  360008     BRA LEU, 0x3822
003812  9000CE     MOV [W14+8], W1
003814  90002E     MOV [W14+4], W0
003816  508F80     SUB W1, W0, [W15]
003818  3E0009     BRA GTU, 0x382C
2397:                                 ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
00381A  90009E     MOV [W14+2], W1
00381C  90002E     MOV [W14+4], W0
00381E  508F80     SUB W1, W0, [W15]
003820  390005     BRA NC, 0x382C
2398:                         *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
003822  90006E     MOV [W14+12], W0
003824  2277F1     MOV #0x277F, W1
003826  780801     MOV W1, [W0]
2399:                          return (p_seg_chk);
003828  78001E     MOV [W14], W0
00382A  37000A     BRA 0x3840
2400:                      }
2401:              
2402:                      p_seg_chk = p_seg_chk->NextPtr;
00382C  78001E     MOV [W14], W0
00382E  9000B0     MOV [W0+6], W1
003830  780F01     MOV W1, [W14]
2403:                  }
2404:              
2405:                 *p_err = LIB_MEM_ERR_NONE;
003838  90006E     MOV [W14+12], W0
00383A  227101     MOV #0x2710, W1
00383C  780801     MOV W1, [W0]
2406:              
2407:                  return (DEF_NULL);
00383E  EB0000     CLR W0
2408:              }
003840  FA8000     ULNK
003842  060000     RETURN
2409:              
2410:              
2411:              /*
2412:              *********************************************************************************************************
2413:              *                                       Mem_SegAllocInternal()
2414:              *
2415:              * Description : Allocates memory from specified segment.
2416:              *
2417:              * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
2418:              *
2419:              *               p_seg           Pointer to segment from which to allocate memory.
2420:              *               -----           Argument validated by caller.
2421:              *
2422:              *               size            Size of memory block to allocate, in bytes.
2423:              *
2424:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2425:              *
2426:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2427:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2428:              *                               means no padding.
2429:              *
2430:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2431:              *                                the allocation to succeed. Set to DEF_NULL to skip calculation.
2432:              *
2433:              *               p_err           Pointer to variable that will receive the return error code from this function :
2434:              *
2435:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2436:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2437:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2438:              *
2439:              *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
2440:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2441:              *
2442:              * Return(s)   : Pointer to allocated memory block, if successful.
2443:              *
2444:              *               DEF_NULL, otherwise.
2445:              *
2446:              * Caller(s)   : Mem_DynPoolBlkGet(),
2447:              *               Mem_DynPoolCreateInternal(),
2448:              *               Mem_HeapAlloc(),
2449:              *               Mem_PoolCreate(),
2450:              *               Mem_SegAlloc(),
2451:              *               Mem_SegAllocExt(),
2452:              *               Mem_SegAllocHW().
2453:              *
2454:              * Note(s)     : none.
2455:              *********************************************************************************************************
2456:              */
2457:              
2458:              static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
2459:                                                          MEM_SEG     *p_seg,
2460:                                                          CPU_SIZE_T   size,
2461:                                                          CPU_SIZE_T   align,
2462:                                                          CPU_SIZE_T   padding_align,
2463:                                                          CPU_SIZE_T  *p_bytes_reqd,
2464:                                                          LIB_ERR     *p_err)
2465:              {
003844  FA0012     LNK #0x12
003846  980720     MOV W0, [W14+4]
003848  980731     MOV W1, [W14+6]
00384A  980742     MOV W2, [W14+8]
00384C  980753     MOV W3, [W14+10]
00384E  980764     MOV W4, [W14+12]
003850  980775     MOV W5, [W14+14]
003852  980F06     MOV W6, [W14+16]
2466:                  void  *p_blk;
2467:                  CPU_SR_ALLOC();
003854  EB0000     CLR W0
003856  780F00     MOV W0, [W14]
2468:              
2469:              
2470:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2471:                  if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
2472:                      CPU_SW_EXCEPTION(DEF_NULL);
2473:                  }
2474:              
2475:                  if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
2476:                     *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
2477:                      return (DEF_NULL);
2478:                  }
2479:              
2480:                  if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
2481:                     *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
2482:                      return (DEF_NULL);
2483:                  }
2484:              #endif
2485:              
2486:                  CPU_CRITICAL_ENTER();
003858  800211     MOV SR, W1
00385A  780F01     MOV W1, [W14]
00385C  800211     MOV SR, W1
00385E  200E00     MOV #0xE0, W0
003860  700001     IOR W0, W1, W0
003862  880210     MOV W0, SR
2487:                  p_blk = Mem_SegAllocExtCritical(p_seg,
003864  900A8E     MOV [W14+16], W5
003866  90027E     MOV [W14+14], W4
003868  9001EE     MOV [W14+12], W3
00386A  90015E     MOV [W14+10], W2
00386C  9000CE     MOV [W14+8], W1
00386E  90003E     MOV [W14+6], W0
003870  07000F     RCALL _Mem_SegAllocExtCritical
003872  980710     MOV W0, [W14+2]
2488:                                                  size,
2489:                                                  align,
2490:                                                  padding_align,
2491:                                                  p_bytes_reqd,
2492:                                                  p_err);
2493:                  if (*p_err != LIB_MEM_ERR_NONE) {
003874  90080E     MOV [W14+16], W0
003876  780090     MOV [W0], W1
003878  227100     MOV #0x2710, W0
00387A  508F80     SUB W1, W0, [W15]
00387C  320004     BRA Z, 0x3886
2494:                      CPU_CRITICAL_EXIT();
00387E  78009E     MOV [W14], W1
003880  880211     MOV W1, SR
2495:                      return (DEF_NULL);
003882  EB0000     CLR W0
003884  370003     BRA 0x388C
2496:                  }
2497:              
2498:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
2499:                  Mem_SegAllocTrackCritical(p_name,
2500:                                            p_seg,
2501:                                            size,
2502:                                            p_err);
2503:                  if (*p_err != LIB_MEM_ERR_NONE) {
2504:                      CPU_CRITICAL_EXIT();
2505:                      return (DEF_NULL);
2506:                  }
2507:              #else
2508:                  (void)&p_name;
2509:              #endif
2510:                  CPU_CRITICAL_EXIT();
003886  78009E     MOV [W14], W1
003888  880211     MOV W1, SR
2511:              
2512:                  return (p_blk);
00388A  90001E     MOV [W14+2], W0
2513:              }
00388C  FA8000     ULNK
00388E  060000     RETURN
2514:              
2515:              
2516:              /*
2517:              *********************************************************************************************************
2518:              *                                      Mem_SegAllocExtCritical()
2519:              *
2520:              * Description : Allocates memory from specified segment.
2521:              *
2522:              * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
2523:              *
2524:              *               size            Size of memory block to allocate, in bytes.
2525:              *
2526:              *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
2527:              *
2528:              *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
2529:              *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2530:              *                               means no padding.
2531:              *
2532:              *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
2533:              *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
2534:              *
2535:              *               p_err           Pointer to variable that will receive the return error code from this function :
2536:              *
2537:              *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
2538:              *
2539:              * Return(s)   : Pointer to allocated memory block, if successful.
2540:              *
2541:              *               DEF_NULL, otherwise.
2542:              *
2543:              * Caller(s)   : Mem_PoolCreate(),
2544:              *               Mem_SegAllocInternal(),
2545:              *               Mem_SegAllocTrackCritical().
2546:              *
2547:              * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
2548:              *********************************************************************************************************
2549:              */
2550:              
2551:              static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
2552:                                                      CPU_SIZE_T   size,
2553:                                                      CPU_SIZE_T   align,
2554:                                                      CPU_SIZE_T   padding_align,
2555:                                                      CPU_SIZE_T  *p_bytes_reqd,
2556:                                                      LIB_ERR     *p_err)
2557:              {
003890  FA0016     LNK #0x16
003892  980750     MOV W0, [W14+10]
003894  980761     MOV W1, [W14+12]
003896  980772     MOV W2, [W14+14]
003898  980F03     MOV W3, [W14+16]
00389A  980F14     MOV W4, [W14+18]
00389C  980F25     MOV W5, [W14+20]
2558:                  CPU_ADDR    blk_addr;
2559:                  CPU_ADDR    addr_next;
2560:                  CPU_SIZE_T  size_rem_seg;
2561:                  CPU_SIZE_T  size_tot_blk;
2562:                  CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
00389E  9000FE     MOV [W14+14], W1
0038A0  90080E     MOV [W14+16], W0
0038A2  500F81     SUB W0, W1, [W15]
0038A4  310001     BRA C, 0x38A8
0038A6  780001     MOV W1, W0
0038A8  780F00     MOV W0, [W14]
2563:              
2564:              
2565:                  blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
0038AA  90005E     MOV [W14+10], W0
0038AC  9000A0     MOV [W0+4], W1
0038AE  EA001E     NEG [W14], W0
0038B0  608080     AND W1, W0, W1
0038B2  90005E     MOV [W14+10], W0
0038B4  900120     MOV [W0+4], W2
0038B6  E9001E     DEC [W14], W0
0038B8  610000     AND W2, W0, W0
0038BA  E00000     CP0 W0
0038BC  320002     BRA Z, 0x38C2
0038BE  78001E     MOV [W14], W0
0038C0  370001     BRA 0x38C4
0038C2  EB0000     CLR W0
0038C4  408000     ADD W1, W0, W0
0038C6  980710     MOV W0, [W14+2]
2566:                                                        blk_align);
2567:                  addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
0038C8  90009E     MOV [W14+2], W1
0038CA  90006E     MOV [W14+12], W0
0038CC  408080     ADD W1, W0, W1
0038CE  90080E     MOV [W14+16], W0
0038D0  EA0000     NEG W0, W0
0038D2  608080     AND W1, W0, W1
0038D4  90011E     MOV [W14+2], W2
0038D6  90006E     MOV [W14+12], W0
0038D8  410100     ADD W2, W0, W2
0038DA  90080E     MOV [W14+16], W0
0038DC  E90000     DEC W0, W0
0038DE  610000     AND W2, W0, W0
0038E0  E00000     CP0 W0
0038E2  320002     BRA Z, 0x38E8
0038E4  90080E     MOV [W14+16], W0
0038E6  370001     BRA 0x38EA
0038E8  EB0000     CLR W0
0038EA  408000     ADD W1, W0, W0
0038EC  980720     MOV W0, [W14+4]
2568:                                                        padding_align);
2569:                  size_rem_seg = p_seg->AddrEnd - p_seg->AddrNext + 1u;
0038EE  90005E     MOV [W14+10], W0
0038F0  900090     MOV [W0+2], W1
0038F2  90005E     MOV [W14+10], W0
0038F4  900020     MOV [W0+4], W0
0038F6  508000     SUB W1, W0, W0
0038F8  E80000     INC W0, W0
0038FA  980730     MOV W0, [W14+6]
2570:                  size_tot_blk = addr_next - p_seg->AddrNext;                 /* Compute tot blk size including align and padding.    */
0038FC  90005E     MOV [W14+10], W0
0038FE  900020     MOV [W0+4], W0
003900  9000AE     MOV [W14+4], W1
003902  508000     SUB W1, W0, W0
003904  980740     MOV W0, [W14+8]
2571:                  if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
003906  9000BE     MOV [W14+6], W1
003908  90004E     MOV [W14+8], W0
00390A  508F80     SUB W1, W0, [W15]
00390C  31000D     BRA C, 0x3928
2572:                      if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
00390E  90081E     MOV [W14+18], W0
003910  E00000     CP0 W0
003912  320005     BRA Z, 0x391E
2573:                         *p_bytes_reqd = size_tot_blk - size_rem_seg;
003914  9000CE     MOV [W14+8], W1
003916  90003E     MOV [W14+6], W0
003918  508080     SUB W1, W0, W1
00391A  90081E     MOV [W14+18], W0
00391C  780801     MOV W1, [W0]
2574:                      }
2575:              
2576:                     *p_err = LIB_MEM_ERR_SEG_OVF;
00391E  90082E     MOV [W14+20], W0
003920  227D91     MOV #0x27D9, W1
003922  780801     MOV W1, [W0]
2577:                      return (DEF_NULL);
003924  EB0000     CLR W0
003926  370007     BRA 0x3936
2578:                  }
2579:              
2580:                  p_seg->AddrNext = addr_next;
003928  90005E     MOV [W14+10], W0
00392A  9000AE     MOV [W14+4], W1
00392C  980021     MOV W1, [W0+4]
2581:              
2582:                 *p_err = LIB_MEM_ERR_NONE;
00392E  90082E     MOV [W14+20], W0
003930  227101     MOV #0x2710, W1
003932  780801     MOV W1, [W0]
2583:              
2584:                  return ((void *)blk_addr);
003934  90001E     MOV [W14+2], W0
2585:              }
003936  FA8000     ULNK
003938  060000     RETURN
2586:              
2587:              
2588:              /*
2589:              *********************************************************************************************************
2590:              *                                     Mem_SegAllocTrackCritical()
2591:              *
2592:              * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
2593:              *
2594:              * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
2595:              *                       remain accessible at all times.
2596:              *
2597:              *               p_seg   Pointer to segment data.
2598:              *
2599:              *               size    Allocation size, in bytes.
2600:              *
2601:              *               p_err   Pointer to variable that will receive the return error code from this function :
2602:              *
2603:              *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
2604:              *
2605:              *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
2606:              *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
2607:              *
2608:              * Return(s)   : none.
2609:              *
2610:              * Caller(s)   : Mem_PoolCreate(),
2611:              *               Mem_SegAllocInternal().
2612:              *
2613:              * Note(s)     : none.
2614:              *********************************************************************************************************
2615:              */
2616:              
2617:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2618:              static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
2619:                                                              MEM_SEG     *p_seg,
2620:                                                              CPU_SIZE_T   size,
2621:                                                              LIB_ERR     *p_err)
2622:              {
2623:                  MEM_ALLOC_INFO  *p_alloc;
2624:              
2625:              
2626:                                                                              /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
2627:                  p_alloc = p_seg->AllocInfoHeadPtr;
2628:                  while (p_alloc != DEF_NULL) {
2629:                      if (p_alloc->NamePtr == p_name) {
2630:                          p_alloc->Size += size;
2631:                         *p_err = LIB_MEM_ERR_NONE;
2632:                          return;
2633:                      }
2634:              
2635:                      p_alloc = p_alloc->NextPtr;
2636:                  }
2637:              
2638:                                                                              /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
2639:                  p_alloc = Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
2640:                                                     sizeof(MEM_ALLOC_INFO),
2641:                                                     sizeof(CPU_ALIGN),
2642:                                                     LIB_MEM_PADDING_ALIGN_NONE,
2643:                                                     DEF_NULL,
2644:                                                     p_err);
2645:                  if (*p_err != LIB_MEM_ERR_NONE) {
2646:                      return;
2647:                  }
2648:              
2649:                  p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
2650:                  p_alloc->Size    = size;
2651:              
2652:                  p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
2653:                  p_seg->AllocInfoHeadPtr = p_alloc;
2654:              }
2655:              #endif
2656:              
2657:              
2658:              /*
2659:              *********************************************************************************************************
2660:              *                                     Mem_DynPoolCreateInternal()
2661:              *
2662:              * Description : Creates a dynamic memory pool.
2663:              *
2664:              * Argument(s) : p_name              Pointer to pool name.
2665:              *
2666:              *               p_pool              Pointer to pool data.
2667:              *
2668:              *               p_seg               Pointer to segment from which to allocate memory.
2669:              *
2670:              *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
2671:              *
2672:              *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
2673:              *
2674:              *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
2675:              *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
2676:              *                                   means no padding.
2677:              *
2678:              *               blk_qty_init        Initial number of elements to be allocated in pool.
2679:              *
2680:              *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
2681:              *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
2682:              *
2683:              *               p_err           Pointer to variable that will receive the return error code from this function :
2684:              *
2685:              *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
2686:              *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
2687:              *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
2688:              *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
2689:              *
2690:              *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
2691:              *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
2692:              *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
2693:              *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
2694:              *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
2695:              *
2696:              * Return(s)   : None.
2697:              *
2698:              * Caller(s)   : Mem_DynPoolCreate(),
2699:              *               Mem_DynPoolCreateHW().
2700:              *
2701:              * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
2702:              *                   block is stored in the block itself (only when free/unused).
2703:              *********************************************************************************************************
2704:              */
2705:              
2706:              static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
2707:                                                              MEM_DYN_POOL  *p_pool,
2708:                                                              MEM_SEG       *p_seg,
2709:                                                              CPU_SIZE_T     blk_size,
2710:                                                              CPU_SIZE_T     blk_align,
2711:                                                              CPU_SIZE_T     blk_padding_align,
2712:                                                              CPU_SIZE_T     blk_qty_init,
2713:                                                              CPU_SIZE_T     blk_qty_max,
2714:                                                              LIB_ERR       *p_err)
2715:              {
00393A  FA0018     LNK #0x18
00393C  980740     MOV W0, [W14+8]
00393E  980751     MOV W1, [W14+10]
003940  980762     MOV W2, [W14+12]
003942  980773     MOV W3, [W14+14]
003944  980F04     MOV W4, [W14+16]
003946  980F15     MOV W5, [W14+18]
003948  980F26     MOV W6, [W14+20]
00394A  980F37     MOV W7, [W14+22]
2716:                  CPU_INT08U  *p_blks;
2717:                  CPU_SIZE_T   blk_size_align;
2718:                  CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
00394C  90088E     MOV [W14+16], W1
00394E  90081E     MOV [W14+18], W0
003950  500F81     SUB W0, W1, [W15]
003952  310001     BRA C, 0x3956
003954  780001     MOV W1, W0
003956  980730     MOV W0, [W14+6]
2719:              
2720:              
2721:              #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
2722:                  if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
2723:                      CPU_SW_EXCEPTION(DEF_NULL);
2724:                  }
2725:              
2726:                  if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
2727:                     *p_err = LIB_MEM_ERR_NULL_PTR;
2728:                      return;
2729:                  }
2730:              
2731:                  if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
2732:                     *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
2733:                      return;
2734:                  }
2735:              
2736:                  if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
2737:                      (blk_qty_init >  blk_qty_max)) {
2738:                     *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
2739:                      return;
2740:                  }
2741:              
2742:                  if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
2743:                     *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
2744:                      return;
2745:                  }
2746:              #endif
2747:              
2748:                                                                              /* Calc blk size with align.                            */
2749:                  if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
003958  90007E     MOV [W14+14], W0
00395A  500FE1     SUB W0, #0x1, [W15]
00395C  3E000E     BRA GTU, 0x397A
2750:                                                                              /* ... inc size to ptr size.                            */
2751:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
00395E  90003E     MOV [W14+6], W0
003960  EA0000     NEG W0, W0
003962  6000E2     AND W0, #0x2, W1
003964  90003E     MOV [W14+6], W0
003966  E90000     DEC W0, W0
003968  600062     AND W0, #0x2, W0
00396A  E00000     CP0 W0
00396C  320002     BRA Z, 0x3972
00396E  90003E     MOV [W14+6], W0
003970  370001     BRA 0x3974
003972  EB0000     CLR W0
003974  408000     ADD W1, W0, W0
003976  980710     MOV W0, [W14+2]
003978  37000F     BRA 0x3998
2752:                  } else {
2753:                      blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
00397A  90003E     MOV [W14+6], W0
00397C  EA0080     NEG W0, W1
00397E  90007E     MOV [W14+14], W0
003980  608080     AND W1, W0, W1
003982  90003E     MOV [W14+6], W0
003984  E90100     DEC W0, W2
003986  90007E     MOV [W14+14], W0
003988  610000     AND W2, W0, W0
00398A  E00000     CP0 W0
00398C  320002     BRA Z, 0x3992
00398E  90003E     MOV [W14+6], W0
003990  370001     BRA 0x3994
003992  EB0000     CLR W0
003994  408000     ADD W1, W0, W0
003996  980710     MOV W0, [W14+2]
2754:                  }
2755:              
2756:                  if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
003998  90082E     MOV [W14+20], W0
00399A  E00000     CP0 W0
00399C  320012     BRA Z, 0x39C2
2757:                      p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
00399E  90009E     MOV [W14+2], W1
0039A0  90082E     MOV [W14+20], W0
0039A2  B98800     MUL.SS W1, W0, W0
0039A4  780000     MOV W0, W0
0039A6  97BB4E     MOV [W14-8], W6
0039A8  EB0280     CLR W5
0039AA  200014     MOV #0x1, W4
0039AC  9001BE     MOV [W14+6], W3
0039AE  780100     MOV W0, W2
0039B0  9000EE     MOV [W14+12], W1
0039B2  90004E     MOV [W14+8], W0
0039B4  07FF47     RCALL _Mem_SegAllocInternal
0039B6  780F00     MOV W0, [W14]
2758:                                                                  p_seg,
2759:                                                                  blk_size_align * blk_qty_init,
2760:                                                                  blk_align_worst,
2761:                                                                  LIB_MEM_PADDING_ALIGN_NONE,
2762:                                                                  DEF_NULL,
2763:                                                                  p_err);
2764:                      if (*p_err != LIB_MEM_ERR_NONE) {
0039B8  97B84E     MOV [W14-8], W0
0039BA  780090     MOV [W0], W1
0039BC  227100     MOV #0x2710, W0
0039BE  508F80     SUB W1, W0, [W15]
0039C0  3A0034     BRA NZ, 0x3A2A
2765:                          return;
003A2A  000000     NOP
2766:                      }
2767:                  }
2768:              
2769:              
2770:                                                                              /* ----------------- CREATE POOL DATA ----------------- */
2771:                  p_pool->PoolSegPtr      = p_seg;
0039C2  90005E     MOV [W14+10], W0
0039C4  9000EE     MOV [W14+12], W1
0039C6  780801     MOV W1, [W0]
2772:                  p_pool->BlkSize         = blk_size;
0039C8  90005E     MOV [W14+10], W0
0039CA  9000FE     MOV [W14+14], W1
0039CC  980011     MOV W1, [W0+2]
2773:                  p_pool->BlkAlign        = blk_align_worst;
0039CE  90005E     MOV [W14+10], W0
0039D0  9000BE     MOV [W14+6], W1
0039D2  980021     MOV W1, [W0+4]
2774:                  p_pool->BlkPaddingAlign = blk_padding_align;
0039D4  90005E     MOV [W14+10], W0
0039D6  90089E     MOV [W14+18], W1
0039D8  980031     MOV W1, [W0+6]
2775:                  p_pool->BlkQtyMax       = blk_qty_max;
0039DA  90005E     MOV [W14+10], W0
0039DC  9008BE     MOV [W14+22], W1
0039DE  980051     MOV W1, [W0+10]
2776:                  p_pool->BlkAllocCnt     = 0u;
0039E0  90005E     MOV [W14+10], W0
0039E2  EB0080     CLR W1
0039E4  980061     MOV W1, [W0+12]
2777:              
2778:                  if (blk_qty_init != 0u) {                                   /* Init free list.                                      */
0039E6  90082E     MOV [W14+20], W0
0039E8  E00000     CP0 W0
0039EA  320018     BRA Z, 0x3A1C
2779:                      CPU_SIZE_T  i;
2780:              
2781:              
2782:                      p_pool->BlkFreePtr = (void *)p_blks;
0039EC  90005E     MOV [W14+10], W0
0039EE  78009E     MOV [W14], W1
0039F0  980041     MOV W1, [W0+8]
2783:                      for (i = 0u; i < blk_qty_init - 1u; i++) {
0039F2  EB0000     CLR W0
0039F4  980720     MOV W0, [W14+4]
0039F6  370009     BRA 0x3A0A
003A04  90002E     MOV [W14+4], W0
003A06  E80000     INC W0, W0
003A08  980720     MOV W0, [W14+4]
003A0A  90082E     MOV [W14+20], W0
003A0C  E90080     DEC W0, W1
003A0E  90002E     MOV [W14+4], W0
003A10  508F80     SUB W1, W0, [W15]
003A12  3EFFF2     BRA GTU, 0x39F8
2784:                         *((void **)p_blks)  = p_blks + blk_size_align;
0039F8  78001E     MOV [W14], W0
0039FA  90009E     MOV [W14+2], W1
0039FC  40809E     ADD W1, [W14], W1
0039FE  780801     MOV W1, [W0]
2785:                          p_blks            += blk_size_align;
003A00  90001E     MOV [W14+2], W0
003A02  400F1E     ADD W0, [W14], [W14]
2786:                      }
2787:                     *((void **)p_blks) = DEF_NULL;
003A14  78001E     MOV [W14], W0
003A16  EB0080     CLR W1
003A18  780801     MOV W1, [W0]
003A1A  370003     BRA 0x3A22
2788:                  } else {
2789:                      p_pool->BlkFreePtr = DEF_NULL;
003A1C  90005E     MOV [W14+10], W0
003A1E  EB0080     CLR W1
003A20  980041     MOV W1, [W0+8]
2790:                  }
2791:              
2792:              #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
2793:                  p_pool->NamePtr = p_name;
2794:              #endif
2795:              
2796:                 *p_err = LIB_MEM_ERR_NONE;
003A22  97B84E     MOV [W14-8], W0
003A24  227101     MOV #0x2710, W1
003A26  780801     MOV W1, [W0]
003A28  370001     BRA 0x3A2C
2797:              }
003A2C  FA8000     ULNK
2798:              
2799:              
2800:              /*
2801:              *********************************************************************************************************
2802:              *                                      Mem_PoolBlkIsValidAddr()
2803:              *
2804:              * Description : Calculates if a given memory block address is valid for the memory pool.
2805:              *
2806:              * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
2807:              *               ------   Argument validated by caller.
2808:              *
2809:              *               p_mem    Pointer to memory block address to validate.
2810:              *               -----    Argument validated by caller.
2811:              *
2812:              * Return(s)   : DEF_YES, if valid memory pool block address.
2813:              *
2814:              *               DEF_NO,  otherwise.
2815:              *
2816:              * Caller(s)   : Mem_PoolBlkFree().
2817:              *
2818:              * Note(s)     : none.
2819:              *********************************************************************************************************
2820:              */
2821:              
2822:              #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
2823:                   (LIB_MEM_CFG_HEAP_SIZE      >  0u))
2824:              static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
2825:                                                           void      *p_mem)
2826:              {
2827:                  CPU_ADDR  pool_offset;
2828:              
2829:              
2830:                  if ((p_mem < p_pool->PoolAddrStart) ||
2831:                      (p_mem > p_pool->PoolAddrEnd)) {
2832:                      return (DEF_FALSE);
2833:                  }
2834:              
2835:                  pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
2836:                  if (pool_offset % p_pool->BlkSize != 0u) {
2837:                      return (DEF_FALSE);
2838:                  } else {
2839:                      return (DEF_TRUE);
2840:                  }
2841:              }
2842:              #endif
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uC-LIB/lib_math.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                        MATHEMATIC OPERATIONS
29:                *
30:                * Filename      : lib_math.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : SR
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *********************************************************************************************************
51:                * Notice(s)     : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
52:                *                     us permission to reprint portions of their documentation.  Portions of this text are
53:                *                     reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
54:                *                     Standard for Information Technology -- Portable Operating System Interface (POSIX),
55:                *                     The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
56:                *                     of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
57:                *                     discrepancy between these versions and the original IEEE and The Open Group Standard,
58:                *                     the original IEEE and The Open Group Standard is the referee document.  The original
59:                *                     Standard can be obtained online at http://www.opengroup.org/unix/online.html.
60:                *********************************************************************************************************
61:                */
62:                
63:                
64:                /*
65:                *********************************************************************************************************
66:                *                                            INCLUDE FILES
67:                *********************************************************************************************************
68:                */
69:                
70:                #define    MICRIUM_SOURCE
71:                #define    LIB_MATH_MODULE
72:                #include  <lib_math.h>
73:                
74:                
75:                /*
76:                *********************************************************************************************************
77:                *                                            LOCAL DEFINES
78:                *********************************************************************************************************
79:                */
80:                
81:                
82:                /*
83:                *********************************************************************************************************
84:                *                                           LOCAL CONSTANTS
85:                *********************************************************************************************************
86:                */
87:                
88:                
89:                /*
90:                *********************************************************************************************************
91:                *                                          LOCAL DATA TYPES
92:                *********************************************************************************************************
93:                */
94:                
95:                
96:                /*
97:                *********************************************************************************************************
98:                *                                            LOCAL TABLES
99:                *********************************************************************************************************
100:               */
101:               
102:               
103:               /*
104:               *********************************************************************************************************
105:               *                                       LOCAL GLOBAL VARIABLES
106:               *********************************************************************************************************
107:               */
108:               
109:               RAND_NBR  Math_RandSeedCur;                                     /* Cur rand nbr seed.                                   */
110:               
111:               
112:               /*
113:               *********************************************************************************************************
114:               *                                      LOCAL FUNCTION PROTOTYPES
115:               *********************************************************************************************************
116:               */
117:               
118:               
119:               /*
120:               *********************************************************************************************************
121:               *                                     LOCAL CONFIGURATION ERRORS
122:               *********************************************************************************************************
123:               */
124:               
125:               
126:               /*
127:               *********************************************************************************************************
128:               *                                             Math_Init()
129:               *
130:               * Description : (1) Initialize Mathematic Module :
131:               *
132:               *                   (a) Initialize random number seed value
133:               *
134:               *
135:               * Argument(s) : none.
136:               *
137:               * Return(s)   : none.
138:               *
139:               * Caller(s)   : Application.
140:               *
141:               * Note(s)     : (2) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "if rand()
142:               *                   is called before any calls to srand() are made, the same sequence shall be generated
143:               *                   as when srand() is first called with a seed value of 1".
144:               *********************************************************************************************************
145:               */
146:               
147:               void  Math_Init (void)
148:               {
007878  FA0000     LNK #0x0
149:                   Math_RandSetSeed((RAND_NBR)RAND_SEED_INIT_VAL);             /* See Note #2.                                         */
00787A  200010     MOV #0x1, W0
00787C  200001     MOV #0x0, W1
00787E  070002     RCALL Math_RandSetSeed
150:               }
007880  FA8000     ULNK
007882  060000     RETURN
151:               
152:               
153:               /*
154:               *********************************************************************************************************
155:               *                                         Math_RandSetSeed()
156:               *
157:               * Description : Set the current pseudo-random number generator seed.
158:               *
159:               * Argument(s) : seed        Initial (or current) value to set for the pseudo-random number sequence.
160:               *
161:               * Return(s)   : none.
162:               *
163:               * Caller(s)   : Application.
164:               *
165:               * Note(s)     : (1) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "srand()
166:               *                   ... uses the argument as a seed for a new sequence of pseudo-random numbers to be
167:               *                   returned by subsequent calls to rand()".
168:               *
169:               *               (2) 'Math_RandSeedCur' MUST always be accessed exclusively in critical sections.
170:               *
171:               *                   See also 'Math_Rand()  Note #1b'.
172:               *********************************************************************************************************
173:               */
174:               
175:               void  Math_RandSetSeed (RAND_NBR  seed)
176:               {
007884  FA0006     LNK #0x6
007886  980710     MOV W0, [W14+2]
007888  980721     MOV W1, [W14+4]
177:                   CPU_SR_ALLOC();
00788A  EB0000     CLR W0
00788C  780F00     MOV W0, [W14]
178:               
179:               
180:                   CPU_CRITICAL_ENTER();
00788E  800211     MOV SR, W1
007890  780F01     MOV W1, [W14]
007892  800211     MOV SR, W1
007894  200E00     MOV #0xE0, W0
007896  700001     IOR W0, W1, W0
007898  880210     MOV W0, SR
181:                   Math_RandSeedCur = seed;
00789A  90011E     MOV [W14+2], W2
00789C  9001AE     MOV [W14+4], W3
00789E  884522     MOV W2, Math_RandSeedCur
0078A0  884533     MOV W3, 0x8A6
182:                   CPU_CRITICAL_EXIT();
0078A2  78019E     MOV [W14], W3
0078A4  880213     MOV W3, SR
183:               }
0078A6  FA8000     ULNK
0078A8  060000     RETURN
184:               
185:               
186:               /*
187:               *********************************************************************************************************
188:               *                                             Math_Rand()
189:               *
190:               * Description : Calculate the next pseudo-random number.
191:               *
192:               * Argument(s) : none.
193:               *
194:               * Return(s)   : Next pseudo-random number in the sequence after 'Math_RandSeedCur'.
195:               *
196:               * Caller(s)   : Application.
197:               *
198:               * Note(s)     : (1) (a) The pseudo-random number generator is implemented as a Linear Congruential
199:               *                       Generator (LCG).
200:               *
201:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
202:               *
203:               *                   See also 'Math_RandSeed()  Note #1'.
204:               *
205:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
206:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
207:               *
208:               *                   (b) However, in order to implement Math_Rand() as re-entrant; 'Math_RandSeedCur' MUST
209:               *                       always be accessed & updated exclusively in critical sections.
210:               *
211:               *                   See also 'Math_RandSeed()  Note #2'.
212:               *********************************************************************************************************
213:               */
214:               
215:               RAND_NBR  Math_Rand (void)
216:               {
0078AA  FA000A     LNK #0xA
217:                   RAND_NBR  seed;
218:                   RAND_NBR  rand_nbr;
219:                   CPU_SR_ALLOC();
0078AC  EB0000     CLR W0
0078AE  780F00     MOV W0, [W14]
220:               
221:               
222:                   CPU_CRITICAL_ENTER();
0078B0  800211     MOV SR, W1
0078B2  780F01     MOV W1, [W14]
0078B4  800211     MOV SR, W1
0078B6  200E00     MOV #0xE0, W0
0078B8  700001     IOR W0, W1, W0
0078BA  880210     MOV W0, SR
223:                   seed             = Math_RandSeedCur;
0078BC  804522     MOV Math_RandSeedCur, W2
0078BE  804533     MOV 0x8A6, W3
0078C0  980712     MOV W2, [W14+2]
0078C2  980723     MOV W3, [W14+4]
224:                   rand_nbr         = Math_RandSeed(seed);
0078C4  90001E     MOV [W14+2], W0
0078C6  9000AE     MOV [W14+4], W1
0078C8  07000C     RCALL Math_RandSeed
0078CA  980730     MOV W0, [W14+6]
0078CC  980741     MOV W1, [W14+8]
225:                   Math_RandSeedCur = rand_nbr;
0078CE  90013E     MOV [W14+6], W2
0078D0  9001CE     MOV [W14+8], W3
0078D2  884522     MOV W2, Math_RandSeedCur
0078D4  884533     MOV W3, 0x8A6
226:                   CPU_CRITICAL_EXIT();
0078D6  78019E     MOV [W14], W3
0078D8  880213     MOV W3, SR
227:               
228:                   return (rand_nbr);
0078DA  90003E     MOV [W14+6], W0
0078DC  9000CE     MOV [W14+8], W1
229:               }
0078DE  FA8000     ULNK
0078E0  060000     RETURN
230:               
231:               
232:               /*
233:               *********************************************************************************************************
234:               *                                           Math_RandSeed()
235:               *
236:               * Description : Calculate the next pseudo-random number.
237:               *
238:               * Argument(s) : seed        Initial (or current) value for the pseudo-random number sequence.
239:               *
240:               * Return(s)   : Next pseudo-random number in the sequence after 'seed'.
241:               *
242:               * Caller(s)   : Math_Rand(),
243:               *               Application.
244:               *
245:               * Note(s)     : (1) (a) BSD/ANSI-C implements rand() as a Linear Congruential Generator (LCG) :
246:               *
247:               *                       (A) random_number       =  [(a * random_number ) + b]  modulo m
248:               *                                        n + 1                        n
249:               *
250:               *                               where
251:               *                                       (1) (a) random_number           Next     random number to generate
252:               *                                                            n+1
253:               *                                           (b) random_number           Previous random number    generated
254:               *                                                            n
255:               *
256:               *                                       (2) a = RAND_LCG_PARAM_A        LCG multiplier
257:               *                                       (3) b = RAND_LCG_PARAM_B        LCG incrementor
258:               *                                       (4) m = RAND_LCG_PARAM_M + 1    LCG modulus
259:               *
260:               *                   (b) The pseudo-random number generated is in the range [0, RAND_LCG_PARAM_M].
261:               *
262:                                   See also 'lib_math.h  RANDOM NUMBER DEFINES  Note #1b'.
263:               *
264:               *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'rand() : DESCRIPTION' states that "rand()
265:               *                       ... need not be reentrant ... [and] is not required to be thread-safe".
266:               *
267:               *                   (b) However, Math_RandSeed() is re-entrant since it calculates the next random number
268:               *                       using ONLY local variables.
269:               *********************************************************************************************************
270:               */
271:               
272:               RAND_NBR  Math_RandSeed (RAND_NBR  seed)
273:               {
0078E2  FA0008     LNK #0x8
0078E4  980720     MOV W0, [W14+4]
0078E6  980731     MOV W1, [W14+6]
274:                   RAND_NBR  rand_nbr;
275:               
276:               
277:                   rand_nbr = (((RAND_NBR)RAND_LCG_PARAM_A * seed) + (RAND_NBR)RAND_LCG_PARAM_B)  %  ((RAND_NBR)RAND_LCG_PARAM_M + 1u);
0078E8  9000BE     MOV [W14+6], W1
0078EA  24E6D0     MOV #0x4E6D, W0
0078EC  B98800     MUL.SS W1, W0, W0
0078EE  780100     MOV W0, W2
0078F0  9000AE     MOV [W14+4], W1
0078F2  241C60     MOV #0x41C6, W0
0078F4  B98800     MUL.SS W1, W0, W0
0078F6  780000     MOV W0, W0
0078F8  410100     ADD W2, W0, W2
0078FA  9000AE     MOV [W14+4], W1
0078FC  24E6D0     MOV #0x4E6D, W0
0078FE  B80800     MUL.UU W1, W0, W0
007900  410101     ADD W2, W1, W2
007902  780082     MOV W2, W1
007904  230392     MOV #0x3039, W2
007906  200003     MOV #0x0, W3
007908  410100     ADD W2, W0, W2
00790A  498181     ADDC W3, W1, W3
00790C  2FFFF0     MOV #0xFFFF, W0
00790E  27FFF1     MOV #0x7FFF, W1
007910  780202     MOV W2, W4
007912  780183     MOV W3, W3
007914  780100     MOV W0, W2
007916  780001     MOV W1, W0
007918  620102     AND W4, W2, W2
00791A  618000     AND W3, W0, W0
00791C  EB0080     CLR W1
00791E  DD00C0     SL W0, #0, W1
007920  200000     MOV #0x0, W0
007922  BE8F00     MOV.D W0, [W14]
007924  B81061     MUL.UU W2, #1, W0
007926  701F1E     IOR W0, [W14], [W14++]
007928  70971E     IOR W1, [W14], [W14--]
278:               
279:                   return (rand_nbr);
00792A  BE001E     MOV.D [W14], W0
280:               }
00792C  FA8000     ULNK
281:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uC-LIB/lib_ascii.c  ------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/LIB
4:                 *                                        CUSTOM LIBRARY MODULES
5:                 *
6:                 *                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
7:                 *
8:                 *                  All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
11:                *                  illegal to distribute this source code to any third party unless you receive
12:                *                  written permission by an authorized Micrium representative.  Knowledge of
13:                *                  the source code may NOT be used to develop a similar product.
14:                *
15:                *                  Please help us continue to provide the Embedded community with the finest
16:                *                  software available.  Your honesty is greatly appreciated.
17:                *
18:                *                  You can find our product's user manual, API reference, release notes and
19:                *                  more information at: https://doc.micrium.com
20:                *
21:                *                  You can contact us at: http://www.micrium.com
22:                *********************************************************************************************************
23:                */
24:                
25:                /*
26:                *********************************************************************************************************
27:                *
28:                *                                     ASCII CHARACTER OPERATIONS
29:                *
30:                * Filename      : lib_ascii.c
31:                * Version       : V1.38.01
32:                * Programmer(s) : BAN
33:                *                 ITJ
34:                *********************************************************************************************************
35:                * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
36:                *
37:                *                     (a) ALL standard library functions are implemented in the custom library modules :
38:                *
39:                *                         (1) \<Custom Library Directory>\lib_*.*
40:                *
41:                *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
42:                *
43:                *                               where
44:                *                                       <Custom Library Directory>      directory path for custom library software
45:                *                                       <cpu>                           directory name for specific processor (CPU)
46:                *                                       <compiler>                      directory name for specific compiler
47:                *
48:                *                     (b) Product-specific library functions are implemented in individual products.
49:                *
50:                *
51:                *                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
52:                *                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
53:                *
54:                *                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
55:                *                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
56:                *                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
57:                *                             All other characters are explicitly specified.
58:                *
59:                *                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
60:                *                             in the 7-bit character set.
61:                *
62:                *                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
63:                *                             standard in specified ways.
64:                *
65:                *                     (b) The character set represented in this file reproduces the Internation Reference
66:                *                         Version.  This is identical to the 7-bit character set which occupies Unicode
67:                *                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
68:                *                         Unicode specification, with certain abbreviations so that the resulting #define
69:                *                         names will not violate ANSI C naming restriction :
70:                *
71:                *                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
72:                *                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
73:                *********************************************************************************************************
74:                */
75:                
76:                
77:                /*
78:                *********************************************************************************************************
79:                *                                            INCLUDE FILES
80:                *********************************************************************************************************
81:                */
82:                
83:                #define    MICRIUM_SOURCE
84:                #define    LIB_ASCII_MODULE
85:                #include  <lib_ascii.h>
86:                
87:                
88:                /*
89:                *********************************************************************************************************
90:                *                                            LOCAL DEFINES
91:                *********************************************************************************************************
92:                */
93:                
94:                
95:                /*
96:                *********************************************************************************************************
97:                *                                           LOCAL CONSTANTS
98:                *********************************************************************************************************
99:                */
100:               
101:               
102:               /*
103:               *********************************************************************************************************
104:               *                                          LOCAL DATA TYPES
105:               *********************************************************************************************************
106:               */
107:               
108:               
109:               /*
110:               *********************************************************************************************************
111:               *                                            LOCAL TABLES
112:               *********************************************************************************************************
113:               */
114:               
115:               
116:               /*
117:               *********************************************************************************************************
118:               *                                       LOCAL GLOBAL VARIABLES
119:               *********************************************************************************************************
120:               */
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                      LOCAL FUNCTION PROTOTYPES
126:               *********************************************************************************************************
127:               */
128:               
129:               
130:               /*
131:               *********************************************************************************************************
132:               *                                     LOCAL CONFIGURATION ERRORS
133:               *********************************************************************************************************
134:               */
135:               
136:               
137:               /*
138:               *********************************************************************************************************
139:               *                                           ASCII_IsAlpha()
140:               *
141:               * Description : Determine whether a character is an alphabetic character.
142:               *
143:               * Argument(s) : c           Character to examine.
144:               *
145:               * Return(s)   : DEF_YES, if character is     an alphabetic character.
146:               *
147:               *               DEF_NO,     if character is NOT an alphabetic character.
148:               *
149:               * Caller(s)   : Application.
150:               *
151:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
152:               *                   characters for which isupper() or islower() is true".
153:               *********************************************************************************************************
154:               */
155:               
156:               CPU_BOOLEAN  ASCII_IsAlpha (CPU_CHAR  c)
157:               {
00630A  FA0004     LNK #0x4
00630C  984720     MOV.B W0, [W14+2]
158:                   CPU_BOOLEAN  alpha;
159:               
160:               
161:                   alpha = ASCII_IS_ALPHA(c);
00630E  9040AE     MOV.B [W14+2], W1
006310  B3C400     MOV.B #0x40, W0
006312  50CF80     SUB.B W1, W0, [W15]
006314  360004     BRA LEU, 0x631E
006316  9040AE     MOV.B [W14+2], W1
006318  B3C5A0     MOV.B #0x5A, W0
00631A  50CF80     SUB.B W1, W0, [W15]
00631C  360008     BRA LEU, 0x632E
00631E  9040AE     MOV.B [W14+2], W1
006320  B3C600     MOV.B #0x60, W0
006322  50CF80     SUB.B W1, W0, [W15]
006324  360006     BRA LEU, 0x6332
006326  9040AE     MOV.B [W14+2], W1
006328  B3C7A0     MOV.B #0x7A, W0
00632A  50CF80     SUB.B W1, W0, [W15]
00632C  3E0002     BRA GTU, 0x6332
00632E  B3C010     MOV.B #0x1, W0
006330  370001     BRA 0x6334
006332  EB4000     CLR.B W0
006334  784F00     MOV.B W0, [W14]
162:               
163:                   return (alpha);
006336  78401E     MOV.B [W14], W0
164:               }
006338  FA8000     ULNK
00633A  060000     RETURN
165:               
166:               
167:               /*
168:               *********************************************************************************************************
169:               *                                         ASCII_IsAlphaNum()
170:               *
171:               * Description : Determine whether a character is an alphanumeric character.
172:               *
173:               * Argument(s) : c           Character to examine.
174:               *
175:               * Return(s)   : DEF_YES, if character is     an alphanumeric character.
176:               *
177:               *               DEF_NO,     if character is NOT an alphanumeric character.
178:               *
179:               * Caller(s)   : Application.
180:               *
181:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
182:               *                   for which isalpha() or isdigit() is true".
183:               *********************************************************************************************************
184:               */
185:               
186:               CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
187:               {
00633C  FA0004     LNK #0x4
00633E  984720     MOV.B W0, [W14+2]
188:                   CPU_BOOLEAN  alpha_num;
189:               
190:               
191:                   alpha_num = ASCII_IS_ALPHA_NUM(c);
006340  9040AE     MOV.B [W14+2], W1
006342  B3C400     MOV.B #0x40, W0
006344  50CF80     SUB.B W1, W0, [W15]
006346  360004     BRA LEU, 0x6350
006348  9040AE     MOV.B [W14+2], W1
00634A  B3C5A0     MOV.B #0x5A, W0
00634C  50CF80     SUB.B W1, W0, [W15]
00634E  360010     BRA LEU, 0x6370
006350  9040AE     MOV.B [W14+2], W1
006352  B3C600     MOV.B #0x60, W0
006354  50CF80     SUB.B W1, W0, [W15]
006356  360004     BRA LEU, 0x6360
006358  9040AE     MOV.B [W14+2], W1
00635A  B3C7A0     MOV.B #0x7A, W0
00635C  50CF80     SUB.B W1, W0, [W15]
00635E  360008     BRA LEU, 0x6370
006360  9040AE     MOV.B [W14+2], W1
006362  B3C2F0     MOV.B #0x2F, W0
006364  50CF80     SUB.B W1, W0, [W15]
006366  360006     BRA LEU, 0x6374
006368  9040AE     MOV.B [W14+2], W1
00636A  B3C390     MOV.B #0x39, W0
00636C  50CF80     SUB.B W1, W0, [W15]
00636E  3E0002     BRA GTU, 0x6374
006370  B3C010     MOV.B #0x1, W0
006372  370001     BRA 0x6376
006374  EB4000     CLR.B W0
006376  784F00     MOV.B W0, [W14]
192:               
193:                   return (alpha_num);
006378  78401E     MOV.B [W14], W0
194:               }
00637A  FA8000     ULNK
00637C  060000     RETURN
195:               
196:               
197:               /*
198:               *********************************************************************************************************
199:               *                                           ASCII_IsLower()
200:               *
201:               * Description : Determine whether a character is a lowercase alphabetic character.
202:               *
203:               * Argument(s) : c           Character to examine.
204:               *
205:               * Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
206:               *
207:               *               DEF_NO,     if character is NOT a lowercase alphabetic character.
208:               *
209:               * Caller(s)   : Application.
210:               *
211:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
212:               *                   the lowercase letters".
213:               *********************************************************************************************************
214:               */
215:               
216:               CPU_BOOLEAN  ASCII_IsLower (CPU_CHAR  c)
217:               {
00637E  FA0004     LNK #0x4
006380  984720     MOV.B W0, [W14+2]
218:                   CPU_BOOLEAN  lower;
219:               
220:               
221:                   lower = ASCII_IS_LOWER(c);
006382  9040AE     MOV.B [W14+2], W1
006384  B3C600     MOV.B #0x60, W0
006386  50CF80     SUB.B W1, W0, [W15]
006388  360006     BRA LEU, 0x6396
00638A  9040AE     MOV.B [W14+2], W1
00638C  B3C7A0     MOV.B #0x7A, W0
00638E  50CF80     SUB.B W1, W0, [W15]
006390  3E0002     BRA GTU, 0x6396
006392  B3C010     MOV.B #0x1, W0
006394  370001     BRA 0x6398
006396  EB4000     CLR.B W0
006398  784F00     MOV.B W0, [W14]
222:               
223:                   return (lower);
00639A  78401E     MOV.B [W14], W0
224:               }
00639C  FA8000     ULNK
00639E  060000     RETURN
225:               
226:               
227:               /*
228:               *********************************************************************************************************
229:               *                                           ASCII_IsUpper()
230:               *
231:               * Description : Determine whether a character is an uppercase alphabetic character.
232:               *
233:               * Argument(s) : c           Character to examine.
234:               *
235:               * Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
236:               *
237:               *               DEF_NO,     if character is NOT an uppercase alphabetic character.
238:               *
239:               * Caller(s)   : Application.
240:               *
241:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
242:               *                   the uppercase letters".
243:               *********************************************************************************************************
244:               */
245:               
246:               CPU_BOOLEAN  ASCII_IsUpper (CPU_CHAR  c)
247:               {
0063A0  FA0004     LNK #0x4
0063A2  984720     MOV.B W0, [W14+2]
248:                   CPU_BOOLEAN  upper;
249:               
250:               
251:                   upper = ASCII_IS_UPPER(c);
0063A4  9040AE     MOV.B [W14+2], W1
0063A6  B3C400     MOV.B #0x40, W0
0063A8  50CF80     SUB.B W1, W0, [W15]
0063AA  360006     BRA LEU, 0x63B8
0063AC  9040AE     MOV.B [W14+2], W1
0063AE  B3C5A0     MOV.B #0x5A, W0
0063B0  50CF80     SUB.B W1, W0, [W15]
0063B2  3E0002     BRA GTU, 0x63B8
0063B4  B3C010     MOV.B #0x1, W0
0063B6  370001     BRA 0x63BA
0063B8  EB4000     CLR.B W0
0063BA  784F00     MOV.B W0, [W14]
252:               
253:                   return (upper);
0063BC  78401E     MOV.B [W14], W0
254:               }
0063BE  FA8000     ULNK
0063C0  060000     RETURN
255:               
256:               
257:               /*
258:               *********************************************************************************************************
259:               *                                            ASCII_IsDig()
260:               *
261:               * Description : Determine whether a character is a decimal-digit character.
262:               *
263:               * Argument(s) : c           Character to examine.
264:               *
265:               * Return(s)   : DEF_YES, if character is     a decimal-digit character.
266:               *
267:               *               DEF_NO,     if character is NOT a decimal-digit character.
268:               *
269:               * Caller(s)   : Application.
270:               *
271:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
272:               *                   decimal-digit character".
273:               *********************************************************************************************************
274:               */
275:               
276:               CPU_BOOLEAN  ASCII_IsDig (CPU_CHAR  c)
277:               {
0063C2  FA0004     LNK #0x4
0063C4  984720     MOV.B W0, [W14+2]
278:                   CPU_BOOLEAN  dig;
279:               
280:               
281:                   dig = ASCII_IS_DIG(c);
0063C6  9040AE     MOV.B [W14+2], W1
0063C8  B3C2F0     MOV.B #0x2F, W0
0063CA  50CF80     SUB.B W1, W0, [W15]
0063CC  360006     BRA LEU, 0x63DA
0063CE  9040AE     MOV.B [W14+2], W1
0063D0  B3C390     MOV.B #0x39, W0
0063D2  50CF80     SUB.B W1, W0, [W15]
0063D4  3E0002     BRA GTU, 0x63DA
0063D6  B3C010     MOV.B #0x1, W0
0063D8  370001     BRA 0x63DC
0063DA  EB4000     CLR.B W0
0063DC  784F00     MOV.B W0, [W14]
282:               
283:                   return (dig);
0063DE  78401E     MOV.B [W14], W0
284:               }
0063E0  FA8000     ULNK
0063E2  060000     RETURN
285:               
286:               
287:               /*
288:               *********************************************************************************************************
289:               *                                          ASCII_IsDigOct()
290:               *
291:               * Description : Determine whether a character is an octal-digit character.
292:               *
293:               * Argument(s) : c           Character to examine.
294:               *
295:               * Return(s)   : DEF_YES, if character is     an octal-digit character.
296:               *
297:               *               DEF_NO,     if character is NOT an octal-digit character.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               * Note(s)     : none.
302:               *********************************************************************************************************
303:               */
304:               
305:               CPU_BOOLEAN  ASCII_IsDigOct (CPU_CHAR  c)
306:               {
0063E4  FA0004     LNK #0x4
0063E6  984720     MOV.B W0, [W14+2]
307:                   CPU_BOOLEAN  dig_oct;
308:               
309:               
310:                   dig_oct = ASCII_IS_DIG_OCT(c);
0063E8  9040AE     MOV.B [W14+2], W1
0063EA  B3C2F0     MOV.B #0x2F, W0
0063EC  50CF80     SUB.B W1, W0, [W15]
0063EE  360006     BRA LEU, 0x63FC
0063F0  9040AE     MOV.B [W14+2], W1
0063F2  B3C370     MOV.B #0x37, W0
0063F4  50CF80     SUB.B W1, W0, [W15]
0063F6  3E0002     BRA GTU, 0x63FC
0063F8  B3C010     MOV.B #0x1, W0
0063FA  370001     BRA 0x63FE
0063FC  EB4000     CLR.B W0
0063FE  784F00     MOV.B W0, [W14]
311:               
312:                   return (dig_oct);
006400  78401E     MOV.B [W14], W0
313:               }
006402  FA8000     ULNK
006404  060000     RETURN
314:               
315:               
316:               /*
317:               *********************************************************************************************************
318:               *                                          ASCII_IsDigHex()
319:               *
320:               * Description : Determine whether a character is a hexadecimal-digit character.
321:               *
322:               * Argument(s) : c           Character to examine.
323:               *
324:               * Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
325:               *
326:               *               DEF_NO,     if character is NOT a hexadecimal-digit character.
327:               *
328:               * Caller(s)   : Application.
329:               *
330:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
331:               *                   hexadecimal-digit character".
332:               *********************************************************************************************************
333:               */
334:               
335:               CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
336:               {
006406  FA0004     LNK #0x4
006408  984720     MOV.B W0, [W14+2]
337:                   CPU_BOOLEAN  dig_hex;
338:               
339:               
340:                   dig_hex = ASCII_IS_DIG_HEX(c);
00640A  9040AE     MOV.B [W14+2], W1
00640C  B3C2F0     MOV.B #0x2F, W0
00640E  50CF80     SUB.B W1, W0, [W15]
006410  360004     BRA LEU, 0x641A
006412  9040AE     MOV.B [W14+2], W1
006414  B3C390     MOV.B #0x39, W0
006416  50CF80     SUB.B W1, W0, [W15]
006418  360010     BRA LEU, 0x643A
00641A  9040AE     MOV.B [W14+2], W1
00641C  B3C400     MOV.B #0x40, W0
00641E  50CF80     SUB.B W1, W0, [W15]
006420  360004     BRA LEU, 0x642A
006422  9040AE     MOV.B [W14+2], W1
006424  B3C460     MOV.B #0x46, W0
006426  50CF80     SUB.B W1, W0, [W15]
006428  360008     BRA LEU, 0x643A
00642A  9040AE     MOV.B [W14+2], W1
00642C  B3C600     MOV.B #0x60, W0
00642E  50CF80     SUB.B W1, W0, [W15]
006430  360006     BRA LEU, 0x643E
006432  9040AE     MOV.B [W14+2], W1
006434  B3C660     MOV.B #0x66, W0
006436  50CF80     SUB.B W1, W0, [W15]
006438  3E0002     BRA GTU, 0x643E
00643A  B3C010     MOV.B #0x1, W0
00643C  370001     BRA 0x6440
00643E  EB4000     CLR.B W0
006440  784F00     MOV.B W0, [W14]
341:               
342:                   return (dig_hex);
006442  78401E     MOV.B [W14], W0
343:               }
006444  FA8000     ULNK
006446  060000     RETURN
344:               
345:               
346:               /*
347:               *********************************************************************************************************
348:               *                                           ASCII_IsBlank()
349:               *
350:               * Description : Determine whether a character is a standard blank character.
351:               *
352:               * Argument(s) : c           Character to examine.
353:               *
354:               * Return(s)   : DEF_YES, if character is     a standard blank character.
355:               *
356:               *               DEF_NO,     if character is NOT a standard blank character.
357:               *
358:               * Caller(s)   : Application.
359:               *
360:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
361:               *                       the standard blank characters".
362:               *
363:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
364:               *                       the "space (' '), and horizontal tab ('\t')".
365:               *********************************************************************************************************
366:               */
367:               
368:               CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
369:               {
006448  FA0004     LNK #0x4
00644A  984720     MOV.B W0, [W14+2]
370:                   CPU_BOOLEAN  blank;
371:               
372:               
373:                   blank = ASCII_IS_BLANK(c);
00644C  9040AE     MOV.B [W14+2], W1
00644E  B3C200     MOV.B #0x20, W0
006450  50CF80     SUB.B W1, W0, [W15]
006452  320003     BRA Z, 0x645A
006454  90402E     MOV.B [W14+2], W0
006456  504FE9     SUB.B W0, #0x9, [W15]
006458  3A0002     BRA NZ, 0x645E
00645A  B3C010     MOV.B #0x1, W0
00645C  370001     BRA 0x6460
00645E  EB4000     CLR.B W0
006460  784F00     MOV.B W0, [W14]
374:               
375:                   return (blank);
006462  78401E     MOV.B [W14], W0
376:               }
006464  FA8000     ULNK
006466  060000     RETURN
377:               
378:               
379:               /*
380:               *********************************************************************************************************
381:               *                                           ASCII_IsSpace()
382:               *
383:               * Description : Determine whether a character is a white-space character.
384:               *
385:               * Argument(s) : c           Character to examine.
386:               *
387:               * Return(s)   : DEF_YES, if character is     a white-space character.
388:               *
389:               *               DEF_NO,     if character is NOT a white-space character.
390:               *
391:               * Caller(s)   : Application.
392:               *
393:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
394:               *                       for the standard white-space characters".
395:               *
396:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
397:               *                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
398:               *                       horizontal tab ('\t'), and vertical tab ('\v')".
399:               *********************************************************************************************************
400:               */
401:               
402:               CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
403:               {
006468  FA0004     LNK #0x4
00646A  984720     MOV.B W0, [W14+2]
404:                   CPU_BOOLEAN  space;
405:               
406:               
407:                   space = ASCII_IS_SPACE(c);
00646C  9040AE     MOV.B [W14+2], W1
00646E  B3C200     MOV.B #0x20, W0
006470  50CF80     SUB.B W1, W0, [W15]
006472  32000F     BRA Z, 0x6492
006474  90402E     MOV.B [W14+2], W0
006476  504FED     SUB.B W0, #0xD, [W15]
006478  32000C     BRA Z, 0x6492
00647A  90402E     MOV.B [W14+2], W0
00647C  504FEA     SUB.B W0, #0xA, [W15]
00647E  320009     BRA Z, 0x6492
006480  90402E     MOV.B [W14+2], W0
006482  504FEC     SUB.B W0, #0xC, [W15]
006484  320006     BRA Z, 0x6492
006486  90402E     MOV.B [W14+2], W0
006488  504FE9     SUB.B W0, #0x9, [W15]
00648A  320003     BRA Z, 0x6492
00648C  90402E     MOV.B [W14+2], W0
00648E  504FEB     SUB.B W0, #0xB, [W15]
006490  3A0002     BRA NZ, 0x6496
006492  B3C010     MOV.B #0x1, W0
006494  370001     BRA 0x6498
006496  EB4000     CLR.B W0
006498  784F00     MOV.B W0, [W14]
408:               
409:                   return (space);
00649A  78401E     MOV.B [W14], W0
410:               }
00649C  FA8000     ULNK
00649E  060000     RETURN
411:               
412:               
413:               /*
414:               *********************************************************************************************************
415:               *                                           ASCII_IsPrint()
416:               *
417:               * Description : Determine whether a character is a printing character.
418:               *
419:               * Argument(s) : c           Character to examine.
420:               *
421:               * Return(s)   : DEF_YES, if character is     a printing character.
422:               *
423:               *               DEF_NO,     if character is NOT a printing character.
424:               *
425:               * Caller(s)   : Application.
426:               *
427:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
428:               *                       printing character including space (' ')".
429:               *
430:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
431:               *                       ASCII character set, the printing characters are those whose values lie from
432:               *                       0x20 (space) through 0x7E (tilde)".
433:               *********************************************************************************************************
434:               */
435:               
436:               CPU_BOOLEAN  ASCII_IsPrint (CPU_CHAR  c)
437:               {
0064A0  FA0004     LNK #0x4
0064A2  984720     MOV.B W0, [W14+2]
438:                   CPU_BOOLEAN  print;
439:               
440:               
441:                   print = ASCII_IS_PRINT(c);
0064A4  90402E     MOV.B [W14+2], W0
0064A6  504FFF     SUB.B W0, #0x1F, [W15]
0064A8  360006     BRA LEU, 0x64B6
0064AA  9040AE     MOV.B [W14+2], W1
0064AC  B3C7E0     MOV.B #0x7E, W0
0064AE  50CF80     SUB.B W1, W0, [W15]
0064B0  3E0002     BRA GTU, 0x64B6
0064B2  B3C010     MOV.B #0x1, W0
0064B4  370001     BRA 0x64B8
0064B6  EB4000     CLR.B W0
0064B8  784F00     MOV.B W0, [W14]
442:               
443:                   return (print);
0064BA  78401E     MOV.B [W14], W0
444:               }
0064BC  FA8000     ULNK
0064BE  060000     RETURN
445:               
446:               
447:               /*
448:               *********************************************************************************************************
449:               *                                           ASCII_IsGraph()
450:               *
451:               * Description : Determine whether a character is any printing character except a space character.
452:               *
453:               * Argument(s) : c           Character to examine.
454:               *
455:               * Return(s)   : DEF_YES, if character is     a graphic character.
456:               *
457:               *               DEF_NO,     if character is NOT a graphic character.
458:               *
459:               * Caller(s)   : Application.
460:               *
461:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
462:               *                       printing character except space (' ')".
463:               *
464:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
465:               *                       ASCII character set, the printing characters are those whose values lie from
466:               *                       0x20 (space) through 0x7E (tilde)".
467:               *********************************************************************************************************
468:               */
469:               
470:               CPU_BOOLEAN  ASCII_IsGraph (CPU_CHAR  c)
471:               {
0064C0  FA0004     LNK #0x4
0064C2  984720     MOV.B W0, [W14+2]
472:                   CPU_BOOLEAN  graph;
473:               
474:               
475:                   graph = ASCII_IS_GRAPH(c);
0064C4  9040AE     MOV.B [W14+2], W1
0064C6  B3C200     MOV.B #0x20, W0
0064C8  50CF80     SUB.B W1, W0, [W15]
0064CA  360006     BRA LEU, 0x64D8
0064CC  9040AE     MOV.B [W14+2], W1
0064CE  B3C7E0     MOV.B #0x7E, W0
0064D0  50CF80     SUB.B W1, W0, [W15]
0064D2  3E0002     BRA GTU, 0x64D8
0064D4  B3C010     MOV.B #0x1, W0
0064D6  370001     BRA 0x64DA
0064D8  EB4000     CLR.B W0
0064DA  784F00     MOV.B W0, [W14]
476:               
477:                   return (graph);
0064DC  78401E     MOV.B [W14], W0
478:               }
0064DE  FA8000     ULNK
0064E0  060000     RETURN
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           ASCII_IsPunct()
484:               *
485:               * Description : Determine whether a character is a punctuation character.
486:               *
487:               * Argument(s) : c           Character to examine.
488:               *
489:               * Return(s)   : DEF_YES, if character is     a punctuation character.
490:               *
491:               *               DEF_NO,     if character is NOT a punctuation character.
492:               *
493:               * Caller(s)   : Application.
494:               *
495:               * Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
496:               *                   printing character for which neither isspace() nor isalnum() is true".
497:               *********************************************************************************************************
498:               */
499:               
500:               CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
501:               {
0064E2  FA0004     LNK #0x4
0064E4  984720     MOV.B W0, [W14+2]
502:                   CPU_BOOLEAN  punct;
503:               
504:               
505:                   punct = ASCII_IS_PUNCT(c);
0064E6  90402E     MOV.B [W14+2], W0
0064E8  504FFF     SUB.B W0, #0x1F, [W15]
0064EA  360031     BRA LEU, 0x654E
0064EC  9040AE     MOV.B [W14+2], W1
0064EE  B3C7E0     MOV.B #0x7E, W0
0064F0  50CF80     SUB.B W1, W0, [W15]
0064F2  3E002D     BRA GTU, 0x654E
0064F4  9040AE     MOV.B [W14+2], W1
0064F6  B3C200     MOV.B #0x20, W0
0064F8  50CF80     SUB.B W1, W0, [W15]
0064FA  320029     BRA Z, 0x654E
0064FC  90402E     MOV.B [W14+2], W0
0064FE  504FED     SUB.B W0, #0xD, [W15]
006500  320026     BRA Z, 0x654E
006502  90402E     MOV.B [W14+2], W0
006504  504FEA     SUB.B W0, #0xA, [W15]
006506  320023     BRA Z, 0x654E
006508  90402E     MOV.B [W14+2], W0
00650A  504FEC     SUB.B W0, #0xC, [W15]
00650C  320020     BRA Z, 0x654E
00650E  90402E     MOV.B [W14+2], W0
006510  504FE9     SUB.B W0, #0x9, [W15]
006512  32001D     BRA Z, 0x654E
006514  90402E     MOV.B [W14+2], W0
006516  504FEB     SUB.B W0, #0xB, [W15]
006518  32001A     BRA Z, 0x654E
00651A  9040AE     MOV.B [W14+2], W1
00651C  B3C400     MOV.B #0x40, W0
00651E  50CF80     SUB.B W1, W0, [W15]
006520  360004     BRA LEU, 0x652A
006522  9040AE     MOV.B [W14+2], W1
006524  B3C5A0     MOV.B #0x5A, W0
006526  50CF80     SUB.B W1, W0, [W15]
006528  360012     BRA LEU, 0x654E
00652A  9040AE     MOV.B [W14+2], W1
00652C  B3C600     MOV.B #0x60, W0
00652E  50CF80     SUB.B W1, W0, [W15]
006530  360004     BRA LEU, 0x653A
006532  9040AE     MOV.B [W14+2], W1
006534  B3C7A0     MOV.B #0x7A, W0
006536  50CF80     SUB.B W1, W0, [W15]
006538  36000A     BRA LEU, 0x654E
00653A  9040AE     MOV.B [W14+2], W1
00653C  B3C2F0     MOV.B #0x2F, W0
00653E  50CF80     SUB.B W1, W0, [W15]
006540  360004     BRA LEU, 0x654A
006542  9040AE     MOV.B [W14+2], W1
006544  B3C390     MOV.B #0x39, W0
006546  50CF80     SUB.B W1, W0, [W15]
006548  360002     BRA LEU, 0x654E
00654A  B3C010     MOV.B #0x1, W0
00654C  370001     BRA 0x6550
00654E  EB4000     CLR.B W0
006550  784F00     MOV.B W0, [W14]
506:               
507:                   return (punct);
006552  78401E     MOV.B [W14], W0
508:               }
006554  FA8000     ULNK
006556  060000     RETURN
509:               
510:               
511:               /*
512:               *********************************************************************************************************
513:               *                                           ASCII_IsCtrl()
514:               *
515:               * Description : Determine whether a character is a control character.
516:               *
517:               * Argument(s) : c           Character to examine.
518:               *
519:               * Return(s)   : DEF_YES, if character is     a control character.
520:               *
521:               *               DEF_NO,     if character is NOT a control character.
522:               *
523:               * Caller(s)   : Application.
524:               *
525:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
526:               *                       control character".
527:               *
528:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
529:               *                       ASCII character set, ... the control characters are those whose values lie from
530:               *                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
531:               *********************************************************************************************************
532:               */
533:               
534:               CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
535:               {
006558  FA0004     LNK #0x4
00655A  984720     MOV.B W0, [W14+2]
536:                   CPU_BOOLEAN  ctrl;
537:               
538:               
539:                   ctrl = ASCII_IS_CTRL(c);
00655C  90402E     MOV.B [W14+2], W0
00655E  E00400     CP0.B W0
006560  350003     BRA LT, 0x6568
006562  90402E     MOV.B [W14+2], W0
006564  504FFF     SUB.B W0, #0x1F, [W15]
006566  360004     BRA LEU, 0x6570
006568  9040AE     MOV.B [W14+2], W1
00656A  B3C7F0     MOV.B #0x7F, W0
00656C  50CF80     SUB.B W1, W0, [W15]
00656E  3A0002     BRA NZ, 0x6574
006570  B3C010     MOV.B #0x1, W0
006572  370001     BRA 0x6576
006574  EB4000     CLR.B W0
006576  784F00     MOV.B W0, [W14]
540:               
541:                   return (ctrl);
006578  78401E     MOV.B [W14], W0
542:               }
00657A  FA8000     ULNK
00657C  060000     RETURN
543:               
544:               
545:               /*
546:               *********************************************************************************************************
547:               *                                           ASCII_ToLower()
548:               *
549:               * Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
550:               *
551:               * Argument(s) : c           Character to convert.
552:               *
553:               * Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
554:               *
555:               *               Character 'c',               otherwise                                  (see Note #1b2).
556:               *
557:               * Caller(s)   : Application.
558:               *
559:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
560:               *                       uppercase letter to a corresponding lowercase letter".
561:               *
562:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
563:               *
564:               *                       (1) (A) "if the argument is a character for which isupper() is true and there are
565:               *                                one or more corresponding characters ... for which islower() is true," ...
566:               *                           (B) "tolower() ... returns one of the corresponding characters;" ...
567:               *
568:               *                       (2) "otherwise, the argument is returned unchanged."
569:               *********************************************************************************************************
570:               */
571:               
572:               CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
573:               {
00657E  FA0004     LNK #0x4
006580  984720     MOV.B W0, [W14+2]
574:                   CPU_CHAR  lower;
575:               
576:               
577:                   lower = ASCII_TO_LOWER(c);
006582  9040AE     MOV.B [W14+2], W1
006584  B3C400     MOV.B #0x40, W0
006586  50CF80     SUB.B W1, W0, [W15]
006588  360007     BRA LEU, 0x6598
00658A  9040AE     MOV.B [W14+2], W1
00658C  B3C5A0     MOV.B #0x5A, W0
00658E  50CF80     SUB.B W1, W0, [W15]
006590  3E0003     BRA GTU, 0x6598
006592  90402E     MOV.B [W14+2], W0
006594  B04200     ADD.B #0x20, W0
006596  370001     BRA 0x659A
006598  90402E     MOV.B [W14+2], W0
00659A  784F00     MOV.B W0, [W14]
578:               
579:                   return (lower);
00659C  78401E     MOV.B [W14], W0
580:               }
00659E  FA8000     ULNK
0065A0  060000     RETURN
581:               
582:               
583:               /*
584:               *********************************************************************************************************
585:               *                                           ASCII_ToUpper()
586:               *
587:               * Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
588:               *
589:               * Argument(s) : c           Character to convert.
590:               *
591:               * Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
592:               *
593:               *               Character 'c',               otherwise                                 (see Note #1b2).
594:               *
595:               * Caller(s)   : Application.
596:               *
597:               * Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
598:               *                       lowercase letter to a corresponding uppercase letter".
599:               *
600:               *                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
601:               *
602:               *                       (1) (A) "if the argument is a character for which islower() is true and there are
603:               *                                one or more corresponding characters ... for which isupper() is true," ...
604:               *                           (B) "toupper() ... returns one of the corresponding characters;" ...
605:               *
606:               *                       (2) "otherwise, the argument is returned unchanged."
607:               *********************************************************************************************************
608:               */
609:               
610:               CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
611:               {
0065A2  FA0004     LNK #0x4
0065A4  984720     MOV.B W0, [W14+2]
612:                   CPU_CHAR  upper;
613:               
614:               
615:                   upper = ASCII_TO_UPPER(c);
0065A6  9040AE     MOV.B [W14+2], W1
0065A8  B3C600     MOV.B #0x60, W0
0065AA  50CF80     SUB.B W1, W0, [W15]
0065AC  360008     BRA LEU, 0x65BE
0065AE  9040AE     MOV.B [W14+2], W1
0065B0  B3C7A0     MOV.B #0x7A, W0
0065B2  50CF80     SUB.B W1, W0, [W15]
0065B4  3E0004     BRA GTU, 0x65BE
0065B6  9040AE     MOV.B [W14+2], W1
0065B8  B3CE00     MOV.B #0xE0, W0
0065BA  40C000     ADD.B W1, W0, W0
0065BC  370001     BRA 0x65C0
0065BE  90402E     MOV.B [W14+2], W0
0065C0  784F00     MOV.B W0, [W14]
616:               
617:                   return (upper);
0065C2  78401E     MOV.B [W14], W0
618:               }
0065C4  FA8000     ULNK
0065C6  060000     RETURN
619:               
620:               
621:               /*
622:               *********************************************************************************************************
623:               *                                             ASCII_Cmp()
624:               *
625:               * Description : Determine if two characters are identical (case-insensitive).
626:               *
627:               * Argument(s) : c1          First  character.
628:               *
629:               *               c2          Second character.
630:               *
631:               * Return(s)   : DEF_YES, if the characters are     identical.
632:               *
633:               *               DEF_NO,  if the characters are NOT identical.
634:               *
635:               * Caller(s)   : Application.
636:               *
637:               * Note(s)     : none.
638:               *********************************************************************************************************
639:               */
640:               
641:               CPU_BOOLEAN  ASCII_Cmp (CPU_CHAR  c1,
642:                                       CPU_CHAR  c2)
643:               {
0065C8  FA0006     LNK #0x6
0065CA  984740     MOV.B W0, [W14+4]
0065CC  984751     MOV.B W1, [W14+5]
644:                   CPU_CHAR     c1_upper;
645:                   CPU_CHAR     c2_upper;
646:                   CPU_BOOLEAN  cmp;
647:               
648:               
649:                   c1_upper =  ASCII_ToUpper(c1);
0065CE  90404E     MOV.B [W14+4], W0
0065D0  07FFE8     RCALL ASCII_ToUpper
0065D2  784F00     MOV.B W0, [W14]
650:                   c2_upper =  ASCII_ToUpper(c2);
0065D4  90405E     MOV.B [W14+5], W0
0065D6  07FFE5     RCALL ASCII_ToUpper
0065D8  984710     MOV.B W0, [W14+1]
651:                   cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);
0065DA  90401E     MOV.B [W14+1], W0
0065DC  78409E     MOV.B [W14], W1
0065DE  50CF80     SUB.B W1, W0, [W15]
0065E0  3A0002     BRA NZ, 0x65E6
0065E2  B3C010     MOV.B #0x1, W0
0065E4  370001     BRA 0x65E8
0065E6  EB4000     CLR.B W0
0065E8  984720     MOV.B W0, [W14+2]
652:               
653:                   return (cmp);
0065EA  90402E     MOV.B [W14+2], W0
654:               }
0065EC  FA8000     ULNK
655:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/uC-CPU/cpu_core.c  -------------------------------
1:                 /*
2:                 *********************************************************************************************************
3:                 *                                                uC/CPU
4:                 *                                    CPU CONFIGURATION & PORT LAYER
5:                 *
6:                 *                          (c) Copyright 2004-2013; Micrium, Inc.; Weston, FL
7:                 *
8:                 *               All rights reserved.  Protected by international copyright laws.
9:                 *
10:                *               uC/CPU is provided in source form to registered licensees ONLY.  It is
11:                *               illegal to distribute this source code to any third party unless you receive
12:                *               written permission by an authorized Micrium representative.  Knowledge of
13:                *               the source code may NOT be used to develop a similar product.
14:                *
15:                *               Please help us continue to provide the Embedded community with the finest
16:                *               software available.  Your honesty is greatly appreciated.
17:                *
18:                *               You can find our product's user manual, API reference, release notes and
19:                *               more information at https://doc.micrium.com.
20:                *               You can contact us at www.micrium.com.
21:                *********************************************************************************************************
22:                */
23:                
24:                /*
25:                *********************************************************************************************************
26:                *
27:                *                                           CORE CPU MODULE
28:                *
29:                * Filename      : cpu_core.c
30:                * Version       : V1.30.01
31:                * Programmer(s) : SR
32:                *                 ITJ
33:                *********************************************************************************************************
34:                */
35:                
36:                
37:                /*
38:                *********************************************************************************************************
39:                *                                            INCLUDE FILES
40:                *********************************************************************************************************
41:                */
42:                
43:                #define    MICRIUM_SOURCE
44:                #define    CPU_CORE_MODULE
45:                #include  "cpu_core.h"
46:                
47:                #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
48:                #include  "cpu_cache.h"
49:                #endif
50:                
51:                
52:                /*
53:                *********************************************************************************************************
54:                *                                            LOCAL DEFINES
55:                *********************************************************************************************************
56:                */
57:                
58:                
59:                /*
60:                *********************************************************************************************************
61:                *                                           LOCAL CONSTANTS
62:                *********************************************************************************************************
63:                */
64:                
65:                
66:                /*
67:                *********************************************************************************************************
68:                *                                          LOCAL DATA TYPES
69:                *********************************************************************************************************
70:                */
71:                
72:                
73:                /*
74:                *********************************************************************************************************
75:                *                                            LOCAL TABLES
76:                *********************************************************************************************************
77:                */
78:                
79:                /*
80:                *********************************************************************************************************
81:                *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
82:                *
83:                * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
84:                *
85:                *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
86:                *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
87:                *                          1    x    x    x    x    x    x    x            0
88:                *                          0    1    x    x    x    x    x    x            1
89:                *                          0    0    1    x    x    x    x    x            2
90:                *                          0    0    0    1    x    x    x    x            3
91:                *                          0    0    0    0    1    x    x    x            4
92:                *                          0    0    0    0    0    1    x    x            5
93:                *                          0    0    0    0    0    0    1    x            6
94:                *                          0    0    0    0    0    0    0    1            7
95:                *                          0    0    0    0    0    0    0    0            8
96:                *********************************************************************************************************
97:                */
98:                
99:                #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
100:                     (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))
101:               static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
102:               /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
103:                   8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
104:                   3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
105:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
106:                   2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
107:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
108:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
109:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
110:                   1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
111:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
112:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
113:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
114:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
115:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
116:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
117:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
118:                   0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
119:               };
120:               #endif
121:               
122:               
123:               /*
124:               *********************************************************************************************************
125:               *                                       LOCAL GLOBAL VARIABLES
126:               *********************************************************************************************************
127:               */
128:               
129:               CPU_INT32U  const  CPU_EndiannessTest = 0x12345678LU;               /* Variable to test CPU endianness.                 */
130:               
131:               
132:               /*
133:               *********************************************************************************************************
134:               *                                      LOCAL FUNCTION PROTOTYPES
135:               *********************************************************************************************************
136:               */
137:               
138:               #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
139:               static  void        CPU_NameInit         (void);
140:               #endif
141:               
142:               
143:                                                                                   /* ----------------- CPU TS FNCTS ----------------- */
144:               #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
145:                      (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
146:               static  void        CPU_TS_Init          (void);
147:               #endif
148:               
149:               
150:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
151:               static  void        CPU_IntDisMeasInit   (void);
152:               
153:               static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
154:               #endif
155:               
156:               
157:               /*
158:               *********************************************************************************************************
159:               *                                     LOCAL CONFIGURATION ERRORS
160:               *********************************************************************************************************
161:               */
162:               
163:               
164:               /*
165:               *********************************************************************************************************
166:               *                                             CPU_Init()
167:               *
168:               * Description : (1) Initialize CPU module :
169:               *
170:               *                   (a) Initialize CPU timestamps
171:               *                   (b) Initialize CPU interrupts disabled time measurements
172:               *                   (c) Initialize CPU host name
173:               *
174:               *
175:               * Argument(s) : none.
176:               *
177:               * Return(s)   : none.
178:               *
179:               * Caller(s)   : Your Product's Application.
180:               *
181:               *               This function is a CPU initialization function & MAY be called by application/
182:               *               initialization function(s).
183:               *
184:               * Note(s)     : (2) CPU_Init() MUST be called ... :
185:               *
186:               *                   (a) ONLY ONCE from a product's application; ...
187:               *                   (b) BEFORE product's application calls any core CPU module function(s)
188:               *
189:               *               (3) The following initialization functions MUST be sequenced as follows :
190:               *
191:               *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
192:               *
193:               *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
194:               *                                                   & other CPU interrupts disabled time measurement functions
195:               *********************************************************************************************************
196:               */
197:               
198:               void  CPU_Init (void)
199:               {
005654  FA0000     LNK #0x0
200:                                                                               /* --------------------- INIT TS ---------------------- */
201:               #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
202:                    (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
203:                   CPU_TS_Init();                                              /* See Note #3a.                                        */
204:               #endif
205:                                                                               /* -------------- INIT INT DIS TIME MEAS -------------- */
206:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
207:                   CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
208:               #endif
209:               
210:                                                                               /* ------------------ INIT CPU NAME ------------------- */
211:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
212:                    CPU_NameInit();
213:               #endif
214:               
215:               #if (CPU_CFG_CACHE_MGMT_EN == DEF_ENABLED)
216:                    CPU_Cache_Init();
217:               #endif
218:               }
005656  FA8000     ULNK
005658  060000     RETURN
219:               
220:               
221:               /*
222:               *********************************************************************************************************
223:               *                                         CPU_SW_Exception()
224:               *
225:               * Description : Trap unrecoverable software exception.
226:               *
227:               * Argument(s) : none.
228:               *
229:               * Return(s)   : none.
230:               *
231:               * Caller(s)   : various.
232:               *
233:               * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
234:               *                   -processed/-threaded or single-threaded -- when the current code execution cannot 
235:               *                   gracefully recover or report a fault or exception condition.
236:               *
237:               *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
238:               *********************************************************************************************************
239:               */
240:               
241:               void  CPU_SW_Exception (void)
242:               {
00565A  FA0000     LNK #0x0
243:                   while (DEF_ON) {
244:                       ;
245:                   }
00565C  37FFFF     BRA 0x565C
246:               }
247:               
248:               
249:               /*
250:               *********************************************************************************************************
251:               *                                            CPU_NameClr()
252:               *
253:               * Description : Clear CPU Name.
254:               *
255:               * Argument(s) : none.
256:               *
257:               * Return(s)   : none.
258:               *
259:               * Caller(s)   : CPU_NameInit(),
260:               *               Application.
261:               *
262:               *               This function is a CPU module application programming interface (API) function & MAY be 
263:               *               called by application function(s).
264:               *
265:               * Note(s)     : none.
266:               *********************************************************************************************************
267:               */
268:               
269:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
270:               void  CPU_NameClr (void)
271:               {
272:                   CPU_SR_ALLOC();
273:               
274:               
275:                   CPU_CRITICAL_ENTER();
276:                   Mem_Clr((void     *)&CPU_Name[0],
277:                           (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
278:                   CPU_CRITICAL_EXIT();
279:               }
280:               #endif
281:               
282:               
283:               /*
284:               *********************************************************************************************************
285:               *                                            CPU_NameGet()
286:               *
287:               * Description : Get CPU host name.
288:               *
289:               * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
290:               *                               name ASCII string from this function (see Note #1).
291:               *
292:               *               p_err       Pointer to variable that will receive the return error code from this function :
293:               *
294:               *                               CPU_ERR_NONE                    CPU host name successfully returned.
295:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
296:               *
297:               * Return(s)   : none.
298:               *
299:               * Caller(s)   : Application.
300:               *
301:               *               This function is a CPU module application programming interface (API) function & MAY 
302:               *               be called by application function(s).
303:               *
304:               * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
305:               *                   ASCII string :
306:               *
307:               *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
308:               *                           size including the terminating NULL character;
309:               *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
310:               *********************************************************************************************************
311:               */
312:               
313:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
314:               void  CPU_NameGet (CPU_CHAR  *p_name,
315:                                  CPU_ERR   *p_err)
316:               {
317:                   CPU_SR_ALLOC();
318:               
319:               
320:                   if (p_err == (CPU_ERR *)0) {
321:                       CPU_SW_EXCEPTION(;);
322:                   }
323:               
324:                   if (p_name == (CPU_CHAR *)0) {
325:                      *p_err = CPU_ERR_NULL_PTR;
326:                       return;
327:                   }
328:               
329:                   CPU_CRITICAL_ENTER();
330:                  (void)Str_Copy_N(p_name,
331:                                  &CPU_Name[0],
332:                                   CPU_CFG_NAME_SIZE);
333:                   CPU_CRITICAL_EXIT();
334:               
335:                  *p_err = CPU_ERR_NONE;
336:               }
337:               #endif
338:               
339:               
340:               /*
341:               *********************************************************************************************************
342:               *                                            CPU_NameSet()
343:               *
344:               * Description : Set CPU host name.
345:               *
346:               * Argument(s) : p_name      Pointer to CPU host name to set.
347:               *
348:               *               p_err       Pointer to variable that will receive the return error code from this function :
349:               *
350:               *                               CPU_ERR_NONE                    CPU host name successfully set.
351:               *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
352:               *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
353:               *
354:               * Return(s)   : none.
355:               *
356:               * Caller(s)   : Application.
357:               *
358:               *               This function is a CPU module application programming interface (API) function & MAY be 
359:               *               called by application function(s).
360:               *
361:               * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
362:               *                    than or equal to CPU_CFG_NAME_SIZE.
363:               *********************************************************************************************************
364:               */
365:               
366:               #if (CPU_CFG_NAME_EN == DEF_ENABLED)
367:               void  CPU_NameSet (const  CPU_CHAR  *p_name,
368:                                         CPU_ERR   *p_err)
369:               {
370:                   CPU_SIZE_T  len;
371:                   CPU_SR_ALLOC();
372:               
373:               
374:                   if (p_err == (CPU_ERR *)0) {
375:                       CPU_SW_EXCEPTION(;);
376:                   }
377:               
378:                   if (p_name == (const CPU_CHAR *)0) {
379:                      *p_err = CPU_ERR_NULL_PTR;
380:                       return;
381:                   }
382:               
383:                   len = Str_Len_N(p_name,
384:                                   CPU_CFG_NAME_SIZE);
385:                   if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
386:                       CPU_CRITICAL_ENTER();
387:                      (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
388:                                        p_name,
389:                                        CPU_CFG_NAME_SIZE);
390:                       CPU_CRITICAL_EXIT();
391:                      *p_err = CPU_ERR_NONE;
392:               
393:                   } else {
394:                      *p_err = CPU_ERR_NAME_SIZE;
395:                   }
396:               }
397:               #endif
398:               
399:               
400:               /*
401:               *********************************************************************************************************
402:               *                                           CPU_TS_Get32()
403:               *
404:               * Description : Get current 32-bit CPU timestamp.
405:               *
406:               * Argument(s) : none.
407:               *
408:               * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
409:               *
410:               * Caller(s)   : Application.
411:               *
412:               *               This function is a CPU module application programming interface (API) function & MAY 
413:               *               be called by application function(s).
414:               *
415:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
416:               *                   either of the following equations :
417:               *
418:               *                       (a) Time measured  =  Number timer counts  *  Timer period
419:               *
420:               *                               where
421:               *
422:               *                                   Number timer counts     Number of timer counts measured
423:               *                                   Timer period            Timer's period in some units of
424:               *                                                               (fractional) seconds
425:               *                                   Time measured           Amount of time measured, in same
426:               *                                                               units of (fractional) seconds
427:               *                                                               as the Timer period
428:               *
429:               *                                              Number timer counts
430:               *                       (b) Time measured  =  ---------------------
431:               *                                                Timer frequency
432:               *
433:               *                               where
434:               *
435:               *                                   Number timer counts     Number of timer counts measured
436:               *                                   Timer frequency         Timer's frequency in some units
437:               *                                                               of counts per second
438:               *                                   Time measured           Amount of time measured, in seconds
439:               *
440:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
441:               *
442:               *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
443:               *                   its precision is extended via periodic updates by accumulating the deltas of the
444:               *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
445:               *
446:               *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
447:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
448:               *                   with critical sections.
449:               *********************************************************************************************************
450:               */
451:               
452:               #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
453:               CPU_TS32  CPU_TS_Get32 (void)
454:               {
455:                   CPU_TS32    ts;
456:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
457:                   CPU_TS_TMR  tmr_cur;
458:                   CPU_TS_TMR  tmr_delta;
459:                   CPU_SR_ALLOC();
460:               #endif
461:               
462:               
463:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
464:                   ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
465:               
466:               #else
467:                   CPU_INT_DIS();
468:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
469:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
470:                   CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
471:                   CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
472:                   ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
473:                   CPU_INT_EN();
474:               #endif
475:               
476:                   return (ts);
477:               }
478:               #endif
479:               
480:               
481:               /*
482:               *********************************************************************************************************
483:               *                                           CPU_TS_Get64()
484:               *
485:               * Description : Get current 64-bit CPU timestamp.
486:               *
487:               * Argument(s) : none.
488:               *
489:               * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
490:               *
491:               * Caller(s)   : Application.
492:               *
493:               *               This function is a CPU module application programming interface (API) function & MAY 
494:               *               be called by application function(s).
495:               *
496:               * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
497:               *                   either of the following equations :
498:               *
499:               *                       (a) Time measured  =  Number timer counts  *  Timer period
500:               *
501:               *                               where
502:               *
503:               *                                   Number timer counts     Number of timer counts measured
504:               *                                   Timer period            Timer's period in some units of
505:               *                                                               (fractional) seconds
506:               *                                   Time measured           Amount of time measured, in same
507:               *                                                               units of (fractional) seconds
508:               *                                                               as the Timer period
509:               *
510:               *                                              Number timer counts
511:               *                       (b) Time measured  =  ---------------------
512:               *                                                Timer frequency
513:               *
514:               *                               where
515:               *
516:               *                                   Number timer counts     Number of timer counts measured
517:               *                                   Timer frequency         Timer's frequency in some units
518:               *                                                               of counts per second
519:               *                                   Time measured           Amount of time measured, in seconds
520:               *
521:               *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
522:               *
523:               *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
524:               *                   its precision is extended via periodic updates by accumulating the deltas of the
525:               *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
526:               *
527:               *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
528:               *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
529:               *                   with critical sections.
530:               *********************************************************************************************************
531:               */
532:               
533:               #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
534:               CPU_TS64  CPU_TS_Get64 (void)
535:               {
536:                   CPU_TS64    ts;
537:               #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
538:                   CPU_TS_TMR  tmr_cur;
539:                   CPU_TS_TMR  tmr_delta;
540:                   CPU_SR_ALLOC();
541:               #endif
542:               
543:               
544:               #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
545:                   ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
546:               
547:               #else
548:                   CPU_INT_DIS();
549:                   tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
550:                   tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
551:                   CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
552:                   CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
553:                   ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
554:                   CPU_INT_EN();
555:               #endif
556:               
557:                   return (ts);
558:               }
559:               #endif
560:               
561:               
562:               /*
563:               *********************************************************************************************************
564:               *                                           CPU_TS_Update()
565:               *
566:               * Description : Update current CPU timestamp(s).
567:               *
568:               * Argument(s) : none.
569:               *
570:               * Return(s)   : none.
571:               *
572:               * Caller(s)   : Application/BSP periodic time handler (see Note #1).
573:               *
574:               *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
575:               *               application/BSP function(s).
576:               *
577:               * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
578:               *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
579:               *
580:               *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
581:               *                       overflows; otherwise, CPU timestamp(s) will lose time.
582:               *
583:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
584:               *********************************************************************************************************
585:               */
586:               
587:               #if (CPU_CFG_TS_EN == DEF_ENABLED)
588:               void  CPU_TS_Update (void)
589:               {
590:               #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
591:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
592:                  (void)CPU_TS_Get32();
593:               #endif
594:               
595:               #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
596:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
597:                  (void)CPU_TS_Get64();
598:               #endif
599:               }
600:               #endif
601:               
602:               
603:               /*
604:               *********************************************************************************************************
605:               *                                         CPU_TS_TmrFreqGet()
606:               *
607:               * Description : Get CPU timestamp's timer frequency.
608:               *
609:               * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
610:               *
611:               *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
612:               *                                                                   returned.
613:               *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
614:               *                                                                   NOT yet configured.
615:               *
616:               * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
617:               *
618:               *               0,                                          otherwise.
619:               *
620:               * Caller(s)   : Application.
621:               *
622:               *               This function is a CPU module application programming interface (API) function & MAY be 
623:               *               called by application function(s).
624:               *
625:               * Note(s)     : none.
626:               *********************************************************************************************************
627:               */
628:               
629:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
630:               CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
631:               {
632:                   CPU_TS_TMR_FREQ  freq_hz;
633:               
634:               
635:                   if (p_err == (CPU_ERR *)0) {
636:                       CPU_SW_EXCEPTION(;);
637:                   }
638:               
639:                   freq_hz =  CPU_TS_TmrFreq_Hz;
640:                  *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
641:               
642:                   return (freq_hz);
643:               }
644:               #endif
645:               
646:               
647:               /*
648:               *********************************************************************************************************
649:               *                                         CPU_TS_TmrFreqSet()
650:               *
651:               * Description : Set CPU timestamp's timer frequency.
652:               *
653:               * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
654:               *
655:               * Return(s)   : none.
656:               *
657:               * Caller(s)   : CPU_TS_TmrInit(),
658:               *               Application/BSP initialization function(s).
659:               *
660:               *               This function is a CPU module BSP function & SHOULD be called only by appropriate
661:               *               application/BSP function(s) [see Note #1].
662:               *
663:               * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
664:               *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
665:               *                           application/BSP initialization functions.
666:               *
667:               *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
668:               *                           to convert CPU timestamps from timer counts into microseconds.
669:               *
670:               *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
671:               *
672:               *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
673:               *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
674:               *                       measure desired times.
675:               *
676:               *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
677:               *********************************************************************************************************
678:               */
679:               
680:               #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
681:               void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
682:               {
683:                   CPU_TS_TmrFreq_Hz = freq_hz;
684:               }
685:               #endif
686:               
687:               
688:               /*
689:               *********************************************************************************************************
690:               *                                     CPU_IntDisMeasMaxCurReset()
691:               *
692:               * Description : Reset current maximum interrupts disabled time.
693:               *
694:               * Argument(s) : none.
695:               *
696:               * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
697:               *
698:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
699:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
700:               *
701:               * Caller(s)   : Application.
702:               *
703:               *               This function is a CPU module application programming interface (API) function 
704:               *               & MAY be called by application function(s).
705:               *
706:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
707:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
708:               *********************************************************************************************************
709:               */
710:               
711:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
712:               CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
713:               {
714:                   CPU_TS_TMR  time_max_cnts;
715:                   CPU_SR_ALLOC();
716:               
717:               
718:                   time_max_cnts             = CPU_IntDisMeasMaxCurGet();
719:                   CPU_INT_DIS();
720:                   CPU_IntDisMeasMaxCur_cnts = 0u;
721:                   CPU_INT_EN();
722:               
723:                   return (time_max_cnts);
724:               }
725:               #endif
726:               
727:               
728:               /*
729:               *********************************************************************************************************
730:               *                                      CPU_IntDisMeasMaxCurGet()
731:               *
732:               * Description : Get current maximum interrupts disabled time.
733:               *
734:               * Argument(s) : none.
735:               *
736:               * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
737:               *
738:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
739:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
740:               *
741:               * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
742:               *               Application.
743:               *
744:               *               This function is a CPU module application programming interface (API) function 
745:               *               & MAY be called by application function(s).
746:               *
747:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
748:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
749:               *********************************************************************************************************
750:               */
751:               
752:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
753:               CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
754:               {
755:                   CPU_TS_TMR  time_tot_cnts;
756:                   CPU_TS_TMR  time_max_cnts;
757:                   CPU_SR_ALLOC();
758:               
759:               
760:                   CPU_INT_DIS();
761:                   time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
762:                   CPU_INT_EN();
763:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
764:               
765:                   return (time_max_cnts);
766:               }
767:               #endif
768:               
769:               
770:               /*
771:               *********************************************************************************************************
772:               *                                       CPU_IntDisMeasMaxGet()
773:               *
774:               * Description : Get (non-resetable) maximum interrupts disabled time.
775:               *
776:               * Argument(s) : none.
777:               *
778:               * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
779:               *
780:               *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
781:               *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
782:               *
783:               * Caller(s)   : CPU_IntDisMeasInit(),
784:               *               Application.
785:               *
786:               *               This function is a CPU module application programming interface (API) function 
787:               *               & MAY be called by application function(s).
788:               *
789:               * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
790:               *                   exclusively with interrupts disabled -- but NOT with critical sections.
791:               *********************************************************************************************************
792:               */
793:               
794:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
795:               CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
796:               {
797:                   CPU_TS_TMR  time_tot_cnts;
798:                   CPU_TS_TMR  time_max_cnts;
799:                   CPU_SR_ALLOC();
800:               
801:               
802:                   CPU_INT_DIS();
803:                   time_tot_cnts = CPU_IntDisMeasMax_cnts;
804:                   CPU_INT_EN();
805:                   time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
806:               
807:                   return (time_max_cnts);
808:               }
809:               #endif
810:               
811:               
812:               /*
813:               *********************************************************************************************************
814:               *                                        CPU_IntDisMeasStart()
815:               *
816:               * Description : Start interrupts disabled time measurement.
817:               *
818:               * Argument(s) : none.
819:               *
820:               * Return(s)   : none.
821:               *
822:               * Caller(s)   : CPU_CRITICAL_ENTER().
823:               *
824:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
825:               *               function(s).
826:               *
827:               * Note(s)     : none.
828:               *********************************************************************************************************
829:               */
830:               
831:               #ifdef  CPU_CFG_INT_DIS_MEAS_EN
832:               void  CPU_IntDisMeasStart (void)
833:               {
834:                   CPU_IntDisMeasCtr++;
835:                   if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
836:                       CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
837:                   }
838:                   CPU_IntDisNestCtr++;
839:               }
840:               #endif
841:               
842:               
843:               /*
844:               *********************************************************************************************************
845:               *                                        CPU_IntDisMeasStop()
846:               *
847:               * Description : Stop interrupts disabled time measurement.
848:               *
849:               * Argument(s) : none.
850:               *
851:               * Return(s)   : none.
852:               *
853:               * Caller(s)   : CPU_CRITICAL_EXIT().
854:               *
855:               *               This function is an INTERNAL CPU module function & MUST NOT be called by application
856:               *               function(s).
857:               *
858:               * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
859:               *                       during critical sections is calculated by the following equations :
860:               *
861:               *                       (1) When interrupts disabled time measurements are disabled :
862:               *
863:               *
864:               *                               |   CRITICAL  |                           |   CRITICAL  |
865:               *                               |<- SECTION ->|                           |<- SECTION ->|
866:               *                               |    ENTER    |                           |    EXIT     |
867:               *
868:               *                            Disable                                    Enable
869:               *                           Interrupts                                Interrupts
870:               *
871:               *                               ||           ||                           ||           ||
872:               *                               ||           ||                           ||           ||
873:               *                               ||       |   ||<------------------------->||       |   ||
874:               *                               ||       |<->||             |             ||<----->|   ||
875:               *                               ||       | | ||             |             ||   |   |   ||
876:               *                                        | |                |                  |   |
877:               *                                   interrupts            time                 interrupts
878:               *                                    disabled                 interrupts       |enabled
879:               *                                          |                   disabled        |
880:               *                                          |              (via application)    |
881:               *                                       time                                 time
882:               *                                           interrupts                           interrupts
883:               *                                         disabled ovrhd                        enabled ovrhd
884:               *
885:               *
886:               *                           (A) time            =  [ time            -  time           ]  -  time
887:               *                                   interrupts     [     interrupts         interrupts ]         total
888:               *                                    disabled      [      enabled            disabled  ]         ovrhd
889:               *                               (via application)
890:               *
891:               *
892:               *                           (B) time       =  time              +  time
893:               *                                   total         interrupts           interrupts
894:               *                                   ovrhd        enabled ovrhd       disabled ovrhd
895:               *
896:               *
897:               *                                   where
898:               *
899:               *                                           time                    time interrupts are disabled between
900:               *                                               interrupts              first critical section enter &
901:               *                                                disabled               last  critical section exit (i.e.
902:               *                                           (via application)           minus total overhead time)
903:               *
904:               *                                           time                    time when interrupts are disabled
905:               *                                               interrupts
906:               *                                                disabled
907:               *
908:               *                                           time                    time when interrupts are  enabled
909:               *                                               interrupts
910:               *                                                enabled
911:               *
912:               *
913:               *                                           time                    total overhead time to disable/enable
914:               *                                               total                   interrupts during critical section
915:               *                                               ovrhd                   enter & exit
916:               *
917:               *                                           time                    total overhead time to disable interrupts
918:               *                                               interrupts              during critical section enter
919:               *                                             disabled ovrhd
920:               *
921:               *                                           time                    total overhead time to enable  interrupts
922:               *                                               interrupts              during critical section exit
923:               *                                              enabled ovrhd
924:               *
925:               *
926:               *                       (2) When interrupts disabled time measurements are enabled :
927:               *
928:               *
929:               *        |                                    |                           |                                       |
930:               *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
931:               *        |                                    |                           |                                       |
932:               *
933:               *                   Time                                                 Time
934:               *     Disable    Measurement                                          Measurement                  Enable
935:               *    Interrupts     Start                                                Stop                    Interrupts
936:               *
937:               *        ||           |                      ||                           ||                         |           ||
938:               *        ||           |                      ||                           ||                         |           ||
939:               *        ||           |        |             ||<------------------------->||               |         |           ||
940:               *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
941:               *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
942:               *                 |            |      |                     |                      |       |                 |
943:               *            interrupts       get     |                   time                     |      get            interrupts
944:               *             disabled    start time  |                       interrupts           |   stop time          enabled
945:               *                            meas     |                        disabled            |     meas
946:               *                                   time                  (via application)      time
947:               *                                       start meas                                   stop meas
948:               *                                         ovrhd                                        ovrhd
949:               *
950:               *
951:               *                           (A) time            =  [ time       -  time      ]  -  time
952:               *                                   interrupts     [      stop         start ]         total meas
953:               *                                    disabled      [      meas         meas  ]           ovrhd
954:               *                               (via application)
955:               *
956:               *
957:               *                           (B) time            =  time            +  time
958:               *                                   total meas         start meas         stop meas
959:               *                                     ovrhd              ovrhd              ovrhd
960:               *
961:               *
962:               *                                   where
963:               *
964:               *                                           time                    time interrupts are disabled between first
965:               *                                               interrupts              critical section enter & last critical
966:               *                                                disabled               section exit (i.e. minus measurement
967:               *                                           (via application)           overhead time; however, this does NOT
968:               *                                                                       include any overhead time to disable
969:               *                                                                       or enable interrupts during critical
970:               *                                                                       section enter & exit)
971:               *
972:               *                                           time                    time of disable interrupts start time
973:               *                                               start                   measurement (in timer counts)
974:               *                                               meas
975:               *
976:               *                                           time                    time of disable interrupts stop  time
977:               *                                               stop                    measurement (in timer counts)
978:               *                                               meas
979:               *
980:               *
981:               *                                           time                    total overhead time to start/stop disabled
982:               *                                               total meas              interrupts time measurements (in timer
983:               *                                                 ovrhd                 counts)
984:               *
985:               *                                           time                    total overhead time after getting start
986:               *                                               start meas              time until end of start measurement
987:               *                                                 ovrhd                 function  (in timer counts)
988:               *
989:               *                                           time                    total overhead time from beginning of stop
990:               *                                               stop meas               measurement function until after getting
991:               *                                                 ovrhd                 stop time (in timer counts)
992:               *
993:               *
994:               *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times 
995:               *                               from stop times, CPU timestamp timer count values MUST be returned via 
996:               *                               word-size-configurable 'CPU_TS_TMR' data type.
997:               *
998:               *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
999:               *
1000:              *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
1001:              *                               values, timestamp timer count values MUST increase with each time count.
1002:              *
1003:              *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
1004:              *
1005:              *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
1006:              *                               subtraction of start times from stop times is performed.
1007:              *
1008:              *                           (B) The final calculations to subtract the interrupts disabled time measurement
1009:              *                               overhead is performed asynchronously in appropriate API functions.
1010:              *
1011:              *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
1012:              *********************************************************************************************************
1013:              */
1014:              
1015:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
1016:              void  CPU_IntDisMeasStop (void)
1017:              {
1018:                  CPU_TS_TMR  time_ints_disd_cnts;
1019:              
1020:              
1021:                  CPU_IntDisNestCtr--;
1022:                  if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
1023:                      CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
1024:                                                                                  /* ... calc ints dis'd tot  time (see Note #1b2A).  */
1025:                      time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
1026:                                                CPU_IntDisMeasStart_cnts;
1027:                                                                                  /* Calc max ints dis'd times.                       */
1028:                      if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
1029:                          CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
1030:                      }
1031:                      if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
1032:                          CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
1033:                      }
1034:                  }
1035:              }
1036:              #endif
1037:              
1038:              
1039:              /*
1040:              *********************************************************************************************************
1041:              *                                         CPU_CntLeadZeros()
1042:              *
1043:              * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
1044:              *
1045:              * Argument(s) : val         Data value to count leading zero bits.
1046:              *
1047:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
1048:              *
1049:              *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
1050:              *
1051:              * Caller(s)   : CPU_CntTrailZeros(),
1052:              *               Application.
1053:              *
1054:              *               This function is a CPU module application programming interface (API) function & MAY 
1055:              *               be called by application function(s).
1056:              *
1057:              * Note(s)     : (1) (a) Supports the following data value sizes :
1058:              *
1059:              *                       (1)  8-bits
1060:              *                       (2) 16-bits
1061:              *                       (3) 32-bits
1062:              *                       (4) 64-bits
1063:              *
1064:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1065:              *
1066:              *                   (b) (1) For  8-bit values :
1067:              *
1068:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1069:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1070:              *                                   1    x    x    x    x    x    x    x            0
1071:              *                                   0    1    x    x    x    x    x    x            1
1072:              *                                   0    0    1    x    x    x    x    x            2
1073:              *                                   0    0    0    1    x    x    x    x            3
1074:              *                                   0    0    0    0    1    x    x    x            4
1075:              *                                   0    0    0    0    0    1    x    x            5
1076:              *                                   0    0    0    0    0    0    1    x            6
1077:              *                                   0    0    0    0    0    0    0    1            7
1078:              *                                   0    0    0    0    0    0    0    0            8
1079:              *
1080:              *
1081:              *                       (2) For 16-bit values :
1082:              *
1083:              *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1084:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1085:              *                              1    x    x         x    x    x    x    x            0
1086:              *                              0    1    x         x    x    x    x    x            1
1087:              *                              0    0    1         x    x    x    x    x            2
1088:              *                              :    :    :         :    :    :    :    :            :
1089:              *                              :    :    :         :    :    :    :    :            :
1090:              *                              0    0    0         1    x    x    x    x           11
1091:              *                              0    0    0         0    1    x    x    x           12
1092:              *                              0    0    0         0    0    1    x    x           13
1093:              *                              0    0    0         0    0    0    1    x           14
1094:              *                              0    0    0         0    0    0    0    1           15
1095:              *                              0    0    0         0    0    0    0    0           16
1096:              *
1097:              *                       (3) For 32-bit values :
1098:              *
1099:              *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1100:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1101:              *                              1    x    x         x    x    x    x    x            0
1102:              *                              0    1    x         x    x    x    x    x            1
1103:              *                              0    0    1         x    x    x    x    x            2
1104:              *                              :    :    :         :    :    :    :    :            :
1105:              *                              :    :    :         :    :    :    :    :            :
1106:              *                              0    0    0         1    x    x    x    x           27
1107:              *                              0    0    0         0    1    x    x    x           28
1108:              *                              0    0    0         0    0    1    x    x           29
1109:              *                              0    0    0         0    0    0    1    x           30
1110:              *                              0    0    0         0    0    0    0    1           31
1111:              *                              0    0    0         0    0    0    0    0           32
1112:              *
1113:              *
1114:              *                       (4) For 64-bit values :
1115:              *
1116:              *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1117:              *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1118:              *                              1    x    x         x    x    x    x    x            0
1119:              *                              0    1    x         x    x    x    x    x            1
1120:              *                              0    0    1         x    x    x    x    x            2
1121:              *                              :    :    :         :    :    :    :    :            :
1122:              *                              :    :    :         :    :    :    :    :            :
1123:              *                              0    0    0         1    x    x    x    x           59
1124:              *                              0    0    0         0    1    x    x    x           60
1125:              *                              0    0    0         0    0    1    x    x           61
1126:              *                              0    0    0         0    0    0    1    x           62
1127:              *                              0    0    0         0    0    0    0    1           63
1128:              *                              0    0    0         0    0    0    0    0           64
1129:              *
1130:              *
1131:              *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1132:              *********************************************************************************************************
1133:              */
1134:              
1135:              #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT
1136:              CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
1137:              {
00565E  FA0004     LNK #0x4
005660  980710     MOV W0, [W14+2]
1138:                  CPU_DATA  nbr_lead_zeros;
1139:              
1140:              
1141:              #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
1142:                  nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
1143:              
1144:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
1145:                  nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
005662  90001E     MOV [W14+2], W0
005664  070011     RCALL CPU_CntLeadZeros16
005666  780F00     MOV W0, [W14]
1146:              
1147:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
1148:                  nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
1149:              
1150:              #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
1151:                  nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
1152:              
1153:              #else                                                           /* See Note #1a.                                        */
1154:                  nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
1155:              #endif
1156:              
1157:              
1158:                  return (nbr_lead_zeros);
005668  78001E     MOV [W14], W0
1159:              }
00566A  FA8000     ULNK
00566C  060000     RETURN
1160:              #endif
1161:              
1162:              
1163:              /*
1164:              *********************************************************************************************************
1165:              *                                        CPU_CntLeadZeros08()
1166:              *
1167:              * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
1168:              *
1169:              * Argument(s) : val         Data value to count leading zero bits.
1170:              *
1171:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1172:              *
1173:              * Caller(s)   : CPU_CntLeadZeros(),
1174:              *               CPU_CntTrailZeros08(),
1175:              *               Application.
1176:              *
1177:              *               This function is a CPU module application programming interface (API) function & MAY be 
1178:              *               called by application function(s).
1179:              *
1180:              * Note(s)     : (1) Supports  8-bit values :
1181:              *
1182:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
1183:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
1184:              *                                1    x    x    x    x    x    x    x            0
1185:              *                                0    1    x    x    x    x    x    x            1
1186:              *                                0    0    1    x    x    x    x    x            2
1187:              *                                0    0    0    1    x    x    x    x            3
1188:              *                                0    0    0    0    1    x    x    x            4
1189:              *                                0    0    0    0    0    1    x    x            5
1190:              *                                0    0    0    0    0    0    1    x            6
1191:              *                                0    0    0    0    0    0    0    1            7
1192:              *                                0    0    0    0    0    0    0    0            8
1193:              *
1194:              *
1195:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1196:              *********************************************************************************************************
1197:              */
1198:              
1199:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1200:              CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
1201:              {
00566E  FA0006     LNK #0x6
005670  984740     MOV.B W0, [W14+4]
1202:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1203:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1204:                  CPU_DATA  ix;
1205:              #endif
1206:                  CPU_DATA  nbr_lead_zeros;
1207:              
1208:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1209:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1210:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1211:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1212:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1213:              
1214:              
1215:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1216:                                                                                              /* Chk bits [07:00] :                   */
1217:                                                                                              /* .. Nbr lead zeros =               .. */
1218:                  ix              = (CPU_DATA)(val);                                          /* .. lookup tbl ix  = 'val' >>  0 bits */
005672  90404E     MOV.B [W14+4], W0
005674  FB8000     ZE W0, W0
005676  780F00     MOV W0, [W14]
1219:                  nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                      /* .. plus nbr msb lead zeros =  0 bits.*/
005678  29D0A0     MOV #0x9D0A, W0
00567A  40001E     ADD W0, [W14], W0
00567C  784010     MOV.B [W0], W0
00567E  FB8000     ZE W0, W0
005680  980710     MOV W0, [W14+2]
1220:              #endif
1221:              
1222:              
1223:                  return (nbr_lead_zeros);
005682  90001E     MOV [W14+2], W0
1224:              }
005684  FA8000     ULNK
005686  060000     RETURN
1225:              #endif
1226:              
1227:              
1228:              /*
1229:              *********************************************************************************************************
1230:              *                                        CPU_CntLeadZeros16()
1231:              *
1232:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
1233:              *
1234:              * Argument(s) : val         Data value to count leading zero bits.
1235:              *
1236:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1237:              *
1238:              * Caller(s)   : CPU_CntLeadZeros(),
1239:              *               CPU_CntTrailZeros16(),
1240:              *               Application.
1241:              *
1242:              *               This function is a CPU module application programming interface (API) function & MAY be 
1243:              *               called by application function(s).
1244:              *
1245:              * Note(s)     : (1) Supports 16-bit values :
1246:              *
1247:              *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
1248:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1249:              *                           1    x    x         x    x    x    x    x            0
1250:              *                           0    1    x         x    x    x    x    x            1
1251:              *                           0    0    1         x    x    x    x    x            2
1252:              *                           :    :    :         :    :    :    :    :            :
1253:              *                           :    :    :         :    :    :    :    :            :
1254:              *                           0    0    0         1    x    x    x    x           11
1255:              *                           0    0    0         0    1    x    x    x           12
1256:              *                           0    0    0         0    0    1    x    x           13
1257:              *                           0    0    0         0    0    0    1    x           14
1258:              *                           0    0    0         0    0    0    0    1           15
1259:              *                           0    0    0         0    0    0    0    0           16
1260:              *
1261:              *
1262:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1263:              *********************************************************************************************************
1264:              */
1265:              
1266:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1267:              CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
1268:              {
005688  FA0006     LNK #0x6
00568A  980720     MOV W0, [W14+4]
1269:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1270:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1271:                  CPU_DATA  ix;
1272:              #endif
1273:                  CPU_DATA  nbr_lead_zeros;
1274:              
1275:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1276:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1277:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1278:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1279:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1280:              
1281:              
1282:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1283:                  if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
00568C  9000AE     MOV [W14+4], W1
00568E  200FF0     MOV #0xFF, W0
005690  508F80     SUB W1, W0, [W15]
005692  36000A     BRA LEU, 0x56A8
1284:                                                                                              /* .. Nbr lead zeros =               .. */
1285:                      ix             = (CPU_DATA)((CPU_DATA)val >> 8u);                       /* .. lookup tbl ix  = 'val' >>  8 bits */
005694  90002E     MOV [W14+4], W0
005696  DE0048     LSR W0, #8, W0
005698  980710     MOV W0, [W14+2]
1286:                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);                   /* .. plus nbr msb lead zeros =  0 bits.*/
00569A  29D0A1     MOV #0x9D0A, W1
00569C  90001E     MOV [W14+2], W0
00569E  408000     ADD W1, W0, W0
0056A0  784010     MOV.B [W0], W0
0056A2  FB8000     ZE W0, W0
0056A4  780F00     MOV W0, [W14]
0056A6  370008     BRA 0x56B8
1287:              
1288:                  } else {                                                                    /* Chk bits [07:00] :                   */
1289:                                                                                              /* .. Nbr lead zeros =               .. */
1290:                      ix             = (CPU_DATA)(val);                                       /* .. lookup tbl ix  = 'val' >>  0 bits */
0056A8  9000AE     MOV [W14+4], W1
0056AA  980711     MOV W1, [W14+2]
1291:                      nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);   /* .. plus nbr msb lead zeros =  8 bits.*/
0056AC  29D0A1     MOV #0x9D0A, W1
0056AE  90001E     MOV [W14+2], W0
0056B0  408000     ADD W1, W0, W0
0056B2  784010     MOV.B [W0], W0
0056B4  FB8000     ZE W0, W0
0056B6  400F68     ADD W0, #0x8, [W14]
1292:                  }
1293:              #endif
1294:              
1295:              
1296:                  return (nbr_lead_zeros);
0056B8  78001E     MOV [W14], W0
1297:              }
0056BA  FA8000     ULNK
0056BC  060000     RETURN
1298:              #endif
1299:              
1300:              
1301:              /*
1302:              *********************************************************************************************************
1303:              *                                        CPU_CntLeadZeros32()
1304:              *
1305:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
1306:              *
1307:              * Argument(s) : val         Data value to count leading zero bits.
1308:              *
1309:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1310:              *
1311:              * Caller(s)   : CPU_CntLeadZeros(),
1312:              *               CPU_CntTrailZeros32(),
1313:              *               Application.
1314:              *
1315:              *               This function is a CPU module application programming interface (API) function & MAY be 
1316:              *               called by application function(s).
1317:              *
1318:              * Note(s)     : (1) Supports 32-bit values :
1319:              *
1320:              *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
1321:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1322:              *                           1    x    x         x    x    x    x    x            0
1323:              *                           0    1    x         x    x    x    x    x            1
1324:              *                           0    0    1         x    x    x    x    x            2
1325:              *                           :    :    :         :    :    :    :    :            :
1326:              *                           :    :    :         :    :    :    :    :            :
1327:              *                           0    0    0         1    x    x    x    x           27
1328:              *                           0    0    0         0    1    x    x    x           28
1329:              *                           0    0    0         0    0    1    x    x           29
1330:              *                           0    0    0         0    0    0    1    x           30
1331:              *                           0    0    0         0    0    0    0    1           31
1332:              *                           0    0    0         0    0    0    0    0           32
1333:              *
1334:              *
1335:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1336:              *********************************************************************************************************
1337:              */
1338:              
1339:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1340:              CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
1341:              {
0056BE  FA0008     LNK #0x8
0056C0  980720     MOV W0, [W14+4]
0056C2  980731     MOV W1, [W14+6]
1342:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1343:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1344:                  CPU_DATA  ix;
1345:              #endif
1346:                  CPU_DATA  nbr_lead_zeros;
1347:              
1348:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1349:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1350:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1351:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1352:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1353:              
1354:              
1355:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1356:                  if (val > 0x0000FFFFu) {
0056C4  90012E     MOV [W14+4], W2
0056C6  9001BE     MOV [W14+6], W3
0056C8  2FFFF0     MOV #0xFFFF, W0
0056CA  200001     MOV #0x0, W1
0056CC  510F80     SUB W2, W0, [W15]
0056CE  598F81     SUBB W3, W1, [W15]
0056D0  36001D     BRA LEU, 0x570C
1357:                      if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
0056D2  90012E     MOV [W14+4], W2
0056D4  9001BE     MOV [W14+6], W3
0056D6  2FFFF0     MOV #0xFFFF, W0
0056D8  200FF1     MOV #0xFF, W1
0056DA  510F80     SUB W2, W0, [W15]
0056DC  598F81     SUBB W3, W1, [W15]
0056DE  36000B     BRA LEU, 0x56F6
1358:                                                                                              /* .. Nbr lead zeros =               .. */
1359:                          ix             = (CPU_DATA)(val >> 24u);                  /* .. lookup tbl ix  = 'val' >> 24 bits */
0056E0  90002E     MOV [W14+4], W0
0056E2  9000BE     MOV [W14+6], W1
0056E4  DE0848     LSR W1, #8, W0
0056E6  980710     MOV W0, [W14+2]
1360:                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);               /* .. plus nbr msb lead zeros =  0 bits.*/
0056E8  29D0A1     MOV #0x9D0A, W1
0056EA  90001E     MOV [W14+2], W0
0056EC  408000     ADD W1, W0, W0
0056EE  784010     MOV.B [W0], W0
0056F0  FB8000     ZE W0, W0
0056F2  780F00     MOV W0, [W14]
0056F4  370024     BRA 0x573E
1361:              
1362:                      } else {                                                                /* Chk bits [23:16] :                   */
1363:                                                                                              /* .. Nbr lead zeros =               .. */
1364:                          ix             = (CPU_DATA)(val >> 16u);                  /* .. lookup tbl ix  = 'val' >> 16 bits */
0056F6  90002E     MOV [W14+4], W0
0056F8  9000BE     MOV [W14+6], W1
0056FA  DE0840     LSR W1, #0, W0
0056FC  980710     MOV W0, [W14+2]
1365:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
0056FE  29D0A1     MOV #0x9D0A, W1
005700  90001E     MOV [W14+2], W0
005702  408000     ADD W1, W0, W0
005704  784010     MOV.B [W0], W0
005706  FB8000     ZE W0, W0
005708  400F68     ADD W0, #0x8, [W14]
00570A  370019     BRA 0x573E
1366:                      }
1367:              
1368:                  } else {
1369:                      if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
00570C  90012E     MOV [W14+4], W2
00570E  9001BE     MOV [W14+6], W3
005710  200FF0     MOV #0xFF, W0
005712  200001     MOV #0x0, W1
005714  510F80     SUB W2, W0, [W15]
005716  598F81     SUBB W3, W1, [W15]
005718  36000A     BRA LEU, 0x572E
1370:                                                                                              /* .. Nbr lead zeros =               .. */
1371:                          ix             = (CPU_DATA)((CPU_DATA)val >>  8u);                  /* .. lookup tbl ix  = 'val' >>  8 bits */
00571A  90002E     MOV [W14+4], W0
00571C  DE0048     LSR W0, #8, W0
00571E  980710     MOV W0, [W14+2]
1372:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
005720  29D0A1     MOV #0x9D0A, W1
005722  90001E     MOV [W14+2], W0
005724  408000     ADD W1, W0, W0
005726  784010     MOV.B [W0], W0
005728  FB8000     ZE W0, W0
00572A  400F70     ADD W0, #0x10, [W14]
00572C  370008     BRA 0x573E
1373:              
1374:                      } else {                                                                /* Chk bits [07:00] :                   */
1375:                                                                                              /* .. Nbr lead zeros =               .. */
1376:                          ix             = (CPU_DATA)((CPU_DATA)val >>  0u);                  /* .. lookup tbl ix  = 'val' >>  0 bits */
00572E  9000AE     MOV [W14+4], W1
005730  980711     MOV W1, [W14+2]
1377:                          nbr_lead_zeros = (CPU_DATA)((CPU_DATA)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
005732  29D0A1     MOV #0x9D0A, W1
005734  90001E     MOV [W14+2], W0
005736  408000     ADD W1, W0, W0
005738  784010     MOV.B [W0], W0
00573A  FB8000     ZE W0, W0
00573C  400F78     ADD W0, #0x18, [W14]
1378:                      }
1379:                  }
1380:              #endif
1381:              
1382:              
1383:                  return (nbr_lead_zeros);
00573E  78001E     MOV [W14], W0
1384:              }
005740  FA8000     ULNK
005742  060000     RETURN
1385:              #endif
1386:              
1387:              
1388:              /*
1389:              *********************************************************************************************************
1390:              *                                        CPU_CntLeadZeros64()
1391:              *
1392:              * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
1393:              *
1394:              * Argument(s) : val         Data value to count leading zero bits.
1395:              *
1396:              * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
1397:              *
1398:              * Caller(s)   : CPU_CntLeadZeros(),
1399:              *               CPU_CntTrailZeros64(),
1400:              *               Application.
1401:              *
1402:              *               This function is a CPU module application programming interface (API) function & MAY be 
1403:              *               called by application function(s).
1404:              *
1405:              * Note(s)     : (1) Supports 64-bit values :
1406:              *
1407:              *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
1408:              *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
1409:              *                           1    x    x         x    x    x    x    x            0
1410:              *                           0    1    x         x    x    x    x    x            1
1411:              *                           0    0    1         x    x    x    x    x            2
1412:              *                           :    :    :         :    :    :    :    :            :
1413:              *                           :    :    :         :    :    :    :    :            :
1414:              *                           0    0    0         1    x    x    x    x           59
1415:              *                           0    0    0         0    1    x    x    x           60
1416:              *                           0    0    0         0    0    1    x    x           61
1417:              *                           0    0    0         0    0    0    1    x           62
1418:              *                           0    0    0         0    0    0    0    1           63
1419:              *                           0    0    0         0    0    0    0    0           64
1420:              *
1421:              *
1422:              *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
1423:              *********************************************************************************************************
1424:              */
1425:              
1426:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
1427:              CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
1428:              {
005744  FA000C     LNK #0xC
005746  980720     MOV W0, [W14+4]
005748  980731     MOV W1, [W14+6]
00574A  980742     MOV W2, [W14+8]
00574C  980753     MOV W3, [W14+10]
1429:              #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1430:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
1431:                  CPU_DATA  ix;
1432:              #endif
1433:                  CPU_DATA  nbr_lead_zeros;
1434:              
1435:                                                                                              /* ---------- ASM-OPTIMIZED ----------- */
1436:              #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
1437:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
1438:                  nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
1439:                  nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1440:              
1441:              
1442:              #else                                                                           /* ----------- C-OPTIMIZED ------------ */
1443:                  if (val > 0x00000000FFFFFFFFu) {
00574E  90022E     MOV [W14+4], W4
005750  9002BE     MOV [W14+6], W5
005752  90034E     MOV [W14+8], W6
005754  9003DE     MOV [W14+10], W7
005756  2FFFF0     MOV #0xFFFF, W0
005758  2FFFF1     MOV #0xFFFF, W1
00575A  B81160     MUL.UU W2, #0, W2
00575C  E12000     CP W4, W0
00575E  E1A801     CPB W5, W1
005760  E1B002     CPB W6, W2
005762  E1B803     CPB W7, W3
005764  36005D     BRA LEU, 0x5820
1444:                      if (val > 0x0000FFFFFFFFFFFFu) {
005766  90022E     MOV [W14+4], W4
005768  9002BE     MOV [W14+6], W5
00576A  90034E     MOV [W14+8], W6
00576C  9003DE     MOV [W14+10], W7
00576E  2FFFF0     MOV #0xFFFF, W0
005770  2FFFF1     MOV #0xFFFF, W1
005772  2FFFF2     MOV #0xFFFF, W2
005774  200003     MOV #0x0, W3
005776  E12000     CP W4, W0
005778  E1A801     CPB W5, W1
00577A  E1B002     CPB W6, W2
00577C  E1B803     CPB W7, W3
00577E  360027     BRA LEU, 0x57CE
1445:                          if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
005780  90022E     MOV [W14+4], W4
005782  9002BE     MOV [W14+6], W5
005784  90034E     MOV [W14+8], W6
005786  9003DE     MOV [W14+10], W7
005788  2FFFF0     MOV #0xFFFF, W0
00578A  2FFFF1     MOV #0xFFFF, W1
00578C  2FFFF2     MOV #0xFFFF, W2
00578E  200FF3     MOV #0xFF, W3
005790  E12000     CP W4, W0
005792  E1A801     CPB W5, W1
005794  E1B002     CPB W6, W2
005796  E1B803     CPB W7, W3
005798  36000D     BRA LEU, 0x57B4
1446:                                                                                              /* .. Nbr lead zeros =               .. */
1447:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 56u);            /* .. lookup tbl ix  = 'val' >> 56 bits */
00579A  90002E     MOV [W14+4], W0
00579C  9000BE     MOV [W14+6], W1
00579E  90014E     MOV [W14+8], W2
0057A0  9001DE     MOV [W14+10], W3
0057A2  DE1848     LSR W3, #8, W0
0057A4  980710     MOV W0, [W14+2]
1448:                              nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix]);           /* .. plus nbr msb lead zeros =  0 bits.*/
0057A6  29D0A1     MOV #0x9D0A, W1
0057A8  90001E     MOV [W14+2], W0
0057AA  408000     ADD W1, W0, W0
0057AC  784010     MOV.B [W0], W0
0057AE  FB8000     ZE W0, W0
0057B0  780F00     MOV W0, [W14]
0057B2  370091     BRA 0x58D6
1449:              
1450:                          } else {                                                            /* Chk bits [55:48] :                   */
1451:                                                                                              /* .. Nbr lead zeros =               .. */
1452:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 48u);            /* .. lookup tbl ix  = 'val' >> 48 bits */
0057B4  90002E     MOV [W14+4], W0
0057B6  9000BE     MOV [W14+6], W1
0057B8  90014E     MOV [W14+8], W2
0057BA  9001DE     MOV [W14+10], W3
0057BC  780003     MOV W3, W0
0057BE  980710     MOV W0, [W14+2]
1453:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] +  8u);/* .. plus nbr msb lead zeros =  8 bits.*/
0057C0  29D0A1     MOV #0x9D0A, W1
0057C2  90001E     MOV [W14+2], W0
0057C4  408000     ADD W1, W0, W0
0057C6  784010     MOV.B [W0], W0
0057C8  FB8000     ZE W0, W0
0057CA  400F68     ADD W0, #0x8, [W14]
0057CC  370084     BRA 0x58D6
1454:                          }
1455:              
1456:                      } else {
1457:                          if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
0057CE  90022E     MOV [W14+4], W4
0057D0  9002BE     MOV [W14+6], W5
0057D2  90034E     MOV [W14+8], W6
0057D4  9003DE     MOV [W14+10], W7
0057D6  2FFFF0     MOV #0xFFFF, W0
0057D8  2FFFF1     MOV #0xFFFF, W1
0057DA  200FF2     MOV #0xFF, W2
0057DC  200003     MOV #0x0, W3
0057DE  E12000     CP W4, W0
0057E0  E1A801     CPB W5, W1
0057E2  E1B002     CPB W6, W2
0057E4  E1B803     CPB W7, W3
0057E6  36000F     BRA LEU, 0x5806
1458:                                                                                              /* .. Nbr lead zeros =               .. */
1459:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 40u);            /* .. lookup tbl ix  = 'val' >> 40 bits */
0057E8  90002E     MOV [W14+4], W0
0057EA  9000BE     MOV [W14+6], W1
0057EC  90014E     MOV [W14+8], W2
0057EE  9001DE     MOV [W14+10], W3
0057F0  DE1048     LSR W2, #8, W0
0057F2  DD1A48     SL W3, #8, W4
0057F4  720000     IOR W4, W0, W0
0057F6  980710     MOV W0, [W14+2]
1460:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 16u);/* .. plus nbr msb lead zeros = 16 bits.*/
0057F8  29D0A1     MOV #0x9D0A, W1
0057FA  90001E     MOV [W14+2], W0
0057FC  408000     ADD W1, W0, W0
0057FE  784010     MOV.B [W0], W0
005800  FB8000     ZE W0, W0
005802  400F70     ADD W0, #0x10, [W14]
005804  370068     BRA 0x58D6
1461:              
1462:                          } else {                                                            /* Chk bits [39:32] :                   */
1463:                                                                                              /* .. Nbr lead zeros =               .. */
1464:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 32u);            /* .. lookup tbl ix  = 'val' >> 32 bits */
005806  90002E     MOV [W14+4], W0
005808  9000BE     MOV [W14+6], W1
00580A  90014E     MOV [W14+8], W2
00580C  9001DE     MOV [W14+10], W3
00580E  780002     MOV W2, W0
005810  980710     MOV W0, [W14+2]
1465:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 24u);/* .. plus nbr msb lead zeros = 24 bits.*/
005812  29D0A1     MOV #0x9D0A, W1
005814  90001E     MOV [W14+2], W0
005816  408000     ADD W1, W0, W0
005818  784010     MOV.B [W0], W0
00581A  FB8000     ZE W0, W0
00581C  400F78     ADD W0, #0x18, [W14]
00581E  37005B     BRA 0x58D6
1466:                          }
1467:                      }
1468:              
1469:                  } else {
1470:                      if (val > 0x000000000000FFFFu) {
005820  90022E     MOV [W14+4], W4
005822  9002BE     MOV [W14+6], W5
005824  90034E     MOV [W14+8], W6
005826  9003DE     MOV [W14+10], W7
005828  2FFFF0     MOV #0xFFFF, W0
00582A  200001     MOV #0x0, W1
00582C  B81160     MUL.UU W2, #0, W2
00582E  E12000     CP W4, W0
005830  E1A801     CPB W5, W1
005832  E1B002     CPB W6, W2
005834  E1B803     CPB W7, W3
005836  36002A     BRA LEU, 0x588C
1471:                          if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
005838  90022E     MOV [W14+4], W4
00583A  9002BE     MOV [W14+6], W5
00583C  90034E     MOV [W14+8], W6
00583E  9003DE     MOV [W14+10], W7
005840  2FFFF0     MOV #0xFFFF, W0
005842  200FF1     MOV #0xFF, W1
005844  B81160     MUL.UU W2, #0, W2
005846  E12000     CP W4, W0
005848  E1A801     CPB W5, W1
00584A  E1B002     CPB W6, W2
00584C  E1B803     CPB W7, W3
00584E  360010     BRA LEU, 0x5870
1472:                                                                                              /* .. Nbr lead zeros =               .. */
1473:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 24u);              /* .. lookup tbl ix  = 'val' >> 24 bits */
005850  90002E     MOV [W14+4], W0
005852  9000BE     MOV [W14+6], W1
005854  90014E     MOV [W14+8], W2
005856  9001DE     MOV [W14+10], W3
005858  DE0848     LSR W1, #8, W0
00585A  DD1248     SL W2, #8, W4
00585C  720000     IOR W4, W0, W0
00585E  980710     MOV W0, [W14+2]
1474:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 32u);/* .. plus nbr msb lead zeros = 32 bits.*/
005860  29D0A1     MOV #0x9D0A, W1
005862  90001E     MOV [W14+2], W0
005864  408000     ADD W1, W0, W0
005866  784010     MOV.B [W0], W0
005868  FB8000     ZE W0, W0
00586A  200201     MOV #0x20, W1
00586C  400F01     ADD W0, W1, [W14]
00586E  370033     BRA 0x58D6
1475:              
1476:                          } else {                                                            /* Chk bits [23:16] :                   */
1477:                                                                                              /* .. Nbr lead zeros =               .. */
1478:                              ix             = (CPU_DATA)((CPU_INT64U)val >> 16u);            /* .. lookup tbl ix  = 'val' >> 16 bits */
005870  90002E     MOV [W14+4], W0
005872  9000BE     MOV [W14+6], W1
005874  90014E     MOV [W14+8], W2
005876  9001DE     MOV [W14+10], W3
005878  780001     MOV W1, W0
00587A  980710     MOV W0, [W14+2]
1479:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 40u);/* .. plus nbr msb lead zeros = 40 bits.*/
00587C  29D0A1     MOV #0x9D0A, W1
00587E  90001E     MOV [W14+2], W0
005880  408000     ADD W1, W0, W0
005882  784010     MOV.B [W0], W0
005884  FB8000     ZE W0, W0
005886  200281     MOV #0x28, W1
005888  400F01     ADD W0, W1, [W14]
00588A  370025     BRA 0x58D6
1480:                          }
1481:              
1482:                      } else {
1483:                          if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
00588C  90022E     MOV [W14+4], W4
00588E  9002BE     MOV [W14+6], W5
005890  90034E     MOV [W14+8], W6
005892  9003DE     MOV [W14+10], W7
005894  200FF0     MOV #0xFF, W0
005896  200001     MOV #0x0, W1
005898  B81160     MUL.UU W2, #0, W2
00589A  E12000     CP W4, W0
00589C  E1A801     CPB W5, W1
00589E  E1B002     CPB W6, W2
0058A0  E1B803     CPB W7, W3
0058A2  360010     BRA LEU, 0x58C4
1484:                                                                                              /* .. Nbr lead zeros =               .. */
1485:                              ix             = (CPU_DATA)((CPU_INT64U)val >>  8u);            /* .. lookup tbl ix  = 'val' >>  8 bits */
0058A4  90002E     MOV [W14+4], W0
0058A6  9000BE     MOV [W14+6], W1
0058A8  90014E     MOV [W14+8], W2
0058AA  9001DE     MOV [W14+10], W3
0058AC  DE0048     LSR W0, #8, W0
0058AE  DD0A48     SL W1, #8, W4
0058B0  720000     IOR W4, W0, W0
0058B2  980710     MOV W0, [W14+2]
1486:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 48u);/* .. plus nbr msb lead zeros = 48 bits.*/
0058B4  29D0A1     MOV #0x9D0A, W1
0058B6  90001E     MOV [W14+2], W0
0058B8  408000     ADD W1, W0, W0
0058BA  784010     MOV.B [W0], W0
0058BC  FB8000     ZE W0, W0
0058BE  200301     MOV #0x30, W1
0058C0  400F01     ADD W0, W1, [W14]
0058C2  370009     BRA 0x58D6
1487:              
1488:                          } else {                                                            /* Chk bits [07:00] :                   */
1489:                                                                                              /* .. Nbr lead zeros =               .. */
1490:                              ix             = (CPU_DATA)(val);                               /* .. lookup tbl ix  = 'val' >>  0 bits */
0058C4  90022E     MOV [W14+4], W4
0058C6  980714     MOV W4, [W14+2]
1491:                              nbr_lead_zeros = (CPU_DATA)((CPU_INT64U)CPU_CntLeadZerosTbl[ix] + 56u);/* .. plus nbr msb lead zeros = 56 bits.*/
0058C8  29D0A1     MOV #0x9D0A, W1
0058CA  90001E     MOV [W14+2], W0
0058CC  408000     ADD W1, W0, W0
0058CE  784010     MOV.B [W0], W0
0058D0  FB8000     ZE W0, W0
0058D2  200381     MOV #0x38, W1
0058D4  400F01     ADD W0, W1, [W14]
1492:                          }
1493:                      }
1494:                  }
1495:              #endif
1496:              
1497:              
1498:                  return (nbr_lead_zeros);
0058D6  78001E     MOV [W14], W0
1499:              }
0058D8  FA8000     ULNK
0058DA  060000     RETURN
1500:              #endif
1501:              
1502:              
1503:              /*
1504:              *********************************************************************************************************
1505:              *                                         CPU_CntTrailZeros()
1506:              *
1507:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
1508:              *
1509:              * Argument(s) : val         Data value to count trailing zero bits.
1510:              *
1511:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1512:              *
1513:              * Caller(s)   : Application.
1514:              *
1515:              *               This function is a CPU module application programming interface (API) function & MAY 
1516:              *               be called by application function(s).
1517:              *
1518:              * Note(s)     : (1) (a) Supports the following data value sizes :
1519:              *
1520:              *                       (1)  8-bits
1521:              *                       (2) 16-bits
1522:              *                       (3) 32-bits
1523:              *                       (4) 64-bits
1524:              *
1525:              *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
1526:              *
1527:              *                   (b) (1) For  8-bit values :
1528:              *
1529:              *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1530:              *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1531:              *                                   x    x    x    x    x    x    x    1            0
1532:              *                                   x    x    x    x    x    x    1    0            1
1533:              *                                   x    x    x    x    x    1    0    0            2
1534:              *                                   x    x    x    x    1    0    0    0            3
1535:              *                                   x    x    x    1    0    0    0    0            4
1536:              *                                   x    x    1    0    0    0    0    0            5
1537:              *                                   x    1    0    0    0    0    0    0            6
1538:              *                                   1    0    0    0    0    0    0    0            7
1539:              *                                   0    0    0    0    0    0    0    0            8
1540:              *
1541:              *
1542:              *                       (2) For 16-bit values :
1543:              *
1544:              *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1545:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1546:              *                              x    x    x    x    x         x    x    1            0
1547:              *                              x    x    x    x    x         x    1    0            1
1548:              *                              x    x    x    x    x         1    0    0            2
1549:              *                              :    :    :    :    :         :    :    :            :
1550:              *                              :    :    :    :    :         :    :    :            :
1551:              *                              x    x    x    x    1         0    0    0           11
1552:              *                              x    x    x    1    0         0    0    0           12
1553:              *                              x    x    1    0    0         0    0    0           13
1554:              *                              x    1    0    0    0         0    0    0           14
1555:              *                              1    0    0    0    0         0    0    0           15
1556:              *                              0    0    0    0    0         0    0    0           16
1557:              *
1558:              *
1559:              *                       (3) For 32-bit values :
1560:              *
1561:              *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1562:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1563:              *                              x    x    x    x    x         x    x    1            0
1564:              *                              x    x    x    x    x         x    1    0            1
1565:              *                              x    x    x    x    x         1    0    0            2
1566:              *                              :    :    :    :    :         :    :    :            :
1567:              *                              :    :    :    :    :         :    :    :            :
1568:              *                              x    x    x    x    1         0    0    0           27
1569:              *                              x    x    x    1    0         0    0    0           28
1570:              *                              x    x    1    0    0         0    0    0           29
1571:              *                              x    1    0    0    0         0    0    0           30
1572:              *                              1    0    0    0    0         0    0    0           31
1573:              *                              0    0    0    0    0         0    0    0           32
1574:              *
1575:              *
1576:              *                       (4) For 64-bit values :
1577:              *
1578:              *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1579:              *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1580:              *                              x    x    x    x    x         x    x    1            0
1581:              *                              x    x    x    x    x         x    1    0            1
1582:              *                              x    x    x    x    x         1    0    0            2
1583:              *                              :    :    :    :    :         :    :    :            :
1584:              *                              :    :    :    :    :         :    :    :            :
1585:              *                              x    x    x    x    1         0    0    0           59
1586:              *                              x    x    x    1    0         0    0    0           60
1587:              *                              x    x    1    0    0         0    0    0           61
1588:              *                              x    1    0    0    0         0    0    0           62
1589:              *                              1    0    0    0    0         0    0    0           63
1590:              *                              0    0    0    0    0         0    0    0           64
1591:              *
1592:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1593:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1594:              *
1595:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1596:              *
1597:              *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of 
1598:              *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's 
1599:              *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
1600:              *
1601:              *                           if (val != 0u) {
1602:              *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1603:              *                           } else {
1604:              *                               nbr_trail_zeros = nbr_lead_zeros;
1605:              *                           }
1606:              *
1607:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1608:              *                       execute the final 'if' statement.
1609:              *********************************************************************************************************
1610:              */
1611:              
1612:              #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
1613:              CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
1614:              {
0058DC  FA0008     LNK #0x8
0058DE  980730     MOV W0, [W14+6]
1615:                  CPU_DATA  val_bit_mask;
1616:                  CPU_DATA  nbr_lead_zeros;
1617:                  CPU_DATA  nbr_trail_zeros;
1618:              
1619:              
1620:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0058E0  90003E     MOV [W14+6], W0
0058E2  E00000     CP0 W0
0058E4  3A0002     BRA NZ, 0x58EA
1621:                      return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
0058E6  200100     MOV #0x10, W0
0058E8  37000B     BRA 0x5900
1622:                  }
1623:              
1624:              
1625:                  val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
0058EA  90003E     MOV [W14+6], W0
0058EC  EA0080     NEG W0, W1
0058EE  90003E     MOV [W14+6], W0
0058F0  608F00     AND W1, W0, [W14]
1626:                  nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
0058F2  78001E     MOV [W14], W0
0058F4  07FEB4     RCALL CPU_CntLeadZeros
0058F6  980710     MOV W0, [W14+2]
1627:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1628:                  nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0058F8  90001E     MOV [W14+2], W0
0058FA  10006F     SUBR W0, #0xF, W0
0058FC  980720     MOV W0, [W14+4]
1629:              
1630:              
1631:                  return (nbr_trail_zeros);
0058FE  90002E     MOV [W14+4], W0
1632:              }
005900  FA8000     ULNK
005902  060000     RETURN
1633:              #endif
1634:              
1635:              
1636:              /*
1637:              *********************************************************************************************************
1638:              *                                        CPU_CntTrailZeros08()
1639:              *
1640:              * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
1641:              *
1642:              * Argument(s) : val         Data value to count trailing zero bits.
1643:              *
1644:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1645:              *
1646:              * Caller(s)   : Application.
1647:              *
1648:              *               This function is a CPU module application programming interface (API) function & MAY be 
1649:              *               called by application function(s).
1650:              *
1651:              * Note(s)     : (1) Supports  8-bit values :
1652:              *
1653:              *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
1654:              *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
1655:              *                                x    x    x    x    x    x    x    1            0
1656:              *                                x    x    x    x    x    x    1    0            1
1657:              *                                x    x    x    x    x    1    0    0            2
1658:              *                                x    x    x    x    1    0    0    0            3
1659:              *                                x    x    x    1    0    0    0    0            4
1660:              *                                x    x    1    0    0    0    0    0            5
1661:              *                                x    1    0    0    0    0    0    0            6
1662:              *                                1    0    0    0    0    0    0    0            7
1663:              *                                0    0    0    0    0    0    0    0            8
1664:              *
1665:              *
1666:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1667:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1668:              *
1669:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1670:              *
1671:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1672:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1673:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return 
1674:              *                       data size, then the returned number of zeros must be offset by the difference 
1675:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
1676:              *
1677:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1678:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
1679:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
1680:              *                           }
1681:              *
1682:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit 
1683:              *                       values would return a number of trailing zeros less than or equal to  8 bits.
1684:              *
1685:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1686:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1687:              *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
1688:              *
1689:              *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement 
1690:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s 
1691:              *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1692:              *                       initial 'val' is non-'0' :
1693:              *
1694:              *                           if (val != 0u) {
1695:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1696:              *                           } else {
1697:              *                               nbr_trail_zeros = nbr_lead_zeros;
1698:              *                           }
1699:              *
1700:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1701:              *                       execute the final 'if' statement.
1702:              *********************************************************************************************************
1703:              */
1704:              
1705:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
1706:              CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
1707:              {
005904  FA0008     LNK #0x8
005906  984760     MOV.B W0, [W14+6]
1708:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1709:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
1710:                  CPU_INT08U  val_bit_mask;
1711:                  CPU_DATA    nbr_lead_zeros;
1712:              #endif
1713:                  CPU_DATA    nbr_trail_zeros;
1714:              
1715:              
1716:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
005908  90406E     MOV.B [W14+6], W0
00590A  E00400     CP0.B W0
00590C  3A0002     BRA NZ, 0x5912
1717:                      return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
00590E  200080     MOV #0x8, W0
005910  37000B     BRA 0x5928
1718:                  }
1719:              
1720:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1721:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1722:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
1723:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1724:              
1725:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1726:                  val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
005912  90406E     MOV.B [W14+6], W0
005914  EA4080     NEG.B W0, W1
005916  90406E     MOV.B [W14+6], W0
005918  60CF00     AND.B W1, W0, [W14]
1727:                  nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
00591A  78401E     MOV.B [W14], W0
00591C  07FEA8     RCALL CPU_CntLeadZeros08
00591E  980710     MOV W0, [W14+2]
1728:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1729:                  nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
005920  90001E     MOV [W14+2], W0
005922  100067     SUBR W0, #0x7, W0
005924  980720     MOV W0, [W14+4]
1730:              #endif
1731:              
1732:              
1733:                  return (nbr_trail_zeros);
005926  90002E     MOV [W14+4], W0
1734:              }
005928  FA8000     ULNK
00592A  060000     RETURN
1735:              #endif
1736:              
1737:              
1738:              /*
1739:              *********************************************************************************************************
1740:              *                                        CPU_CntTrailZeros16()
1741:              *
1742:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
1743:              *
1744:              * Argument(s) : val         Data value to count trailing zero bits.
1745:              *
1746:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1747:              *
1748:              * Caller(s)   : Application.
1749:              *
1750:              *               This function is a CPU module application programming interface (API) function & MAY be 
1751:              *               called by application function(s).
1752:              *
1753:              * Note(s)     : (1) Supports 16-bit values :
1754:              *
1755:              *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
1756:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1757:              *                           x    x    x    x    x         x    x    1            0
1758:              *                           x    x    x    x    x         x    1    0            1
1759:              *                           x    x    x    x    x         1    0    0            2
1760:              *                           :    :    :    :    :         :    :    :            :
1761:              *                           :    :    :    :    :         :    :    :            :
1762:              *                           x    x    x    x    1         0    0    0           11
1763:              *                           x    x    x    1    0         0    0    0           12
1764:              *                           x    x    1    0    0         0    0    0           13
1765:              *                           x    1    0    0    0         0    0    0           14
1766:              *                           1    0    0    0    0         0    0    0           15
1767:              *                           0    0    0    0    0         0    0    0           16
1768:              *
1769:              *
1770:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1771:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1772:              *
1773:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1774:              *
1775:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1776:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1777:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return 
1778:              *                       data size, then the returned number of zeros must be offset by the difference 
1779:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
1780:              *
1781:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1782:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
1783:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
1784:              *                           }
1785:              *
1786:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit 
1787:              *                       values would return a number of trailing zeros less than or equal to 16 bits.
1788:              *
1789:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1790:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1791:              *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
1792:              *
1793:              *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement 
1794:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s 
1795:              *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1796:              *                       initial 'val' is non-'0' :
1797:              *
1798:              *                           if (val != 0u) {
1799:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1800:              *                           } else {
1801:              *                               nbr_trail_zeros = nbr_lead_zeros;
1802:              *                           }
1803:              *
1804:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1805:              *                       execute the final 'if' statement.
1806:              *********************************************************************************************************
1807:              */
1808:              
1809:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
1810:              CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
1811:              {
00592C  FA0008     LNK #0x8
00592E  980730     MOV W0, [W14+6]
1812:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1813:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
1814:                  CPU_INT16U  val_bit_mask;
1815:                  CPU_DATA    nbr_lead_zeros;
1816:              #endif
1817:                  CPU_DATA    nbr_trail_zeros;
1818:              
1819:              
1820:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
005930  90003E     MOV [W14+6], W0
005932  E00000     CP0 W0
005934  3A0002     BRA NZ, 0x593A
1821:                      return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
005936  200100     MOV #0x10, W0
005938  37000B     BRA 0x5950
1822:                  }
1823:              
1824:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1825:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1826:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
1827:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1828:              
1829:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1830:                  val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
00593A  90003E     MOV [W14+6], W0
00593C  EA0080     NEG W0, W1
00593E  90003E     MOV [W14+6], W0
005940  608F00     AND W1, W0, [W14]
1831:                  nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
005942  78001E     MOV [W14], W0
005944  07FEA1     RCALL CPU_CntLeadZeros16
005946  980710     MOV W0, [W14+2]
1832:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1833:                  nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
005948  90001E     MOV [W14+2], W0
00594A  10006F     SUBR W0, #0xF, W0
00594C  980720     MOV W0, [W14+4]
1834:              #endif
1835:              
1836:              
1837:                  return (nbr_trail_zeros);
00594E  90002E     MOV [W14+4], W0
1838:              }
005950  FA8000     ULNK
005952  060000     RETURN
1839:              #endif
1840:              
1841:              
1842:              /*
1843:              *********************************************************************************************************
1844:              *                                        CPU_CntTrailZeros32()
1845:              *
1846:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
1847:              *
1848:              * Argument(s) : val         Data value to count trailing zero bits.
1849:              *
1850:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1851:              *
1852:              * Caller(s)   : Application.
1853:              *
1854:              *               This function is a CPU module application programming interface (API) function & MAY be 
1855:              *               called by application function(s).
1856:              *
1857:              * Note(s)     : (1) Supports 32-bit values :
1858:              *
1859:              *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
1860:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1861:              *                           x    x    x    x    x         x    x    1            0
1862:              *                           x    x    x    x    x         x    1    0            1
1863:              *                           x    x    x    x    x         1    0    0            2
1864:              *                           :    :    :    :    :         :    :    :            :
1865:              *                           :    :    :    :    :         :    :    :            :
1866:              *                           x    x    x    x    1         0    0    0           27
1867:              *                           x    x    x    1    0         0    0    0           28
1868:              *                           x    x    1    0    0         0    0    0           29
1869:              *                           x    1    0    0    0         0    0    0           30
1870:              *                           1    0    0    0    0         0    0    0           31
1871:              *                           0    0    0    0    0         0    0    0           32
1872:              *
1873:              *
1874:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1875:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1876:              *
1877:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1878:              *
1879:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1880:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1881:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return 
1882:              *                       data size, then the returned number of zeros must be offset by the difference 
1883:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
1884:              *
1885:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1886:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
1887:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
1888:              *                           }
1889:              *
1890:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit 
1891:              *                       values would return a number of trailing zeros less than or equal to 32 bits.
1892:              *
1893:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1894:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1895:              *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
1896:              *
1897:              *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement 
1898:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s 
1899:              *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the 
1900:              *                       initial 'val' is non-'0' :
1901:              *
1902:              *                           if (val != 0u) {
1903:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
1904:              *                           } else {
1905:              *                               nbr_trail_zeros = nbr_lead_zeros;
1906:              *                           }
1907:              *
1908:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
1909:              *                       execute the final 'if' statement.
1910:              *********************************************************************************************************
1911:              */
1912:              
1913:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
1914:              CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
1915:              {
005954  FA000C     LNK #0xC
005956  980740     MOV W0, [W14+8]
005958  980751     MOV W1, [W14+10]
1916:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1917:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
1918:                  CPU_INT32U  val_bit_mask;
1919:                  CPU_DATA    nbr_lead_zeros;
1920:              #endif
1921:                  CPU_DATA    nbr_trail_zeros;
1922:              
1923:              
1924:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
00595A  90004E     MOV [W14+8], W0
00595C  9000DE     MOV [W14+10], W1
00595E  500FE0     SUB W0, #0x0, [W15]
005960  588FE0     SUBB W1, #0x0, [W15]
005962  3A0002     BRA NZ, 0x5968
1925:                      return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
005964  200200     MOV #0x20, W0
005966  37001A     BRA 0x599C
1926:                  }
1927:              
1928:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
1929:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
1930:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
1931:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1932:              
1933:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
1934:                  val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
005968  90004E     MOV [W14+8], W0
00596A  9000DE     MOV [W14+10], W1
00596C  100160     SUBR W0, #0x0, W2
00596E  1881E0     SUBBR W1, #0x0, W3
005970  90004E     MOV [W14+8], W0
005972  9000DE     MOV [W14+10], W1
005974  780202     MOV W2, W4
005976  780183     MOV W3, W3
005978  780100     MOV W0, W2
00597A  780001     MOV W1, W0
00597C  620102     AND W4, W2, W2
00597E  618000     AND W3, W0, W0
005980  EB0080     CLR W1
005982  DD00C0     SL W0, #0, W1
005984  200000     MOV #0x0, W0
005986  BE8F00     MOV.D W0, [W14]
005988  B81061     MUL.UU W2, #1, W0
00598A  701F1E     IOR W0, [W14], [W14++]
00598C  70971E     IOR W1, [W14], [W14--]
1935:                  nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
00598E  BE001E     MOV.D [W14], W0
005990  07FE96     RCALL CPU_CntLeadZeros32
005992  980720     MOV W0, [W14+4]
1936:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
1937:                  nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
005994  90002E     MOV [W14+4], W0
005996  10007F     SUBR W0, #0x1F, W0
005998  980730     MOV W0, [W14+6]
1938:              #endif
1939:              
1940:              
1941:                  return (nbr_trail_zeros);
00599A  90003E     MOV [W14+6], W0
1942:              }
00599C  FA8000     ULNK
00599E  060000     RETURN
1943:              #endif
1944:              
1945:              
1946:              /*
1947:              *********************************************************************************************************
1948:              *                                        CPU_CntTrailZeros64()
1949:              *
1950:              * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
1951:              *
1952:              * Argument(s) : val         Data value to count trailing zero bits.
1953:              *
1954:              * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
1955:              *
1956:              * Caller(s)   : Application.
1957:              *
1958:              *               This function is a CPU module application programming interface (API) function & MAY be 
1959:              *               called by application function(s).
1960:              *
1961:              * Note(s)     : (1) Supports 64-bit values :
1962:              *
1963:              *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
1964:              *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
1965:              *                           x    x    x    x    x         x    x    1            0
1966:              *                           x    x    x    x    x         x    1    0            1
1967:              *                           x    x    x    x    x         1    0    0            2
1968:              *                           :    :    :    :    :         :    :    :            :
1969:              *                           :    :    :    :    :         :    :    :            :
1970:              *                           x    x    x    x    1         0    0    0           59
1971:              *                           x    x    x    1    0         0    0    0           60
1972:              *                           x    x    1    0    0         0    0    0           61
1973:              *                           x    1    0    0    0         0    0    0           62
1974:              *                           1    0    0    0    0         0    0    0           63
1975:              *                           0    0    0    0    0         0    0    0           64
1976:              *
1977:              *
1978:              *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing 
1979:              *                   zero bits is also equivalent to the bit position of the least-significant set bit.
1980:              *
1981:              *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
1982:              *
1983:              *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's 
1984:              *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.  
1985:              *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return 
1986:              *                       data size, then the returned number of zeros must be offset by the difference 
1987:              *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
1988:              *
1989:              *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
1990:              *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
1991:              *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
1992:              *                           }
1993:              *
1994:              *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit 
1995:              *                       values would return a number of trailing zeros less than or equal to 64 bits.
1996:              *
1997:              *                       Therefore, initially validating all non-'0' values prior to calling assembly-
1998:              *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned 
1999:              *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
2000:              *
2001:              *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement 
2002:              *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s 
2003:              *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the 
2004:              *                       initial 'val' is non-'0' :
2005:              *
2006:              *                           if (val != 0u) {
2007:              *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
2008:              *                           } else {
2009:              *                               nbr_trail_zeros = nbr_lead_zeros;
2010:              *                           }
2011:              *
2012:              *                       Therefore, initially validating all non-'0' values avoids having to conditionally 
2013:              *                       execute the final 'if' statement.
2014:              *********************************************************************************************************
2015:              */
2016:              
2017:              #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
2018:              CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
2019:              {
0059A0  FA0014     LNK #0x14
0059A2  BE9F88     MOV.D W8, [W15++]
0059A4  BE9F8A     MOV.D W10, [W15++]
0059A6  980760     MOV W0, [W14+12]
0059A8  980771     MOV W1, [W14+14]
0059AA  980F02     MOV W2, [W14+16]
0059AC  980F13     MOV W3, [W14+18]
2020:              #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2021:                      (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
2022:                  CPU_INT64U  val_bit_mask;
2023:                  CPU_DATA    nbr_lead_zeros;
2024:              #endif
2025:                  CPU_DATA    nbr_trail_zeros;
2026:              
2027:              
2028:                  if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
0059AE  90006E     MOV [W14+12], W0
0059B0  9000FE     MOV [W14+14], W1
0059B2  90090E     MOV [W14+16], W2
0059B4  90099E     MOV [W14+18], W3
0059B6  500FE0     SUB W0, #0x0, [W15]
0059B8  588FE0     SUBB W1, #0x0, [W15]
0059BA  590FE0     SUBB W2, #0x0, [W15]
0059BC  598FE0     SUBB W3, #0x0, [W15]
0059BE  3A0002     BRA NZ, 0x59C4
2029:                      return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
0059C0  200400     MOV #0x40, W0
0059C2  37001C     BRA 0x59FC
2030:                  }
2031:              
2032:                                                                              /* ------------------ ASM-OPTIMIZED ------------------- */
2033:              #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
2034:                   (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
2035:                  nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
2036:              
2037:              #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
2038:                  val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
0059C4  B84460     MUL.UU W8, #0, W8
0059C6  B85560     MUL.UU W10, #0, W10
0059C8  90006E     MOV [W14+12], W0
0059CA  9000FE     MOV [W14+14], W1
0059CC  90090E     MOV [W14+16], W2
0059CE  90099E     MOV [W14+18], W3
0059D0  540200     SUB W8, W0, W4
0059D2  5C8281     SUBB W9, W1, W5
0059D4  5D0302     SUBB W10, W2, W6
0059D6  5D8383     SUBB W11, W3, W7
0059D8  90006E     MOV [W14+12], W0
0059DA  9000FE     MOV [W14+14], W1
0059DC  90090E     MOV [W14+16], W2
0059DE  90099E     MOV [W14+18], W3
0059E0  621F00     AND W4, W0, [W14++]
0059E2  629F01     AND W5, W1, [W14++]
0059E4  631F02     AND W6, W2, [W14++]
0059E6  638F03     AND W7, W3, [W14]
0059E8  B1006E     SUB #0x6, W14
2039:                  nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
0059EA  BE003E     MOV.D [W14++], W0
0059EC  BE012E     MOV.D [W14--], W2
0059EE  07FEAA     RCALL CPU_CntLeadZeros64
0059F0  980740     MOV W0, [W14+8]
2040:                                                                              /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
2041:                  nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
0059F2  2003F1     MOV #0x3F, W1
0059F4  90004E     MOV [W14+8], W0
0059F6  508000     SUB W1, W0, W0
0059F8  980750     MOV W0, [W14+10]
2042:              #endif
2043:              
2044:              
2045:                  return (nbr_trail_zeros);
0059FA  90005E     MOV [W14+10], W0
2046:              }
0059FC  BE054F     MOV.D [--W15], W10
2047:              #endif
2048:              
2049:              
2050:              /*
2051:              *********************************************************************************************************
2052:              *********************************************************************************************************
2053:              *                                           LOCAL FUNCTIONS
2054:              *********************************************************************************************************
2055:              *********************************************************************************************************
2056:              */
2057:              
2058:              /*
2059:              *********************************************************************************************************
2060:              *                                           CPU_NameInit()
2061:              *
2062:              * Description : Initialize CPU Name.
2063:              *
2064:              * Argument(s) : none.
2065:              *
2066:              * Return(s)   : none.
2067:              *
2068:              * Caller(s)   : CPU_Init().
2069:              *
2070:              * Note(s)     : none.
2071:              *********************************************************************************************************
2072:              */
2073:              
2074:              #if (CPU_CFG_NAME_EN == DEF_ENABLED)
2075:              static  void  CPU_NameInit (void)
2076:              {
2077:                  CPU_NameClr();
2078:              }
2079:              #endif
2080:              
2081:              
2082:              /*
2083:              *********************************************************************************************************
2084:              *                                            CPU_TS_Init()
2085:              *
2086:              * Description : (1) Initialize CPU timestamp :
2087:              *
2088:              *                   (a) Initialize/start CPU timestamp timer                            See Note #1
2089:              *                   (b) Initialize       CPU timestamp controls
2090:              *
2091:              *
2092:              * Argument(s) : none.
2093:              *
2094:              * Return(s)   : none.
2095:              *
2096:              * Caller(s)   : CPU_Init().
2097:              *
2098:              * Note(s)     : (1) The following initialization MUST be sequenced as follows :
2099:              *
2100:              *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
2101:              *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
2102:              *                                                 otherwise, invalid time measurements may be calculated/
2103:              *                                                 returned.
2104:              *
2105:              *                   See also 'CPU_Init()  Note #3a'.
2106:              *********************************************************************************************************
2107:              */
2108:              
2109:              #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
2110:                   (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
2111:              static  void  CPU_TS_Init (void)
2112:              {
2113:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2114:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2115:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2116:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2117:                  CPU_TS_TMR  ts_tmr_cnts;
2118:              #endif
2119:              
2120:              
2121:                                                                              /* ----------------- INIT CPU TS TMR ------------------ */
2122:              #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
2123:                  CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
2124:                  CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
2125:              #endif
2126:              
2127:              
2128:                                                                              /* ------------------- INIT CPU TS -------------------- */
2129:              #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
2130:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
2131:                   ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
2132:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
2133:                  ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
2134:              #endif
2135:              
2136:              #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
2137:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
2138:                  CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
2139:                  CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
2140:              #endif
2141:              
2142:              #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
2143:                    (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
2144:                  CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
2145:                  CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
2146:              #endif
2147:              }
2148:              #endif
2149:              
2150:              
2151:              /*
2152:              *********************************************************************************************************
2153:              *                                        CPU_IntDisMeasInit()
2154:              *
2155:              * Description : (1) Initialize interrupts disabled time measurements feature :
2156:              *
2157:              *                   (a) Initialize interrupts disabled time measurement controls
2158:              *                   (b) Calculate  interrupts disabled time measurement overhead
2159:              *
2160:              *
2161:              * Argument(s) : none.
2162:              *
2163:              * Return(s)   : none.
2164:              *
2165:              * Caller(s)   : CPU_Init().
2166:              *
2167:              * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
2168:              *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
2169:              *                   disabled time measurements may be calculated/returned.
2170:              *
2171:              *                   See also 'CPU_Init()  Note #3b'.
2172:              *
2173:              *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
2174:              *                           a rounded average with better accuracy, hopefully of +/- one timer count.
2175:              *
2176:              *                       (2) However, a single overhead time measurement is recommended, even for instruction-
2177:              *                           cache-enabled CPUs, since critical sections are NOT typically called within
2178:              *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
2179:              *                           is a more realistic overhead for the majority of non-cached interrupts disabled
2180:              *                           time measurements.
2181:              *
2182:              *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
2183:              *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
2184:              *                       calculate an inflated overhead time which would then incorrectly calculate deflated
2185:              *                       interrupts disabled times.
2186:              *********************************************************************************************************
2187:              */
2188:              
2189:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2190:              static  void  CPU_IntDisMeasInit (void)
2191:              {
2192:                  CPU_TS_TMR  time_meas_tot_cnts;
2193:                  CPU_INT16U  i;
2194:                  CPU_SR_ALLOC();
2195:              
2196:                                                                              /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
2197:                  CPU_IntDisMeasCtr         = 0u;
2198:                  CPU_IntDisNestCtr         = 0u;
2199:                  CPU_IntDisMeasStart_cnts  = 0u;
2200:                  CPU_IntDisMeasStop_cnts   = 0u;
2201:                  CPU_IntDisMeasMaxCur_cnts = 0u;
2202:                  CPU_IntDisMeasMax_cnts    = 0u;
2203:                  CPU_IntDisMeasOvrhd_cnts  = 0u;
2204:              
2205:                                                                              /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
2206:                  time_meas_tot_cnts = 0u;
2207:                  CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
2208:                  for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
2209:                      CPU_IntDisMeasMaxCur_cnts = 0u;
2210:                      CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
2211:                      CPU_IntDisMeasStop();
2212:                      time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
2213:                  }
2214:                                                                              /* ... to calc avg time meas ovrhd (see Note #3a).      */
2215:                  CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
2216:                                                                  /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
2217:                  CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
2218:                  CPU_IntDisMeasMax_cnts    =  0u;
2219:                  CPU_INT_EN();
2220:              }
2221:              #endif
2222:              
2223:              
2224:              /*
2225:              *********************************************************************************************************
2226:              *                                       CPU_IntDisMeasMaxCalc()
2227:              *
2228:              * Description : Calculate maximum interrupts disabled time.
2229:              *
2230:              * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
2231:              *
2232:              * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
2233:              *
2234:              * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
2235:              *               CPU_IntDisMeasMaxGet().
2236:              *
2237:              * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
2238:              *                       during critical sections is calculated by the following equations :
2239:              *
2240:              *                       (1) time            =   [ time      -  time      ]  -  time
2241:              *                               interrupts      [     stop         start ]         total meas
2242:              *                                disabled       [     meas         meas  ]           ovrhd
2243:              *                           (via application)
2244:              *
2245:              *
2246:              *                       (2) time            =  time            +  time
2247:              *                               total meas         start meas         stop meas
2248:              *                                 ovrhd              ovrhd              ovrhd
2249:              *
2250:              *
2251:              *                               where
2252:              *
2253:              *                                       time                    time interrupts are disabled between
2254:              *                                           interrupts              first critical section enter &
2255:              *                                            disabled               last  critical section exit minus
2256:              *                                       (via application)           time measurement overhead
2257:              *
2258:              *                                       time                    time of disable interrupts start time
2259:              *                                           start                   measurement (in timer counts)
2260:              *                                           meas
2261:              *
2262:              *                                       time                    time of disable interrupts stop  time
2263:              *                                           stop                    measurement (in timer counts)
2264:              *                                           meas
2265:              *
2266:              *                                       time                    total overhead time to start/stop disabled
2267:              *                                           total meas              interrupts time measurements (in timer
2268:              *                                             ovrhd                 counts)
2269:              *
2270:              *                                       time                    total overhead time after getting start
2271:              *                                           start meas              time until end of start measurement
2272:              *                                             ovrhd                 function  (in timer counts)
2273:              *
2274:              *                                       time                    total overhead time from beginning of stop
2275:              *                                           stop meas               measurement function until after getting
2276:              *                                             ovrhd                 stop time (in timer counts)
2277:              *
2278:              *
2279:              *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final 
2280:              *                       calculations to subtract the interrupts disabled time measurement overhead is 
2281:              *                       performed asynchronously in API functions.
2282:              *
2283:              *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
2284:              *
2285:              *                   (c) The amount of time interrupts are disabled is calculated by either of the
2286:              *                       following equations :
2287:              *
2288:              *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
2289:              *
2290:              *                               where
2291:              *
2292:              *                                   Number timer counts             Number of timer counts measured
2293:              *                                   Timer period                    Timer's period in some units of
2294:              *                                                                       (fractional) seconds
2295:              *                                   Interrupts disabled time        Amount of time interrupts are
2296:              *                                                                       disabled, in same units of
2297:              *                                                                       (fractional) seconds as the
2298:              *                                                                       Timer period
2299:              *
2300:              *                                                         Number timer counts
2301:              *                       (2) Interrupts disabled time  =  ---------------------
2302:              *                                                           Timer frequency
2303:              *
2304:              *                               where
2305:              *
2306:              *                                   Number timer counts             Number of timer counts measured
2307:              *                                   Timer frequency                 Timer's frequency in some units
2308:              *                                                                       of counts per second
2309:              *                                   Interrupts disabled time        Amount of time interrupts are
2310:              *                                                                       disabled, in seconds
2311:              *
2312:              *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
2313:              *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
2314:              *
2315:              *               (2) Although it is not typical, it is possible for an interrupts disabled time
2316:              *                   measurement to be less than the interrupts disabled time measurement overhead;
2317:              *                   especially if the overhead was calculated with a single, non-cached measurement
2318:              *                   & critical sections are called within instruction-cached loops.
2319:              *********************************************************************************************************
2320:              */
2321:              
2322:              #ifdef  CPU_CFG_INT_DIS_MEAS_EN
2323:              static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
2324:              {
2325:                  CPU_TS_TMR  time_max_cnts;
2326:              
2327:              
2328:                  time_max_cnts = time_tot_cnts;
2329:                  if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
2330:                      time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
2331:                  } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
2332:                      time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
2333:                  }
2334:              
2335:                  return (time_max_cnts);
2336:              }
2337:              #endif
2338:              
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                /*
25:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
26:                
27:                Microchip licenses to you the right to use, modify, copy and distribute
28:                Software only when embedded on a Microchip microcontroller or digital signal
29:                controller that is integrated into your product or third party product
30:                (pursuant to the sublicense terms in the accompanying license agreement).
31:                
32:                You should refer to the license agreement accompanying this Software for
33:                additional information regarding your rights and obligations.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                 */
46:                
47:                
48:                #include <includes.h>
49:                #include "Configbits.h"
50:                
51:                //#include "HL6528.h"
52:                //#include "UART.h"
53:                //#include <xc.h>
54:                //#include "mcc_generated_files/mcc.h"
55:                //volatile uint8_t TMR1_CNT;
56:                
57:                
58:                uint8_t WGC_sta;
59:                OS_STK LEDStk[128];
60:                OS_STK HL6528Stk[512]; //mark
61:                OS_STK E41Stk[256];
62:                OS_STK Tsk7[512]; //
63:                //OS_STK I2CStk[128];
64:                //OS_STK U485Stk[128];
65:                //OS_STK SLPStk[32];
66:                //OS_STK PCCopStk[32];
67:                OS_EVENT *sem_set_alarm, *sem_get_pressure, *sem_send_pressure, *sem_receive_pressure, *sem_mutex;
68:                //OS_EVENT* E41_Dat; //, *sem2;
69:                //OS_FLAG_GRP *sem_F;
70:                
71:                static void Task1Led(void* p_arg);
72:                //static void Task2CopGPRS(void* p_arg);
73:                static void Task2UseHL6528(void *p_arg);
74:                static void Task3UseE41(void *parg);
75:                static void Task4Use485(void *parg);
76:                static void Task5TestI2C(void* parg);
77:                static void Task6Sleep(void* p_arg);
78:                static void Task7SetAlarm(void *p_arg);
79:                extern I2C1_Buffer i2c_buf;
80:                extern volatile uint8_t i2c1_state;
81:                
82:                /*
83:                                         Main application
84:                 */
85:                CPU_INT16S main(void) {
0074A4  FA0000     LNK #0x0
86:                    // initialize the device
87:                    //    SYSTEM_Initialize();
88:                    //    TMR1_Stop();
89:                    //    TMR1_Stop();
90:                    INT8U err;
91:                    BSP_Init(); //
0074A6  07FDF0     RCALL BSP_Init
92:                
93:                    OSInit();
0074A8  07D74B     RCALL OSInit
94:                    //    sem_send_pressure = OSSemCreate(0);
95:                    //    sem_get_pressure = OSSemCreate(0);
96:                    //    sem_receive_pressure = OSSemCreate(0);
97:                    sem_set_alarm = OSSemCreate(0);
0074AA  EB0000     CLR W0
0074AC  07EEB3     RCALL OSSemCreate
0074AE  884450     MOV W0, sem_set_alarm
98:                    //    sem_mutex = OSMutexCreate(0);
99:                    //    sem_F = OSFlagCreate(0, &err);
100:                   //    sem2 = OSSemCreate(0);
101:                   //    E41_Dat = OSMboxCreate((void*) 0);
102:                   //    sem2 = OSSemCreate(1);
103:               
104:                   OSTaskCreate(Task1Led, (void*) 0, (OS_STK *) & LEDStk[0], 3);
0074B0  B3C033     MOV.B #0x3, W3
0074B2  208AC2     MOV #0x8AC, W2
0074B4  EB0080     CLR W1
0074B6  274CC0     MOV #0x74CC, W0
0074B8  07E9F8     RCALL OSTaskCreate
105:                   OSTaskCreate(Task7SetAlarm, (void*) 0, (OS_STK*) & Tsk7[0], 4);
0074BA  B3C043     MOV.B #0x4, W3
0074BC  20FAC2     MOV #0xFAC, W2
0074BE  EB0080     CLR W1
0074C0  275B00     MOV #0x75B0, W0
0074C2  07E9F3     RCALL OSTaskCreate
106:                   //    OSTaskCreate(Task3UseE41, (void*) 0, (OS_STK*) & E41Stk[0], 5);
107:                   //    OSTaskCreate(Task2UseHL6528, (void*) 0, (OS_STK *) & HL6528Stk[0], 6); //mark
108:                   //    OSTaskCreate(Task4Use485, (void*) 0, (OS_STK *) & U485Stk[0], 4);
109:                   //    OSTaskCreate(Task5TestI2C, (void*) 0, (OS_STK*) & I2CStk[0], 6);
110:                   //    OSTaskCreate(Task6Sleep, (void*) 0, (OS_STK*) & SLPStk[0], 8);
111:                   OSStart();
0074C4  07D7CA     RCALL OSStart
112:                   return -1;
0074C6  EB8000     SETM W0
113:               }
0074C8  FA8000     ULNK
0074CA  060000     RETURN
114:               
115:               /**
116:                End of File
117:                */
118:               
119:               void Task1Led(void* p_arg) {
0074CC  FA0004     LNK #0x4
0074CE  980710     MOV W0, [W14+2]
120:                   INT8U err;
121:                   //    uint8_t cnt = 0;
122:                   //    OS_EVENT sem1;
123:                   while (1) {
124:                       //        PrintTime();
125:                       switch (WGC_sta) {
0074D0  BFC888     MOV.B WGC_sta, WREG
0074D2  FB8000     ZE W0, W0
0074D4  500FE2     SUB W0, #0x2, [W15]
0074D6  320011     BRA Z, 0x74FA
0074D8  500FE2     SUB W0, #0x2, [W15]
0074DA  3C0003     BRA GT, 0x74E2
0074DC  500FE1     SUB W0, #0x1, [W15]
0074DE  320006     BRA Z, 0x74EC
0074E0  370021     BRA 0x7524
0074E2  500FE3     SUB W0, #0x3, [W15]
0074E4  320011     BRA Z, 0x7508
0074E6  500FE4     SUB W0, #0x4, [W15]
0074E8  320016     BRA Z, 0x7516
0074EA  37001C     BRA 0x7524
126:                           case 1://
127:                           {
128:                               LED_Toggle();
0074EC  07FE3F     RCALL LED_Toggle
129:                               OSTimeDlyHMSM(0, 0, 1, 0); //1s 
0074EE  EB0180     CLR W3
0074F0  B3C012     MOV.B #0x1, W2
0074F2  EB4080     CLR.B W1
0074F4  EB4000     CLR.B W0
0074F6  07FEBD     RCALL OSTimeDlyHMSM
130:                               break;
0074F8  37001D     BRA 0x7534
131:                           }
132:                           case 2://
133:                           {
134:                               LED_Toggle();
0074FA  07FE38     RCALL LED_Toggle
135:                               OSTimeDlyHMSM(0, 0, 0, 500); //1s  
0074FC  201F43     MOV #0x1F4, W3
0074FE  EB4100     CLR.B W2
007500  EB4080     CLR.B W1
007502  EB4000     CLR.B W0
007504  07FEB6     RCALL OSTimeDlyHMSM
136:                               break;
007506  370016     BRA 0x7534
137:                           }
138:                           case 3://
139:                           {
140:                               LED_On();
007508  07FE29     RCALL LED_On
141:                               OSTimeDlyHMSM(0, 0, 3, 0); //  
00750A  EB0180     CLR W3
00750C  B3C032     MOV.B #0x3, W2
00750E  EB4080     CLR.B W1
007510  EB4000     CLR.B W0
007512  07FEAF     RCALL OSTimeDlyHMSM
142:                               break;
007514  37000F     BRA 0x7534
143:                           }
144:                           case 4://
145:                           {
146:                               LED_Toggle();
007516  07FE2A     RCALL LED_Toggle
147:                               OSTimeDlyHMSM(0, 0, 0, 200); //1s  
007518  200C83     MOV #0xC8, W3
00751A  EB4100     CLR.B W2
00751C  EB4080     CLR.B W1
00751E  EB4000     CLR.B W0
007520  07FEA8     RCALL OSTimeDlyHMSM
148:                               break;
007522  370008     BRA 0x7534
149:                           }
150:                           default://
151:                           {
152:                               LED_Toggle();
007524  07FE23     RCALL LED_Toggle
153:                               err = OSTimeDlyHMSM(0, 0, 0, 300); //1s                  
007526  2012C3     MOV #0x12C, W3
007528  EB4100     CLR.B W2
00752A  EB4080     CLR.B W1
00752C  EB4000     CLR.B W0
00752E  07FEA1     RCALL OSTimeDlyHMSM
007530  784F00     MOV.B W0, [W14]
154:                               break;
007532  000000     NOP
155:                           }
156:               
157:                       }
158:                   }
007534  37FFCD     BRA 0x74D0
159:               }
160:               
161:               void Task2UseHL6528(void *p_arg) {
007536  FA0002     LNK #0x2
007538  780F00     MOV W0, [W14]
162:                   INT8U err;
163:                   HL6528_Init(); /*Initialize the HL6528*/
00753A  07F56A     RCALL HL6528_Init
164:                   //    OSTimeDlyHMSM(0, 0, 5, 0);
165:                   while (1) {
166:                       //        OSSemPend(sem_send_pressure, 0, &err);
167:                       HL6528_GetIP_Port(); //IP
00753C  07F64A     RCALL HL6528_GetIP_Port
168:                       UART2_Open();
00753E  0700D0     RCALL UART2_Open
169:                       WGC_sta = 2; //GPRS
007540  B3C020     MOV.B #0x2, W0
007542  B7E888     MOV.B WREG, WGC_sta
170:                       //        HL6528_GetIP_Port(tmp);
171:                       if (!HL6528_DialingIsERR()) {
007544  07F574     RCALL HL6528_DialingIsERR
007546  A20400     BTG.B W0, #0
007548  E00400     CP0.B W0
00754A  32000E     BRA Z, 0x7568
172:                           WGC_sta = 3; //GPRS
00754C  B3C030     MOV.B #0x3, W0
00754E  B7E888     MOV.B WREG, WGC_sta
173:                           OSTimeDlyHMSM(0, 0, 1, 0); //1s
007550  EB0180     CLR W3
007552  B3C012     MOV.B #0x1, W2
007554  EB4080     CLR.B W1
007556  EB4000     CLR.B W0
007558  07FE8C     RCALL OSTimeDlyHMSM
174:                           UART2_SendString("103.1");
00755A  29FF00     MOV #0x9FF0, W0
00755C  0700D9     RCALL UART2_SendString
175:                           OSTimeDlyHMSM(0, 0, 1, 0); //1s
00755E  EB0180     CLR W3
007560  B3C012     MOV.B #0x1, W2
007562  EB4080     CLR.B W1
007564  EB4000     CLR.B W0
007566  07FE85     RCALL OSTimeDlyHMSM
176:                       }
177:                       HL6528_Close();
007568  07F5BB     RCALL HL6528_Close
178:                       WGC_sta = 0; //GPRS
00756A  EF6888     CLR.B WGC_sta
179:                   }
00756C  37FFE7     BRA 0x753C
180:               }
181:               
182:               void Task3UseE41(void *parg) {
00756E  FA0008     LNK #0x8
007570  980730     MOV W0, [W14+6]
183:                   INT8U err;
184:                   float f_dat;
185:                   E41_Init();
007572  07FF1B     RCALL E41_Init
186:                   OSTimeDlyHMSM(0, 0, 1, 0); //1s
007574  EB0180     CLR W3
007576  B3C012     MOV.B #0x1, W2
007578  EB4080     CLR.B W1
00757A  EB4000     CLR.B W0
00757C  07FE7A     RCALL OSTimeDlyHMSM
187:                   //    uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34};
188:                   //    E41_SetArg(); //E41
189:                   while (1) {
190:                       OSSemPend(sem_get_pressure, 0, &err); //
00757E  804460     MOV sem_get_pressure, W0
007580  78008E     MOV W14, W1
007582  B81160     MUL.UU W2, #0, W2
007584  07EEFA     RCALL OSSemPend
191:                       E41_Active_Send();
007586  07FF62     RCALL E41_Active_Send
192:                       OSSemPend(sem_receive_pressure, 1000, &err);
007588  804480     MOV sem_receive_pressure, W0
00758A  78008E     MOV W14, W1
00758C  203E82     MOV #0x3E8, W2
00758E  200003     MOV #0x0, W3
007590  07EEF4     RCALL OSSemPend
193:                       WGC_sta = 4;
007592  B3C040     MOV.B #0x4, W0
007594  B7E888     MOV.B WREG, WGC_sta
194:                       OSTimeDlyHMSM(0, 0, 3, 0); //1s
007596  EB0180     CLR W3
007598  B3C032     MOV.B #0x3, W2
00759A  EB4080     CLR.B W1
00759C  EB4000     CLR.B W0
00759E  07FE69     RCALL OSTimeDlyHMSM
195:                       //        LED_Toggle();
196:                       //        OSTimeDlyHMSM(0, 0, 0, 200);
197:                       if (E41_PressureIsGet(&f_dat)) {
0075A0  E8800E     INC2 W14, W0
0075A2  07FF20     RCALL E41_PressureIsGet
0075A4  E00400     CP0.B W0
0075A6  320002     BRA Z, 0x75AC
198:                           OSSemPost(sem_send_pressure);
0075A8  804470     MOV sem_send_pressure, W0
0075AA  07EFAB     RCALL OSSemPost
199:                           //            OSMboxPost(E41_Dat, &f_dat); //
200:                       }
201:                       WGC_sta = 0;
0075AC  EF6888     CLR.B WGC_sta
202:                       //        UART3_SendString(E41_tmp, 5);
203:                       //        OSTimeDlyHMSM(0, 0, 10, 0); //1s
204:                   }
0075AE  37FFE7     BRA 0x757E
205:               }
206:               
207:               //void Task4Use485(void *parg) {
208:               //    parg = parg;
209:               //    while (1) {
210:               //        RS485SendChar(0x30);
211:               //        //        RS485SendString("123", 3);
212:               //        OSTimeDlyHMSM(0, 0, 1, 0);
213:               //        //        OSSemPost(sem1);
214:               //    }
215:               //}
216:               
217:               //void Task5UseCAT24C512(void* parg) {
218:               //    INT8U err;
219:               //    parg = parg; //
220:               //    CAT24C512_Init(); //
221:               //
222:               //    while (1) {
223:               //        //
224:               //        //
225:               //        //
226:               ////        OSMutexPost();
227:               ////        OSMutexPend();
228:               ////        OSMBoxPost
229:               ////        OSSemPend(sem2, 0, &err); //, 0, &err);
230:               ////        -(0, tmp2);
231:               //    }
232:               //}
233:               
234:               //void Task6Sleep(void* p_arg) {
235:               //    p_arg = p_arg;
236:               //    LED_Off();
237:               //    
238:               //    OSSchedLock();//
239:               //    while (1) {
240:               //        DeepSleep();
241:               //        OSSemPost(sem2); //, 0, &err);
242:               //        //        Sleep();
243:               //
244:               //    }
245:               ////    OSSchedUnlock();//
246:               //}
247:               
248:               void Task7SetAlarm(void *p_arg) {
0075B0  FA0004     LNK #0x4
0075B2  980710     MOV W0, [W14+2]
249:                   INT8U err;
250:                   WGC_sta = 0;
0075B4  EF6888     CLR.B WGC_sta
251:                   IFS3bits.RTCIF = 1; // 
0075B6  A8C08B     BSET 0x8B, #6
252:               
253:                   while (1) {
254:                       OSSemPend(sem_set_alarm, 0, &err);
0075B8  804450     MOV sem_set_alarm, W0
0075BA  78008E     MOV W14, W1
0075BC  B81160     MUL.UU W2, #0, W2
0075BE  07EEDD     RCALL OSSemPend
255:               //        PrintTime();
256:                       WGC_CalcAlarmPeriod(); //
0075C0  07FBC8     RCALL WGC_CalcAlarmPeriod
257:                       //        OSSemPost(sem_get_pressure); //
258:                   }
0075C2  37FFFA     BRA 0x75B8
259:               }
260:               
261:               
262:               
263:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/WCG.c  --------------------------------------
1:                 #include "WCG.h"
2:                 
3:                 #define TIMEOFFSET 1483200000
4:                 
5:                 volatile WGCTIME0BITS WGCTIME0bits;
6:                 volatile WGCTIME1BITS WGCTIME1bits;
7:                 volatile WGCTIME2BITS WGCTIME2bits;
8:                 volatile WGCCON0BITS WGCCON0bits;
9:                 volatile WGCCON1BITS WGCCON1bits;
10:                volatile WGCCON2BITS WGCCON2bits;
11:                volatile WGCIPBITS WGCIPbits;
12:                volatile uint16_t WGCPORT;
13:                volatile WGCPERIODBITS WGCPeriodbits;
14:                
15:                void WGC_Init(void) {
006D16  FA0000     LNK #0x0
16:                    WGCIPbits.IP3 = 139; //IP
006D18  B3C8B0     MOV.B #0x8B, W0
006D1A  B7E885     MOV.B WREG, 0x885
17:                    WGCIPbits.IP2 = 196;
006D1C  B3CC40     MOV.B #0xC4, W0
006D1E  B7E884     MOV.B WREG, 0x884
18:                    WGCIPbits.IP1 = 122;
006D20  B3C7A0     MOV.B #0x7A, W0
006D22  B7E883     MOV.B WREG, 0x883
19:                    WGCIPbits.IP0 = 159;
006D24  B3C9F0     MOV.B #0x9F, W0
006D26  B7E882     MOV.B WREG, WGCIPbits
20:                    WGCPORT = 5080; //
006D28  213D80     MOV #0x13D8, W0
006D2A  884430     MOV W0, WGCPORT
21:                    WGCCON0bits.Send_60s = 0x01; //2
006D2C  8043E1     MOV WGCCON0bits, W1
006D2E  2F8000     MOV #0xF800, W0
006D30  608000     AND W1, W0, W0
006D32  A00000     BSET W0, #0
006D34  8843E0     MOV W0, WGCCON0bits
22:                    WGCCON1bits.Sample_5s = 0x01; //5
006D36  8043F1     MOV WGCCON1bits, W1
006D38  280000     MOV #0x8000, W0
006D3A  608000     AND W1, W0, W0
006D3C  A00000     BSET W0, #0
006D3E  8843F0     MOV W0, WGCCON1bits
23:                    WGCCON2bits.E41_Is_Use_For_Send_Data = 0; //E41
006D40  A90881     BCLR 0x881, #0
24:                    WGCCON2bits.E41_Is_Use_For_Set_Arg = 0; //E41
006D42  A92881     BCLR 0x881, #1
25:                    WGCCON2bits.WGC_ID = 0x03; //ID
006D44  B3C030     MOV.B #0x3, W0
006D46  B7E880     MOV.B WREG, WGCCON2bits
26:                    WGCPeriodbits.CNT = 0;
006D48  EB0000     CLR W0
006D4A  88F580     MOV W0, 0x1EB0
27:                    WGCCON2bits.Alarm_RST_FLAG = 1;
006D4C  A84881     BSET 0x881, #2
28:                }
006D4E  FA8000     ULNK
006D50  060000     RETURN
29:                
30:                bool WGC_CalcAlarmPeriod(void) {//
006D52  FA001A     LNK #0x1A
31:                    struct tm now_time;
32:                    struct tm *set_time; //
33:                    time_t now_second; //
34:                    uint8_t cnt;
35:                
36:                    if (WGCCON2bits.Alarm_RST_FLAG) {//,
006D54  804401     MOV WGCCON2bits, W1
006D56  204000     MOV #0x400, W0
006D58  608000     AND W1, W0, W0
006D5A  E00000     CP0 W0
006D5C  32006D     BRA Z, 0x6E38
37:                        WGCCON2bits.Alarm_RST_FLAG = 0; //
006D5E  A94881     BCLR 0x881, #2
38:                        if (WGCCON0bits.Send_60s < 3)//
006D60  8043E1     MOV WGCCON0bits, W1
006D62  207FF0     MOV #0x7FF, W0
006D64  608000     AND W1, W0, W0
006D66  500FE2     SUB W0, #0x2, [W15]
006D68  3C0006     BRA GT, 0x6D76
39:                            WGCCON0bits.Send_60s = 3;
006D6A  8043E1     MOV WGCCON0bits, W1
006D6C  2F8000     MOV #0xF800, W0
006D6E  608000     AND W1, W0, W0
006D70  B30030     IOR #0x3, W0
006D72  8843E0     MOV W0, WGCCON0bits
006D74  37000D     BRA 0x6D90
40:                        else if (WGCCON0bits.Send_60s > 1440)
006D76  8043E1     MOV WGCCON0bits, W1
006D78  207FF0     MOV #0x7FF, W0
006D7A  608000     AND W1, W0, W0
006D7C  780080     MOV W0, W1
006D7E  205A00     MOV #0x5A0, W0
006D80  508F80     SUB W1, W0, [W15]
006D82  340006     BRA LE, 0x6D90
41:                            WGCCON0bits.Send_60s = 1440;
006D84  8043E1     MOV WGCCON0bits, W1
006D86  2F8000     MOV #0xF800, W0
006D88  608080     AND W1, W0, W1
006D8A  205A00     MOV #0x5A0, W0
006D8C  700001     IOR W0, W1, W0
006D8E  8843E0     MOV W0, WGCCON0bits
42:                        if (WGCCON1bits.Sample_5s < 1)//
006D90  8043F1     MOV WGCCON1bits, W1
006D92  27FFF0     MOV #0x7FFF, W0
006D94  608000     AND W1, W0, W0
006D96  E00000     CP0 W0
006D98  3C0006     BRA GT, 0x6DA6
43:                            WGCCON1bits.Sample_5s = 1;
006D9A  8043F1     MOV WGCCON1bits, W1
006D9C  280000     MOV #0x8000, W0
006D9E  608000     AND W1, W0, W0
006DA0  A00000     BSET W0, #0
006DA2  8843F0     MOV W0, WGCCON1bits
006DA4  37000D     BRA 0x6DC0
44:                        else if (WGCCON1bits.Sample_5s > 17280)
006DA6  8043F1     MOV WGCCON1bits, W1
006DA8  27FFF0     MOV #0x7FFF, W0
006DAA  608000     AND W1, W0, W0
006DAC  780080     MOV W0, W1
006DAE  243800     MOV #0x4380, W0
006DB0  508F80     SUB W1, W0, [W15]
006DB2  340006     BRA LE, 0x6DC0
45:                            WGCCON1bits.Sample_5s = 17280;
006DB4  8043F1     MOV WGCCON1bits, W1
006DB6  280000     MOV #0x8000, W0
006DB8  608080     AND W1, W0, W1
006DBA  243800     MOV #0x4380, W0
006DBC  700001     IOR W0, W1, W0
006DBE  8843F0     MOV W0, WGCCON1bits
46:                
47:                        if (WGCCON1bits.Sample_5s > (WGCCON0bits.Send_60s * 12))//
006DC0  8043F1     MOV WGCCON1bits, W1
006DC2  27FFF0     MOV #0x7FFF, W0
006DC4  608000     AND W1, W0, W0
006DC6  780100     MOV W0, W2
006DC8  8043E1     MOV WGCCON0bits, W1
006DCA  207FF0     MOV #0x7FF, W0
006DCC  608000     AND W1, W0, W0
006DCE  B9006C     MUL.SU W0, #12, W0
006DD0  780000     MOV W0, W0
006DD2  510F80     SUB W2, W0, [W15]
006DD4  34000F     BRA LE, 0x6DF4
48:                            WGCCON1bits.Sample_5s = WGCCON0bits.Send_60s * 12;
006DD6  8043E1     MOV WGCCON0bits, W1
006DD8  207FF0     MOV #0x7FF, W0
006DDA  608000     AND W1, W0, W0
006DDC  B9006C     MUL.SU W0, #12, W0
006DDE  780000     MOV W0, W0
006DE0  780080     MOV W0, W1
006DE2  27FFF0     MOV #0x7FFF, W0
006DE4  608080     AND W1, W0, W1
006DE6  27FFF0     MOV #0x7FFF, W0
006DE8  608000     AND W1, W0, W0
006DEA  8043F2     MOV WGCCON1bits, W2
006DEC  280001     MOV #0x8000, W1
006DEE  610081     AND W2, W1, W1
006DF0  700001     IOR W0, W1, W0
006DF2  8843F0     MOV W0, WGCCON1bits
49:                        WGCPeriodbits.B1 = (WGCCON0bits.Send_60s * 12) / WGCCON1bits.Sample_5s; //
006DF4  8043E1     MOV WGCCON0bits, W1
006DF6  207FF0     MOV #0x7FF, W0
006DF8  608000     AND W1, W0, W0
006DFA  B9006C     MUL.SU W0, #12, W0
006DFC  780080     MOV W0, W1
006DFE  8043F2     MOV WGCCON1bits, W2
006E00  27FFF0     MOV #0x7FFF, W0
006E02  610000     AND W2, W0, W0
006E04  780100     MOV W0, W2
006E06  090011     REPEAT #0x11
006E08  D80082     DIV.SW W1, W2
006E0A  88F560     MOV W0, WGCPeriodbits
50:                        WGCPeriodbits.Y2 = (WGCCON0bits.Send_60s * 12) % WGCCON1bits.Sample_5s; //     
006E0C  8043E1     MOV WGCCON0bits, W1
006E0E  207FF0     MOV #0x7FF, W0
006E10  608000     AND W1, W0, W0
006E12  B9006C     MUL.SU W0, #12, W0
006E14  780080     MOV W0, W1
006E16  8043F2     MOV WGCCON1bits, W2
006E18  27FFF0     MOV #0x7FFF, W0
006E1A  610000     AND W2, W0, W0
006E1C  780100     MOV W0, W2
006E1E  090011     REPEAT #0x11
006E20  D80082     DIV.SW W1, W2
006E22  FD0080     EXCH W0, W1
006E24  88F570     MOV W0, 0x1EAE
51:                        WGCPeriodbits.CNT = 0; //
006E26  EB0000     CLR W0
006E28  88F580     MOV W0, 0x1EB0
52:                    }
53:                    //
54:                    while (!RTC_Read_Time(&now_time)) {//
006E2A  370007     BRA 0x6E3A
006E38  000000     NOP
006E3A  470064     ADD W14, #0x4, W0
006E3C  07F644     RCALL RTC_Read_Time
006E3E  E00000     CP0 W0
006E40  32FFF5     BRA Z, 0x6E2C
55:                        cnt++;
006E2C  E84F1E     INC.B [W14], [W14]
56:                        //LCD LED 01
57:                        if (cnt > 10)
006E2E  78401E     MOV.B [W14], W0
006E30  504FEA     SUB.B W0, #0xA, [W15]
006E32  360003     BRA LEU, 0x6E3A
58:                            return false;
006E34  EB4000     CLR.B W0
006E36  37005D     BRA 0x6EF2
59:                    } //
60:                    now_second = mktime(&now_time); //
006E42  470064     ADD W14, #0x4, W0
006E44  07CC89     RCALL 0x758
006E46  980F30     MOV W0, [W14+22]
006E48  980F41     MOV W1, [W14+24]
61:                    if (WGCPeriodbits.CNT == WGCPeriodbits.B1) {//
006E4A  80F581     MOV 0x1EB0, W1
006E4C  80F560     MOV WGCPeriodbits, W0
006E4E  508F80     SUB W1, W0, [W15]
006E50  3A0020     BRA NZ, 0x6E92
62:                        //
63:                        if (!WGCPeriodbits.Y2) {//0
006E52  80F570     MOV 0x1EAE, W0
006E54  E00000     CP0 W0
006E56  3A000F     BRA NZ, 0x6E76
64:                            now_second += (WGCCON1bits.Sample_5s * 5); //
006E58  8043F1     MOV WGCCON1bits, W1
006E5A  27FFF0     MOV #0x7FFF, W0
006E5C  608000     AND W1, W0, W0
006E5E  B90065     MUL.SU W0, #5, W0
006E60  780000     MOV W0, W0
006E62  B90161     MUL.SU W0, #1, W2
006E64  90083E     MOV [W14+22], W0
006E66  9008CE     MOV [W14+24], W1
006E68  400002     ADD W0, W2, W0
006E6A  488083     ADDC W1, W3, W1
006E6C  980F30     MOV W0, [W14+22]
006E6E  980F41     MOV W1, [W14+24]
65:                            //GPRS
66:                            WGCPeriodbits.CNT = 0;
006E70  EB0000     CLR W0
006E72  88F580     MOV W0, 0x1EB0
006E74  370030     BRA 0x6ED6
67:                        } else {
68:                            now_second += WGCPeriodbits.Y2 * 5; //
006E76  80F570     MOV 0x1EAE, W0
006E78  B90065     MUL.SU W0, #5, W0
006E7A  780000     MOV W0, W0
006E7C  B80161     MUL.UU W0, #1, W2
006E7E  90083E     MOV [W14+22], W0
006E80  9008CE     MOV [W14+24], W1
006E82  400002     ADD W0, W2, W0
006E84  488083     ADDC W1, W3, W1
006E86  980F30     MOV W0, [W14+22]
006E88  980F41     MOV W1, [W14+24]
69:                            WGCPeriodbits.CNT += 1;
006E8A  80F580     MOV 0x1EB0, W0
006E8C  E80000     INC W0, W0
006E8E  88F580     MOV W0, 0x1EB0
006E90  370022     BRA 0x6ED6
70:                        }
71:                    } else if (WGCPeriodbits.CNT > WGCPeriodbits.B1) {
006E92  80F581     MOV 0x1EB0, W1
006E94  80F560     MOV WGCPeriodbits, W0
006E96  508F80     SUB W1, W0, [W15]
006E98  36000F     BRA LEU, 0x6EB8
72:                        now_second += (WGCCON1bits.Sample_5s * 5); //
006E9A  8043F1     MOV WGCCON1bits, W1
006E9C  27FFF0     MOV #0x7FFF, W0
006E9E  608000     AND W1, W0, W0
006EA0  B90065     MUL.SU W0, #5, W0
006EA2  780000     MOV W0, W0
006EA4  B90161     MUL.SU W0, #1, W2
006EA6  90083E     MOV [W14+22], W0
006EA8  9008CE     MOV [W14+24], W1
006EAA  400002     ADD W0, W2, W0
006EAC  488083     ADDC W1, W3, W1
006EAE  980F30     MOV W0, [W14+22]
006EB0  980F41     MOV W1, [W14+24]
73:                        //GPRS
74:                        WGCPeriodbits.CNT = 0;
006EB2  EB0000     CLR W0
006EB4  88F580     MOV W0, 0x1EB0
006EB6  37000F     BRA 0x6ED6
75:                    } else {
76:                        //
77:                        now_second += (WGCCON1bits.Sample_5s * 5); //
006EB8  8043F1     MOV WGCCON1bits, W1
006EBA  27FFF0     MOV #0x7FFF, W0
006EBC  608000     AND W1, W0, W0
006EBE  B90065     MUL.SU W0, #5, W0
006EC0  780000     MOV W0, W0
006EC2  B90161     MUL.SU W0, #1, W2
006EC4  90083E     MOV [W14+22], W0
006EC6  9008CE     MOV [W14+24], W1
006EC8  400002     ADD W0, W2, W0
006ECA  488083     ADDC W1, W3, W1
006ECC  980F30     MOV W0, [W14+22]
006ECE  980F41     MOV W1, [W14+24]
78:                        WGCPeriodbits.CNT += 1;
006ED0  80F580     MOV 0x1EB0, W0
006ED2  E80000     INC W0, W0
006ED4  88F580     MOV W0, 0x1EB0
79:                    }
80:                    set_time = gmtime(&now_second); //
006ED6  470076     ADD W14, #0x16, W0
006ED8  07CC3B     RCALL 0x750
006EDA  980710     MOV W0, [W14+2]
81:                    RTC_Set_Alarm(*set_time); //
006EDC  90009E     MOV [W14+2], W1
006EDE  4787F2     ADD W15, #0x12, W15
006EE0  578072     SUB W15, #0x12, W0
006EE2  090008     REPEAT #0x8
006EE4  781831     MOV [W1++], [W0++]
006EE6  B10120     SUB #0x12, W0
006EE8  B10121     SUB #0x12, W1
006EEA  07F5C6     RCALL RTC_Set_Alarm
006EEC  5787F2     SUB W15, #0x12, W15
82:                    PrintTime();
006EEE  07F690     RCALL PrintTime
83:                    return true;
006EF0  B3C010     MOV.B #0x1, W0
84:                }
006EF2  FA8000     ULNK
85:                
86:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**************************************************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 
25:                Input: 12 
26:                Output: 
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
005D12  FA0002     LNK #0x2
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {// 
005D14  BFC89E     MOV.B bufferWptr_uart1, WREG
005D16  FB8080     ZE W0, W1
005D18  BFC89F     MOV.B bufferRptr_uart1, WREG
005D1A  FB8000     ZE W0, W0
005D1C  E90000     DEC W0, W0
005D1E  508F80     SUB W1, W0, [W15]
005D20  3A0003     BRA NZ, 0x5D28
31:                        tmp = U1RXREG; //
005D22  801130     MOV U1RXREG, W0
005D24  784F00     MOV.B W0, [W14]
32:                        return;
005D26  37000C     BRA 0x5D40
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
005D28  BFC89E     MOV.B bufferWptr_uart1, WREG
005D2A  FB8000     ZE W0, W0
005D2C  801131     MOV U1RXREG, W1
005D2E  784101     MOV.B W1, W2
005D30  21CC81     MOV #0x1CC8, W1
005D32  787082     MOV.B W2, [W1+W0]
35:                    bufferWptr_uart1++;
005D34  BFC89E     MOV.B bufferWptr_uart1, WREG
005D36  E84000     INC.B W0, W0
005D38  B7E89E     MOV.B WREG, bufferWptr_uart1
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
005D3A  BFC89E     MOV.B bufferWptr_uart1, WREG
005D3C  B243F0     AND.B #0x3F, W0
005D3E  B7E89E     MOV.B WREG, bufferWptr_uart1
37:                }
005D40  FA8000     ULNK
005D42  060000     RETURN
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 
42:                Input: 12 
43:                Output: 
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
005D44  FA0002     LNK #0x2
46:                    uint8_t tmp = 0;
005D46  EB4000     CLR.B W0
005D48  784F00     MOV.B W0, [W14]
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {// 
005D4A  BFC8A0     MOV.B bufferWptr_uart2, WREG
005D4C  FB8080     ZE W0, W1
005D4E  BFC8A1     MOV.B bufferRptr_uart2, WREG
005D50  FB8000     ZE W0, W0
005D52  E90000     DEC W0, W0
005D54  508F80     SUB W1, W0, [W15]
005D56  3A0003     BRA NZ, 0x5D5E
48:                        tmp = U2RXREG; //
005D58  8011B0     MOV U2RXREG, W0
005D5A  784F00     MOV.B W0, [W14]
49:                        return;
005D5C  37000C     BRA 0x5D76
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
005D5E  BFC8A0     MOV.B bufferWptr_uart2, WREG
005D60  FB8000     ZE W0, W0
005D62  8011B1     MOV U2RXREG, W1
005D64  784101     MOV.B W1, W2
005D66  21D081     MOV #0x1D08, W1
005D68  787082     MOV.B W2, [W1+W0]
52:                    bufferWptr_uart2++;
005D6A  BFC8A0     MOV.B bufferWptr_uart2, WREG
005D6C  E84000     INC.B W0, W0
005D6E  B7E8A0     MOV.B WREG, bufferWptr_uart2
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
005D70  BFC8A0     MOV.B bufferWptr_uart2, WREG
005D72  B243F0     AND.B #0x3F, W0
005D74  B7E8A0     MOV.B WREG, bufferWptr_uart2
54:                }
005D76  FA8000     ULNK
005D78  060000     RETURN
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 
59:                Input: 12 
60:                Output: 
61:                 *************************************/
62:                void BufferWrite_UART3(void) {
005D7A  FA0002     LNK #0x2
63:                    uint8_t tmp = 0;
005D7C  EB4000     CLR.B W0
005D7E  784F00     MOV.B W0, [W14]
64:                    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {// 
005D80  BFC8A2     MOV.B bufferWptr_uart3, WREG
005D82  FB8080     ZE W0, W1
005D84  BFC8A3     MOV.B bufferRptr_uart3, WREG
005D86  FB8000     ZE W0, W0
005D88  E90000     DEC W0, W0
005D8A  508F80     SUB W1, W0, [W15]
005D8C  3A0003     BRA NZ, 0x5D94
65:                        tmp = U3RXREG; //
005D8E  8012B0     MOV U3RXREG, W0
005D90  784F00     MOV.B W0, [W14]
66:                        return;
005D92  37000C     BRA 0x5DAC
67:                    }
68:                    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
005D94  BFC8A2     MOV.B bufferWptr_uart3, WREG
005D96  FB8000     ZE W0, W0
005D98  8012B1     MOV U3RXREG, W1
005D9A  784101     MOV.B W1, W2
005D9C  21D481     MOV #0x1D48, W1
005D9E  787082     MOV.B W2, [W1+W0]
69:                    bufferWptr_uart3++;
005DA0  BFC8A2     MOV.B bufferWptr_uart3, WREG
005DA2  E84000     INC.B W0, W0
005DA4  B7E8A2     MOV.B WREG, bufferWptr_uart3
70:                    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
005DA6  BFC8A2     MOV.B bufferWptr_uart3, WREG
005DA8  B243F0     AND.B #0x3F, W0
005DAA  B7E8A2     MOV.B WREG, bufferWptr_uart3
71:                }
005DAC  FA8000     ULNK
005DAE  060000     RETURN
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 
76:                Input:  
77:                Output: 10
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
005DB0  FA0002     LNK #0x2
005DB2  780F00     MOV W0, [W14]
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
005DB4  2089F1     MOV #0x89F, W1
005DB6  784091     MOV.B [W1], W1
005DB8  BFC89E     MOV.B bufferWptr_uart1, WREG
005DBA  50CF80     SUB.B W1, W0, [W15]
005DBC  3A0002     BRA NZ, 0x5DC2
81:                        return 0;
005DBE  EB4000     CLR.B W0
005DC0  37000D     BRA 0x5DDC
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
005DC2  BFC89F     MOV.B bufferRptr_uart1, WREG
005DC4  FB8000     ZE W0, W0
005DC6  21CC81     MOV #0x1CC8, W1
005DC8  7840E1     MOV.B [W1+W0], W1
005DCA  78001E     MOV [W14], W0
005DCC  784801     MOV.B W1, [W0]
84:                    bufferRptr_uart1++;
005DCE  BFC89F     MOV.B bufferRptr_uart1, WREG
005DD0  E84000     INC.B W0, W0
005DD2  B7E89F     MOV.B WREG, bufferRptr_uart1
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
005DD4  BFC89F     MOV.B bufferRptr_uart1, WREG
005DD6  B243F0     AND.B #0x3F, W0
005DD8  B7E89F     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
005DDA  B3C010     MOV.B #0x1, W0
87:                }
005DDC  FA8000     ULNK
005DDE  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 
92:                Input:  
93:                Output: 10
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
005DE0  FA0002     LNK #0x2
005DE2  780F00     MOV W0, [W14]
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
005DE4  208A11     MOV #0x8A1, W1
005DE6  784091     MOV.B [W1], W1
005DE8  BFC8A0     MOV.B bufferWptr_uart2, WREG
005DEA  50CF80     SUB.B W1, W0, [W15]
005DEC  3A0007     BRA NZ, 0x5DFC
97:                        if (U2STAbits.OERR)
005DEE  801190     MOV U2STA, W0
005DF0  600062     AND W0, #0x2, W0
005DF2  E00000     CP0 W0
005DF4  320001     BRA Z, 0x5DF8
98:                            U2STAbits.OERR = 0; //FIFO
005DF6  A92232     BCLR U2STA, #1
99:                        return 0;
005DF8  EB4000     CLR.B W0
005DFA  37000D     BRA 0x5E16
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
005DFC  BFC8A1     MOV.B bufferRptr_uart2, WREG
005DFE  FB8000     ZE W0, W0
005E00  21D081     MOV #0x1D08, W1
005E02  7840E1     MOV.B [W1+W0], W1
005E04  78001E     MOV [W14], W0
005E06  784801     MOV.B W1, [W0]
102:                   bufferRptr_uart2++;
005E08  BFC8A1     MOV.B bufferRptr_uart2, WREG
005E0A  E84000     INC.B W0, W0
005E0C  B7E8A1     MOV.B WREG, bufferRptr_uart2
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
005E0E  BFC8A1     MOV.B bufferRptr_uart2, WREG
005E10  B243F0     AND.B #0x3F, W0
005E12  B7E8A1     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
005E14  B3C010     MOV.B #0x1, W0
106:               }
005E16  FA8000     ULNK
005E18  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 
111:               Input:  
112:               Output: 10
113:                *************************************/
114:               bool BufferRead_UART3(uint8_t *data) {
005E1A  FA0002     LNK #0x2
005E1C  780F00     MOV W0, [W14]
115:                   if (bufferRptr_uart3 == bufferWptr_uart3) {
005E1E  208A31     MOV #0x8A3, W1
005E20  784091     MOV.B [W1], W1
005E22  BFC8A2     MOV.B bufferWptr_uart3, WREG
005E24  50CF80     SUB.B W1, W0, [W15]
005E26  3A0007     BRA NZ, 0x5E36
116:                       if (U3STAbits.OERR)
005E28  801290     MOV U3STA, W0
005E2A  600062     AND W0, #0x2, W0
005E2C  E00000     CP0 W0
005E2E  320001     BRA Z, 0x5E32
117:                           U3STAbits.OERR = 0; //FIFO
005E30  A92252     BCLR U3STA, #1
118:                       return 0;
005E32  EB4000     CLR.B W0
005E34  37000D     BRA 0x5E50
119:                   }
120:                   *data = Buffer_uart3[bufferRptr_uart3];
005E36  BFC8A3     MOV.B bufferRptr_uart3, WREG
005E38  FB8000     ZE W0, W0
005E3A  21D481     MOV #0x1D48, W1
005E3C  7840E1     MOV.B [W1+W0], W1
005E3E  78001E     MOV [W14], W0
005E40  784801     MOV.B W1, [W0]
121:                   bufferRptr_uart3++;
005E42  BFC8A3     MOV.B bufferRptr_uart3, WREG
005E44  E84000     INC.B W0, W0
005E46  B7E8A3     MOV.B WREG, bufferRptr_uart3
122:                   bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
005E48  BFC8A3     MOV.B bufferRptr_uart3, WREG
005E4A  B243F0     AND.B #0x3F, W0
005E4C  B7E8A3     MOV.B WREG, bufferRptr_uart3
123:                   //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:                   return 1;
005E4E  B3C010     MOV.B #0x1, W0
125:               }
005E50  FA8000     ULNK
005E52  060000     RETURN
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 
130:               Input: 
131:               Output: 
132:               Notice256    
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//
005E54  FA0008     LNK #0x8
005E56  980730     MOV W0, [W14+6]
135:                   bool IsFind = false; //
005E58  EB4000     CLR.B W0
005E5A  784F00     MOV.B W0, [W14]
136:                   uint8_t cnt = 0/**/, cnt1 = 0/**/, cnt2/**/, /*offset,*/ byte = 0;
005E5C  EB4000     CLR.B W0
005E5E  984710     MOV.B W0, [W14+1]
005E60  EB4000     CLR.B W0
005E62  984720     MOV.B W0, [W14+2]
005E64  EB4000     CLR.B W0
005E66  984740     MOV.B W0, [W14+4]
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//0
005E68  90003E     MOV [W14+6], W0
005E6A  904060     MOV.B [W0+6], W0
005E6C  E00400     CP0.B W0
005E6E  320004     BRA Z, 0x5E78
005E70  90003E     MOV [W14+6], W0
005E72  904020     MOV.B [W0+2], W0
005E74  E00400     CP0.B W0
005E76  3A0036     BRA NZ, 0x5EE4
139:                       return false; //
005E78  EB4000     CLR.B W0
005E7A  3700AD     BRA 0x5FD6
140:               
141:                   while (cnt < strcmp->Source_len) {
005EE4  000000     NOP
005EE6  90003E     MOV [W14+6], W0
005EE8  9040A0     MOV.B [W0+2], W1
005EEA  90401E     MOV.B [W14+1], W0
005EEC  50CF80     SUB.B W1, W0, [W15]
005EEE  3EFFC6     BRA GTU, 0x5E7C
005EF0  370001     BRA 0x5EF4
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//==head           
005E7C  90003E     MOV [W14+6], W0
005E7E  780090     MOV [W0], W1
005E80  90401E     MOV.B [W14+1], W0
005E82  FB8000     ZE W0, W0
005E84  408000     ADD W1, W0, W0
005E86  784090     MOV.B [W0], W1
005E88  90003E     MOV [W14+6], W0
005E8A  900020     MOV [W0+4], W0
005E8C  784010     MOV.B [W0], W0
005E8E  50CF80     SUB.B W1, W0, [W15]
005E90  3A0022     BRA NZ, 0x5ED6
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//               
005E92  B3C010     MOV.B #0x1, W0
005E94  984720     MOV.B W0, [W14+2]
005E96  37001A     BRA 0x5ECC
005EBE  90402E     MOV.B [W14+2], W0
005EC0  E84000     INC.B W0, W0
005EC2  984720     MOV.B W0, [W14+2]
005EC4  370003     BRA 0x5ECC
005ECC  90003E     MOV [W14+6], W0
005ECE  9040E0     MOV.B [W0+6], W1
005ED0  90402E     MOV.B [W14+2], W0
005ED2  50CF80     SUB.B W1, W0, [W15]
005ED4  3EFFE1     BRA GTU, 0x5E98
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//
005E98  90003E     MOV [W14+6], W0
005E9A  780090     MOV [W0], W1
005E9C  90401E     MOV.B [W14+1], W0
005E9E  FB8100     ZE W0, W2
005EA0  90402E     MOV.B [W14+2], W0
005EA2  FB8000     ZE W0, W0
005EA4  410000     ADD W2, W0, W0
005EA6  408000     ADD W1, W0, W0
005EA8  784090     MOV.B [W0], W1
005EAA  90003E     MOV [W14+6], W0
005EAC  900120     MOV [W0+4], W2
005EAE  90402E     MOV.B [W14+2], W0
005EB0  FB8000     ZE W0, W0
005EB2  410000     ADD W2, W0, W0
005EB4  784010     MOV.B [W0], W0
005EB6  50CF80     SUB.B W1, W0, [W15]
005EB8  3A0006     BRA NZ, 0x5EC6
145:                                   IsFind = true;
005EBA  B3C010     MOV.B #0x1, W0
005EBC  784F00     MOV.B W0, [W14]
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
005EC6  EB4000     CLR.B W0
005EC8  784F00     MOV.B W0, [W14]
149:                                   break;
005ECA  370005     BRA 0x5ED6
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //
005ED6  78401E     MOV.B [W14], W0
005ED8  E00400     CP0.B W0
005EDA  3A000B     BRA NZ, 0x5EF2
005EF2  000000     NOP
154:                       cnt++; //1
005EDC  90401E     MOV.B [W14+1], W0
005EDE  E84000     INC.B W0, W0
005EE0  984710     MOV.B W0, [W14+1]
005EE2  370001     BRA 0x5EE6
155:                   }
156:               
157:                   if (IsFind) {//
005EF4  78401E     MOV.B [W14], W0
005EF6  E00400     CP0.B W0
005EF8  32006A     BRA Z, 0x5FCE
158:                       if (strcmp->Get_len < strcmp->Check_len) {
005EFA  90003E     MOV [W14+6], W0
005EFC  9048A0     MOV.B [W0+10], W1
005EFE  90003E     MOV [W14+6], W0
005F00  904060     MOV.B [W0+6], W0
005F02  50CF80     SUB.B W1, W0, [W15]
005F04  31001A     BRA C, 0x5F3A
159:                           byte = strcmp->Get_len; //,
005F06  90003E     MOV [W14+6], W0
005F08  9048A0     MOV.B [W0+10], W1
005F0A  984741     MOV.B W1, [W14+4]
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //
005F0C  EB4000     CLR.B W0
005F0E  984730     MOV.B W0, [W14+3]
005F10  37000F     BRA 0x5F30
005F2A  90403E     MOV.B [W14+3], W0
005F2C  E84000     INC.B W0, W0
005F2E  984730     MOV.B W0, [W14+3]
005F30  9040BE     MOV.B [W14+3], W1
005F32  90404E     MOV.B [W14+4], W0
005F34  50CF80     SUB.B W1, W0, [W15]
005F36  39FFED     BRA NC, 0x5F12
005F38  370045     BRA 0x5FC4
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
005F12  90003E     MOV [W14+6], W0
005F14  9000C0     MOV [W0+8], W1
005F16  90403E     MOV.B [W14+3], W0
005F18  FB8000     ZE W0, W0
005F1A  408000     ADD W1, W0, W0
005F1C  9000BE     MOV [W14+6], W1
005F1E  900121     MOV [W1+4], W2
005F20  9040BE     MOV.B [W14+3], W1
005F22  FB8081     ZE W1, W1
005F24  410081     ADD W2, W1, W1
005F26  784091     MOV.B [W1], W1
005F28  784801     MOV.B W1, [W0]
162:                       } else {//
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//
005F3A  90003E     MOV [W14+6], W0
005F3C  904020     MOV.B [W0+2], W0
005F3E  FB8080     ZE W0, W1
005F40  90401E     MOV.B [W14+1], W0
005F42  FB8000     ZE W0, W0
005F44  508080     SUB W1, W0, W1
005F46  90003E     MOV [W14+6], W0
005F48  904820     MOV.B [W0+10], W0
005F4A  FB8000     ZE W0, W0
005F4C  508F80     SUB W1, W0, [W15]
005F4E  3D0020     BRA GE, 0x5F90
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //
005F50  EB4000     CLR.B W0
005F52  984730     MOV.B W0, [W14+3]
005F54  370012     BRA 0x5F7A
005F74  90403E     MOV.B [W14+3], W0
005F76  E84000     INC.B W0, W0
005F78  984730     MOV.B W0, [W14+3]
005F7A  90403E     MOV.B [W14+3], W0
005F7C  FB8080     ZE W0, W1
005F7E  90003E     MOV [W14+6], W0
005F80  904020     MOV.B [W0+2], W0
005F82  FB8100     ZE W0, W2
005F84  90401E     MOV.B [W14+1], W0
005F86  FB8000     ZE W0, W0
005F88  510000     SUB W2, W0, W0
005F8A  508F80     SUB W1, W0, [W15]
005F8C  35FFE4     BRA LT, 0x5F56
005F8E  37001A     BRA 0x5FC4
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
005F56  90003E     MOV [W14+6], W0
005F58  9000C0     MOV [W0+8], W1
005F5A  90403E     MOV.B [W14+3], W0
005F5C  FB8000     ZE W0, W0
005F5E  408000     ADD W1, W0, W0
005F60  9000BE     MOV [W14+6], W1
005F62  780111     MOV [W1], W2
005F64  90409E     MOV.B [W14+1], W1
005F66  FB8181     ZE W1, W3
005F68  9040BE     MOV.B [W14+3], W1
005F6A  FB8081     ZE W1, W1
005F6C  418081     ADD W3, W1, W1
005F6E  410081     ADD W2, W1, W1
005F70  784091     MOV.B [W1], W1
005F72  784801     MOV.B W1, [W0]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //
005F90  EB4000     CLR.B W0
005F92  984730     MOV.B W0, [W14+3]
005F94  370012     BRA 0x5FBA
005FB4  90403E     MOV.B [W14+3], W0
005FB6  E84000     INC.B W0, W0
005FB8  984730     MOV.B W0, [W14+3]
005FBA  90003E     MOV [W14+6], W0
005FBC  9048A0     MOV.B [W0+10], W1
005FBE  90403E     MOV.B [W14+3], W0
005FC0  50CF80     SUB.B W1, W0, [W15]
005FC2  31FFE9     BRA C, 0x5F96
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
005F96  90003E     MOV [W14+6], W0
005F98  9000C0     MOV [W0+8], W1
005F9A  90403E     MOV.B [W14+3], W0
005F9C  FB8000     ZE W0, W0
005F9E  408000     ADD W1, W0, W0
005FA0  9000BE     MOV [W14+6], W1
005FA2  780111     MOV [W1], W2
005FA4  90409E     MOV.B [W14+1], W1
005FA6  FB8181     ZE W1, W3
005FA8  9040BE     MOV.B [W14+3], W1
005FAA  FB8081     ZE W1, W1
005FAC  418081     ADD W3, W1, W1
005FAE  410081     ADD W2, W1, W1
005FB0  784091     MOV.B [W1], W1
005FB2  784801     MOV.B W1, [W0]
169:                       }
170:                       strcmp->Real_len = cnt2; //
005FC4  90003E     MOV [W14+6], W0
005FC6  9040BE     MOV.B [W14+3], W1
005FC8  984831     MOV.B W1, [W0+11]
171:                       return true;
005FCA  B3C010     MOV.B #0x1, W0
005FCC  370004     BRA 0x5FD6
172:                   }
173:                   strcmp->Real_len = 0;
005FCE  90003E     MOV [W14+6], W0
005FD0  EB4080     CLR.B W1
005FD2  984831     MOV.B W1, [W0+11]
174:                   return false;
005FD4  EB4000     CLR.B W0
175:               }
005FD6  FA8000     ULNK
005FD8  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 
180:               Input: UARTn
181:               Output: 
182:               Notice256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data) {//, const uint8_t get_size) {//'\0'
005FDA  FA0006     LNK #0x6
005FDC  980710     MOV W0, [W14+2]
005FDE  980721     MOV W1, [W14+4]
185:                   uint8_t byte = 0;
005FE0  EB4000     CLR.B W0
005FE2  784F00     MOV.B W0, [W14]
186:                   while (1) {
187:                       if (f_uart(Get_Data + byte))
005FE4  FB801E     ZE [W14], W0
005FE6  9000AE     MOV [W14+4], W1
005FE8  408000     ADD W1, W0, W0
005FEA  90009E     MOV [W14+2], W1
005FEC  010001     CALL W1
005FEE  E00400     CP0.B W0
005FF0  320002     BRA Z, 0x5FF6
188:                           byte++;
005FF2  E84F1E     INC.B [W14], [W14]
189:                       else
190:                           break;
191:                   }
005FF4  37FFF7     BRA 0x5FE4
192:                   return byte;
005FF6  78401E     MOV.B [W14], W0
193:               }
005FF8  FA8000     ULNK
005FFA  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 
198:               Input: 
199:               Output: 
200:               Notice
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
005FFC  FA0004     LNK #0x4
005FFE  980710     MOV W0, [W14+2]
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
006000  000000     NOP
006002  90009E     MOV [W14+2], W1
006004  78000E     MOV W14, W0
006006  010001     CALL W1
006008  E00400     CP0.B W0
00600A  3AFFFB     BRA NZ, 0x6002
205:               }
00600C  FA8000     ULNK
206:               //UARTGetData
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//505050
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/PCF8583.c  ----------------------------------
1:                 #include <PCF8583.h>
2:                 #include <I2C.h>
3:                 #include "Common.h"
4:                 
5:                 #define PCF_ADD 0xA2//
6:                 #define PCF_CON_STA 0x00//PCF8583
7:                 
8:                 //typedef enum {
9:                 //    con = 0, /* sec_100 = 1, sec = 2, min = 3, hours = 4, year = 5, months = 6, */timer = 7,
10:                //    alarm_con = 8, alarm_reg = 9
11:                //} PCF_Reg;
12:                
13:                void PCF8583_Init(void) {
006B10  FA0000     LNK #0x0
14:                    TRISBbits.TRISB13 = 1; //RTCC
006B12  A8A2C9     BSET 0x2C9, #5
15:                
16:                }
006B14  FA8000     ULNK
006B16  060000     RETURN
17:                
18:                void PCF8583_SetTime(uint32_t* timestamp) {//1s2s
006B18  FA001C     LNK #0x1C
006B1A  781F88     MOV W8, [W15++]
006B1C  980F50     MOV W0, [W14+26]
19:                    struct tm time_tmp;
20:                    time_tmp = *gmtime((time_t*) timestamp);
006B1E  90085E     MOV [W14+26], W0
006B20  07CE17     RCALL 0x750
006B22  090008     REPEAT #0x8
006B24  781F30     MOV [W0++], [W14++]
006B26  B1012E     SUB #0x12, W14
006B28  B10120     SUB #0x12, W0
21:                    uint8_t tmp[8] = {0x85, 00}; // 05
006B2A  4700F2     ADD W14, #0x12, W1
006B2C  090003     REPEAT #0x3
006B2E  EB1880     CLR [W1++]
006B30  B3C850     MOV.B #0x85, W0
006B32  985720     MOV.B W0, [W14+18]
22:                    tmp[2] = DCH(time_tmp.tm_sec);
006B34  78001E     MOV [W14], W0
006B36  784000     MOV.B W0, W0
006B38  07FDAD     RCALL DCH
006B3A  985740     MOV.B W0, [W14+20]
23:                    tmp[3] = DCH(time_tmp.tm_min);
006B3C  90001E     MOV [W14+2], W0
006B3E  784000     MOV.B W0, W0
006B40  07FDA9     RCALL DCH
006B42  985750     MOV.B W0, [W14+21]
24:                    tmp[4] = DCH(time_tmp.tm_hour) & 0x3F;
006B44  90002E     MOV [W14+4], W0
006B46  784000     MOV.B W0, W0
006B48  07FDA5     RCALL DCH
006B4A  B243F0     AND.B #0x3F, W0
006B4C  985760     MOV.B W0, [W14+22]
25:                    tmp[5] = (GetMod(time_tmp.tm_year + 1900, 2) << 6) + (DCH(time_tmp.tm_mday) & 0x3F);
006B4E  9000DE     MOV [W14+10], W1
006B50  2076C0     MOV #0x76C, W0
006B52  408000     ADD W1, W0, W0
006B54  B3C021     MOV.B #0x2, W1
006B56  07FE56     RCALL GetMod
006B58  200061     MOV #0x6, W1
006B5A  DD0401     SL W0, W1, W8
006B5C  90003E     MOV [W14+6], W0
006B5E  784000     MOV.B W0, W0
006B60  07FD99     RCALL DCH
006B62  B243F0     AND.B #0x3F, W0
006B64  444000     ADD.B W8, W0, W0
006B66  985770     MOV.B W0, [W14+23]
26:                    tmp[6] = (DCH(time_tmp.tm_wday) << 5)+(DCH(time_tmp.tm_mon + 1) & 0x1F); //tm10
006B68  90006E     MOV [W14+12], W0
006B6A  784000     MOV.B W0, W0
006B6C  07FD93     RCALL DCH
006B6E  200051     MOV #0x5, W1
006B70  DD0401     SL W0, W1, W8
006B72  90004E     MOV [W14+8], W0
006B74  784000     MOV.B W0, W0
006B76  E84000     INC.B W0, W0
006B78  07FD8D     RCALL DCH
006B7A  60407F     AND.B W0, #0x1F, W0
006B7C  444000     ADD.B W8, W0, W0
006B7E  985F00     MOV.B W0, [W14+24]
27:                    tmp[7] = 0; //
006B80  EB4000     CLR.B W0
006B82  985F10     MOV.B W0, [W14+25]
28:                    //    tmp[8] = 0xB0; //0x90; //
29:                    //    tmp[9] = 00; //
30:                    //    tmp[10] = 4; //GetMod(alarmtime, 30); //
31:                    //    tmp[11] = 0; //GetMod(alarmtime / 30, 60); //
32:                    //    tmp[12] = 0; //GetMod(alarmtime / 1800, 60); //
33:                    //    tmp[13] = tmp[14] = 0; //=0
34:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};    
35:                    i2c1_state = S_MASTER_IDLE;//123
006B84  EF6828     CLR.B i2c1_state
36:                    i2c_buf.operatcode = PCF_ADD;
006B86  21EA20     MOV #0x1EA2, W0
006B88  B3CA21     MOV.B #0xA2, W1
006B8A  784801     MOV.B W1, [W0]
37:                    i2c_buf.address = PCF_CON_STA;
006B8C  EB0000     CLR W0
006B8E  88F520     MOV W0, 0x1EA4
38:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
006B90  21EA60     MOV #0x1EA6, W0
006B92  B3C081     MOV.B #0x8, W1
006B94  784801     MOV.B W1, [W0]
39:                    i2c_buf.pbuffer = tmp;
006B96  470072     ADD W14, #0x12, W0
006B98  88F540     MOV W0, 0x1EA8
40:                    i2c_buf.flag.F_IsSelectiveMode = 1;
006B9A  80F550     MOV 0x1EAA, W0
006B9C  A00000     BSET W0, #0
006B9E  88F550     MOV W0, 0x1EAA
41:                    i2c_buf.flag.F_WriteOrRead = 0;
006BA0  80F550     MOV 0x1EAA, W0
006BA2  A12000     BCLR W0, #2
006BA4  88F550     MOV W0, 0x1EAA
42:                    i2c_buf.flag.F_Is16bitsDevice = 0;
006BA6  80F550     MOV 0x1EAA, W0
006BA8  A11000     BCLR W0, #1
006BAA  88F550     MOV W0, 0x1EAA
43:                    IFS1bits.MI2C1IF = 1;
006BAC  A82086     BSET IFS1, #1
44:                
45:                    while (i2c1_state != S_MASTER_Finish); //
006BAE  000000     NOP
006BB0  BFC828     MOV.B i2c1_state, WREG
006BB2  504FED     SUB.B W0, #0xD, [W15]
006BB4  3AFFFD     BRA NZ, 0x6BB0
46:                    //    while (IFS1bits.MI2C1IF);
47:                    //    while (i2c1_state != S_MASTER_IDLE);
48:                }
006BB6  78044F     MOV [--W15], W8
006BB8  FA8000     ULNK
006BBA  060000     RETURN
49:                
50:                void PCF8583_SetAlarmTime(struct tm alarmtime) {
006BBC  FA0008     LNK #0x8
51:                    uint8_t tmp[7] = {0x90, 00}; //cat24c512 0xA8 05
006BBE  090002     REPEAT #0x2
006BC0  EB1F00     CLR [W14++]
006BC2  EB5F00     CLR.B [W14++]
006BC4  B1007E     SUB #0x7, W14
006BC6  B3C900     MOV.B #0x90, W0
006BC8  784F00     MOV.B W0, [W14]
52:                    //    tmp[8] = 0xB0; //0x90; //
53:                    //    tmp[9] = 00; //
54:                    tmp[2] = DCH(alarmtime.tm_sec); //GetMod(alarmtime, 30); //
006BCA  97B04E     MOV [W14-24], W0
006BCC  784000     MOV.B W0, W0
006BCE  07FD62     RCALL DCH
006BD0  984720     MOV.B W0, [W14+2]
55:                    tmp[3] = DCH(alarmtime.tm_min); //GetMod(alarmtime / 30, 60); //
006BD2  97B05E     MOV [W14-22], W0
006BD4  784000     MOV.B W0, W0
006BD6  07FD5E     RCALL DCH
006BD8  984730     MOV.B W0, [W14+3]
56:                    tmp[4] = DCH(alarmtime.tm_hour); //GetMod(alarmtime / 1800, 60); //
006BDA  97B06E     MOV [W14-20], W0
006BDC  784000     MOV.B W0, W0
006BDE  07FD5A     RCALL DCH
006BE0  984740     MOV.B W0, [W14+4]
57:                    tmp[5] = tmp[6] = 0; //=0
006BE2  EB4000     CLR.B W0
006BE4  984760     MOV.B W0, [W14+6]
006BE6  90406E     MOV.B [W14+6], W0
006BE8  984750     MOV.B W0, [W14+5]
58:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};
59:                    i2c_buf.operatcode = PCF_ADD;
006BEA  21EA20     MOV #0x1EA2, W0
006BEC  B3CA21     MOV.B #0xA2, W1
006BEE  784801     MOV.B W1, [W0]
60:                    i2c_buf.address = PCF_CON_STA + 8;
006BF0  200080     MOV #0x8, W0
006BF2  88F520     MOV W0, 0x1EA4
61:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
006BF4  21EA60     MOV #0x1EA6, W0
006BF6  B3C071     MOV.B #0x7, W1
006BF8  784801     MOV.B W1, [W0]
62:                    i2c_buf.pbuffer = tmp;
006BFA  88F54E     MOV W14, 0x1EA8
63:                    i2c_buf.flag.F_IsSelectiveMode = 1;
006BFC  80F550     MOV 0x1EAA, W0
006BFE  A00000     BSET W0, #0
006C00  88F550     MOV W0, 0x1EAA
64:                    i2c_buf.flag.F_WriteOrRead = 0;
006C02  80F550     MOV 0x1EAA, W0
006C04  A12000     BCLR W0, #2
006C06  88F550     MOV W0, 0x1EAA
65:                    i2c_buf.flag.F_Is16bitsDevice = 0;
006C08  80F550     MOV 0x1EAA, W0
006C0A  A11000     BCLR W0, #1
006C0C  88F550     MOV W0, 0x1EAA
66:                    i2c1_state = S_MASTER_IDLE;
006C0E  EF6828     CLR.B i2c1_state
67:                    IFS1bits.MI2C1IF = 1;
006C10  A82086     BSET IFS1, #1
68:                
69:                    while (i2c1_state != S_MASTER_Finish); //
006C12  000000     NOP
006C14  BFC828     MOV.B i2c1_state, WREG
006C16  504FED     SUB.B W0, #0xD, [W15]
006C18  3AFFFD     BRA NZ, 0x6C14
70:                }
006C1A  FA8000     ULNK
006C1C  060000     RETURN
71:                
72:                uint32_t PCF8583_ReadTime(void) {
006C1E  FA0018     LNK #0x18
73:                    struct tm time_tmp; //timestamp
74:                
75:                    uint8_t tmp[5] = {0x03, 00}; //cat24c512 0xA8 
006C20  4700F2     ADD W14, #0x12, W1
006C22  090001     REPEAT #0x1
006C24  EB1880     CLR [W1++]
006C26  EB5880     CLR.B [W1++]
006C28  B3C030     MOV.B #0x3, W0
006C2A  985720     MOV.B W0, [W14+18]
76:                    i2c_buf.operatcode = PCF_ADD;
006C2C  21EA20     MOV #0x1EA2, W0
006C2E  B3CA21     MOV.B #0xA2, W1
006C30  784801     MOV.B W1, [W0]
77:                    i2c_buf.address = PCF_CON_STA + 2; //
006C32  200020     MOV #0x2, W0
006C34  88F520     MOV W0, 0x1EA4
78:                    i2c_buf.length = sizeof (tmp) / sizeof (uint8_t);
006C36  21EA60     MOV #0x1EA6, W0
006C38  B3C051     MOV.B #0x5, W1
006C3A  784801     MOV.B W1, [W0]
79:                    i2c_buf.pbuffer = tmp;
006C3C  470072     ADD W14, #0x12, W0
006C3E  88F540     MOV W0, 0x1EA8
80:                    i2c_buf.flag.F_IsSelectiveMode = 1;
006C40  80F550     MOV 0x1EAA, W0
006C42  A00000     BSET W0, #0
006C44  88F550     MOV W0, 0x1EAA
81:                    i2c_buf.flag.F_WriteOrRead = 1;
006C46  80F550     MOV 0x1EAA, W0
006C48  A02000     BSET W0, #2
006C4A  88F550     MOV W0, 0x1EAA
82:                    i2c_buf.flag.F_Is16bitsDevice = 0;
006C4C  80F550     MOV 0x1EAA, W0
006C4E  A11000     BCLR W0, #1
006C50  88F550     MOV W0, 0x1EAA
83:                    i2c1_state = S_MASTER_IDLE;
006C52  EF6828     CLR.B i2c1_state
84:                    IFS1bits.MI2C1IF = 1;
006C54  A82086     BSET IFS1, #1
85:                    while (i2c1_state != S_MASTER_Finish); //
006C56  000000     NOP
006C58  BFC828     MOV.B i2c1_state, WREG
006C5A  504FED     SUB.B W0, #0xD, [W15]
006C5C  3AFFFD     BRA NZ, 0x6C58
86:                
87:                    time_tmp.tm_sec = HCD(tmp[0]); //
006C5E  90502E     MOV.B [W14+18], W0
006C60  07FD0C     RCALL HCD
006C62  FB8000     ZE W0, W0
006C64  780F00     MOV W0, [W14]
88:                    time_tmp.tm_min = HCD(tmp[1]); //
006C66  90503E     MOV.B [W14+19], W0
006C68  07FD08     RCALL HCD
006C6A  FB8000     ZE W0, W0
006C6C  980710     MOV W0, [W14+2]
89:                    time_tmp.tm_hour = HCD(tmp[2]&0x3F); //
006C6E  90504E     MOV.B [W14+20], W0
006C70  B243F0     AND.B #0x3F, W0
006C72  07FD03     RCALL HCD
006C74  FB8000     ZE W0, W0
006C76  980720     MOV W0, [W14+4]
90:                    time_tmp.tm_mday = HCD(tmp[3]&0x3F); //
006C78  90505E     MOV.B [W14+21], W0
006C7A  B243F0     AND.B #0x3F, W0
006C7C  07FCFE     RCALL HCD
006C7E  FB8000     ZE W0, W0
006C80  980730     MOV W0, [W14+6]
91:                    time_tmp.tm_mon = HCD(tmp[4]&0x1F) - 1; //
006C82  90506E     MOV.B [W14+22], W0
006C84  60407F     AND.B W0, #0x1F, W0
006C86  07FCF9     RCALL HCD
006C88  FB8000     ZE W0, W0
006C8A  E90000     DEC W0, W0
006C8C  980740     MOV W0, [W14+8]
92:                    time_tmp.tm_year = (uint16_t) (tmp[3] >> 6) + 2016 - 1900; //2016E2ROM
006C8E  90505E     MOV.B [W14+21], W0
006C90  FB8000     ZE W0, W0
006C92  DE0046     LSR W0, #6, W0
006C94  784000     MOV.B W0, W0
006C96  FB8000     ZE W0, W0
006C98  B00740     ADD #0x74, W0
006C9A  980750     MOV W0, [W14+10]
93:                
94:                    return mktime(&time_tmp);
006C9C  78000E     MOV W14, W0
006C9E  07CD5C     RCALL 0x758
95:                }
006CA0  FA8000     ULNK
006CA2  060000     RETURN
96:                
97:                void PCF8583_SetStatusReg(uint8_t reg) {//
006CA4  FA0002     LNK #0x2
006CA6  784F00     MOV.B W0, [W14]
98:                    //    uint8_t tmp = 0x05; // 05
99:                    i2c_buf.operatcode = PCF_ADD;
006CA8  21EA20     MOV #0x1EA2, W0
006CAA  B3CA21     MOV.B #0xA2, W1
006CAC  784801     MOV.B W1, [W0]
100:                   i2c_buf.address = PCF_CON_STA;
006CAE  EB0000     CLR W0
006CB0  88F520     MOV W0, 0x1EA4
101:                   i2c_buf.length = 1;
006CB2  21EA60     MOV #0x1EA6, W0
006CB4  B3C011     MOV.B #0x1, W1
006CB6  784801     MOV.B W1, [W0]
102:                   i2c_buf.pbuffer = &reg;
006CB8  88F54E     MOV W14, 0x1EA8
103:                   i2c_buf.flag.F_IsSelectiveMode = 1;
006CBA  80F550     MOV 0x1EAA, W0
006CBC  A00000     BSET W0, #0
006CBE  88F550     MOV W0, 0x1EAA
104:                   i2c_buf.flag.F_WriteOrRead = 0;
006CC0  80F550     MOV 0x1EAA, W0
006CC2  A12000     BCLR W0, #2
006CC4  88F550     MOV W0, 0x1EAA
105:                   i2c_buf.flag.F_Is16bitsDevice = 0;
006CC6  80F550     MOV 0x1EAA, W0
006CC8  A11000     BCLR W0, #1
006CCA  88F550     MOV W0, 0x1EAA
106:                   i2c1_state = S_MASTER_IDLE;
006CCC  EF6828     CLR.B i2c1_state
107:                   IFS1bits.MI2C1IF = 1;
006CCE  A82086     BSET IFS1, #1
108:                   while (i2c1_state != S_MASTER_Finish); //
006CD0  000000     NOP
006CD2  BFC828     MOV.B i2c1_state, WREG
006CD4  504FED     SUB.B W0, #0xD, [W15]
006CD6  3AFFFD     BRA NZ, 0x6CD2
109:               }
006CD8  FA8000     ULNK
006CDA  060000     RETURN
110:               
111:               void PCF8583_ReadStatus(uint8_t *tmp) {
006CDC  FA0002     LNK #0x2
006CDE  780F00     MOV W0, [W14]
112:                   //    struct tm time_tmp; //timestamp
113:               
114:                   //    uint8_t tmp[16] = {0x03, 00}; //cat24c512 0xA8 
115:                   i2c_buf.operatcode = PCF_ADD;
006CE0  21EA20     MOV #0x1EA2, W0
006CE2  B3CA21     MOV.B #0xA2, W1
006CE4  784801     MOV.B W1, [W0]
116:                   i2c_buf.address = PCF_CON_STA; //
006CE6  EB0000     CLR W0
006CE8  88F520     MOV W0, 0x1EA4
117:                   i2c_buf.length = 16;
006CEA  21EA60     MOV #0x1EA6, W0
006CEC  B3C101     MOV.B #0x10, W1
006CEE  784801     MOV.B W1, [W0]
118:                   i2c_buf.pbuffer = tmp;
006CF0  78009E     MOV [W14], W1
006CF2  88F541     MOV W1, 0x1EA8
119:                   i2c_buf.flag.F_IsSelectiveMode = 1;
006CF4  80F550     MOV 0x1EAA, W0
006CF6  A00000     BSET W0, #0
006CF8  88F550     MOV W0, 0x1EAA
120:                   i2c_buf.flag.F_WriteOrRead = 1;
006CFA  80F550     MOV 0x1EAA, W0
006CFC  A02000     BSET W0, #2
006CFE  88F550     MOV W0, 0x1EAA
121:                   i2c_buf.flag.F_Is16bitsDevice = 0;
006D00  80F550     MOV 0x1EAA, W0
006D02  A11000     BCLR W0, #1
006D04  88F550     MOV W0, 0x1EAA
122:                   i2c1_state = S_MASTER_IDLE;
006D06  EF6828     CLR.B i2c1_state
123:                   IFS1bits.MI2C1IF = 1;
006D08  A82086     BSET IFS1, #1
124:                   while (i2c1_state != S_MASTER_Finish); //
006D0A  000000     NOP
006D0C  BFC828     MOV.B i2c1_state, WREG
006D0E  504FED     SUB.B W0, #0xD, [W15]
006D10  3AFFFD     BRA NZ, 0x6D0C
125:               
126:                   //    time_tmp.tm_sec = HCD(tmp[0]); //
127:                   //    time_tmp.tm_min = HCD(tmp[1]); //
128:                   //    time_tmp.tm_hour = HCD(tmp[2]&0x3F); //
129:                   //    time_tmp.tm_mday = HCD(tmp[3]&0x3F); //
130:                   //    time_tmp.tm_mon = HCD(tmp[4]&0x1F) - 1; //
131:                   //    time_tmp.tm_year = (uint16_t) (tmp[3] >> 6) + 2016 - 1900; //2016E2ROM
132:               
133:                   //    return mktime(&time_tmp);
134:               }
006D12  FA8000     ULNK
135:               
136:               //void PCF8583_CelarFlag(void) {
137:               //    uint8_t tmp = 0x05; // 05
138:               //    i2c_buf.operatcode = PCF_ADD;
139:               //    i2c_buf.address = PCF_CON_STA;
140:               //    i2c_buf.length = 1;
141:               //    i2c_buf.pbuffer = &tmp;
142:               //    i2c_buf.flag.F_IsSelectiveMode = 1;
143:               //    i2c_buf.flag.F_WriteOrRead = 0;
144:               //    i2c_buf.flag.F_Is16bitsDevice = 0;
145:               //    i2c1_state = S_MASTER_IDLE;
146:               //    IFS1bits.MI2C1IF = 1;
147:               //    while (i2c1_state != S_MASTER_Finish); //
148:               //}
149:               
150:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/PC.c  ---------------------------------------
1:                 //#include "pc.h"
2:                 #include "includes.h"
3:                 
4:                 void PCCop_Init(void)
5:                 {
007C72  FA0000     LNK #0x0
6:                     RS485_Init();
007C74  07FEB7     RCALL RS485_Init
7:                 }
007C76  FA8000     ULNK
007C78  060000     RETURN
8:                 
9:                 
10:                void PCCopTask(void*arg) {
007C7A  FA0002     LNK #0x2
007C7C  780F00     MOV W0, [W14]
11:                
12:                    while (1) {
13:                        RS485SendChar(0x31);
007C7E  B3C310     MOV.B #0x31, W0
007C80  07FEC2     RCALL RS485SendChar
14:                        //        RS485SendString("ErrCode:\r\n", 10);
15:                        OSTimeDlyHMSM(0, 0, 1, 0);
007C82  EB0180     CLR W3
007C84  B3C012     MOV.B #0x1, W2
007C86  EB4080     CLR.B W1
007C88  EB4000     CLR.B W0
007C8A  07FAF3     RCALL OSTimeDlyHMSM
16:                    }
007C8C  37FFF8     BRA 0x7C7E
17:                }
18:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/HL6528.c  -----------------------------------
1:                 #include "HL6528.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 #include <stdlib.h>
5:                 #include  <libq.h>
6:                 #include "WCG.h"
7:                 //#include "includes.h"
8:                 //#include <stdbool.h>
9:                 //#include "cJSON.h"
10:                
11:                
12:                //extern OS_EVENT* sem1, *sem2; //
13:                
14:                //struct ATCommand {
15:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
16:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
17:                const uint8_t AT[] = {"AT\r\n"};
18:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
19:                const uint8_t OK[] = {"OK"};
20:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
21:                const uint8_t READY[] = {"+CPIN: READY"};
22:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
23:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
24:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
25:                const uint8_t _5[] = {",5"};
26:                const uint8_t _1[] = {",1"};
27:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
28:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
29:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
30:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
31:                uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.140.140\",11811\r\n\n"};
32:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
33:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//ONENET
34:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
35:                const uint8_t CONNECT[] = {"CONNECT"};
36:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
37:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
38:                
39:                
40:                static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
41:                
42:                void HL6528_Init(void) {
006010  FA0000     LNK #0x0
43:                    //
44:                    PWRON_TRIS = 0; //PWN_ON 6528
006012  A9C2D8     BCLR TRISD, #6
45:                    PWR_TRIS = 0; //6528
006014  A9E2D8     BCLR TRISD, #7
46:                    DSR_TRIS = 0; //    
006016  A922D8     BCLR TRISD, #1
47:                    DTR_TRIS = 0; //
006018  A902D8     BCLR TRISD, #0
48:                    RTS_TRIS = 0; //
00601A  A982D8     BCLR TRISD, #4
49:                    CTS_TRIS = 0; //  
00601C  A9A2D8     BCLR TRISD, #5
50:                    PWR = 0;
00601E  A9E2DC     BCLR LATD, #7
51:                    PWRON = 0;
006020  A9C2DC     BCLR LATD, #6
52:                    CTS = 0;
006022  A9A2DC     BCLR LATD, #5
53:                    RTS = 0;
006024  A982DC     BCLR LATD, #4
54:                    DSR = 0;
006026  A922DC     BCLR LATD, #1
55:                    DTR = 0;
006028  A902DC     BCLR LATD, #0
56:                    //    UART2_Init();
57:                }
00602A  FA8000     ULNK
00602C  060000     RETURN
58:                
59:                bool HL6528_DialingIsERR(void) {
00602E  FA001A     LNK #0x1A
60:                    uint8_t sta;
61:                    uint8_t ip_port[25] = {'\0'};
006030  4700E1     ADD W14, #0x1, W1
006032  090018     REPEAT #0x18
006034  EB5880     CLR.B [W1++]
62:                
63:                    //    HL6528_GetIP_Port();
64:                    PWR = 1;
006036  A8E2DC     BSET LATD, #7
65:                    PWRON = 1;
006038  A8C2DC     BSET LATD, #6
66:                    CTS = 0;
00603A  A9A2DC     BCLR LATD, #5
67:                    RTS = 0;
00603C  A982DC     BCLR LATD, #4
68:                    DSR = 0;
00603E  A922DC     BCLR LATD, #1
69:                    DTR = 0;
006040  A902DC     BCLR LATD, #0
70:                    OSTimeDlyHMSM(0, 0, 1, 0);
006042  EB0180     CLR W3
006044  200012     MOV #0x1, W2
006046  EB0080     CLR W1
006048  EB0000     CLR W0
00604A  070913     RCALL OSTimeDlyHMSM
71:                    if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
00604C  B3C024     MOV.B #0x2, W4
00604E  B3C023     MOV.B #0x2, W3
006050  EB0100     CLR W2
006052  29E2F1     MOV #0x9E2F, W1
006054  29E160     MOV #0x9E16, W0
006056  07007E     RCALL _HL6528SendCmd
006058  E00400     CP0.B W0
00605A  32003A     BRA Z, 0x60D0
72:                        if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
00605C  B3C024     MOV.B #0x2, W4
00605E  B3C083     MOV.B #0x8, W3
006060  EB0100     CLR W2
006062  29E3D1     MOV #0x9E3D, W1
006064  29E320     MOV #0x9E32, W0
006066  070076     RCALL _HL6528SendCmd
006068  E00400     CP0.B W0
00606A  32002F     BRA Z, 0x60CA
73:                            if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//
00606C  B3C0A4     MOV.B #0xA, W4
00606E  B3C023     MOV.B #0x2, W3
006070  29E6E2     MOV #0x9E6E, W2
006072  29E6B1     MOV #0x9E6B, W1
006074  29E540     MOV #0x9E54, W0
006076  07006E     RCALL _HL6528SendCmd
006078  E00400     CP0.B W0
00607A  320024     BRA Z, 0x60C4
74:                                if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
00607C  B3C034     MOV.B #0x3, W4
00607E  B3C023     MOV.B #0x2, W3
006080  EB0100     CLR W2
006082  29E2F1     MOV #0x9E2F, W1
006084  29E7B0     MOV #0x9E7B, W0
006086  070066     RCALL _HL6528SendCmd
006088  E00400     CP0.B W0
00608A  320019     BRA Z, 0x60BE
75:                                    //                    HL6528_GetIP_Port(); //IP
76:                                    if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
00608C  B3C034     MOV.B #0x3, W4
00608E  B3C023     MOV.B #0x2, W3
006090  EB0100     CLR W2
006092  29E2F1     MOV #0x9E2F, W1
006094  21E020     MOV #0x1E02, W0
006096  07005E     RCALL _HL6528SendCmd
006098  E00400     CP0.B W0
00609A  32000E     BRA Z, 0x60B8
77:                                        if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 7, 5)) {
00609C  B3C054     MOV.B #0x5, W4
00609E  B3C073     MOV.B #0x7, W3
0060A0  EB0100     CLR W2
0060A2  29ED71     MOV #0x9ED7, W1
0060A4  29EC60     MOV #0x9EC6, W0
0060A6  070056     RCALL _HL6528SendCmd
0060A8  E00400     CP0.B W0
0060AA  320003     BRA Z, 0x60B2
78:                                            sta = 0;
0060AC  EB4000     CLR.B W0
0060AE  784F00     MOV.B W0, [W14]
0060B0  370011     BRA 0x60D4
79:                                        } else
80:                                            sta = 6; //TCP
0060B2  B3C060     MOV.B #0x6, W0
0060B4  784F00     MOV.B W0, [W14]
0060B6  37000E     BRA 0x60D4
81:                                    } else
82:                                        sta = 5; //TCP
0060B8  B3C050     MOV.B #0x5, W0
0060BA  784F00     MOV.B W0, [W14]
0060BC  37000B     BRA 0x60D4
83:                                } else
84:                                    sta = 4; //APN
0060BE  B3C040     MOV.B #0x4, W0
0060C0  784F00     MOV.B W0, [W14]
0060C2  370008     BRA 0x60D4
85:                            } else
86:                                sta = 3; //
0060C4  B3C030     MOV.B #0x3, W0
0060C6  784F00     MOV.B W0, [W14]
0060C8  370005     BRA 0x60D4
87:                        } else
88:                            sta = 2; //
0060CA  B3C020     MOV.B #0x2, W0
0060CC  784F00     MOV.B W0, [W14]
0060CE  370002     BRA 0x60D4
89:                    } else
90:                        sta = 1; //
0060D0  B3C010     MOV.B #0x1, W0
0060D2  784F00     MOV.B W0, [W14]
91:                    return sta;
0060D4  FB801E     ZE [W14], W0
0060D6  EA0000     NEG W0, W0
0060D8  DE004F     LSR W0, #15, W0
0060DA  784000     MOV.B W0, W0
92:                }
0060DC  FA8000     ULNK
0060DE  060000     RETURN
93:                
94:                void HL6528_Close(void) {
0060E0  FA0020     LNK #0x20
95:                    uint8_t tmp[20];
96:                    StrCmp stcp;
97:                    ClearBuffer(BufferRead_UART2);
0060E2  25DE00     MOV #0x5DE0, W0
0060E4  07FF8B     RCALL ClearBuffer
98:                    do {
99:                        DSR = 1; //AT
0060E6  A822DC     BSET LATD, #1
100:                       OSTimeDlyHMSM(0, 0, 1, 0); //1s
0060E8  EB0180     CLR W3
0060EA  200012     MOV #0x1, W2
0060EC  EB0080     CLR W1
0060EE  EB0000     CLR W0
0060F0  0708C0     RCALL OSTimeDlyHMSM
101:                       DSR = 0; //
0060F2  A922DC     BCLR LATD, #1
102:                       stcp.SourceData = tmp;
0060F4  980F2E     MOV W14, [W14+20]
103:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //mark
0060F6  90082E     MOV [W14+20], W0
0060F8  780080     MOV W0, W1
0060FA  25DE00     MOV #0x5DE0, W0
0060FC  07FF6E     RCALL UARTGetData
0060FE  985760     MOV.B W0, [W14+22]
104:                       stcp.CheckData = (uint8_t*) OK;
006100  29E2F0     MOV #0x9E2F, W0
006102  980F40     MOV W0, [W14+24]
105:                       stcp.Check_len = 2;
006104  B3C020     MOV.B #0x2, W0
006106  985F20     MOV.B W0, [W14+26]
106:                       stcp.GetData = NULL;
006108  EB0000     CLR W0
00610A  980F60     MOV W0, [W14+28]
107:                       stcp.Get_len = 0;
00610C  EB4000     CLR.B W0
00610E  985F60     MOV.B W0, [W14+30]
108:                       stcp.Real_len = 0;
006110  EB4000     CLR.B W0
006112  985F70     MOV.B W0, [W14+31]
109:                   } while (UARTDataIsRight(&stcp)); //OK
006114  470074     ADD W14, #0x14, W0
006116  07FE9E     RCALL UARTDataIsRight
006118  E00400     CP0.B W0
00611A  3AFFE5     BRA NZ, 0x60E6
110:                   if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//TCPID
00611C  B3C024     MOV.B #0x2, W4
00611E  B3C023     MOV.B #0x2, W3
006120  EB0100     CLR W2
006122  29E2F1     MOV #0x9E2F, W1
006124  29EDF0     MOV #0x9EDF, W0
006126  070016     RCALL _HL6528SendCmd
006128  E00400     CP0.B W0
00612A  320006     BRA Z, 0x6138
111:                       HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
00612C  B3C024     MOV.B #0x2, W4
00612E  B3C023     MOV.B #0x2, W3
006130  EB0100     CLR W2
006132  29E2F1     MOV #0x9E2F, W1
006134  29EF20     MOV #0x9EF2, W0
006136  07000E     RCALL _HL6528SendCmd
112:                   OSTimeDlyHMSM(0, 0, 1, 0); //1s    
006138  EB0180     CLR W3
00613A  200012     MOV #0x1, W2
00613C  EB0080     CLR W1
00613E  EB0000     CLR W0
006140  070898     RCALL OSTimeDlyHMSM
113:                   PWR = 0; //
006142  A9E2DC     BCLR LATD, #7
114:                   PWRON = 0; //
006144  A9C2DC     BCLR LATD, #6
115:                   CTS = 0; //
006146  A9A2DC     BCLR LATD, #5
116:                   RTS = 0; //
006148  A982DC     BCLR LATD, #4
117:                   DSR = 0; //
00614A  A922DC     BCLR LATD, #1
118:                   DTR = 0; //
00614C  A902DC     BCLR LATD, #0
119:                   UART2_Close();
00614E  070ACE     RCALL UART2_Close
120:               }
006150  FA8000     ULNK
006152  060000     RETURN
121:               
122:               /*ss**/
123:               static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
006154  FA0048     LNK #0x48
006156  982700     MOV W0, [W14+64]
006158  982711     MOV W1, [W14+66]
00615A  982722     MOV W2, [W14+68]
00615C  98C763     MOV.B W3, [W14+70]
00615E  98C774     MOV.B W4, [W14+71]
124:                   uint8_t cnt_tmp = 0;
006160  EB4000     CLR.B W0
006162  784F00     MOV.B W0, [W14]
125:                   bool b_sta = false;
006164  EB4000     CLR.B W0
006166  984710     MOV.B W0, [W14+1]
126:                   StrCmp stcp;
127:                   uint8_t tmp[50];
128:                   do {
129:                       cnt_tmp += 1;
006168  E84F1E     INC.B [W14], [W14]
130:                       UART2_SendString(ss); //AT                               
00616A  90200E     MOV [W14+64], W0
00616C  070AD1     RCALL UART2_SendString
131:                       OSTimeDlyHMSM(0, 0, 3, 0); //1s
00616E  EB0180     CLR W3
006170  200032     MOV #0x3, W2
006172  EB0080     CLR W1
006174  EB0000     CLR W0
006176  07087D     RCALL OSTimeDlyHMSM
132:                       U2Rx4Byte();
006178  070B01     RCALL U2Rx4Byte
133:                       stcp.SourceData = tmp;
00617A  47006E     ADD W14, #0xE, W0
00617C  980710     MOV W0, [W14+2]
134:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData); //mark
00617E  90001E     MOV [W14+2], W0
006180  780080     MOV W0, W1
006182  25DE00     MOV #0x5DE0, W0
006184  07FF2A     RCALL UARTGetData
006186  984740     MOV.B W0, [W14+4]
135:                       stcp.CheckData = (uint8_t*) cs;
006188  90209E     MOV [W14+66], W1
00618A  980731     MOV W1, [W14+6]
136:                       stcp.Check_len = csl;
00618C  90C0EE     MOV.B [W14+70], W1
00618E  984F01     MOV.B W1, [W14+8]
137:                       stcp.GetData = NULL;
006190  EB0000     CLR W0
006192  980750     MOV W0, [W14+10]
138:                       stcp.Get_len = 0;
006194  EB4000     CLR.B W0
006196  984F40     MOV.B W0, [W14+12]
139:                       stcp.Real_len = 0;
006198  EB4000     CLR.B W0
00619A  984F50     MOV.B W0, [W14+13]
140:               
141:                       if (UARTDataIsRight(&stcp)) {
00619C  E8800E     INC2 W14, W0
00619E  07FE5A     RCALL UARTDataIsRight
0061A0  E00400     CP0.B W0
0061A2  320003     BRA Z, 0x61AA
142:                           b_sta = true;
0061A4  B3C010     MOV.B #0x1, W0
0061A6  984710     MOV.B W0, [W14+1]
143:                           break;
0061A8  37000F     BRA 0x61C8
144:                       }
145:               
146:                       if (cs1 != NULL) {//NULL
0061AA  90202E     MOV [W14+68], W0
0061AC  E00000     CP0 W0
0061AE  320009     BRA Z, 0x61C2
147:                           stcp.CheckData = (uint8_t*) cs1;
0061B0  9020AE     MOV [W14+68], W1
0061B2  980731     MOV W1, [W14+6]
148:                           if (UARTDataIsRight(&stcp)) {
0061B4  E8800E     INC2 W14, W0
0061B6  07FE4E     RCALL UARTDataIsRight
0061B8  E00400     CP0.B W0
0061BA  320003     BRA Z, 0x61C2
149:                               b_sta = true;
0061BC  B3C010     MOV.B #0x1, W0
0061BE  984710     MOV.B W0, [W14+1]
150:                               break;
0061C0  370003     BRA 0x61C8
151:                           }
152:                       }
153:               
154:                   } while (cnt > cnt_tmp);
0061C2  90C07E     MOV.B [W14+71], W0
0061C4  504F9E     SUB.B W0, [W14], [W15]
0061C6  3EFFD0     BRA GTU, 0x6168
155:                   ClearBuffer(BufferRead_UART2);
0061C8  25DE00     MOV #0x5DE0, W0
0061CA  07FF18     RCALL ClearBuffer
156:                   return b_sta;
0061CC  90401E     MOV.B [W14+1], W0
157:               }
0061CE  FA8000     ULNK
0061D0  060000     RETURN
158:               
159:               //static void HL6528_IOStart(void) {
160:               //    PWR = 1;
161:               //    PWRON = 1;
162:               //    CTS = 0;
163:               //    RTS = 0;
164:               //    DSR = 0;
165:               //    DTR = 0;
166:               //}
167:               //
168:               //static void HL6528_IOClose(void) {
169:               //    PWRON = 0;
170:               //    PWR = 0;
171:               //    CTS = 1;
172:               //    RTS = 1;
173:               //    DSR = 1;
174:               //    DTR = 1;
175:               //}
176:               
177:               void HL6528_GetIP_Port(void) {
0061D2  FA0020     LNK #0x20
178:                   uint8_t net_addr[25] = {'\0'};
0061D4  4700E2     ADD W14, #0x2, W1
0061D6  09000B     REPEAT #0xB
0061D8  EB1880     CLR [W1++]
0061DA  EB5880     CLR.B [W1++]
179:                   uint8_t str_tmp[4] = {1, 2, 3, 4};
0061DC  47017B     ADD W14, #0x1B, W2
0061DE  29F011     MOV #0x9F01, W1
0061E0  090003     REPEAT #0x3
0061E2  785931     MOV.B [W1++], [W2++]
180:                   uint8_t cnt;
181:                   uint8_t all_bytes = 0;
0061E4  EB4000     CLR.B W0
0061E6  984710     MOV.B W0, [W14+1]
182:                   
183:                   //
184:                   all_bytes = my_itoa(WGCIPbits.IP3, net_addr);
0061E8  BFC885     MOV.B 0x885, WREG
0061EA  FB8000     ZE W0, W0
0061EC  E8808E     INC2 W14, W1
0061EE  07031A     RCALL my_itoa
0061F0  984710     MOV.B W0, [W14+1]
185:                   net_addr[all_bytes] = '.';
0061F2  90401E     MOV.B [W14+1], W0
0061F4  FB8000     ZE W0, W0
0061F6  470000     ADD W14, W0, W0
0061F8  B3C2E1     MOV.B #0x2E, W1
0061FA  984021     MOV.B W1, [W0+2]
186:                   net_addr[all_bytes + 1] = '\0';
0061FC  90401E     MOV.B [W14+1], W0
0061FE  FB8000     ZE W0, W0
006200  E80000     INC W0, W0
006202  470000     ADD W14, W0, W0
006204  EB4080     CLR.B W1
006206  984021     MOV.B W1, [W0+2]
187:                   all_bytes = all_bytes + 1;
006208  90401E     MOV.B [W14+1], W0
00620A  E84000     INC.B W0, W0
00620C  984710     MOV.B W0, [W14+1]
188:               
189:                   all_bytes += my_itoa(WGCIPbits.IP2, str_tmp);
00620E  BFC884     MOV.B 0x884, WREG
006210  FB8000     ZE W0, W0
006212  4700FB     ADD W14, #0x1B, W1
006214  070307     RCALL my_itoa
006216  90409E     MOV.B [W14+1], W1
006218  40C000     ADD.B W1, W0, W0
00621A  984710     MOV.B W0, [W14+1]
190:                   strcat(net_addr, str_tmp);
00621C  4700FB     ADD W14, #0x1B, W1
00621E  E8800E     INC2 W14, W0
006220  07D327     RCALL 0x870
191:                   net_addr[all_bytes ] = '.';
006222  90401E     MOV.B [W14+1], W0
006224  FB8000     ZE W0, W0
006226  470000     ADD W14, W0, W0
006228  B3C2E1     MOV.B #0x2E, W1
00622A  984021     MOV.B W1, [W0+2]
192:                   net_addr[ all_bytes + 1] = '\0';
00622C  90401E     MOV.B [W14+1], W0
00622E  FB8000     ZE W0, W0
006230  E80000     INC W0, W0
006232  470000     ADD W14, W0, W0
006234  EB4080     CLR.B W1
006236  984021     MOV.B W1, [W0+2]
193:                   all_bytes = all_bytes + 1;
006238  90401E     MOV.B [W14+1], W0
00623A  E84000     INC.B W0, W0
00623C  984710     MOV.B W0, [W14+1]
194:               
195:                   all_bytes += my_itoa(WGCIPbits.IP1, str_tmp);
00623E  BFC883     MOV.B 0x883, WREG
006240  FB8000     ZE W0, W0
006242  4700FB     ADD W14, #0x1B, W1
006244  0702EF     RCALL my_itoa
006246  90409E     MOV.B [W14+1], W1
006248  40C000     ADD.B W1, W0, W0
00624A  984710     MOV.B W0, [W14+1]
196:                   strcat(net_addr, str_tmp);
00624C  4700FB     ADD W14, #0x1B, W1
00624E  E8800E     INC2 W14, W0
006250  07D30F     RCALL 0x870
197:                   net_addr[all_bytes ] = '.';
006252  90401E     MOV.B [W14+1], W0
006254  FB8000     ZE W0, W0
006256  470000     ADD W14, W0, W0
006258  B3C2E1     MOV.B #0x2E, W1
00625A  984021     MOV.B W1, [W0+2]
198:                   net_addr[ all_bytes + 1] = '\0';
00625C  90401E     MOV.B [W14+1], W0
00625E  FB8000     ZE W0, W0
006260  E80000     INC W0, W0
006262  470000     ADD W14, W0, W0
006264  EB4080     CLR.B W1
006266  984021     MOV.B W1, [W0+2]
199:                   all_bytes = all_bytes + 1;
006268  90401E     MOV.B [W14+1], W0
00626A  E84000     INC.B W0, W0
00626C  984710     MOV.B W0, [W14+1]
200:               
201:                   all_bytes += my_itoa(WGCIPbits.IP0, str_tmp);
00626E  BFC882     MOV.B WGCIPbits, WREG
006270  FB8000     ZE W0, W0
006272  4700FB     ADD W14, #0x1B, W1
006274  0702D7     RCALL my_itoa
006276  90409E     MOV.B [W14+1], W1
006278  40C000     ADD.B W1, W0, W0
00627A  984710     MOV.B W0, [W14+1]
202:                   strcat(net_addr, str_tmp);
00627C  4700FB     ADD W14, #0x1B, W1
00627E  E8800E     INC2 W14, W0
006280  07D2F7     RCALL 0x870
203:                   net_addr[ all_bytes ] = '"';
006282  90401E     MOV.B [W14+1], W0
006284  FB8000     ZE W0, W0
006286  470000     ADD W14, W0, W0
006288  B3C221     MOV.B #0x22, W1
00628A  984021     MOV.B W1, [W0+2]
204:                   net_addr[all_bytes + 1 ] = ',';
00628C  90401E     MOV.B [W14+1], W0
00628E  FB8000     ZE W0, W0
006290  E80000     INC W0, W0
006292  470000     ADD W14, W0, W0
006294  B3C2C1     MOV.B #0x2C, W1
006296  984021     MOV.B W1, [W0+2]
205:                   net_addr[ all_bytes + 2] = '\0';
006298  90401E     MOV.B [W14+1], W0
00629A  FB8000     ZE W0, W0
00629C  E88000     INC2 W0, W0
00629E  470000     ADD W14, W0, W0
0062A0  EB4080     CLR.B W1
0062A2  984021     MOV.B W1, [W0+2]
206:                   all_bytes = all_bytes + 2;
0062A4  90401E     MOV.B [W14+1], W0
0062A6  E8C000     INC2.B W0, W0
0062A8  984710     MOV.B W0, [W14+1]
207:               
208:                   all_bytes += my_itoa(WGCPORT, str_tmp);
0062AA  804430     MOV WGCPORT, W0
0062AC  4700FB     ADD W14, #0x1B, W1
0062AE  0702BA     RCALL my_itoa
0062B0  90409E     MOV.B [W14+1], W1
0062B2  40C000     ADD.B W1, W0, W0
0062B4  984710     MOV.B W0, [W14+1]
209:                   strcat(net_addr, str_tmp);
0062B6  4700FB     ADD W14, #0x1B, W1
0062B8  E8800E     INC2 W14, W0
0062BA  07D2DA     RCALL 0x870
210:                   net_addr[ all_bytes ] = '\r';
0062BC  90401E     MOV.B [W14+1], W0
0062BE  FB8000     ZE W0, W0
0062C0  470000     ADD W14, W0, W0
0062C2  B3C0D1     MOV.B #0xD, W1
0062C4  984021     MOV.B W1, [W0+2]
211:                   net_addr[ all_bytes + 1] = '\n';
0062C6  90401E     MOV.B [W14+1], W0
0062C8  FB8000     ZE W0, W0
0062CA  E80000     INC W0, W0
0062CC  470000     ADD W14, W0, W0
0062CE  B3C0A1     MOV.B #0xA, W1
0062D0  984021     MOV.B W1, [W0+2]
212:                   net_addr[ all_bytes + 2] = '\0';
0062D2  90401E     MOV.B [W14+1], W0
0062D4  FB8000     ZE W0, W0
0062D6  E88000     INC2 W0, W0
0062D8  470000     ADD W14, W0, W0
0062DA  EB4080     CLR.B W1
0062DC  984021     MOV.B W1, [W0+2]
213:                   all_bytes = all_bytes + 2;
0062DE  90401E     MOV.B [W14+1], W0
0062E0  E8C000     INC2.B W0, W0
0062E2  984710     MOV.B W0, [W14+1]
214:                   //   uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
215:                   for (cnt = 0; cnt < all_bytes; cnt++)
0062E4  EB4000     CLR.B W0
0062E6  784F00     MOV.B W0, [W14]
0062E8  37000A     BRA 0x62FE
0062FC  E84F1E     INC.B [W14], [W14]
0062FE  90401E     MOV.B [W14+1], W0
006300  78409E     MOV.B [W14], W1
006302  50CF80     SUB.B W1, W0, [W15]
006304  39FFF2     BRA NC, 0x62EA
216:                       *(KTCPCFG1 + 16 + cnt) = *(net_addr + cnt);
0062EA  FB801E     ZE [W14], W0
0062EC  4000F0     ADD W0, #0x10, W1
0062EE  21E020     MOV #0x1E02, W0
0062F0  408000     ADD W1, W0, W0
0062F2  FB809E     ZE [W14], W1
0062F4  E8810E     INC2 W14, W2
0062F6  410081     ADD W2, W1, W1
0062F8  784091     MOV.B [W1], W1
0062FA  784801     MOV.B W1, [W0]
217:               //    return all_bytes;
218:               }
006306  FA8000     ULNK
219:               
220:               
221:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/E41.c  --------------------------------------
1:                 #include "E41.h"
2:                 
3:                 #define M0_TRIS TRISEbits.TRISE5
4:                 #define M1_TRIS TRISEbits.TRISE6
5:                 #define M0 LATEbits.LATE5
6:                 #define M1 LATEbits.LATE6
7:                 #define M0_PORT PORTEbits.RE5
8:                 #define M1_PORT PORTEbits.RE6
9:                 #define AUX PORTFbits.RF6
10:                
11:                #define WORK 0
12:                #define WAKE 1
13:                #define LOWPOWER 2
14:                #define SLEEP 3
15:                uint8_t E41_Arg[] = {0xC0, 0xff, 0xff, 0x18, 0x1, 0xfc};
16:                // FF FF 18 01 9C
17:                //static ADDBITS E41_ADD;
18:                //static ARG1BITS E41_ARG1;
19:                //static ARG2BITS E41_ARG2;
20:                
21:                /*
22:                 AUX
23:                AUX 
24:                a)  AUX AUX ?
25:                b)  3 AUX 
26:                c)  AUX  M1M0 2ms 
27:                d)  AUX  M1M0 AUX  2ms 
28:                 */
29:                static void E41_SetMode(uint8_t mode) {
007356  FA0002     LNK #0x2
007358  784F00     MOV.B W0, [W14]
30:                    //
31:                    //    uint8_t now_mode = M0_PORT + (M1_PORT << 1);//mark
32:                    //
33:                    //    switch (mode) {
34:                    //        case SLEEP:
35:                    //        {
36:                    INT0_Close(); //
00735A  070475     RCALL INT0_Close
37:                    M0 = 0;
00735C  A9A2E4     BCLR LATE, #5
38:                    M1 = 0; //
00735E  A9C2E4     BCLR LATE, #6
39:                    OSTimeDlyHMSM(0, 0, 0, 250);
007360  200FA3     MOV #0xFA, W3
007362  EB0100     CLR W2
007364  EB0080     CLR W1
007366  EB0000     CLR W0
007368  07FF84     RCALL OSTimeDlyHMSM
40:                    M0 = mode & 0x01;
00736A  78409E     MOV.B [W14], W1
00736C  60C061     AND.B W1, #0x1, W0
00736E  604061     AND.B W0, #0x1, W0
007370  604061     AND.B W0, #0x1, W0
007372  FB8000     ZE W0, W0
007374  600061     AND W0, #0x1, W0
007376  DD0045     SL W0, #5, W0
007378  801721     MOV LATE, W1
00737A  A15001     BCLR W1, #5
00737C  700001     IOR W0, W1, W0
00737E  881720     MOV W0, LATE
41:                    M1 = (mode >> 1) & 0x01;
007380  FB801E     ZE [W14], W0
007382  D10000     LSR W0, W0
007384  784000     MOV.B W0, W0
007386  604061     AND.B W0, #0x1, W0
007388  604061     AND.B W0, #0x1, W0
00738A  604061     AND.B W0, #0x1, W0
00738C  FB8000     ZE W0, W0
00738E  600061     AND W0, #0x1, W0
007390  DD0046     SL W0, #6, W0
007392  801721     MOV LATE, W1
007394  A16001     BCLR W1, #6
007396  700001     IOR W0, W1, W0
007398  881720     MOV W0, LATE
42:                    OSTimeDlyHMSM(0, 0, 0, 10);
00739A  2000A3     MOV #0xA, W3
00739C  EB0100     CLR W2
00739E  EB0080     CLR W1
0073A0  EB0000     CLR W0
0073A2  07FF67     RCALL OSTimeDlyHMSM
43:                    INT0_Open();
0073A4  07044B     RCALL INT0_Open
44:                    //            break;
45:                    //        }
46:                    //        case LOWPOWER:
47:                    //        {
48:                    //            break;
49:                    //        }
50:                    //        case WAKE:
51:                    //        {
52:                    //            break;
53:                    //        }
54:                    //        case WORK:
55:                    //        {
56:                    //            break;
57:                }
0073A6  FA8000     ULNK
0073A8  060000     RETURN
58:                //            M0 = mode & 0x01;
59:                //            M1 = (mode >> 1) & 0x01;
60:                //}
61:                //}
62:                
63:                void E41_Init(void) {
0073AA  FA0002     LNK #0x2
64:                    uint8_t cnt;
65:                    M0_TRIS = 0; //
0073AC  A9A2E0     BCLR TRISE, #5
66:                    M1_TRIS = 0;
0073AE  A9C2E0     BCLR TRISE, #6
67:                    //    uint8_t currentMode = E41_SetGetMode(10);
68:                    E41_SetMode(SLEEP);
0073B0  B3C030     MOV.B #0x3, W0
0073B2  07FFD1     RCALL _E41_SetMode
69:                    OSTimeDlyHMSM(0, 0, 0, 300); // 300ms 
0073B4  2012C3     MOV #0x12C, W3
0073B6  EB0100     CLR W2
0073B8  EB0080     CLR W1
0073BA  EB0000     CLR W0
0073BC  07FF5A     RCALL OSTimeDlyHMSM
70:                    //    UART3_SendChar(0xC0);
71:                    for (cnt = 0; cnt < 3; cnt++) {
0073BE  EB4000     CLR.B W0
0073C0  784F00     MOV.B W0, [W14]
0073C2  370009     BRA 0x73D6
0073D4  E84F1E     INC.B [W14], [W14]
0073D6  78401E     MOV.B [W14], W0
0073D8  504FE2     SUB.B W0, #0x2, [W15]
0073DA  36FFF4     BRA LEU, 0x73C4
72:                        UART3_SendString(E41_Arg, 6);
0073C4  B3C061     MOV.B #0x6, W1
0073C6  21EB20     MOV #0x1EB2, W0
0073C8  070224     RCALL UART3_SendString
73:                        //    UART3_SendString(E41_Arg, 6);
74:                        OSTimeDlyHMSM(0, 0, 0, 10);
0073CA  2000A3     MOV #0xA, W3
0073CC  EB0100     CLR W2
0073CE  EB0080     CLR W1
0073D0  EB0000     CLR W0
0073D2  07FF4F     RCALL OSTimeDlyHMSM
75:                    }
76:                    //    E41_SetMode(LOWPOWER); //
77:                    //    E41_SetMode(WORK); //   
78:                    E41_SetMode(WAKE); //   
0073DC  B3C010     MOV.B #0x1, W0
0073DE  07FFBB     RCALL _E41_SetMode
79:                }
0073E0  FA8000     ULNK
0073E2  060000     RETURN
80:                
81:                bool E41_PressureIsGet(float* pres) {//01 03 04 3E F4 00 00 B6 2916
0073E4  FA004E     LNK #0x4E
0073E6  982760     MOV W0, [W14+76]
82:                    //
83:                    uint8_t tmp[10];
84:                    uint8_t Head[3] = {0x1, 0x3, 0x4};
0073E8  B3C010     MOV.B #0x1, W0
0073EA  984F20     MOV.B W0, [W14+10]
0073EC  B3C030     MOV.B #0x3, W0
0073EE  984F30     MOV.B W0, [W14+11]
0073F0  B3C040     MOV.B #0x4, W0
0073F2  984F40     MOV.B W0, [W14+12]
85:                    U3Rx4Byte();
0073F4  070232     RCALL U3Rx4Byte
86:                    StrCmp stcp;
87:                    uint8_t Source_tmp[50]; //
88:                
89:                    stcp.Source_len = UARTGetData(BufferRead_UART3, Source_tmp);
0073F6  47007A     ADD W14, #0x1A, W0
0073F8  780080     MOV W0, W1
0073FA  25E1A0     MOV #0x5E1A, W0
0073FC  07F5EE     RCALL UARTGetData
0073FE  985700     MOV.B W0, [W14+16]
90:                    if (stcp.Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//505050
007400  90508E     MOV.B [W14+16], W1
007402  B3C320     MOV.B #0x32, W0
007404  50CF80     SUB.B W1, W0, [W15]
007406  360002     BRA LEU, 0x740C
91:                        stcp.Source_len = 50;
007408  B3C320     MOV.B #0x32, W0
00740A  985700     MOV.B W0, [W14+16]
92:                    stcp.SourceData = Source_tmp;
00740C  47007A     ADD W14, #0x1A, W0
00740E  980770     MOV W0, [W14+14]
93:                    stcp.CheckData = Head;
007410  47006A     ADD W14, #0xA, W0
007412  980F10     MOV W0, [W14+18]
94:                    stcp.Check_len = 3;
007414  B3C030     MOV.B #0x3, W0
007416  985740     MOV.B W0, [W14+20]
95:                    stcp.GetData = tmp;
007418  980F3E     MOV W14, [W14+22]
96:                    stcp.Get_len = 8;
00741A  B3C080     MOV.B #0x8, W0
00741C  985F00     MOV.B W0, [W14+24]
97:                    stcp.Real_len = 0;
00741E  EB4000     CLR.B W0
007420  985F10     MOV.B W0, [W14+25]
98:                    UARTDataIsRight(&stcp);
007422  47006E     ADD W14, #0xE, W0
007424  07F517     RCALL UARTDataIsRight
99:                    if ((stcp.Real_len == 9) && CRCIsRight(tmp, 7, tmp + 7)) {//
007426  90581E     MOV.B [W14+25], W0
007428  504FE9     SUB.B W0, #0x9, [W15]
00742A  3A000D     BRA NZ, 0x7446
00742C  470067     ADD W14, #0x7, W0
00742E  780100     MOV W0, W2
007430  B3C071     MOV.B #0x7, W1
007432  78000E     MOV W14, W0
007434  0700C7     RCALL CRCIsRight
007436  E00400     CP0.B W0
007438  320006     BRA Z, 0x7446
100:                       CharToFloat(pres, tmp + 3);
00743A  470063     ADD W14, #0x3, W0
00743C  780080     MOV W0, W1
00743E  90206E     MOV [W14+76], W0
007440  07F8EE     RCALL CharToFloat
101:                       return true;
007442  B3C010     MOV.B #0x1, W0
007444  370001     BRA 0x7448
102:                   }
103:                   return false;
007446  EB4000     CLR.B W0
104:               }
007448  FA8000     ULNK
00744A  060000     RETURN
105:               
106:               void E41_Active_Send(void) {//01 03 04 3E F4 00 00 B6 2916
00744C  FA0014     LNK #0x14
107:                   //
108:                   uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34, 0x20, 0x30, 0x42}, cnt;
00744E  090009     REPEAT #0x9
007450  EB1F00     CLR [W14++]
007452  B1014E     SUB #0x14, W14
007454  B3C010     MOV.B #0x1, W0
007456  984710     MOV.B W0, [W14+1]
007458  B3C010     MOV.B #0x1, W0
00745A  984720     MOV.B W0, [W14+2]
00745C  B3C120     MOV.B #0x12, W0
00745E  984730     MOV.B W0, [W14+3]
007460  B3C340     MOV.B #0x34, W0
007462  984740     MOV.B W0, [W14+4]
007464  B3C200     MOV.B #0x20, W0
007466  984750     MOV.B W0, [W14+5]
007468  B3C300     MOV.B #0x30, W0
00746A  984760     MOV.B W0, [W14+6]
00746C  B3C420     MOV.B #0x42, W0
00746E  984770     MOV.B W0, [W14+7]
109:                   E41_SetMode(WAKE); //    
007470  B3C010     MOV.B #0x1, W0
007472  07FF71     RCALL _E41_SetMode
110:                   OSTimeDlyHMSM(0, 0, 0, 100);
007474  200643     MOV #0x64, W3
007476  EB0100     CLR W2
007478  EB0080     CLR W1
00747A  EB0000     CLR W0
00747C  07FEFA     RCALL OSTimeDlyHMSM
111:                   INT0_Close();
00747E  0703E3     RCALL INT0_Close
112:                   //    for (cnt = 0; cnt < 3; cnt++) {
113:                   UART3_SendString(E41_tmp, 8);
007480  B3C081     MOV.B #0x8, W1
007482  78000E     MOV W14, W0
007484  0701C6     RCALL UART3_SendString
114:                   OSTimeDlyHMSM(0, 0, 0, 10);
007486  2000A3     MOV #0xA, W3
007488  EB0100     CLR W2
00748A  EB0080     CLR W1
00748C  EB0000     CLR W0
00748E  07FEF1     RCALL OSTimeDlyHMSM
115:                   //
116:                   //    }
117:                   INT0_Open();
007490  0703D5     RCALL INT0_Open
118:                   OSTimeDlyHMSM(0, 0, 10, 0);
007492  EB0180     CLR W3
007494  2000A2     MOV #0xA, W2
007496  EB0080     CLR W1
007498  EB0000     CLR W0
00749A  07FEEB     RCALL OSTimeDlyHMSM
119:                   E41_SetMode(LOWPOWER); //    
00749C  B3C020     MOV.B #0x2, W0
00749E  07FF5B     RCALL _E41_SetMode
120:                   //    OSTimeDlyHMSM(0, 0, 10, 0);
121:               }
0074A0  FA8000     ULNK
122:               
123:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: char
6:                 Input:  4  8  
7:                 Output: 
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
0065F0  FA0008     LNK #0x8
0065F2  980720     MOV W0, [W14+4]
0065F4  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
0065F6  9000AE     MOV [W14+4], W1
0065F8  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
0065FA  EB4000     CLR.B W0
0065FC  784F00     MOV.B W0, [W14]
0065FE  37000A     BRA 0x6614
006612  E84F1E     INC.B [W14], [W14]
006614  78401E     MOV.B [W14], W0
006616  504FE3     SUB.B W0, #0x3, [W15]
006618  36FFF3     BRA LEU, 0x6600
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
006600  FB801E     ZE [W14], W0
006602  9000BE     MOV [W14+6], W1
006604  408000     ADD W1, W0, W0
006606  90011E     MOV [W14+2], W2
006608  FB809E     ZE [W14], W1
00660A  1080E3     SUBR W1, #0x3, W1
00660C  410081     ADD W2, W1, W1
00660E  784091     MOV.B [W1], W1
006610  784801     MOV.B W1, [W0]
16:                    }
17:                }
00661A  FA8000     ULNK
00661C  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char 
22:                Input:     4  8  
23:                Output: 
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
00661E  FA0008     LNK #0x8
006620  980720     MOV W0, [W14+4]
006622  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
006624  9000AE     MOV [W14+4], W1
006626  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
006628  EB4000     CLR.B W0
00662A  784F00     MOV.B W0, [W14]
00662C  37000A     BRA 0x6642
006640  E84F1E     INC.B [W14], [W14]
006642  78401E     MOV.B [W14], W0
006644  504FE3     SUB.B W0, #0x3, [W15]
006646  36FFF3     BRA LEU, 0x662E
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
00662E  90009E     MOV [W14+2], W1
006630  FB801E     ZE [W14], W0
006632  408000     ADD W1, W0, W0
006634  FB809E     ZE [W14], W1
006636  1080E3     SUBR W1, #0x3, W1
006638  90013E     MOV [W14+6], W2
00663A  410081     ADD W2, W1, W1
00663C  784091     MOV.B [W1], W1
00663E  784801     MOV.B W1, [W0]
32:                    }
33:                }
006648  FA8000     ULNK
00664A  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: char
38:                Input:  4  8  
39:                Output: 
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
00664C  FA0008     LNK #0x8
00664E  980720     MOV W0, [W14+4]
006650  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
006652  9000AE     MOV [W14+4], W1
006654  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
006656  EB4000     CLR.B W0
006658  784F00     MOV.B W0, [W14]
00665A  37000A     BRA 0x6670
00666E  E84F1E     INC.B [W14], [W14]
006670  78401E     MOV.B [W14], W0
006672  504FE7     SUB.B W0, #0x7, [W15]
006674  36FFF3     BRA LEU, 0x665C
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
00665C  FB801E     ZE [W14], W0
00665E  9000BE     MOV [W14+6], W1
006660  408000     ADD W1, W0, W0
006662  90011E     MOV [W14+2], W2
006664  FB809E     ZE [W14], W1
006666  1080E7     SUBR W1, #0x7, W1
006668  410081     ADD W2, W1, W1
00666A  784091     MOV.B [W1], W1
00666C  784801     MOV.B W1, [W0]
48:                    }
49:                }
006676  FA8000     ULNK
006678  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 1610
54:                Input: 
55:                Output: 
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
00667A  FA0002     LNK #0x2
00667C  784F00     MOV.B W0, [W14]
58:                    return ((dat >> 4)&0x0f)*10 + (dat & 0x0f);
00667E  FB801E     ZE [W14], W0
006680  DE0044     LSR W0, #4, W0
006682  784000     MOV.B W0, W0
006684  B9006A     MUL.SU W0, #10, W0
006686  780000     MOV W0, W0
006688  784080     MOV.B W0, W1
00668A  78411E     MOV.B [W14], W2
00668C  61406F     AND.B W2, #0xF, W0
00668E  40C000     ADD.B W1, W0, W0
59:                }
006690  FA8000     ULNK
006692  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 1016
64:                Input: 
65:                Output: 
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
006694  FA0004     LNK #0x4
006696  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
006698  FB809E     ZE [W14], W1
00669A  2000A0     MOV #0xA, W0
00669C  780100     MOV W0, W2
00669E  090011     REPEAT #0x11
0066A0  D88082     DIV.UW W1, W2
0066A2  784000     MOV.B W0, W0
0066A4  FB8000     ZE W0, W0
0066A6  DD0044     SL W0, #4, W0
0066A8  784000     MOV.B W0, W0
0066AA  984720     MOV.B W0, [W14+2]
0066AC  FB811E     ZE [W14], W2
0066AE  2000A0     MOV #0xA, W0
0066B0  780180     MOV W0, W3
0066B2  090011     REPEAT #0x11
0066B4  D88103     DIV.UW W2, W3
0066B6  FD0080     EXCH W0, W1
0066B8  784000     MOV.B W0, W0
0066BA  60406F     AND.B W0, #0xF, W0
0066BC  9040AE     MOV.B [W14+2], W1
0066BE  70C000     IOR.B W1, W0, W0
69:                }
0066C0  FA8000     ULNK
0066C2  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x1117-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 
79:                Input: 
80:                Output: 
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
0066C4  FA0006     LNK #0x6
0066C6  780F00     MOV W0, [W14]
0066C8  980711     MOV W1, [W14+2]
0066CA  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
0066CC  90001E     MOV [W14+2], W0
0066CE  78009E     MOV [W14], W1
0066D0  508F80     SUB W1, W0, [W15]
0066D2  360002     BRA LEU, 0x66D8
0066D4  EB4000     CLR.B W0
0066D6  370007     BRA 0x66E6
84:                    else if (dat < min) return false;
0066D8  90002E     MOV [W14+4], W0
0066DA  78009E     MOV [W14], W1
0066DC  508F80     SUB W1, W0, [W15]
0066DE  310002     BRA C, 0x66E4
0066E0  EB4000     CLR.B W0
0066E2  370001     BRA 0x66E6
85:                    return true;
0066E4  B3C010     MOV.B #0x1, W0
86:                }
0066E6  FA8000     ULNK
0066E8  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 
91:                Input: 
92:                Output: 
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
0066EA  FA000A     LNK #0xA
0066EC  980710     MOV W0, [W14+2]
0066EE  980722     MOV W2, [W14+4]
0066F0  980733     MOV W3, [W14+6]
0066F2  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
0066F4  90001E     MOV [W14+2], W0
0066F6  780010     MOV [W0], W0
0066F8  DD00C8     SL W0, #8, W1
0066FA  90001E     MOV [W14+2], W0
0066FC  E88000     INC2 W0, W0
0066FE  780010     MOV [W0], W0
006700  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
006702  78001E     MOV [W14], W0
006704  B80161     MUL.UU W0, #1, W2
006706  90002E     MOV [W14+4], W0
006708  9000BE     MOV [W14+6], W1
00670A  510F80     SUB W2, W0, [W15]
00670C  598F81     SUBB W3, W1, [W15]
00670E  360004     BRA LEU, 0x6718
98:                        *dat = max;
006710  9000AE     MOV [W14+4], W1
006712  90001E     MOV [W14+2], W0
006714  780801     MOV W1, [W0]
006716  370007     BRA 0x6726
99:                    } else if (tmp < min) {
006718  90004E     MOV [W14+8], W0
00671A  78009E     MOV [W14], W1
00671C  508F80     SUB W1, W0, [W15]
00671E  310003     BRA C, 0x6726
100:                       *dat = min;
006720  90001E     MOV [W14+2], W0
006722  9000CE     MOV [W14+8], W1
006724  780801     MOV W1, [W0]
101:                   }
102:               }
006726  FA8000     ULNK
006728  060000     RETURN
103:               //
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
00672A  FA0006     LNK #0x6
00672C  980710     MOV W0, [W14+2]
00672E  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
006730  EB4000     CLR.B W0
006732  784F00     MOV.B W0, [W14]
006734  37001B     BRA 0x676C
00676A  E84F1E     INC.B [W14], [W14]
00676C  90404E     MOV.B [W14+4], W0
00676E  FB8000     ZE W0, W0
006770  D10000     LSR W0, W0
006772  784000     MOV.B W0, W0
006774  504F9E     SUB.B W0, [W14], [W15]
006776  3EFFDF     BRA GTU, 0x6736
109:                       tmp = dat[cnt];
006736  FB801E     ZE [W14], W0
006738  90009E     MOV [W14+2], W1
00673A  408000     ADD W1, W0, W0
00673C  784090     MOV.B [W0], W1
00673E  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
006740  FB801E     ZE [W14], W0
006742  90009E     MOV [W14+2], W1
006744  408000     ADD W1, W0, W0
006746  9040CE     MOV.B [W14+4], W1
006748  FB8081     ZE W1, W1
00674A  E90101     DEC W1, W2
00674C  FB809E     ZE [W14], W1
00674E  510081     SUB W2, W1, W1
006750  90011E     MOV [W14+2], W2
006752  410081     ADD W2, W1, W1
006754  784091     MOV.B [W1], W1
006756  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
006758  90404E     MOV.B [W14+4], W0
00675A  FB8000     ZE W0, W0
00675C  E90080     DEC W0, W1
00675E  FB801E     ZE [W14], W0
006760  508000     SUB W1, W0, W0
006762  90009E     MOV [W14+2], W1
006764  408000     ADD W1, W0, W0
006766  90409E     MOV.B [W14+1], W1
006768  784801     MOV.B W1, [W0]
112:                   }
113:               }
006778  FA8000     ULNK
00677A  060000     RETURN
114:               
115:               //8MHz-4Mhz
116:               
117:               //void Delay10ms(char time) {
118:               //    uint16_t i;
119:               //    while (time-- > 0)
120:               //        for (i = 0; i < 6700; i++)
121:               //            asm("Nop()");
122:               //}
123:               
124:               //void Delay100ms(char time) {
125:               //    uint16_t i;
126:               //    while (time-- > 0)
127:               //        for (i = 0; i < 65500; i++)
128:               //            asm("Nop()");
129:               //}
130:               //
131:               //void Delay1s(char time) {
132:               //    uint32_t i; //,j;
133:               //    while (time-- > 0)
134:               //        for (i = 0; i < 365000; i++)
135:               //            asm("Nop()");
136:               //}
137:               
138:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
00677C  FA0008     LNK #0x8
00677E  980710     MOV W0, [W14+2]
006780  980721     MOV W1, [W14+4]
006782  984762     MOV.B W2, [W14+6]
139:                   uint8_t num;
140:                   for (num = 0; num < bytes; num++)
006784  EB4000     CLR.B W0
006786  784F00     MOV.B W0, [W14]
006788  370009     BRA 0x679C
00679A  E84F1E     INC.B [W14], [W14]
00679C  90406E     MOV.B [W14+6], W0
00679E  78409E     MOV.B [W14], W1
0067A0  50CF80     SUB.B W1, W0, [W15]
0067A2  39FFF3     BRA NC, 0x678A
141:                       *(output + num) = *(input + num);
00678A  FB801E     ZE [W14], W0
00678C  90009E     MOV [W14+2], W1
00678E  408000     ADD W1, W0, W0
006790  FB809E     ZE [W14], W1
006792  90012E     MOV [W14+4], W2
006794  410081     ADD W2, W1, W1
006796  784091     MOV.B [W1], W1
006798  784801     MOV.B W1, [W0]
142:               }
0067A4  FA8000     ULNK
0067A6  060000     RETURN
143:               
144:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
0067A8  FA0006     LNK #0x6
0067AA  980710     MOV W0, [W14+2]
0067AC  984741     MOV.B W1, [W14+4]
0067AE  984752     MOV.B W2, [W14+5]
145:                   uint8_t num;
146:                   for (num = 0; num < bytes; num++)
0067B0  EB4000     CLR.B W0
0067B2  784F00     MOV.B W0, [W14]
0067B4  370006     BRA 0x67C2
0067C0  E84F1E     INC.B [W14], [W14]
0067C2  90405E     MOV.B [W14+5], W0
0067C4  78409E     MOV.B [W14], W1
0067C6  50CF80     SUB.B W1, W0, [W15]
0067C8  39FFF6     BRA NC, 0x67B6
147:                       *(output + num) = dat;
0067B6  FB801E     ZE [W14], W0
0067B8  90009E     MOV [W14+2], W1
0067BA  408000     ADD W1, W0, W0
0067BC  9040CE     MOV.B [W14+4], W1
0067BE  784801     MOV.B W1, [W0]
148:               }
0067CA  FA8000     ULNK
0067CC  060000     RETURN
149:               
150:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
0067CE  FA0008     LNK #0x8
0067D0  980710     MOV W0, [W14+2]
0067D2  980721     MOV W1, [W14+4]
0067D4  984762     MOV.B W2, [W14+6]
151:                   uint8_t cnt;
152:                   for (cnt = 0; cnt < bytes; cnt++)
0067D6  EB4000     CLR.B W0
0067D8  784F00     MOV.B W0, [W14]
0067DA  37000D     BRA 0x67F6
0067F4  E84F1E     INC.B [W14], [W14]
0067F6  90406E     MOV.B [W14+6], W0
0067F8  78409E     MOV.B [W14], W1
0067FA  50CF80     SUB.B W1, W0, [W15]
0067FC  39FFEF     BRA NC, 0x67DC
153:                       if (*(str1 + cnt) != *(str2 + cnt))
0067DC  FB801E     ZE [W14], W0
0067DE  90009E     MOV [W14+2], W1
0067E0  408000     ADD W1, W0, W0
0067E2  784090     MOV.B [W0], W1
0067E4  FB801E     ZE [W14], W0
0067E6  90012E     MOV [W14+4], W2
0067E8  410000     ADD W2, W0, W0
0067EA  784010     MOV.B [W0], W0
0067EC  50CF80     SUB.B W1, W0, [W15]
0067EE  320002     BRA Z, 0x67F4
154:                           return false;
0067F0  EB4000     CLR.B W0
0067F2  370006     BRA 0x6800
155:                   return true;
0067FE  B3C010     MOV.B #0x1, W0
156:               }
006800  FA8000     ULNK
006802  060000     RETURN
157:               
158:               //
159:               
160:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
006804  FA0004     LNK #0x4
006806  780F00     MOV W0, [W14]
006808  984721     MOV.B W1, [W14+2]
161:                   return num - ((num >> mod_num) << mod_num);
00680A  78001E     MOV [W14], W0
00680C  784080     MOV.B W0, W1
00680E  90402E     MOV.B [W14+2], W0
006810  FB8000     ZE W0, W0
006812  78011E     MOV [W14], W2
006814  DE1100     LSR W2, W0, W2
006816  90402E     MOV.B [W14+2], W0
006818  FB8000     ZE W0, W0
00681A  DD1000     SL W2, W0, W0
00681C  784000     MOV.B W0, W0
00681E  50C000     SUB.B W1, W0, W0
162:               }
006820  FA8000     ULNK
006822  060000     RETURN
163:               
164:               //16
165:               
166:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
006824  FA0010     LNK #0x10
006826  980750     MOV W0, [W14+10]
006828  980761     MOV W1, [W14+12]
167:                   uint8_t buf[6];
168:                   uint8_t cnt = 0, len;
00682A  EB4000     CLR.B W0
00682C  784F00     MOV.B W0, [W14]
169:                   uint16_t tmp = i;
00682E  90005E     MOV [W14+10], W0
006830  980710     MOV W0, [W14+2]
170:                   if (!tmp) {
006832  90001E     MOV [W14+2], W0
006834  E00000     CP0 W0
006836  3A001E     BRA NZ, 0x6874
171:                       *str = '0';
006838  90006E     MOV [W14+12], W0
00683A  B3C301     MOV.B #0x30, W1
00683C  784801     MOV.B W1, [W0]
172:                       *(str + 1) = '\0';
00683E  90006E     MOV [W14+12], W0
006840  E80000     INC W0, W0
006842  EB4080     CLR.B W1
006844  784801     MOV.B W1, [W0]
173:                       len = 1;
006846  B3C010     MOV.B #0x1, W0
006848  984710     MOV.B W0, [W14+1]
00684A  370034     BRA 0x68B4
174:                   } else {
175:                       while (tmp) {
006874  90001E     MOV [W14+2], W0
006876  E00000     CP0 W0
006878  3AFFE9     BRA NZ, 0x684C
176:                           *(buf + cnt++) = tmp % 10 + 0x30;
00684C  FB801E     ZE [W14], W0
00684E  4700E4     ADD W14, #0x4, W1
006850  408080     ADD W1, W0, W1
006852  980771     MOV W1, [W14+14]
006854  90011E     MOV [W14+2], W2
006856  2000A1     MOV #0xA, W1
006858  780181     MOV W1, W3
00685A  090011     REPEAT #0x11
00685C  D88103     DIV.UW W2, W3
00685E  784081     MOV.B W1, W1
006860  B04301     ADD.B #0x30, W1
006862  90007E     MOV [W14+14], W0
006864  784801     MOV.B W1, [W0]
006866  E84F1E     INC.B [W14], [W14]
177:                           tmp /= 10;
006868  90009E     MOV [W14+2], W1
00686A  2000A0     MOV #0xA, W0
00686C  780100     MOV W0, W2
00686E  090011     REPEAT #0x11
006870  D88082     DIV.UW W1, W2
006872  980710     MOV W0, [W14+2]
178:                       }
179:                       len = cnt;
00687A  78419E     MOV.B [W14], W3
00687C  984713     MOV.B W3, [W14+1]
180:                       cnt += 1;
00687E  E84F1E     INC.B [W14], [W14]
181:                       while (cnt--) {
006880  37000C     BRA 0x689A
00689A  FB801E     ZE [W14], W0
00689C  EA0000     NEG W0, W0
00689E  DE004F     LSR W0, #15, W0
0068A0  784000     MOV.B W0, W0
0068A2  E94F1E     DEC.B [W14], [W14]
0068A4  E00400     CP0.B W0
0068A6  3AFFED     BRA NZ, 0x6882
182:                           *(str + cnt - 1) = *(buf + len - cnt);
006882  FB801E     ZE [W14], W0
006884  E90000     DEC W0, W0
006886  9000EE     MOV [W14+12], W1
006888  408000     ADD W1, W0, W0
00688A  90409E     MOV.B [W14+1], W1
00688C  FB8101     ZE W1, W2
00688E  FB809E     ZE [W14], W1
006890  510081     SUB W2, W1, W1
006892  470164     ADD W14, #0x4, W2
006894  410081     ADD W2, W1, W1
006896  784091     MOV.B [W1], W1
006898  784801     MOV.B W1, [W0]
183:                       }
184:                       *(str + len) = '\0';
0068A8  90401E     MOV.B [W14+1], W0
0068AA  FB8000     ZE W0, W0
0068AC  9000EE     MOV [W14+12], W1
0068AE  408000     ADD W1, W0, W0
0068B0  EB4080     CLR.B W1
0068B2  784801     MOV.B W1, [W0]
185:                   }
186:                   return len;
0068B4  90401E     MOV.B [W14+1], W0
187:               }
0068B6  FA8000     ULNK
188:               
189:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/CheckData.c  --------------------------------
1:                 //#include "user.h"
2:                 #include "CheckData.h"
3:                 
4:                 ///****************************************************************************
5:                 //: CRC16()
6:                 //: CRC16
7:                 //: *CRC_Buf:
8:                 //      CRC_Leni:
9:                 //: CRC
10:                // *****************************************************************************/
11:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, const uint8_t CRC_Leni) {
12:                //    uint16_t i, j;
13:                //    uint16_t CRC_Sumx;
14:                //
15:                //    CRC_Sumx = 0xFFFF;
16:                //    for (i = 0; i < CRC_Leni; i++) {
17:                //        CRC_Sumx ^= *(CRC_Buf + i); //
18:                //        for (j = 0; j < 8; j++) {
19:                //            if (CRC_Sumx & 0x01) {
20:                //                CRC_Sumx >>= 1;
21:                //                CRC_Sumx ^= 0xA001;
22:                //            } else {
23:                //                CRC_Sumx >>= 1;
24:                //            }
25:                //        }
26:                //    }
27:                //    return (CRC_Sumx);
28:                //}
29:                
30:                /*************************************
31:                Function: CheckIsRight  
32:                Description: datfp
33:                Input: fp dat:bytes:
34:                Output: 1  0
35:                 *************************************/
36:                bool CRCIsRight(uint8_t * CRC_Buf, const uint8_t CRC_Leni, const uint8_t* CHC_Dat) {
0075C4  FA000C     LNK #0xC
0075C6  980730     MOV W0, [W14+6]
0075C8  984F01     MOV.B W1, [W14+8]
0075CA  980752     MOV W2, [W14+10]
37:                    uint16_t i, j;
38:                    uint16_t CRC_Sumx;
39:                
40:                    CRC_Sumx = 0xFFFF;
0075CC  EB8000     SETM W0
0075CE  980720     MOV W0, [W14+4]
41:                    for (i = 0; i < CRC_Leni; i++) {
0075D0  EB0000     CLR W0
0075D2  780F00     MOV W0, [W14]
0075D4  370021     BRA 0x7618
007616  E80F1E     INC [W14], [W14]
007618  90480E     MOV.B [W14+8], W0
00761A  FB8000     ZE W0, W0
00761C  500F9E     SUB W0, [W14], [W15]
00761E  3EFFDB     BRA GTU, 0x75D6
42:                        CRC_Sumx ^= *(CRC_Buf + i); //
0075D6  90003E     MOV [W14+6], W0
0075D8  40001E     ADD W0, [W14], W0
0075DA  784010     MOV.B [W0], W0
0075DC  FB8000     ZE W0, W0
0075DE  9000AE     MOV [W14+4], W1
0075E0  688000     XOR W1, W0, W0
0075E2  980720     MOV W0, [W14+4]
43:                        for (j = 0; j < 8; j++) {
0075E4  EB0000     CLR W0
0075E6  980710     MOV W0, [W14+2]
0075E8  370013     BRA 0x7610
00760A  90001E     MOV [W14+2], W0
00760C  E80000     INC W0, W0
00760E  980710     MOV W0, [W14+2]
007610  90001E     MOV [W14+2], W0
007612  500FE7     SUB W0, #0x7, [W15]
007614  36FFEA     BRA LEU, 0x75EA
44:                            if (CRC_Sumx & 0x01) {
0075EA  90002E     MOV [W14+4], W0
0075EC  600061     AND W0, #0x1, W0
0075EE  784000     MOV.B W0, W0
0075F0  E00400     CP0.B W0
0075F2  320008     BRA Z, 0x7604
45:                                CRC_Sumx >>= 1;
0075F4  90002E     MOV [W14+4], W0
0075F6  D10000     LSR W0, W0
0075F8  980720     MOV W0, [W14+4]
46:                                CRC_Sumx ^= 0xA001;
0075FA  9000AE     MOV [W14+4], W1
0075FC  2A0010     MOV #0xA001, W0
0075FE  688000     XOR W1, W0, W0
007600  980720     MOV W0, [W14+4]
007602  370003     BRA 0x760A
47:                            } else {
48:                                CRC_Sumx >>= 1;
007604  90002E     MOV [W14+4], W0
007606  D10000     LSR W0, W0
007608  980720     MOV W0, [W14+4]
49:                            }
50:                        }
51:                    }; //CRC
52:                    return (CRC_Sumx == (*CHC_Dat + (*(CHC_Dat + 1) << 8))); //+CRC
007620  90005E     MOV [W14+10], W0
007622  784010     MOV.B [W0], W0
007624  FB8080     ZE W0, W1
007626  90005E     MOV [W14+10], W0
007628  E80000     INC W0, W0
00762A  784010     MOV.B [W0], W0
00762C  FB8000     ZE W0, W0
00762E  DD0048     SL W0, #8, W0
007630  408000     ADD W1, W0, W0
007632  780080     MOV W0, W1
007634  90002E     MOV [W14+4], W0
007636  688000     XOR W1, W0, W0
007638  A7F000     BTSC W0, #15
00763A  EA0000     NEG W0, W0
00763C  E90000     DEC W0, W0
00763E  DE004F     LSR W0, #15, W0
007640  784000     MOV.B W0, W0
53:                }
007642  FA8000     ULNK
007644  060000     RETURN
54:                
55:                ///*************************************
56:                //Function: Sum_Check 
57:                //Description: 
58:                //Input: framebytes 
59:                //Output: 
60:                // *************************************/
61:                //uint16_t Sum_Check(uint8_t *frame, const uint8_t bytes) {
62:                //    uint16_t cksum = 0;
63:                //    uint16_t cnt = bytes;
64:                //    while (cnt > 0) {
65:                //        cksum += *frame++;
66:                //        cnt--;
67:                //    }
68:                //    return cksum;
69:                //}
70:                
71:                /*************************************
72:                Function: Sum_Check256
73:                Description: 
74:                Input: framebytes 
75:                Output: 
76:                 *************************************/
77:                bool SumCheckIsRight(uint8_t *frame, const uint16_t bytes, const uint8_t CheckSum) {
007646  FA000C     LNK #0xC
007648  980730     MOV W0, [W14+6]
00764A  980741     MOV W1, [W14+8]
00764C  984F22     MOV.B W2, [W14+10]
78:                    uint32_t ckSum = 0; //
00764E  B80060     MUL.UU W0, #0, W0
007650  BE8F00     MOV.D W0, [W14]
79:                    uint16_t cnt;
80:                
81:                    for (cnt = 0; cnt < bytes; cnt++)
007652  EB0000     CLR W0
007654  980720     MOV W0, [W14+4]
007656  37000C     BRA 0x7670
00766A  90002E     MOV [W14+4], W0
00766C  E80000     INC W0, W0
00766E  980720     MOV W0, [W14+4]
007670  9000AE     MOV [W14+4], W1
007672  90004E     MOV [W14+8], W0
007674  508F80     SUB W1, W0, [W15]
007676  39FFF0     BRA NC, 0x7658
82:                        ckSum += *frame++;
007658  90003E     MOV [W14+6], W0
00765A  784010     MOV.B [W0], W0
00765C  FB8000     ZE W0, W0
00765E  EB0080     CLR W1
007660  400F1E     ADD W0, [W14], [W14]
007662  48975E     ADDC W1, [++W14], [W14--]
007664  90003E     MOV [W14+6], W0
007666  E80000     INC W0, W0
007668  980730     MOV W0, [W14+6]
83:                
84:                    return (CheckSum == (ckSum - ((ckSum >> 8) << 8)));
007678  90482E     MOV.B [W14+10], W0
00767A  FB8200     ZE W0, W4
00767C  EB0280     CLR W5
00767E  200FF0     MOV #0xFF, W0
007680  200001     MOV #0x0, W1
007682  BE011E     MOV.D [W14], W2
007684  780302     MOV W2, W6
007686  780103     MOV W3, W2
007688  780180     MOV W0, W3
00768A  780001     MOV W1, W0
00768C  630303     AND W6, W3, W6
00768E  610000     AND W2, W0, W0
007690  EB0080     CLR W1
007692  DD00C0     SL W0, #0, W1
007694  200000     MOV #0x0, W0
007696  BE0100     MOV.D W0, W2
007698  B83061     MUL.UU W6, #1, W0
00769A  710100     IOR W2, W0, W2
00769C  718181     IOR W3, W1, W3
00769E  6A0002     XOR W4, W2, W0
0076A0  6A8083     XOR W5, W3, W1
0076A2  708000     IOR W1, W0, W0
0076A4  A7F000     BTSC W0, #15
0076A6  EA0000     NEG W0, W0
0076A8  E90000     DEC W0, W0
0076AA  DE004F     LSR W0, #15, W0
0076AC  784000     MOV.B W0, W0
85:                }
0076AE  FA8000     ULNK
86:                
87:                
88:                
89:                //bool CheckSrting(uint8_t*dat1, uint8_t*dat2, const uint8_t num) {
90:                //    uint8_t cnt;
91:                //    for (cnt = 0; cnt < num; cnt++) {//EID
92:                //        if (*(dat1 + cnt) != *(dat2 + cnt)) {
93:                //            return false;
94:                //        }
95:                //    }
96:                //    return true;
97:                //}
98:                
99:                ///*************************************
100:               //Function: MD5encrypt  
101:               //Description: 
102:               //Input: 
103:               //Output:
104:               //*************************************/
105:               //void MD5encrypt(uint8_t* input,uint8_t *output)
106:               //{
107:               //    
108:               //}
109:               
110:               
111:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/User/CAT24C512.c  --------------------------------
1:                 #include "CAT24C512.h"
2:                 
3:                 //0x0000-0xffff 512kb
4:                 #define BufferSize 40//
5:                 
6:                 
7:                 uint16_t CAT_OperatID;
8:                 //CAT24Arg CAT24Argbits;
9:                 
10:                void CAT24C512_Init(void) {
007B30  FA0000     LNK #0x0
11:                    TRISBbits.TRISB12 = 0; //WP    
007B32  A982C9     BCLR 0x2C9, #4
12:                    LATBbits.LATB12 = 1;//
007B34  A882CD     BSET 0x2CD, #4
13:                    //    CAT24Argbits.ID = 0; //
14:                    //    CAT24Argbits.data = NULL;
15:                }
007B36  FA8000     ULNK
007B38  060000     RETURN
16:                
17:                void CAT24C512_Read(uint16_t id, uint8_t *tmp) {
007B3A  FA0004     LNK #0x4
007B3C  780F00     MOV W0, [W14]
007B3E  980711     MOV W1, [W14+2]
18:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //cat24c512 0xA8 
19:                    i2c_buf.operatcode = CAT_ADD;
007B40  21EA20     MOV #0x1EA2, W0
007B42  B3CA81     MOV.B #0xA8, W1
007B44  784801     MOV.B W1, [W0]
20:                    i2c_buf.address = id*BufferSize;
007B46  78009E     MOV [W14], W1
007B48  200280     MOV #0x28, W0
007B4A  B98800     MUL.SS W1, W0, W0
007B4C  780000     MOV W0, W0
007B4E  88F520     MOV W0, 0x1EA4
21:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
007B50  21EA60     MOV #0x1EA6, W0
007B52  B3C281     MOV.B #0x28, W1
007B54  784801     MOV.B W1, [W0]
22:                    i2c_buf.pbuffer = tmp;
007B56  90009E     MOV [W14+2], W1
007B58  88F541     MOV W1, 0x1EA8
23:                    i2c_buf.flag.F_IsSelectiveMode = 1;
007B5A  80F550     MOV 0x1EAA, W0
007B5C  A00000     BSET W0, #0
007B5E  88F550     MOV W0, 0x1EAA
24:                    i2c_buf.flag.F_WriteOrRead = 1;
007B60  80F550     MOV 0x1EAA, W0
007B62  A02000     BSET W0, #2
007B64  88F550     MOV W0, 0x1EAA
25:                    i2c_buf.flag.F_Is16bitsDevice = 1;
007B66  80F550     MOV 0x1EAA, W0
007B68  A01000     BSET W0, #1
007B6A  88F550     MOV W0, 0x1EAA
26:                    i2c1_state = S_MASTER_IDLE;
007B6C  EF6828     CLR.B i2c1_state
27:                    IFS1bits.MI2C1IF = 1; //I2C
007B6E  A82086     BSET IFS1, #1
28:                    //
29:                    //
30:                    while (i2c1_state != S_MASTER_SEND_STOP); //
007B70  000000     NOP
007B72  BFC828     MOV.B i2c1_state, WREG
007B74  504FE6     SUB.B W0, #0x6, [W15]
007B76  3AFFFD     BRA NZ, 0x7B72
31:                }
007B78  FA8000     ULNK
007B7A  060000     RETURN
32:                
33:                void CAT24C512_Write(uint16_t id, uint8_t *tmp) {
007B7C  FA0004     LNK #0x4
007B7E  780F00     MOV W0, [W14]
007B80  980711     MOV W1, [W14+2]
34:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //cat24c512 0xA8 
35:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};
36:                    i2c_buf.operatcode = CAT_ADD;
007B82  21EA20     MOV #0x1EA2, W0
007B84  B3CA81     MOV.B #0xA8, W1
007B86  784801     MOV.B W1, [W0]
37:                    i2c_buf.address = id*BufferSize;
007B88  78009E     MOV [W14], W1
007B8A  200280     MOV #0x28, W0
007B8C  B98800     MUL.SS W1, W0, W0
007B8E  780000     MOV W0, W0
007B90  88F520     MOV W0, 0x1EA4
38:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
007B92  21EA60     MOV #0x1EA6, W0
007B94  B3C281     MOV.B #0x28, W1
007B96  784801     MOV.B W1, [W0]
39:                    i2c_buf.pbuffer = tmp;
007B98  90009E     MOV [W14+2], W1
007B9A  88F541     MOV W1, 0x1EA8
40:                    i2c_buf.flag.F_IsSelectiveMode = 1;
007B9C  80F550     MOV 0x1EAA, W0
007B9E  A00000     BSET W0, #0
007BA0  88F550     MOV W0, 0x1EAA
41:                    i2c_buf.flag.F_WriteOrRead = 0;
007BA2  80F550     MOV 0x1EAA, W0
007BA4  A12000     BCLR W0, #2
007BA6  88F550     MOV W0, 0x1EAA
42:                    i2c_buf.flag.F_Is16bitsDevice = 1;
007BA8  80F550     MOV 0x1EAA, W0
007BAA  A01000     BSET W0, #1
007BAC  88F550     MOV W0, 0x1EAA
43:                    i2c1_state = S_MASTER_IDLE;
007BAE  EF6828     CLR.B i2c1_state
44:                    IFS1bits.MI2C1IF = 1;
007BB0  A82086     BSET IFS1, #1
45:                    while (i2c1_state != S_MASTER_SEND_STOP); //
007BB2  000000     NOP
007BB4  BFC828     MOV.B i2c1_state, WREG
007BB6  504FE6     SUB.B W0, #0x6, [W15]
007BB8  3AFFFD     BRA NZ, 0x7BB4
46:                    //
47:                }
007BBA  FA8000     ULNK
48:                
49:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/bsp_a.s  -------------------------------------
                                                  1:     ;
                                                  2:     ;********************************************************************************************************
                                                  3:     ;                                               uC/OS-II
                                                  4:     ;                                         The Real-Time Kernel
                                                  5:     ;
                                                  6:     ;                         (c) Copyright 2002, Jean J. Labrosse, Weston, FL
                                                  7:     ;                                          All Rights Reserved
                                                  8:     ;
                                                  9:     ;
                                                  10:    ;                                  dsPIC33FJ Board Support Package
                                                  11:    ;
                                                  12:    ;
                                                  13:    ; File         : bsp_a.s
                                                  14:    ; By           : Eric Shufro
                                                  15:    ;********************************************************************************************************
                                                  16:    ;
                                                  17:    
                                                  18:    ;
                                                  19:    ;********************************************************************************************************
                                                  20:    ;                                                CONSTANTS
                                                  21:    ;********************************************************************************************************
                                                  22:    ;
                                                  23:    ;
                                                  24:    ;********************************************************************************************************
                                                  25:    ;                                                INCLUDES
                                                  26:    ;********************************************************************************************************
                                                  27:    ;
                                                  28:    
                                                  29:    .include "xc.inc"
                                                  30:    .include "os_cpu_util_a.s"                    ; Include an assembly utility files with macros for saving and restoring the CPU registers
                                                  31:    
                                                  32:    ;
                                                  33:    ;********************************************************************************************************
                                                  34:    ;                                             LINKER SPECIFICS
                                                  35:    ;********************************************************************************************************
                                                  36:    ;
                                                  37:    
                                                  38:        .text                                                               ; Locate this file in the text region of the build
                                                  39:    
                                                  40:    ;
                                                  41:    ;********************************************************************************************************
                                                  42:    ;                                                 GLOBALS
                                                  43:    ;********************************************************************************************************
                                                  44:    ;
                                                  45:    
                                                  46:        .global __T2Interrupt
                                                  47:        .global __T4Interrupt
                                                  48:    
                                                  49:    ;
                                                  50:    ;********************************************************************************************************
                                                  51:    ;                                            OS Time Tick ISR Handler
                                                  52:    ;
                                                  53:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #2
                                                  54:    ;
                                                  55:    ; Notes       : All user interrupts should be defined as follows.
                                                  56:    ;********************************************************************************************************
                                                  57:    ;
                                                  58:    
                                                  59:    __T2Interrupt:
007A94  BE9F80     MOV.D W0, [W15++]              60:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  61:    
007AB0  208611     MOV #0x861, W1                 62:        mov   #_OSIntNesting, w1
007AB2  E84891     INC.B [W1], [W1]               63:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  64:    
007AB4  ED4861     DEC.B 0x861, WREG              65:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
007AB6  3A0002     BRA NZ, 0x7ABC                 66:        bra nz, T2_Cont
007AB8  804360     MOV 0x86C, W0                  67:        mov _OSTCBCur, w0
007ABA  78080F     MOV W15, [W0]                  68:        mov w15, [w0]
                                                  69:    
                                                  70:    T2_Cont:
007ABC  0271CC     CALL 0x71CC                    71:        call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
007AC0  02236E     CALL 0x236E                    72:        call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  73:    
007AC4  F90044     POP CORCON                     74:        OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  75:    
007AE0  064000     RETFIE                         76:        retfie                                                              ; 7) Return from interrupt
                                                  77:    
                                                  78:    
                                                  79:    ;
                                                  80:    ;********************************************************************************************************
                                                  81:    ;                                            OS Time Tick ISR Handler
                                                  82:    ;
                                                  83:    ; Description : This function services the OS Time Tick Interrupt when configured using Timer #4
                                                  84:    ;
                                                  85:    ; Notes       : All user interrupts should be defined as follows.
                                                  86:    ;********************************************************************************************************
                                                  87:    ;
                                                  88:    
                                                  89:    __T4Interrupt:
007AE2  BE9F80     MOV.D W0, [W15++]              90:        OS_REGS_SAVE                                                        ; 1) Save processor registers
                                                  91:    
007AFE  208611     MOV #0x861, W1                 92:        mov   #_OSIntNesting, w1
007B00  E84891     INC.B [W1], [W1]               93:        inc.b [w1], [w1]                                                    ; 2) Call OSIntEnter() or increment OSIntNesting
                                                  94:    
007B02  ED4861     DEC.B 0x861, WREG              95:        dec.b _OSIntNesting, wreg                                           ; 3) Check OSIntNesting. if OSIntNesting == 1, then save the stack pointer, otherwise jump to T2_Cont
007B04  3A0002     BRA NZ, 0x7B0A                 96:        bra nz, T4_Cont
007B06  804360     MOV 0x86C, W0                  97:        mov _OSTCBCur, w0
007B08  78080F     MOV W15, [W0]                  98:        mov w15, [w0]
                                                  99:    
                                                  100:   T4_Cont:
007B0A  0271CC     CALL 0x71CC                    101:       call _OS_Tick_ISR_Handler                                           ; 4) Call YOUR ISR Handler (May be a C function). In this case, the OS Tick ISR Handler
007B0E  02236E     CALL 0x236E                    102:       call _OSIntExit                                                     ; 5) Call OSIntExit() or decrement 1 from OSIntNesting
                                                  103:   
007B12  F90044     POP CORCON                     104:       OS_REGS_RESTORE                                                     ; 6) Restore registers
                                                  105:   
007B2E  064000     RETFIE                         106:       retfie                                                              ; 7) Return from interrupt
                                                  107:   
                                                  108:   
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                #include "HL6528.h"
18:                #include "E41.h"
19:                //#include <p24F32KA302.h>
20:                //#include <p24FJ64GA306.h>
21:                
22:                /*
23:                 *********************************************************************************************************
24:                 *                                       MPLAB CONFIGURATION MACROS
25:                 *********************************************************************************************************
26:                 */
27:                //#if defined(__dsPIC33E__)
28:                //// FICD
29:                //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
30:                //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
31:                //
32:                //// FPOR
33:                //#pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
34:                //#pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
35:                //#pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)
36:                //
37:                //// FWDT
38:                //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
39:                //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
40:                //#pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
41:                //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
42:                //#pragma config FWDTEN = ON              // Watchdog Timer Enable bit (Watchdog timer always enabled)
43:                //
44:                //// FOSC
45:                //#pragma config POSCMD = NONE            // Primary Oscillator Mode Select bits (Primary Oscillator disabled)
46:                //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
47:                //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
48:                //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
49:                //
50:                //// FOSCSEL
51:                //#pragma config FNOSC = FRCDIVN          // Oscillator Source Selection (Internal Fast RC (FRC) Oscillator with postscaler)
52:                //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
53:                //
54:                //// FGS
55:                //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
56:                //#pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)
57:                //#elif defined (__PIC24F__)
58:                // CONFIG4
59:                
60:                // CONFIG4
61:                //#pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68719476736 (25.7 Days))
62:                //#pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select (DSWDT uses LPRC as reference clock)
63:                //#pragma config DSBOREN = OFF            // Deep Sleep BOR Enable bit (DSBOR Disabled)
64:                //#pragma config DSWDTEN = OFF            // Deep Sleep Watchdog Timer Enable (DSWDT Disabled)
65:                //#pragma config DSSWEN = OFF             // DSEN Bit Enable (Deep Sleep operation is always disabled)
66:                //
67:                //// CONFIG3
68:                //#pragma config WPFP = WPFP63            // Write Protection Flash Page Segment Boundary (Page 52 (0xFC00))
69:                //#pragma config VBTBOR = ON              // VBAT BOR enable bit (VBAT BOR enabled)
70:                //#pragma config SOSCSEL = OFF            // SOSC Selection bits (Digital (SCLKI) mode)
71:                //#pragma config WDTWIN = PS25_0          // Watch Dog Timer Window Width (Watch Dog Timer Window Width is 25 percent)
72:                //#pragma config BOREN = ON               // Brown-out Reset Enable (Brown-out Reset Enable)
73:                //#pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Disabled)
74:                //#pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Disabled)
75:                //#pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
76:                //
77:                //// CONFIG2
78:                //#pragma config POSCMD = NONE            // Primary Oscillator Select (Primary Oscillator Disabled)
79:                //#pragma config BOREN1 = EN              // BOR Override bit (BOR Enabled [When BOREN=1])
80:                //#pragma config IOL1WAY = ON             // IOLOCK One-Way Set Enable bit (Once set, the IOLOCK bit cannot be cleared)
81:                //#pragma config OSCIOFCN = ON            // OSCO Pin Configuration (OSCO/CLKO/RC15 functions as port I/O (RC15))
82:                //#pragma config FCKSM = CSDCMD           // Clock Switching and Fail-Safe Clock Monitor Configuration bits (Clock switching and Fail-Safe Clock Monitor are disabled)
83:                //#pragma config FNOSC = FRCPLL           // Initial Oscillator Select (Fast RC Oscillator with PLL module (FRCPLL))
84:                //#pragma config ALTVREF = ALT_AV_ALT_CV  // Alternate VREF/CVREF Pins Selection bit (Voltage reference input, ADC =RB0/RB1   Comparator =RB0/RB1)
85:                //#pragma config IESO = ON                // Internal External Switchover (Enabled)
86:                //
87:                //// CONFIG1
88:                //#pragma config WDTPS = PS32768          // Watchdog Timer Postscaler Select (1:32,768)
89:                //#pragma config FWPSA = PR128            // WDT Prescaler Ratio Select (1:128)
90:                //#pragma config FWDTEN = WDT_DIS         // Watchdog Timer Enable (WDT disabled in hardware; SWDTEN bit disabled)
91:                //#pragma config WINDIS = OFF             // Windowed WDT Disable (Standard Watchdog Timer)
92:                //#pragma config ICS = PGx2               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC2/PGED2)
93:                //#pragma config LPCFG = OFF              // Low power regulator control (Disabled)
94:                //#pragma config GWRP = OFF               // General Segment Write Protect (Disabled)
95:                //#pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
96:                //#pragma config JTAGEN = OFF             // JTAG Port Enable (Disabled)
97:                
98:                
99:                //#elif defined (__PIC24E__)
100:               //#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
101:               //#pragma config GSS = OFF                // General Segment Code-Protect bit (General Segment Code protect is disabled)
102:               //#pragma config GSSK = OFF               // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)
103:               //
104:               //// FOSCSEL
105:               //#pragma config FNOSC = FRC           // Initial Oscillator Source Selection bits (Primary Oscillator (XT, HS, EC) with PLL)
106:               //#pragma config IESO = ON                // Two-speed Oscillator Start-up Enable bit (Start up device with FRC, then switch to user-selected oscillator source)
107:               //
108:               //// FOSC
109:               //#pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
110:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
111:               //#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
112:               //#pragma config FCKSM = CSDCMD           // Clock Switching Mode bits (Both Clock switching and Fail-safe Clock Monitor are disabled)
113:               //
114:               //// FWDT
115:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
116:               //#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
117:               //#pragma config PLLKEN = ON              // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
118:               //#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
119:               //#pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)
120:               //
121:               //// FPOR
122:               //#pragma config FPWRT = PWR128           // Power-on Reset Timer Value Select bits (128ms)
123:               //#pragma config BOREN = ON               // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
124:               //#pragma config ALTI2C1 = OFF            // Alternate I2C pins for I2C1 (SDA1/SCK1 pins are selected as the I/O pins for I2C1)
125:               //#pragma config ALTI2C2 = OFF            // Alternate I2C pins for I2C2 (SDA2/SCK2 pins are selected as the I/O pins for I2C2)
126:               //
127:               //// FICD
128:               //#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
129:               //#pragma config RSTPRI = PF              // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
130:               //#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)
131:               //
132:               //// FAS
133:               //#pragma config AWRP = OFF               // Auxiliary Segment Write-protect bit (Aux Flash may be written)
134:               //#pragma config APL = OFF                // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
135:               //#pragma config APLK = OFF               // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)
136:               //
137:               //#elif defined(__dsPIC33F__)
138:               //
139:               //// FBS
140:               //#pragma config BWRP = WRPROTECT_OFF     // Boot Segment Write Protect (Boot Segment may be written)
141:               //#pragma config BSS = NO_FLASH           // Boot Segment Program Flash Code Protection (No Boot program Flash segment)
142:               //#pragma config RBS = NO_RAM             // Boot Segment RAM Protection (No Boot RAM)
143:               //
144:               //// FSS
145:               //#pragma config SWRP = WRPROTECT_OFF     // Secure Segment Program Write Protect (Secure Segment may be written)
146:               //#pragma config SSS = NO_FLASH           // Secure Segment Program Flash Code Protection (No Secure Segment)
147:               //#pragma config RSS = NO_RAM             // Secure Segment Data RAM Protection (No Secure RAM)
148:               //
149:               //// FGS
150:               //#pragma config GWRP = OFF               // General Code Segment Write Protect (User program memory is not write-protected)
151:               //#pragma config GSS = OFF                // General Segment Code Protection (User program memory is not code-protected)
152:               //
153:               //// FOSCSEL
154:               //#pragma config FNOSC = LPRCDIVN           // Oscillator Mode (Primary Oscillator (XT, HS, EC) w/ PLL)
155:               //#pragma config IESO = ON                // Two-speed Oscillator Start-Up Enable (Start up with FRC, then switch)
156:               //
157:               //// FOSC
158:               //#pragma config POSCMD = XT              // Primary Oscillator Source (XT Oscillator Mode)
159:               //#pragma config OSCIOFNC = OFF           // OSC2 Pin Function (OSC2 pin has clock out function)
160:               //#pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Both Clock Switching and Fail-Safe Clock Monitor are disabled)
161:               //
162:               //// FWDT
163:               //#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler (1:32,768)
164:               //#pragma config WDTPRE = PR128           // WDT Prescaler (1:128)
165:               //#pragma config WINDIS = OFF             // Watchdog Timer Window (Watchdog Timer in Non-Window mode)
166:               //#pragma config FWDTEN = ON              // Watchdog Timer Enable (Watchdog timer always enabled)
167:               //
168:               //// FPOR
169:               //#pragma config FPWRT = PWR128           // POR Timer Value (128ms)
170:               //
171:               //// FICD
172:               //#pragma config ICS = PGD1               // Comm Channel Select (Communicate on PGC1/EMUC1 and PGD1/EMUD1)
173:               //#pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG is Disabled)
174:               //#endif
175:               /*********************************************************************************************************
176:                *                                              CONSTANTS
177:                *********************************************************************************************************
178:                */
179:               
180:               //#define  LED6   0x40                                                    /* Port A pin 6                                             */
181:               //#define  LED7   0x80                                                    /* Port A pin 7                                             */
182:               
183:               /*
184:                *********************************************************************************************************
185:                *                                              VARIABLES
186:                *********************************************************************************************************
187:                */
188:               
189:               /*
190:                *********************************************************************************************************
191:                *                                              PROTOTYPES
192:                *********************************************************************************************************
193:                */
194:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
195:               static void BSP_PLL_Init(void);
196:               #endif
197:               static void Tmr_TickInit(void);
198:               
199:               /*
200:                *********************************************************************************************************
201:                *                                         BSP INITIALIZATION
202:                *
203:                * Description : This function should be called by your application code before you make use of any of the
204:                *               functions found in this module.
205:                *
206:                * Arguments   : none
207:                *********************************************************************************************************
208:                */
209:               
210:               void BSP_Init(void) {
007088  FA0000     LNK #0x0
211:                   RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
00708A  803A00     MOV RCON, W0
00708C  A15000     BCLR W0, #5
00708E  883A00     MOV W0, RCON
212:                   //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
213:                   //    BSP_PLL_Init(); /* Initialize the PLL                                       */
214:                   //#endif
215:                   OSCILLATOR_Initialize(); //
007090  0700A4     RCALL OSCILLATOR_Initialize
216:                   Tmr_TickInit(); //UCOS
007092  07007B     RCALL _Tmr_TickInit
217:                   LED_Init(); //LED
007094  07005E     RCALL LED_Init
218:                   RTC_Init(); //
007096  07F4B6     RCALL RTC_Init
219:                   PPSInit(); //
007098  070592     RCALL PPSInit
220:                   UART2_Init(); //2GPRShl6528
00709A  07030B     RCALL UART2_Init
221:                   UART3_Init(); //3433
00709C  07037E     RCALL UART3_Init
222:                   RS485_Init(); //1485
00709E  0704A2     RCALL RS485_Init
223:                   I2C_Init(); //i2c,
0070A0  0705D7     RCALL I2C_Init
224:               //    INT0_Init(); //
225:               //    E41_Init(); //
226:               //    HL6528_Init(); /*Initialize the HL6528*/
227:               ////#ifdef CLOSE_6528
228:               ////    HL6528_Close();// 
229:               ////    UART2_Close();
230:               ////#endif
231:               //    CAT24C512_Init(); //
232:               //    //    PCF8583_Init();//PCF8583
233:               //    //        Close6528Cop(); /*Close UART2 */
234:                   WGC_Init();//WGC
0070A2  07FE39     RCALL WGC_Init
235:               }
0070A4  FA8000     ULNK
0070A6  060000     RETURN
236:               
237:               /*
238:                *********************************************************************************************************
239:                *                                      BSP_PLL_Init()
240:                *
241:                * Description : This function configures and enables the PLL with the external oscillator
242:                *               selected as the input clock to the PLL.
243:                *
244:                * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
245:                *               2) FIN is the PLL input clock frequency, defined in bsp.h as
246:                *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
247:                *                  oscillator on the Explorer 16 Evaluation Board.
248:                *               3) M is the desired PLL multiplier
249:                *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
250:                *               5) N2 is the PLL output divider (Post-Divider)
251:                *
252:                * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
253:                *                  The processor clock is (1/2) of the PLL output.
254:                *                  Performance = 40 MIPS.
255:                *********************************************************************************************************
256:                */
257:               #if defined (__dsPIC33F__) || defined(__dsPIC33E__)
258:               
259:               static void BSP_PLL_Init(void) {
260:                   PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
261:                   CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
262:               }
263:               #endif
264:               
265:               /*
266:                *********************************************************************************************************
267:                *                                      BSP_CPU_ClkFrq()
268:               
269:                * Description : This function determines the CPU clock frequency (Fcy)
270:                * Returns     : The CPU frequency in (HZ)
271:                *********************************************************************************************************
272:                */
273:               
274:               CPU_INT32U BSP_CPU_ClkFrq(void) {
0070A8  FA0008     LNK #0x8
275:                   CPU_INT08U Clk_Selected;
276:                   CPU_INT16U FRC_Div;
277:                   CPU_INT32U CPU_Clk_Frq;
278:               
279:               
280:               #if defined (__dsPIC33E__) || defined (__dsPIC33F__)
281:                   CPU_INT08U PLL_n1;
282:                   CPU_INT08U PLL_n2;
283:                   CPU_INT16U PLL_m;
284:                   PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
285:                   PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
286:                   PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
287:                   PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
288:               #endif
289:               
290:                   FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
0070AA  803A21     MOV CLKDIV, W1
0070AC  207000     MOV #0x700, W0
0070AE  608000     AND W1, W0, W0
0070B0  DE0048     LSR W0, #8, W0
0070B2  980720     MOV W0, [W14+4]
291:                   FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
0070B4  90002E     MOV [W14+4], W0
0070B6  200021     MOV #0x2, W1
0070B8  DD0800     SL W1, W0, W0
0070BA  980720     MOV W0, [W14+4]
292:               
293:                   Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
0070BC  803A11     MOV OSCCON, W1
0070BE  270000     MOV #0x7000, W0
0070C0  608000     AND W1, W0, W0
0070C2  DE004C     LSR W0, #12, W0
0070C4  984760     MOV.B W0, [W14+6]
294:               
295:                   switch (Clk_Selected) {
0070C6  90406E     MOV.B [W14+6], W0
0070C8  FB8000     ZE W0, W0
0070CA  500FE3     SUB W0, #0x3, [W15]
0070CC  32001E     BRA Z, 0x710A
0070CE  500FE3     SUB W0, #0x3, [W15]
0070D0  3C0007     BRA GT, 0x70E0
0070D2  500FE1     SUB W0, #0x1, [W15]
0070D4  320012     BRA Z, 0x70FA
0070D6  500FE1     SUB W0, #0x1, [W15]
0070D8  3C0014     BRA GT, 0x7102
0070DA  E00000     CP0 W0
0070DC  32000A     BRA Z, 0x70F2
0070DE  37002C     BRA 0x7138
0070E0  500FE5     SUB W0, #0x5, [W15]
0070E2  32001B     BRA Z, 0x711A
0070E4  500FE5     SUB W0, #0x5, [W15]
0070E6  350015     BRA LT, 0x7112
0070E8  500FE6     SUB W0, #0x6, [W15]
0070EA  32001B     BRA Z, 0x7122
0070EC  500FE7     SUB W0, #0x7, [W15]
0070EE  32001C     BRA Z, 0x7128
0070F0  370023     BRA 0x7138
296:                       case 0: /* Fast Oscillator (FRC) Selected                           */
297:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
0070F2  212000     MOV #0x1200, W0
0070F4  2007A1     MOV #0x7A, W1
0070F6  BE8F00     MOV.D W0, [W14]
298:                           break;
0070F8  370022     BRA 0x713E
299:               
300:                       case 1:
301:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
302:                           CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
303:                                   (FRC_Div * PLL_n1 * PLL_n2));
304:               #else
305:                           /* Fast Oscillator (FRC) with PLL Selected                  */
306:                           CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
0070FA  248000     MOV #0x4800, W0
0070FC  201E81     MOV #0x1E8, W1
0070FE  BE8F00     MOV.D W0, [W14]
307:               #endif
308:                           break;
007100  37001E     BRA 0x713E
309:               
310:                       case 2: /* Primary External Oscillator Selected                     */
311:                           CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
007102  212000     MOV #0x1200, W0
007104  2007A1     MOV #0x7A, W1
007106  BE8F00     MOV.D W0, [W14]
312:                           break;
007108  37001A     BRA 0x713E
313:               
314:                       case 3:
315:               #if defined (__dsPIC33E__) || defined(__dsPIC33F__)
316:                           CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
317:                                   (PLL_n1 * PLL_n2));
318:               #else
319:                           /* Primary External Oscillator with PLL Selected            */
320:                           CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
00710A  248000     MOV #0x4800, W0
00710C  201E81     MOV #0x1E8, W1
00710E  BE8F00     MOV.D W0, [W14]
321:               #endif
322:                           break;
007110  370016     BRA 0x713E
323:               
324:                       case 4: /* Secondary Oscillator Selected (SOCS)                     */
325:                           CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
007112  280000     MOV #0x8000, W0
007114  200001     MOV #0x0, W1
007116  BE8F00     MOV.D W0, [W14]
326:                           break;
007118  370012     BRA 0x713E
327:               
328:                       case 5: /* Low Power Oscillator (LPOSC) Selected                    */
329:                           CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
00711A  279180     MOV #0x7918, W0
00711C  200001     MOV #0x0, W1
00711E  BE8F00     MOV.D W0, [W14]
330:                           break;
007120  37000E     BRA 0x713E
331:               
332:                       case 6:
333:                           CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
007122  B80060     MUL.UU W0, #0, W0
007124  BE8F00     MOV.D W0, [W14]
334:                           break;
007126  37000B     BRA 0x713E
335:               
336:                       case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
337:                           CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
007128  90002E     MOV [W14+4], W0
00712A  EB0080     CLR W1
00712C  BE0100     MOV.D W0, W2
00712E  212000     MOV #0x1200, W0
007130  2007A1     MOV #0x7A, W1
007132  07CAEC     RCALL 0x70C
007134  BE8F00     MOV.D W0, [W14]
338:                           break;
007136  370003     BRA 0x713E
339:               
340:                       default:
341:                           CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
007138  B80060     MUL.UU W0, #0, W0
00713A  BE8F00     MOV.D W0, [W14]
342:                           break;
00713C  000000     NOP
343:                   }
344:               
345:                   CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
00713E  BE001E     MOV.D [W14], W0
007140  D10081     LSR W1, W1
007142  D38000     RRC W0, W0
007144  BE8F00     MOV.D W0, [W14]
346:               
347:                   return (CPU_Clk_Frq); /* Return the operating frequency                           */
007146  BE001E     MOV.D [W14], W0
348:               }
007148  FA8000     ULNK
00714A  060000     RETURN
349:               
350:               /*
351:                *********************************************************************************************************
352:                *                                     DISABLE ALL INTERRUPTS
353:                *
354:                * Description : This function disables all interrupts from the interrupt controller.
355:                *
356:                * Arguments   : none
357:                *********************************************************************************************************
358:                */
359:               
360:               void BSP_IntDisAll(void) {
00714C  FA0000     LNK #0x0
361:               }
00714E  FA8000     ULNK
007150  060000     RETURN
362:               
363:               /*
364:                *********************************************************************************************************
365:                *                                         LED I/O INITIALIZATION
366:                *
367:                * Description : This function initializes the I/O Pins used by the onboard LEDs
368:                *
369:                * Arguments   : none
370:                *
371:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
372:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
373:                *********************************************************************************************************
374:                */
375:               
376:               void LED_Init(void) {
007152  FA0000     LNK #0x0
377:                   TRISBbits.TRISB13 = 0;
007154  A9A2C9     BCLR 0x2C9, #5
378:               
379:                   LED_Off(); /* Shut off all LEDs                                        */
007156  070006     RCALL LED_Off
380:               }
007158  FA8000     ULNK
00715A  060000     RETURN
381:               
382:               /*
383:                *********************************************************************************************************
384:                *                                             LED ON
385:                *
386:                * Description : This function is used to control any or all the LEDs on the board.
387:                *
388:                * Arguments   : led    is the number of the LED to control
389:                *                      0    indicates that you want ALL the LEDs to be ON
390:                *                      1    turns ON LED1
391:                *                      2    turns ON LED2
392:                *                      ...
393:                *                      8    turns ON LED8
394:                *
395:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
396:                *********************************************************************************************************
397:                */
398:               
399:               void LED_On(void) {
00715C  FA0000     LNK #0x0
400:                   PORTBbits.RB13 = 1;
00715E  A8A2CB     BSET 0x2CB, #5
401:               }
007160  FA8000     ULNK
007162  060000     RETURN
402:               
403:               /*
404:                *********************************************************************************************************
405:                *                                             LED OFF
406:                *
407:                * Description : This function is used to control any or all the LEDs on the board.
408:                *
409:                * Arguments   : led    is the number of the LED to turn OFF
410:                *                      0    indicates that you want ALL the LEDs to be OFF
411:                *                      1    turns OFF LED1
412:                *                      2    turns OFF LED2
413:                *                      .
414:                *                      8    turns OFF LED8
415:                *
416:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
417:                *********************************************************************************************************
418:                */
419:               
420:               void LED_Off(void) {
007164  FA0000     LNK #0x0
421:                   LATBbits.LATB13 = 0;
007166  A9A2CD     BCLR 0x2CD, #5
422:               }
007168  FA8000     ULNK
00716A  060000     RETURN
423:               
424:               /*
425:                *********************************************************************************************************
426:                *                                             LED TOGGLE
427:                *
428:                * Description : This function is used to toggle any or all the LEDs on the board.
429:                *
430:                * Arguments   : led    is the number of the LED to control
431:                *                      0    indicates that you want to toggle ALL the LEDs
432:                *                      1    toggles LED1
433:                *                      2    toggles LED2
434:                *                      .
435:                *                      8    toggles LED8
436:                *
437:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
438:                *********************************************************************************************************
439:                */
440:               
441:               void LED_Toggle(void) {
00716C  FA0000     LNK #0x0
442:                   LATBbits.LATB13 ^= 1;
00716E  801660     MOV LATB, W0
007170  DE004D     LSR W0, #13, W0
007172  604061     AND.B W0, #0x1, W0
007174  A20400     BTG.B W0, #0
007176  604061     AND.B W0, #0x1, W0
007178  FB8000     ZE W0, W0
00717A  600061     AND W0, #0x1, W0
00717C  DD004D     SL W0, #13, W0
00717E  801661     MOV LATB, W1
007180  A1D001     BCLR W1, #13
007182  700001     IOR W0, W1, W0
007184  881660     MOV W0, LATB
443:               }
007186  FA8000     ULNK
007188  060000     RETURN
444:               
445:               /*
446:                *********************************************************************************************************
447:                *                                   OSProbe_TmrInit()
448:                *
449:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
450:                *               free running timer that is used to make time measurements.
451:                *
452:                * Arguments   : none
453:                *
454:                * Returns     : none
455:                *
456:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
457:                *                  from Tmr_TickInit().
458:                *********************************************************************************************************
459:                */
460:               
461:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
462:               
463:               void OSProbe_TmrInit(void) {
464:               #if OS_PROBE_TIMER_SEL == 3
465:                   T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
466:                   TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
467:                   PR3 = 0xFFFF; /* Set the period register to its maximum value             */
468:                   T3CON |= TON; /* Start the timer                                          */
469:               #endif
470:               
471:               #if OS_PROBE_TIMER_SEL == 5
472:                   T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
473:                   TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
474:                   PR5 = 0xFFFF; /* Set the period register to its maximum value             */
475:                   T5CON |= TON; /* Start the timer                                          */
476:               #endif
477:               }
478:               #endif
479:               
480:               /*
481:                *********************************************************************************************************
482:                *                                   OSProbe_TmrRd()
483:                *
484:                * Description : This function is called to read the current counts of a 16 bit free running timer.
485:                *
486:                * Arguments   : none
487:                *
488:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
489:                *********************************************************************************************************
490:                */
491:               
492:               #if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
493:               
494:               CPU_INT32U OSProbe_TmrRd(void) {
495:               #if OS_PROBE_TIMER_SEL == 3
496:                   return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
497:               #endif
498:               
499:               #if OS_PROBE_TIMER_SEL == 5
500:                   return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
501:               #endif
502:               }
503:               #endif
504:               
505:               /*
506:                *********************************************************************************************************
507:                *                                       TICKER INITIALIZATION
508:                *
509:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
510:                *               interrupts every 1 to 100 mS).
511:                *
512:                * Arguments   : none
513:                *
514:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
515:                *               2) The timer resets to 0 after period register match interrupt is generated
516:                *********************************************************************************************************
517:                */
518:               
519:               static void Tmr_TickInit(void) {
00718A  FA0006     LNK #0x6
520:                   CPU_INT32U tmr_frq;
521:                   CPU_INT16U cnts;
522:               
523:               
524:                   tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
00718C  07FF8D     RCALL BSP_CPU_ClkFrq
00718E  BE8F00     MOV.D W0, [W14]
525:                   cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
007190  BE001E     MOV.D [W14], W0
007192  203E82     MOV #0x3E8, W2
007194  200003     MOV #0x0, W3
007196  07CAC9     RCALL 0x72A
007198  780000     MOV W0, W0
00719A  E90000     DEC W0, W0
00719C  980720     MOV W0, [W14+4]
526:               
527:               #if BSP_OS_TMR_SEL == 2
528:                   T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
00719E  EF2110     CLR T2CON
529:                   TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
0071A0  EF2106     CLR TMR2
530:                   PR2 = cnts; /* Set the period register                                  */
0071A2  9000AE     MOV [W14+4], W1
0071A4  880861     MOV W1, PR2
531:                   IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
0071A6  800531     MOV IPC1, W1
0071A8  28FFF0     MOV #0x8FFF, W0
0071AA  608000     AND W1, W0, W0
0071AC  880530     MOV W0, IPC1
532:                   IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
0071AE  800530     MOV IPC1, W0
0071B0  A0E000     BSET W0, #14
0071B2  880530     MOV W0, IPC1
533:                   IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
0071B4  800420     MOV IFS0, W0
0071B6  A17000     BCLR W0, #7
0071B8  880420     MOV W0, IFS0
534:                   IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
0071BA  8004A0     MOV IEC0, W0
0071BC  A07000     BSET W0, #7
0071BE  8804A0     MOV W0, IEC0
535:                   T2CON |= TON; /* Start the timer                                          */
0071C0  800881     MOV T2CON, W1
0071C2  280000     MOV #0x8000, W0
0071C4  700001     IOR W0, W1, W0
0071C6  880880     MOV W0, T2CON
536:               #endif
537:               
538:               #if BSP_OS_TMR_SEL == 4
539:                   T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
540:                   TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
541:                   PR4 = cnts; /* Set the period register                                  */
542:                   IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
543:                   IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
544:                   IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
545:                   IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
546:                   T4CON |= TON; /* Start the timer                                          */
547:               #endif
548:               }
0071C8  FA8000     ULNK
0071CA  060000     RETURN
549:               
550:               /*
551:                *********************************************************************************************************
552:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
553:                *
554:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
555:                *********************************************************************************************************
556:                */
557:               
558:               void OS_Tick_ISR_Handler(void) {
0071CC  FA0000     LNK #0x0
559:               #if  BSP_OS_TMR_SEL == 2
560:                   IFS0 &= ~T2IF;
0071CE  800420     MOV IFS0, W0
0071D0  A17000     BCLR W0, #7
0071D2  880420     MOV W0, IFS0
561:               #endif
562:               
563:               #if  BSP_OS_TMR_SEL == 4
564:                   IFS1 &= ~T41F;
565:               #endif
566:               
567:                   OSTimeTick();
0071D4  07D978     RCALL OSTimeTick
568:               }
0071D6  FA8000     ULNK
0071D8  060000     RETURN
569:               
570:               //void OSC_Unlock_Sequence(void) {
571:                   //        //Place the new oscillator selection in W0
572:                   //        //OSCCONH (high byte) Unlock Sequence
573:                   //        asm("MOV #OSCCONH,w1");
574:                   //        asm("MOV #0x78, w2");
575:                   //        asm("MOV #0x9A, w3");
576:                   //        asm("MOV.b w2, [w1]");
577:                   //        asm("MOV.b w3, [w1]");
578:                   //        //Set new oscillator selection
579:                   //        asm("MOV.b WREG, OSCCONH");
580:                   //        //OSCCONL (low byte) unlock sequence
581:                   //        asm("MOV #OSCCONL,w1");
582:                   //        asm("MOV.b #0x01, w0");
583:                   //        asm("MOV #0x46, w2");
584:                   //        asm("MOV #0x57, w3");
585:                   //        asm("MOV.b w2, [w1]");
586:                   //        asm("MOV.b w3, [w1]");
587:                   //        //Start oscillator switch operation
588:                   //        asm("MOV.b w0, [w1]");
589:               //    __builtin_write_OSCCONH(0x03);
590:               //    __builtin_write_OSCCONL(0x02);
591:                   //    OSCCONbits.LOCK = 1;
592:               //    OSCCONbits.OSWEN = 1;
593:               //    OSCCONbits.LOCK = 0;
594:               //}
595:               //
596:               
597:               void OSCILLATOR_Initialize(void) {
0071DA  FA0000     LNK #0x0
598:                   // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
599:                   CLKDIV = 0x3000;
0071DC  230000     MOV #0x3000, W0
0071DE  883A20     MOV W0, CLKDIV
600:               
601:                   // Set the secondary oscillator    
602:                   OSCCONbits.SOSCEN = 1; //
0071E0  A82742     BSET OSCCON, #1
603:                   __builtin_write_OSCCONL(0x02);
0071E2  200022     MOV #0x2, W2
0071E4  200460     MOV #0x46, W0
0071E6  200571     MOV #0x57, W1
0071E8  207423     MOV #0x742, W3
0071EA  784980     MOV.B W0, [W3]
0071EC  784981     MOV.B W1, [W3]
0071EE  784982     MOV.B W2, [W3]
604:                   //    OSCCONbits.OSWEN = 1;
605:                   //    OSC_Unlock_Sequence(); //
606:               }
0071F0  FA8000     ULNK
607:               
608:               
609:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/UART3.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
00779A  FA0000     LNK #0x0
6:                     TRISGbits.TRISG8 = 1; //
00779C  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //
00779E  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //
0077A0  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
0077A2  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1;//
0077A4  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //
12:                    //    TRISDbits.TRISD2 = 0; //
13:                
14:                    U3MODEbits.BRGH = 0; //1:16
0077A6  A96250     BCLR U3MODE, #3
15:                    U3BRG = 103; //19200 103; //16000000/9600/16-1
0077A8  200670     MOV #0x67, W0
0077AA  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //
0077AC  801281     MOV U3MODE, W1
0077AE  2FFF90     MOV #0xFFF9, W0
0077B0  608000     AND W1, W0, W0
0077B2  881280     MOV W0, U3MODE
17:                    U3MODEbits.STSEL = 0; //1
0077B4  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //
0077B6  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; // 4  1
0077B8  801291     MOV U3STA, W1
0077BA  200C00     MOV #0xC0, W0
0077BC  700001     IOR W0, W1, W0
0077BE  881290     MOV W0, U3STA
22:                    IFS5bits.U3RXIF = 0; //  
0077C0  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
0077C2  800661     MOV IPC20, W1
0077C4  2F8FF0     MOV #0xF8FF, W0
0077C6  608080     AND W1, W0, W1
0077C8  206000     MOV #0x600, W0
0077CA  700001     IOR W0, W1, W0
0077CC  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //
0077CE  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
0077D0  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
0077D2  800661     MOV IPC20, W1
0077D4  200700     MOV #0x70, W0
0077D6  700001     IOR W0, W1, W0
0077D8  880660     MOV W0, IPC20
27:                    IEC5bits.U3ERIE = 1;
0077DA  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //  
0077DC  A84253     BSET 0x253, #2
29:                }
0077DE  FA8000     ULNK
0077E0  060000     RETURN
30:                
31:                void UART3_Open(void) {
0077E2  FA0000     LNK #0x0
32:                    U3MODEbits.UARTEN = 1; //
0077E4  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //  
0077E6  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
0077E8  A8409E     BSET IEC5, #2
36:                }
0077EA  FA8000     ULNK
0077EC  060000     RETURN
37:                
38:                void UART3_Close(void) {
0077EE  FA0000     LNK #0x0
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
0077F0  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //  
0077F2  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //    
0077F4  A9E251     BCLR 0x251, #7
43:                }
0077F6  FA8000     ULNK
0077F8  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
0077FA  FA0002     LNK #0x2
0077FC  784F00     MOV.B W0, [W14]
46:                    U3TXREG = ch;
0077FE  FB801E     ZE [W14], W0
007800  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
007802  000000     NOP
007804  801291     MOV U3STA, W1
007806  201000     MOV #0x100, W0
007808  608000     AND W1, W0, W0
00780A  E00000     CP0 W0
00780C  32FFFB     BRA Z, 0x7804
48:                }
00780E  FA8000     ULNK
007810  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
007812  FA0006     LNK #0x6
007814  980710     MOV W0, [W14+2]
007816  984741     MOV.B W1, [W14+4]
51:                    uint8_t bytes = 0;
007818  EB4000     CLR.B W0
00781A  784F00     MOV.B W0, [W14]
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
00781C  EB4000     CLR.B W0
00781E  784F00     MOV.B W0, [W14]
007820  370006     BRA 0x782E
00782C  E84F1E     INC.B [W14], [W14]
00782E  90404E     MOV.B [W14+4], W0
007830  78409E     MOV.B [W14], W1
007832  50CF80     SUB.B W1, W0, [W15]
007834  39FFF6     BRA NC, 0x7822
53:                        UART3_SendChar(*(str + bytes));
007822  FB801E     ZE [W14], W0
007824  90009E     MOV [W14+2], W1
007826  408000     ADD W1, W0, W0
007828  784010     MOV.B [W0], W0
00782A  07FFE7     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
007836  78401E     MOV.B [W14], W0
57:                }
007838  FA8000     ULNK
00783A  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
00783C  FA0002     LNK #0x2
00783E  780F00     MOV W0, [W14]
60:                    if (U3STAbits.URXDA) {
007840  801290     MOV U3STA, W0
007842  600061     AND W0, #0x1, W0
007844  E00000     CP0 W0
007846  320006     BRA Z, 0x7854
61:                        *ch = U3RXREG;
007848  8012B0     MOV U3RXREG, W0
00784A  784080     MOV.B W0, W1
00784C  78001E     MOV [W14], W0
00784E  784801     MOV.B W1, [W0]
62:                        return true;
007850  B3C010     MOV.B #0x1, W0
007852  370001     BRA 0x7856
63:                    } else
64:                        return false;
007854  EB4000     CLR.B W0
65:                }
007856  FA8000     ULNK
007858  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//4
00785A  FA0002     LNK #0x2
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//
00785C  EB4000     CLR.B W0
00785E  784F00     MOV.B W0, [W14]
007860  370006     BRA 0x786E
00786C  E84F1E     INC.B [W14], [W14]
00786E  78401E     MOV.B [W14], W0
007870  504FE3     SUB.B W0, #0x3, [W15]
007872  36FFF7     BRA LEU, 0x7862
70:                        if (U3STAbits.URXDA) //
007862  801290     MOV U3STA, W0
007864  600061     AND W0, #0x1, W0
007866  E00000     CP0 W0
007868  320001     BRA Z, 0x786C
71:                            BufferWrite_UART3();
00786A  07F287     RCALL BufferWrite_UART3
72:                }
007874  FA8000     ULNK
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/UART2.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART2.h"
3:                 
4:                 void UART2_Init(void) {
0076B2  FA0000     LNK #0x0
5:                     //
6:                     TRISDbits.TRISD2 = 1; //
0076B4  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //
0076B6  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //
9:                     //    TRISDbits.TRISD2 = 0; //
10:                
11:                    U2MODEbits.BRGH = 0; //1:16
0076B8  A96230     BCLR U2MODE, #3
12:                    U2BRG = 51; //19200 103; //16000000/9600/16-1
0076BA  200330     MOV #0x33, W0
0076BC  8811C0     MOV W0, U2BRG
13:                    U2MODEbits.PDSEL = 00; //
0076BE  801181     MOV U2MODE, W1
0076C0  2FFF90     MOV #0xFFF9, W0
0076C2  608000     AND W1, W0, W0
0076C4  881180     MOV W0, U2MODE
14:                    U2MODEbits.STSEL = 0; //1
0076C6  A90230     BCLR U2MODE, #0
15:                
16:                    U2MODEbits.UARTEN = 1; //
0076C8  A8E231     BSET 0x231, #7
17:                
18:                    U2STAbits.UTXEN = 1; //  
0076CA  A84233     BSET 0x233, #2
19:                    U2STAbits.URXISEL = 3; // 4  1
0076CC  801191     MOV U2STA, W1
0076CE  200C00     MOV #0xC0, W0
0076D0  700001     IOR W0, W1, W0
0076D2  881190     MOV W0, U2STA
20:                    IEC1bits.U2RXIE = 1; //
0076D4  A8C097     BSET 0x97, #6
21:                    IFS1bits.U2RXIF = 0; //
0076D6  A9C087     BCLR 0x87, #6
22:                    IEC4bits.U2ERIE = 1;
0076D8  A8409C     BSET IEC4, #2
23:                    IFS4bits.U2ERIF = 0;
0076DA  A9408C     BCLR IFS4, #2
24:                }
0076DC  FA8000     ULNK
0076DE  060000     RETURN
25:                
26:                void UART2_Open(void) {
0076E0  FA0000     LNK #0x0
27:                    U2MODEbits.UARTEN = 1; //
0076E2  A8E231     BSET 0x231, #7
28:                    U2STAbits.UTXEN = 1; //  
0076E4  A84233     BSET 0x233, #2
29:                    // IEC1bits.U2TXIE=1;
30:                    IEC1bits.U2RXIE = 1;
0076E6  A8C097     BSET 0x97, #6
31:                }
0076E8  FA8000     ULNK
0076EA  060000     RETURN
32:                
33:                void UART2_Close(void) {
0076EC  FA0000     LNK #0x0
34:                    // IEC1bits.U2TXIE=0;
35:                    IEC1bits.U2RXIE = 0;
0076EE  A9C097     BCLR 0x97, #6
36:                    U2STAbits.UTXEN = 1; //  
0076F0  A84233     BSET 0x233, #2
37:                    U2MODEbits.UARTEN = 0; //    
0076F2  A9E231     BCLR 0x231, #7
38:                }
0076F4  FA8000     ULNK
0076F6  060000     RETURN
39:                
40:                void UART2_SendChar(uint8_t ch) {
0076F8  FA0002     LNK #0x2
0076FA  784F00     MOV.B W0, [W14]
41:                    U2TXREG = ch;
0076FC  FB801E     ZE [W14], W0
0076FE  8811A0     MOV W0, U2TXREG
42:                    while (!U2STAbits.TRMT);
007700  000000     NOP
007702  801191     MOV U2STA, W1
007704  201000     MOV #0x100, W0
007706  608000     AND W1, W0, W0
007708  E00000     CP0 W0
00770A  32FFFB     BRA Z, 0x7702
43:                }
00770C  FA8000     ULNK
00770E  060000     RETURN
44:                
45:                uint8_t UART2_SendString(const uint8_t *str) {
007710  FA0004     LNK #0x4
007712  980710     MOV W0, [W14+2]
46:                    uint8_t bytes = 0;
007714  EB4000     CLR.B W0
007716  784F00     MOV.B W0, [W14]
47:                    while (*str != '\0') {
007718  370007     BRA 0x7728
007728  90001E     MOV [W14+2], W0
00772A  784010     MOV.B [W0], W0
00772C  E00400     CP0.B W0
00772E  3AFFF5     BRA NZ, 0x771A
48:                        UART2_SendChar(*str++);
00771A  90001E     MOV [W14+2], W0
00771C  784010     MOV.B [W0], W0
00771E  90009E     MOV [W14+2], W1
007720  E80081     INC W1, W1
007722  980711     MOV W1, [W14+2]
007724  07FFE9     RCALL UART2_SendChar
49:                        bytes++;
007726  E84F1E     INC.B [W14], [W14]
50:                    }
51:                    return bytes;
007730  78401E     MOV.B [W14], W0
52:                }
007732  FA8000     ULNK
007734  060000     RETURN
53:                
54:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
007736  FA0006     LNK #0x6
007738  980710     MOV W0, [W14+2]
00773A  984741     MOV.B W1, [W14+4]
55:                    uint8_t bytes = 0;
00773C  EB4000     CLR.B W0
00773E  784F00     MOV.B W0, [W14]
56:                    while (bytes < len) {
007740  370007     BRA 0x7750
007750  90404E     MOV.B [W14+4], W0
007752  78409E     MOV.B [W14], W1
007754  50CF80     SUB.B W1, W0, [W15]
007756  39FFF5     BRA NC, 0x7742
57:                        UART2_SendChar(*str++);
007742  90001E     MOV [W14+2], W0
007744  784010     MOV.B [W0], W0
007746  90009E     MOV [W14+2], W1
007748  E80081     INC W1, W1
00774A  980711     MOV W1, [W14+2]
00774C  07FFD5     RCALL UART2_SendChar
58:                        bytes++;
00774E  E84F1E     INC.B [W14], [W14]
59:                    }
60:                    return bytes;
007758  78401E     MOV.B [W14], W0
61:                }
00775A  FA8000     ULNK
00775C  060000     RETURN
62:                
63:                bool UART2_ReceiveChar(uint8_t * ch) {
00775E  FA0002     LNK #0x2
007760  780F00     MOV W0, [W14]
64:                    if (U2STAbits.URXDA) {
007762  801190     MOV U2STA, W0
007764  600061     AND W0, #0x1, W0
007766  E00000     CP0 W0
007768  320006     BRA Z, 0x7776
65:                        *ch = U2RXREG;
00776A  8011B0     MOV U2RXREG, W0
00776C  784080     MOV.B W0, W1
00776E  78001E     MOV [W14], W0
007770  784801     MOV.B W1, [W0]
66:                        return true;
007772  B3C010     MOV.B #0x1, W0
007774  370001     BRA 0x7778
67:                    } else
68:                        return false;
007776  EB4000     CLR.B W0
69:                }
007778  FA8000     ULNK
00777A  060000     RETURN
70:                
71:                void U2Rx4Byte(void) {//4
00777C  FA0002     LNK #0x2
72:                    uint8_t cnt;
73:                    for (cnt = 0; cnt < 4; cnt++)//
00777E  EB4000     CLR.B W0
007780  784F00     MOV.B W0, [W14]
007782  370006     BRA 0x7790
00778E  E84F1E     INC.B [W14], [W14]
007790  78401E     MOV.B [W14], W0
007792  504FE3     SUB.B W0, #0x3, [W15]
007794  36FFF7     BRA LEU, 0x7784
74:                        if (U2STAbits.URXDA) //
007784  801190     MOV U2STA, W0
007786  600061     AND W0, #0x1, W0
007788  E00000     CP0 W0
00778A  320001     BRA Z, 0x778E
75:                            BufferWrite_UART2();
00778C  07F2DB     RCALL BufferWrite_UART2
76:                }
007796  FA8000     ULNK
77:                
78:                
79:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/RTCC.c  --------------------------------------
1:                 #include "RTCC.h"
2:                 #include <xc.h>
3:                 
4:                 /*************************************
5:                 Function: RTC_Configuration 
6:                 Description: 
7:                 Input: 
8:                 Output: 
9:                  *************************************/
10:                void RTC_Init(void) {
005A04  FA0008     LNK #0x8
11:                    uint8_t rtcc_tmp[7] = {0x20, 0x17, 0x10, 0x6, 0x12, 0x30, 0x07};
005A06  29FE81     MOV #0x9FE8, W1
005A08  090006     REPEAT #0x6
005A0A  785F31     MOV.B [W1++], [W14++]
005A0C  B1007E     SUB #0x7, W14
12:                    // Set the RTCWREN bit
13:                    __builtin_write_RTCWEN(); //unlock sequence
005A0E  200550     MOV #0x55, W0
005A10  883B30     MOV W0, NVMKEY
005A12  200AA0     MOV #0xAA, W0
005A14  883B30     MOV W0, NVMKEY
005A16  A8A627     BSET 0x627, #5
14:                
15:                    RCFGCALbits.RTCPTR = 3; //RTCC 
005A18  803131     MOV RCFGCAL, W1
005A1A  203000     MOV #0x300, W0
005A1C  700001     IOR W0, W1, W0
005A1E  883130     MOV W0, RCFGCAL
16:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
005A20  90401E     MOV.B [W14+1], W0
005A22  FB8000     ZE W0, W0
005A24  883120     MOV W0, RTCVAL
17:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
005A26  90402E     MOV.B [W14+2], W0
005A28  FB8000     ZE W0, W0
005A2A  DD00C8     SL W0, #8, W1
005A2C  90403E     MOV.B [W14+3], W0
005A2E  FB8000     ZE W0, W0
005A30  408000     ADD W1, W0, W0
005A32  883120     MOV W0, RTCVAL
18:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
005A34  90404E     MOV.B [W14+4], W0
005A36  FB8000     ZE W0, W0
005A38  883120     MOV W0, RTCVAL
19:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //  
005A3A  90405E     MOV.B [W14+5], W0
005A3C  FB8000     ZE W0, W0
005A3E  DD00C8     SL W0, #8, W1
005A40  90406E     MOV.B [W14+6], W0
005A42  FB8000     ZE W0, W0
005A44  408000     ADD W1, W0, W0
005A46  883120     MOV W0, RTCVAL
20:                
21:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
22:                    //    RTCPWC = 0x0000;
23:                
24:                    //    ALCFGRPTbits.AMASK = 0b0110; ////0b0011; -1s  0x11
25:                    //    ALCFGRPTbits.CHIME = 1; //1 =  ARPT<7:0>  00h  FFh
26:                    ALCFGRPTbits.ALRMEN = 0; //
005A48  A9E623     BCLR 0x623, #7
27:                    ALCFGRPTbits.ALRMPTR = 2; //
005A4A  803111     MOV ALCFGRPT, W1
005A4C  2FCFF0     MOV #0xFCFF, W0
005A4E  608000     AND W1, W0, W0
005A50  A09000     BSET W0, #9
005A52  883110     MOV W0, ALCFGRPT
28:                    //        ALRMVAL = 0x0000; //none       
29:                    ALRMVAL = 0x0000; //month day 0001
005A54  EF2620     CLR ALRMVAL
30:                    ALRMVAL = 0x0000; //week hour
005A56  EF2620     CLR ALRMVAL
31:                    ALRMVAL = 0x0000; //minute second  0000
005A58  EF2620     CLR ALRMVAL
32:                    //    ALRMVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //  2016.6.1. 3 13:10:10
33:                    //    ALRMVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; // 
34:                    //    ALRMVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //  
35:                    //    ALRMVAL = (rtcc_tmp[5] << 8) + 0x25; //rtcc_tmp[6] ; //0x3050; //  
36:                    //    ALCFGRPTbits.ARPT=0;
37:                    //    ALCFGRPTbits.ALRMEN = 1; //  ARPT<7:0> = 00  CHIME = 0     
38:                
39:                    // ALRMEN enabled; ARPT 0; AMASK Every Second; CHIME enabled; ALRMPTR MIN_SEC; 
40:                    ALCFGRPT = 0xD800; //    every day once 
005A5A  2D8000     MOV #0xD800, W0
005A5C  883110     MOV W0, ALCFGRPT
41:                    //    ALCFGRPT = 0xC800;
42:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
43:                    RTCPWC = 0x0000;
005A5E  EF2628     CLR RTCPWC
44:                    IPC15bits.RTCIP = 6;
005A60  800611     MOV IPC15, W1
005A62  2F8FF0     MOV #0xF8FF, W0
005A64  608080     AND W1, W0, W1
005A66  206000     MOV #0x600, W0
005A68  700001     IOR W0, W1, W0
005A6A  880610     MOV W0, IPC15
45:                    IFS3bits.RTCIF = 0; //
005A6C  A9C08B     BCLR 0x8B, #6
46:                    IEC3bits.RTCIE = 1; // =1
005A6E  A8C09B     BSET 0x9B, #6
47:                
48:                    RCFGCALbits.RTCEN = 1; // RTCC 
005A70  A8E627     BSET 0x627, #7
49:                    RCFGCALbits.RTCWREN = 0; //RTCC
005A72  A9A627     BCLR 0x627, #5
50:                }
005A74  FA8000     ULNK
005A76  060000     RETURN
51:                
52:                void RTC_Set_Alarm(struct tm initialTime) {
005A78  FA0000     LNK #0x0
005A7A  781F88     MOV W8, [W15++]
53:                    // ALRMEN = 0RTCSYNC = 0  ALCFGRPT  CHIME 
54:                //    __builtin_write_RTCWEN(); //unlock sequence
55:                    ALCFGRPTbits.ALRMEN = 0; //
005A7C  A9E623     BCLR 0x623, #7
56:                    while (RCFGCALbits.RTCSYNC); //
005A7E  000000     NOP
005A80  803131     MOV RCFGCAL, W1
005A82  210000     MOV #0x1000, W0
005A84  608000     AND W1, W0, W0
005A86  E00000     CP0 W0
005A88  3AFFFB     BRA NZ, 0x5A80
57:                    ALCFGRPTbits.ALRMPTR = 2; //
005A8A  803111     MOV ALCFGRPT, W1
005A8C  2FCFF0     MOV #0xFCFF, W0
005A8E  608000     AND W1, W0, W0
005A90  A09000     BSET W0, #9
005A92  883110     MOV W0, ALCFGRPT
58:                    ALRMVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday);
005A94  97B80E     MOV [W14-16], W0
005A96  0705FE     RCALL DCH
005A98  DD0448     SL W0, #8, W8
005A9A  97B07E     MOV [W14-18], W0
005A9C  0705FB     RCALL DCH
005A9E  440000     ADD W8, W0, W0
005AA0  883100     MOV W0, ALRMVAL
59:                    ALRMVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour);
005AA2  97B82E     MOV [W14-12], W0
005AA4  0705F7     RCALL DCH
005AA6  DD0448     SL W0, #8, W8
005AA8  97B06E     MOV [W14-20], W0
005AAA  0705F4     RCALL DCH
005AAC  440000     ADD W8, W0, W0
005AAE  883100     MOV W0, ALRMVAL
60:                    ALRMVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec);
005AB0  97B05E     MOV [W14-22], W0
005AB2  0705F0     RCALL DCH
005AB4  DD0448     SL W0, #8, W8
005AB6  97B04E     MOV [W14-24], W0
005AB8  0705ED     RCALL DCH
005ABA  440000     ADD W8, W0, W0
005ABC  883100     MOV W0, ALRMVAL
61:                    ALCFGRPTbits.ALRMEN = 1; //
005ABE  A8E623     BSET 0x623, #7
62:                //    RCFGCALbits.RTCWREN = 0; //RTCC
63:                }
005AC0  78044F     MOV [--W15], W8
005AC2  FA8000     ULNK
005AC4  060000     RETURN
64:                
65:                /*************************************
66:                Function: RTC_ReadTime 
67:                Description: 
68:                Input: 4u16 
69:                Output: 
70:                 *************************************/
71:                bool RTC_Read_Time(struct tm*currentTime) {
005AC6  FA0004     LNK #0x4
005AC8  980710     MOV W0, [W14+2]
72:                    uint16_t time_tmp;
73:                    if (RCFGCALbits.RTCSYNC)//
005ACA  803132     MOV RCFGCAL, W2
005ACC  210000     MOV #0x1000, W0
005ACE  610000     AND W2, W0, W0
005AD0  E00000     CP0 W0
005AD2  320002     BRA Z, 0x5AD8
74:                        return false;
005AD4  EB4000     CLR.B W0
005AD6  37006E     BRA 0x5BB4
75:                
76:                    __builtin_write_RTCWEN(); // Set the RTCWREN bit
005AD8  200551     MOV #0x55, W1
005ADA  883B31     MOV W1, NVMKEY
005ADC  200AA1     MOV #0xAA, W1
005ADE  883B31     MOV W1, NVMKEY
005AE0  A8A627     BSET 0x627, #5
77:                
78:                    RCFGCALbits.RTCPTR = 3; //RTCC 
005AE2  803131     MOV RCFGCAL, W1
005AE4  203000     MOV #0x300, W0
005AE6  700001     IOR W0, W1, W0
005AE8  883130     MOV W0, RCFGCAL
79:                    time_tmp = RTCVAL; // 
005AEA  803121     MOV RTCVAL, W1
005AEC  780F01     MOV W1, [W14]
80:                    currentTime->tm_year = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
005AEE  200F00     MOV #0xF0, W0
005AF0  60001E     AND W0, [W14], W0
005AF2  DE0044     LSR W0, #4, W0
005AF4  B9006A     MUL.SU W0, #10, W0
005AF6  780080     MOV W0, W1
005AF8  78011E     MOV [W14], W2
005AFA  61006F     AND W2, #0xF, W0
005AFC  408000     ADD W1, W0, W0
005AFE  780080     MOV W0, W1
005B00  90001E     MOV [W14+2], W0
005B02  980051     MOV W1, [W0+10]
81:                    RCFGCALbits.RTCPTR = 2;
005B04  803131     MOV RCFGCAL, W1
005B06  2FCFF0     MOV #0xFCFF, W0
005B08  608000     AND W1, W0, W0
005B0A  A09000     BSET W0, #9
005B0C  883130     MOV W0, RCFGCAL
82:                    time_tmp = RTCVAL; //
005B0E  803121     MOV RTCVAL, W1
005B10  780F01     MOV W1, [W14]
83:                    currentTime->tm_mon = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
005B12  78001E     MOV [W14], W0
005B14  DE004C     LSR W0, #12, W0
005B16  B9006A     MUL.SU W0, #10, W0
005B18  780080     MOV W0, W1
005B1A  78001E     MOV [W14], W0
005B1C  DE0048     LSR W0, #8, W0
005B1E  60006F     AND W0, #0xF, W0
005B20  408000     ADD W1, W0, W0
005B22  780080     MOV W0, W1
005B24  90001E     MOV [W14+2], W0
005B26  980041     MOV W1, [W0+8]
84:                    currentTime->tm_mday = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
005B28  200F00     MOV #0xF0, W0
005B2A  60001E     AND W0, [W14], W0
005B2C  DE0044     LSR W0, #4, W0
005B2E  B9006A     MUL.SU W0, #10, W0
005B30  780080     MOV W0, W1
005B32  78011E     MOV [W14], W2
005B34  61006F     AND W2, #0xF, W0
005B36  408000     ADD W1, W0, W0
005B38  780080     MOV W0, W1
005B3A  90001E     MOV [W14+2], W0
005B3C  980031     MOV W1, [W0+6]
85:                    RCFGCALbits.RTCPTR = 1;
005B3E  803131     MOV RCFGCAL, W1
005B40  2FCFF0     MOV #0xFCFF, W0
005B42  608000     AND W1, W0, W0
005B44  A08000     BSET W0, #8
005B46  883130     MOV W0, RCFGCAL
86:                    time_tmp = RTCVAL; //
005B48  803121     MOV RTCVAL, W1
005B4A  780F01     MOV W1, [W14]
87:                    currentTime->tm_wday = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
005B4C  78001E     MOV [W14], W0
005B4E  DE004C     LSR W0, #12, W0
005B50  B9006A     MUL.SU W0, #10, W0
005B52  780080     MOV W0, W1
005B54  78001E     MOV [W14], W0
005B56  DE0048     LSR W0, #8, W0
005B58  60006F     AND W0, #0xF, W0
005B5A  408000     ADD W1, W0, W0
005B5C  780080     MOV W0, W1
005B5E  90001E     MOV [W14+2], W0
005B60  980061     MOV W1, [W0+12]
88:                    currentTime->tm_hour = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
005B62  200F00     MOV #0xF0, W0
005B64  60001E     AND W0, [W14], W0
005B66  DE0044     LSR W0, #4, W0
005B68  B9006A     MUL.SU W0, #10, W0
005B6A  780080     MOV W0, W1
005B6C  78011E     MOV [W14], W2
005B6E  61006F     AND W2, #0xF, W0
005B70  408000     ADD W1, W0, W0
005B72  780080     MOV W0, W1
005B74  90001E     MOV [W14+2], W0
005B76  980021     MOV W1, [W0+4]
89:                    RCFGCALbits.RTCPTR = 0;
005B78  803131     MOV RCFGCAL, W1
005B7A  2FCFF0     MOV #0xFCFF, W0
005B7C  608000     AND W1, W0, W0
005B7E  883130     MOV W0, RCFGCAL
90:                    time_tmp = RTCVAL; //
005B80  803121     MOV RTCVAL, W1
005B82  780F01     MOV W1, [W14]
91:                    currentTime->tm_min = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
005B84  78001E     MOV [W14], W0
005B86  DE004C     LSR W0, #12, W0
005B88  B9006A     MUL.SU W0, #10, W0
005B8A  780080     MOV W0, W1
005B8C  78001E     MOV [W14], W0
005B8E  DE0048     LSR W0, #8, W0
005B90  60006F     AND W0, #0xF, W0
005B92  408000     ADD W1, W0, W0
005B94  780080     MOV W0, W1
005B96  90001E     MOV [W14+2], W0
005B98  980011     MOV W1, [W0+2]
92:                    currentTime->tm_sec = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
005B9A  200F00     MOV #0xF0, W0
005B9C  60001E     AND W0, [W14], W0
005B9E  DE0044     LSR W0, #4, W0
005BA0  B9006A     MUL.SU W0, #10, W0
005BA2  780080     MOV W0, W1
005BA4  78011E     MOV [W14], W2
005BA6  61006F     AND W2, #0xF, W0
005BA8  408000     ADD W1, W0, W0
005BAA  780080     MOV W0, W1
005BAC  90001E     MOV [W14+2], W0
005BAE  780801     MOV W1, [W0]
93:                //    currentTime->tm_isdst
94:                    RCFGCALbits.RTCWREN = 0;
005BB0  A9A627     BCLR 0x627, #5
95:                
96:                    return true;
005BB2  B3C010     MOV.B #0x1, W0
97:                }
005BB4  FA8000     ULNK
005BB6  060000     RETURN
98:                
99:                /*************************************
100:               Function: Check_RTCC 
101:               Description:  RTCC
102:               Input: 6u8
103:               Output: 
104:                *************************************/
105:               void RTC_Set_Time(struct tm initialTime) {
005BB8  FA0000     LNK #0x0
005BBA  781F88     MOV W8, [W15++]
106:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
005BBC  200550     MOV #0x55, W0
005BBE  883B30     MOV W0, NVMKEY
005BC0  200AA0     MOV #0xAA, W0
005BC2  883B30     MOV W0, NVMKEY
005BC4  A8A627     BSET 0x627, #5
107:                   RCFGCALbits.RTCEN = 0; //Close RTCC
005BC6  A9E627     BCLR 0x627, #7
108:               
109:                   IFS3bits.RTCIF = false;
005BC8  A9C08B     BCLR 0x8B, #6
110:                   IEC3bits.RTCIE = 0;
005BCA  A9C09B     BCLR 0x9B, #6
111:               
112:                   // set RTCC initial time
113:                   RCFGCALbits.RTCPTR = 3; // start the sequence
005BCC  803131     MOV RCFGCAL, W1
005BCE  203000     MOV #0x300, W0
005BD0  700001     IOR W0, W1, W0
005BD2  883130     MOV W0, RCFGCAL
114:                   RTCVAL = DCH(initialTime.tm_year); // YEAR
005BD4  97B81E     MOV [W14-14], W0
005BD6  07055E     RCALL DCH
005BD8  883120     MOV W0, RTCVAL
115:                   RTCVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday); // MONTH-1/DAY-1
005BDA  97B80E     MOV [W14-16], W0
005BDC  07055B     RCALL DCH
005BDE  DD0448     SL W0, #8, W8
005BE0  97B07E     MOV [W14-18], W0
005BE2  070558     RCALL DCH
005BE4  440000     ADD W8, W0, W0
005BE6  883120     MOV W0, RTCVAL
116:                   RTCVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour); // WEEKDAY/HOURS
005BE8  97B82E     MOV [W14-12], W0
005BEA  070554     RCALL DCH
005BEC  DD0448     SL W0, #8, W8
005BEE  97B06E     MOV [W14-20], W0
005BF0  070551     RCALL DCH
005BF2  440000     ADD W8, W0, W0
005BF4  883120     MOV W0, RTCVAL
117:                   RTCVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec); // MINUTES/SECONDS   
005BF6  97B05E     MOV [W14-22], W0
005BF8  07054D     RCALL DCH
005BFA  DD0448     SL W0, #8, W8
005BFC  97B04E     MOV [W14-24], W0
005BFE  07054A     RCALL DCH
005C00  440000     ADD W8, W0, W0
005C02  883120     MOV W0, RTCVAL
118:               
119:                   // Enable RTCC, clear RTCWREN         
120:                   RCFGCALbits.RTCEN = 1;
005C04  A8E627     BSET 0x627, #7
121:                   RCFGCALbits.RTCWREN = 0;
005C06  A9A627     BCLR 0x627, #5
122:               
123:                   IEC3bits.RTCIE = 1;
005C08  A8C09B     BSET 0x9B, #6
124:               }
005C0A  78044F     MOV [--W15], W8
005C0C  FA8000     ULNK
005C0E  060000     RETURN
125:               
126:               /*************************************
127:               Function: StartRTCC 
128:               Description: 
129:               Input: 
130:               Output: 
131:                *************************************/
132:               //void StartRTCC(void) {
133:               //
134:               //    IEC3bits.RTCIE = 1; //
135:               //    ALCFGRPTbits.ALRMEN = 1;
136:               //    RCFGCALbits.RTCEN = 1; //RTCC
137:               //}
138:               
139:               /*************************************
140:               Function: StopRTCC 
141:               Description: 
142:               Input: 
143:               Output: 
144:                *************************************/
145:               //void StopRTCC(void) {
146:               //    IEC3bits.RTCIE = 0; // 
147:               //    ALCFGRPTbits.ALRMEN = 0;
148:               //    RCFGCALbits.RTCEN = 0; // RTCC 
149:               //}
150:               
151:               void PrintTime(void) {
005C10  FA0026     LNK #0x26
152:                   struct tm time1;
153:                   uint8_t sendstr[20] = {"1234578901234567890"};
005C12  29FD40     MOV #0x9FD4, W0
005C14  4700F2     ADD W14, #0x12, W1
005C16  090013     REPEAT #0x13
005C18  7858B0     MOV.B [W0++], [W1++]
005C1A  B10140     SUB #0x14, W0
154:                   if (RTC_Read_Time(&time1)) {
005C1C  78000E     MOV W14, W0
005C1E  07FF53     RCALL RTC_Read_Time
005C20  E00400     CP0.B W0
005C22  320075     BRA Z, 0x5D0E
155:                       sendstr[0] = time1.tm_year / 10 + 0x30;
005C24  9000DE     MOV [W14+10], W1
005C26  2000A0     MOV #0xA, W0
005C28  780100     MOV W0, W2
005C2A  090011     REPEAT #0x11
005C2C  D80082     DIV.SW W1, W2
005C2E  784000     MOV.B W0, W0
005C30  B04300     ADD.B #0x30, W0
005C32  985720     MOV.B W0, [W14+18]
156:                       sendstr[1] = time1.tm_year % 10 + 0x30;
005C34  9000DE     MOV [W14+10], W1
005C36  2000A0     MOV #0xA, W0
005C38  780100     MOV W0, W2
005C3A  090011     REPEAT #0x11
005C3C  D80082     DIV.SW W1, W2
005C3E  FD0080     EXCH W0, W1
005C40  784000     MOV.B W0, W0
005C42  B04300     ADD.B #0x30, W0
005C44  985730     MOV.B W0, [W14+19]
157:                       sendstr[2] = '/';
005C46  B3C2F0     MOV.B #0x2F, W0
005C48  985740     MOV.B W0, [W14+20]
158:                       sendstr[3] = time1.tm_mon / 10 + 0x30;
005C4A  9000CE     MOV [W14+8], W1
005C4C  2000A0     MOV #0xA, W0
005C4E  780100     MOV W0, W2
005C50  090011     REPEAT #0x11
005C52  D80082     DIV.SW W1, W2
005C54  784000     MOV.B W0, W0
005C56  B04300     ADD.B #0x30, W0
005C58  985750     MOV.B W0, [W14+21]
159:                       sendstr[4] = time1.tm_mon % 10 + 0x30;
005C5A  9000CE     MOV [W14+8], W1
005C5C  2000A0     MOV #0xA, W0
005C5E  780100     MOV W0, W2
005C60  090011     REPEAT #0x11
005C62  D80082     DIV.SW W1, W2
005C64  FD0080     EXCH W0, W1
005C66  784000     MOV.B W0, W0
005C68  B04300     ADD.B #0x30, W0
005C6A  985760     MOV.B W0, [W14+22]
160:                       sendstr[5] = '/';
005C6C  B3C2F0     MOV.B #0x2F, W0
005C6E  985770     MOV.B W0, [W14+23]
161:                       sendstr[6] = time1.tm_mday / 10 + 0x30;
005C70  9000BE     MOV [W14+6], W1
005C72  2000A0     MOV #0xA, W0
005C74  780100     MOV W0, W2
005C76  090011     REPEAT #0x11
005C78  D80082     DIV.SW W1, W2
005C7A  784000     MOV.B W0, W0
005C7C  B04300     ADD.B #0x30, W0
005C7E  985F00     MOV.B W0, [W14+24]
162:                       sendstr[7] = time1.tm_mday % 10 + 0x30;
005C80  9000BE     MOV [W14+6], W1
005C82  2000A0     MOV #0xA, W0
005C84  780100     MOV W0, W2
005C86  090011     REPEAT #0x11
005C88  D80082     DIV.SW W1, W2
005C8A  FD0080     EXCH W0, W1
005C8C  784000     MOV.B W0, W0
005C8E  B04300     ADD.B #0x30, W0
005C90  985F10     MOV.B W0, [W14+25]
163:                       sendstr[8] = '-';
005C92  B3C2D0     MOV.B #0x2D, W0
005C94  985F20     MOV.B W0, [W14+26]
164:                       sendstr[9] = time1.tm_hour / 10 + 0x30;
005C96  9000AE     MOV [W14+4], W1
005C98  2000A0     MOV #0xA, W0
005C9A  780100     MOV W0, W2
005C9C  090011     REPEAT #0x11
005C9E  D80082     DIV.SW W1, W2
005CA0  784000     MOV.B W0, W0
005CA2  B04300     ADD.B #0x30, W0
005CA4  985F30     MOV.B W0, [W14+27]
165:                       sendstr[10] = time1.tm_hour % 10 + 0x30;
005CA6  9000AE     MOV [W14+4], W1
005CA8  2000A0     MOV #0xA, W0
005CAA  780100     MOV W0, W2
005CAC  090011     REPEAT #0x11
005CAE  D80082     DIV.SW W1, W2
005CB0  FD0080     EXCH W0, W1
005CB2  784000     MOV.B W0, W0
005CB4  B04300     ADD.B #0x30, W0
005CB6  985F40     MOV.B W0, [W14+28]
166:                       sendstr[11] = ':';
005CB8  B3C3A0     MOV.B #0x3A, W0
005CBA  985F50     MOV.B W0, [W14+29]
167:                       sendstr[12] = time1.tm_min / 10 + 0x30;
005CBC  90009E     MOV [W14+2], W1
005CBE  2000A0     MOV #0xA, W0
005CC0  780100     MOV W0, W2
005CC2  090011     REPEAT #0x11
005CC4  D80082     DIV.SW W1, W2
005CC6  784000     MOV.B W0, W0
005CC8  B04300     ADD.B #0x30, W0
005CCA  985F60     MOV.B W0, [W14+30]
168:                       sendstr[13] = time1.tm_min % 10 + 0x30;
005CCC  90009E     MOV [W14+2], W1
005CCE  2000A0     MOV #0xA, W0
005CD0  780100     MOV W0, W2
005CD2  090011     REPEAT #0x11
005CD4  D80082     DIV.SW W1, W2
005CD6  FD0080     EXCH W0, W1
005CD8  784000     MOV.B W0, W0
005CDA  B04300     ADD.B #0x30, W0
005CDC  985F70     MOV.B W0, [W14+31]
169:                       sendstr[14] = ':';
005CDE  B3C3A0     MOV.B #0x3A, W0
005CE0  986700     MOV.B W0, [W14+32]
170:                       sendstr[15] = time1.tm_sec / 10 + 0x30;
005CE2  78009E     MOV [W14], W1
005CE4  2000A0     MOV #0xA, W0
005CE6  780100     MOV W0, W2
005CE8  090011     REPEAT #0x11
005CEA  D80082     DIV.SW W1, W2
005CEC  784000     MOV.B W0, W0
005CEE  B04300     ADD.B #0x30, W0
005CF0  986710     MOV.B W0, [W14+33]
171:                       sendstr[16] = time1.tm_sec % 10 + 0x30;
005CF2  78009E     MOV [W14], W1
005CF4  2000A0     MOV #0xA, W0
005CF6  780100     MOV W0, W2
005CF8  090011     REPEAT #0x11
005CFA  D80082     DIV.SW W1, W2
005CFC  FD0080     EXCH W0, W1
005CFE  784000     MOV.B W0, W0
005D00  B04300     ADD.B #0x30, W0
005D02  986720     MOV.B W0, [W14+34]
172:                       sendstr[17] = '\n';
005D04  B3C0A0     MOV.B #0xA, W0
005D06  986730     MOV.B W0, [W14+35]
173:                       //        sendstr[18] = '\n';
174:                       //        sendstr[18] = '\0';
175:                       RS485SendString(sendstr, 18);
005D08  470072     ADD W14, #0x12, W0
005D0A  B3C121     MOV.B #0x12, W1
005D0C  070E8F     RCALL RS485SendString
176:                       //        OSTimeDlyHMSM();
177:                   }
178:               }
005D0E  FA8000     ULNK
179:               
180:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485
13:                Input:  
14:                Output: 
15:                 *************************************/
16:                void RS485_Init(void) {
0079E4  FA0000     LNK #0x0
17:                    RS485_TRIS = 0; // 485_CON
0079E6  A942C9     BCLR 0x2C9, #2
18:                    RS485_IN_TRIS = 1; ///
0079E8  A802C9     BSET 0x2C9, #0
19:                    RS485_OUT_TRIS = 0; //
0079EA  A922C9     BCLR 0x2C9, #1
20:                    ANSBbits.ANSB8 = 1; //
0079EC  A804E3     BSET 0x4E3, #0
21:                    //    ANSBbits.ANSB9 = 1;
22:                
23:                    U1MODEbits.BRGH = 0; //16
0079EE  A96220     BCLR U1MODE, #3
24:                    U1BRG = 103; //16000000/9600/16-1
0079F0  200670     MOV #0x67, W0
0079F2  881140     MOV W0, U1BRG
25:                
26:                    U1MODEbits.PDSEL = 00; //
0079F4  801101     MOV U1MODE, W1
0079F6  2FFF90     MOV #0xFFF9, W0
0079F8  608000     AND W1, W0, W0
0079FA  881100     MOV W0, U1MODE
27:                    U1MODEbits.STSEL = 0; //1
0079FC  A90220     BCLR U1MODE, #0
28:                    U1MODEbits.UARTEN = 1; //
0079FE  A8E221     BSET 0x221, #7
29:                
30:                    U1STAbits.UTXEN = 1; //  
007A00  A84223     BSET 0x223, #2
31:                    //    U1STAbits.URXISEL = 3; // 4  1
32:                    //    IEC0bits.U1RXIE = 1; //
33:                    //    IFS0bits.U1RXIF = 0; //
34:                    //    IEC4bits.U1ERIE = 1; //
35:                    //    IFS4bits.U1ERIF = 0; //
36:                }
007A02  FA8000     ULNK
007A04  060000     RETURN
37:                
38:                //void OpenAwake485(void) {//CN6
39:                //    RS485_RX_IN;
40:                //    CNEN1bits.CN6IE = 1; //RX1
41:                //}
42:                
43:                //void CloseAwake485(void) {
44:                //    CNEN1bits.CN6IE = 0;
45:                //}
46:                
47:                /*************************************
48:                Function: RS485_Send  
49:                Description: 485
50:                Input:  
51:                Output: 1:
52:                 *************************************/
53:                void RS485SendChar(const uint8_t dat) {
007A06  FA0002     LNK #0x2
007A08  784F00     MOV.B W0, [W14]
54:                    RS485_CON = 1; //
007A0A  A842CD     BSET 0x2CD, #2
55:                    //    OSTimeDlyHMSM(0, 0, 0, 30);
56:                    U1TXREG = dat;
007A0C  FB801E     ZE [W14], W0
007A0E  881120     MOV W0, U1TXREG
57:                    while (!U1STAbits.TRMT); //while (!U2STAbits.TRMT);
007A10  000000     NOP
007A12  801111     MOV U1STA, W1
007A14  201000     MOV #0x100, W0
007A16  608000     AND W1, W0, W0
007A18  E00000     CP0 W0
007A1A  32FFFB     BRA Z, 0x7A12
58:                    OSTimeDlyHMSM(0, 0, 0, 10);
007A1C  2000A3     MOV #0xA, W3
007A1E  EB0100     CLR W2
007A20  EB0080     CLR W1
007A22  EB0000     CLR W0
007A24  07FC26     RCALL OSTimeDlyHMSM
59:                    RS485_CON = 0; //
007A26  A942CD     BCLR 0x2CD, #2
60:                    //    OSTimeDlyHMSM(0, 0, 0, 1);
61:                }
007A28  FA8000     ULNK
007A2A  060000     RETURN
62:                
63:                /*************************************
64:                Function: RS485_SendString 
65:                Description: 485
66:                Input:   
67:                Output: 
68:                 *************************************/
69:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
007A2C  FA0006     LNK #0x6
007A2E  980710     MOV W0, [W14+2]
007A30  984741     MOV.B W1, [W14+4]
70:                    uint8_t count = 0;
007A32  EB4000     CLR.B W0
007A34  784F00     MOV.B W0, [W14]
71:                
72:                    RS485_CON = 1; //    
007A36  A842CD     BSET 0x2CD, #2
73:                    OSTimeDlyHMSM(0, 0, 0, 100);
007A38  200643     MOV #0x64, W3
007A3A  EB0100     CLR W2
007A3C  EB0080     CLR W1
007A3E  EB0000     CLR W0
007A40  07FC18     RCALL OSTimeDlyHMSM
74:                    while (count < bytes) {
007A42  37000D     BRA 0x7A5E
007A5E  90404E     MOV.B [W14+4], W0
007A60  78409E     MOV.B [W14], W1
007A62  50CF80     SUB.B W1, W0, [W15]
007A64  39FFEF     BRA NC, 0x7A44
75:                        U1TXREG = *(dat + count);
007A44  FB801E     ZE [W14], W0
007A46  90009E     MOV [W14+2], W1
007A48  408000     ADD W1, W0, W0
007A4A  784010     MOV.B [W0], W0
007A4C  FB8000     ZE W0, W0
007A4E  881120     MOV W0, U1TXREG
76:                        while (!U1STAbits.TRMT);
007A50  000000     NOP
007A52  801111     MOV U1STA, W1
007A54  201000     MOV #0x100, W0
007A56  608000     AND W1, W0, W0
007A58  E00000     CP0 W0
007A5A  32FFFB     BRA Z, 0x7A52
77:                        count++;
007A5C  E84F1E     INC.B [W14], [W14]
78:                    }
79:                    OSTimeDlyHMSM(0, 0, 0, 100);
007A66  200643     MOV #0x64, W3
007A68  EB0100     CLR W2
007A6A  EB0080     CLR W1
007A6C  EB0000     CLR W0
007A6E  07FC01     RCALL OSTimeDlyHMSM
80:                    RS485_CON = 0; //
007A70  A942CD     BCLR 0x2CD, #2
81:                    OSTimeDlyHMSM(0, 0, 0, 1);
007A72  200013     MOV #0x1, W3
007A74  EB0100     CLR W2
007A76  EB0080     CLR W1
007A78  EB0000     CLR W0
007A7A  07FBFB     RCALL OSTimeDlyHMSM
82:                }
007A7C  FA8000     ULNK
007A7E  060000     RETURN
83:                
84:                /*************************************
85:                Function: OpenRS485 
86:                Description: 485
87:                Input:   
88:                Output: 
89:                 *************************************/
90:                void OpenRS485(void) {
007A80  FA0000     LNK #0x0
91:                    IEC0bits.U1RXIE = 1;
007A82  A86095     BSET 0x95, #3
92:                    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled ??????????
007A84  A84223     BSET 0x223, #2
93:                }
007A86  FA8000     ULNK
007A88  060000     RETURN
94:                
95:                /*************************************
96:                Function: RS485_SendString 
97:                Description: 485
98:                Input:   
99:                Output: 
100:                *************************************/
101:               void CloseRS485(void) {
007A8A  FA0000     LNK #0x0
102:                   IEC0bits.U1RXIE = 0;
007A8C  A96095     BCLR 0x95, #3
103:                   U1STAbits.UTXEN = 0; //UARTx transmitter is enabled ??????????
007A8E  A94223     BCLR 0x223, #2
104:               }
007A90  FA8000     ULNK
105:               /*************************************
106:               Function: RS485_test 
107:               Description: 485
108:               Input:  
109:               Output: 
110:                *************************************/
111:               //void RS485test(void)
112:               //{
113:               //    uint8_t dat='6';
114:               
115:               //RS485Send('T');
116:               //    if(!RS485Receive(&dat))
117:               //    {
118:               //        RS485Send(dat);
119:               //        RS485Send('T');
120:               //    }
121:               //}
122:               
123:               /*************************************
124:               Function: RS485_Receive  
125:               Description: 485
126:               Input:  
127:               Output: 1
128:                ************************************
129:               bool RS485Receive(uint8_t* dat) {
130:               
131:                   bool b = true;
132:               //    uint8_t timeCount;
133:                   
134:               //    RS485_CON = 0; //
135:               
136:                   if (U1STAbits.OERR)
137:                       U1STAbits.OERR = 0;
138:                   
139:               //    gT23Count=0;
140:               //    T2CONbits.TON = 1;// 
141:                  
142:                   while (!U1STAbits.URXDA) //
143:                   {
144:               //        timeCount = gT23Count;
145:               //        if( T100msIsOver(timeCount,10) ) {//1s
146:               //            b = false;
147:               //            break;
148:               //        }
149:                   }
150:               //    T2CONbits.TON = 0;//
151:               //    gT23Count=0;           //
152:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
153:               //    TMR2 = 0x0000;
154:                   
155:               //    if(b)
156:               //        *dat = U1RXREG;
157:               
158:                   return b;
159:               }*/
160:               
161:               
162:               
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/PPS.c  ---------------------------------------
1:                 /* 
2:                  * File:   PPS.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 2017620, 1:52
6:                  */
7:                 #include <xc.h>
8:                 
9:                 void PPSInit(void) {
007BBE  FA0000     LNK #0x0
10:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
007BC0  803A11     MOV OSCCON, W1
007BC2  200BF0     MOV #0xBF, W0
007BC4  608100     AND W1, W0, W2
007BC6  200460     MOV #0x46, W0
007BC8  200571     MOV #0x57, W1
007BCA  207423     MOV #0x742, W3
007BCC  784980     MOV.B W0, [W3]
007BCE  784981     MOV.B W1, [W3]
007BD0  784982     MOV.B W2, [W3]
11:                    //    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
12:                    //    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
13:                    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
007BD2  803641     MOV RPOR4, W1
007BD4  2C0FF0     MOV #0xC0FF, W0
007BD6  608080     AND W1, W0, W1
007BD8  203000     MOV #0x300, W0
007BDA  700001     IOR W0, W1, W0
007BDC  883640     MOV W0, RPOR4
14:                    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
007BDE  803521     MOV RPINR18, W1
007BE0  2FFC00     MOV #0xFFC0, W0
007BE2  608000     AND W1, W0, W0
007BE4  A03000     BSET W0, #3
007BE6  883520     MOV W0, RPINR18
15:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
007BE8  8036B1     MOV RPOR11, W1
007BEA  2FFC00     MOV #0xFFC0, W0
007BEC  608000     AND W1, W0, W0
007BEE  B30050     IOR #0x5, W0
007BF0  8836B0     MOV W0, RPOR11
16:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX 
007BF2  803531     MOV RPINR19, W1
007BF4  2FFC00     MOV #0xFFC0, W0
007BF6  608000     AND W1, W0, W0
007BF8  B30170     IOR #0x17, W0
007BFA  883530     MOV W0, RPINR19
17:                    RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
007BFC  8036D1     MOV RPOR13, W1
007BFE  2FFC00     MOV #0xFFC0, W0
007C00  608000     AND W1, W0, W0
007C02  B301C0     IOR #0x1C, W0
007C04  8836D0     MOV W0, RPOR13
18:                    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
007C06  803511     MOV RPINR17, W1
007C08  2C0FF0     MOV #0xC0FF, W0
007C0A  608080     AND W1, W0, W1
007C0C  213000     MOV #0x1300, W0
007C0E  700001     IOR W0, W1, W0
007C10  883510     MOV W0, RPINR17
19:                    //    RPINR3bits.
20:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
21:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
22:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
007C12  803A10     MOV OSCCON, W0
007C14  780100     MOV W0, W2
007C16  A06002     BSET W2, #6
007C18  200460     MOV #0x46, W0
007C1A  200571     MOV #0x57, W1
007C1C  207423     MOV #0x742, W3
007C1E  784980     MOV.B W0, [W3]
007C20  784981     MOV.B W1, [W3]
007C22  784982     MOV.B W2, [W3]
23:                }
007C24  FA8000     ULNK
24:                
25:                //RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
26:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX
27:                
28:                
29:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 201666, 8:48
6:                  */
7:                 #include "SerialBuffer.h"
8:                 #include "includes.h"
9:                 #include "stdbool.h"
10:                #include "stdio.h"
11:                #include "RTCC.h"
12:                
13:                extern OS_EVENT *sem_receive_pressure, *sem_set_alarm;
14:                extern volatile uint8_t i2c1_state;
15:                extern I2C1_Buffer i2c_buf;
16:                
17:                /* Function:
18:                    void __attribute__ ( ( interrupt, no_auto_psv ) ) _ISR _RTCCInterrupt( void )
19:                
20:                  Summary:
21:                    Interrupt Service Routine for the RTCC Peripheral
22:                
23:                  Description:
24:                    This is the interrupt service routine for the RTCC peripheral. Add in code if 
25:                    required in the ISR. 
26:                 */
27:                
28:                /*************************************
29:                Function: RTCC
30:                Description: 
31:                Input:  
32:                Output: 
33:                 *************************************/
34:                void __attribute__((interrupt, no_auto_psv)) _ISR _RTCCInterrupt(void) {
000324  F80036     PUSH RCOUNT
000326  BE9F80     MOV.D W0, [W15++]
000328  BE9F82     MOV.D W2, [W15++]
00032A  BE9F84     MOV.D W4, [W15++]
00032C  BE9F86     MOV.D W6, [W15++]
00032E  FA0000     LNK #0x0
35:                    /* TODO : Add interrupt handling code */
36:                    IFS3bits.RTCIF = false;
000330  A9C08B     BCLR 0x8B, #6
37:                    OSIntEnter();
000332  071011     RCALL OSIntEnter
38:                    OSSemPost(sem_set_alarm); //notes :sem can't find here
000334  804450     MOV sem_set_alarm, W0
000336  0728E5     RCALL OSSemPost
39:                    OSIntExit();
000338  07101A     RCALL OSIntExit
40:                    //    OSSemPost(sem_set_alarm);
41:                }
00033A  FA8000     ULNK
00033C  BE034F     MOV.D [--W15], W6
00033E  BE024F     MOV.D [--W15], W4
000340  BE014F     MOV.D [--W15], W2
000342  BE004F     MOV.D [--W15], W0
000344  F90036     POP RCOUNT
000346  064000     RETFIE
42:                
43:                /*************************************
44:                Function: 0
45:                Description: 
46:                Input:  
47:                Output: 
48:                 *************************************/
49:                void __attribute__((interrupt, no_auto_psv))_ISR _INT0Interrupt(void) {
000348  F80036     PUSH RCOUNT
00034A  BE9F80     MOV.D W0, [W15++]
00034C  BE9F82     MOV.D W2, [W15++]
00034E  BE9F84     MOV.D W4, [W15++]
000350  BE9F86     MOV.D W6, [W15++]
000352  FA0000     LNK #0x0
50:                    OSIntEnter();
000354  071000     RCALL OSIntEnter
51:                    IFS0bits.INT0IF = 0;
000356  A90084     BCLR IFS0, #0
52:                    OSSemPost(sem_receive_pressure);
000358  804480     MOV sem_receive_pressure, W0
00035A  0728D3     RCALL OSSemPost
53:                    OSIntExit();
00035C  071008     RCALL OSIntExit
54:                }
00035E  FA8000     ULNK
000360  BE034F     MOV.D [--W15], W6
000362  BE024F     MOV.D [--W15], W4
000364  BE014F     MOV.D [--W15], W2
000366  BE004F     MOV.D [--W15], W0
000368  F90036     POP RCOUNT
00036A  064000     RETFIE
55:                /*************************************
56:                Function:  
57:                Description: GPRS
58:                Input:  
59:                Output: 
60:                 *************************************/
61:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
62:                //    gT3Count++;
63:                //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
64:                //}
65:                
66:                /*************************************
67:                Function:  
68:                Description: 485
69:                Input:  
70:                Output: 
71:                 *************************************/
72:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
73:                //    while (!U1STAbits.RIDLE);
74:                //    PC_Cop();
75:                //    T2CONbits.TON = 0;
76:                //    TMR2 = 0;
77:                //    FLagArgbits.TestFlag = 0; //
78:                //    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
79:                //}
80:                
81:                /*************************************
82:                Function:  
83:                Description: 
84:                Input:  
85:                Output: 
86:                 *************************************/
87:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
88:                //    gT1Count++;
89:                //    IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
90:                //}
91:                
92:                /*************************************
93:                Function: t4 
94:                Description: 
95:                Input:  
96:                Output: 
97:                 *************************************/
98:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
99:                //    if (FLagArgbits.LowPowerGetDataFlag) {
100:               //        FLagArgbits.LowPowerGetDataFlag = 0;
101:               //        GetValueTask(LowPowerData); //
102:               //    } else if (FLagArgbits.TestGetDataFlag) {
103:               //        FLagArgbits.TestGetDataFlag = 0;
104:               //        GetValueTask(TestData); //
105:               //    } else
106:               //        GetValueTask(SampleData); //
107:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //
108:               //
109:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
110:               //    CloseTime4();
111:               //}
112:               
113:               /*************************************
114:               Function:  
115:               Description: 
116:               Input:  
117:               Output: 
118:                *************************************/
119:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //
120:               //    if (S1) {//
121:               //        gPulseCount++; //+1
122:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//T1
123:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //ms
124:               //            if (gPulseTime < 2000)//2s
125:               //                gPulseTime = 0;
126:               //            else {
127:               //                FLagArgbits.PulseTimeFlag = 1; // 
128:               //                FLagArgbits.T1CountFlag = 0;
129:               //                T1CONbits.TON = 0;
130:               //            }
131:               //        }
132:               //        TMR1 = 0;
133:               //        gT1Count = 0;
134:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //FLagArgbits.T1CountLastFlag
135:               //    }
136:               //    IFS1bits.CNIF = 0;
137:               //}
138:               
139:               /*************************************
140:               Function: UART1
141:               Description: 485
142:               Input:  
143:               Output: 
144:                *************************************/
145:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
00036C  F80036     PUSH RCOUNT
00036E  BE9F80     MOV.D W0, [W15++]
000370  BE9F82     MOV.D W2, [W15++]
000372  BE9F84     MOV.D W4, [W15++]
000374  BE9F86     MOV.D W6, [W15++]
000376  F80032     PUSH DSRPAG
000378  F80034     PUSH DSWPAG
00037A  200010     MOV #0x1, W0
00037C  8801A0     MOV W0, DSWPAG
00037E  202000     MOV #0x200, W0
000380  880190     MOV W0, DSRPAG
000382  FA0002     LNK #0x2
146:                   uint8_t cnt = 0;
000384  EB4000     CLR.B W0
000386  784F00     MOV.B W0, [W14]
147:                   //    OSIntEnter();
148:                   for (cnt = 0; cnt < 4; cnt++)
000388  EB4000     CLR.B W0
00038A  784F00     MOV.B W0, [W14]
00038C  370006     BRA 0x39A
000398  E84F1E     INC.B [W14], [W14]
00039A  78401E     MOV.B [W14], W0
00039C  504FE3     SUB.B W0, #0x3, [W15]
00039E  36FFF7     BRA LEU, 0x38E
149:                       if (U1STAbits.URXDA == 1) //
00038E  801110     MOV U1STA, W0
000390  600061     AND W0, #0x1, W0
000392  E00000     CP0 W0
000394  320001     BRA Z, 0x398
150:                           BufferWrite_UART1();
000396  072CBD     RCALL BufferWrite_UART1
151:                   IFS0bits.U1RXIF = 0;
0003A0  A96085     BCLR 0x85, #3
152:                   //    OSIntExit();
153:               }
0003A2  FA8000     ULNK
0003A4  F90034     POP DSWPAG
0003A6  F90032     POP DSRPAG
0003A8  BE034F     MOV.D [--W15], W6
0003AA  BE024F     MOV.D [--W15], W4
0003AC  BE014F     MOV.D [--W15], W2
0003AE  BE004F     MOV.D [--W15], W0
0003B0  F90036     POP RCOUNT
0003B2  064000     RETFIE
154:               
155:               /*************************************
156:               Function: UART2
157:               Description: GPRS
158:               Input:  
159:               Output: 
160:                *************************************/
161:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
0003B4  F80036     PUSH RCOUNT
0003B6  BE9F80     MOV.D W0, [W15++]
0003B8  BE9F82     MOV.D W2, [W15++]
0003BA  BE9F84     MOV.D W4, [W15++]
0003BC  BE9F86     MOV.D W6, [W15++]
0003BE  F80032     PUSH DSRPAG
0003C0  F80034     PUSH DSWPAG
0003C2  200010     MOV #0x1, W0
0003C4  8801A0     MOV W0, DSWPAG
0003C6  202000     MOV #0x200, W0
0003C8  880190     MOV W0, DSRPAG
0003CA  FA0002     LNK #0x2
162:                   uint8_t cnt = 0;
0003CC  EB4000     CLR.B W0
0003CE  784F00     MOV.B W0, [W14]
163:                   //    OSIntEnter();
164:                   for (cnt = 0; cnt < 4; cnt++)
0003D0  EB4000     CLR.B W0
0003D2  784F00     MOV.B W0, [W14]
0003D4  370006     BRA 0x3E2
0003E0  E84F1E     INC.B [W14], [W14]
0003E2  78401E     MOV.B [W14], W0
0003E4  504FE3     SUB.B W0, #0x3, [W15]
0003E6  36FFF7     BRA LEU, 0x3D6
165:                       if (U2STAbits.URXDA == 1) //        
0003D6  801190     MOV U2STA, W0
0003D8  600061     AND W0, #0x1, W0
0003DA  E00000     CP0 W0
0003DC  320001     BRA Z, 0x3E0
166:                           BufferWrite_UART2();
0003DE  072CB2     RCALL BufferWrite_UART2
167:                   IFS1bits.U2RXIF = 0;
0003E8  A9C087     BCLR 0x87, #6
168:                   //    OSIntExit();
169:               }
0003EA  FA8000     ULNK
0003EC  F90034     POP DSWPAG
0003EE  F90032     POP DSRPAG
0003F0  BE034F     MOV.D [--W15], W6
0003F2  BE024F     MOV.D [--W15], W4
0003F4  BE014F     MOV.D [--W15], W2
0003F6  BE004F     MOV.D [--W15], W0
0003F8  F90036     POP RCOUNT
0003FA  064000     RETFIE
170:               
171:               /*************************************
172:               Function: UART2
173:               Description: GPRS
174:               Input:  
175:               Output: 
176:                *************************************/
177:               void __attribute__((__interrupt__, __auto_psv__)) _U3RXInterrupt(void) {
0003FC  F80036     PUSH RCOUNT
0003FE  BE9F80     MOV.D W0, [W15++]
000400  BE9F82     MOV.D W2, [W15++]
000402  BE9F84     MOV.D W4, [W15++]
000404  BE9F86     MOV.D W6, [W15++]
000406  F80032     PUSH DSRPAG
000408  F80034     PUSH DSWPAG
00040A  200010     MOV #0x1, W0
00040C  8801A0     MOV W0, DSWPAG
00040E  202000     MOV #0x200, W0
000410  880190     MOV W0, DSRPAG
000412  FA0002     LNK #0x2
178:                   uint8_t cnt = 0;
000414  EB4000     CLR.B W0
000416  784F00     MOV.B W0, [W14]
179:                   //    OSIntEnter();
180:                   for (cnt = 0; cnt < 4; cnt++)
000418  EB4000     CLR.B W0
00041A  784F00     MOV.B W0, [W14]
00041C  370006     BRA 0x42A
000428  E84F1E     INC.B [W14], [W14]
00042A  78401E     MOV.B [W14], W0
00042C  504FE3     SUB.B W0, #0x3, [W15]
00042E  36FFF7     BRA LEU, 0x41E
181:                       if (U3STAbits.URXDA == 1) //        
00041E  801290     MOV U3STA, W0
000420  600061     AND W0, #0x1, W0
000422  E00000     CP0 W0
000424  320001     BRA Z, 0x428
182:                           BufferWrite_UART3();
000426  072CA9     RCALL BufferWrite_UART3
183:                   IFS5bits.U3RXIF = 0;
000430  A9408E     BCLR IFS5, #2
184:                   //    OSIntExit();
185:               }
000432  FA8000     ULNK
000434  F90034     POP DSWPAG
000436  F90032     POP DSRPAG
000438  BE034F     MOV.D [--W15], W6
00043A  BE024F     MOV.D [--W15], W4
00043C  BE014F     MOV.D [--W15], W2
00043E  BE004F     MOV.D [--W15], W0
000440  F90036     POP RCOUNT
000442  064000     RETFIE
186:               
187:               /*************************************
188:               Function: UART2
189:               Description: GPRS
190:               Input:  
191:               Output: 
192:                *************************************/
193:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
194:               //    u8 cnt = 0;
195:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
196:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //
197:               //
198:               //        while (!U2STAbits.TRMT);
199:               //        cnt++;
200:               //    }
201:               //    IFS1bits.U2TXIF = 0;
202:               //}
203:               
204:               /*************************************
205:               Function: UART1
206:               Description: 
207:               Input:  
208:               Output: 
209:                *************************************/
210:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
000444  781F80     MOV W0, [W15++]
000446  FA0000     LNK #0x0
211:                   //    OSIntEnter();
212:                   if (U1STAbits.OERR == 1)
000448  801110     MOV U1STA, W0
00044A  600062     AND W0, #0x2, W0
00044C  E00000     CP0 W0
00044E  320001     BRA Z, 0x452
213:                       U1STAbits.OERR = 0;
000450  A92222     BCLR U1STA, #1
214:                   IFS4bits.U1ERIF = 0;
000452  A9208C     BCLR IFS4, #1
215:                   //    OSIntExit();
216:               }
000454  FA8000     ULNK
000456  78004F     MOV [--W15], W0
000458  064000     RETFIE
217:               
218:               /*************************************
219:               Function: UART2
220:               Description: 
221:               Input:  
222:               Output: 
223:                *************************************/
224:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
00045A  781F80     MOV W0, [W15++]
00045C  FA0000     LNK #0x0
225:                   //    OSIntEnter();
226:                   if (U2STAbits.OERR == 1)
00045E  801190     MOV U2STA, W0
000460  600062     AND W0, #0x2, W0
000462  E00000     CP0 W0
000464  320001     BRA Z, 0x468
227:                       U2STAbits.OERR = 0;
000466  A92232     BCLR U2STA, #1
228:                   IFS4bits.U2ERIF = 0;
000468  A9408C     BCLR IFS4, #2
229:                   //    OSIntExit();
230:               }
00046A  FA8000     ULNK
00046C  78004F     MOV [--W15], W0
00046E  064000     RETFIE
231:               
232:               /*************************************
233:               Function: UART2
234:               Description: 
235:               Input:  
236:               Output: 
237:                *************************************/
238:               void __attribute__((interrupt, no_auto_psv)) _U3ErrInterrupt(void) {
000470  781F80     MOV W0, [W15++]
000472  FA0000     LNK #0x0
239:                   //    OSIntEnter();
240:                   if (U3STAbits.OERR == 1)
000474  801290     MOV U3STA, W0
000476  600062     AND W0, #0x2, W0
000478  E00000     CP0 W0
00047A  320001     BRA Z, 0x47E
241:                       U3STAbits.OERR = 0;
00047C  A92252     BCLR U3STA, #1
242:                   IFS5bits.U3ERIF = 0;
00047E  A9208E     BCLR IFS5, #1
243:                   //    OSIntExit();
244:               }
000480  FA8000     ULNK
000482  78004F     MOV [--W15], W0
000484  064000     RETFIE
245:               
246:               /*************************************
247:               Function: 
248:               Description: 
249:               Input:  
250:               Output: 
251:                *************************************/
252:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
000486  781F80     MOV W0, [W15++]
000488  FA0000     LNK #0x0
253:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
00048A  800400     MOV INTCON1, W0
00048C  600064     AND W0, #0x4, W0
00048E  E00000     CP0 W0
000490  320001     BRA Z, 0x494
000492  A94080     BCLR INTCON1, #2
254:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
000494  800400     MOV INTCON1, W0
000496  600068     AND W0, #0x8, W0
000498  E00000     CP0 W0
00049A  320001     BRA Z, 0x49E
00049C  A96080     BCLR INTCON1, #3
255:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
00049E  800400     MOV INTCON1, W0
0004A0  600070     AND W0, #0x10, W0
0004A2  E00000     CP0 W0
0004A4  320001     BRA Z, 0x4A8
0004A6  A98080     BCLR INTCON1, #4
256:                   asm("GOTO __reset");
0004A8  040200     GOTO 0x200
0004AA  000000     NOP
257:               }
0004AC  FA8000     ULNK
0004AE  78004F     MOV [--W15], W0
0004B0  064000     RETFIE
258:               
259:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
0004B2  F80036     PUSH RCOUNT
0004B4  BE9F80     MOV.D W0, [W15++]
0004B6  BE9F82     MOV.D W2, [W15++]
0004B8  BE9F84     MOV.D W4, [W15++]
0004BA  BE9F86     MOV.D W6, [W15++]
0004BC  FA0000     LNK #0x0
260:                   OSIntEnter();
0004BE  070F4B     RCALL OSIntEnter
261:                   static uint16_t i2c_operatcode;
262:                   static uint8_t* pi2c_buf_ptr;
263:                   static uint16_t i2c_address;
264:                   static uint8_t i2c_bytes_left;
265:                   static I2C_Flag i2c_flag;
266:                   static bool i2c_IsResart; //
267:               
268:                   IFS1bits.MI2C1IF = 0; //
0004C0  A92086     BCLR IFS1, #1
269:                   if (I2C1STATbits.IWCOL) {//1
0004C2  801041     MOV I2C1STAT, W1
0004C4  200800     MOV #0x80, W0
0004C6  608000     AND W1, W0, W0
0004C8  E00000     CP0 W0
0004CA  320002     BRA Z, 0x4D0
270:                       I2C1STATbits.IWCOL = 0;
0004CC  A9E208     BCLR I2C1STAT, #7
271:                       //        i2c_address_restart = 0;
272:                       //
273:                       return;
0004CE  3700F4     BRA 0x6B8
274:                   }
275:                   /* Handle the correct i2c state */
276:                   switch (i2c1_state) {
0004D0  BFC828     MOV.B i2c1_state, WREG
0004D2  FB8000     ZE W0, W0
0004D4  DE80CF     ASR W0, #15, W1
0004D6  2000D2     MOV #0xD, W2
0004D8  200003     MOV #0x0, W3
0004DA  500F82     SUB W0, W2, [W15]
0004DC  588F83     SUBB W1, W3, [W15]
0004DE  3E00EB     BRA GTU, 0x6B6
0004E0  016000     BRA W0
0004E2  37000D     BRA 0x4FE
0004E4  370023     BRA 0x52C
0004E6  370029     BRA 0x53A
0004E8  37007D     BRA 0x5E4
0004EA  370052     BRA 0x590
0004EC  3700E4     BRA 0x6B6
0004EE  3700C5     BRA 0x67A
0004F0  370098     BRA 0x622
0004F2  3700A5     BRA 0x63E
0004F4  3700BD     BRA 0x670
0004F6  3700A7     BRA 0x646
0004F8  3700DE     BRA 0x6B6
0004FA  3700DD     BRA 0x6B6
0004FC  3700C2     BRA 0x682
277:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
278:                       {
279:                           if (i2c_bytes_left == 0) {//0
0004FE  BFC894     MOV.B i2c_bytes_left, WREG
000500  E00400     CP0.B W0
000502  3A00D8     BRA NZ, 0x6B4
280:                               //                I2C1CONbits.SEN = 1; // 
281:                               //            } else {
282:                               I2C1CONbits.SEN = 1; // 
000504  A80206     BSET I2C1CON, #0
283:                               i2c_operatcode = i2c_buf.operatcode; //
000506  21EA20     MOV #0x1EA2, W0
000508  784010     MOV.B [W0], W0
00050A  FB8000     ZE W0, W0
00050C  8844B0     MOV W0, i2c_operatcode
284:                               i2c_address = i2c_buf.address; //
00050E  80F520     MOV 0x1EA4, W0
000510  8844C0     MOV W0, i2c_address
285:                               i2c_bytes_left = i2c_buf.length; //
000512  21EA60     MOV #0x1EA6, W0
000514  784010     MOV.B [W0], W0
000516  B7E894     MOV.B WREG, i2c_bytes_left
286:                               pi2c_buf_ptr = i2c_buf.pbuffer; //
000518  80F540     MOV 0x1EA8, W0
00051A  8844D0     MOV W0, pi2c_buf_ptr
287:                               i2c_flag = i2c_buf.flag; //
00051C  21EAA0     MOV #0x1EAA, W0
00051E  784110     MOV.B [W0], W2
000520  2089C1     MOV #0x89C, W1
000522  784882     MOV.B W2, [W1]
288:                               i2c_IsResart = 0;
000524  EF689D     CLR.B i2c_IsResart
289:                               i2c1_state = S_MASTER_SEND_ADDR; //
000526  B3C020     MOV.B #0x2, W0
000528  B7E828     MOV.B WREG, i2c1_state
290:                           }
291:                           break;
00052A  3700C5     BRA 0x6B6
0006B4  000000     NOP
292:                       }
293:                       case S_MASTER_RESTART:
294:                       {
295:                           I2C1CONbits.RSEN = 1; // 
00052C  A82206     BSET I2C1CON, #1
296:                           i2c_bytes_left = i2c_buf.length; //
00052E  21EA60     MOV #0x1EA6, W0
000530  784010     MOV.B [W0], W0
000532  B7E894     MOV.B WREG, i2c_bytes_left
297:                           i2c1_state = S_MASTER_SEND_ADDR; //
000534  B3C020     MOV.B #0x2, W0
000536  B7E828     MOV.B WREG, i2c1_state
298:                           break;
000538  3700BE     BRA 0x6B6
299:                       }
300:                       case S_MASTER_SEND_ADDR:
301:                       {
302:                           if (!i2c_flag.F_IsSelectiveMode) {// && i2c_IsResart) {
00053A  BFC89C     MOV.B i2c_flag, WREG
00053C  604061     AND.B W0, #0x1, W0
00053E  E00400     CP0.B W0
000540  3A000F     BRA NZ, 0x560
303:                               if (i2c_flag.F_WriteOrRead) {//=1ACK
000542  BFC89C     MOV.B i2c_flag, WREG
000544  604064     AND.B W0, #0x4, W0
000546  E00400     CP0.B W0
000548  320006     BRA Z, 0x556
304:                                   I2C1TRN = i2c_operatcode | 0x01;
00054A  8044B0     MOV i2c_operatcode, W0
00054C  A00000     BSET W0, #0
00054E  881010     MOV W0, I2C1TRN
305:                                   i2c1_state = S_MASTER_ACK_ADDR; //
000550  B3C070     MOV.B #0x7, W0
000552  B7E828     MOV.B WREG, i2c1_state
306:                               } else {
307:                                   I2C1TRN = i2c_operatcode;
000556  8044B0     MOV i2c_operatcode, W0
000558  881010     MOV W0, I2C1TRN
308:                                   i2c1_state = S_MASTER_SEND_DATA; //
00055A  B3C030     MOV.B #0x3, W0
00055C  B7E828     MOV.B WREG, i2c1_state
309:                               }
310:                           } else if (!i2c_IsResart) {//,
000560  BFC89D     MOV.B i2c_IsResart, WREG
000562  A20400     BTG.B W0, #0
000564  E00400     CP0.B W0
000566  320005     BRA Z, 0x572
311:                               I2C1TRN = i2c_operatcode;
000568  8044B0     MOV i2c_operatcode, W0
00056A  881010     MOV W0, I2C1TRN
312:                               i2c1_state = S_MASTER_SEND_ADDR_16BIT;
00056C  B3C040     MOV.B #0x4, W0
00056E  B7E828     MOV.B WREG, i2c1_state
313:                           } else {//
314:                               if (i2c_flag.F_WriteOrRead) {//=1ACK
000572  BFC89C     MOV.B i2c_flag, WREG
000574  604064     AND.B W0, #0x4, W0
000576  E00400     CP0.B W0
000578  320006     BRA Z, 0x586
315:                                   I2C1TRN = i2c_operatcode | 0x01;
00057A  8044B0     MOV i2c_operatcode, W0
00057C  A00000     BSET W0, #0
00057E  881010     MOV W0, I2C1TRN
316:                                   i2c1_state = S_MASTER_ACK_ADDR; //                    
000580  B3C070     MOV.B #0x7, W0
000582  B7E828     MOV.B WREG, i2c1_state
317:                               } else {
318:                                   I2C1TRN = i2c_operatcode;
000586  8044B0     MOV i2c_operatcode, W0
000588  881010     MOV W0, I2C1TRN
319:                                   i2c1_state = S_MASTER_SEND_DATA; //
00058A  B3C030     MOV.B #0x3, W0
00058C  B7E828     MOV.B WREG, i2c1_state
320:                               }
321:                           }
322:                           break;
000554  3700B0     BRA 0x6B6
00055E  3700AB     BRA 0x6B6
000570  3700A2     BRA 0x6B6
000584  370098     BRA 0x6B6
00058E  370093     BRA 0x6B6
323:                       }
324:                       case S_MASTER_SEND_ADDR_16BIT:
325:                       {
326:                           if (I2C1STATbits.ACKSTAT) {//NACK
000590  801041     MOV I2C1STAT, W1
000592  280000     MOV #0x8000, W0
000594  608000     AND W1, W0, W0
000596  E00000     CP0 W0
000598  320005     BRA Z, 0x5A4
327:                               I2C1STATbits.ACKSTAT = 0; //ACK
00059A  A9E209     BCLR 0x209, #7
328:                               I2C1CONbits.PEN = 1; //  
00059C  A84206     BSET I2C1CON, #2
329:                               IFS1bits.MI2C1IF = 0; //
00059E  A92086     BCLR IFS1, #1
330:                               i2c1_state = S_MASTER_IDLE; //
0005A0  EF6828     CLR.B i2c1_state
331:                           } else {
332:                               if (i2c_flag.F_Is16bitsDevice) {
0005A4  BFC89C     MOV.B i2c_flag, WREG
0005A6  604062     AND.B W0, #0x2, W0
0005A8  E00400     CP0.B W0
0005AA  320009     BRA Z, 0x5BE
333:                                   i2c_flag.F_Is16bitsDevice = 0;
0005AC  A9289C     BCLR i2c_flag, #1
334:                                   I2C1TRN = (uint8_t) (i2c_address >> 8); //16 
0005AE  8044C0     MOV i2c_address, W0
0005B0  DE0048     LSR W0, #8, W0
0005B2  784000     MOV.B W0, W0
0005B4  FB8000     ZE W0, W0
0005B6  881010     MOV W0, I2C1TRN
335:                                   i2c1_state = S_MASTER_SEND_ADDR_16BIT;
0005B8  B3C040     MOV.B #0x4, W0
0005BA  B7E828     MOV.B WREG, i2c1_state
336:                                   //                    break;
337:                               } else {
338:                                   I2C1TRN = (uint8_t) (i2c_address & 0x00FF); //16 
0005BE  8044C0     MOV i2c_address, W0
0005C0  784000     MOV.B W0, W0
0005C2  FB8000     ZE W0, W0
0005C4  881010     MOV W0, I2C1TRN
339:                                   if (i2c_flag.F_WriteOrRead)//
0005C6  BFC89C     MOV.B i2c_flag, WREG
0005C8  604064     AND.B W0, #0x4, W0
0005CA  E00400     CP0.B W0
0005CC  320008     BRA Z, 0x5DE
340:                                   {
341:                                       i2c_IsResart = 1;
0005CE  B3C010     MOV.B #0x1, W0
0005D0  B7E89D     MOV.B WREG, i2c_IsResart
342:                                       //                        I2C1CONbits.RSEN = 1; // 
343:                                       i2c_operatcode |= 0x01; //
0005D2  8044B0     MOV i2c_operatcode, W0
0005D4  A00000     BSET W0, #0
0005D6  8844B0     MOV W0, i2c_operatcode
344:                                       i2c1_state = S_MASTER_RESTART;
0005D8  B3C010     MOV.B #0x1, W0
0005DA  B7E828     MOV.B WREG, i2c1_state
345:                                   } else
346:                                       i2c1_state = S_MASTER_SEND_DATA;
0005DE  B3C030     MOV.B #0x3, W0
0005E0  B7E828     MOV.B WREG, i2c1_state
347:                               }
348:                           }
349:                           break;
0005A2  370089     BRA 0x6B6
0005BC  37007C     BRA 0x6B6
0005DC  37006C     BRA 0x6B6
0005E2  370069     BRA 0x6B6
350:                       }
351:                       case S_MASTER_SEND_DATA:
352:                       {
353:                           if (I2C1STATbits.ACKSTAT) {//NACK
0005E4  801041     MOV I2C1STAT, W1
0005E6  280000     MOV #0x8000, W0
0005E8  608000     AND W1, W0, W0
0005EA  E00000     CP0 W0
0005EC  320005     BRA Z, 0x5F8
354:                               I2C1STATbits.ACKSTAT = 0; //ACK
0005EE  A9E209     BCLR 0x209, #7
355:                               I2C1CONbits.PEN = 1; //  
0005F0  A84206     BSET I2C1CON, #2
356:                               IFS1bits.MI2C1IF = 0; //
0005F2  A92086     BCLR IFS1, #1
357:                               i2c1_state = S_MASTER_IDLE; //
0005F4  EF6828     CLR.B i2c1_state
0005F6  370015     BRA 0x622
358:                           } else {
359:                               if (i2c_bytes_left-- == 0U) {//
0005F8  BFC894     MOV.B i2c_bytes_left, WREG
0005FA  FB8080     ZE W0, W1
0005FC  E90081     DEC W1, W1
0005FE  DE08CF     LSR W1, #15, W1
000600  784081     MOV.B W1, W1
000602  E94000     DEC.B W0, W0
000604  B7E894     MOV.B WREG, i2c_bytes_left
000606  E00401     CP0.B W1
000608  320005     BRA Z, 0x614
360:                                   I2C1CONbits.PEN = 1; // I2C STOP control bit.   
00060A  A84206     BSET I2C1CON, #2
361:                                   IFS1bits.MI2C1IF = 0; //
00060C  A92086     BCLR IFS1, #1
362:                                   i2c1_state = S_MASTER_SEND_STOP; //
00060E  B3C060     MOV.B #0x6, W0
000610  B7E828     MOV.B WREG, i2c1_state
363:                               } else {
364:                                   I2C1TRN = *pi2c_buf_ptr++; //
000614  8044D0     MOV pi2c_buf_ptr, W0
000616  784090     MOV.B [W0], W1
000618  FB8081     ZE W1, W1
00061A  881011     MOV W1, I2C1TRN
00061C  E80000     INC W0, W0
00061E  8844D0     MOV W0, pi2c_buf_ptr
365:                               }
366:                               break;
000612  370051     BRA 0x6B6
000620  37004A     BRA 0x6B6
367:                           }
368:                       }
369:                       case S_MASTER_ACK_ADDR://
370:                       {
371:                           if (I2C1STATbits.ACKSTAT) { //NACK
000622  801041     MOV I2C1STAT, W1
000624  280000     MOV #0x8000, W0
000626  608000     AND W1, W0, W0
000628  E00000     CP0 W0
00062A  320005     BRA Z, 0x636
372:                               I2C1CONbits.PEN = 1; //
00062C  A84206     BSET I2C1CON, #2
373:                               IFS1bits.MI2C1IF = 0; //
00062E  A92086     BCLR IFS1, #1
374:                               i2c1_state = S_MASTER_IDLE;
000630  EF6828     CLR.B i2c1_state
375:                               I2C1STATbits.ACKSTAT = 0; //ACK
000632  A9E209     BCLR 0x209, #7
376:                           } else {
377:                               I2C1CONbits.RCEN = 1; //
000636  A86206     BSET I2C1CON, #3
378:                               i2c1_state = S_MASTER_ACK_RCV_DATA; //
000638  B3C0A0     MOV.B #0xA, W0
00063A  B7E828     MOV.B WREG, i2c1_state
379:                           }
380:                           break;
000634  370040     BRA 0x6B6
00063C  37003C     BRA 0x6B6
381:                       }
382:                       case S_MASTER_RCV_DATA:
383:                       {
384:                           i2c1_state = S_MASTER_ACK_RCV_DATA; //ACK
00063E  B3C0A0     MOV.B #0xA, W0
000640  B7E828     MOV.B WREG, i2c1_state
385:                           I2C1CONbits.RCEN = 1; //
000642  A86206     BSET I2C1CON, #3
386:                           break;
000644  370038     BRA 0x6B6
387:                       }
388:                       case S_MASTER_ACK_RCV_DATA:
389:                       {
390:                           *pi2c_buf_ptr++ = I2C1RCV; //
000646  8044D0     MOV pi2c_buf_ptr, W0
000648  801001     MOV I2C1RCV, W1
00064A  784081     MOV.B W1, W1
00064C  784801     MOV.B W1, [W0]
00064E  E80000     INC W0, W0
000650  8844D0     MOV W0, pi2c_buf_ptr
391:                           if (--i2c_bytes_left) {
000652  BFC894     MOV.B i2c_bytes_left, WREG
000654  E94000     DEC.B W0, W0
000656  B7E894     MOV.B WREG, i2c_bytes_left
000658  BFC894     MOV.B i2c_bytes_left, WREG
00065A  E00400     CP0.B W0
00065C  320004     BRA Z, 0x666
392:                               I2C1CONbits.ACKDT = 0; //ACK
00065E  A9A206     BCLR I2C1CON, #5
393:                               i2c1_state = S_MASTER_RCV_DATA; //
000660  B3C080     MOV.B #0x8, W0
000662  B7E828     MOV.B WREG, i2c1_state
000664  370003     BRA 0x66C
394:                           } else {
395:               
396:                               // Yes, it's the last byte.  Don't ack it
397:                               // Flag that we will nak the data
398:                               I2C1CONbits.ACKDT = 1; // I2C ACK data control bit.
000666  A8A206     BSET I2C1CON, #5
399:               
400:                               //            I2C1_FunctionComplete();
401:                               i2c1_state = S_MASTER_RCV_STOP;
000668  B3C090     MOV.B #0x9, W0
00066A  B7E828     MOV.B WREG, i2c1_state
402:                               //                break; //
403:                           }
404:               
405:                           // Initiate the acknowledge
406:                           I2C1CONbits.ACKEN = 1; // I2C ACK .
00066C  A88206     BSET I2C1CON, #4
407:                           break;
00066E  370023     BRA 0x6B6
408:                       }
409:                       case S_MASTER_RCV_STOP:
410:                       {
411:                           I2C1CONbits.ACKDT = 0;
000670  A9A206     BCLR I2C1CON, #5
412:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000672  A84206     BSET I2C1CON, #2
413:                           //            IFS1bits.MI2C1IF = 0; // 
414:                           i2c1_state = S_MASTER_Finish;
000674  B3C0D0     MOV.B #0xD, W0
000676  B7E828     MOV.B WREG, i2c1_state
415:                           break;
000678  37001E     BRA 0x6B6
416:                       }
417:                       case S_MASTER_SEND_STOP:
418:                       {
419:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
00067A  A84206     BSET I2C1CON, #2
420:                           //            IFS1bits.MI2C1IF = 0; // 
421:                           i2c1_state = S_MASTER_Finish;
00067C  B3C0D0     MOV.B #0xD, W0
00067E  B7E828     MOV.B WREG, i2c1_state
422:                           break;
000680  37001A     BRA 0x6B6
423:                       }
424:                       case S_MASTER_Finish:
425:                       {
426:                           i2c_operatcode = 0;
000682  EF2896     CLR i2c_operatcode
427:                           pi2c_buf_ptr = NULL;
000684  EF289A     CLR pi2c_buf_ptr
428:                           i2c_address = 0;
000686  EF2898     CLR i2c_address
429:                           i2c_bytes_left = 0;
000688  EF6894     CLR.B i2c_bytes_left
430:                           i2c_flag.F_Is16bitsDevice = i2c_flag.F_IsSelectiveMode = i2c_flag.F_WriteOrRead = 0;
00068A  A9489C     BCLR i2c_flag, #2
00068C  8044E0     MOV i2c_flag, W0
00068E  DE0042     LSR W0, #2, W0
000690  604061     AND.B W0, #0x1, W0
000692  604061     AND.B W0, #0x1, W0
000694  2089C1     MOV #0x89C, W1
000696  784091     MOV.B [W1], W1
000698  A10401     BCLR.B W1, #0
00069A  70C000     IOR.B W1, W0, W0
00069C  B7E89C     MOV.B WREG, i2c_flag
00069E  8044E0     MOV i2c_flag, W0
0006A0  604061     AND.B W0, #0x1, W0
0006A2  604061     AND.B W0, #0x1, W0
0006A4  404000     ADD.B W0, W0, W0
0006A6  2089C1     MOV #0x89C, W1
0006A8  784091     MOV.B [W1], W1
0006AA  A11401     BCLR.B W1, #1
0006AC  70C000     IOR.B W1, W0, W0
0006AE  B7E89C     MOV.B WREG, i2c_flag
431:                           i2c_IsResart = 0; //
0006B0  EF689D     CLR.B i2c_IsResart
432:                           break;
0006B2  370001     BRA 0x6B6
433:                       }
434:               
435:                           //        default:
436:                           //
437:                           //            // This case should not happen, if it does then
438:                           //            // terminate the transfer
439:                           //            //    i2c1_object.i2cErrors++;
440:                           //        {
441:                           //            I2C1CONbits.PEN = 1; // I2C STOP control bit.  
442:                           //            //            IFS1bits.MI2C1IF = 0; //
443:                           //            //            i2c1_state = S_MASTER_IDLE;
444:                           //            break;
445:                           //        }
446:                   }
447:                   OSIntExit();
0006B6  070E5B     RCALL OSIntExit
448:               }
0006B8  FA8000     ULNK
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/INT.c  ---------------------------------------
1:                 #include "INT.h"
2:                 
3:                 void INT0_Init(void) {
007C28  FA0000     LNK #0x0
4:                     TRISFbits.TRISF6 = 1; //
007C2A  A8C2E8     BSET TRISF, #6
5:                     INTCON2bits.INT0EP = 1; //  1 =   0 = 
007C2C  A80082     BSET INTCON2, #0
6:                     IPC0bits.INT0IP = 7; //2
007C2E  800520     MOV IPC0, W0
007C30  B30070     IOR #0x7, W0
007C32  880520     MOV W0, IPC0
7:                     IFS0bits.INT0IF = 0; //
007C34  A90084     BCLR IFS0, #0
8:                     IEC0bits.INT0IE = 1; //
007C36  A80094     BSET IEC0, #0
9:                 }
007C38  FA8000     ULNK
007C3A  060000     RETURN
10:                
11:                void INT0_Open(void) {
007C3C  FA0000     LNK #0x0
12:                    IFS0bits.INT0IF = 0; //
007C3E  A90084     BCLR IFS0, #0
13:                    IEC0bits.INT0IE = 1;
007C40  A80094     BSET IEC0, #0
14:                }
007C42  FA8000     ULNK
007C44  060000     RETURN
15:                
16:                void INT0_Close(void) {
007C46  FA0000     LNK #0x0
17:                    IFS0bits.INT0IF = 0; //
007C48  A90084     BCLR IFS0, #0
18:                    IEC0bits.INT0IE = 0;
007C4A  A90094     BCLR IEC0, #0
19:                }
007C4C  FA8000     ULNK
20:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/I2C.c  ---------------------------------------
1:                 #include "I2C.h"
2:                 
3:                 volatile uint8_t i2c1_state;
4:                 I2C1_Buffer i2c_buf;
5:                 
6:                 void I2C_Init(void) {
007C50  FA0000     LNK #0x0
7:                     TRISGbits.TRISG2 = 0; //SCL1
007C52  A942F0     BCLR TRISG, #2
8:                     TRISGbits.TRISG3 = 0; //SCK1
007C54  A962F0     BCLR TRISG, #3
9:                     I2C1BRG = 0x9D; //100kHz Fcy=16000000
007C56  2009D0     MOV #0x9D, W0
007C58  881020     MOV W0, I2C1BRG
10:                    I2C1CONbits.I2CEN = 1; //I2C1
007C5A  A8E207     BSET 0x207, #7
11:                    I2C1CONbits.I2CSIDL = 0; //
007C5C  A9A207     BCLR 0x207, #5
12:                    I2C1CONbits.IPMIEN = 0; //IPMI
007C5E  A96207     BCLR 0x207, #3
13:                    I2C1CONbits.A10M = 0; //7
007C60  A94207     BCLR 0x207, #2
14:                    IEC1bits.MI2C1IE = 1; //Master
007C62  A82096     BSET IEC1, #1
15:                    IFS1bits.MI2C1IF = 0; //Master
007C64  A92086     BCLR IFS1, #1
16:                    //    IEC1bits.SI2C1IE = 1;//Slave
17:                    //    IFS1bits.SI2C1IF = 0;//Slave
18:                    //    I2C1CONbits.I2CEN = 0; //I2C1
19:                }
007C66  FA8000     ULNK
007C68  060000     RETURN
20:                
21:                void Start_I2C(void) {
007C6A  FA0000     LNK #0x0
22:                    //    IEC4bits.
23:                    //    I2C1CONbits.I2CEN = 1;
24:                    IFS1bits.MI2C1IF = 1;
007C6C  A82086     BSET IFS1, #1
25:                }
007C6E  FA8000     ULNK
26:                
27:                //void Stop_I2C(void) {
28:                //    IFS1bits.MI2C1IF = 0;
29:                //    I2C1CONbits.I2CEN = 0;
30:                //}
31:                
32:                //void Check_I2C(void) {
33:                //    if (I2C1STATbits.IWCOL) {//1
34:                //        I2C1STATbits.IWCOL = 0;
35:                //    }
36:                //}
37:                
38:                //void Clear_I2C_Sta(void) {
39:                //    i2c1_state = S_MASTER_IDLE;
40:                //}
41:                
42:                //void Send_I2C_Data(I2C1_Buffer* buf)
43:                //{
44:                //    buf
45:                //}
46:                
---  C:/Users/Administrator/Desktop/V1_1_4WCGforkjxm.X/BSP/DeepSleep.c  ---------------------------------
1:                 #include <DeepSleep.h>
2:                 #include <xc.h>
3:                 #include <stdint.h>
4:                 
5:                 /************
6:                  * /
7:                 LPCFGCW1<10>
8:                  RETEN RCON<12> LPCFG
9:                  0  RETEN  1
10:                 ************************************************/
11:                void DeepSleep(void) {
007C8E  FA0000     LNK #0x0
12:                    //    uint8_t Result;
13:                    //    if (RCONbits.WDTO) {
14:                    //        Result = 3;
15:                    //        RCONbits.WDTO = 0;
16:                    //        DSCONbits.RELEASE = 0;
17:                    //    } else if (RCONbits.EXTR) {
18:                    //        Result = 2;
19:                    //        RCONbits.EXTR = 0;
20:                    //        DSCONbits.RELEASE = 0;
21:                    //    } else if (RCONbits.DPSLP) {
22:                    //        Result = 1;
23:                    //        RCONbits.DPSLP = 0;
24:                    //        DSCONbits.RELEASE = 0;
25:                    //        if (DSWAKEbits.DSWDT) DSGPR0 = DSGPR0 + 1; /* count when wake from DSWDT */
26:                    //        if (DSWAKEbits.DSINT0) DSGPR1 = DSGPR1 + 1; /* count when wake from INT0  */
27:                    //    } else {
28:                    //        Result = 0; /* assume we are a Power On reset */
29:                    //        RCONbits.POR = 0;
30:                    //        DSGPR0 = 0;
31:                    //        DSGPR1 = 0;
32:                    //    }
33:                    //    if (Result == 0) {
34:                    RCONbits.RETEN = 1; // CONFIG1  #pragma config LPCFG = ON    // Low power regulator control->Disabled
007C90  A88741     BSET 0x741, #4
35:                    //    while (!RCONbits.RETEN)
36:                    //        RCONbits.RETEN = 1;
37:                    //    asm("disi #4");
38:                    //    asm("bset DSCON, #15");
39:                    //    asm("nop");
40:                    //    asm("nop");
41:                    //    asm("btss INTTREG, #15");
42:                    //    asm("pwrsav #0");
43:                    RCONbits.DPSLP = 0; /* clear all previous deep sleep wake flags */
007C92  A94741     BCLR 0x741, #2
44:                    DSWAKE = 0; /* clear all previous deep sleep wake flags */
007C94  EF275A     CLR DSWAKE
45:                    /* enter deep sleep code cut and paste from data sheet */
46:                    asm("disi #4");
007C96  FC0004     DISI #0x4
47:                    asm("bset  DSCON, #15");
007C98  A8E759     BSET 0x759, #7
48:                    asm("nop");
007C9A  000000     NOP
49:                    asm("nop");
007C9C  000000     NOP
50:                    asm("nop");    
007C9E  000000     NOP
51:                //    asm("bset  DSCON, #15");
52:                    asm("pwrsav #0");
007CA0  FE4000     PWRSAV #0
53:                    //    }
54:                }
007CA2  FA8000     ULNK
55:                
56:                
57:                
