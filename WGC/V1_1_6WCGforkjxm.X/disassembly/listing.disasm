Disassembly Listing for V1_1_5WCGforkjxm
Generated From:
C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/dist/default/production/V1_1_5WCGforkjxm.X.production.elf
2017-10-17 16:20:54

---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                
25:                /*
26:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
27:                
28:                Microchip licenses to you the right to use, modify, copy and distribute
29:                Software only when embedded on a Microchip microcontroller or digital signal
30:                controller that is integrated into your product or third party product
31:                (pursuant to the sublicense terms in the accompanying license agreement).
32:                
33:                You should refer to the license agreement accompanying this Software for
34:                additional information regarding your rights and obligations.
35:                
36:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                 */
47:                
48:                
49:                #include <includes.h>
50:                #include "Configbits.h"
51:                
52:                #ifdef DEBUG_RTCC_TIME
53:                volatile uint32_t rtime;
54:                uint8_t main_cnt = 0;
55:                uint32_t main_nums;
56:                volatile uint8_t samplecount;
57:                #endif
58:                
59:                /*
60:                                         Main application
61:                 */
62:                void main(void) {
002B1E  FA0000     LNK #0x0
63:                    //    uint32_t nums = 1;
64:                    //    uint8_t tmp[10];    
65:                    BSP_Init(); //底层驱动初始化
002B20  0700D7     RCALL BSP_Init
66:                    NUMS_SHOW(1, 0);
002B22  EB0080     CLR W1
002B24  200010     MOV #0x1, W0
002B26  07F4CC     RCALL NUMS_SHOW
67:                    IFS3bits.RTCIF = 1; //外设相关的中断标志状态位清零
002B28  A8C08B     BSET 0x8B, #6
68:                    while (1) {
69:                #ifdef DEBUG_RTCC_TIME
70:                        while (!WGCCON2bits.SET_TIME_TEST_FLAG);
002B2A  000000     NOP
002B2C  804051     MOV WGCCON2bits, W1
002B2E  240000     MOV #0x4000, W0
002B30  608000     AND W1, W0, W0
002B32  E00000     CP0 W0
002B34  32FFFB     BRA Z, 0x2B2C
002BB0  37FFBD     BRA 0x2B2C
71:                        if (WGCCON2bits.SET_TIME_TEST_FLAG) {
002B36  804051     MOV WGCCON2bits, W1
002B38  240000     MOV #0x4000, W0
002B3A  608000     AND W1, W0, W0
002B3C  E00000     CP0 W0
002B3E  32000C     BRA Z, 0x2B58
72:                            WGCCON2bits.SET_TIME_TEST_FLAG = 0; //清楚标志位
002B40  A9C80B     BCLR 0x80B, #6
73:                            RS485SendString1("\r\n/*********************************************************\r\n");
002B42  28FBC0     MOV #0x8FBC, W0
002B44  07FFCA     RCALL RS485SendString1
74:                            RS485SendString1("Nt:");
002B46  28FFB0     MOV #0x8FFB, W0
002B48  07FFC8     RCALL RS485SendString1
75:                            PrintTime(); //打印当前时间
002B4A  07F6B2     RCALL PrintTime
76:                            //            RS485SendString("\tSetting Alarm Time is ", 12);
77:                            printrtccArg();
002B4C  07F734     RCALL printrtccArg
78:                            printrtccArg1(rtime);
002B4E  8040E0     MOV rtime, W0
002B50  8040F1     MOV 0x81E, W1
002B52  07F777     RCALL printrtccArg1
79:                            RS485SendString1("\r\n**********************************************************/\r\n");
002B54  28FFF0     MOV #0x8FFF, W0
002B56  07FFC1     RCALL RS485SendString1
80:                        }
81:                #endif
82:                        if (WGCCON2bits.Send_FLAG) {
002B58  804051     MOV WGCCON2bits, W1
002B5A  220000     MOV #0x2000, W0
002B5C  608000     AND W1, W0, W0
002B5E  E00000     CP0 W0
002B60  320010     BRA Z, 0x2B82
83:                            WGCCON2bits.Send_FLAG = 0;
002B62  A9A80B     BCLR 0x80B, #5
84:                            //            Delay100ms(1);
85:                #ifdef DEBUG_RTCC_TIME
86:                            main_nums += 1;
002B64  804110     MOV main_nums, W0
002B66  804121     MOV 0x824, W1
002B68  400061     ADD W0, #0x1, W0
002B6A  4880E0     ADDC W1, #0x0, W1
002B6C  884110     MOV W0, main_nums
002B6E  884121     MOV W1, 0x824
87:                            NUMS_SHOW(main_nums, 0);
002B70  804110     MOV main_nums, W0
002B72  804121     MOV 0x824, W1
002B74  EB0100     CLR W2
002B76  07F4A4     RCALL NUMS_SHOW
88:                            RS485SendString1("\r\nStart GPRS!!!:");
002B78  2903F0     MOV #0x903F, W0
002B7A  07FFAF     RCALL RS485SendString1
89:                            PrintTime(); //打印当前时间
002B7C  07F699     RCALL PrintTime
90:                            RS485SendString1("\r\n");
002B7E  290500     MOV #0x9050, W0
002B80  07FFAC     RCALL RS485SendString1
91:                #endif
92:                        }
93:                        if (WGCCON2bits.Sample_FLAG) {
002B82  804051     MOV WGCCON2bits, W1
002B84  210000     MOV #0x1000, W0
002B86  608000     AND W1, W0, W0
002B88  E00000     CP0 W0
002B8A  320011     BRA Z, 0x2BAE
94:                            WGCCON2bits.Sample_FLAG = 0;
002B8C  A9880B     BCLR 0x80B, #4
95:                #ifdef DEBUG_RTCC_TIME
96:                            for (main_cnt = 0; main_cnt < 10; main_cnt++) {
002B8E  EF6820     CLR.B main_cnt
002B90  370006     BRA 0x2B9E
002B98  BFC820     MOV.B main_cnt, WREG
002B9A  E84000     INC.B W0, W0
002B9C  B7E820     MOV.B WREG, main_cnt
002B9E  BFC820     MOV.B main_cnt, WREG
002BA0  504FE9     SUB.B W0, #0x9, [W15]
002BA2  36FFF7     BRA LEU, 0x2B92
97:                                Delay100ms(1);
002B92  200010     MOV #0x1, W0
002B94  07F867     RCALL Delay100ms
98:                                LED_Toggle();
002B96  0700B7     RCALL LED_Toggle
99:                            }
100:                           RS485SendString1("\r\nStart Sample!!!:");
002BA4  290530     MOV #0x9053, W0
002BA6  07FF99     RCALL RS485SendString1
101:                           printrtccArg1(samplecount);
002BA8  BFC826     MOV.B samplecount, WREG
002BAA  FB8000     ZE W0, W0
002BAC  07F74A     RCALL printrtccArg1
102:               #endif
103:                       }
104:                       //        Delay1s(1);
105:                       //        LED_Toggle(); //  
106:                       //        printf("Hello world%d,\n",123);
107:                       //        NUMS_SHOW(nums++, 0);
108:                       //        RS485SendString("Now time is ", 12);
109:                       //        PrintTime();
110:                   }
002BAE  000000     NOP
111:               }
112:               
113:               /**
114:                End of File
115:                */
116:               
117:               //void Task1Led(void* p_arg) {
118:               ////    INT8U err;
119:               //    //    uint8_t cnt = 0;
120:               //    //    OS_EVENT sem1;
121:               //    while (1) {
122:               //        //        PrintTime();
123:               //        switch (WGC_sta) {
124:               //            case 1://进入睡眠模式
125:               //            {
126:               //                LED_Toggle();
127:               //                OSTimeDlyHMSM(0, 0, 1, 0); //延时1s 
128:               //                break;
129:               //            }
130:               //            case 2://上线过程
131:               //            {
132:               //                LED_Toggle();
133:               //                OSTimeDlyHMSM(0, 0, 0, 500); //延时1s  
134:               //                break;
135:               //            }
136:               //            case 3://发送数据
137:               //            {
138:               //                LED_On();
139:               //                OSTimeDlyHMSM(0, 0, 3, 0); //避免任务锁死  
140:               //                break;
141:               //            }
142:               //            case 4://采集数据
143:               //            {
144:               //                LED_Toggle();
145:               //                OSTimeDlyHMSM(0, 0, 0, 200); //延时1s  
146:               //                break;
147:               //            }
148:               //            default://工作模式
149:               //            {
150:               //                LED_Toggle();
151:               //                err = OSTimeDlyHMSM(0, 0, 0, 300); //延时1s                  
152:               //                break;
153:               //            }
154:               //
155:               //        }
156:               //    }
157:               //}
158:               
159:               //void Task2UseHL6528(void *p_arg) {
160:               ////    INT8U err;
161:               //    HL6528_Init(); /*Initialize the HL6528*/
162:               //    //    OSTimeDlyHMSM(0, 0, 5, 0);
163:               //    while (1) {
164:               //        //        OSSemPend(sem_send_pressure, 0, &err);
165:               //        HL6528_GetIP_Port(); //每次通讯都更新下IP地址和端口号
166:               //        UART2_Open();
167:               //        WGC_sta = 2; //GPRS拨号
168:               //        //        HL6528_GetIP_Port(tmp);
169:               //        if (!HL6528_DialingIsERR()) {
170:               //            WGC_sta = 3; //GPRS发送数据
171:               //            OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
172:               //            UART2_SendString("103.1");
173:               //            OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
174:               //        }
175:               //        HL6528_Close();
176:               //        WGC_sta = 0; //GPRS拨号
177:               //    }
178:               //}
179:               
180:               //void Task3UseE41(void *parg) {
181:               ////    uint8_t err;
182:               //    float f_dat;
183:               //    E41_Init();
184:               //    OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
185:               //    //    uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34};
186:               //    //    E41_SetArg(); //E41设置参数
187:               //    while (1) {
188:               //        OSSemPend(sem_get_pressure, 0, &err); //等待主动采集指令
189:               //        E41_Active_Send();
190:               //        OSSemPend(sem_receive_pressure, 1000, &err);
191:               //        WGC_sta = 4;
192:               //        OSTimeDlyHMSM(0, 0, 3, 0); //延时1s
193:               //        //        LED_Toggle();
194:               //        //        OSTimeDlyHMSM(0, 0, 0, 200);
195:               //        if (E41_PressureIsGet(&f_dat)) {
196:               //            OSSemPost(sem_send_pressure);
197:               //            //            OSMboxPost(E41_Dat, &f_dat); //通过邮箱发送数据给服务器
198:               //        }
199:               //        WGC_sta = 0;
200:               //        //        UART3_SendString(E41_tmp, 5);
201:               //        //        OSTimeDlyHMSM(0, 0, 10, 0); //延时1s
202:               //    }
203:               //}
204:               
205:               //void Task4Use485(void *parg) {
206:               //    parg = parg;
207:               //    while (1) {
208:               //        RS485SendChar(0x30);
209:               //        //        RS485SendString("123", 3);
210:               //        OSTimeDlyHMSM(0, 0, 1, 0);
211:               //        //        OSSemPost(sem1);
212:               //    }
213:               //}
214:               
215:               //void Task5UseCAT24C512(void* parg) {
216:               //    INT8U err;
217:               //    parg = parg; //防止编译器警告
218:               //    CAT24C512_Init(); //应用程序初始化
219:               //
220:               //    while (1) {
221:               //        //等待使用互斥量信号
222:               //        //通过邮箱判断存储还是读取
223:               //        //
224:               ////        OSMutexPost();
225:               ////        OSMutexPend();
226:               ////        OSMBoxPost
227:               ////        OSSemPend(sem2, 0, &err); //, 0, &err);
228:               ////        -(0, tmp2);
229:               //    }
230:               //}
231:               
232:               //void Task6Sleep(void* p_arg) {
233:               //    p_arg = p_arg;
234:               //    LED_Off();
235:               //    
236:               //    OSSchedLock();//禁止任务调度
237:               //    while (1) {
238:               //        DeepSleep();
239:               //        OSSemPost(sem2); //, 0, &err);
240:               //        //        Sleep();
241:               //
242:               //    }
243:               ////    OSSchedUnlock();//允许任务调度
244:               //}
245:               
246:               //void Task7SetAlarm(void *p_arg) {
247:               ////    INT8U err;
248:               ////    WGC_sta = 0;
249:               ////    IFS3bits.RTCIF = 1; //启动闹钟一次，方便下次设置时间 用于测试
250:               ////
251:               ////    while (1) {
252:               ////        OSSemPend(sem_set_alarm, 0, &err);
253:               //////        PrintTime();
254:               ////        WGC_CalcAlarmPeriod(); //计算周期
255:               ////        //        OSSemPost(sem_get_pressure); //主动采集
256:               ////    }
257:               //}
258:               
259:               
260:               
261:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/WGC.c  --------------------------------------
1:                 #include "WGC.h"
2:                 
3:                 #define TIMEOFFSET 1483200000
4:                 
5:                 //enum {Jan=31,Feb=30,Mar=31,Apr=30,May=31,Jun=30,Jul=31,Aug=31,Sep=30,Oct=31,Nov=30,Dec=31};
6:                 uint8_t Month[12] = {31, 30, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
7:                 
8:                 volatile WGCTIME0BITS WGCTIME0bits;
9:                 volatile WGCTIME1BITS WGCTIME1bits;
10:                volatile WGCTIME2BITS WGCTIME2bits;
11:                volatile WGCCON0BITS WGCCON0bits;
12:                volatile WGCCON1BITS WGCCON1bits;
13:                volatile WGCCON2BITS WGCCON2bits;
14:                volatile WGCCON3BITS WGCCON3bits;
15:                volatile WGCCON4BITS WGCCON4bits;
16:                volatile WGCIPBITS WGCIPbits;
17:                volatile uint16_t WGCPORT;
18:                //volatile WGCPERIODBITS WGCPeriodbits;
19:                volatile uint8_t WGC_Sta = 1;
20:                //struct RTCC_Time_Node RT_node;
21:                
22:                //static volatile struct RTCC_Time_Node rtcc_sample;
23:                //static volatile struct RTCC_Time_Node rtcc_send;
24:                
25:                void WGC_Init(void) {
002424  FA0000     LNK #0x0
26:                    WGCIPbits.IP3 = 139; //设置IP地址
002426  B3C8B0     MOV.B #0x8B, W0
002428  B7E817     MOV.B WREG, 0x817
27:                    WGCIPbits.IP2 = 196;
00242A  B3CC40     MOV.B #0xC4, W0
00242C  B7E816     MOV.B WREG, 0x816
28:                    WGCIPbits.IP1 = 122;
00242E  B3C7A0     MOV.B #0x7A, W0
002430  B7E815     MOV.B WREG, 0x815
29:                    WGCIPbits.IP0 = 159;
002432  B3C9F0     MOV.B #0x9F, W0
002434  B7E814     MOV.B WREG, WGCIPbits
30:                    WGCPORT = 5080; //设置端口号
002436  213D80     MOV #0x13D8, W0
002438  8840C0     MOV W0, WGCPORT
31:                    WGCCON0bits.Send_60s = 0x01; //发送2分钟
00243A  804031     MOV WGCCON0bits, W1
00243C  2F8000     MOV #0xF800, W0
00243E  608000     AND W1, W0, W0
002440  A00000     BSET W0, #0
002442  884030     MOV W0, WGCCON0bits
32:                    WGCCON1bits.Sample_5s = 0x03; //采集5秒
002444  804041     MOV WGCCON1bits, W1
002446  280000     MOV #0x8000, W0
002448  608000     AND W1, W0, W0
00244A  B30030     IOR #0x3, W0
00244C  884040     MOV W0, WGCCON1bits
33:                    WGCCON2bits.E41_Is_Use_For_Send_Data = 0; //关闭E41
00244E  A9080B     BCLR 0x80B, #0
34:                    WGCCON2bits.E41_Is_Use_For_Set_Arg = 0; //关闭E41
002450  A9280B     BCLR 0x80B, #1
35:                    WGCCON2bits.WGC_ID = 0x03; //ID号
002452  B3C030     MOV.B #0x3, W0
002454  B7E80A     MOV.B WREG, WGCCON2bits
36:                    //    RTCC_TIME_Init(); //初始化RTCC_TIME数据结构
37:                    WGCCON2bits.Period_FLAG = 1; //初始化开始计算时间
002456  A8680B     BSET 0x80B, #3
38:                    //    WGCPeriodbits.CNT = 0;
39:                    //    WGCCON2bits.Alarm_RST_FLAG = 0; //上电成重新计算
40:                }
002458  FA8000     ULNK
00245A  060000     RETURN
41:                
42:                //static void GetPressure(void) {
43:                //    
44:                //}
45:                
46:                //bool WGC_CalcAlarmPeriod(void) {//设置下次报警时间
47:                //    struct tm now_time1, now_time2;
48:                //    uint32_t time1;
49:                //    //获取当前的时间，然后在这个时间的基础上加上秒数
50:                //    while (!RTC_Read_Time(&now_time1)); //容错设计
51:                //    //    while (!RTC_Read_Time(&now_time1)); //容错设计
52:                //    time1 = mktime(&now_time1);
53:                //    time1 += 10;
54:                //    now_time2 = *gmtime(&time1);
55:                //
56:                //    RTC_Set_Alarm(now_time1);
57:                //}
58:                
59:                void GPRS_Task(void) {
00245C  FA0014     LNK #0x14
60:                    uint8_t tmp[20];
61:                    HL6528_GetIP_Port(); //每次通讯都更新下IP地址和端口号
00245E  07FF46     RCALL HL6528_GetIP_Port
62:                    UART2_Open();
002460  07022E     RCALL UART2_Open
63:                    WGC_Sta = GPRS_Dingling; //GPRS拨号
002462  B3C010     MOV.B #0x1, W0
002464  B7E83C     MOV.B WREG, 0x83C
64:                    //        HL6528_GetIP_Port(tmp);
65:                    if (!HL6528_DialingIsERR()) {
002466  07FEB7     RCALL HL6528_DialingIsERR
002468  A20400     BTG.B W0, #0
00246A  E00400     CP0.B W0
00246C  32000D     BRA Z, 0x2488
66:                        WGC_Sta = GPRS_Online; //GPRS发送数据
00246E  B3C020     MOV.B #0x2, W0
002470  B7E83C     MOV.B WREG, 0x83C
67:                        Delays(1); //延时1s
002472  B3C010     MOV.B #0x1, W0
002474  07FC31     RCALL Delays
68:                        CAT24C512_Read(1, tmp); //获取数据  !!!添加判断 如果I2C错误
002476  78008E     MOV W14, W1
002478  200010     MOV #0x1, W0
00247A  0703A0     RCALL CAT24C512_Read
69:                        //处理数据
70:                        UART2_SendString2(tmp + 3, 4); //发送传输数据
00247C  470063     ADD W14, #0x3, W0
00247E  B3C041     MOV.B #0x4, W1
002480  070249     RCALL UART2_SendString2
71:                        Delays(1); //延时1s
002482  B3C010     MOV.B #0x1, W0
002484  07FC29     RCALL Delays
002486  370002     BRA 0x248C
72:                    } else
73:                        WGC_Sta = GPRS_Err; //GPRS拨号失败
002488  B3C060     MOV.B #0x6, W0
00248A  B7E83C     MOV.B WREG, 0x83C
74:                
75:                    HL6528_Close(); //发送AT指令传输数据}
00248C  07FEFA     RCALL HL6528_Close
76:                }
00248E  FA8000     ULNK
002490  060000     RETURN
77:                
78:                void Sample_Task(void) {
002492  FA005A     LNK #0x5A
79:                    uint8_t Sendstr[] = {0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x85, 0xD4}; //获取压力的指令
002494  290FE1     MOV #0x90FE, W1
002496  090007     REPEAT #0x7
002498  785F31     MOV.B [W1++], [W14++]
00249A  B1008E     SUB #0x8, W14
80:                    StrCmp pressure;
81:                    uint8_t Getstr[20] = {0x01, 0x03, 0x04}; //用于保存接收的数据
00249C  4700F4     ADD W14, #0x14, W1
00249E  090009     REPEAT #0x9
0024A0  EB1880     CLR [W1++]
0024A2  B3C010     MOV.B #0x1, W0
0024A4  985740     MOV.B W0, [W14+20]
0024A6  B3C030     MOV.B #0x3, W0
0024A8  985750     MOV.B W0, [W14+21]
0024AA  B3C040     MOV.B #0x4, W0
0024AC  985760     MOV.B W0, [W14+22]
82:                    uint8_t Savstr[50] = {0x00}; //uart获取缓冲区数据
0024AE  78008E     MOV W14, W1
0024B0  B00281     ADD #0x28, W1
0024B2  090018     REPEAT #0x18
0024B4  EB1880     CLR [W1++]
83:                    RS485SendString(Sendstr, 8);
0024B6  200081     MOV #0x8, W1
0024B8  78000E     MOV W14, W0
0024BA  0702EE     RCALL RS485SendString
84:                
85:                    Delays(1); //延时1s 需要测试下
0024BC  B3C010     MOV.B #0x1, W0
0024BE  07FC0C     RCALL Delays
86:                    pressure.CheckData = Getstr;
0024C0  470074     ADD W14, #0x14, W0
0024C2  980760     MOV W0, [W14+12]
87:                    pressure.Check_len = 3;
0024C4  B3C030     MOV.B #0x3, W0
0024C6  984F60     MOV.B W0, [W14+14]
88:                    pressure.GetData = Getstr;
0024C8  470074     ADD W14, #0x14, W0
0024CA  980F00     MOV W0, [W14+16]
89:                    pressure.Get_len = 9;
0024CC  B3C090     MOV.B #0x9, W0
0024CE  985720     MOV.B W0, [W14+18]
90:                    pressure.SourceData = Savstr;
0024D0  200280     MOV #0x28, W0
0024D2  40000E     ADD W0, W14, W0
0024D4  980740     MOV W0, [W14+8]
91:                    pressure.Source_len = UARTGetData(BufferRead_UART1, Savstr, 50);
0024D6  200280     MOV #0x28, W0
0024D8  40000E     ADD W0, W14, W0
0024DA  B3C322     MOV.B #0x32, W2
0024DC  780080     MOV W0, W1
0024DE  21ED20     MOV #0x1ED2, W0
0024E0  07FE0D     RCALL UARTGetData
0024E2  984F20     MOV.B W0, [W14+10]
92:                
93:                    if (UARTDataIsRight(&pressure)) {
0024E4  470068     ADD W14, #0x8, W0
0024E6  07FD47     RCALL UARTDataIsRight
94:                        //        WGC_Sta = Sample_Send_Flag;
95:                        //        CAT24C512_Write(1, Savstr);
96:                    } else {
97:                        //        WGC_Sta = Sample_Err;
98:                    }
99:                }
0024E8  FA8000     ULNK
0024EA  060000     RETURN
100:               
101:               
102:               
103:               //    if (WGCCON2bits.Alarm_RST_FLAG) {//如果需要重启的话,那么重新计算周期参数；反之，设置下次报警的时间
104:               //        WGCCON2bits.Alarm_RST_FLAG = 0; //清楚标志为
105:               //        if (WGCCON0bits.Send_60s < 3)//发送阈值判断
106:               //            WGCCON0bits.Send_60s = 3;
107:               //        else if (WGCCON0bits.Send_60s > 1440)
108:               //            WGCCON0bits.Send_60s = 1440;
109:               //        if (WGCCON1bits.Sample_5s < 1)//采集阈值判断
110:               //            WGCCON1bits.Sample_5s = 1;
111:               //        else if (WGCCON1bits.Sample_5s > 17280)
112:               //            WGCCON1bits.Sample_5s = 17280;
113:               //
114:               //        if (WGCCON1bits.Sample_5s > (WGCCON0bits.Send_60s * 12))//如果采集时间大于发送时间，那么将采集时间设置为发送时间
115:               //            WGCCON1bits.Sample_5s = WGCCON0bits.Send_60s * 12;
116:               //        WGCPeriodbits.B1 = (WGCCON0bits.Send_60s * 12) / WGCCON1bits.Sample_5s; //倍数
117:               //        WGCPeriodbits.Y2 = (WGCCON0bits.Send_60s * 12) % WGCCON1bits.Sample_5s; //余数     
118:               //        WGCPeriodbits.CNT = 0; //清楚计数
119:               //    }
120:               
121:               
122:               
123:               //    if (WGCPeriodbits.CNT == WGCPeriodbits.B1) {//下个时间就是发送的时间
124:               //        //设置报警时间为余数的时间
125:               //        if (!WGCPeriodbits.Y2) {//如果余数为0的话，那么直接设置下次采集时间（上传时间已经到了），反之，设置下次计算上传时间
126:               //            now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
127:               //            //开始调用GPRS上传数据
128:               //            WGCCON2bits.Send_FLAG = 1; //采集时间和发送时间均到了
129:               //            WGCPeriodbits.CNT = 0;
130:               //        } else {
131:               //            now_second += WGCPeriodbits.Y2 * 5; //设置上传时间
132:               //            WGCPeriodbits.CNT += 1;
133:               //        }
134:               //    } else if (WGCPeriodbits.CNT > WGCPeriodbits.B1) {
135:               //        now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
136:               //        //开始调用GPRS上传数据
137:               //        WGCPeriodbits.CNT = 0;
138:               //    } else {
139:               //        //设置报警时间为采集的时间
140:               //        WGCCON2bits.Sample_FLAG = 1;
141:               //        now_second += (WGCCON1bits.Sample_5s * 5); //加上报警的时间
142:               //        WGCPeriodbits.CNT += 1;
143:               //    }
144:               
145:               uint32_t CalaAlarmTime(void) {
0024EC  FA0000     LNK #0x0
146:                   static uint8_t cnt = 0;
147:                   if (WGCCON2bits.Period_FLAG) {
0024EE  804051     MOV WGCCON2bits, W1
0024F0  208000     MOV #0x800, W0
0024F2  608000     AND W1, W0, W0
0024F4  E00000     CP0 W0
0024F6  320011     BRA Z, 0x251A
148:                       WGCCON2bits.Period_FLAG = 0;
0024F8  A9680B     BCLR 0x80B, #3
149:               #ifdef DEBUG_RTCC_TIME
150:                       WGCCON3bits.delay = 10; //采集时间
0024FA  2000A0     MOV #0xA, W0
0024FC  884060     MOV W0, WGCCON3bits
0024FE  A9080E     BCLR 0x80E, #0
151:                       WGCCON3bits.count = 6; //计算采集的次数
002500  804070     MOV 0x80E, W0
002502  600061     AND W0, #0x1, W0
002504  B300C0     IOR #0xC, W0
002506  884070     MOV W0, 0x80E
152:                       WGCCON4bits.delay = 0; //计算上传的时间 总时间为12*3+3=39s
002508  EF2810     CLR WGCCON4bits
00250A  A90812     BCLR 0x812, #0
153:                       WGCCON4bits.count = 0; //上传累计次数清零
00250C  804090     MOV 0x812, W0
00250E  600061     AND W0, #0x1, W0
002510  884090     MOV W0, 0x812
154:               #else
155:                       WGCCON3bits.delay = WGCCON1bits.Sample_5s * 5; //采集时间
156:                       WGCCON3bits.count = WGCCON0bits.Send_60s * 12 / WGCCON1bits.Sample_5s; //计算采集的次数
157:                       WGCCON4bits.delay = WGCCON0bits.Send_60s * 12 % WGCCON1bits.Sample_5s; //计算上传的时间
158:                       WGCCON4bits.count = 0; //上传累计次数清零
159:               #endif
160:                       return WGCCON3bits.delay;
002512  804060     MOV WGCCON3bits, W0
002514  804072     MOV 0x80E, W2
002516  6100E1     AND W2, #0x1, W1
002518  37005D     BRA 0x25D4
161:                   } else {
162:                       if (cnt < WGCCON3bits.count - 1) {//如果技术的时间还没有到，那么继续将定时设置为采集的时间
00251A  BFC81A     MOV.B cnt, WREG
00251C  FB8080     ZE W0, W1
00251E  804070     MOV 0x80E, W0
002520  D10000     LSR W0, W0
002522  E90000     DEC W0, W0
002524  508F80     SUB W1, W0, [W15]
002526  3D000A     BRA GE, 0x253C
163:                           WGCCON2bits.Sample_FLAG = 1;
002528  A8880B     BSET 0x80B, #4
164:                           cnt += 1;
00252A  BFC81A     MOV.B cnt, WREG
00252C  E84000     INC.B W0, W0
00252E  B7E81A     MOV.B WREG, cnt
165:               #ifdef DEBUG_RTCC_TIME
166:                           samplecount = cnt;
002530  BFC81A     MOV.B cnt, WREG
002532  B7E826     MOV.B WREG, samplecount
167:               #endif
168:                           return WGCCON3bits.delay;
002534  804060     MOV WGCCON3bits, W0
002536  804072     MOV 0x80E, W2
002538  6100E1     AND W2, #0x1, W1
00253A  37004C     BRA 0x25D4
169:                       } else {//如果采集计数和规定的时间计数相同，那么需要判断是否采集时间是否是上传时间的整数倍
170:                           //            cnt += 1;
171:                           //#ifdef DEBUG_RTCC_TIME
172:                           //            samplecount = cnt;
173:                           //#endif
174:                           if (WGCCON4bits.delay)//如果发送时间刚好是采集时间的整数倍的话，将控制寄存器2标志为置1、设置下次定时时间
00253C  804080     MOV WGCCON4bits, W0
00253E  804092     MOV 0x812, W2
002540  6100E1     AND W2, #0x1, W1
002542  500FE0     SUB W0, #0x0, [W15]
002544  588FE0     SUBB W1, #0x0, [W15]
002546  320034     BRA Z, 0x25B0
175:                           {
176:                               if (WGCCON4bits.count) {
002548  804090     MOV 0x812, W0
00254A  A10000     BCLR W0, #0
00254C  E00000     CP0 W0
00254E  32001E     BRA Z, 0x258C
177:                                   WGCCON4bits.count = 0;
002550  804090     MOV 0x812, W0
002552  600061     AND W0, #0x1, W0
002554  884090     MOV W0, 0x812
178:                                   WGCCON2bits.Send_FLAG = 1;
002556  A8A80B     BSET 0x80B, #5
179:                                   cnt = 0;
002558  EF681A     CLR.B cnt
180:                                   return WGCCON3bits.delay - WGCCON4bits.delay;
00255A  804062     MOV WGCCON3bits, W2
00255C  804070     MOV 0x80E, W0
00255E  6001E1     AND W0, #0x1, W3
002560  804080     MOV WGCCON4bits, W0
002562  804094     MOV 0x812, W4
002564  6200E1     AND W4, #0x1, W1
002566  510000     SUB W2, W0, W0
002568  598081     SUBB W3, W1, W1
00256A  2FFFF2     MOV #0xFFFF, W2
00256C  200013     MOV #0x1, W3
00256E  780280     MOV W0, W5
002570  780081     MOV W1, W1
002572  780202     MOV W2, W4
002574  780003     MOV W3, W0
002576  628204     AND W5, W4, W4
002578  608000     AND W1, W0, W0
00257A  EB0080     CLR W1
00257C  DD00C0     SL W0, #0, W1
00257E  200000     MOV #0x0, W0
002580  BE0100     MOV.D W0, W2
002582  B82061     MUL.UU W4, #1, W0
002584  710100     IOR W2, W0, W2
002586  718181     IOR W3, W1, W3
002588  BE0002     MOV.D W2, W0
00258A  370024     BRA 0x25D4
181:                               }
182:               #ifdef DEBUG_RTCC_TIME
183:                               samplecount = cnt + 1;
00258C  BFC81A     MOV.B cnt, WREG
00258E  E84000     INC.B W0, W0
002590  B7E826     MOV.B WREG, samplecount
184:               #endif
185:                               WGCCON4bits.count += 1; //上线次数加1
002592  804090     MOV 0x812, W0
002594  D10000     LSR W0, W0
002596  E80000     INC W0, W0
002598  780080     MOV W0, W1
00259A  27FFF0     MOV #0x7FFF, W0
00259C  608000     AND W1, W0, W0
00259E  400000     ADD W0, W0, W0
0025A0  804091     MOV 0x812, W1
0025A2  6080E1     AND W1, #0x1, W1
0025A4  700001     IOR W0, W1, W0
0025A6  884090     MOV W0, 0x812
186:                               return WGCCON4bits.delay;
0025A8  804080     MOV WGCCON4bits, W0
0025AA  804092     MOV 0x812, W2
0025AC  6100E1     AND W2, #0x1, W1
0025AE  370012     BRA 0x25D4
187:                           } else//反之，将定时时间设置为采样的时间
188:                           {
189:               #ifdef DEBUG_RTCC_TIME
190:                               samplecount = cnt + 1;
0025B0  BFC81A     MOV.B cnt, WREG
0025B2  E84000     INC.B W0, W0
0025B4  B7E826     MOV.B WREG, samplecount
191:               #endif
192:                               WGCCON2bits.Sample_FLAG = WGCCON2bits.Send_FLAG = 1;
0025B6  A8A80B     BSET 0x80B, #5
0025B8  804050     MOV WGCCON2bits, W0
0025BA  DE004D     LSR W0, #13, W0
0025BC  604061     AND.B W0, #0x1, W0
0025BE  FB8000     ZE W0, W0
0025C0  600061     AND W0, #0x1, W0
0025C2  DD004C     SL W0, #12, W0
0025C4  804051     MOV WGCCON2bits, W1
0025C6  A1C001     BCLR W1, #12
0025C8  700001     IOR W0, W1, W0
0025CA  884050     MOV W0, WGCCON2bits
193:                               cnt = 0; //清楚内部计数
0025CC  EF681A     CLR.B cnt
194:                               return WGCCON3bits.delay;
0025CE  804060     MOV WGCCON3bits, W0
0025D0  804072     MOV 0x80E, W2
0025D2  6100E1     AND W2, #0x1, W1
195:                           }
196:                       }
197:                   }
198:               }
0025D4  FA8000     ULNK
0025D6  060000     RETURN
199:               
200:               void SetNextAlarm(uint32_t sample_sec) {
0025D8  FA001E     LNK #0x1E
0025DA  980F50     MOV W0, [W14+26]
0025DC  980F61     MOV W1, [W14+28]
201:                   struct tm time1;
202:                   uint32_t tmp, tmp1;
203:               
204:                   enum {
205:                       sec, min, hour, day, mon, year
206:                   };
207:               
208:                   while (!RTC_Read_Time(&time1)); //容错设计
0025DE  000000     NOP
0025E0  470068     ADD W14, #0x8, W0
0025E2  07F8B3     RCALL RTC_Read_Time
0025E4  E00000     CP0 W0
0025E6  32FFFC     BRA Z, 0x25E0
209:                   tmp = (time1.tm_sec + sample_sec); //计算秒数
0025E8  90004E     MOV [W14+8], W0
0025EA  B90161     MUL.SU W0, #1, W2
0025EC  90085E     MOV [W14+26], W0
0025EE  9008EE     MOV [W14+28], W1
0025F0  411F00     ADD W2, W0, [W14++]
0025F2  499701     ADDC W3, W1, [W14--]
210:                   time1.tm_sec = tmp % 60;
0025F4  BE001E     MOV.D [W14], W0
0025F6  2003C2     MOV #0x3C, W2
0025F8  200003     MOV #0x0, W3
0025FA  07F22A     RCALL 0xA50
0025FC  780000     MOV W0, W0
0025FE  980740     MOV W0, [W14+8]
211:                   tmp1 = tmp / 60; //分钟是否溢出
002600  BE001E     MOV.D [W14], W0
002602  2003C2     MOV #0x3C, W2
002604  200003     MOV #0x0, W3
002606  07F214     RCALL 0xA30
002608  980720     MOV W0, [W14+4]
00260A  980731     MOV W1, [W14+6]
212:                   if (tmp1 > 0)//如果累加的时间大于60s
00260C  90002E     MOV [W14+4], W0
00260E  9000BE     MOV [W14+6], W1
002610  500FE0     SUB W0, #0x0, [W15]
002612  588FE0     SUBB W1, #0x0, [W15]
002614  320029     BRA Z, 0x2668
213:                   {
214:                       tmp = (time1.tm_min + tmp1);
002616  90005E     MOV [W14+10], W0
002618  B90161     MUL.SU W0, #1, W2
00261A  90002E     MOV [W14+4], W0
00261C  9000BE     MOV [W14+6], W1
00261E  411F00     ADD W2, W0, [W14++]
002620  499701     ADDC W3, W1, [W14--]
215:                       time1.tm_min = tmp % 60;
002622  BE001E     MOV.D [W14], W0
002624  2003C2     MOV #0x3C, W2
002626  200003     MOV #0x0, W3
002628  07F213     RCALL 0xA50
00262A  780000     MOV W0, W0
00262C  980750     MOV W0, [W14+10]
216:                       tmp1 = tmp / 60;
00262E  BE001E     MOV.D [W14], W0
002630  2003C2     MOV #0x3C, W2
002632  200003     MOV #0x0, W3
002634  07F1FD     RCALL 0xA30
002636  980720     MOV W0, [W14+4]
002638  980731     MOV W1, [W14+6]
217:                       if (tmp1 > 0) {
00263A  90002E     MOV [W14+4], W0
00263C  9000BE     MOV [W14+6], W1
00263E  500FE0     SUB W0, #0x0, [W15]
002640  588FE0     SUBB W1, #0x0, [W15]
002642  320012     BRA Z, 0x2668
218:                           tmp = (time1.tm_hour + tmp1);
002644  90006E     MOV [W14+12], W0
002646  B90161     MUL.SU W0, #1, W2
002648  90002E     MOV [W14+4], W0
00264A  9000BE     MOV [W14+6], W1
00264C  411F00     ADD W2, W0, [W14++]
00264E  499701     ADDC W3, W1, [W14--]
219:                           time1.tm_hour = tmp % 24;
002650  BE001E     MOV.D [W14], W0
002652  200182     MOV #0x18, W2
002654  200003     MOV #0x0, W3
002656  07F1FC     RCALL 0xA50
002658  780000     MOV W0, W0
00265A  980760     MOV W0, [W14+12]
220:                           tmp1 = tmp / 24;
00265C  BE001E     MOV.D [W14], W0
00265E  200182     MOV #0x18, W2
002660  200003     MOV #0x0, W3
002662  07F1E6     RCALL 0xA30
002664  980720     MOV W0, [W14+4]
002666  980731     MOV W1, [W14+6]
221:                       }
222:                   }
223:               
224:                   RTC_Set_Alarm(time1); //每日一次闹钟
002668  4787F2     ADD W15, #0x12, W15
00266A  578072     SUB W15, #0x12, W0
00266C  4700E8     ADD W14, #0x8, W1
00266E  090008     REPEAT #0x8
002670  781831     MOV [W1++], [W0++]
002672  B10120     SUB #0x12, W0
002674  07F831     RCALL RTC_Set_Alarm
002676  5787F2     SUB W15, #0x12, W15
225:               }
002678  FA8000     ULNK
226:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**********************************定义****************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 写数据到环形缓冲区
25:                Input: 串口号，1和2 
26:                Output: 无
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
001E34  FA0002     LNK #0x2
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {//如果缓冲区已满 写的速度比读的速度块
001E36  BFC832     MOV.B bufferWptr_uart1, WREG
001E38  FB8080     ZE W0, W1
001E3A  BFC833     MOV.B bufferRptr_uart1, WREG
001E3C  FB8000     ZE W0, W0
001E3E  E90000     DEC W0, W0
001E40  508F80     SUB W1, W0, [W15]
001E42  3A0003     BRA NZ, 0x1E4A
31:                        tmp = U1RXREG; //将溢出的数据，丢弃
001E44  801130     MOV U1RXREG, W0
001E46  784F00     MOV.B W0, [W14]
32:                        return;
001E48  37000C     BRA 0x1E62
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
001E4A  BFC832     MOV.B bufferWptr_uart1, WREG
001E4C  FB8000     ZE W0, W0
001E4E  801131     MOV U1RXREG, W1
001E50  784101     MOV.B W1, W2
001E52  208401     MOV #0x840, W1
001E54  787082     MOV.B W2, [W1+W0]
35:                    bufferWptr_uart1++;
001E56  BFC832     MOV.B bufferWptr_uart1, WREG
001E58  E84000     INC.B W0, W0
001E5A  B7E832     MOV.B WREG, bufferWptr_uart1
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
001E5C  BFC832     MOV.B bufferWptr_uart1, WREG
001E5E  B243F0     AND.B #0x3F, W0
001E60  B7E832     MOV.B WREG, bufferWptr_uart1
37:                }
001E62  FA8000     ULNK
001E64  060000     RETURN
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 写数据到环形缓冲区
42:                Input: 串口号，1和2 
43:                Output: 无
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
001E66  FA0002     LNK #0x2
46:                    uint8_t tmp = 0;
001E68  EB4000     CLR.B W0
001E6A  784F00     MOV.B W0, [W14]
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {//如果缓冲区已满 写的速度比读的速度块
001E6C  BFC834     MOV.B bufferWptr_uart2, WREG
001E6E  FB8080     ZE W0, W1
001E70  BFC835     MOV.B bufferRptr_uart2, WREG
001E72  FB8000     ZE W0, W0
001E74  E90000     DEC W0, W0
001E76  508F80     SUB W1, W0, [W15]
001E78  3A0003     BRA NZ, 0x1E80
48:                        tmp = U2RXREG; //将溢出的数据，丢弃
001E7A  8011B0     MOV U2RXREG, W0
001E7C  784F00     MOV.B W0, [W14]
49:                        return;
001E7E  37000C     BRA 0x1E98
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
001E80  BFC834     MOV.B bufferWptr_uart2, WREG
001E82  FB8000     ZE W0, W0
001E84  8011B1     MOV U2RXREG, W1
001E86  784101     MOV.B W1, W2
001E88  208801     MOV #0x880, W1
001E8A  787082     MOV.B W2, [W1+W0]
52:                    bufferWptr_uart2++;
001E8C  BFC834     MOV.B bufferWptr_uart2, WREG
001E8E  E84000     INC.B W0, W0
001E90  B7E834     MOV.B WREG, bufferWptr_uart2
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
001E92  BFC834     MOV.B bufferWptr_uart2, WREG
001E94  B243F0     AND.B #0x3F, W0
001E96  B7E834     MOV.B WREG, bufferWptr_uart2
54:                }
001E98  FA8000     ULNK
001E9A  060000     RETURN
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 写数据到环形缓冲区
59:                Input: 串口号，1和2 
60:                Output: 无
61:                 *************************************/
62:                void BufferWrite_UART3(void) {
001E9C  FA0002     LNK #0x2
63:                    uint8_t tmp = 0;
001E9E  EB4000     CLR.B W0
001EA0  784F00     MOV.B W0, [W14]
64:                    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {//如果缓冲区已满 写的速度比读的速度块
001EA2  BFC836     MOV.B bufferWptr_uart3, WREG
001EA4  FB8080     ZE W0, W1
001EA6  BFC837     MOV.B bufferRptr_uart3, WREG
001EA8  FB8000     ZE W0, W0
001EAA  E90000     DEC W0, W0
001EAC  508F80     SUB W1, W0, [W15]
001EAE  3A0003     BRA NZ, 0x1EB6
65:                        tmp = U3RXREG; //将溢出的数据，丢弃
001EB0  8012B0     MOV U3RXREG, W0
001EB2  784F00     MOV.B W0, [W14]
66:                        return;
001EB4  37000C     BRA 0x1ECE
67:                    }
68:                    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
001EB6  BFC836     MOV.B bufferWptr_uart3, WREG
001EB8  FB8000     ZE W0, W0
001EBA  8012B1     MOV U3RXREG, W1
001EBC  784101     MOV.B W1, W2
001EBE  208C01     MOV #0x8C0, W1
001EC0  787082     MOV.B W2, [W1+W0]
69:                    bufferWptr_uart3++;
001EC2  BFC836     MOV.B bufferWptr_uart3, WREG
001EC4  E84000     INC.B W0, W0
001EC6  B7E836     MOV.B WREG, bufferWptr_uart3
70:                    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
001EC8  BFC836     MOV.B bufferWptr_uart3, WREG
001ECA  B243F0     AND.B #0x3F, W0
001ECC  B7E836     MOV.B WREG, bufferWptr_uart3
71:                }
001ECE  FA8000     ULNK
001ED0  060000     RETURN
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 读环形缓冲区
76:                Input: 数据地址 
77:                Output: 1：读取成功，0：读取失败
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
001ED2  FA0002     LNK #0x2
001ED4  780F00     MOV W0, [W14]
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
001ED6  208331     MOV #0x833, W1
001ED8  784091     MOV.B [W1], W1
001EDA  BFC832     MOV.B bufferWptr_uart1, WREG
001EDC  50CF80     SUB.B W1, W0, [W15]
001EDE  3A0002     BRA NZ, 0x1EE4
81:                        return 0;
001EE0  EB4000     CLR.B W0
001EE2  37000D     BRA 0x1EFE
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
001EE4  BFC833     MOV.B bufferRptr_uart1, WREG
001EE6  FB8000     ZE W0, W0
001EE8  208401     MOV #0x840, W1
001EEA  7840E1     MOV.B [W1+W0], W1
001EEC  78001E     MOV [W14], W0
001EEE  784801     MOV.B W1, [W0]
84:                    bufferRptr_uart1++;
001EF0  BFC833     MOV.B bufferRptr_uart1, WREG
001EF2  E84000     INC.B W0, W0
001EF4  B7E833     MOV.B WREG, bufferRptr_uart1
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
001EF6  BFC833     MOV.B bufferRptr_uart1, WREG
001EF8  B243F0     AND.B #0x3F, W0
001EFA  B7E833     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
001EFC  B3C010     MOV.B #0x1, W0
87:                }
001EFE  FA8000     ULNK
001F00  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 读环形缓冲区
92:                Input: 数据地址 
93:                Output: 1：读取成功，0：读取失败
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
001F02  FA0002     LNK #0x2
001F04  780F00     MOV W0, [W14]
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
001F06  208351     MOV #0x835, W1
001F08  784091     MOV.B [W1], W1
001F0A  BFC834     MOV.B bufferWptr_uart2, WREG
001F0C  50CF80     SUB.B W1, W0, [W15]
001F0E  3A0007     BRA NZ, 0x1F1E
97:                        if (U2STAbits.OERR)
001F10  801190     MOV U2STA, W0
001F12  600062     AND W0, #0x2, W0
001F14  E00000     CP0 W0
001F16  320001     BRA Z, 0x1F1A
98:                            U2STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
001F18  A92232     BCLR U2STA, #1
99:                        return 0;
001F1A  EB4000     CLR.B W0
001F1C  37000D     BRA 0x1F38
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
001F1E  BFC835     MOV.B bufferRptr_uart2, WREG
001F20  FB8000     ZE W0, W0
001F22  208801     MOV #0x880, W1
001F24  7840E1     MOV.B [W1+W0], W1
001F26  78001E     MOV [W14], W0
001F28  784801     MOV.B W1, [W0]
102:                   bufferRptr_uart2++;
001F2A  BFC835     MOV.B bufferRptr_uart2, WREG
001F2C  E84000     INC.B W0, W0
001F2E  B7E835     MOV.B WREG, bufferRptr_uart2
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
001F30  BFC835     MOV.B bufferRptr_uart2, WREG
001F32  B243F0     AND.B #0x3F, W0
001F34  B7E835     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
001F36  B3C010     MOV.B #0x1, W0
106:               }
001F38  FA8000     ULNK
001F3A  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 读环形缓冲区
111:               Input: 数据地址 
112:               Output: 1：读取成功，0：读取失败
113:                *************************************/
114:               bool BufferRead_UART3(uint8_t *data) {
001F3C  FA0002     LNK #0x2
001F3E  780F00     MOV W0, [W14]
115:                   if (bufferRptr_uart3 == bufferWptr_uart3) {
001F40  208371     MOV #0x837, W1
001F42  784091     MOV.B [W1], W1
001F44  BFC836     MOV.B bufferWptr_uart3, WREG
001F46  50CF80     SUB.B W1, W0, [W15]
001F48  3A0007     BRA NZ, 0x1F58
116:                       if (U3STAbits.OERR)
001F4A  801290     MOV U3STA, W0
001F4C  600062     AND W0, #0x2, W0
001F4E  E00000     CP0 W0
001F50  320001     BRA Z, 0x1F54
117:                           U3STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
001F52  A92252     BCLR U3STA, #1
118:                       return 0;
001F54  EB4000     CLR.B W0
001F56  37000D     BRA 0x1F72
119:                   }
120:                   *data = Buffer_uart3[bufferRptr_uart3];
001F58  BFC837     MOV.B bufferRptr_uart3, WREG
001F5A  FB8000     ZE W0, W0
001F5C  208C01     MOV #0x8C0, W1
001F5E  7840E1     MOV.B [W1+W0], W1
001F60  78001E     MOV [W14], W0
001F62  784801     MOV.B W1, [W0]
121:                   bufferRptr_uart3++;
001F64  BFC837     MOV.B bufferRptr_uart3, WREG
001F66  E84000     INC.B W0, W0
001F68  B7E837     MOV.B WREG, bufferRptr_uart3
122:                   bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
001F6A  BFC837     MOV.B bufferRptr_uart3, WREG
001F6C  B243F0     AND.B #0x3F, W0
001F6E  B7E837     MOV.B WREG, bufferRptr_uart3
123:                   //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:                   return 1;
001F70  B3C010     MOV.B #0x1, W0
125:               }
001F72  FA8000     ULNK
001F74  060000     RETURN
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 根据结构体的内容获取有效数据和有效长度
130:               Input: 数据结构体
131:               Output: 是否获取到数据
132:               Notice：字节数不能大于256 取数据的时间可能短   
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//注意
001F76  FA0008     LNK #0x8
001F78  980730     MOV W0, [W14+6]
135:                   bool IsFind = false; //记录字节数
001F7A  EB4000     CLR.B W0
001F7C  784F00     MOV.B W0, [W14]
136:                   uint8_t cnt = 0/*校验寻找循环地址*/, cnt1 = 0/*校验判断循环地址*/, cnt2/*赋值地址*/, /*offset,*/ byte = 0;
001F7E  EB4000     CLR.B W0
001F80  984710     MOV.B W0, [W14+1]
001F82  EB4000     CLR.B W0
001F84  984720     MOV.B W0, [W14+2]
001F86  EB4000     CLR.B W0
001F88  984740     MOV.B W0, [W14+4]
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//如果设置的字节数为0的话，返回错误
001F8A  90003E     MOV [W14+6], W0
001F8C  904060     MOV.B [W0+6], W0
001F8E  E00400     CP0.B W0
001F90  320004     BRA Z, 0x1F9A
001F92  90003E     MOV [W14+6], W0
001F94  904020     MOV.B [W0+2], W0
001F96  E00400     CP0.B W0
001F98  3A0036     BRA NZ, 0x2006
139:                       return false; //为获取
001F9A  EB4000     CLR.B W0
001F9C  3700AD     BRA 0x20F8
140:               
141:                   while (cnt < strcmp->Source_len) {
002006  000000     NOP
002008  90003E     MOV [W14+6], W0
00200A  9040A0     MOV.B [W0+2], W1
00200C  90401E     MOV.B [W14+1], W0
00200E  50CF80     SUB.B W1, W0, [W15]
002010  3EFFC6     BRA GTU, 0x1F9E
002012  370001     BRA 0x2016
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//如果数据==head的话           
001F9E  90003E     MOV [W14+6], W0
001FA0  780090     MOV [W0], W1
001FA2  90401E     MOV.B [W14+1], W0
001FA4  FB8000     ZE W0, W0
001FA6  408000     ADD W1, W0, W0
001FA8  784090     MOV.B [W0], W1
001FAA  90003E     MOV [W14+6], W0
001FAC  900020     MOV [W0+4], W0
001FAE  784010     MOV.B [W0], W0
001FB0  50CF80     SUB.B W1, W0, [W15]
001FB2  3A0022     BRA NZ, 0x1FF8
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//获取帧头的数据长度               
001FB4  B3C010     MOV.B #0x1, W0
001FB6  984720     MOV.B W0, [W14+2]
001FB8  37001A     BRA 0x1FEE
001FE0  90402E     MOV.B [W14+2], W0
001FE2  E84000     INC.B W0, W0
001FE4  984720     MOV.B W0, [W14+2]
001FE6  370003     BRA 0x1FEE
001FEE  90003E     MOV [W14+6], W0
001FF0  9040E0     MOV.B [W0+6], W1
001FF2  90402E     MOV.B [W14+2], W0
001FF4  50CF80     SUB.B W1, W0, [W15]
001FF6  3EFFE1     BRA GTU, 0x1FBA
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//如果获取到数据和帧头一样，那么继续获取数据，反之退出
001FBA  90003E     MOV [W14+6], W0
001FBC  780090     MOV [W0], W1
001FBE  90401E     MOV.B [W14+1], W0
001FC0  FB8100     ZE W0, W2
001FC2  90402E     MOV.B [W14+2], W0
001FC4  FB8000     ZE W0, W0
001FC6  410000     ADD W2, W0, W0
001FC8  408000     ADD W1, W0, W0
001FCA  784090     MOV.B [W0], W1
001FCC  90003E     MOV [W14+6], W0
001FCE  900120     MOV [W0+4], W2
001FD0  90402E     MOV.B [W14+2], W0
001FD2  FB8000     ZE W0, W0
001FD4  410000     ADD W2, W0, W0
001FD6  784010     MOV.B [W0], W0
001FD8  50CF80     SUB.B W1, W0, [W15]
001FDA  3A0006     BRA NZ, 0x1FE8
145:                                   IsFind = true;
001FDC  B3C010     MOV.B #0x1, W0
001FDE  784F00     MOV.B W0, [W14]
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
001FE8  EB4000     CLR.B W0
001FEA  784F00     MOV.B W0, [W14]
149:                                   break;
001FEC  370005     BRA 0x1FF8
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //如果找到数据，退出寻找帧头程序
001FF8  78401E     MOV.B [W14], W0
001FFA  E00400     CP0.B W0
001FFC  3A000B     BRA NZ, 0x2014
002014  000000     NOP
154:                       cnt++; //校验位置加1
001FFE  90401E     MOV.B [W14+1], W0
002000  E84000     INC.B W0, W0
002002  984710     MOV.B W0, [W14+1]
002004  370001     BRA 0x2008
155:                   }
156:               
157:                   if (IsFind) {//如果存在接受的字节数且找到帧头
002016  78401E     MOV.B [W14], W0
002018  E00400     CP0.B W0
00201A  32006A     BRA Z, 0x20F0
158:                       if (strcmp->Get_len < strcmp->Check_len) {
00201C  90003E     MOV [W14+6], W0
00201E  9048A0     MOV.B [W0+10], W1
002020  90003E     MOV [W14+6], W0
002022  904060     MOV.B [W0+6], W0
002024  50CF80     SUB.B W1, W0, [W15]
002026  31001A     BRA C, 0x205C
159:                           byte = strcmp->Get_len; //获取字节小于校验字节,比如只需要校验不需要获取数据
002028  90003E     MOV [W14+6], W0
00202A  9048A0     MOV.B [W0+10], W1
00202C  984741     MOV.B W1, [W14+4]
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //获取帧头数据
00202E  EB4000     CLR.B W0
002030  984730     MOV.B W0, [W14+3]
002032  37000F     BRA 0x2052
00204C  90403E     MOV.B [W14+3], W0
00204E  E84000     INC.B W0, W0
002050  984730     MOV.B W0, [W14+3]
002052  9040BE     MOV.B [W14+3], W1
002054  90404E     MOV.B [W14+4], W0
002056  50CF80     SUB.B W1, W0, [W15]
002058  39FFED     BRA NC, 0x2034
00205A  370045     BRA 0x20E6
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
002034  90003E     MOV [W14+6], W0
002036  9000C0     MOV [W0+8], W1
002038  90403E     MOV.B [W14+3], W0
00203A  FB8000     ZE W0, W0
00203C  408000     ADD W1, W0, W0
00203E  9000BE     MOV [W14+6], W1
002040  900121     MOV [W1+4], W2
002042  9040BE     MOV.B [W14+3], W1
002044  FB8081     ZE W1, W1
002046  410081     ADD W2, W1, W1
002048  784091     MOV.B [W1], W1
00204A  784801     MOV.B W1, [W0]
162:                       } else {//如果要获取的字节数大于帧头数据，需要判断有效的剩余字节数数量
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//如果获取数据大于有效数据，
00205C  90003E     MOV [W14+6], W0
00205E  904020     MOV.B [W0+2], W0
002060  FB8080     ZE W0, W1
002062  90401E     MOV.B [W14+1], W0
002064  FB8000     ZE W0, W0
002066  508080     SUB W1, W0, W1
002068  90003E     MOV [W14+6], W0
00206A  904820     MOV.B [W0+10], W0
00206C  FB8000     ZE W0, W0
00206E  508F80     SUB W1, W0, [W15]
002070  3D0020     BRA GE, 0x20B2
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //获取剩余数据
002072  EB4000     CLR.B W0
002074  984730     MOV.B W0, [W14+3]
002076  370012     BRA 0x209C
002096  90403E     MOV.B [W14+3], W0
002098  E84000     INC.B W0, W0
00209A  984730     MOV.B W0, [W14+3]
00209C  90403E     MOV.B [W14+3], W0
00209E  FB8080     ZE W0, W1
0020A0  90003E     MOV [W14+6], W0
0020A2  904020     MOV.B [W0+2], W0
0020A4  FB8100     ZE W0, W2
0020A6  90401E     MOV.B [W14+1], W0
0020A8  FB8000     ZE W0, W0
0020AA  510000     SUB W2, W0, W0
0020AC  508F80     SUB W1, W0, [W15]
0020AE  35FFE4     BRA LT, 0x2078
0020B0  37001A     BRA 0x20E6
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
002078  90003E     MOV [W14+6], W0
00207A  9000C0     MOV [W0+8], W1
00207C  90403E     MOV.B [W14+3], W0
00207E  FB8000     ZE W0, W0
002080  408000     ADD W1, W0, W0
002082  9000BE     MOV [W14+6], W1
002084  780111     MOV [W1], W2
002086  90409E     MOV.B [W14+1], W1
002088  FB8181     ZE W1, W3
00208A  9040BE     MOV.B [W14+3], W1
00208C  FB8081     ZE W1, W1
00208E  418081     ADD W3, W1, W1
002090  410081     ADD W2, W1, W1
002092  784091     MOV.B [W1], W1
002094  784801     MOV.B W1, [W0]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //获取剩余数据
0020B2  EB4000     CLR.B W0
0020B4  984730     MOV.B W0, [W14+3]
0020B6  370012     BRA 0x20DC
0020D6  90403E     MOV.B [W14+3], W0
0020D8  E84000     INC.B W0, W0
0020DA  984730     MOV.B W0, [W14+3]
0020DC  90003E     MOV [W14+6], W0
0020DE  9048A0     MOV.B [W0+10], W1
0020E0  90403E     MOV.B [W14+3], W0
0020E2  50CF80     SUB.B W1, W0, [W15]
0020E4  31FFE9     BRA C, 0x20B8
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
0020B8  90003E     MOV [W14+6], W0
0020BA  9000C0     MOV [W0+8], W1
0020BC  90403E     MOV.B [W14+3], W0
0020BE  FB8000     ZE W0, W0
0020C0  408000     ADD W1, W0, W0
0020C2  9000BE     MOV [W14+6], W1
0020C4  780111     MOV [W1], W2
0020C6  90409E     MOV.B [W14+1], W1
0020C8  FB8181     ZE W1, W3
0020CA  9040BE     MOV.B [W14+3], W1
0020CC  FB8081     ZE W1, W1
0020CE  418081     ADD W3, W1, W1
0020D0  410081     ADD W2, W1, W1
0020D2  784091     MOV.B [W1], W1
0020D4  784801     MOV.B W1, [W0]
169:                       }
170:                       strcmp->Real_len = cnt2; //实际获取到的长度
0020E6  90003E     MOV [W14+6], W0
0020E8  9040BE     MOV.B [W14+3], W1
0020EA  984831     MOV.B W1, [W0+11]
171:                       return true;
0020EC  B3C010     MOV.B #0x1, W0
0020EE  370004     BRA 0x20F8
172:                   }
173:                   strcmp->Real_len = 0;
0020F0  90003E     MOV [W14+6], W0
0020F2  EB4080     CLR.B W1
0020F4  984831     MOV.B W1, [W0+11]
174:                   return false;
0020F6  EB4000     CLR.B W0
175:               }
0020F8  FA8000     ULNK
0020FA  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 通过指定串口获取函数，获取数据保存至数据地址
180:               Input: UARTn获取函数，获取数据的地址
181:               Output: 字节数
182:               Notice：字节数不能大于256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data, uint8_t bytes) {//, const uint8_t get_size) {//注意'\0'
0020FC  FA0008     LNK #0x8
0020FE  980710     MOV W0, [W14+2]
002100  980721     MOV W1, [W14+4]
002102  984762     MOV.B W2, [W14+6]
185:                   uint8_t byte = 0;
002104  EB4000     CLR.B W0
002106  784F00     MOV.B W0, [W14]
186:                   while (bytes > byte) {
002108  370008     BRA 0x211A
00211A  90406E     MOV.B [W14+6], W0
00211C  504F9E     SUB.B W0, [W14], [W15]
00211E  3EFFF5     BRA GTU, 0x210A
002120  370001     BRA 0x2124
187:                       if (f_uart(Get_Data + byte))
00210A  FB801E     ZE [W14], W0
00210C  9000AE     MOV [W14+4], W1
00210E  408000     ADD W1, W0, W0
002110  90009E     MOV [W14+2], W1
002112  010001     CALL W1
002114  E00400     CP0.B W0
002116  320005     BRA Z, 0x2122
188:                           byte++;
002118  E84F1E     INC.B [W14], [W14]
189:                       else
190:                           break;
002122  000000     NOP
191:                   }
192:                   return byte;
002124  78401E     MOV.B [W14], W0
193:               }
002126  FA8000     ULNK
002128  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 清楚缓冲区数据
198:               Input: 指定清楚的串口
199:               Output: 无
200:               Notice：清楚串口缓冲区
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
00212A  FA0004     LNK #0x4
00212C  980710     MOV W0, [W14+2]
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
00212E  000000     NOP
002130  90009E     MOV [W14+2], W1
002132  78000E     MOV W14, W0
002134  010001     CALL W1
002136  E00400     CP0.B W0
002138  3AFFFB     BRA NZ, 0x2130
205:               }
00213A  FA8000     ULNK
206:               //将UARTGetData和
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //临时变量
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/PC.c  ---------------------------------------
1:                 //#include "pc.h"
2:                 #include "includes.h"
3:                 
4:                 void PCCop_Init(void)
5:                 {
002E18  FA0000     LNK #0x0
6:                     RS485_Init();
002E1A  07FE1D     RCALL RS485_Init
7:                 }
002E1C  FA8000     ULNK
002E1E  060000     RETURN
8:                 
9:                 
10:                void PCCopTask(void*arg) {
002E20  FA0002     LNK #0x2
002E22  780F00     MOV W0, [W14]
11:                
12:                    while (1) {
13:                        RS485SendChar(0x31);
002E24  B3C310     MOV.B #0x31, W0
002E26  07FE28     RCALL RS485SendChar
14:                        //        RS485SendString("ErrCode:\r\n", 10);
15:                //        OSTimeDlyHMSM(0, 0, 1, 0);
16:                //        Delay_1S(1);
17:                    }
002E28  37FFFD     BRA 0x2E24
18:                }
19:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/HL6528.c  -----------------------------------
1:                 #include "HL6528.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 #include <stdlib.h>
5:                 #include  <libq.h>
6:                 #include "WGC.h"
7:                 #include "Common.h"
8:                 //#include "includes.h"
9:                 //#include <stdbool.h>
10:                //#include "cJSON.h"
11:                
12:                
13:                //extern OS_EVENT* sem1, *sem2; //上线拨号任务标志
14:                
15:                //struct ATCommand {
16:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
17:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
18:                const uint8_t AT[] = {"AT\r\n"};
19:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
20:                const uint8_t OK[] = {"OK"};
21:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
22:                const uint8_t READY[] = {"+CPIN: READY"};
23:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
24:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
25:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
26:                const uint8_t _5[] = {",5"};
27:                const uint8_t _1[] = {",1"};
28:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
29:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
30:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
31:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
32:                uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.140.140\",11811\r\n\n"};
33:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
34:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//移动ONENET
35:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
36:                const uint8_t CONNECT[] = {"CONNECT"};
37:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
38:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
39:                
40:                
41:                //static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
42:                
43:                void HL6528_Init(void) {
00213E  FA0000     LNK #0x0
44:                    //初始化端口
45:                    PWRON_TRIS = 0; //PWN_ON 6528芯片电源控制
002140  A9C2D8     BCLR TRISD, #6
46:                    PWR_TRIS = 0; //外部控制6528芯片电源
002142  A9E2D8     BCLR TRISD, #7
47:                    DSR_TRIS = 0; //数据设备请求    
002144  A922D8     BCLR TRISD, #1
48:                    DTR_TRIS = 0; //数据终端请求
002146  A902D8     BCLR TRISD, #0
49:                    RTS_TRIS = 0; //请求发送数据
002148  A982D8     BCLR TRISD, #4
50:                    CTS_TRIS = 0; //请求接受数据  
00214A  A9A2D8     BCLR TRISD, #5
51:                    PWR = 0;
00214C  A9E2DC     BCLR LATD, #7
52:                    PWRON = 0;
00214E  A9C2DC     BCLR LATD, #6
53:                    CTS = 0;
002150  A9A2DC     BCLR LATD, #5
54:                    RTS = 0;
002152  A982DC     BCLR LATD, #4
55:                    DSR = 0;
002154  A922DC     BCLR LATD, #1
56:                    DTR = 0;
002156  A902DC     BCLR LATD, #0
57:                    //    UART2_Init();
58:                }
002158  FA8000     ULNK
00215A  060000     RETURN
59:                
60:                /*输入变量：发送字符串地址ss、接受字符串、接受字符串长度、发送字符串长度、对比字符串地址、对比字符串长度、发送间隔时间、发送次数**/
61:                static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
00215C  FA0048     LNK #0x48
00215E  982700     MOV W0, [W14+64]
002160  982711     MOV W1, [W14+66]
002162  982722     MOV W2, [W14+68]
002164  98C763     MOV.B W3, [W14+70]
002166  98C774     MOV.B W4, [W14+71]
62:                    uint8_t cnt_tmp = 0;
002168  EB4000     CLR.B W0
00216A  784F00     MOV.B W0, [W14]
63:                    bool b_sta = false;
00216C  EB4000     CLR.B W0
00216E  984710     MOV.B W0, [W14+1]
64:                    StrCmp stcp;
65:                    uint8_t tmp[50];
66:                    do {
67:                        cnt_tmp += 1;
002170  E84F1E     INC.B [W14], [W14]
68:                        UART2_SendString(ss); //发送AT指令                               
002172  90200E     MOV [W14+64], W0
002174  0703BC     RCALL UART2_SendString
69:                        Delays(3); //(0, 0, 3, 0); //延时1s
002176  B3C030     MOV.B #0x3, W0
002178  07FDAF     RCALL Delays
70:                        U2Rx4Byte();
00217A  0703EF     RCALL U2Rx4Byte
71:                        stcp.SourceData = tmp;
00217C  47006E     ADD W14, #0xE, W0
00217E  980710     MOV W0, [W14+2]
72:                        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 50); //获取mark
002180  90001E     MOV [W14+2], W0
002182  B3C322     MOV.B #0x32, W2
002184  780080     MOV W0, W1
002186  21F020     MOV #0x1F02, W0
002188  07FFB9     RCALL UARTGetData
00218A  984740     MOV.B W0, [W14+4]
73:                        stcp.CheckData = (uint8_t*) cs;
00218C  90209E     MOV [W14+66], W1
00218E  980731     MOV W1, [W14+6]
74:                        stcp.Check_len = csl;
002190  90C0EE     MOV.B [W14+70], W1
002192  984F01     MOV.B W1, [W14+8]
75:                        stcp.GetData = NULL;
002194  EB0000     CLR W0
002196  980750     MOV W0, [W14+10]
76:                        stcp.Get_len = 0;
002198  EB4000     CLR.B W0
00219A  984F40     MOV.B W0, [W14+12]
77:                        stcp.Real_len = 0;
00219C  EB4000     CLR.B W0
00219E  984F50     MOV.B W0, [W14+13]
78:                
79:                        if (UARTDataIsRight(&stcp)) {
0021A0  E8800E     INC2 W14, W0
0021A2  07FEE9     RCALL UARTDataIsRight
0021A4  E00400     CP0.B W0
0021A6  320003     BRA Z, 0x21AE
80:                            b_sta = true;
0021A8  B3C010     MOV.B #0x1, W0
0021AA  984710     MOV.B W0, [W14+1]
81:                            break;
0021AC  37000F     BRA 0x21CC
82:                        }
83:                
84:                        if (cs1 != NULL) {//如果第二个校验数据不是NULL，那么进行第二个数据头的处理，判断处理。
0021AE  90202E     MOV [W14+68], W0
0021B0  E00000     CP0 W0
0021B2  320009     BRA Z, 0x21C6
85:                            stcp.CheckData = (uint8_t*) cs1;
0021B4  9020AE     MOV [W14+68], W1
0021B6  980731     MOV W1, [W14+6]
86:                            if (UARTDataIsRight(&stcp)) {
0021B8  E8800E     INC2 W14, W0
0021BA  07FEDD     RCALL UARTDataIsRight
0021BC  E00400     CP0.B W0
0021BE  320003     BRA Z, 0x21C6
87:                                b_sta = true;
0021C0  B3C010     MOV.B #0x1, W0
0021C2  984710     MOV.B W0, [W14+1]
88:                                break;
0021C4  370003     BRA 0x21CC
89:                            }
90:                        }
91:                
92:                    } while (cnt > cnt_tmp);
0021C6  90C07E     MOV.B [W14+71], W0
0021C8  504F9E     SUB.B W0, [W14], [W15]
0021CA  3EFFD2     BRA GTU, 0x2170
93:                    ClearBuffer(BufferRead_UART2);
0021CC  21F020     MOV #0x1F02, W0
0021CE  07FFAD     RCALL ClearBuffer
94:                    return b_sta;
0021D0  90401E     MOV.B [W14+1], W0
95:                }
0021D2  FA8000     ULNK
0021D4  060000     RETURN
96:                
97:                bool HL6528_DialingIsERR(void) {
0021D6  FA001A     LNK #0x1A
98:                    uint8_t sta;
99:                    uint8_t ip_port[25] = {'\0'};
0021D8  4700E1     ADD W14, #0x1, W1
0021DA  090018     REPEAT #0x18
0021DC  EB5880     CLR.B [W1++]
100:               
101:                   //    HL6528_GetIP_Port();
102:                   PWR = 1;
0021DE  A8E2DC     BSET LATD, #7
103:                   PWRON = 1;
0021E0  A8C2DC     BSET LATD, #6
104:                   CTS = 0;
0021E2  A9A2DC     BCLR LATD, #5
105:                   RTS = 0;
0021E4  A982DC     BCLR LATD, #4
106:                   DSR = 0;
0021E6  A922DC     BCLR LATD, #1
107:                   DTR = 0;
0021E8  A902DC     BCLR LATD, #0
108:                   Delays(1); 
0021EA  B3C010     MOV.B #0x1, W0
0021EC  07FD75     RCALL Delays
109:                   if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
0021EE  B3C024     MOV.B #0x2, W4
0021F0  B3C023     MOV.B #0x2, W3
0021F2  EB0100     CLR W2
0021F4  28EE51     MOV #0x8EE5, W1
0021F6  28ECC0     MOV #0x8ECC, W0
0021F8  07FFB1     RCALL _HL6528SendCmd
0021FA  E00400     CP0.B W0
0021FC  32003A     BRA Z, 0x2272
110:                       if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
0021FE  B3C024     MOV.B #0x2, W4
002200  B3C083     MOV.B #0x8, W3
002202  EB0100     CLR W2
002204  28EF31     MOV #0x8EF3, W1
002206  28EE80     MOV #0x8EE8, W0
002208  07FFA9     RCALL _HL6528SendCmd
00220A  E00400     CP0.B W0
00220C  32002F     BRA Z, 0x226C
111:                           if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//设置网络模式
00220E  B3C0A4     MOV.B #0xA, W4
002210  B3C023     MOV.B #0x2, W3
002212  28F242     MOV #0x8F24, W2
002214  28F211     MOV #0x8F21, W1
002216  28F0A0     MOV #0x8F0A, W0
002218  07FFA1     RCALL _HL6528SendCmd
00221A  E00400     CP0.B W0
00221C  320024     BRA Z, 0x2266
112:                               if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
00221E  B3C034     MOV.B #0x3, W4
002220  B3C023     MOV.B #0x2, W3
002222  EB0100     CLR W2
002224  28EE51     MOV #0x8EE5, W1
002226  28F310     MOV #0x8F31, W0
002228  07FF99     RCALL _HL6528SendCmd
00222A  E00400     CP0.B W0
00222C  320019     BRA Z, 0x2260
113:                                   //                    HL6528_GetIP_Port(); //刷新IP地址和端口号
114:                                   if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
00222E  B3C034     MOV.B #0x3, W4
002230  B3C023     MOV.B #0x2, W3
002232  EB0100     CLR W2
002234  28EE51     MOV #0x8EE5, W1
002236  209000     MOV #0x900, W0
002238  07FF91     RCALL _HL6528SendCmd
00223A  E00400     CP0.B W0
00223C  32000E     BRA Z, 0x225A
115:                                       if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 7, 5)) {
00223E  B3C054     MOV.B #0x5, W4
002240  B3C073     MOV.B #0x7, W3
002242  EB0100     CLR W2
002244  28F8D1     MOV #0x8F8D, W1
002246  28F7C0     MOV #0x8F7C, W0
002248  07FF89     RCALL _HL6528SendCmd
00224A  E00400     CP0.B W0
00224C  320003     BRA Z, 0x2254
116:                                           sta = 0;
00224E  EB4000     CLR.B W0
002250  784F00     MOV.B W0, [W14]
002252  370011     BRA 0x2276
117:                                       } else
118:                                           sta = 6; //未开启TCP，
002254  B3C060     MOV.B #0x6, W0
002256  784F00     MOV.B W0, [W14]
002258  37000E     BRA 0x2276
119:                                   } else
120:                                       sta = 5; //设置TCP失败
00225A  B3C050     MOV.B #0x5, W0
00225C  784F00     MOV.B W0, [W14]
00225E  37000B     BRA 0x2276
121:                               } else
122:                                   sta = 4; //设置APN的问题
002260  B3C040     MOV.B #0x4, W0
002262  784F00     MOV.B W0, [W14]
002264  370008     BRA 0x2276
123:                           } else
124:                               sta = 3; //手机信号未找到
002266  B3C030     MOV.B #0x3, W0
002268  784F00     MOV.B W0, [W14]
00226A  370005     BRA 0x2276
125:                       } else
126:                           sta = 2; //手机卡未插入
00226C  B3C020     MOV.B #0x2, W0
00226E  784F00     MOV.B W0, [W14]
002270  370002     BRA 0x2276
127:                   } else
128:                       sta = 1; //模块损坏
002272  B3C010     MOV.B #0x1, W0
002274  784F00     MOV.B W0, [W14]
129:                   return sta;
002276  FB801E     ZE [W14], W0
002278  EA0000     NEG W0, W0
00227A  DE004F     LSR W0, #15, W0
00227C  784000     MOV.B W0, W0
130:               }
00227E  FA8000     ULNK
002280  060000     RETURN
131:               
132:               void HL6528_Close(void) {
002282  FA0020     LNK #0x20
133:                   uint8_t tmp[20];
134:                   StrCmp stcp;
135:                   ClearBuffer(BufferRead_UART2);
002284  21F020     MOV #0x1F02, W0
002286  07FF51     RCALL ClearBuffer
136:                   do {
137:                       DSR = 1; //切换数据至AT命令
002288  A822DC     BSET LATD, #1
138:                       Delays(1);  //(0, 0, 1, 0); //延时1s
00228A  B3C010     MOV.B #0x1, W0
00228C  07FD25     RCALL Delays
139:                       DSR = 0; //请求发送数据
00228E  A922DC     BCLR LATD, #1
140:                       stcp.SourceData = tmp;
002290  980F2E     MOV W14, [W14+20]
141:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData,20); //获取mark
002292  90082E     MOV [W14+20], W0
002294  B3C142     MOV.B #0x14, W2
002296  780080     MOV W0, W1
002298  21F020     MOV #0x1F02, W0
00229A  07FF30     RCALL UARTGetData
00229C  985760     MOV.B W0, [W14+22]
142:                       stcp.CheckData = (uint8_t*) OK;
00229E  28EE50     MOV #0x8EE5, W0
0022A0  980F40     MOV W0, [W14+24]
143:                       stcp.Check_len = 2;
0022A2  B3C020     MOV.B #0x2, W0
0022A4  985F20     MOV.B W0, [W14+26]
144:                       stcp.GetData = NULL;
0022A6  EB0000     CLR W0
0022A8  980F60     MOV W0, [W14+28]
145:                       stcp.Get_len = 0;
0022AA  EB4000     CLR.B W0
0022AC  985F60     MOV.B W0, [W14+30]
146:                       stcp.Real_len = 0;
0022AE  EB4000     CLR.B W0
0022B0  985F70     MOV.B W0, [W14+31]
147:                   } while (UARTDataIsRight(&stcp)); //等待接受成功下线返回OK
0022B2  470074     ADD W14, #0x14, W0
0022B4  07FE60     RCALL UARTDataIsRight
0022B6  E00400     CP0.B W0
0022B8  3AFFE7     BRA NZ, 0x2288
148:                   if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//关闭并删除TCP的ID通道
0022BA  B3C024     MOV.B #0x2, W4
0022BC  B3C023     MOV.B #0x2, W3
0022BE  EB0100     CLR W2
0022C0  28EE51     MOV #0x8EE5, W1
0022C2  28F950     MOV #0x8F95, W0
0022C4  07FF4B     RCALL _HL6528SendCmd
0022C6  E00400     CP0.B W0
0022C8  320006     BRA Z, 0x22D6
149:                       HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
0022CA  B3C024     MOV.B #0x2, W4
0022CC  B3C023     MOV.B #0x2, W3
0022CE  EB0100     CLR W2
0022D0  28EE51     MOV #0x8EE5, W1
0022D2  28FA80     MOV #0x8FA8, W0
0022D4  07FF43     RCALL _HL6528SendCmd
150:                   Delays(1); // (0, 0, 1, 0); //延时1s    
0022D6  B3C010     MOV.B #0x1, W0
0022D8  07FCFF     RCALL Delays
151:                   PWR = 0; //电源控制
0022DA  A9E2DC     BCLR LATD, #7
152:                   PWRON = 0; //电源关闭
0022DC  A9C2DC     BCLR LATD, #6
153:                   CTS = 0; //请求接受
0022DE  A9A2DC     BCLR LATD, #5
154:                   RTS = 0; //请求发送
0022E0  A982DC     BCLR LATD, #4
155:                   DSR = 0; //设备
0022E2  A922DC     BCLR LATD, #1
156:                   DTR = 0; //终端
0022E4  A902DC     BCLR LATD, #0
157:                   UART2_Close();
0022E6  0702F1     RCALL UART2_Close
158:               }
0022E8  FA8000     ULNK
0022EA  060000     RETURN
159:               
160:               
161:               
162:               //static void HL6528_IOStart(void) {
163:               //    PWR = 1;
164:               //    PWRON = 1;
165:               //    CTS = 0;
166:               //    RTS = 0;
167:               //    DSR = 0;
168:               //    DTR = 0;
169:               //}
170:               //
171:               //static void HL6528_IOClose(void) {
172:               //    PWRON = 0;
173:               //    PWR = 0;
174:               //    CTS = 1;
175:               //    RTS = 1;
176:               //    DSR = 1;
177:               //    DTR = 1;
178:               //}
179:               
180:               void HL6528_GetIP_Port(void) {
0022EC  FA0020     LNK #0x20
181:                   uint8_t net_addr[25] = {'\0'};
0022EE  4700E2     ADD W14, #0x2, W1
0022F0  09000B     REPEAT #0xB
0022F2  EB1880     CLR [W1++]
0022F4  EB5880     CLR.B [W1++]
182:                   uint8_t str_tmp[4] = {1, 2, 3, 4};
0022F6  47017B     ADD W14, #0x1B, W2
0022F8  28FB71     MOV #0x8FB7, W1
0022FA  090003     REPEAT #0x3
0022FC  785931     MOV.B [W1++], [W2++]
183:                   uint8_t cnt;
184:                   uint8_t all_bytes = 0;
0022FE  EB4000     CLR.B W0
002300  984710     MOV.B W0, [W14+1]
185:               
186:                   //获取网络地址
187:                   all_bytes = my_itoa(WGCIPbits.IP3, net_addr);
002302  BFC817     MOV.B 0x817, WREG
002304  FB8000     ZE W0, W0
002306  E8808E     INC2 W14, W1
002308  07FD4A     RCALL my_itoa
00230A  984710     MOV.B W0, [W14+1]
188:                   net_addr[all_bytes] = '.';
00230C  90401E     MOV.B [W14+1], W0
00230E  FB8000     ZE W0, W0
002310  470000     ADD W14, W0, W0
002312  B3C2E1     MOV.B #0x2E, W1
002314  984021     MOV.B W1, [W0+2]
189:                   net_addr[all_bytes + 1] = '\0';
002316  90401E     MOV.B [W14+1], W0
002318  FB8000     ZE W0, W0
00231A  E80000     INC W0, W0
00231C  470000     ADD W14, W0, W0
00231E  EB4080     CLR.B W1
002320  984021     MOV.B W1, [W0+2]
190:                   all_bytes = all_bytes + 1;
002322  90401E     MOV.B [W14+1], W0
002324  E84000     INC.B W0, W0
002326  984710     MOV.B W0, [W14+1]
191:               
192:                   all_bytes += my_itoa(WGCIPbits.IP2, str_tmp);
002328  BFC816     MOV.B 0x816, WREG
00232A  FB8000     ZE W0, W0
00232C  4700FB     ADD W14, #0x1B, W1
00232E  07FD37     RCALL my_itoa
002330  90409E     MOV.B [W14+1], W1
002332  40C000     ADD.B W1, W0, W0
002334  984710     MOV.B W0, [W14+1]
193:                   strcat(net_addr, str_tmp);
002336  4700FB     ADD W14, #0x1B, W1
002338  E8800E     INC2 W14, W0
00233A  07F5B4     RCALL 0xEA4
194:                   net_addr[all_bytes ] = '.';
00233C  90401E     MOV.B [W14+1], W0
00233E  FB8000     ZE W0, W0
002340  470000     ADD W14, W0, W0
002342  B3C2E1     MOV.B #0x2E, W1
002344  984021     MOV.B W1, [W0+2]
195:                   net_addr[ all_bytes + 1] = '\0';
002346  90401E     MOV.B [W14+1], W0
002348  FB8000     ZE W0, W0
00234A  E80000     INC W0, W0
00234C  470000     ADD W14, W0, W0
00234E  EB4080     CLR.B W1
002350  984021     MOV.B W1, [W0+2]
196:                   all_bytes = all_bytes + 1;
002352  90401E     MOV.B [W14+1], W0
002354  E84000     INC.B W0, W0
002356  984710     MOV.B W0, [W14+1]
197:               
198:                   all_bytes += my_itoa(WGCIPbits.IP1, str_tmp);
002358  BFC815     MOV.B 0x815, WREG
00235A  FB8000     ZE W0, W0
00235C  4700FB     ADD W14, #0x1B, W1
00235E  07FD1F     RCALL my_itoa
002360  90409E     MOV.B [W14+1], W1
002362  40C000     ADD.B W1, W0, W0
002364  984710     MOV.B W0, [W14+1]
199:                   strcat(net_addr, str_tmp);
002366  4700FB     ADD W14, #0x1B, W1
002368  E8800E     INC2 W14, W0
00236A  07F59C     RCALL 0xEA4
200:                   net_addr[all_bytes ] = '.';
00236C  90401E     MOV.B [W14+1], W0
00236E  FB8000     ZE W0, W0
002370  470000     ADD W14, W0, W0
002372  B3C2E1     MOV.B #0x2E, W1
002374  984021     MOV.B W1, [W0+2]
201:                   net_addr[ all_bytes + 1] = '\0';
002376  90401E     MOV.B [W14+1], W0
002378  FB8000     ZE W0, W0
00237A  E80000     INC W0, W0
00237C  470000     ADD W14, W0, W0
00237E  EB4080     CLR.B W1
002380  984021     MOV.B W1, [W0+2]
202:                   all_bytes = all_bytes + 1;
002382  90401E     MOV.B [W14+1], W0
002384  E84000     INC.B W0, W0
002386  984710     MOV.B W0, [W14+1]
203:               
204:                   all_bytes += my_itoa(WGCIPbits.IP0, str_tmp);
002388  BFC814     MOV.B WGCIPbits, WREG
00238A  FB8000     ZE W0, W0
00238C  4700FB     ADD W14, #0x1B, W1
00238E  07FD07     RCALL my_itoa
002390  90409E     MOV.B [W14+1], W1
002392  40C000     ADD.B W1, W0, W0
002394  984710     MOV.B W0, [W14+1]
205:                   strcat(net_addr, str_tmp);
002396  4700FB     ADD W14, #0x1B, W1
002398  E8800E     INC2 W14, W0
00239A  07F584     RCALL 0xEA4
206:                   net_addr[ all_bytes ] = '"';
00239C  90401E     MOV.B [W14+1], W0
00239E  FB8000     ZE W0, W0
0023A0  470000     ADD W14, W0, W0
0023A2  B3C221     MOV.B #0x22, W1
0023A4  984021     MOV.B W1, [W0+2]
207:                   net_addr[all_bytes + 1 ] = ',';
0023A6  90401E     MOV.B [W14+1], W0
0023A8  FB8000     ZE W0, W0
0023AA  E80000     INC W0, W0
0023AC  470000     ADD W14, W0, W0
0023AE  B3C2C1     MOV.B #0x2C, W1
0023B0  984021     MOV.B W1, [W0+2]
208:                   net_addr[ all_bytes + 2] = '\0';
0023B2  90401E     MOV.B [W14+1], W0
0023B4  FB8000     ZE W0, W0
0023B6  E88000     INC2 W0, W0
0023B8  470000     ADD W14, W0, W0
0023BA  EB4080     CLR.B W1
0023BC  984021     MOV.B W1, [W0+2]
209:                   all_bytes = all_bytes + 2;
0023BE  90401E     MOV.B [W14+1], W0
0023C0  E8C000     INC2.B W0, W0
0023C2  984710     MOV.B W0, [W14+1]
210:               
211:                   all_bytes += my_itoa(WGCPORT, str_tmp);
0023C4  8040C0     MOV WGCPORT, W0
0023C6  4700FB     ADD W14, #0x1B, W1
0023C8  07FCEA     RCALL my_itoa
0023CA  90409E     MOV.B [W14+1], W1
0023CC  40C000     ADD.B W1, W0, W0
0023CE  984710     MOV.B W0, [W14+1]
212:                   strcat(net_addr, str_tmp);
0023D0  4700FB     ADD W14, #0x1B, W1
0023D2  E8800E     INC2 W14, W0
0023D4  07F567     RCALL 0xEA4
213:                   net_addr[ all_bytes ] = '\r';
0023D6  90401E     MOV.B [W14+1], W0
0023D8  FB8000     ZE W0, W0
0023DA  470000     ADD W14, W0, W0
0023DC  B3C0D1     MOV.B #0xD, W1
0023DE  984021     MOV.B W1, [W0+2]
214:                   net_addr[ all_bytes + 1] = '\n';
0023E0  90401E     MOV.B [W14+1], W0
0023E2  FB8000     ZE W0, W0
0023E4  E80000     INC W0, W0
0023E6  470000     ADD W14, W0, W0
0023E8  B3C0A1     MOV.B #0xA, W1
0023EA  984021     MOV.B W1, [W0+2]
215:                   net_addr[ all_bytes + 2] = '\0';
0023EC  90401E     MOV.B [W14+1], W0
0023EE  FB8000     ZE W0, W0
0023F0  E88000     INC2 W0, W0
0023F2  470000     ADD W14, W0, W0
0023F4  EB4080     CLR.B W1
0023F6  984021     MOV.B W1, [W0+2]
216:                   all_bytes = all_bytes + 2;
0023F8  90401E     MOV.B [W14+1], W0
0023FA  E8C000     INC2.B W0, W0
0023FC  984710     MOV.B W0, [W14+1]
217:                   //   uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
218:                   for (cnt = 0; cnt < all_bytes; cnt++)
0023FE  EB4000     CLR.B W0
002400  784F00     MOV.B W0, [W14]
002402  37000A     BRA 0x2418
002416  E84F1E     INC.B [W14], [W14]
002418  90401E     MOV.B [W14+1], W0
00241A  78409E     MOV.B [W14], W1
00241C  50CF80     SUB.B W1, W0, [W15]
00241E  39FFF2     BRA NC, 0x2404
219:                       *(KTCPCFG1 + 16 + cnt) = *(net_addr + cnt);
002404  FB801E     ZE [W14], W0
002406  4000F0     ADD W0, #0x10, W1
002408  209000     MOV #0x900, W0
00240A  408000     ADD W1, W0, W0
00240C  FB809E     ZE [W14], W1
00240E  E8810E     INC2 W14, W2
002410  410081     ADD W2, W1, W1
002412  784091     MOV.B [W1], W1
002414  784801     MOV.B W1, [W0]
220:                   //    return all_bytes;
221:               }
002420  FA8000     ULNK
222:               
223:               
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/E41.c  --------------------------------------
1:                 #include "E41.h"
2:                 
3:                 #define M0_TRIS TRISEbits.TRISE5
4:                 #define M1_TRIS TRISEbits.TRISE6
5:                 #define M0 LATEbits.LATE5
6:                 #define M1 LATEbits.LATE6
7:                 #define M0_PORT PORTEbits.RE5
8:                 #define M1_PORT PORTEbits.RE6
9:                 #define AUX PORTFbits.RF6
10:                
11:                #define WORK 0
12:                #define WAKE 1
13:                #define LOWPOWER 2
14:                #define SLEEP 3
15:                uint8_t E41_Arg[] = {0xC0, 0xff, 0xff, 0x18, 0x1, 0xfc};
16:                // FF FF 18 01 9C
17:                //static ADDBITS E41_ADD;
18:                //static ARG1BITS E41_ARG1;
19:                //static ARG2BITS E41_ARG2;
20:                
21:                /*
22:                模式切换和 AUX：在低功耗应用中，用户单片机可能需要切换工作模式，从而达到休眠、无线唤醒的目的。此时，
23:                AUX 引脚将起到关键作用。表现在如下几个方面：
24:                a) 复位后，模块自检期间 AUX 处理低电平，AUX 上升沿后，模块才开始?入工作状态。
25:                b) 从模式 3 切换到其他模式后，模块也会产生自检，AUX 逡辑状态等同于复位。
26:                c) 模式切换前，如果 AUX 是高电平，可以直接改发 M1M0 切换到新模式，2ms 生效。
27:                d) 模式切换前，如果 AUX 是低电平，可以直接改发 M1M0 切换到新模式，AUX 上升沿后 2ms 生效。
28:                 */
29:                static void E41_SetMode(uint8_t mode) {
00267C  FA0002     LNK #0x2
00267E  784F00     MOV.B W0, [W14]
30:                    //获取当前的模式
31:                    //    uint8_t now_mode = M0_PORT + (M1_PORT << 1);//mark
32:                    //设置当前模式
33:                    //    switch (mode) {
34:                    //        case SLEEP:
35:                    //        {
36:                    INT0_Close(); //关闭串口，避免切换模式导致错误接受
002680  070395     RCALL INT0_Close
37:                    M0 = 0;
002682  A9A2E4     BCLR LATE, #5
38:                    M1 = 0; //避免自检程序
002684  A9C2E4     BCLR LATE, #6
39:                    Delayms(300); //(0, 0, 0, 250);
002686  2012C0     MOV #0x12C, W0
002688  07FABD     RCALL Delayms
40:                    M0 = mode & 0x01;
00268A  78409E     MOV.B [W14], W1
00268C  60C061     AND.B W1, #0x1, W0
00268E  604061     AND.B W0, #0x1, W0
002690  604061     AND.B W0, #0x1, W0
002692  FB8000     ZE W0, W0
002694  600061     AND W0, #0x1, W0
002696  DD0045     SL W0, #5, W0
002698  801721     MOV LATE, W1
00269A  A15001     BCLR W1, #5
00269C  700001     IOR W0, W1, W0
00269E  881720     MOV W0, LATE
41:                    M1 = (mode >> 1) & 0x01;
0026A0  FB801E     ZE [W14], W0
0026A2  D10000     LSR W0, W0
0026A4  784000     MOV.B W0, W0
0026A6  604061     AND.B W0, #0x1, W0
0026A8  604061     AND.B W0, #0x1, W0
0026AA  604061     AND.B W0, #0x1, W0
0026AC  FB8000     ZE W0, W0
0026AE  600061     AND W0, #0x1, W0
0026B0  DD0046     SL W0, #6, W0
0026B2  801721     MOV LATE, W1
0026B4  A16001     BCLR W1, #6
0026B6  700001     IOR W0, W1, W0
0026B8  881720     MOV W0, LATE
42:                    Delayms(10); //(0, 0, 0, 10);
0026BA  2000A0     MOV #0xA, W0
0026BC  07FAA3     RCALL Delayms
43:                    INT0_Open();
0026BE  070371     RCALL INT0_Open
44:                    //            break;
45:                    //        }
46:                    //        case LOWPOWER:
47:                    //        {
48:                    //            break;
49:                    //        }
50:                    //        case WAKE:
51:                    //        {
52:                    //            break;
53:                    //        }
54:                    //        case WORK:
55:                    //        {
56:                    //            break;
57:                }
0026C0  FA8000     ULNK
0026C2  060000     RETURN
58:                //            M0 = mode & 0x01;
59:                //            M1 = (mode >> 1) & 0x01;
60:                //}
61:                //}
62:                
63:                void E41_Init(void) {
0026C4  FA0002     LNK #0x2
64:                    uint8_t cnt;
65:                    M0_TRIS = 0; //设置引脚
0026C6  A9A2E0     BCLR TRISE, #5
66:                    M1_TRIS = 0;
0026C8  A9C2E0     BCLR TRISE, #6
67:                    //    uint8_t currentMode = E41_SetGetMode(10);
68:                    E41_SetMode(SLEEP);
0026CA  B3C030     MOV.B #0x3, W0
0026CC  07FFD7     RCALL _E41_SetMode
69:                    Delayms(300); //(0, 0, 0, 300); //必须加 300ms 避开自检
0026CE  2012C0     MOV #0x12C, W0
0026D0  07FA99     RCALL Delayms
70:                    //    UART3_SendChar(0xC0);
71:                    for (cnt = 0; cnt < 3; cnt++) {
0026D2  EB4000     CLR.B W0
0026D4  784F00     MOV.B W0, [W14]
0026D6  370006     BRA 0x26E4
0026E2  E84F1E     INC.B [W14], [W14]
0026E4  78401E     MOV.B [W14], W0
0026E6  504FE2     SUB.B W0, #0x2, [W15]
0026E8  36FFF7     BRA LEU, 0x26D8
72:                        UART3_SendString(E41_Arg, 6);
0026D8  B3C061     MOV.B #0x6, W1
0026DA  209400     MOV #0x940, W0
0026DC  070189     RCALL UART3_SendString
73:                        //    UART3_SendString(E41_Arg, 6);
74:                        Delayms(10);
0026DE  2000A0     MOV #0xA, W0
0026E0  07FA91     RCALL Delayms
75:                        (0, 0, 0, 10);
76:                    }
77:                    //    E41_SetMode(LOWPOWER); //设置为低功耗模式
78:                    //    E41_SetMode(WORK); //设置为唤醒模式   
79:                    E41_SetMode(WAKE); //设置为唤醒模式   
0026EA  B3C010     MOV.B #0x1, W0
0026EC  07FFC7     RCALL _E41_SetMode
80:                }
0026EE  FA8000     ULNK
0026F0  060000     RETURN
81:                
82:                bool E41_PressureIsGet(float* pres) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
0026F2  FA004E     LNK #0x4E
0026F4  982760     MOV W0, [W14+76]
83:                    //判断接受到数据类型是仪表还是压力值
84:                    uint8_t tmp[10];
85:                    uint8_t Head[3] = {0x1, 0x3, 0x4};
0026F6  B3C010     MOV.B #0x1, W0
0026F8  984F20     MOV.B W0, [W14+10]
0026FA  B3C030     MOV.B #0x3, W0
0026FC  984F30     MOV.B W0, [W14+11]
0026FE  B3C040     MOV.B #0x4, W0
002700  984F40     MOV.B W0, [W14+12]
86:                    U3Rx4Byte();
002702  07019A     RCALL U3Rx4Byte
87:                    StrCmp stcp;
88:                    uint8_t Source_tmp[50]; //临时变量
89:                
90:                    stcp.Source_len = UARTGetData(BufferRead_UART3, Source_tmp, 10);
002704  47007A     ADD W14, #0x1A, W0
002706  B3C0A2     MOV.B #0xA, W2
002708  780080     MOV W0, W1
00270A  21F3C0     MOV #0x1F3C, W0
00270C  07FCF7     RCALL UARTGetData
00270E  985700     MOV.B W0, [W14+16]
91:                    if (stcp.Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
002710  90508E     MOV.B [W14+16], W1
002712  B3C320     MOV.B #0x32, W0
002714  50CF80     SUB.B W1, W0, [W15]
002716  360002     BRA LEU, 0x271C
92:                        stcp.Source_len = 50;
002718  B3C320     MOV.B #0x32, W0
00271A  985700     MOV.B W0, [W14+16]
93:                    stcp.SourceData = Source_tmp;
00271C  47007A     ADD W14, #0x1A, W0
00271E  980770     MOV W0, [W14+14]
94:                    stcp.CheckData = Head;
002720  47006A     ADD W14, #0xA, W0
002722  980F10     MOV W0, [W14+18]
95:                    stcp.Check_len = 3;
002724  B3C030     MOV.B #0x3, W0
002726  985740     MOV.B W0, [W14+20]
96:                    stcp.GetData = tmp;
002728  980F3E     MOV W14, [W14+22]
97:                    stcp.Get_len = 8;
00272A  B3C080     MOV.B #0x8, W0
00272C  985F00     MOV.B W0, [W14+24]
98:                    stcp.Real_len = 0;
00272E  EB4000     CLR.B W0
002730  985F10     MOV.B W0, [W14+25]
99:                    UARTDataIsRight(&stcp);
002732  47006E     ADD W14, #0xE, W0
002734  07FC20     RCALL UARTDataIsRight
100:                   if ((stcp.Real_len == 9) && CRCIsRight(tmp, 7, tmp + 7)) {//注意优先的结合顺序
002736  90581E     MOV.B [W14+25], W0
002738  504FE9     SUB.B W0, #0x9, [W15]
00273A  3A000D     BRA NZ, 0x2756
00273C  470067     ADD W14, #0x7, W0
00273E  780100     MOV W0, W2
002740  B3C071     MOV.B #0x7, W1
002742  78000E     MOV W14, W0
002744  07002E     RCALL CRCIsRight
002746  E00400     CP0.B W0
002748  320006     BRA Z, 0x2756
101:                       CharToFloat(pres, tmp + 3);
00274A  470063     ADD W14, #0x3, W0
00274C  780080     MOV W0, W1
00274E  90206E     MOV [W14+76], W0
002750  07F9AA     RCALL CharToFloat
102:                       return true;
002752  B3C010     MOV.B #0x1, W0
002754  370001     BRA 0x2758
103:                   }
104:                   return false;
002756  EB4000     CLR.B W0
105:               }
002758  FA8000     ULNK
00275A  060000     RETURN
106:               
107:               void E41_Active_Send(void) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
00275C  FA0014     LNK #0x14
108:                   //判断接受到数据类型是仪表还是压力值
109:                   uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34, 0x20, 0x30, 0x42}, cnt;
00275E  090009     REPEAT #0x9
002760  EB1F00     CLR [W14++]
002762  B1014E     SUB #0x14, W14
002764  B3C010     MOV.B #0x1, W0
002766  984710     MOV.B W0, [W14+1]
002768  B3C010     MOV.B #0x1, W0
00276A  984720     MOV.B W0, [W14+2]
00276C  B3C120     MOV.B #0x12, W0
00276E  984730     MOV.B W0, [W14+3]
002770  B3C340     MOV.B #0x34, W0
002772  984740     MOV.B W0, [W14+4]
002774  B3C200     MOV.B #0x20, W0
002776  984750     MOV.B W0, [W14+5]
002778  B3C300     MOV.B #0x30, W0
00277A  984760     MOV.B W0, [W14+6]
00277C  B3C420     MOV.B #0x42, W0
00277E  984770     MOV.B W0, [W14+7]
110:                   E41_SetMode(WAKE); //设置为唤醒模式    
002780  B3C010     MOV.B #0x1, W0
002782  07FF7C     RCALL _E41_SetMode
111:                   Delayms(100); //(0, 0, 0, 100);
002784  200640     MOV #0x64, W0
002786  07FA3E     RCALL Delayms
112:                   INT0_Close();
002788  070311     RCALL INT0_Close
113:                   //    for (cnt = 0; cnt < 3; cnt++) {
114:                   UART3_SendString(E41_tmp, 8);
00278A  B3C081     MOV.B #0x8, W1
00278C  78000E     MOV W14, W0
00278E  070130     RCALL UART3_SendString
115:                   Delayms(10); //(0, 0, 0, 10);
002790  2000A0     MOV #0xA, W0
002792  07FA38     RCALL Delayms
116:                   //必须加
117:                   //    }
118:                   INT0_Open();
002794  070306     RCALL INT0_Open
119:                   Delays(10); //(0, 0, 10, 0);
002796  2000A0     MOV #0xA, W0
002798  07FA9F     RCALL Delays
120:                   E41_SetMode(LOWPOWER); //设置为低功耗模式    
00279A  B3C020     MOV.B #0x2, W0
00279C  07FF6F     RCALL _E41_SetMode
121:                   //    OSTimeDlyHMSM(0, 0, 10, 0);
122:               }
00279E  FA8000     ULNK
123:               
124:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: 浮点数转化为char数组
6:                 Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
7:                 Output: 输出数值
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
001A78  FA0008     LNK #0x8
001A7A  980720     MOV W0, [W14+4]
001A7C  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
001A7E  9000AE     MOV [W14+4], W1
001A80  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
001A82  EB4000     CLR.B W0
001A84  784F00     MOV.B W0, [W14]
001A86  37000A     BRA 0x1A9C
001A9A  E84F1E     INC.B [W14], [W14]
001A9C  78401E     MOV.B [W14], W0
001A9E  504FE3     SUB.B W0, #0x3, [W15]
001AA0  36FFF3     BRA LEU, 0x1A88
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
001A88  FB801E     ZE [W14], W0
001A8A  9000BE     MOV [W14+6], W1
001A8C  408000     ADD W1, W0, W0
001A8E  90011E     MOV [W14+2], W2
001A90  FB809E     ZE [W14], W1
001A92  1080E3     SUBR W1, #0x3, W1
001A94  410081     ADD W2, W1, W1
001A96  784091     MOV.B [W1], W1
001A98  784801     MOV.B W1, [W0]
16:                    }
17:                }
001AA2  FA8000     ULNK
001AA4  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char数组转化为浮点数 
22:                Input: 输出数值    模式：4 单精度浮点数 8 双精度浮点数 
23:                Output: 输入浮点数
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
001AA6  FA0008     LNK #0x8
001AA8  980720     MOV W0, [W14+4]
001AAA  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
001AAC  9000AE     MOV [W14+4], W1
001AAE  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
001AB0  EB4000     CLR.B W0
001AB2  784F00     MOV.B W0, [W14]
001AB4  37000A     BRA 0x1ACA
001AC8  E84F1E     INC.B [W14], [W14]
001ACA  78401E     MOV.B [W14], W0
001ACC  504FE3     SUB.B W0, #0x3, [W15]
001ACE  36FFF3     BRA LEU, 0x1AB6
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
001AB6  90009E     MOV [W14+2], W1
001AB8  FB801E     ZE [W14], W0
001ABA  408000     ADD W1, W0, W0
001ABC  FB809E     ZE [W14], W1
001ABE  1080E3     SUBR W1, #0x3, W1
001AC0  90013E     MOV [W14+6], W2
001AC2  410081     ADD W2, W1, W1
001AC4  784091     MOV.B [W1], W1
001AC6  784801     MOV.B W1, [W0]
32:                    }
33:                }
001AD0  FA8000     ULNK
001AD2  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: 浮点数转化为char数组
38:                Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
39:                Output: 输出数值
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
001AD4  FA0008     LNK #0x8
001AD6  980720     MOV W0, [W14+4]
001AD8  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
001ADA  9000AE     MOV [W14+4], W1
001ADC  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
001ADE  EB4000     CLR.B W0
001AE0  784F00     MOV.B W0, [W14]
001AE2  37000A     BRA 0x1AF8
001AF6  E84F1E     INC.B [W14], [W14]
001AF8  78401E     MOV.B [W14], W0
001AFA  504FE7     SUB.B W0, #0x7, [W15]
001AFC  36FFF3     BRA LEU, 0x1AE4
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
001AE4  FB801E     ZE [W14], W0
001AE6  9000BE     MOV [W14+6], W1
001AE8  408000     ADD W1, W0, W0
001AEA  90011E     MOV [W14+2], W2
001AEC  FB809E     ZE [W14], W1
001AEE  1080E7     SUBR W1, #0x7, W1
001AF0  410081     ADD W2, W1, W1
001AF2  784091     MOV.B [W1], W1
001AF4  784801     MOV.B W1, [W0]
48:                    }
49:                }
001AFE  FA8000     ULNK
001B00  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 16进制转化为10进制
54:                Input: 数据，字节数
55:                Output: 输出数值
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
001B02  FA0002     LNK #0x2
001B04  784F00     MOV.B W0, [W14]
58:                    return ((dat >> 4)&0x0f)*10 + (dat & 0x0f);
001B06  FB801E     ZE [W14], W0
001B08  DE0044     LSR W0, #4, W0
001B0A  784000     MOV.B W0, W0
001B0C  B9006A     MUL.SU W0, #10, W0
001B0E  780000     MOV W0, W0
001B10  784080     MOV.B W0, W1
001B12  78411E     MOV.B [W14], W2
001B14  61406F     AND.B W2, #0xF, W0
001B16  40C000     ADD.B W1, W0, W0
59:                }
001B18  FA8000     ULNK
001B1A  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 10进制转化为16进制
64:                Input: 数据，字节数
65:                Output: 输出数值
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
001B1C  FA0004     LNK #0x4
001B1E  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
001B20  FB809E     ZE [W14], W1
001B22  2000A0     MOV #0xA, W0
001B24  780100     MOV W0, W2
001B26  090011     REPEAT #0x11
001B28  D88082     DIV.UW W1, W2
001B2A  784000     MOV.B W0, W0
001B2C  FB8000     ZE W0, W0
001B2E  DD0044     SL W0, #4, W0
001B30  784000     MOV.B W0, W0
001B32  984720     MOV.B W0, [W14+2]
001B34  FB811E     ZE [W14], W2
001B36  2000A0     MOV #0xA, W0
001B38  780180     MOV W0, W3
001B3A  090011     REPEAT #0x11
001B3C  D88103     DIV.UW W2, W3
001B3E  FD0080     EXCH W0, W1
001B40  784000     MOV.B W0, W0
001B42  60406F     AND.B W0, #0xF, W0
001B44  9040AE     MOV.B [W14+2], W1
001B46  70C000     IOR.B W1, W0, W0
69:                }
001B48  FA8000     ULNK
001B4A  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x11（17）-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 判断数据是否有效
79:                Input: 是否
80:                Output: 输出数值
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
001B4C  FA0006     LNK #0x6
001B4E  780F00     MOV W0, [W14]
001B50  980711     MOV W1, [W14+2]
001B52  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
001B54  90001E     MOV [W14+2], W0
001B56  78009E     MOV [W14], W1
001B58  508F80     SUB W1, W0, [W15]
001B5A  360002     BRA LEU, 0x1B60
001B5C  EB4000     CLR.B W0
001B5E  370007     BRA 0x1B6E
84:                    else if (dat < min) return false;
001B60  90002E     MOV [W14+4], W0
001B62  78009E     MOV [W14], W1
001B64  508F80     SUB W1, W0, [W15]
001B66  310002     BRA C, 0x1B6C
001B68  EB4000     CLR.B W0
001B6A  370001     BRA 0x1B6E
85:                    return true;
001B6C  B3C010     MOV.B #0x1, W0
86:                }
001B6E  FA8000     ULNK
001B70  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 根据阀值设置参数
91:                Input: 是否
92:                Output: 输出数值
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
001B72  FA000A     LNK #0xA
001B74  980710     MOV W0, [W14+2]
001B76  980722     MOV W2, [W14+4]
001B78  980733     MOV W3, [W14+6]
001B7A  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
001B7C  90001E     MOV [W14+2], W0
001B7E  780010     MOV [W0], W0
001B80  DD00C8     SL W0, #8, W1
001B82  90001E     MOV [W14+2], W0
001B84  E88000     INC2 W0, W0
001B86  780010     MOV [W0], W0
001B88  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
001B8A  78001E     MOV [W14], W0
001B8C  B80161     MUL.UU W0, #1, W2
001B8E  90002E     MOV [W14+4], W0
001B90  9000BE     MOV [W14+6], W1
001B92  510F80     SUB W2, W0, [W15]
001B94  598F81     SUBB W3, W1, [W15]
001B96  360004     BRA LEU, 0x1BA0
98:                        *dat = max;
001B98  9000AE     MOV [W14+4], W1
001B9A  90001E     MOV [W14+2], W0
001B9C  780801     MOV W1, [W0]
001B9E  370007     BRA 0x1BAE
99:                    } else if (tmp < min) {
001BA0  90004E     MOV [W14+8], W0
001BA2  78009E     MOV [W14], W1
001BA4  508F80     SUB W1, W0, [W15]
001BA6  310003     BRA C, 0x1BAE
100:                       *dat = min;
001BA8  90001E     MOV [W14+2], W0
001BAA  9000CE     MOV [W14+8], W1
001BAC  780801     MOV W1, [W0]
101:                   }
102:               }
001BAE  FA8000     ULNK
001BB0  060000     RETURN
103:               //将数据反转
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
001BB2  FA0006     LNK #0x6
001BB4  980710     MOV W0, [W14+2]
001BB6  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
001BB8  EB4000     CLR.B W0
001BBA  784F00     MOV.B W0, [W14]
001BBC  37001B     BRA 0x1BF4
001BF2  E84F1E     INC.B [W14], [W14]
001BF4  90404E     MOV.B [W14+4], W0
001BF6  FB8000     ZE W0, W0
001BF8  D10000     LSR W0, W0
001BFA  784000     MOV.B W0, W0
001BFC  504F9E     SUB.B W0, [W14], [W15]
001BFE  3EFFDF     BRA GTU, 0x1BBE
109:                       tmp = dat[cnt];
001BBE  FB801E     ZE [W14], W0
001BC0  90009E     MOV [W14+2], W1
001BC2  408000     ADD W1, W0, W0
001BC4  784090     MOV.B [W0], W1
001BC6  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
001BC8  FB801E     ZE [W14], W0
001BCA  90009E     MOV [W14+2], W1
001BCC  408000     ADD W1, W0, W0
001BCE  9040CE     MOV.B [W14+4], W1
001BD0  FB8081     ZE W1, W1
001BD2  E90101     DEC W1, W2
001BD4  FB809E     ZE [W14], W1
001BD6  510081     SUB W2, W1, W1
001BD8  90011E     MOV [W14+2], W2
001BDA  410081     ADD W2, W1, W1
001BDC  784091     MOV.B [W1], W1
001BDE  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
001BE0  90404E     MOV.B [W14+4], W0
001BE2  FB8000     ZE W0, W0
001BE4  E90080     DEC W0, W1
001BE6  FB801E     ZE [W14], W0
001BE8  508000     SUB W1, W0, W0
001BEA  90009E     MOV [W14+2], W1
001BEC  408000     ADD W1, W0, W0
001BEE  90409E     MOV.B [W14+1], W1
001BF0  784801     MOV.B W1, [W0]
112:                   }
113:               }
001C00  FA8000     ULNK
001C02  060000     RETURN
114:               
115:               void Delayms(uint16_t time) {//不能大于1000,溢出
001C04  FA0002     LNK #0x2
001C06  780F00     MOV W0, [W14]
116:                   TMR2 = 0; //清楚定时器2的计数器
001C08  EF2106     CLR TMR2
117:                   PR2 = 625 * time / 10; //设置定时时间
001C0A  78009E     MOV [W14], W1
001C0C  202710     MOV #0x271, W0
001C0E  B98800     MUL.SS W1, W0, W0
001C10  780080     MOV W0, W1
001C12  2000A0     MOV #0xA, W0
001C14  780100     MOV W0, W2
001C16  090011     REPEAT #0x11
001C18  D88082     DIV.UW W1, W2
001C1A  880860     MOV W0, PR2
118:                   IFS0bits.T2IF = 0;
001C1C  A9E084     BCLR IFS0, #7
119:                   T2CONbits.TON = 1; //开启定时器二    
001C1E  A8E111     BSET 0x111, #7
120:                   while (!IFS0bits.T2IF); //等待定时时间到
001C20  000000     NOP
001C22  800421     MOV IFS0, W1
001C24  200800     MOV #0x80, W0
001C26  608000     AND W1, W0, W0
001C28  E00000     CP0 W0
001C2A  32FFFB     BRA Z, 0x1C22
121:                   T2CONbits.TON = 0; //关闭定时器二
001C2C  A9E111     BCLR 0x111, #7
122:                   IFS0bits.T2IF = 0; //清楚标志位
001C2E  A9E084     BCLR IFS0, #7
123:               }
001C30  FA8000     ULNK
001C32  060000     RETURN
124:               //8MHz-》4Mhz 使用重载入的函数
125:               //0x0271 10ms
126:               
127:               //32Mhz
128:               void Delay10ms(char time) {
001C34  FA0004     LNK #0x4
001C36  984720     MOV.B W0, [W14+2]
129:                   uint16_t i;
130:                   while (time-- > 0)
001C38  370009     BRA 0x1C4C
001C4C  B3C010     MOV.B #0x1, W0
001C4E  9040AE     MOV.B [W14+2], W1
001C50  E00401     CP0.B W1
001C52  3C0001     BRA GT, 0x1C56
001C54  EB4000     CLR.B W0
001C56  9040AE     MOV.B [W14+2], W1
001C58  E94081     DEC.B W1, W1
001C5A  984721     MOV.B W1, [W14+2]
001C5C  E00400     CP0.B W0
001C5E  3AFFED     BRA NZ, 0x1C3A
131:                       for (i = 0; i < 23000; i++)
001C3A  EB0000     CLR W0
001C3C  780F00     MOV W0, [W14]
001C3E  370002     BRA 0x1C44
001C42  E80F1E     INC [W14], [W14]
001C44  259D70     MOV #0x59D7, W0
001C46  78009E     MOV [W14], W1
001C48  508F80     SUB W1, W0, [W15]
001C4A  36FFFA     BRA LEU, 0x1C40
132:                           Nop();
001C40  000000     NOP
133:               }
001C60  FA8000     ULNK
001C62  060000     RETURN
134:               
135:               void Delay100ms(char time) {
001C64  FA0006     LNK #0x6
001C66  984740     MOV.B W0, [W14+4]
136:                   uint32_t i;
137:                   while (time-- > 0)
001C68  37000E     BRA 0x1C86
001C86  B3C010     MOV.B #0x1, W0
001C88  9040CE     MOV.B [W14+4], W1
001C8A  E00401     CP0.B W1
001C8C  3C0001     BRA GT, 0x1C90
001C8E  EB4000     CLR.B W0
001C90  9040CE     MOV.B [W14+4], W1
001C92  E94081     DEC.B W1, W1
001C94  984741     MOV.B W1, [W14+4]
001C96  E00400     CP0.B W0
001C98  3AFFE8     BRA NZ, 0x1C6A
138:                       for (i = 0; i < 122500; i++)
001C6A  B80060     MUL.UU W0, #0, W0
001C6C  BE8F00     MOV.D W0, [W14]
001C6E  370005     BRA 0x1C7A
001C72  200012     MOV #0x1, W2
001C74  200003     MOV #0x0, W3
001C76  410F1E     ADD W2, [W14], [W14]
001C78  49975E     ADDC W3, [++W14], [W14--]
001C7A  2DE830     MOV #0xDE83, W0
001C7C  200011     MOV #0x1, W1
001C7E  BE011E     MOV.D [W14], W2
001C80  510F80     SUB W2, W0, [W15]
001C82  598F81     SUBB W3, W1, [W15]
001C84  36FFF5     BRA LEU, 0x1C70
139:                           Nop();
001C70  000000     NOP
140:               }
001C9A  FA8000     ULNK
001C9C  060000     RETURN
141:               
142:               void Delay1s(char time) {
001C9E  FA0006     LNK #0x6
001CA0  984740     MOV.B W0, [W14+4]
143:                   uint32_t i; //,j;
144:                   while (time-- > 0)
001CA2  37000E     BRA 0x1CC0
001CC0  B3C010     MOV.B #0x1, W0
001CC2  9040CE     MOV.B [W14+4], W1
001CC4  E00401     CP0.B W1
001CC6  3C0001     BRA GT, 0x1CCA
001CC8  EB4000     CLR.B W0
001CCA  9040CE     MOV.B [W14+4], W1
001CCC  E94081     DEC.B W1, W1
001CCE  984741     MOV.B W1, [W14+4]
001CD0  E00400     CP0.B W0
001CD2  3AFFE8     BRA NZ, 0x1CA4
145:                       for (i = 0; i < 1235000; i++)
001CA4  B80060     MUL.UU W0, #0, W0
001CA6  BE8F00     MOV.D W0, [W14]
001CA8  370005     BRA 0x1CB4
001CAC  200012     MOV #0x1, W2
001CAE  200003     MOV #0x0, W3
001CB0  410F1E     ADD W2, [W14], [W14]
001CB2  49975E     ADDC W3, [++W14], [W14--]
001CB4  2D8370     MOV #0xD837, W0
001CB6  200121     MOV #0x12, W1
001CB8  BE011E     MOV.D [W14], W2
001CBA  510F80     SUB W2, W0, [W15]
001CBC  598F81     SUBB W3, W1, [W15]
001CBE  36FFF5     BRA LEU, 0x1CAA
146:                           Nop();
001CAA  000000     NOP
147:               }
001CD4  FA8000     ULNK
001CD6  060000     RETURN
148:                
149:               void Delays(char time) {
001CD8  FA0004     LNK #0x4
001CDA  984720     MOV.B W0, [W14+2]
150:                   uint8_t cnt;
151:                   for (cnt = 0; cnt < time; cnt++)
001CDC  EB4000     CLR.B W0
001CDE  784F00     MOV.B W0, [W14]
001CE0  370003     BRA 0x1CE8
001CE6  E84F1E     INC.B [W14], [W14]
001CE8  FB809E     ZE [W14], W1
001CEA  90402E     MOV.B [W14+2], W0
001CEC  FB0000     SE W0, W0
001CEE  508F80     SUB W1, W0, [W15]
001CF0  35FFF8     BRA LT, 0x1CE2
152:                       Delayms(1000);
001CE2  203E80     MOV #0x3E8, W0
001CE4  07FF8F     RCALL Delayms
153:               }
001CF2  FA8000     ULNK
001CF4  060000     RETURN
154:               
155:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
001CF6  FA0008     LNK #0x8
001CF8  980710     MOV W0, [W14+2]
001CFA  980721     MOV W1, [W14+4]
001CFC  984762     MOV.B W2, [W14+6]
156:                   uint8_t num;
157:                   for (num = 0; num < bytes; num++)
001CFE  EB4000     CLR.B W0
001D00  784F00     MOV.B W0, [W14]
001D02  370009     BRA 0x1D16
001D14  E84F1E     INC.B [W14], [W14]
001D16  90406E     MOV.B [W14+6], W0
001D18  78409E     MOV.B [W14], W1
001D1A  50CF80     SUB.B W1, W0, [W15]
001D1C  39FFF3     BRA NC, 0x1D04
158:                       *(output + num) = *(input + num);
001D04  FB801E     ZE [W14], W0
001D06  90009E     MOV [W14+2], W1
001D08  408000     ADD W1, W0, W0
001D0A  FB809E     ZE [W14], W1
001D0C  90012E     MOV [W14+4], W2
001D0E  410081     ADD W2, W1, W1
001D10  784091     MOV.B [W1], W1
001D12  784801     MOV.B W1, [W0]
159:               }
001D1E  FA8000     ULNK
001D20  060000     RETURN
160:               
161:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
001D22  FA0006     LNK #0x6
001D24  980710     MOV W0, [W14+2]
001D26  984741     MOV.B W1, [W14+4]
001D28  984752     MOV.B W2, [W14+5]
162:                   uint8_t num;
163:                   for (num = 0; num < bytes; num++)
001D2A  EB4000     CLR.B W0
001D2C  784F00     MOV.B W0, [W14]
001D2E  370006     BRA 0x1D3C
001D3A  E84F1E     INC.B [W14], [W14]
001D3C  90405E     MOV.B [W14+5], W0
001D3E  78409E     MOV.B [W14], W1
001D40  50CF80     SUB.B W1, W0, [W15]
001D42  39FFF6     BRA NC, 0x1D30
164:                       *(output + num) = dat;
001D30  FB801E     ZE [W14], W0
001D32  90009E     MOV [W14+2], W1
001D34  408000     ADD W1, W0, W0
001D36  9040CE     MOV.B [W14+4], W1
001D38  784801     MOV.B W1, [W0]
165:               }
001D44  FA8000     ULNK
001D46  060000     RETURN
166:               
167:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
001D48  FA0008     LNK #0x8
001D4A  980710     MOV W0, [W14+2]
001D4C  980721     MOV W1, [W14+4]
001D4E  984762     MOV.B W2, [W14+6]
168:                   uint8_t cnt;
169:                   for (cnt = 0; cnt < bytes; cnt++)
001D50  EB4000     CLR.B W0
001D52  784F00     MOV.B W0, [W14]
001D54  37000D     BRA 0x1D70
001D6E  E84F1E     INC.B [W14], [W14]
001D70  90406E     MOV.B [W14+6], W0
001D72  78409E     MOV.B [W14], W1
001D74  50CF80     SUB.B W1, W0, [W15]
001D76  39FFEF     BRA NC, 0x1D56
170:                       if (*(str1 + cnt) != *(str2 + cnt))
001D56  FB801E     ZE [W14], W0
001D58  90009E     MOV [W14+2], W1
001D5A  408000     ADD W1, W0, W0
001D5C  784090     MOV.B [W0], W1
001D5E  FB801E     ZE [W14], W0
001D60  90012E     MOV [W14+4], W2
001D62  410000     ADD W2, W0, W0
001D64  784010     MOV.B [W0], W0
001D66  50CF80     SUB.B W1, W0, [W15]
001D68  320002     BRA Z, 0x1D6E
171:                           return false;
001D6A  EB4000     CLR.B W0
001D6C  370006     BRA 0x1D7A
172:                   return true;
001D78  B3C010     MOV.B #0x1, W0
173:               }
001D7A  FA8000     ULNK
001D7C  060000     RETURN
174:               
175:               //快速去余数
176:               
177:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
001D7E  FA0004     LNK #0x4
001D80  780F00     MOV W0, [W14]
001D82  984721     MOV.B W1, [W14+2]
178:                   return num - ((num >> mod_num) << mod_num);
001D84  78001E     MOV [W14], W0
001D86  784080     MOV.B W0, W1
001D88  90402E     MOV.B [W14+2], W0
001D8A  FB8000     ZE W0, W0
001D8C  78011E     MOV [W14], W2
001D8E  DE1100     LSR W2, W0, W2
001D90  90402E     MOV.B [W14+2], W0
001D92  FB8000     ZE W0, W0
001D94  DD1000     SL W2, W0, W0
001D96  784000     MOV.B W0, W0
001D98  50C000     SUB.B W1, W0, W0
179:               }
001D9A  FA8000     ULNK
001D9C  060000     RETURN
180:               
181:               //16位整数转化为字符串
182:               
183:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
001D9E  FA0010     LNK #0x10
001DA0  980750     MOV W0, [W14+10]
001DA2  980761     MOV W1, [W14+12]
184:                   uint8_t buf[6];
185:                   uint8_t cnt = 0, len;
001DA4  EB4000     CLR.B W0
001DA6  784F00     MOV.B W0, [W14]
186:                   uint16_t tmp = i;
001DA8  90005E     MOV [W14+10], W0
001DAA  980710     MOV W0, [W14+2]
187:                   if (!tmp) {
001DAC  90001E     MOV [W14+2], W0
001DAE  E00000     CP0 W0
001DB0  3A001E     BRA NZ, 0x1DEE
188:                       *str = '0';
001DB2  90006E     MOV [W14+12], W0
001DB4  B3C301     MOV.B #0x30, W1
001DB6  784801     MOV.B W1, [W0]
189:                       *(str + 1) = '\0';
001DB8  90006E     MOV [W14+12], W0
001DBA  E80000     INC W0, W0
001DBC  EB4080     CLR.B W1
001DBE  784801     MOV.B W1, [W0]
190:                       len = 1;
001DC0  B3C010     MOV.B #0x1, W0
001DC2  984710     MOV.B W0, [W14+1]
001DC4  370034     BRA 0x1E2E
191:                   } else {
192:                       while (tmp) {
001DEE  90001E     MOV [W14+2], W0
001DF0  E00000     CP0 W0
001DF2  3AFFE9     BRA NZ, 0x1DC6
193:                           *(buf + cnt++) = tmp % 10 + 0x30;
001DC6  FB801E     ZE [W14], W0
001DC8  4700E4     ADD W14, #0x4, W1
001DCA  408080     ADD W1, W0, W1
001DCC  980771     MOV W1, [W14+14]
001DCE  90011E     MOV [W14+2], W2
001DD0  2000A1     MOV #0xA, W1
001DD2  780181     MOV W1, W3
001DD4  090011     REPEAT #0x11
001DD6  D88103     DIV.UW W2, W3
001DD8  784081     MOV.B W1, W1
001DDA  B04301     ADD.B #0x30, W1
001DDC  90007E     MOV [W14+14], W0
001DDE  784801     MOV.B W1, [W0]
001DE0  E84F1E     INC.B [W14], [W14]
194:                           tmp /= 10;
001DE2  90009E     MOV [W14+2], W1
001DE4  2000A0     MOV #0xA, W0
001DE6  780100     MOV W0, W2
001DE8  090011     REPEAT #0x11
001DEA  D88082     DIV.UW W1, W2
001DEC  980710     MOV W0, [W14+2]
195:                       }
196:                       len = cnt;
001DF4  78419E     MOV.B [W14], W3
001DF6  984713     MOV.B W3, [W14+1]
197:                       cnt += 1;
001DF8  E84F1E     INC.B [W14], [W14]
198:                       while (cnt--) {
001DFA  37000C     BRA 0x1E14
001E14  FB801E     ZE [W14], W0
001E16  EA0000     NEG W0, W0
001E18  DE004F     LSR W0, #15, W0
001E1A  784000     MOV.B W0, W0
001E1C  E94F1E     DEC.B [W14], [W14]
001E1E  E00400     CP0.B W0
001E20  3AFFED     BRA NZ, 0x1DFC
199:                           *(str + cnt - 1) = *(buf + len - cnt);
001DFC  FB801E     ZE [W14], W0
001DFE  E90000     DEC W0, W0
001E00  9000EE     MOV [W14+12], W1
001E02  408000     ADD W1, W0, W0
001E04  90409E     MOV.B [W14+1], W1
001E06  FB8101     ZE W1, W2
001E08  FB809E     ZE [W14], W1
001E0A  510081     SUB W2, W1, W1
001E0C  470164     ADD W14, #0x4, W2
001E0E  410081     ADD W2, W1, W1
001E10  784091     MOV.B [W1], W1
001E12  784801     MOV.B W1, [W0]
200:                       }
201:                       *(str + len) = '\0';
001E22  90401E     MOV.B [W14+1], W0
001E24  FB8000     ZE W0, W0
001E26  9000EE     MOV [W14+12], W1
001E28  408000     ADD W1, W0, W0
001E2A  EB4080     CLR.B W1
001E2C  784801     MOV.B W1, [W0]
202:                   }
203:                   return len;
001E2E  90401E     MOV.B [W14+1], W0
204:               }
001E30  FA8000     ULNK
205:               
206:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/CheckData.c  --------------------------------
1:                 //#include "user.h"
2:                 #include "CheckData.h"
3:                 
4:                 ///****************************************************************************
5:                 //名称: CRC16()
6:                 //说明: CRC16校验程序
7:                 //参数: *CRC_Buf:数据地址
8:                 //      CRC_Leni:数据长度
9:                 //返回: CRC校验值
10:                // *****************************************************************************/
11:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, const uint8_t CRC_Leni) {
12:                //    uint16_t i, j;
13:                //    uint16_t CRC_Sumx;
14:                //
15:                //    CRC_Sumx = 0xFFFF;
16:                //    for (i = 0; i < CRC_Leni; i++) {
17:                //        CRC_Sumx ^= *(CRC_Buf + i); //异或
18:                //        for (j = 0; j < 8; j++) {
19:                //            if (CRC_Sumx & 0x01) {
20:                //                CRC_Sumx >>= 1;
21:                //                CRC_Sumx ^= 0xA001;
22:                //            } else {
23:                //                CRC_Sumx >>= 1;
24:                //            }
25:                //        }
26:                //    }
27:                //    return (CRC_Sumx);
28:                //}
29:                
30:                /*************************************
31:                Function: CheckIsRight  
32:                Description: 判断接受dat，根据fp校验，返回数据正确性
33:                Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
34:                Output: 1：校验正确  0：校验错误
35:                 *************************************/
36:                bool CRCIsRight(uint8_t * CRC_Buf, const uint8_t CRC_Leni, const uint8_t* CHC_Dat) {
0027A2  FA000C     LNK #0xC
0027A4  980730     MOV W0, [W14+6]
0027A6  984F01     MOV.B W1, [W14+8]
0027A8  980752     MOV W2, [W14+10]
37:                    uint16_t i, j;
38:                    uint16_t CRC_Sumx;
39:                
40:                    CRC_Sumx = 0xFFFF;
0027AA  EB8000     SETM W0
0027AC  980720     MOV W0, [W14+4]
41:                    for (i = 0; i < CRC_Leni; i++) {
0027AE  EB0000     CLR W0
0027B0  780F00     MOV W0, [W14]
0027B2  370021     BRA 0x27F6
0027F4  E80F1E     INC [W14], [W14]
0027F6  90480E     MOV.B [W14+8], W0
0027F8  FB8000     ZE W0, W0
0027FA  500F9E     SUB W0, [W14], [W15]
0027FC  3EFFDB     BRA GTU, 0x27B4
42:                        CRC_Sumx ^= *(CRC_Buf + i); //异或
0027B4  90003E     MOV [W14+6], W0
0027B6  40001E     ADD W0, [W14], W0
0027B8  784010     MOV.B [W0], W0
0027BA  FB8000     ZE W0, W0
0027BC  9000AE     MOV [W14+4], W1
0027BE  688000     XOR W1, W0, W0
0027C0  980720     MOV W0, [W14+4]
43:                        for (j = 0; j < 8; j++) {
0027C2  EB0000     CLR W0
0027C4  980710     MOV W0, [W14+2]
0027C6  370013     BRA 0x27EE
0027E8  90001E     MOV [W14+2], W0
0027EA  E80000     INC W0, W0
0027EC  980710     MOV W0, [W14+2]
0027EE  90001E     MOV [W14+2], W0
0027F0  500FE7     SUB W0, #0x7, [W15]
0027F2  36FFEA     BRA LEU, 0x27C8
44:                            if (CRC_Sumx & 0x01) {
0027C8  90002E     MOV [W14+4], W0
0027CA  600061     AND W0, #0x1, W0
0027CC  784000     MOV.B W0, W0
0027CE  E00400     CP0.B W0
0027D0  320008     BRA Z, 0x27E2
45:                                CRC_Sumx >>= 1;
0027D2  90002E     MOV [W14+4], W0
0027D4  D10000     LSR W0, W0
0027D6  980720     MOV W0, [W14+4]
46:                                CRC_Sumx ^= 0xA001;
0027D8  9000AE     MOV [W14+4], W1
0027DA  2A0010     MOV #0xA001, W0
0027DC  688000     XOR W1, W0, W0
0027DE  980720     MOV W0, [W14+4]
0027E0  370003     BRA 0x27E8
47:                            } else {
48:                                CRC_Sumx >>= 1;
0027E2  90002E     MOV [W14+4], W0
0027E4  D10000     LSR W0, W0
0027E6  980720     MOV W0, [W14+4]
49:                            }
50:                        }
51:                    }; //CRC校验
52:                    return (CRC_Sumx == (*CHC_Dat + (*(CHC_Dat + 1) << 8))); //校验数据+CRC
0027FE  90005E     MOV [W14+10], W0
002800  784010     MOV.B [W0], W0
002802  FB8080     ZE W0, W1
002804  90005E     MOV [W14+10], W0
002806  E80000     INC W0, W0
002808  784010     MOV.B [W0], W0
00280A  FB8000     ZE W0, W0
00280C  DD0048     SL W0, #8, W0
00280E  408000     ADD W1, W0, W0
002810  780080     MOV W0, W1
002812  90002E     MOV [W14+4], W0
002814  688000     XOR W1, W0, W0
002816  A7F000     BTSC W0, #15
002818  EA0000     NEG W0, W0
00281A  E90000     DEC W0, W0
00281C  DE004F     LSR W0, #15, W0
00281E  784000     MOV.B W0, W0
53:                }
002820  FA8000     ULNK
002822  060000     RETURN
54:                
55:                ///*************************************
56:                //Function: Sum_Check 
57:                //Description: 计算和校验的数值，
58:                //Input: frame：数据，bytes：字节数 
59:                //Output: 和校验结果值
60:                // *************************************/
61:                //uint16_t Sum_Check(uint8_t *frame, const uint8_t bytes) {
62:                //    uint16_t cksum = 0;
63:                //    uint16_t cnt = bytes;
64:                //    while (cnt > 0) {
65:                //        cksum += *frame++;
66:                //        cnt--;
67:                //    }
68:                //    return cksum;
69:                //}
70:                
71:                /*************************************
72:                Function: Sum_Check256
73:                Description: 计算和校验的数值，
74:                Input: frame：数据，bytes：字节数 
75:                Output: 和校验结果值
76:                 *************************************/
77:                bool SumCheckIsRight(uint8_t *frame, const uint16_t bytes, const uint8_t CheckSum) {
002824  FA000C     LNK #0xC
002826  980730     MOV W0, [W14+6]
002828  980741     MOV W1, [W14+8]
00282A  984F22     MOV.B W2, [W14+10]
78:                    uint32_t ckSum = 0; //避免数据溢出
00282C  B80060     MUL.UU W0, #0, W0
00282E  BE8F00     MOV.D W0, [W14]
79:                    uint16_t cnt;
80:                
81:                    for (cnt = 0; cnt < bytes; cnt++)
002830  EB0000     CLR W0
002832  980720     MOV W0, [W14+4]
002834  37000C     BRA 0x284E
002848  90002E     MOV [W14+4], W0
00284A  E80000     INC W0, W0
00284C  980720     MOV W0, [W14+4]
00284E  9000AE     MOV [W14+4], W1
002850  90004E     MOV [W14+8], W0
002852  508F80     SUB W1, W0, [W15]
002854  39FFF0     BRA NC, 0x2836
82:                        ckSum += *frame++;
002836  90003E     MOV [W14+6], W0
002838  784010     MOV.B [W0], W0
00283A  FB8000     ZE W0, W0
00283C  EB0080     CLR W1
00283E  400F1E     ADD W0, [W14], [W14]
002840  48975E     ADDC W1, [++W14], [W14--]
002842  90003E     MOV [W14+6], W0
002844  E80000     INC W0, W0
002846  980730     MOV W0, [W14+6]
83:                
84:                    return (CheckSum == (ckSum - ((ckSum >> 8) << 8)));
002856  90482E     MOV.B [W14+10], W0
002858  FB8200     ZE W0, W4
00285A  EB0280     CLR W5
00285C  200FF0     MOV #0xFF, W0
00285E  200001     MOV #0x0, W1
002860  BE011E     MOV.D [W14], W2
002862  780302     MOV W2, W6
002864  780103     MOV W3, W2
002866  780180     MOV W0, W3
002868  780001     MOV W1, W0
00286A  630303     AND W6, W3, W6
00286C  610000     AND W2, W0, W0
00286E  EB0080     CLR W1
002870  DD00C0     SL W0, #0, W1
002872  200000     MOV #0x0, W0
002874  BE0100     MOV.D W0, W2
002876  B83061     MUL.UU W6, #1, W0
002878  710100     IOR W2, W0, W2
00287A  718181     IOR W3, W1, W3
00287C  6A0002     XOR W4, W2, W0
00287E  6A8083     XOR W5, W3, W1
002880  708000     IOR W1, W0, W0
002882  A7F000     BTSC W0, #15
002884  EA0000     NEG W0, W0
002886  E90000     DEC W0, W0
002888  DE004F     LSR W0, #15, W0
00288A  784000     MOV.B W0, W0
85:                }
00288C  FA8000     ULNK
86:                
87:                
88:                
89:                //bool CheckSrting(uint8_t*dat1, uint8_t*dat2, const uint8_t num) {
90:                //    uint8_t cnt;
91:                //    for (cnt = 0; cnt < num; cnt++) {//判断EID
92:                //        if (*(dat1 + cnt) != *(dat2 + cnt)) {
93:                //            return false;
94:                //        }
95:                //    }
96:                //    return true;
97:                //}
98:                
99:                ///*************************************
100:               //Function: MD5encrypt  
101:               //Description: 
102:               //Input: 
103:               //Output:
104:               //*************************************/
105:               //void MD5encrypt(uint8_t* input,uint8_t *output)
106:               //{
107:               //    
108:               //}
109:               
110:               
111:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/User/CAT24C512.c  --------------------------------
1:                 #include "CAT24C512.h"
2:                 
3:                 //取值范围0x0000-0xffff 512kb
4:                 #define BufferSize 9//40//一组采集数据的字节
5:                 
6:                 
7:                 uint16_t CAT_OperatID;
8:                 //CAT24Arg CAT24Argbits;
9:                 
10:                void CAT24C512_Init(void) {
002BB2  FA0000     LNK #0x0
11:                    TRISBbits.TRISB12 = 0; //WP引脚设置为输出    
002BB4  A982C9     BCLR 0x2C9, #4
12:                    LATBbits.LATB12 = 1; //开启写保护
002BB6  A882CD     BSET 0x2CD, #4
13:                    //    CAT24Argbits.ID = 0; //初始化结构体
14:                    //    CAT24Argbits.data = NULL;
15:                }
002BB8  FA8000     ULNK
002BBA  060000     RETURN
16:                
17:                void CAT24C512_Read(uint16_t id, uint8_t *tmp) {
002BBC  FA0004     LNK #0x4
002BBE  780F00     MOV W0, [W14]
002BC0  980711     MOV W1, [W14+2]
18:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //调试cat24c512 地址0xA8写操作地址 
19:                    i2c_buf.operatcode = CAT_ADD;
002BC2  209360     MOV #0x936, W0
002BC4  B3CA81     MOV.B #0xA8, W1
002BC6  784801     MOV.B W1, [W0]
20:                    i2c_buf.address = id*BufferSize;
002BC8  78001E     MOV [W14], W0
002BCA  B90069     MUL.SU W0, #9, W0
002BCC  780000     MOV W0, W0
002BCE  8849C0     MOV W0, 0x938
21:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
002BD0  2093A0     MOV #0x93A, W0
002BD2  B3C091     MOV.B #0x9, W1
002BD4  784801     MOV.B W1, [W0]
22:                    i2c_buf.pbuffer = tmp;
002BD6  90009E     MOV [W14+2], W1
002BD8  8849E1     MOV W1, 0x93C
23:                    i2c_buf.flag.F_IsSelectiveMode = 1;
002BDA  8049F0     MOV 0x93E, W0
002BDC  A00000     BSET W0, #0
002BDE  8849F0     MOV W0, 0x93E
24:                    i2c_buf.flag.F_WriteOrRead = 1;
002BE0  8049F0     MOV 0x93E, W0
002BE2  A02000     BSET W0, #2
002BE4  8849F0     MOV W0, 0x93E
25:                    i2c_buf.flag.F_Is16bitsDevice = 1;
002BE6  8049F0     MOV 0x93E, W0
002BE8  A01000     BSET W0, #1
002BEA  8849F0     MOV W0, 0x93E
26:                    i2c1_state = S_MASTER_IDLE;
002BEC  EF6838     CLR.B i2c1_state
27:                    IFS1bits.MI2C1IF = 1; //开始I2C
002BEE  A82086     BSET IFS1, #1
28:                    //等待数据发送完成或是数据异常
29:                    //发送数据给上位机
30:                    while (i2c1_state != S_MASTER_SEND_STOP); //等待发送完成，避免重复发送数据
002BF0  000000     NOP
002BF2  BFC838     MOV.B i2c1_state, WREG
002BF4  504FE6     SUB.B W0, #0x6, [W15]
002BF6  3AFFFD     BRA NZ, 0x2BF2
31:                }
002BF8  FA8000     ULNK
002BFA  060000     RETURN
32:                
33:                void CAT24C512_Write(uint16_t id, uint8_t *tmp) {
002BFC  FA0004     LNK #0x4
002BFE  780F00     MOV W0, [W14]
002C00  980711     MOV W1, [W14+2]
34:                    //    uint8_t tmp[BufferSize] = {1, 2, 3, 4}; //调试cat24c512 地址0xA8写操作地址 
35:                    //    uint8_t tmp1[4] = {CAT_ADD, 0x00, 0x00, 0x00};
36:                    i2c_buf.operatcode = CAT_ADD;
002C02  209360     MOV #0x936, W0
002C04  B3CA81     MOV.B #0xA8, W1
002C06  784801     MOV.B W1, [W0]
37:                    i2c_buf.address = id*BufferSize;
002C08  78001E     MOV [W14], W0
002C0A  B90069     MUL.SU W0, #9, W0
002C0C  780000     MOV W0, W0
002C0E  8849C0     MOV W0, 0x938
38:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
002C10  2093A0     MOV #0x93A, W0
002C12  B3C091     MOV.B #0x9, W1
002C14  784801     MOV.B W1, [W0]
39:                    i2c_buf.pbuffer = tmp;
002C16  90009E     MOV [W14+2], W1
002C18  8849E1     MOV W1, 0x93C
40:                    i2c_buf.flag.F_IsSelectiveMode = 1;
002C1A  8049F0     MOV 0x93E, W0
002C1C  A00000     BSET W0, #0
002C1E  8849F0     MOV W0, 0x93E
41:                    i2c_buf.flag.F_WriteOrRead = 0;
002C20  8049F0     MOV 0x93E, W0
002C22  A12000     BCLR W0, #2
002C24  8849F0     MOV W0, 0x93E
42:                    i2c_buf.flag.F_Is16bitsDevice = 1;
002C26  8049F0     MOV 0x93E, W0
002C28  A01000     BSET W0, #1
002C2A  8849F0     MOV W0, 0x93E
43:                    i2c1_state = S_MASTER_IDLE;
002C2C  EF6838     CLR.B i2c1_state
44:                    IFS1bits.MI2C1IF = 1;
002C2E  A82086     BSET IFS1, #1
45:                    while (i2c1_state != S_MASTER_SEND_STOP); //等待发送完成，避免重复发送数据
002C30  000000     NOP
002C32  BFC838     MOV.B i2c1_state, WREG
002C34  504FE6     SUB.B W0, #0x6, [W15]
002C36  3AFFFD     BRA NZ, 0x2C32
46:                    //等待数据发送完成或是数据异常
47:                }
002C38  FA8000     ULNK
48:                
49:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                //#include "HL6528.h"
18:                //#include "E41.h"
19:                //#include "xc.h"
20:                
21:                void OSCILLATOR_Initialize(void) {
002CB6  FA0000     LNK #0x0
22:                    // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
23:                    CLKDIV = 0x3000;
002CB8  230000     MOV #0x3000, W0
002CBA  883A20     MOV W0, CLKDIV
24:                
25:                    // Set the secondary oscillator    
26:                    OSCCONbits.SOSCEN = 1; //开启辅助振荡器
002CBC  A82742     BSET OSCCON, #1
27:                    __builtin_write_OSCCONL(0x02);
002CBE  200022     MOV #0x2, W2
002CC0  200460     MOV #0x46, W0
002CC2  200571     MOV #0x57, W1
002CC4  207423     MOV #0x742, W3
002CC6  784980     MOV.B W0, [W3]
002CC8  784981     MOV.B W1, [W3]
002CCA  784982     MOV.B W2, [W3]
28:                    //    OSCCONbits.OSWEN = 1;
29:                    //    OSC_Unlock_Sequence(); //切换时钟
30:                }
002CCC  FA8000     ULNK
002CCE  060000     RETURN
31:                
32:                /*
33:                 *********************************************************************************************************
34:                 *                                         BSP INITIALIZATION
35:                 *
36:                 * Description : This function should be called by your application code before you make use of any of the
37:                 *               functions found in this module.
38:                 *
39:                 * Arguments   : none
40:                 *********************************************************************************************************
41:                 */
42:                
43:                void BSP_Init(void) {
002CD0  FA0000     LNK #0x0
44:                    //    RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
45:                    //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
46:                    //    BSP_PLL_Init(); /* Initialize the PLL                                       */
47:                    //#endif
48:                    OSCILLATOR_Initialize(); //初始化时钟
002CD2  07FFF1     RCALL OSCILLATOR_Initialize
49:                    //    Tmr_TickInit(); //初始化UCOS的指令周期
50:                    LED_Init(); //初始化LED
002CD4  07000B     RCALL LED_Init
51:                    WGC_Init(); //初始化WGC参数
002CD6  07FBA6     RCALL WGC_Init
52:                    RTC_Init(); //初始化实时时钟
002CD8  07F4C5     RCALL RTC_Init
53:                    PPSInit(); //选择设备
002CDA  070024     RCALL PPSInit
54:                    UART2_Init(); //初始化串口2，用于GPRS通讯hl6528
002CDC  07FDD9     RCALL UART2_Init
55:                    UART3_Init(); //初始化串口3，用于短程无线通讯433
002CDE  07FE4C     RCALL UART3_Init
56:                    RS485_Init(); //初始化串口1，用于485通讯上位机通讯
002CE0  07FEBA     RCALL RS485_Init
57:                    I2C_Init(); //初始化i2c,用于获取时钟和存储数据
002CE2  07007D     RCALL I2C_Init
58:                    //    INT0_Init(); //外部中断初始化
59:                    //    E41_Init(); //初始化短程无线
60:                    //    HL6528_Init(); /*Initialize the HL6528*/
61:                    ////#ifdef CLOSE_6528
62:                    ////    HL6528_Close();//注意：开启 容易导致初始化失败
63:                    ////    UART2_Close();
64:                    ////#endif
65:                    //    CAT24C512_Init(); //应用程序初始化
66:                    // no use   //    PCF8583_Init();//初始化PCF8583
67:                    //    //        Close6528Cop(); /*Close UART2 */
68:                    LCD_Init();
002CE4  07F210     RCALL LCD_Init
69:                    //    TMR1_Initialize();
70:                    TMR2_Initialize();
002CE6  070071     RCALL TMR2_Initialize
71:                }
002CE8  FA8000     ULNK
002CEA  060000     RETURN
72:                
73:                /*
74:                 *********************************************************************************************************
75:                 *                                      BSP_PLL_Init()
76:                 *
77:                 * Description : This function configures and enables the PLL with the external oscillator
78:                 *               selected as the input clock to the PLL.
79:                 *
80:                 * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
81:                 *               2) FIN is the PLL input clock frequency, defined in bsp.h as
82:                 *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
83:                 *                  oscillator on the Explorer 16 Evaluation Board.
84:                 *               3) M is the desired PLL multiplier
85:                 *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
86:                 *               5) N2 is the PLL output divider (Post-Divider)
87:                 *
88:                 * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
89:                 *                  The processor clock is (1/2) of the PLL output.
90:                 *                  Performance = 40 MIPS.
91:                 *********************************************************************************************************
92:                 */
93:                //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
94:                //
95:                //static void BSP_PLL_Init(void) {
96:                //    PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
97:                //    CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
98:                //}
99:                //#endif
100:               
101:               /*
102:                *********************************************************************************************************
103:                *                                      BSP_CPU_ClkFrq()
104:               
105:                * Description : This function determines the CPU clock frequency (Fcy)
106:                * Returns     : The CPU frequency in (HZ)
107:                *********************************************************************************************************
108:                */
109:               
110:               //CPU_INT32U BSP_CPU_ClkFrq(void) {
111:               //    CPU_INT08U Clk_Selected;
112:               //    CPU_INT16U FRC_Div;
113:               //    CPU_INT32U CPU_Clk_Frq;
114:               //
115:               //
116:               //#if defined (__dsPIC33E__) || defined (__dsPIC33F__)
117:               //    CPU_INT08U PLL_n1;
118:               //    CPU_INT08U PLL_n2;
119:               //    CPU_INT16U PLL_m;
120:               //    PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
121:               //    PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
122:               //    PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
123:               //    PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
124:               //#endif
125:               //
126:               //    FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
127:               //    FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
128:               //
129:               //    Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
130:               //
131:               //    switch (Clk_Selected) {
132:               //        case 0: /* Fast Oscillator (FRC) Selected                           */
133:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
134:               //            break;
135:               //
136:               //        case 1:
137:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
138:               //            CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
139:               //                    (FRC_Div * PLL_n1 * PLL_n2));
140:               //#else
141:               //            /* Fast Oscillator (FRC) with PLL Selected                  */
142:               //            CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
143:               //#endif
144:               //            break;
145:               //
146:               //        case 2: /* Primary External Oscillator Selected                     */
147:               //            CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
148:               //            break;
149:               //
150:               //        case 3:
151:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
152:               //            CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
153:               //                    (PLL_n1 * PLL_n2));
154:               //#else
155:               //            /* Primary External Oscillator with PLL Selected            */
156:               //            CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
157:               //#endif
158:               //            break;
159:               //
160:               //        case 4: /* Secondary Oscillator Selected (SOCS)                     */
161:               //            CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
162:               //            break;
163:               //
164:               //        case 5: /* Low Power Oscillator (LPOSC) Selected                    */
165:               //            CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
166:               //            break;
167:               //
168:               //        case 6:
169:               //            CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
170:               //            break;
171:               //
172:               //        case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
173:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
174:               //            break;
175:               //
176:               //        default:
177:               //            CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
178:               //            break;
179:               //    }
180:               //
181:               //    CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
182:               //
183:               //    return (CPU_Clk_Frq); /* Return the operating frequency                           */
184:               //}
185:               
186:               /*
187:                *********************************************************************************************************
188:                *                                     DISABLE ALL INTERRUPTS
189:                *
190:                * Description : This function disables all interrupts from the interrupt controller.
191:                *
192:                * Arguments   : none
193:                *********************************************************************************************************
194:                */
195:               
196:               //void BSP_IntDisAll(void) {
197:               //}
198:               
199:               /*
200:                *********************************************************************************************************
201:                *                                         LED I/O INITIALIZATION
202:                *
203:                * Description : This function initializes the I/O Pins used by the onboard LEDs
204:                *
205:                * Arguments   : none
206:                *
207:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
208:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
209:                *********************************************************************************************************
210:                */
211:               
212:               void LED_Init(void) {
002CEC  FA0000     LNK #0x0
213:                   TRISBbits.TRISB13 = 0;
002CEE  A9A2C9     BCLR 0x2C9, #5
214:               
215:                   LED_Off(); /* Shut off all LEDs                                        */
002CF0  070006     RCALL LED_Off
216:               }
002CF2  FA8000     ULNK
002CF4  060000     RETURN
217:               
218:               /*
219:                *********************************************************************************************************
220:                *                                             LED ON
221:                *
222:                * Description : This function is used to control any or all the LEDs on the board.
223:                *
224:                * Arguments   : led    is the number of the LED to control
225:                *                      0    indicates that you want ALL the LEDs to be ON
226:                *                      1    turns ON LED1
227:                *                      2    turns ON LED2
228:                *                      ...
229:                *                      8    turns ON LED8
230:                *
231:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
232:                *********************************************************************************************************
233:                */
234:               
235:               void LED_On(void) {
002CF6  FA0000     LNK #0x0
236:                   PORTBbits.RB13 = 1;
002CF8  A8A2CB     BSET 0x2CB, #5
237:               }
002CFA  FA8000     ULNK
002CFC  060000     RETURN
238:               
239:               /*
240:                *********************************************************************************************************
241:                *                                             LED OFF
242:                *
243:                * Description : This function is used to control any or all the LEDs on the board.
244:                *
245:                * Arguments   : led    is the number of the LED to turn OFF
246:                *                      0    indicates that you want ALL the LEDs to be OFF
247:                *                      1    turns OFF LED1
248:                *                      2    turns OFF LED2
249:                *                      .
250:                *                      8    turns OFF LED8
251:                *
252:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
253:                *********************************************************************************************************
254:                */
255:               
256:               void LED_Off(void) {
002CFE  FA0000     LNK #0x0
257:                   LATBbits.LATB13 = 0;
002D00  A9A2CD     BCLR 0x2CD, #5
258:               }
002D02  FA8000     ULNK
002D04  060000     RETURN
259:               
260:               /*
261:                *********************************************************************************************************
262:                *                                             LED TOGGLE
263:                *
264:                * Description : This function is used to toggle any or all the LEDs on the board.
265:                *
266:                * Arguments   : led    is the number of the LED to control
267:                *                      0    indicates that you want to toggle ALL the LEDs
268:                *                      1    toggles LED1
269:                *                      2    toggles LED2
270:                *                      .
271:                *                      8    toggles LED8
272:                *
273:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
274:                *********************************************************************************************************
275:                */
276:               
277:               void LED_Toggle(void) {
002D06  FA0000     LNK #0x0
278:                   LATBbits.LATB13 ^= 1;
002D08  801660     MOV LATB, W0
002D0A  DE004D     LSR W0, #13, W0
002D0C  604061     AND.B W0, #0x1, W0
002D0E  A20400     BTG.B W0, #0
002D10  604061     AND.B W0, #0x1, W0
002D12  FB8000     ZE W0, W0
002D14  600061     AND W0, #0x1, W0
002D16  DD004D     SL W0, #13, W0
002D18  801661     MOV LATB, W1
002D1A  A1D001     BCLR W1, #13
002D1C  700001     IOR W0, W1, W0
002D1E  881660     MOV W0, LATB
279:               }
002D20  FA8000     ULNK
280:               
281:               /*
282:                *********************************************************************************************************
283:                *                                   OSProbe_TmrInit()
284:                *
285:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
286:                *               free running timer that is used to make time measurements.
287:                *
288:                * Arguments   : none
289:                *
290:                * Returns     : none
291:                *
292:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
293:                *                  from Tmr_TickInit().
294:                *********************************************************************************************************
295:                */
296:               
297:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
298:               
299:               //void OSProbe_TmrInit(void) {
300:               //#if OS_PROBE_TIMER_SEL == 3
301:               //    T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
302:               //    TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
303:               //    PR3 = 0xFFFF; /* Set the period register to its maximum value             */
304:               //    T3CON |= TON; /* Start the timer                                          */
305:               //#endif
306:               //
307:               //#if OS_PROBE_TIMER_SEL == 5
308:               //    T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
309:               //    TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
310:               //    PR5 = 0xFFFF; /* Set the period register to its maximum value             */
311:               //    T5CON |= TON; /* Start the timer                                          */
312:               //#endif
313:               //}
314:               //#endif
315:               
316:               /*
317:                *********************************************************************************************************
318:                *                                   OSProbe_TmrRd()
319:                *
320:                * Description : This function is called to read the current counts of a 16 bit free running timer.
321:                *
322:                * Arguments   : none
323:                *
324:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
325:                *********************************************************************************************************
326:                */
327:               
328:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
329:               
330:               //CPU_INT32U OSProbe_TmrRd(void) {
331:               //#if OS_PROBE_TIMER_SEL == 3
332:               //    return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
333:               //#endif
334:               //
335:               //#if OS_PROBE_TIMER_SEL == 5
336:               //    return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
337:               //#endif
338:               //}
339:               //#endif
340:               
341:               /*
342:                *********************************************************************************************************
343:                *                                       TICKER INITIALIZATION
344:                *
345:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
346:                *               interrupts every 1 to 100 mS).
347:                *
348:                * Arguments   : none
349:                *
350:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
351:                *               2) The timer resets to 0 after period register match interrupt is generated
352:                *********************************************************************************************************
353:                */
354:               
355:               //static void Tmr_TickInit(void) {
356:               //    CPU_INT32U tmr_frq;
357:               //    CPU_INT16U cnts;
358:               //
359:               //
360:               //    tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
361:               //    cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
362:               //
363:               //#if BSP_OS_TMR_SEL == 2
364:               //    T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
365:               //    TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
366:               //    PR2 = cnts; /* Set the period register                                  */
367:               //    IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
368:               //    IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
369:               //    IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
370:               //    IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
371:               //    T2CON |= TON; /* Start the timer                                          */
372:               //#endif
373:               //
374:               //#if BSP_OS_TMR_SEL == 4
375:               //    T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
376:               //    TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
377:               //    PR4 = cnts; /* Set the period register                                  */
378:               //    IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
379:               //    IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
380:               //    IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
381:               //    IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
382:               //    T4CON |= TON; /* Start the timer                                          */
383:               //#endif
384:               //}
385:               
386:               /*
387:                *********************************************************************************************************
388:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
389:                *
390:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
391:                *********************************************************************************************************
392:                */
393:               
394:               //void OS_Tick_ISR_Handler(void) {
395:               //#if  BSP_OS_TMR_SEL == 2
396:               //    IFS0 &= ~T2IF;
397:               //#endif
398:               //
399:               //#if  BSP_OS_TMR_SEL == 4
400:               //    IFS1 &= ~T41F;
401:               //#endif
402:               //
403:               //    OSTimeTick();
404:               //}
405:               
406:               //void OSC_Unlock_Sequence(void) {
407:               //        //Place the new oscillator selection in W0
408:               //        //OSCCONH (high byte) Unlock Sequence
409:               //        asm("MOV #OSCCONH,w1");
410:               //        asm("MOV #0x78, w2");
411:               //        asm("MOV #0x9A, w3");
412:               //        asm("MOV.b w2, [w1]");
413:               //        asm("MOV.b w3, [w1]");
414:               //        //Set new oscillator selection
415:               //        asm("MOV.b WREG, OSCCONH");
416:               //        //OSCCONL (low byte) unlock sequence
417:               //        asm("MOV #OSCCONL,w1");
418:               //        asm("MOV.b #0x01, w0");
419:               //        asm("MOV #0x46, w2");
420:               //        asm("MOV #0x57, w3");
421:               //        asm("MOV.b w2, [w1]");
422:               //        asm("MOV.b w3, [w1]");
423:               //        //Start oscillator switch operation
424:               //        asm("MOV.b w0, [w1]");
425:               //    __builtin_write_OSCCONH(0x03);
426:               //    __builtin_write_OSCCONL(0x02);
427:               //    OSCCONbits.LOCK = 1;
428:               //    OSCCONbits.OSWEN = 1;
429:               //    OSCCONbits.LOCK = 0;
430:               //}
431:               //时钟初始化
432:               
433:               
434:               
435:               
436:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/UART3.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
002978  FA0000     LNK #0x0
6:                     TRISGbits.TRISG8 = 1; //设置为输入
00297A  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //设置为输出
00297C  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //已经为数字端口
00297E  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
002980  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1;//漏极开路输出
002982  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //设置为输入
12:                    //    TRISDbits.TRISD2 = 0; //设置为输出
13:                
14:                    U3MODEbits.BRGH = 0; //波特率使用标准模式1:16
002984  A96250     BCLR U3MODE, #3
15:                    U3BRG = 103; //19200 103; //16000000/9600/16-1
002986  200670     MOV #0x67, W0
002988  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //无奇偶校验
00298A  801281     MOV U3MODE, W1
00298C  2FFF90     MOV #0xFFF9, W0
00298E  608000     AND W1, W0, W0
002990  881280     MOV W0, U3MODE
17:                    U3MODEbits.STSEL = 0; //1位停止位
002992  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //使能串口
002994  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
002996  801291     MOV U3STA, W1
002998  200C00     MOV #0xC0, W0
00299A  700001     IOR W0, W1, W0
00299C  881290     MOV W0, U3STA
22:                    IFS5bits.U3RXIF = 0; //清除接收中断  
00299E  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
0029A0  800661     MOV IPC20, W1
0029A2  2F8FF0     MOV #0xF8FF, W0
0029A4  608080     AND W1, W0, W1
0029A6  206000     MOV #0x600, W0
0029A8  700001     IOR W0, W1, W0
0029AA  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //开启接受中断
0029AC  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
0029AE  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
0029B0  800661     MOV IPC20, W1
0029B2  200700     MOV #0x70, W0
0029B4  700001     IOR W0, W1, W0
0029B6  880660     MOV W0, IPC20
27:                    IEC5bits.U3ERIE = 1;
0029B8  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0029BA  A84253     BSET 0x253, #2
29:                }
0029BC  FA8000     ULNK
0029BE  060000     RETURN
30:                
31:                void UART3_Open(void) {
0029C0  FA0000     LNK #0x0
32:                    U3MODEbits.UARTEN = 1; //使能串口
0029C2  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0029C4  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
0029C6  A8409E     BSET IEC5, #2
36:                }
0029C8  FA8000     ULNK
0029CA  060000     RETURN
37:                
38:                void UART3_Close(void) {
0029CC  FA0000     LNK #0x0
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
0029CE  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0029D0  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //使能串口发送    
0029D2  A9E251     BCLR 0x251, #7
43:                }
0029D4  FA8000     ULNK
0029D6  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
0029D8  FA0002     LNK #0x2
0029DA  784F00     MOV.B W0, [W14]
46:                    U3TXREG = ch;
0029DC  FB801E     ZE [W14], W0
0029DE  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
0029E0  000000     NOP
0029E2  801291     MOV U3STA, W1
0029E4  201000     MOV #0x100, W0
0029E6  608000     AND W1, W0, W0
0029E8  E00000     CP0 W0
0029EA  32FFFB     BRA Z, 0x29E2
48:                }
0029EC  FA8000     ULNK
0029EE  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
0029F0  FA0006     LNK #0x6
0029F2  980710     MOV W0, [W14+2]
0029F4  984741     MOV.B W1, [W14+4]
51:                    uint8_t bytes = 0;
0029F6  EB4000     CLR.B W0
0029F8  784F00     MOV.B W0, [W14]
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
0029FA  EB4000     CLR.B W0
0029FC  784F00     MOV.B W0, [W14]
0029FE  370006     BRA 0x2A0C
002A0A  E84F1E     INC.B [W14], [W14]
002A0C  90404E     MOV.B [W14+4], W0
002A0E  78409E     MOV.B [W14], W1
002A10  50CF80     SUB.B W1, W0, [W15]
002A12  39FFF6     BRA NC, 0x2A00
53:                        UART3_SendChar(*(str + bytes));
002A00  FB801E     ZE [W14], W0
002A02  90009E     MOV [W14+2], W1
002A04  408000     ADD W1, W0, W0
002A06  784010     MOV.B [W0], W0
002A08  07FFE7     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
002A14  78401E     MOV.B [W14], W0
57:                }
002A16  FA8000     ULNK
002A18  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
002A1A  FA0002     LNK #0x2
002A1C  780F00     MOV W0, [W14]
60:                    if (U3STAbits.URXDA) {
002A1E  801290     MOV U3STA, W0
002A20  600061     AND W0, #0x1, W0
002A22  E00000     CP0 W0
002A24  320006     BRA Z, 0x2A32
61:                        *ch = U3RXREG;
002A26  8012B0     MOV U3RXREG, W0
002A28  784080     MOV.B W0, W1
002A2A  78001E     MOV [W14], W0
002A2C  784801     MOV.B W1, [W0]
62:                        return true;
002A2E  B3C010     MOV.B #0x1, W0
002A30  370001     BRA 0x2A34
63:                    } else
64:                        return false;
002A32  EB4000     CLR.B W0
65:                }
002A34  FA8000     ULNK
002A36  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
002A38  FA0002     LNK #0x2
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
002A3A  EB4000     CLR.B W0
002A3C  784F00     MOV.B W0, [W14]
002A3E  370006     BRA 0x2A4C
002A4A  E84F1E     INC.B [W14], [W14]
002A4C  78401E     MOV.B [W14], W0
002A4E  504FE3     SUB.B W0, #0x3, [W15]
002A50  36FFF7     BRA LEU, 0x2A40
70:                        if (U3STAbits.URXDA) //没有接收到
002A40  801290     MOV U3STA, W0
002A42  600061     AND W0, #0x1, W0
002A44  E00000     CP0 W0
002A46  320001     BRA Z, 0x2A4A
71:                            BufferWrite_UART3();
002A48  07FA29     RCALL BufferWrite_UART3
72:                }
002A52  FA8000     ULNK
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/UART2.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART2.h"
3:                 
4:                 void UART2_Init(void) {
002890  FA0000     LNK #0x0
5:                     //已经为数字端口，
6:                     TRISDbits.TRISD2 = 1; //设置为输入
002892  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //设置为输出
002894  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //设置为输入
9:                     //    TRISDbits.TRISD2 = 0; //设置为输出
10:                
11:                    U2MODEbits.BRGH = 0; //波特率使用标准模式1:16
002896  A96230     BCLR U2MODE, #3
12:                    U2BRG = 51; //19200 103; //16000000/9600/16-1
002898  200330     MOV #0x33, W0
00289A  8811C0     MOV W0, U2BRG
13:                    U2MODEbits.PDSEL = 00; //无奇偶校验
00289C  801181     MOV U2MODE, W1
00289E  2FFF90     MOV #0xFFF9, W0
0028A0  608000     AND W1, W0, W0
0028A2  881180     MOV W0, U2MODE
14:                    U2MODEbits.STSEL = 0; //1位停止位
0028A4  A90230     BCLR U2MODE, #0
15:                
16:                    U2MODEbits.UARTEN = 1; //使能串口
0028A6  A8E231     BSET 0x231, #7
17:                
18:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0028A8  A84233     BSET 0x233, #2
19:                    U2STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
0028AA  801191     MOV U2STA, W1
0028AC  200C00     MOV #0xC0, W0
0028AE  700001     IOR W0, W1, W0
0028B0  881190     MOV W0, U2STA
20:                    IEC1bits.U2RXIE = 1; //开启接受中断
0028B2  A8C097     BSET 0x97, #6
21:                    IFS1bits.U2RXIF = 0; //清除接收中断
0028B4  A9C087     BCLR 0x87, #6
22:                    IEC4bits.U2ERIE = 1;
0028B6  A8409C     BSET IEC4, #2
23:                    IFS4bits.U2ERIF = 0;
0028B8  A9408C     BCLR IFS4, #2
24:                }
0028BA  FA8000     ULNK
0028BC  060000     RETURN
25:                
26:                void UART2_Open(void) {
0028BE  FA0000     LNK #0x0
27:                    U2MODEbits.UARTEN = 1; //使能串口
0028C0  A8E231     BSET 0x231, #7
28:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0028C2  A84233     BSET 0x233, #2
29:                    // IEC1bits.U2TXIE=1;
30:                    IEC1bits.U2RXIE = 1;
0028C4  A8C097     BSET 0x97, #6
31:                }
0028C6  FA8000     ULNK
0028C8  060000     RETURN
32:                
33:                void UART2_Close(void) {
0028CA  FA0000     LNK #0x0
34:                    // IEC1bits.U2TXIE=0;
35:                    IEC1bits.U2RXIE = 0;
0028CC  A9C097     BCLR 0x97, #6
36:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0028CE  A84233     BSET 0x233, #2
37:                    U2MODEbits.UARTEN = 0; //使能串口发送    
0028D0  A9E231     BCLR 0x231, #7
38:                }
0028D2  FA8000     ULNK
0028D4  060000     RETURN
39:                
40:                void UART2_SendChar(uint8_t ch) {
0028D6  FA0002     LNK #0x2
0028D8  784F00     MOV.B W0, [W14]
41:                    U2TXREG = ch;
0028DA  FB801E     ZE [W14], W0
0028DC  8811A0     MOV W0, U2TXREG
42:                    while (!U2STAbits.TRMT);
0028DE  000000     NOP
0028E0  801191     MOV U2STA, W1
0028E2  201000     MOV #0x100, W0
0028E4  608000     AND W1, W0, W0
0028E6  E00000     CP0 W0
0028E8  32FFFB     BRA Z, 0x28E0
43:                }
0028EA  FA8000     ULNK
0028EC  060000     RETURN
44:                
45:                uint8_t UART2_SendString(const uint8_t *str) {
0028EE  FA0004     LNK #0x4
0028F0  980710     MOV W0, [W14+2]
46:                    uint8_t bytes = 0;
0028F2  EB4000     CLR.B W0
0028F4  784F00     MOV.B W0, [W14]
47:                    while (*str != '\0') {
0028F6  370007     BRA 0x2906
002906  90001E     MOV [W14+2], W0
002908  784010     MOV.B [W0], W0
00290A  E00400     CP0.B W0
00290C  3AFFF5     BRA NZ, 0x28F8
48:                        UART2_SendChar(*str++);
0028F8  90001E     MOV [W14+2], W0
0028FA  784010     MOV.B [W0], W0
0028FC  90009E     MOV [W14+2], W1
0028FE  E80081     INC W1, W1
002900  980711     MOV W1, [W14+2]
002902  07FFE9     RCALL UART2_SendChar
49:                        bytes++;
002904  E84F1E     INC.B [W14], [W14]
50:                    }
51:                    return bytes;
00290E  78401E     MOV.B [W14], W0
52:                }
002910  FA8000     ULNK
002912  060000     RETURN
53:                
54:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
002914  FA0006     LNK #0x6
002916  980710     MOV W0, [W14+2]
002918  984741     MOV.B W1, [W14+4]
55:                    uint8_t bytes = 0;
00291A  EB4000     CLR.B W0
00291C  784F00     MOV.B W0, [W14]
56:                    while (bytes < len) {
00291E  370007     BRA 0x292E
00292E  90404E     MOV.B [W14+4], W0
002930  78409E     MOV.B [W14], W1
002932  50CF80     SUB.B W1, W0, [W15]
002934  39FFF5     BRA NC, 0x2920
57:                        UART2_SendChar(*str++);
002920  90001E     MOV [W14+2], W0
002922  784010     MOV.B [W0], W0
002924  90009E     MOV [W14+2], W1
002926  E80081     INC W1, W1
002928  980711     MOV W1, [W14+2]
00292A  07FFD5     RCALL UART2_SendChar
58:                        bytes++;
00292C  E84F1E     INC.B [W14], [W14]
59:                    }
60:                    return bytes;
002936  78401E     MOV.B [W14], W0
61:                }
002938  FA8000     ULNK
00293A  060000     RETURN
62:                
63:                bool UART2_ReceiveChar(uint8_t * ch) {
00293C  FA0002     LNK #0x2
00293E  780F00     MOV W0, [W14]
64:                    if (U2STAbits.URXDA) {
002940  801190     MOV U2STA, W0
002942  600061     AND W0, #0x1, W0
002944  E00000     CP0 W0
002946  320006     BRA Z, 0x2954
65:                        *ch = U2RXREG;
002948  8011B0     MOV U2RXREG, W0
00294A  784080     MOV.B W0, W1
00294C  78001E     MOV [W14], W0
00294E  784801     MOV.B W1, [W0]
66:                        return true;
002950  B3C010     MOV.B #0x1, W0
002952  370001     BRA 0x2956
67:                    } else
68:                        return false;
002954  EB4000     CLR.B W0
69:                }
002956  FA8000     ULNK
002958  060000     RETURN
70:                
71:                void U2Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
00295A  FA0002     LNK #0x2
72:                    uint8_t cnt;
73:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
00295C  EB4000     CLR.B W0
00295E  784F00     MOV.B W0, [W14]
002960  370006     BRA 0x296E
00296C  E84F1E     INC.B [W14], [W14]
00296E  78401E     MOV.B [W14], W0
002970  504FE3     SUB.B W0, #0x3, [W15]
002972  36FFF7     BRA LEU, 0x2962
74:                        if (U2STAbits.URXDA) //没有接收到
002962  801190     MOV U2STA, W0
002964  600061     AND W0, #0x1, W0
002966  E00000     CP0 W0
002968  320001     BRA Z, 0x296C
75:                            BufferWrite_UART2();
00296A  07FA7D     RCALL BufferWrite_UART2
76:                }
002974  FA8000     ULNK
77:                
78:                
79:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/TIM.c  ---------------------------------------
1:                 #include <TIM.h>
2:                 //用于显示LCD
3:                 
4:                 void TMR1_Initialize(void) {
002DB6  FA0000     LNK #0x0
5:                     //TSIDL disabled; TGATE disabled; TCS External; TSYNC disabled; TCKPS 1:1; TECS SOSC; TON enabled; 
6:                     T1CON = 0x8002;
002DB8  280020     MOV #0x8002, W0
002DBA  880820     MOV W0, T1CON
7:                     //TMR1 0; 
8:                     TMR1 = 0x0000;
002DBC  EF2100     CLR TMR1
9:                     //PR1 20; 
10:                    PR1 = 0x7918;
002DBE  279180     MOV #0x7918, W0
002DC0  880810     MOV W0, PR1
11:                
12:                    IFS0bits.T1IF = 0;
002DC2  A96084     BCLR IFS0, #3
13:                    IEC0bits.T1IE = 1;
002DC4  A86094     BSET IEC0, #3
14:                }
002DC6  FA8000     ULNK
002DC8  060000     RETURN
15:                //用于基本延时
16:                
17:                void TMR2_Initialize(void) {
002DCA  FA0000     LNK #0x0
18:                    //TSIDL disabled; TGATE disabled; TCS FOSC/2; TCKPS 1:256; T32 disabled; TON enabled; 
19:                    T2CON = 0x8030;
002DCC  280300     MOV #0x8030, W0
002DCE  880880     MOV W0, T2CON
20:                    //TMR2 0; 
21:                    TMR2 = 0x0000;
002DD0  EF2106     CLR TMR2
22:                    //Period Value = 10.000 ms; PR2 20000; 
23:                    PR2 = 0x4E20;
002DD2  24E200     MOV #0x4E20, W0
002DD4  880860     MOV W0, PR2
24:                    T2CONbits.TON = 0;
002DD6  A9E111     BCLR 0x111, #7
25:                    IFS0bits.T2IF = 0;
002DD8  A9E084     BCLR IFS0, #7
26:                }
002DDA  FA8000     ULNK
27:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/RTCC.c  --------------------------------------
1:                 #include "RTCC.h"
2:                 #include "WGC.h"
3:                 #include "RS485.h"
4:                 #include <xc.h>
5:                 
6:                 /*************************************
7:                 Function: RTC_Configuration 
8:                 Description: 实时时钟和闹钟初始化
9:                 Input: 无
10:                Output: 无
11:                 *************************************/
12:                void RTC_Init(void) {
001664  FA0008     LNK #0x8
13:                    uint8_t rtcc_tmp[7] = {0x20, 0x17, 0x10, 0x6, 0x12, 0x30, 0x07};
001666  290F71     MOV #0x90F7, W1
001668  090006     REPEAT #0x6
00166A  785F31     MOV.B [W1++], [W14++]
00166C  B1007E     SUB #0x7, W14
14:                    // Set the RTCWREN bit
15:                    __builtin_write_RTCWEN(); //unlock sequence
00166E  200550     MOV #0x55, W0
001670  883B30     MOV W0, NVMKEY
001672  200AA0     MOV #0xAA, W0
001674  883B30     MOV W0, NVMKEY
001676  A8A627     BSET 0x627, #5
16:                
17:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
001678  803131     MOV RCFGCAL, W1
00167A  203000     MOV #0x300, W0
00167C  700001     IOR W0, W1, W0
00167E  883130     MOV W0, RCFGCAL
18:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
001680  90401E     MOV.B [W14+1], W0
001682  FB8000     ZE W0, W0
001684  883120     MOV W0, RTCVAL
19:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
001686  90402E     MOV.B [W14+2], W0
001688  FB8000     ZE W0, W0
00168A  DD00C8     SL W0, #8, W1
00168C  90403E     MOV.B [W14+3], W0
00168E  FB8000     ZE W0, W0
001690  408000     ADD W1, W0, W0
001692  883120     MOV W0, RTCVAL
20:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
001694  90404E     MOV.B [W14+4], W0
001696  FB8000     ZE W0, W0
001698  883120     MOV W0, RTCVAL
21:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //分钟 秒 
00169A  90405E     MOV.B [W14+5], W0
00169C  FB8000     ZE W0, W0
00169E  DD00C8     SL W0, #8, W1
0016A0  90406E     MOV.B [W14+6], W0
0016A2  FB8000     ZE W0, W0
0016A4  408000     ADD W1, W0, W0
0016A6  883120     MOV W0, RTCVAL
22:                
23:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
24:                    //    RTCPWC = 0x0000;
25:                
26:                    //    ALCFGRPTbits.AMASK = 0b0110; //每日中断//0b0011; -1s 闹钟掩码设置 0x11每分钟闹钟中断一次
27:                    //    ALCFGRPTbits.CHIME = 1; //1 = 使能响铃； ARPT<7:0> 允许从 00h 进位到 FFh
28:                    ALCFGRPTbits.ALRMEN = 0; //关闭报警
0016A8  A9E623     BCLR 0x623, #7
29:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
0016AA  803111     MOV ALCFGRPT, W1
0016AC  2FCFF0     MOV #0xFCFF, W0
0016AE  608000     AND W1, W0, W0
0016B0  A09000     BSET W0, #9
0016B2  883110     MOV W0, ALCFGRPT
30:                    //        ALRMVAL = 0x0000; //none       
31:                    ALRMVAL = 0x0000; //month day 0001
0016B4  EF2620     CLR ALRMVAL
32:                    ALRMVAL = 0x0000; //week hour
0016B6  EF2620     CLR ALRMVAL
33:                    ALRMVAL = 0x0000; //minute second  0000
0016B8  EF2620     CLR ALRMVAL
34:                    //    ALRMVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
35:                    //    ALRMVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
36:                    //    ALRMVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
37:                    //    ALRMVAL = (rtcc_tmp[5] << 8) + 0x25; //rtcc_tmp[6] ; //0x3050; //分钟 秒 
38:                    //    ALCFGRPTbits.ARPT=0;
39:                    //    ALCFGRPTbits.ALRMEN = 1; //闹钟已使能 （每当 ARPT<7:0> = 00 和 CHIME = 0 时，发生闹钟事件后都自动清零）    
40:                
41:                    // ALRMEN enabled; ARPT 0; AMASK Every Second; CHIME enabled; ALRMPTR MIN_SEC; 
42:                    ALCFGRPT = 0xD800; //    every day once 
0016BA  2D8000     MOV #0xD800, W0
0016BC  883110     MOV W0, ALCFGRPT
43:                    //    ALCFGRPT = 0xC800;
44:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
45:                    RTCPWC = 0x0000;
0016BE  EF2628     CLR RTCPWC
46:                    IPC15bits.RTCIP = 6;
0016C0  800611     MOV IPC15, W1
0016C2  2F8FF0     MOV #0xF8FF, W0
0016C4  608080     AND W1, W0, W1
0016C6  206000     MOV #0x600, W0
0016C8  700001     IOR W0, W1, W0
0016CA  880610     MOV W0, IPC15
47:                    IFS3bits.RTCIF = 0; //外设相关的中断标志状态位清零
0016CC  A9C08B     BCLR 0x8B, #6
48:                    IEC3bits.RTCIE = 1; //开中断 =1
0016CE  A8C09B     BSET 0x9B, #6
49:                
50:                    RCFGCALbits.RTCEN = 1; //使能 RTCC 模块
0016D0  A8E627     BSET 0x627, #7
51:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
0016D2  A9A627     BCLR 0x627, #5
52:                }
0016D4  FA8000     ULNK
0016D6  060000     RETURN
53:                
54:                void RTC_Set_Alarm(struct tm initialTime) {//, uint8_t mask) {
0016D8  FA0000     LNK #0x0
0016DA  781F88     MOV W8, [W15++]
55:                    //只能在禁止闹钟 （ALRMEN = 0）时更改定时器和闹钟值。建议在RTCSYNC = 0 时更改 ALCFGRPT 寄存器和 CHIME 位。
56:                    __builtin_write_RTCWEN(); //unlock sequence
0016DC  200550     MOV #0x55, W0
0016DE  883B30     MOV W0, NVMKEY
0016E0  200AA0     MOV #0xAA, W0
0016E2  883B30     MOV W0, NVMKEY
0016E4  A8A627     BSET 0x627, #5
57:                
58:                    ALCFGRPTbits.ALRMEN = 0; //关闭闹钟
0016E6  A9E623     BCLR 0x623, #7
59:                    while (RCFGCALbits.RTCSYNC); //等待同步位
0016E8  000000     NOP
0016EA  803131     MOV RCFGCAL, W1
0016EC  210000     MOV #0x1000, W0
0016EE  608000     AND W1, W0, W0
0016F0  E00000     CP0 W0
0016F2  3AFFFB     BRA NZ, 0x16EA
60:                
61:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
0016F4  803111     MOV ALCFGRPT, W1
0016F6  2FCFF0     MOV #0xFCFF, W0
0016F8  608000     AND W1, W0, W0
0016FA  A09000     BSET W0, #9
0016FC  883110     MOV W0, ALCFGRPT
62:                    ALRMVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday);
0016FE  97B80E     MOV [W14-16], W0
001700  784000     MOV.B W0, W0
001702  07020C     RCALL DCH
001704  FB8000     ZE W0, W0
001706  DD0448     SL W0, #8, W8
001708  97B07E     MOV [W14-18], W0
00170A  784000     MOV.B W0, W0
00170C  070207     RCALL DCH
00170E  FB8000     ZE W0, W0
001710  440000     ADD W8, W0, W0
001712  883100     MOV W0, ALRMVAL
63:                    ALRMVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour);
001714  97B82E     MOV [W14-12], W0
001716  784000     MOV.B W0, W0
001718  070201     RCALL DCH
00171A  FB8000     ZE W0, W0
00171C  DD0448     SL W0, #8, W8
00171E  97B06E     MOV [W14-20], W0
001720  784000     MOV.B W0, W0
001722  0701FC     RCALL DCH
001724  FB8000     ZE W0, W0
001726  440000     ADD W8, W0, W0
001728  883100     MOV W0, ALRMVAL
64:                    ALRMVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec);
00172A  97B05E     MOV [W14-22], W0
00172C  784000     MOV.B W0, W0
00172E  0701F6     RCALL DCH
001730  FB8000     ZE W0, W0
001732  DD0448     SL W0, #8, W8
001734  97B04E     MOV [W14-24], W0
001736  784000     MOV.B W0, W0
001738  0701F1     RCALL DCH
00173A  FB8000     ZE W0, W0
00173C  440000     ADD W8, W0, W0
00173E  883100     MOV W0, ALRMVAL
65:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
001740  A9A627     BCLR 0x627, #5
66:                    ALCFGRPTbits.ALRMEN = 1; //开启闹钟
001742  A8E623     BSET 0x623, #7
67:                }
001744  78044F     MOV [--W15], W8
001746  FA8000     ULNK
001748  060000     RETURN
68:                
69:                /*************************************
70:                Function: RTC_ReadTime 
71:                Description: 获取实时时钟的时间
72:                Input: 4个u16类型数据 
73:                Output: 无
74:                 *************************************/
75:                bool RTC_Read_Time(struct tm*currentTime) {
00174A  FA0004     LNK #0x4
00174C  980710     MOV W0, [W14+2]
76:                    uint16_t time_tmp;
77:                    if (RCFGCALbits.RTCSYNC)//等待进入安全读取域
00174E  803132     MOV RCFGCAL, W2
001750  210000     MOV #0x1000, W0
001752  610000     AND W2, W0, W0
001754  E00000     CP0 W0
001756  320002     BRA Z, 0x175C
78:                        return false;
001758  EB4000     CLR.B W0
00175A  37006E     BRA 0x1838
79:                
80:                    __builtin_write_RTCWEN(); // Set the RTCWREN bit
00175C  200551     MOV #0x55, W1
00175E  883B31     MOV W1, NVMKEY
001760  200AA1     MOV #0xAA, W1
001762  883B31     MOV W1, NVMKEY
001764  A8A627     BSET 0x627, #5
81:                
82:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
001766  803131     MOV RCFGCAL, W1
001768  203000     MOV #0x300, W0
00176A  700001     IOR W0, W1, W0
00176C  883130     MOV W0, RCFGCAL
83:                    time_tmp = RTCVAL; //获取年份 
00176E  803121     MOV RTCVAL, W1
001770  780F01     MOV W1, [W14]
84:                    currentTime->tm_year = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
001772  200F00     MOV #0xF0, W0
001774  60001E     AND W0, [W14], W0
001776  DE0044     LSR W0, #4, W0
001778  B9006A     MUL.SU W0, #10, W0
00177A  780080     MOV W0, W1
00177C  78011E     MOV [W14], W2
00177E  61006F     AND W2, #0xF, W0
001780  408000     ADD W1, W0, W0
001782  780080     MOV W0, W1
001784  90001E     MOV [W14+2], W0
001786  980051     MOV W1, [W0+10]
85:                    RCFGCALbits.RTCPTR = 2;
001788  803131     MOV RCFGCAL, W1
00178A  2FCFF0     MOV #0xFCFF, W0
00178C  608000     AND W1, W0, W0
00178E  A09000     BSET W0, #9
001790  883130     MOV W0, RCFGCAL
86:                    time_tmp = RTCVAL; //获取月日
001792  803121     MOV RTCVAL, W1
001794  780F01     MOV W1, [W14]
87:                    currentTime->tm_mon = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
001796  78001E     MOV [W14], W0
001798  DE004C     LSR W0, #12, W0
00179A  B9006A     MUL.SU W0, #10, W0
00179C  780080     MOV W0, W1
00179E  78001E     MOV [W14], W0
0017A0  DE0048     LSR W0, #8, W0
0017A2  60006F     AND W0, #0xF, W0
0017A4  408000     ADD W1, W0, W0
0017A6  780080     MOV W0, W1
0017A8  90001E     MOV [W14+2], W0
0017AA  980041     MOV W1, [W0+8]
88:                    currentTime->tm_mday = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
0017AC  200F00     MOV #0xF0, W0
0017AE  60001E     AND W0, [W14], W0
0017B0  DE0044     LSR W0, #4, W0
0017B2  B9006A     MUL.SU W0, #10, W0
0017B4  780080     MOV W0, W1
0017B6  78011E     MOV [W14], W2
0017B8  61006F     AND W2, #0xF, W0
0017BA  408000     ADD W1, W0, W0
0017BC  780080     MOV W0, W1
0017BE  90001E     MOV [W14+2], W0
0017C0  980031     MOV W1, [W0+6]
89:                    RCFGCALbits.RTCPTR = 1;
0017C2  803131     MOV RCFGCAL, W1
0017C4  2FCFF0     MOV #0xFCFF, W0
0017C6  608000     AND W1, W0, W0
0017C8  A08000     BSET W0, #8
0017CA  883130     MOV W0, RCFGCAL
90:                    time_tmp = RTCVAL; //获取小时
0017CC  803121     MOV RTCVAL, W1
0017CE  780F01     MOV W1, [W14]
91:                    currentTime->tm_wday = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
0017D0  78001E     MOV [W14], W0
0017D2  DE004C     LSR W0, #12, W0
0017D4  B9006A     MUL.SU W0, #10, W0
0017D6  780080     MOV W0, W1
0017D8  78001E     MOV [W14], W0
0017DA  DE0048     LSR W0, #8, W0
0017DC  60006F     AND W0, #0xF, W0
0017DE  408000     ADD W1, W0, W0
0017E0  780080     MOV W0, W1
0017E2  90001E     MOV [W14+2], W0
0017E4  980061     MOV W1, [W0+12]
92:                    currentTime->tm_hour = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
0017E6  200F00     MOV #0xF0, W0
0017E8  60001E     AND W0, [W14], W0
0017EA  DE0044     LSR W0, #4, W0
0017EC  B9006A     MUL.SU W0, #10, W0
0017EE  780080     MOV W0, W1
0017F0  78011E     MOV [W14], W2
0017F2  61006F     AND W2, #0xF, W0
0017F4  408000     ADD W1, W0, W0
0017F6  780080     MOV W0, W1
0017F8  90001E     MOV [W14+2], W0
0017FA  980021     MOV W1, [W0+4]
93:                    RCFGCALbits.RTCPTR = 0;
0017FC  803131     MOV RCFGCAL, W1
0017FE  2FCFF0     MOV #0xFCFF, W0
001800  608000     AND W1, W0, W0
001802  883130     MOV W0, RCFGCAL
94:                    time_tmp = RTCVAL; //获取分钟秒
001804  803121     MOV RTCVAL, W1
001806  780F01     MOV W1, [W14]
95:                    currentTime->tm_min = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
001808  78001E     MOV [W14], W0
00180A  DE004C     LSR W0, #12, W0
00180C  B9006A     MUL.SU W0, #10, W0
00180E  780080     MOV W0, W1
001810  78001E     MOV [W14], W0
001812  DE0048     LSR W0, #8, W0
001814  60006F     AND W0, #0xF, W0
001816  408000     ADD W1, W0, W0
001818  780080     MOV W0, W1
00181A  90001E     MOV [W14+2], W0
00181C  980011     MOV W1, [W0+2]
96:                    currentTime->tm_sec = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
00181E  200F00     MOV #0xF0, W0
001820  60001E     AND W0, [W14], W0
001822  DE0044     LSR W0, #4, W0
001824  B9006A     MUL.SU W0, #10, W0
001826  780080     MOV W0, W1
001828  78011E     MOV [W14], W2
00182A  61006F     AND W2, #0xF, W0
00182C  408000     ADD W1, W0, W0
00182E  780080     MOV W0, W1
001830  90001E     MOV [W14+2], W0
001832  780801     MOV W1, [W0]
97:                    //    currentTime->tm_isdst
98:                    RCFGCALbits.RTCWREN = 0;
001834  A9A627     BCLR 0x627, #5
99:                
100:                   return true;
001836  B3C010     MOV.B #0x1, W0
101:               }
001838  FA8000     ULNK
00183A  060000     RETURN
102:               
103:               /*************************************
104:               Function: Check_RTCC 
105:               Description: 从仪表获取时间 赋值给RTCC
106:               Input: 6个u8类型数据
107:               Output: 无
108:                *************************************/
109:               void RTC_Set_Time(struct tm initialTime) {
00183C  FA0000     LNK #0x0
00183E  781F88     MOV W8, [W15++]
110:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
001840  200550     MOV #0x55, W0
001842  883B30     MOV W0, NVMKEY
001844  200AA0     MOV #0xAA, W0
001846  883B30     MOV W0, NVMKEY
001848  A8A627     BSET 0x627, #5
111:                   RCFGCALbits.RTCEN = 0; //Close RTCC
00184A  A9E627     BCLR 0x627, #7
112:               
113:                   IFS3bits.RTCIF = false;
00184C  A9C08B     BCLR 0x8B, #6
114:                   IEC3bits.RTCIE = 0;
00184E  A9C09B     BCLR 0x9B, #6
115:               
116:                   // set RTCC initial time
117:                   RCFGCALbits.RTCPTR = 3; // start the sequence
001850  803131     MOV RCFGCAL, W1
001852  203000     MOV #0x300, W0
001854  700001     IOR W0, W1, W0
001856  883130     MOV W0, RCFGCAL
118:                   RTCVAL = DCH(initialTime.tm_year); // YEAR
001858  97B81E     MOV [W14-14], W0
00185A  784000     MOV.B W0, W0
00185C  07015F     RCALL DCH
00185E  FB8000     ZE W0, W0
001860  883120     MOV W0, RTCVAL
119:                   RTCVAL = (DCH(initialTime.tm_mon) << 8) + DCH(initialTime.tm_mday); // MONTH-1/DAY-1
001862  97B80E     MOV [W14-16], W0
001864  784000     MOV.B W0, W0
001866  07015A     RCALL DCH
001868  FB8000     ZE W0, W0
00186A  DD0448     SL W0, #8, W8
00186C  97B07E     MOV [W14-18], W0
00186E  784000     MOV.B W0, W0
001870  070155     RCALL DCH
001872  FB8000     ZE W0, W0
001874  440000     ADD W8, W0, W0
001876  883120     MOV W0, RTCVAL
120:                   RTCVAL = (DCH(initialTime.tm_wday) << 8) + DCH(initialTime.tm_hour); // WEEKDAY/HOURS
001878  97B82E     MOV [W14-12], W0
00187A  784000     MOV.B W0, W0
00187C  07014F     RCALL DCH
00187E  FB8000     ZE W0, W0
001880  DD0448     SL W0, #8, W8
001882  97B06E     MOV [W14-20], W0
001884  784000     MOV.B W0, W0
001886  07014A     RCALL DCH
001888  FB8000     ZE W0, W0
00188A  440000     ADD W8, W0, W0
00188C  883120     MOV W0, RTCVAL
121:                   RTCVAL = (DCH(initialTime.tm_min) << 8) + DCH(initialTime.tm_sec); // MINUTES/SECONDS   
00188E  97B05E     MOV [W14-22], W0
001890  784000     MOV.B W0, W0
001892  070144     RCALL DCH
001894  FB8000     ZE W0, W0
001896  DD0448     SL W0, #8, W8
001898  97B04E     MOV [W14-24], W0
00189A  784000     MOV.B W0, W0
00189C  07013F     RCALL DCH
00189E  FB8000     ZE W0, W0
0018A0  440000     ADD W8, W0, W0
0018A2  883120     MOV W0, RTCVAL
122:               
123:                   // Enable RTCC, clear RTCWREN         
124:                   RCFGCALbits.RTCEN = 1;
0018A4  A8E627     BSET 0x627, #7
125:                   RCFGCALbits.RTCWREN = 0;
0018A6  A9A627     BCLR 0x627, #5
126:               
127:                   IEC3bits.RTCIE = 1;
0018A8  A8C09B     BSET 0x9B, #6
128:               }
0018AA  78044F     MOV [--W15], W8
0018AC  FA8000     ULNK
0018AE  060000     RETURN
129:               
130:               /*************************************
131:               Function: StartRTCC 
132:               Description: 
133:               Input: 
134:               Output: 
135:                *************************************/
136:               //void StartRTCC(void) {
137:               //
138:               //    IEC3bits.RTCIE = 1; //开启中断
139:               //    ALCFGRPTbits.ALRMEN = 1;
140:               //    RCFGCALbits.RTCEN = 1; //开启RTCC
141:               //}
142:               
143:               /*************************************
144:               Function: StopRTCC 
145:               Description: 
146:               Input: 
147:               Output: 
148:                *************************************/
149:               //void StopRTCC(void) {
150:               //    IEC3bits.RTCIE = 0; //关闭中断 
151:               //    ALCFGRPTbits.ALRMEN = 0;
152:               //    RCFGCALbits.RTCEN = 0; //关闭 RTCC 模块
153:               //}
154:               
155:               void PrintTime(void) {
0018B0  FA0026     LNK #0x26
156:                   struct tm time1;
157:                   uint8_t sendstr[20] = {"1234578901234567890"};
0018B2  290BE0     MOV #0x90BE, W0
0018B4  4700F2     ADD W14, #0x12, W1
0018B6  090013     REPEAT #0x13
0018B8  7858B0     MOV.B [W0++], [W1++]
0018BA  B10140     SUB #0x14, W0
158:                   while (!RTC_Read_Time(&time1));
0018BC  000000     NOP
0018BE  78000E     MOV W14, W0
0018C0  07FF44     RCALL RTC_Read_Time
0018C2  A20400     BTG.B W0, #0
0018C4  E00400     CP0.B W0
0018C6  3AFFFB     BRA NZ, 0x18BE
159:               
160:                   sendstr[0] = time1.tm_year / 10 + 0x30;
0018C8  9000DE     MOV [W14+10], W1
0018CA  2000A0     MOV #0xA, W0
0018CC  780100     MOV W0, W2
0018CE  090011     REPEAT #0x11
0018D0  D80082     DIV.SW W1, W2
0018D2  784000     MOV.B W0, W0
0018D4  B04300     ADD.B #0x30, W0
0018D6  985720     MOV.B W0, [W14+18]
161:                   sendstr[1] = time1.tm_year % 10 + 0x30;
0018D8  9000DE     MOV [W14+10], W1
0018DA  2000A0     MOV #0xA, W0
0018DC  780100     MOV W0, W2
0018DE  090011     REPEAT #0x11
0018E0  D80082     DIV.SW W1, W2
0018E2  FD0080     EXCH W0, W1
0018E4  784000     MOV.B W0, W0
0018E6  B04300     ADD.B #0x30, W0
0018E8  985730     MOV.B W0, [W14+19]
162:                   sendstr[2] = '/';
0018EA  B3C2F0     MOV.B #0x2F, W0
0018EC  985740     MOV.B W0, [W14+20]
163:                   sendstr[3] = time1.tm_mon / 10 + 0x30;
0018EE  9000CE     MOV [W14+8], W1
0018F0  2000A0     MOV #0xA, W0
0018F2  780100     MOV W0, W2
0018F4  090011     REPEAT #0x11
0018F6  D80082     DIV.SW W1, W2
0018F8  784000     MOV.B W0, W0
0018FA  B04300     ADD.B #0x30, W0
0018FC  985750     MOV.B W0, [W14+21]
164:                   sendstr[4] = time1.tm_mon % 10 + 0x30;
0018FE  9000CE     MOV [W14+8], W1
001900  2000A0     MOV #0xA, W0
001902  780100     MOV W0, W2
001904  090011     REPEAT #0x11
001906  D80082     DIV.SW W1, W2
001908  FD0080     EXCH W0, W1
00190A  784000     MOV.B W0, W0
00190C  B04300     ADD.B #0x30, W0
00190E  985760     MOV.B W0, [W14+22]
165:                   sendstr[5] = '/';
001910  B3C2F0     MOV.B #0x2F, W0
001912  985770     MOV.B W0, [W14+23]
166:                   sendstr[6] = time1.tm_mday / 10 + 0x30;
001914  9000BE     MOV [W14+6], W1
001916  2000A0     MOV #0xA, W0
001918  780100     MOV W0, W2
00191A  090011     REPEAT #0x11
00191C  D80082     DIV.SW W1, W2
00191E  784000     MOV.B W0, W0
001920  B04300     ADD.B #0x30, W0
001922  985F00     MOV.B W0, [W14+24]
167:                   sendstr[7] = time1.tm_mday % 10 + 0x30;
001924  9000BE     MOV [W14+6], W1
001926  2000A0     MOV #0xA, W0
001928  780100     MOV W0, W2
00192A  090011     REPEAT #0x11
00192C  D80082     DIV.SW W1, W2
00192E  FD0080     EXCH W0, W1
001930  784000     MOV.B W0, W0
001932  B04300     ADD.B #0x30, W0
001934  985F10     MOV.B W0, [W14+25]
168:                   sendstr[8] = '-';
001936  B3C2D0     MOV.B #0x2D, W0
001938  985F20     MOV.B W0, [W14+26]
169:                   sendstr[9] = time1.tm_hour / 10 + 0x30;
00193A  9000AE     MOV [W14+4], W1
00193C  2000A0     MOV #0xA, W0
00193E  780100     MOV W0, W2
001940  090011     REPEAT #0x11
001942  D80082     DIV.SW W1, W2
001944  784000     MOV.B W0, W0
001946  B04300     ADD.B #0x30, W0
001948  985F30     MOV.B W0, [W14+27]
170:                   sendstr[10] = time1.tm_hour % 10 + 0x30;
00194A  9000AE     MOV [W14+4], W1
00194C  2000A0     MOV #0xA, W0
00194E  780100     MOV W0, W2
001950  090011     REPEAT #0x11
001952  D80082     DIV.SW W1, W2
001954  FD0080     EXCH W0, W1
001956  784000     MOV.B W0, W0
001958  B04300     ADD.B #0x30, W0
00195A  985F40     MOV.B W0, [W14+28]
171:                   sendstr[11] = ':';
00195C  B3C3A0     MOV.B #0x3A, W0
00195E  985F50     MOV.B W0, [W14+29]
172:                   sendstr[12] = time1.tm_min / 10 + 0x30;
001960  90009E     MOV [W14+2], W1
001962  2000A0     MOV #0xA, W0
001964  780100     MOV W0, W2
001966  090011     REPEAT #0x11
001968  D80082     DIV.SW W1, W2
00196A  784000     MOV.B W0, W0
00196C  B04300     ADD.B #0x30, W0
00196E  985F60     MOV.B W0, [W14+30]
173:                   sendstr[13] = time1.tm_min % 10 + 0x30;
001970  90009E     MOV [W14+2], W1
001972  2000A0     MOV #0xA, W0
001974  780100     MOV W0, W2
001976  090011     REPEAT #0x11
001978  D80082     DIV.SW W1, W2
00197A  FD0080     EXCH W0, W1
00197C  784000     MOV.B W0, W0
00197E  B04300     ADD.B #0x30, W0
001980  985F70     MOV.B W0, [W14+31]
174:                   sendstr[14] = ':';
001982  B3C3A0     MOV.B #0x3A, W0
001984  986700     MOV.B W0, [W14+32]
175:                   sendstr[15] = time1.tm_sec / 10 + 0x30;
001986  78009E     MOV [W14], W1
001988  2000A0     MOV #0xA, W0
00198A  780100     MOV W0, W2
00198C  090011     REPEAT #0x11
00198E  D80082     DIV.SW W1, W2
001990  784000     MOV.B W0, W0
001992  B04300     ADD.B #0x30, W0
001994  986710     MOV.B W0, [W14+33]
176:                   sendstr[16] = time1.tm_sec % 10 + 0x30;
001996  78009E     MOV [W14], W1
001998  2000A0     MOV #0xA, W0
00199A  780100     MOV W0, W2
00199C  090011     REPEAT #0x11
00199E  D80082     DIV.SW W1, W2
0019A0  FD0080     EXCH W0, W1
0019A2  784000     MOV.B W0, W0
0019A4  B04300     ADD.B #0x30, W0
0019A6  986720     MOV.B W0, [W14+34]
177:                   sendstr[17] = '\n';
0019A8  B3C0A0     MOV.B #0xA, W0
0019AA  986730     MOV.B W0, [W14+35]
178:                   //        sendstr[18] = '\n';
179:                   //        sendstr[18] = '\0';
180:                   RS485SendString(sendstr, 18);
0019AC  470072     ADD W14, #0x12, W0
0019AE  B3C121     MOV.B #0x12, W1
0019B0  070873     RCALL RS485SendString
181:                   //        OSTimeDlyHMSM();
182:               }
0019B2  FA8000     ULNK
0019B4  060000     RETURN
183:               #ifdef DEBUG_RTCC_TIME
184:               
185:               void printrtccArg(void){
0019B6  FA00D2     LNK #0xD2
0019B8  781F88     MOV W8, [W15++]
186:                   uint8_t tmp[10];
187:                   uint8_t strings[200] = {'\0'}; //clear history data
0019BA  4700EA     ADD W14, #0xA, W1
0019BC  090063     REPEAT #0x63
0019BE  EB1880     CLR [W1++]
188:               
189:                   strcat(strings, "S1_t:");
0019C0  47046A     ADD W14, #0xA, W8
0019C2  47006A     ADD W14, #0xA, W0
0019C4  07FA79     RCALL 0xEB8
0019C6  440000     ADD W8, W0, W0
0019C8  200062     MOV #0x6, W2
0019CA  290D21     MOV #0x90D2, W1
0019CC  07FA64     RCALL 0xE96
190:                   my_itoa(WGCCON3bits.delay, tmp);
0019CE  804060     MOV WGCCON3bits, W0
0019D0  804072     MOV 0x80E, W2
0019D2  6100E1     AND W2, #0x1, W1
0019D4  780000     MOV W0, W0
0019D6  78008E     MOV W14, W1
0019D8  0701E2     RCALL my_itoa
191:                   strcat(strings, tmp);
0019DA  78008E     MOV W14, W1
0019DC  47006A     ADD W14, #0xA, W0
0019DE  07FA62     RCALL 0xEA4
192:               
193:                   strcat(strings, ";\tS1_c:");
0019E0  47046A     ADD W14, #0xA, W8
0019E2  47006A     ADD W14, #0xA, W0
0019E4  07FA69     RCALL 0xEB8
0019E6  440000     ADD W8, W0, W0
0019E8  200082     MOV #0x8, W2
0019EA  290D81     MOV #0x90D8, W1
0019EC  07FA54     RCALL 0xE96
194:                   my_itoa(WGCCON3bits.count, tmp);
0019EE  804070     MOV 0x80E, W0
0019F0  D10000     LSR W0, W0
0019F2  78008E     MOV W14, W1
0019F4  0701D4     RCALL my_itoa
195:                   strcat(strings, tmp);
0019F6  78008E     MOV W14, W1
0019F8  47006A     ADD W14, #0xA, W0
0019FA  07FA54     RCALL 0xEA4
196:               
197:               
198:                   strcat(strings, ";\r\nS2_t:");
0019FC  47046A     ADD W14, #0xA, W8
0019FE  47006A     ADD W14, #0xA, W0
001A00  07FA5B     RCALL 0xEB8
001A02  440000     ADD W8, W0, W0
001A04  200092     MOV #0x9, W2
001A06  290E01     MOV #0x90E0, W1
001A08  07FA46     RCALL 0xE96
199:                   my_itoa(WGCCON4bits.delay, tmp);
001A0A  804080     MOV WGCCON4bits, W0
001A0C  804092     MOV 0x812, W2
001A0E  6100E1     AND W2, #0x1, W1
001A10  780000     MOV W0, W0
001A12  78008E     MOV W14, W1
001A14  0701C4     RCALL my_itoa
200:                   strcat(strings, tmp);
001A16  78008E     MOV W14, W1
001A18  47006A     ADD W14, #0xA, W0
001A1A  07FA44     RCALL 0xEA4
201:               
202:                   strcat(strings, ";\tS2_c:");
001A1C  47046A     ADD W14, #0xA, W8
001A1E  47006A     ADD W14, #0xA, W0
001A20  07FA4B     RCALL 0xEB8
001A22  440000     ADD W8, W0, W0
001A24  200082     MOV #0x8, W2
001A26  290E91     MOV #0x90E9, W1
001A28  07FA36     RCALL 0xE96
203:                   my_itoa(WGCCON4bits.count, tmp);
001A2A  804090     MOV 0x812, W0
001A2C  D10000     LSR W0, W0
001A2E  78008E     MOV W14, W1
001A30  0701B6     RCALL my_itoa
204:                   strcat(strings, tmp);
001A32  78008E     MOV W14, W1
001A34  47006A     ADD W14, #0xA, W0
001A36  07FA36     RCALL 0xEA4
205:                   RS485SendString1(strings); //无法正确输出
001A38  47006A     ADD W14, #0xA, W0
001A3A  07084F     RCALL RS485SendString1
206:               }
001A3C  78044F     MOV [--W15], W8
001A3E  FA8000     ULNK
001A40  060000     RETURN
207:               
208:               void printrtccArg1(uint32_t settingtime) {
001A42  FA0040     LNK #0x40
001A44  781F88     MOV W8, [W15++]
001A46  981F60     MOV W0, [W14+60]
001A48  981F71     MOV W1, [W14+62]
209:                   uint8_t strings[50] = {'\0'}; //clear history data
001A4A  090018     REPEAT #0x18
001A4C  EB1F00     CLR [W14++]
001A4E  B1032E     SUB #0x32, W14
210:                   uint8_t tmp[10];
211:                   strcat(strings, "\r\nst:");
001A50  78040E     MOV W14, W8
001A52  78000E     MOV W14, W0
001A54  07FA31     RCALL 0xEB8
001A56  440000     ADD W8, W0, W0
001A58  200062     MOV #0x6, W2
001A5A  290F11     MOV #0x90F1, W1
001A5C  07FA1C     RCALL 0xE96
212:                   my_itoa(settingtime, tmp);
001A5E  90186E     MOV [W14+60], W0
001A60  200321     MOV #0x32, W1
001A62  40808E     ADD W1, W14, W1
001A64  07019C     RCALL my_itoa
213:                   strcat(strings, tmp);
001A66  200321     MOV #0x32, W1
001A68  40808E     ADD W1, W14, W1
001A6A  78000E     MOV W14, W0
001A6C  07FA1B     RCALL 0xEA4
214:                   RS485SendString1(strings); //无法正确输出
001A6E  78000E     MOV W14, W0
001A70  070834     RCALL RS485SendString1
215:                   //    my_itoa(WGCCON3bits.count,tmp);
216:                   //    strcat(strings,tmp);
217:               
218:                   //    WGCCON3bits.delay;
219:                   //    WGCCON4bits.count;
220:                   //    WGCCON4bits.delay;
221:               
222:                   //     my_itoa(); 
223:               }
001A72  78044F     MOV [--W15], W8
224:               
225:               #endif
226:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485通讯初始化
13:                Input: 无 
14:                Output: 无
15:                 *************************************/
16:                void RS485_Init(void) {
002A56  FA0000     LNK #0x0
17:                    RS485_TRIS = 0; //控制口设置位输出 485_CON
002A58  A942C9     BCLR 0x2C9, #2
18:                    RS485_IN_TRIS = 1; //设置为输入/
002A5A  A802C9     BSET 0x2C9, #0
19:                    RS485_OUT_TRIS = 0; //设置为输出
002A5C  A922C9     BCLR 0x2C9, #1
20:                    ANSBbits.ANSB8 = 1; //数字输入
002A5E  A804E3     BSET 0x4E3, #0
21:                    //    ANSBbits.ANSB9 = 1;
22:                
23:                    U1MODEbits.BRGH = 0; //16
002A60  A96220     BCLR U1MODE, #3
24:                    U1BRG = 103; //16000000/9600/16-1
002A62  200670     MOV #0x67, W0
002A64  881140     MOV W0, U1BRG
25:                
26:                    U1MODEbits.PDSEL = 00; //无奇偶校验
002A66  801101     MOV U1MODE, W1
002A68  2FFF90     MOV #0xFFF9, W0
002A6A  608000     AND W1, W0, W0
002A6C  881100     MOV W0, U1MODE
27:                    U1MODEbits.STSEL = 0; //1位停止位
002A6E  A90220     BCLR U1MODE, #0
28:                    U1MODEbits.UARTEN = 1; //使能串口
002A70  A8E221     BSET 0x221, #7
29:                
30:                    U1STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
002A72  A84223     BSET 0x223, #2
31:                    //    U1STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
32:                    //    IEC0bits.U1RXIE = 1; //开启接受中断
33:                    //    IFS0bits.U1RXIF = 0; //清除接收中断
34:                    //    IEC4bits.U1ERIE = 1; //开启错误中断
35:                    //    IFS4bits.U1ERIF = 0; //清楚错误中断
36:                }
002A74  FA8000     ULNK
002A76  060000     RETURN
37:                
38:                //void OpenAwake485(void) {//CN6电平通知中断唤醒设备
39:                //    RS485_RX_IN;
40:                //    CNEN1bits.CN6IE = 1; //RX1接受
41:                //}
42:                
43:                //void CloseAwake485(void) {
44:                //    CNEN1bits.CN6IE = 0;
45:                //}
46:                
47:                /*************************************
48:                Function: RS485_Send 待修改 
49:                Description: 485发送数据指令
50:                Input: 发送的数据 
51:                Output: 1:发送成功
52:                 *************************************/
53:                void RS485SendChar(const uint8_t dat) {
002A78  FA0002     LNK #0x2
002A7A  784F00     MOV.B W0, [W14]
54:                    RS485_CON = 1; //发送
002A7C  A842CD     BSET 0x2CD, #2
55:                    U1TXREG = dat;
002A7E  FB801E     ZE [W14], W0
002A80  881120     MOV W0, U1TXREG
56:                    while (!U1STAbits.TRMT); //while (!U2STAbits.TRMT);
002A82  000000     NOP
002A84  801111     MOV U1STA, W1
002A86  201000     MOV #0x100, W0
002A88  608000     AND W1, W0, W0
002A8A  E00000     CP0 W0
002A8C  32FFFB     BRA Z, 0x2A84
57:                    Delayms(10);
002A8E  2000A0     MOV #0xA, W0
002A90  07F8B9     RCALL Delayms
58:                    RS485_CON = 0; //接收
002A92  A942CD     BCLR 0x2CD, #2
59:                }
002A94  FA8000     ULNK
002A96  060000     RETURN
60:                
61:                /*************************************
62:                Function: RS485_SendString 
63:                Description: 485发送字符串
64:                Input: 字符串 字符串长度 
65:                Output: 无
66:                 *************************************/
67:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
002A98  FA0006     LNK #0x6
002A9A  980710     MOV W0, [W14+2]
002A9C  984741     MOV.B W1, [W14+4]
68:                    uint8_t count = 0;
002A9E  EB4000     CLR.B W0
002AA0  784F00     MOV.B W0, [W14]
69:                
70:                    RS485_CON = 1; //发送    
002AA2  A842CD     BSET 0x2CD, #2
71:                    Delay100ms(1);
002AA4  200010     MOV #0x1, W0
002AA6  07F8DE     RCALL Delay100ms
72:                    while (count < bytes) {
002AA8  37000D     BRA 0x2AC4
002AC4  90404E     MOV.B [W14+4], W0
002AC6  78409E     MOV.B [W14], W1
002AC8  50CF80     SUB.B W1, W0, [W15]
002ACA  39FFEF     BRA NC, 0x2AAA
73:                        U1TXREG = *(dat + count);
002AAA  FB801E     ZE [W14], W0
002AAC  90009E     MOV [W14+2], W1
002AAE  408000     ADD W1, W0, W0
002AB0  784010     MOV.B [W0], W0
002AB2  FB8000     ZE W0, W0
002AB4  881120     MOV W0, U1TXREG
74:                        while (!U1STAbits.TRMT);
002AB6  000000     NOP
002AB8  801111     MOV U1STA, W1
002ABA  201000     MOV #0x100, W0
002ABC  608000     AND W1, W0, W0
002ABE  E00000     CP0 W0
002AC0  32FFFB     BRA Z, 0x2AB8
75:                        count++;
002AC2  E84F1E     INC.B [W14], [W14]
76:                    }
77:                    Delay100ms(1);
002ACC  200010     MOV #0x1, W0
002ACE  07F8CA     RCALL Delay100ms
78:                    RS485_CON = 0; //接收
002AD0  A942CD     BCLR 0x2CD, #2
79:                    Delayms(1);
002AD2  200010     MOV #0x1, W0
002AD4  07F897     RCALL Delayms
80:                    //    OSTimeDlyHMSM(0, 0, 0, 1);
81:                }
002AD6  FA8000     ULNK
002AD8  060000     RETURN
82:                
83:                #ifdef DEBUG_485_SEND_STR
84:                /*************************************
85:                Function: RS485_SendString 
86:                Description: 485发送字符串
87:                Input: 字符串 字符串长度 
88:                Output: 无
89:                 *************************************/
90:                void RS485SendString1(const uint8_t* dat) {
002ADA  FA0004     LNK #0x4
002ADC  980710     MOV W0, [W14+2]
91:                    uint8_t count = 0;
002ADE  EB4000     CLR.B W0
002AE0  784F00     MOV.B W0, [W14]
92:                
93:                    RS485_CON = 1; //发送    
002AE2  A842CD     BSET 0x2CD, #2
94:                    Delay100ms(1);
002AE4  200010     MOV #0x1, W0
002AE6  07F8BE     RCALL Delay100ms
95:                    while (dat[count]!='\0') {
002AE8  37000D     BRA 0x2B04
002B04  FB801E     ZE [W14], W0
002B06  90009E     MOV [W14+2], W1
002B08  408000     ADD W1, W0, W0
002B0A  784010     MOV.B [W0], W0
002B0C  E00400     CP0.B W0
002B0E  3AFFED     BRA NZ, 0x2AEA
96:                        U1TXREG = *(dat + count);
002AEA  FB801E     ZE [W14], W0
002AEC  90009E     MOV [W14+2], W1
002AEE  408000     ADD W1, W0, W0
002AF0  784010     MOV.B [W0], W0
002AF2  FB8000     ZE W0, W0
002AF4  881120     MOV W0, U1TXREG
97:                        while (!U1STAbits.TRMT);
002AF6  000000     NOP
002AF8  801111     MOV U1STA, W1
002AFA  201000     MOV #0x100, W0
002AFC  608000     AND W1, W0, W0
002AFE  E00000     CP0 W0
002B00  32FFFB     BRA Z, 0x2AF8
98:                        count++;
002B02  E84F1E     INC.B [W14], [W14]
99:                    }
100:                   Delay100ms(1);
002B10  200010     MOV #0x1, W0
002B12  07F8A8     RCALL Delay100ms
101:                   RS485_CON = 0; //接收
002B14  A942CD     BCLR 0x2CD, #2
102:                   Delayms(1);
002B16  200010     MOV #0x1, W0
002B18  07F875     RCALL Delayms
103:                   //    OSTimeDlyHMSM(0, 0, 0, 1);
104:               }
002B1A  FA8000     ULNK
105:               #endif
106:               ///*************************************
107:               //Function: OpenRS485 
108:               //Description: 打开485通讯
109:               //Input: 字符串 字符串长度 
110:               //Output: 无
111:               // *************************************/
112:               //void OpenRS485(void) {
113:               //    IEC0bits.U1RXIE = 1;
114:               //    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
115:               //}
116:               //
117:               ///*************************************
118:               //Function: RS485_SendString 
119:               //Description: 关闭485通讯
120:               //Input: 字符串 字符串长度 
121:               //Output: 无
122:               // *************************************/
123:               //void CloseRS485(void) {
124:               //    IEC0bits.U1RXIE = 0;
125:               //    U1STAbits.UTXEN = 0; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
126:               //}
127:               /*************************************
128:               Function: RS485_test 
129:               Description: 485通讯测试
130:               Input: 无 
131:               Output: 无
132:                *************************************/
133:               //void RS485test(void)
134:               //{
135:               //    uint8_t dat='6';
136:               
137:               //RS485Send('T');
138:               //    if(!RS485Receive(&dat))
139:               //    {
140:               //        RS485Send(dat);
141:               //        RS485Send('T');
142:               //    }
143:               //}
144:               
145:               /*************************************
146:               Function: RS485_Receive  待修改
147:               Description: 485接收数据指令
148:               Input: 接收数据的指针 
149:               Output: 1：接收到数据
150:                ************************************
151:               bool RS485Receive(uint8_t* dat) {
152:               
153:                   bool b = true;
154:               //    uint8_t timeCount;
155:                   
156:               //    RS485_CON = 0; //接收
157:               
158:                   if (U1STAbits.OERR)
159:                       U1STAbits.OERR = 0;
160:                   
161:               //    gT23Count=0;
162:               //    T2CONbits.TON = 1;//开定时器 提高通讯稳定性
163:                  
164:                   while (!U1STAbits.URXDA) //没有接收到
165:                   {
166:               //        timeCount = gT23Count;
167:               //        if( T100msIsOver(timeCount,10) ) {//1s没有接收到数据
168:               //            b = false;
169:               //            break;
170:               //        }
171:                   }
172:               //    T2CONbits.TON = 0;//关定时器
173:               //    gT23Count=0;           //清除计数
174:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
175:               //    TMR2 = 0x0000;
176:                   
177:               //    if(b)
178:               //        *dat = U1RXREG;
179:               
180:                   return b;
181:               }*/
182:               
183:               
184:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/PPS.c  ---------------------------------------
1:                 /* 
2:                  * File:   PPS.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 2017年6月20日, 下午1:52
6:                  */
7:                 #include <xc.h>
8:                 
9:                 void PPSInit(void) {
002D24  FA0000     LNK #0x0
10:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
002D26  803A11     MOV OSCCON, W1
002D28  200BF0     MOV #0xBF, W0
002D2A  608100     AND W1, W0, W2
002D2C  200460     MOV #0x46, W0
002D2E  200571     MOV #0x57, W1
002D30  207423     MOV #0x742, W3
002D32  784980     MOV.B W0, [W3]
002D34  784981     MOV.B W1, [W3]
002D36  784982     MOV.B W2, [W3]
11:                    //    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
12:                    //    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
13:                    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
002D38  803641     MOV RPOR4, W1
002D3A  2C0FF0     MOV #0xC0FF, W0
002D3C  608080     AND W1, W0, W1
002D3E  203000     MOV #0x300, W0
002D40  700001     IOR W0, W1, W0
002D42  883640     MOV W0, RPOR4
14:                    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
002D44  803521     MOV RPINR18, W1
002D46  2FFC00     MOV #0xFFC0, W0
002D48  608000     AND W1, W0, W0
002D4A  A03000     BSET W0, #3
002D4C  883520     MOV W0, RPINR18
15:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
002D4E  8036B1     MOV RPOR11, W1
002D50  2FFC00     MOV #0xFFC0, W0
002D52  608000     AND W1, W0, W0
002D54  B30050     IOR #0x5, W0
002D56  8836B0     MOV W0, RPOR11
16:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX 
002D58  803531     MOV RPINR19, W1
002D5A  2FFC00     MOV #0xFFC0, W0
002D5C  608000     AND W1, W0, W0
002D5E  B30170     IOR #0x17, W0
002D60  883530     MOV W0, RPINR19
17:                    RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
002D62  8036D1     MOV RPOR13, W1
002D64  2FFC00     MOV #0xFFC0, W0
002D66  608000     AND W1, W0, W0
002D68  B301C0     IOR #0x1C, W0
002D6A  8836D0     MOV W0, RPOR13
18:                    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
002D6C  803511     MOV RPINR17, W1
002D6E  2C0FF0     MOV #0xC0FF, W0
002D70  608080     AND W1, W0, W1
002D72  213000     MOV #0x1300, W0
002D74  700001     IOR W0, W1, W0
002D76  883510     MOV W0, RPINR17
19:                    //    RPINR3bits.
20:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
21:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
22:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
002D78  803A10     MOV OSCCON, W0
002D7A  780100     MOV W0, W2
002D7C  A06002     BSET W2, #6
002D7E  200460     MOV #0x46, W0
002D80  200571     MOV #0x57, W1
002D82  207423     MOV #0x742, W3
002D84  784980     MOV.B W0, [W3]
002D86  784981     MOV.B W1, [W3]
002D88  784982     MOV.B W2, [W3]
23:                }
002D8A  FA8000     ULNK
24:                
25:                //RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
26:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX
27:                
28:                
29:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年6月6日, 上午8:48
6:                  */
7:                 #include "SerialBuffer.h"
8:                 #include "includes.h"
9:                 #include "stdbool.h"
10:                #include "stdio.h"
11:                #include "RTCC.h"
12:                #include "LCD.h"
13:                #include "WGC.h"
14:                //#include "Debug.h"
15:                
16:                extern volatile uint8_t i2c1_state;
17:                extern I2C1_Buffer i2c_buf;
18:                static uint8_t T0_Cnt;
19:                
20:                /*************************************
21:                Function: RTCC中断
22:                Description: 
23:                Input: 无 
24:                Output: 无
25:                 *************************************/
26:                void __attribute__((interrupt, no_auto_psv)) _ISR _RTCCInterrupt(void) {
000310  F80036     PUSH RCOUNT
000312  BE9F80     MOV.D W0, [W15++]
000314  BE9F82     MOV.D W2, [W15++]
000316  BE9F84     MOV.D W4, [W15++]
000318  BE9F86     MOV.D W6, [W15++]
00031A  FA0002     LNK #0x2
27:                    uint8_t tmp = 0;
00031C  EB4000     CLR.B W0
00031E  784F00     MOV.B W0, [W14]
28:                    //    WGCCON2bits.Send_FLAG = 1; //添加时间计算避免时间上的误差
29:                //    RS485SendString
30:                    tmp = CalaAlarmTime(); //计算下次闹钟的时间
000320  0710E5     RCALL CalaAlarmTime
000322  784F00     MOV.B W0, [W14]
31:                    rtime=tmp;
000324  FB801E     ZE [W14], W0
000326  EB0080     CLR W1
000328  8840E0     MOV W0, rtime
00032A  8840F1     MOV W1, 0x81E
32:                //    printrtccArg1(tmp); //中断里面不要放硬件输出
33:                    SetNextAlarm(tmp); //设置下次闹钟时间
00032C  FB801E     ZE [W14], W0
00032E  EB0080     CLR W1
000330  071153     RCALL SetNextAlarm
34:                #ifdef DEBUG_RTCC_TIME
35:                    WGCCON2bits.SET_TIME_TEST_FLAG = 1; //测试定时时间，用于串口显示输出，便于测试
000332  A8C80B     BSET 0x80B, #6
36:                #endif
37:                    IFS3bits.RTCIF = false;
000334  A9C08B     BCLR 0x8B, #6
38:                }
000336  FA8000     ULNK
000338  BE034F     MOV.D [--W15], W6
00033A  BE024F     MOV.D [--W15], W4
00033C  BE014F     MOV.D [--W15], W2
00033E  BE004F     MOV.D [--W15], W0
000340  F90036     POP RCOUNT
000342  064000     RETFIE
39:                
40:                /*************************************
41:                Function: 外部终端0
42:                Description: 电压检测
43:                Input: 无 
44:                Output: 无
45:                 *************************************/
46:                void __attribute__((interrupt, no_auto_psv))_ISR _INT0Interrupt(void) {
000344  FA0000     LNK #0x0
47:                
48:                    IFS0bits.INT0IF = 0;
000346  A90084     BCLR IFS0, #0
49:                }
000348  FA8000     ULNK
00034A  064000     RETFIE
50:                /*************************************
51:                Function: 定时器中断 
52:                Description: 用于在GPRS上线过程中，定时时间
53:                Input: 无 
54:                Output: 无
55:                 *************************************/
56:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
57:                //    gT3Count++;
58:                //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
59:                //}
60:                
61:                /*************************************
62:                Function: 定时器中断 
63:                Description: 用于485通讯，时间延时
64:                Input: 无 
65:                Output: 无
66:                 *************************************/
67:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
68:                //    while (!U1STAbits.RIDLE);
69:                //    PC_Cop();
70:                //    T2CONbits.TON = 0;
71:                //    TMR2 = 0;
72:                //    FLagArgbits.TestFlag = 0; //退出调试模式
73:                //    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
74:                //}
75:                
76:                /*************************************
77:                Function: 定时器中断 
78:                Description: LCD显示
79:                Input: 无 
80:                Output: 无
81:                 *************************************/
82:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {
00034C  FEA000     PUSH.S
00034E  F80036     PUSH RCOUNT
000350  BE9F84     MOV.D W4, [W15++]
000352  BE9F86     MOV.D W6, [W15++]
000354  F80032     PUSH DSRPAG
000356  F80034     PUSH DSWPAG
000358  200014     MOV #0x1, W4
00035A  8801A4     MOV W4, DSWPAG
00035C  202004     MOV #0x200, W4
00035E  880194     MOV W4, DSRPAG
000360  FA0016     LNK #0x16
83:                    struct tm tmptr;
84:                    uint32_t time;
85:                    if (T0_Cnt++ % 2) {//周期为2s，1s显示压力值，1s显示时间
000362  BFC828     MOV.B T0_Cnt, WREG
000364  FB8080     ZE W0, W1
000366  6080E1     AND W1, #0x1, W1
000368  784081     MOV.B W1, W1
00036A  E84000     INC.B W0, W0
00036C  B7E828     MOV.B WREG, T0_Cnt
00036E  E00401     CP0.B W1
000370  320007     BRA Z, 0x380
86:                        NUMS_SHOW(12345678, 0);
000372  EB4100     CLR.B W2
000374  2614E0     MOV #0x614E, W0
000376  200BC1     MOV #0xBC, W1
000378  0708A3     RCALL NUMS_SHOW
87:                        DP_SHOW(1);
00037A  B3C010     MOV.B #0x1, W0
00037C  0708D6     RCALL DP_SHOW
00037E  37000F     BRA 0x39E
88:                    } else {
89:                        DP_SHOW(0);
000380  EB4000     CLR.B W0
000382  0708D3     RCALL DP_SHOW
90:                        ClrNum();
000384  070924     RCALL ClrNum
91:                        while (!RTC_Read_Time(&tmptr));
000386  000000     NOP
000388  470064     ADD W14, #0x4, W0
00038A  0709DF     RCALL RTC_Read_Time
00038C  A20400     BTG.B W0, #0
00038E  E00400     CP0.B W0
000390  3AFFFB     BRA NZ, 0x388
92:                        time = tmptr.tm_hour;
000392  90004E     MOV [W14+8], W0
000394  DE80CF     ASR W0, #15, W1
000396  BE8F00     MOV.D W0, [W14]
93:                        //        time = (DCH(tmptr.tm_hour) * 10000) + DCH(tmptr.tm_min) * 100 + DCH(tmptr.tm_sec);
94:                        NUMS_SHOW(time, 1);
000398  B3C012     MOV.B #0x1, W2
00039A  BE001E     MOV.D [W14], W0
00039C  070891     RCALL NUMS_SHOW
95:                    }
96:                    LED_Toggle();
00039E  0714B3     RCALL LED_Toggle
97:                    IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
0003A0  A96084     BCLR IFS0, #3
98:                }
0003A2  FA8000     ULNK
0003A4  F90034     POP DSWPAG
0003A6  F90032     POP DSRPAG
0003A8  BE034F     MOV.D [--W15], W6
0003AA  BE024F     MOV.D [--W15], W4
0003AC  F90036     POP RCOUNT
0003AE  FE8000     POP.S
0003B0  064000     RETFIE
99:                
100:               /*************************************
101:               Function: 定时器t4中断 
102:               Description: 用于采集数据的任务
103:               Input: 无 
104:               Output: 无
105:                *************************************/
106:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
107:               //    if (FLagArgbits.LowPowerGetDataFlag) {
108:               //        FLagArgbits.LowPowerGetDataFlag = 0;
109:               //        GetValueTask(LowPowerData); //获取报警时仪表的通讯数据
110:               //    } else if (FLagArgbits.TestGetDataFlag) {
111:               //        FLagArgbits.TestGetDataFlag = 0;
112:               //        GetValueTask(TestData); //获取报警时仪表的通讯数据
113:               //    } else
114:               //        GetValueTask(SampleData); //获取仪表的通讯数据
115:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //保存脉冲总量
116:               //
117:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
118:               //    CloseTime4();
119:               //}
120:               
121:               /*************************************
122:               Function: 电平变化中断 
123:               Description: 获取脉冲的任务
124:               Input: 无 
125:               Output: 无
126:                *************************************/
127:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //提醒更换电池
128:               //    if (S1) {//通过第二次上升获取数据
129:               //        gPulseCount++; //脉冲数+1
130:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//如果开启T1定时器而且是第二次进入，则采集数据
131:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //单位ms
132:               //            if (gPulseTime < 2000)//采集时间小于2s
133:               //                gPulseTime = 0;
134:               //            else {
135:               //                FLagArgbits.PulseTimeFlag = 1; // 如果已经获取到脉冲时间，那么需要关闭定时器
136:               //                FLagArgbits.T1CountFlag = 0;
137:               //                T1CONbits.TON = 0;
138:               //            }
139:               //        }
140:               //        TMR1 = 0;
141:               //        gT1Count = 0;
142:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //通过上升沿，关闭FLagArgbits.T1CountLastFlag
143:               //    }
144:               //    IFS1bits.CNIF = 0;
145:               //}
146:               
147:               /*************************************
148:               Function: UART1接收中断
149:               Description: 485通讯
150:               Input: 无 
151:               Output: 无
152:                *************************************/
153:               void __attribute__((__interrupt__, __auto_psv__)) _U1RXInterrupt(void) {
0003B2  F80036     PUSH RCOUNT
0003B4  BE9F80     MOV.D W0, [W15++]
0003B6  BE9F82     MOV.D W2, [W15++]
0003B8  BE9F84     MOV.D W4, [W15++]
0003BA  BE9F86     MOV.D W6, [W15++]
0003BC  F80032     PUSH DSRPAG
0003BE  F80034     PUSH DSWPAG
0003C0  200010     MOV #0x1, W0
0003C2  8801A0     MOV W0, DSWPAG
0003C4  202000     MOV #0x200, W0
0003C6  880190     MOV W0, DSRPAG
0003C8  FA0002     LNK #0x2
154:                   uint8_t cnt = 0;
0003CA  EB4000     CLR.B W0
0003CC  784F00     MOV.B W0, [W14]
155:                   //    OSIntEnter();
156:                   for (cnt = 0; cnt < 4; cnt++)
0003CE  EB4000     CLR.B W0
0003D0  784F00     MOV.B W0, [W14]
0003D2  370006     BRA 0x3E0
0003DE  E84F1E     INC.B [W14], [W14]
0003E0  78401E     MOV.B [W14], W0
0003E2  504FE3     SUB.B W0, #0x3, [W15]
0003E4  36FFF7     BRA LEU, 0x3D4
157:                       if (U1STAbits.URXDA == 1) //没有接收到
0003D4  801110     MOV U1STA, W0
0003D6  600061     AND W0, #0x1, W0
0003D8  E00000     CP0 W0
0003DA  320001     BRA Z, 0x3DE
158:                           BufferWrite_UART1();
0003DC  070D2B     RCALL BufferWrite_UART1
159:                   IFS0bits.U1RXIF = 0;
0003E6  A96085     BCLR 0x85, #3
160:                   //    OSIntExit();
161:               }
0003E8  FA8000     ULNK
0003EA  F90034     POP DSWPAG
0003EC  F90032     POP DSRPAG
0003EE  BE034F     MOV.D [--W15], W6
0003F0  BE024F     MOV.D [--W15], W4
0003F2  BE014F     MOV.D [--W15], W2
0003F4  BE004F     MOV.D [--W15], W0
0003F6  F90036     POP RCOUNT
0003F8  064000     RETFIE
162:               
163:               /*************************************
164:               Function: UART2接收中断
165:               Description: GPRS通讯
166:               Input: 无 
167:               Output: 无
168:                *************************************/
169:               void __attribute__((__interrupt__, __auto_psv__)) _U2RXInterrupt(void) {
0003FA  F80036     PUSH RCOUNT
0003FC  BE9F80     MOV.D W0, [W15++]
0003FE  BE9F82     MOV.D W2, [W15++]
000400  BE9F84     MOV.D W4, [W15++]
000402  BE9F86     MOV.D W6, [W15++]
000404  F80032     PUSH DSRPAG
000406  F80034     PUSH DSWPAG
000408  200010     MOV #0x1, W0
00040A  8801A0     MOV W0, DSWPAG
00040C  202000     MOV #0x200, W0
00040E  880190     MOV W0, DSRPAG
000410  FA0002     LNK #0x2
170:                   uint8_t cnt = 0;
000412  EB4000     CLR.B W0
000414  784F00     MOV.B W0, [W14]
171:                   //    OSIntEnter();
172:                   for (cnt = 0; cnt < 4; cnt++)
000416  EB4000     CLR.B W0
000418  784F00     MOV.B W0, [W14]
00041A  370006     BRA 0x428
000426  E84F1E     INC.B [W14], [W14]
000428  78401E     MOV.B [W14], W0
00042A  504FE3     SUB.B W0, #0x3, [W15]
00042C  36FFF7     BRA LEU, 0x41C
173:                       if (U2STAbits.URXDA == 1) //没有接收到        
00041C  801190     MOV U2STA, W0
00041E  600061     AND W0, #0x1, W0
000420  E00000     CP0 W0
000422  320001     BRA Z, 0x426
174:                           BufferWrite_UART2();
000424  070D20     RCALL BufferWrite_UART2
175:                   IFS1bits.U2RXIF = 0;
00042E  A9C087     BCLR 0x87, #6
176:                   //    OSIntExit();
177:               }
000430  FA8000     ULNK
000432  F90034     POP DSWPAG
000434  F90032     POP DSRPAG
000436  BE034F     MOV.D [--W15], W6
000438  BE024F     MOV.D [--W15], W4
00043A  BE014F     MOV.D [--W15], W2
00043C  BE004F     MOV.D [--W15], W0
00043E  F90036     POP RCOUNT
000440  064000     RETFIE
178:               
179:               /*************************************
180:               Function: UART2接收中断
181:               Description: GPRS通讯
182:               Input: 无 
183:               Output: 无
184:                *************************************/
185:               void __attribute__((__interrupt__, __auto_psv__)) _U3RXInterrupt(void) {
000442  F80036     PUSH RCOUNT
000444  BE9F80     MOV.D W0, [W15++]
000446  BE9F82     MOV.D W2, [W15++]
000448  BE9F84     MOV.D W4, [W15++]
00044A  BE9F86     MOV.D W6, [W15++]
00044C  F80032     PUSH DSRPAG
00044E  F80034     PUSH DSWPAG
000450  200010     MOV #0x1, W0
000452  8801A0     MOV W0, DSWPAG
000454  202000     MOV #0x200, W0
000456  880190     MOV W0, DSRPAG
000458  FA0002     LNK #0x2
186:                   uint8_t cnt = 0;
00045A  EB4000     CLR.B W0
00045C  784F00     MOV.B W0, [W14]
187:                   //    OSIntEnter();
188:                   for (cnt = 0; cnt < 4; cnt++)
00045E  EB4000     CLR.B W0
000460  784F00     MOV.B W0, [W14]
000462  370006     BRA 0x470
00046E  E84F1E     INC.B [W14], [W14]
000470  78401E     MOV.B [W14], W0
000472  504FE3     SUB.B W0, #0x3, [W15]
000474  36FFF7     BRA LEU, 0x464
189:                       if (U3STAbits.URXDA == 1) //没有接收到        
000464  801290     MOV U3STA, W0
000466  600061     AND W0, #0x1, W0
000468  E00000     CP0 W0
00046A  320001     BRA Z, 0x46E
190:                           BufferWrite_UART3();
00046C  070D17     RCALL BufferWrite_UART3
191:                   IFS5bits.U3RXIF = 0;
000476  A9408E     BCLR IFS5, #2
192:                   //    OSIntExit();
193:               }
000478  FA8000     ULNK
00047A  F90034     POP DSWPAG
00047C  F90032     POP DSRPAG
00047E  BE034F     MOV.D [--W15], W6
000480  BE024F     MOV.D [--W15], W4
000482  BE014F     MOV.D [--W15], W2
000484  BE004F     MOV.D [--W15], W0
000486  F90036     POP RCOUNT
000488  064000     RETFIE
194:               
195:               /*************************************
196:               Function: UART2发送中断
197:               Description: GPRS通讯
198:               Input: 无 
199:               Output: 无
200:                *************************************/
201:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
202:               //    u8 cnt = 0;
203:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
204:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //发送数据
205:               //
206:               //        while (!U2STAbits.TRMT);
207:               //        cnt++;
208:               //    }
209:               //    IFS1bits.U2TXIF = 0;
210:               //}
211:               
212:               /*************************************
213:               Function: UART1错误终端
214:               Description: 无
215:               Input: 无 
216:               Output: 无
217:                *************************************/
218:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
00048A  781F80     MOV W0, [W15++]
00048C  FA0000     LNK #0x0
219:                   //    OSIntEnter();
220:                   if (U1STAbits.OERR == 1)
00048E  801110     MOV U1STA, W0
000490  600062     AND W0, #0x2, W0
000492  E00000     CP0 W0
000494  320001     BRA Z, 0x498
221:                       U1STAbits.OERR = 0;
000496  A92222     BCLR U1STA, #1
222:                   IFS4bits.U1ERIF = 0;
000498  A9208C     BCLR IFS4, #1
223:                   //    OSIntExit();
224:               }
00049A  FA8000     ULNK
00049C  78004F     MOV [--W15], W0
00049E  064000     RETFIE
225:               
226:               /*************************************
227:               Function: UART2错误中断
228:               Description: 无
229:               Input: 无 
230:               Output: 无
231:                *************************************/
232:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
0004A0  781F80     MOV W0, [W15++]
0004A2  FA0000     LNK #0x0
233:                   //    OSIntEnter();
234:                   if (U2STAbits.OERR == 1)
0004A4  801190     MOV U2STA, W0
0004A6  600062     AND W0, #0x2, W0
0004A8  E00000     CP0 W0
0004AA  320001     BRA Z, 0x4AE
235:                       U2STAbits.OERR = 0;
0004AC  A92232     BCLR U2STA, #1
236:                   IFS4bits.U2ERIF = 0;
0004AE  A9408C     BCLR IFS4, #2
237:                   //    OSIntExit();
238:               }
0004B0  FA8000     ULNK
0004B2  78004F     MOV [--W15], W0
0004B4  064000     RETFIE
239:               
240:               /*************************************
241:               Function: UART2错误中断
242:               Description: 无
243:               Input: 无 
244:               Output: 无
245:                *************************************/
246:               void __attribute__((interrupt, no_auto_psv)) _U3ErrInterrupt(void) {
0004B6  781F80     MOV W0, [W15++]
0004B8  FA0000     LNK #0x0
247:                   //    OSIntEnter();
248:                   if (U3STAbits.OERR == 1)
0004BA  801290     MOV U3STA, W0
0004BC  600062     AND W0, #0x2, W0
0004BE  E00000     CP0 W0
0004C0  320001     BRA Z, 0x4C4
249:                       U3STAbits.OERR = 0;
0004C2  A92252     BCLR U3STA, #1
250:                   IFS5bits.U3ERIF = 0;
0004C4  A9208E     BCLR IFS5, #1
251:                   //    OSIntExit();
252:               }
0004C6  FA8000     ULNK
0004C8  78004F     MOV [--W15], W0
0004CA  064000     RETFIE
253:               
254:               /*************************************
255:               Function: 默认终端
256:               Description: 无
257:               Input: 无 
258:               Output: 无
259:                *************************************/
260:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
0004CC  781F80     MOV W0, [W15++]
0004CE  FA0000     LNK #0x0
261:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
0004D0  800400     MOV INTCON1, W0
0004D2  600064     AND W0, #0x4, W0
0004D4  E00000     CP0 W0
0004D6  320001     BRA Z, 0x4DA
0004D8  A94080     BCLR INTCON1, #2
262:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
0004DA  800400     MOV INTCON1, W0
0004DC  600068     AND W0, #0x8, W0
0004DE  E00000     CP0 W0
0004E0  320001     BRA Z, 0x4E4
0004E2  A96080     BCLR INTCON1, #3
263:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
0004E4  800400     MOV INTCON1, W0
0004E6  600070     AND W0, #0x10, W0
0004E8  E00000     CP0 W0
0004EA  320001     BRA Z, 0x4EE
0004EC  A98080     BCLR INTCON1, #4
264:                   asm("GOTO __reset");
0004EE  040200     GOTO 0x200
0004F0  000000     NOP
265:               }
0004F2  FA8000     ULNK
0004F4  78004F     MOV [--W15], W0
0004F6  064000     RETFIE
266:               
267:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
0004F8  BE9F80     MOV.D W0, [W15++]
0004FA  BE9F82     MOV.D W2, [W15++]
0004FC  FA0000     LNK #0x0
268:                   //    OSIntEnter();
269:                   static uint16_t i2c_operatcode;
270:                   static uint8_t* pi2c_buf_ptr;
271:                   static uint16_t i2c_address;
272:                   static uint8_t i2c_bytes_left;
273:                   static I2C_Flag i2c_flag;
274:                   static bool i2c_IsResart; //设备是否重启
275:               
276:                   IFS1bits.MI2C1IF = 0; //清楚中断标志位
0004FE  A92086     BCLR IFS1, #1
277:                   if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
000500  801041     MOV I2C1STAT, W1
000502  200800     MOV #0x80, W0
000504  608000     AND W1, W0, W0
000506  E00000     CP0 W0
000508  320002     BRA Z, 0x50E
278:                       I2C1STATbits.IWCOL = 0;
00050A  A9E208     BCLR I2C1STAT, #7
279:                       //        i2c_address_restart = 0;
280:                       //是否需要清楚数据
281:                       return;
00050C  3700F4     BRA 0x6F6
282:                   }
283:                   /* Handle the correct i2c state */
284:                   switch (i2c1_state) {
00050E  BFC838     MOV.B i2c1_state, WREG
000510  FB8000     ZE W0, W0
000512  DE80CF     ASR W0, #15, W1
000514  2000D2     MOV #0xD, W2
000516  200003     MOV #0x0, W3
000518  500F82     SUB W0, W2, [W15]
00051A  588F83     SUBB W1, W3, [W15]
00051C  3E00EC     BRA GTU, 0x6F6
00051E  016000     BRA W0
000520  37000D     BRA 0x53C
000522  370023     BRA 0x56A
000524  370029     BRA 0x578
000526  37007D     BRA 0x622
000528  370052     BRA 0x5CE
00052A  3700E5     BRA 0x6F6
00052C  3700C5     BRA 0x6B8
00052E  370098     BRA 0x660
000530  3700A5     BRA 0x67C
000532  3700BD     BRA 0x6AE
000534  3700A7     BRA 0x684
000536  3700DF     BRA 0x6F6
000538  3700DE     BRA 0x6F6
00053A  3700C2     BRA 0x6C0
285:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
286:                       {
287:                           if (i2c_bytes_left == 0) {//如果数据数据不为0的话
00053C  BFC829     MOV.B i2c_bytes_left, WREG
00053E  E00400     CP0.B W0
000540  3A00D9     BRA NZ, 0x6F4
288:                               //                I2C1CONbits.SEN = 1; // 发送启动条件
289:                               //            } else {
290:                               I2C1CONbits.SEN = 1; // 发送启动条件
000542  A80206     BSET I2C1CON, #0
291:                               i2c_operatcode = i2c_buf.operatcode; //赋值操作码
000544  209360     MOV #0x936, W0
000546  784010     MOV.B [W0], W0
000548  FB8000     ZE W0, W0
00054A  884150     MOV W0, i2c_operatcode
292:                               i2c_address = i2c_buf.address; //赋值地址
00054C  8049C0     MOV 0x938, W0
00054E  884160     MOV W0, i2c_address
293:                               i2c_bytes_left = i2c_buf.length; //赋值长度
000550  2093A0     MOV #0x93A, W0
000552  784010     MOV.B [W0], W0
000554  B7E829     MOV.B WREG, i2c_bytes_left
294:                               pi2c_buf_ptr = i2c_buf.pbuffer; //赋值数据地址
000556  8049E0     MOV 0x93C, W0
000558  884170     MOV W0, pi2c_buf_ptr
295:                               i2c_flag = i2c_buf.flag; //将设备选择和工作模式均赋值
00055A  2093E0     MOV #0x93E, W0
00055C  784110     MOV.B [W0], W2
00055E  208301     MOV #0x830, W1
000560  784882     MOV.B W2, [W1]
296:                               i2c_IsResart = 0;
000562  EF6831     CLR.B i2c_IsResart
297:                               i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
000564  B3C020     MOV.B #0x2, W0
000566  B7E838     MOV.B WREG, i2c1_state
298:                           }
299:                           break;
000568  3700C6     BRA 0x6F6
0006F4  000000     NOP
300:                       }
301:                       case S_MASTER_RESTART:
302:                       {
303:                           I2C1CONbits.RSEN = 1; // 发送启动条件
00056A  A82206     BSET I2C1CON, #1
304:                           i2c_bytes_left = i2c_buf.length; //赋值长度
00056C  2093A0     MOV #0x93A, W0
00056E  784010     MOV.B [W0], W0
000570  B7E829     MOV.B WREG, i2c_bytes_left
305:                           i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
000572  B3C020     MOV.B #0x2, W0
000574  B7E838     MOV.B WREG, i2c1_state
306:                           break;
000576  3700BF     BRA 0x6F6
307:                       }
308:                       case S_MASTER_SEND_ADDR:
309:                       {
310:                           if (!i2c_flag.F_IsSelectiveMode) {//表示不带地址读取数据 && i2c_IsResart) {
000578  BFC830     MOV.B i2c_flag, WREG
00057A  604061     AND.B W0, #0x1, W0
00057C  E00400     CP0.B W0
00057E  3A000F     BRA NZ, 0x59E
311:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
000580  BFC830     MOV.B i2c_flag, WREG
000582  604064     AND.B W0, #0x4, W0
000584  E00400     CP0.B W0
000586  320006     BRA Z, 0x594
312:                                   I2C1TRN = i2c_operatcode | 0x01;
000588  804150     MOV i2c_operatcode, W0
00058A  A00000     BSET W0, #0
00058C  881010     MOV W0, I2C1TRN
313:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作
00058E  B3C070     MOV.B #0x7, W0
000590  B7E838     MOV.B WREG, i2c1_state
314:                               } else {
315:                                   I2C1TRN = i2c_operatcode;
000594  804150     MOV i2c_operatcode, W0
000596  881010     MOV W0, I2C1TRN
316:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
000598  B3C030     MOV.B #0x3, W0
00059A  B7E838     MOV.B WREG, i2c1_state
317:                               }
318:                           } else if (!i2c_IsResart) {//如果是重启后的操作码，则根据操作码最后一个字节处理；反之,这
00059E  BFC831     MOV.B i2c_IsResart, WREG
0005A0  A20400     BTG.B W0, #0
0005A2  E00400     CP0.B W0
0005A4  320005     BRA Z, 0x5B0
319:                               I2C1TRN = i2c_operatcode;
0005A6  804150     MOV i2c_operatcode, W0
0005A8  881010     MOV W0, I2C1TRN
320:                               i2c1_state = S_MASTER_SEND_ADDR_16BIT;
0005AA  B3C040     MOV.B #0x4, W0
0005AC  B7E838     MOV.B WREG, i2c1_state
321:                           } else {//就是跟读地址读写数据的后半段
322:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
0005B0  BFC830     MOV.B i2c_flag, WREG
0005B2  604064     AND.B W0, #0x4, W0
0005B4  E00400     CP0.B W0
0005B6  320006     BRA Z, 0x5C4
323:                                   I2C1TRN = i2c_operatcode | 0x01;
0005B8  804150     MOV i2c_operatcode, W0
0005BA  A00000     BSET W0, #0
0005BC  881010     MOV W0, I2C1TRN
324:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作                    
0005BE  B3C070     MOV.B #0x7, W0
0005C0  B7E838     MOV.B WREG, i2c1_state
325:                               } else {
326:                                   I2C1TRN = i2c_operatcode;
0005C4  804150     MOV i2c_operatcode, W0
0005C6  881010     MOV W0, I2C1TRN
327:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
0005C8  B3C030     MOV.B #0x3, W0
0005CA  B7E838     MOV.B WREG, i2c1_state
328:                               }
329:                           }
330:                           break;
000592  3700B1     BRA 0x6F6
00059C  3700AC     BRA 0x6F6
0005AE  3700A3     BRA 0x6F6
0005C2  370099     BRA 0x6F6
0005CC  370094     BRA 0x6F6
331:                       }
332:                       case S_MASTER_SEND_ADDR_16BIT:
333:                       {
334:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
0005CE  801041     MOV I2C1STAT, W1
0005D0  280000     MOV #0x8000, W0
0005D2  608000     AND W1, W0, W0
0005D4  E00000     CP0 W0
0005D6  320005     BRA Z, 0x5E2
335:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
0005D8  A9E209     BCLR 0x209, #7
336:                               I2C1CONbits.PEN = 1; // 发送停止条件 
0005DA  A84206     BSET I2C1CON, #2
337:                               IFS1bits.MI2C1IF = 0; //清除标志
0005DC  A92086     BCLR IFS1, #1
338:                               i2c1_state = S_MASTER_IDLE; //状态设置位空闲
0005DE  EF6838     CLR.B i2c1_state
339:                           } else {
340:                               if (i2c_flag.F_Is16bitsDevice) {
0005E2  BFC830     MOV.B i2c_flag, WREG
0005E4  604062     AND.B W0, #0x2, W0
0005E6  E00400     CP0.B W0
0005E8  320009     BRA Z, 0x5FC
341:                                   i2c_flag.F_Is16bitsDevice = 0;
0005EA  A92830     BCLR i2c_flag, #1
342:                                   I2C1TRN = (uint8_t) (i2c_address >> 8); //发送16位高地址 
0005EC  804160     MOV i2c_address, W0
0005EE  DE0048     LSR W0, #8, W0
0005F0  784000     MOV.B W0, W0
0005F2  FB8000     ZE W0, W0
0005F4  881010     MOV W0, I2C1TRN
343:                                   i2c1_state = S_MASTER_SEND_ADDR_16BIT;
0005F6  B3C040     MOV.B #0x4, W0
0005F8  B7E838     MOV.B WREG, i2c1_state
344:                                   //                    break;
345:                               } else {
346:                                   I2C1TRN = (uint8_t) (i2c_address & 0x00FF); //发送16位低地址 
0005FC  804160     MOV i2c_address, W0
0005FE  784000     MOV.B W0, W0
000600  FB8000     ZE W0, W0
000602  881010     MOV W0, I2C1TRN
347:                                   if (i2c_flag.F_WriteOrRead)//如果是读取指令的话
000604  BFC830     MOV.B i2c_flag, WREG
000606  604064     AND.B W0, #0x4, W0
000608  E00400     CP0.B W0
00060A  320008     BRA Z, 0x61C
348:                                   {
349:                                       i2c_IsResart = 1;
00060C  B3C010     MOV.B #0x1, W0
00060E  B7E831     MOV.B WREG, i2c_IsResart
350:                                       //                        I2C1CONbits.RSEN = 1; // 发送启动条件
351:                                       i2c_operatcode |= 0x01; //将地址设置为读取
000610  804150     MOV i2c_operatcode, W0
000612  A00000     BSET W0, #0
000614  884150     MOV W0, i2c_operatcode
352:                                       i2c1_state = S_MASTER_RESTART;
000616  B3C010     MOV.B #0x1, W0
000618  B7E838     MOV.B WREG, i2c1_state
353:                                   } else
354:                                       i2c1_state = S_MASTER_SEND_DATA;
00061C  B3C030     MOV.B #0x3, W0
00061E  B7E838     MOV.B WREG, i2c1_state
355:                               }
356:                           }
357:                           break;
0005E0  37008A     BRA 0x6F6
0005FA  37007D     BRA 0x6F6
00061A  37006D     BRA 0x6F6
000620  37006A     BRA 0x6F6
358:                       }
359:                       case S_MASTER_SEND_DATA:
360:                       {
361:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
000622  801041     MOV I2C1STAT, W1
000624  280000     MOV #0x8000, W0
000626  608000     AND W1, W0, W0
000628  E00000     CP0 W0
00062A  320005     BRA Z, 0x636
362:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
00062C  A9E209     BCLR 0x209, #7
363:                               I2C1CONbits.PEN = 1; // 发送停止条件 
00062E  A84206     BSET I2C1CON, #2
364:                               IFS1bits.MI2C1IF = 0; //清除标志
000630  A92086     BCLR IFS1, #1
365:                               i2c1_state = S_MASTER_IDLE; //状态设置位空闲
000632  EF6838     CLR.B i2c1_state
000634  370015     BRA 0x660
366:                           } else {
367:                               if (i2c_bytes_left-- == 0U) {//判断数据是否发送完毕
000636  BFC829     MOV.B i2c_bytes_left, WREG
000638  FB8080     ZE W0, W1
00063A  E90081     DEC W1, W1
00063C  DE08CF     LSR W1, #15, W1
00063E  784081     MOV.B W1, W1
000640  E94000     DEC.B W0, W0
000642  B7E829     MOV.B WREG, i2c_bytes_left
000644  E00401     CP0.B W1
000646  320005     BRA Z, 0x652
368:                                   I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000648  A84206     BSET I2C1CON, #2
369:                                   IFS1bits.MI2C1IF = 0; //清除标志
00064A  A92086     BCLR IFS1, #1
370:                                   i2c1_state = S_MASTER_SEND_STOP; //状态设置为空闲
00064C  B3C060     MOV.B #0x6, W0
00064E  B7E838     MOV.B WREG, i2c1_state
371:                               } else {
372:                                   I2C1TRN = *pi2c_buf_ptr++; //发送数据
000652  804170     MOV pi2c_buf_ptr, W0
000654  784090     MOV.B [W0], W1
000656  FB8081     ZE W1, W1
000658  881011     MOV W1, I2C1TRN
00065A  E80000     INC W0, W0
00065C  884170     MOV W0, pi2c_buf_ptr
373:                               }
374:                               break;
000650  370052     BRA 0x6F6
00065E  37004B     BRA 0x6F6
375:                           }
376:                       }
377:                       case S_MASTER_ACK_ADDR://如果是读操作的话，
378:                       {
379:                           if (I2C1STATbits.ACKSTAT) { //如果上次检测到NACK
000660  801041     MOV I2C1STAT, W1
000662  280000     MOV #0x8000, W0
000664  608000     AND W1, W0, W0
000666  E00000     CP0 W0
000668  320005     BRA Z, 0x674
380:                               I2C1CONbits.PEN = 1; //启动停止条件
00066A  A84206     BSET I2C1CON, #2
381:                               IFS1bits.MI2C1IF = 0; //清除标志
00066C  A92086     BCLR IFS1, #1
382:                               i2c1_state = S_MASTER_IDLE;
00066E  EF6838     CLR.B i2c1_state
383:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
000670  A9E209     BCLR 0x209, #7
384:                           } else {
385:                               I2C1CONbits.RCEN = 1; //启动接受
000674  A86206     BSET I2C1CON, #3
386:                               i2c1_state = S_MASTER_ACK_RCV_DATA; //状态为设置为接受数据
000676  B3C0A0     MOV.B #0xA, W0
000678  B7E838     MOV.B WREG, i2c1_state
387:                           }
388:                           break;
000672  370041     BRA 0x6F6
00067A  37003D     BRA 0x6F6
389:                       }
390:                       case S_MASTER_RCV_DATA:
391:                       {
392:                           i2c1_state = S_MASTER_ACK_RCV_DATA; //发送接受数据ACK
00067C  B3C0A0     MOV.B #0xA, W0
00067E  B7E838     MOV.B WREG, i2c1_state
393:                           I2C1CONbits.RCEN = 1; //使能接收
000680  A86206     BSET I2C1CON, #3
394:                           break;
000682  370039     BRA 0x6F6
395:                       }
396:                       case S_MASTER_ACK_RCV_DATA:
397:                       {
398:                           *pi2c_buf_ptr++ = I2C1RCV; //接收数据
000684  804170     MOV pi2c_buf_ptr, W0
000686  801001     MOV I2C1RCV, W1
000688  784081     MOV.B W1, W1
00068A  784801     MOV.B W1, [W0]
00068C  E80000     INC W0, W0
00068E  884170     MOV W0, pi2c_buf_ptr
399:                           if (--i2c_bytes_left) {
000690  BFC829     MOV.B i2c_bytes_left, WREG
000692  E94000     DEC.B W0, W0
000694  B7E829     MOV.B WREG, i2c_bytes_left
000696  BFC829     MOV.B i2c_bytes_left, WREG
000698  E00400     CP0.B W0
00069A  320004     BRA Z, 0x6A4
400:                               I2C1CONbits.ACKDT = 0; //发送ACK
00069C  A9A206     BCLR I2C1CON, #5
401:                               i2c1_state = S_MASTER_RCV_DATA; //启动接收
00069E  B3C080     MOV.B #0x8, W0
0006A0  B7E838     MOV.B WREG, i2c1_state
0006A2  370003     BRA 0x6AA
402:                           } else {
403:               
404:                               // Yes, it's the last byte.  Don't ack it
405:                               // Flag that we will nak the data
406:                               I2C1CONbits.ACKDT = 1; // I2C ACK data control bit.
0006A4  A8A206     BSET I2C1CON, #5
407:               
408:                               //            I2C1_FunctionComplete();
409:                               i2c1_state = S_MASTER_RCV_STOP;
0006A6  B3C090     MOV.B #0x9, W0
0006A8  B7E838     MOV.B WREG, i2c1_state
410:                               //                break; //退出接收
411:                           }
412:               
413:                           // Initiate the acknowledge
414:                           I2C1CONbits.ACKEN = 1; // I2C 发送ACK .
0006AA  A88206     BSET I2C1CON, #4
415:                           break;
0006AC  370024     BRA 0x6F6
416:                       }
417:                       case S_MASTER_RCV_STOP:
418:                       {
419:                           I2C1CONbits.ACKDT = 0;
0006AE  A9A206     BCLR I2C1CON, #5
420:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
0006B0  A84206     BSET I2C1CON, #2
421:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
422:                           i2c1_state = S_MASTER_Finish;
0006B2  B3C0D0     MOV.B #0xD, W0
0006B4  B7E838     MOV.B WREG, i2c1_state
423:                           break;
0006B6  37001F     BRA 0x6F6
424:                       }
425:                       case S_MASTER_SEND_STOP:
426:                       {
427:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
0006B8  A84206     BSET I2C1CON, #2
428:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
429:                           i2c1_state = S_MASTER_Finish;
0006BA  B3C0D0     MOV.B #0xD, W0
0006BC  B7E838     MOV.B WREG, i2c1_state
430:                           break;
0006BE  37001B     BRA 0x6F6
431:                       }
432:                       case S_MASTER_Finish:
433:                       {
434:                           i2c_operatcode = 0;
0006C0  EF282A     CLR i2c_operatcode
435:                           pi2c_buf_ptr = NULL;
0006C2  EF282E     CLR pi2c_buf_ptr
436:                           i2c_address = 0;
0006C4  EF282C     CLR i2c_address
437:                           i2c_bytes_left = 0;
0006C6  EF6829     CLR.B i2c_bytes_left
438:                           i2c_flag.F_Is16bitsDevice = i2c_flag.F_IsSelectiveMode = i2c_flag.F_WriteOrRead = 0;
0006C8  A94830     BCLR i2c_flag, #2
0006CA  804180     MOV i2c_flag, W0
0006CC  DE0042     LSR W0, #2, W0
0006CE  604061     AND.B W0, #0x1, W0
0006D0  604061     AND.B W0, #0x1, W0
0006D2  208301     MOV #0x830, W1
0006D4  784091     MOV.B [W1], W1
0006D6  A10401     BCLR.B W1, #0
0006D8  70C000     IOR.B W1, W0, W0
0006DA  B7E830     MOV.B WREG, i2c_flag
0006DC  804180     MOV i2c_flag, W0
0006DE  604061     AND.B W0, #0x1, W0
0006E0  604061     AND.B W0, #0x1, W0
0006E2  404000     ADD.B W0, W0, W0
0006E4  208301     MOV #0x830, W1
0006E6  784091     MOV.B [W1], W1
0006E8  A11401     BCLR.B W1, #1
0006EA  70C000     IOR.B W1, W0, W0
0006EC  B7E830     MOV.B WREG, i2c_flag
439:                           i2c_IsResart = 0; //设备是否重启
0006EE  EF6831     CLR.B i2c_IsResart
440:                           break;
0006F0  000000     NOP
0006F2  370001     BRA 0x6F6
441:                       }
442:               
443:                           //        default:
444:                           //
445:                           //            // This case should not happen, if it does then
446:                           //            // terminate the transfer
447:                           //            //    i2c1_object.i2cErrors++;
448:                           //        {
449:                           //            I2C1CONbits.PEN = 1; // I2C STOP control bit.  
450:                           //            //            IFS1bits.MI2C1IF = 0; //清除标志
451:                           //            //            i2c1_state = S_MASTER_IDLE;
452:                           //            break;
453:                           //        }
454:                   }
455:                   //    OSIntExit();
456:               }
0006F6  FA8000     ULNK
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/LCD.c  ---------------------------------------
1:                 #include "LCD.h"
2:                 
3:                 //数字符号
4:                 const uint8_t LCD_NUM[10][8] = {
5:                     {N1A, N1B, N1C, N1D, N1E, N1F, 0xFF, N1G}, //[0]0xFF后面数据为HIDE
6:                     {N1B, N1C, 0xFF, N1A, N1D, N1E, N1F, N1G}, //[1]
7:                     {N1A, N1B, N1G, N1E, N1D, 0xFF, N1C, N1F}, //[2]
8:                     {N1A, N1B, N1C, N1D, N1G, 0xFF, N1E, N1F}, //[3]
9:                     {N1B, N1C, N1F, N1G, 0xFF, N1A, N1D, N1E}, //[4]
10:                    {N1A, N1C, N1D, N1F, N1G, 0xFF, N1B, N1E}, //[5]
11:                    {N1A, N1C, N1D, N1E, N1F, N1G, 0xFF, N1B}, //[6]
12:                    {N1A, N1B, N1C, 0xFF, N1D, N1E, N1F, N1G}, //[7]
13:                    {N1A, N1B, N1C, N1D, N1E, N1F, N1G, 0xFF}, //[8]
14:                    {N1A, N1B, N1C, N1D, N1F, N1G, 0xFF, N1E}, //[9]
15:                    //    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, //[10]
16:                };
17:                //数字偏移量
18:                const uint8_t LCD_NUM_OFFSET[7] = {0, 2, 8, 10, 12, 14, 16};
19:                
20:                static void LCD_Show(uint8_t value, bool operation);
21:                static void NUM_SHOW(uint8_t num, uint8_t pos);
22:                
23:                void LCD_Init(void) {
001106  FA0000     LNK #0x0
24:                    LCDSE0 = 0xFFFF; //设置SEG0-15为段驱动引脚
001108  EB8000     SETM W0
00110A  882C40     MOV W0, LCDSE0
25:                    LCDSE1 = 0x0003; //设置SEG16-17为段驱动引脚
00110C  200030     MOV #0x3, W0
00110E  882C50     MOV W0, LCDSE1
26:                    LCDDATA0 = LCDDATA1 = LCDDATA4 = LCDDATA5 = 0;
001110  EF259A     CLR LCDDATA5
001112  802CD0     MOV LCDDATA5, W0
001114  882CC0     MOV W0, LCDDATA4
001116  802CC0     MOV LCDDATA4, W0
001118  882C90     MOV W0, LCDDATA1
00111A  802C90     MOV LCDDATA1, W0
00111C  882C80     MOV W0, LCDDATA0
27:                    LCDDATA8 = LCDDATA9 = LCDDATA16 = LCDDATA17 = 0;
00111E  EF25B2     CLR LCDDATA17
001120  802D90     MOV LCDDATA17, W0
001122  882D80     MOV W0, LCDDATA16
001124  802D80     MOV LCDDATA16, W0
001126  882D10     MOV W0, LCDDATA9
001128  802D10     MOV LCDDATA9, W0
00112A  882D00     MOV W0, LCDDATA8
28:                    LCDREG = 0x0004;
00112C  200040     MOV #0x4, W0
00112E  882C00     MOV W0, LCDREG
29:                    //	LCDREF=0x07F0;  //external
30:                    LCDREF = 0x80FF; //internal regsistor ladder
001130  280FF0     MOV #0x80FF, W0
001132  882C10     MOV W0, LCDREF
31:                    LCDPS = 0x0002;
001134  200020     MOV #0x2, W0
001136  882C30     MOV W0, LCDPS
32:                    LCDREFbits.LCDCST = 0;
001138  802C11     MOV LCDREF, W1
00113A  2C7FF0     MOV #0xC7FF, W0
00113C  608000     AND W1, W0, W0
00113E  882C10     MOV W0, LCDREF
33:                    LCDCON = 0x800B; // 4 common
001140  2800B0     MOV #0x800B, W0
001142  882C20     MOV W0, LCDCON
34:                }
001144  FA8000     ULNK
001146  060000     RETURN
35:                
36:                //void LCD_ShowTest(void) {
37:                //    LCD_Show(8, 0); //25
38:                //    Delay1s(1);
39:                //}
40:                
41:                void LCD_ShowTest(uint8_t value, bool operation) {
001148  FA0002     LNK #0x2
00114A  784F00     MOV.B W0, [W14]
00114C  984711     MOV.B W1, [W14+1]
42:                    LCD_Show(value, operation); //25
00114E  90409E     MOV.B [W14+1], W1
001150  78401E     MOV.B [W14], W0
001152  070002     RCALL _LCD_Show
43:                    //    Delay1s(1);
44:                }
001154  FA8000     ULNK
001156  060000     RETURN
45:                //子函数
46:                
47:                static void LCD_Show(uint8_t value, bool operation) {
001158  FA0004     LNK #0x4
00115A  984720     MOV.B W0, [W14+2]
00115C  984731     MOV.B W1, [W14+3]
48:                    uint8_t com = value / SegCnt; //获取公共码
00115E  90402E     MOV.B [W14+2], W0
001160  FB8080     ZE W0, W1
001162  200120     MOV #0x12, W0
001164  780100     MOV W0, W2
001166  090011     REPEAT #0x11
001168  D88082     DIV.UW W1, W2
00116A  784F00     MOV.B W0, [W14]
49:                    uint8_t seg = value % SegCnt; //获取段码
00116C  90402E     MOV.B [W14+2], W0
00116E  FB8080     ZE W0, W1
001170  200120     MOV #0x12, W0
001172  780100     MOV W0, W2
001174  090011     REPEAT #0x11
001176  D88082     DIV.UW W1, W2
001178  FD0080     EXCH W0, W1
00117A  984710     MOV.B W0, [W14+1]
50:                
51:                    switch (com) {
00117C  FB801E     ZE [W14], W0
00117E  500FE1     SUB W0, #0x1, [W15]
001180  320039     BRA Z, 0x11F4
001182  500FE1     SUB W0, #0x1, [W15]
001184  3C0003     BRA GT, 0x118C
001186  E00000     CP0 W0
001188  320006     BRA Z, 0x1196
00118A  3700C1     BRA 0x130E
00118C  500FE2     SUB W0, #0x2, [W15]
00118E  320061     BRA Z, 0x1252
001190  500FE3     SUB W0, #0x3, [W15]
001192  32008E     BRA Z, 0x12B0
001194  3700BC     BRA 0x130E
52:                        case COM0:
53:                        {
54:                            if (seg > 15)
001196  90401E     MOV.B [W14+1], W0
001198  504FEF     SUB.B W0, #0xF, [W15]
00119A  360017     BRA LEU, 0x11CA
55:                                LCD_Set(1, seg % 16, operation);
00119C  90403E     MOV.B [W14+3], W0
00119E  E00400     CP0.B W0
0011A0  320009     BRA Z, 0x11B4
0011A2  90401E     MOV.B [W14+1], W0
0011A4  FB8000     ZE W0, W0
0011A6  60006F     AND W0, #0xF, W0
0011A8  200011     MOV #0x1, W1
0011AA  DD0800     SL W1, W0, W0
0011AC  780080     MOV W0, W1
0011AE  802C90     MOV LCDDATA1, W0
0011B0  700001     IOR W0, W1, W0
0011B2  370009     BRA 0x11C6
0011B4  90401E     MOV.B [W14+1], W0
0011B6  FB8000     ZE W0, W0
0011B8  60006F     AND W0, #0xF, W0
0011BA  200011     MOV #0x1, W1
0011BC  DD0800     SL W1, W0, W0
0011BE  EA8000     COM W0, W0
0011C0  780080     MOV W0, W1
0011C2  802C90     MOV LCDDATA1, W0
0011C4  608000     AND W1, W0, W0
0011C6  882C90     MOV W0, LCDDATA1
56:                            else
57:                                LCD_Set(0, seg, operation);
0011CA  90403E     MOV.B [W14+3], W0
0011CC  E00400     CP0.B W0
0011CE  320008     BRA Z, 0x11E0
0011D0  90401E     MOV.B [W14+1], W0
0011D2  FB8000     ZE W0, W0
0011D4  200011     MOV #0x1, W1
0011D6  DD0800     SL W1, W0, W0
0011D8  780080     MOV W0, W1
0011DA  802C80     MOV LCDDATA0, W0
0011DC  700001     IOR W0, W1, W0
0011DE  370008     BRA 0x11F0
0011E0  90401E     MOV.B [W14+1], W0
0011E2  FB8000     ZE W0, W0
0011E4  200011     MOV #0x1, W1
0011E6  DD0800     SL W1, W0, W0
0011E8  EA8000     COM W0, W0
0011EA  780080     MOV W0, W1
0011EC  802C80     MOV LCDDATA0, W0
0011EE  608000     AND W1, W0, W0
0011F0  882C80     MOV W0, LCDDATA0
58:                            break;
0011C8  3700A2     BRA 0x130E
0011F2  37008D     BRA 0x130E
59:                        }
60:                        case COM1:
61:                        {
62:                            if (seg > 15)
0011F4  90401E     MOV.B [W14+1], W0
0011F6  504FEF     SUB.B W0, #0xF, [W15]
0011F8  360017     BRA LEU, 0x1228
63:                                LCD_Set(5, seg % 16, operation);
0011FA  90403E     MOV.B [W14+3], W0
0011FC  E00400     CP0.B W0
0011FE  320009     BRA Z, 0x1212
001200  90401E     MOV.B [W14+1], W0
001202  FB8000     ZE W0, W0
001204  60006F     AND W0, #0xF, W0
001206  200011     MOV #0x1, W1
001208  DD0800     SL W1, W0, W0
00120A  780080     MOV W0, W1
00120C  802CD0     MOV LCDDATA5, W0
00120E  700001     IOR W0, W1, W0
001210  370009     BRA 0x1224
001212  90401E     MOV.B [W14+1], W0
001214  FB8000     ZE W0, W0
001216  60006F     AND W0, #0xF, W0
001218  200011     MOV #0x1, W1
00121A  DD0800     SL W1, W0, W0
00121C  EA8000     COM W0, W0
00121E  780080     MOV W0, W1
001220  802CD0     MOV LCDDATA5, W0
001222  608000     AND W1, W0, W0
001224  882CD0     MOV W0, LCDDATA5
64:                            else
65:                                LCD_Set(4, seg, operation);
001228  90403E     MOV.B [W14+3], W0
00122A  E00400     CP0.B W0
00122C  320008     BRA Z, 0x123E
00122E  90401E     MOV.B [W14+1], W0
001230  FB8000     ZE W0, W0
001232  200011     MOV #0x1, W1
001234  DD0800     SL W1, W0, W0
001236  780080     MOV W0, W1
001238  802CC0     MOV LCDDATA4, W0
00123A  700001     IOR W0, W1, W0
00123C  370008     BRA 0x124E
00123E  90401E     MOV.B [W14+1], W0
001240  FB8000     ZE W0, W0
001242  200011     MOV #0x1, W1
001244  DD0800     SL W1, W0, W0
001246  EA8000     COM W0, W0
001248  780080     MOV W0, W1
00124A  802CC0     MOV LCDDATA4, W0
00124C  608000     AND W1, W0, W0
00124E  882CC0     MOV W0, LCDDATA4
66:                            break;
001226  370073     BRA 0x130E
001250  37005E     BRA 0x130E
67:                        }
68:                        case COM2:
69:                        {
70:                            if (seg > 15)
001252  90401E     MOV.B [W14+1], W0
001254  504FEF     SUB.B W0, #0xF, [W15]
001256  360017     BRA LEU, 0x1286
71:                                LCD_Set(9, seg % 16, operation);
001258  90403E     MOV.B [W14+3], W0
00125A  E00400     CP0.B W0
00125C  320009     BRA Z, 0x1270
00125E  90401E     MOV.B [W14+1], W0
001260  FB8000     ZE W0, W0
001262  60006F     AND W0, #0xF, W0
001264  200011     MOV #0x1, W1
001266  DD0800     SL W1, W0, W0
001268  780080     MOV W0, W1
00126A  802D10     MOV LCDDATA9, W0
00126C  700001     IOR W0, W1, W0
00126E  370009     BRA 0x1282
001270  90401E     MOV.B [W14+1], W0
001272  FB8000     ZE W0, W0
001274  60006F     AND W0, #0xF, W0
001276  200011     MOV #0x1, W1
001278  DD0800     SL W1, W0, W0
00127A  EA8000     COM W0, W0
00127C  780080     MOV W0, W1
00127E  802D10     MOV LCDDATA9, W0
001280  608000     AND W1, W0, W0
001282  882D10     MOV W0, LCDDATA9
72:                            else
73:                                LCD_Set(8, seg, operation);
001286  90403E     MOV.B [W14+3], W0
001288  E00400     CP0.B W0
00128A  320008     BRA Z, 0x129C
00128C  90401E     MOV.B [W14+1], W0
00128E  FB8000     ZE W0, W0
001290  200011     MOV #0x1, W1
001292  DD0800     SL W1, W0, W0
001294  780080     MOV W0, W1
001296  802D00     MOV LCDDATA8, W0
001298  700001     IOR W0, W1, W0
00129A  370008     BRA 0x12AC
00129C  90401E     MOV.B [W14+1], W0
00129E  FB8000     ZE W0, W0
0012A0  200011     MOV #0x1, W1
0012A2  DD0800     SL W1, W0, W0
0012A4  EA8000     COM W0, W0
0012A6  780080     MOV W0, W1
0012A8  802D00     MOV LCDDATA8, W0
0012AA  608000     AND W1, W0, W0
0012AC  882D00     MOV W0, LCDDATA8
74:                            break;
001284  370044     BRA 0x130E
0012AE  37002F     BRA 0x130E
75:                        }
76:                        case COM3:
77:                        {
78:                            if (seg > 15)
0012B0  90401E     MOV.B [W14+1], W0
0012B2  504FEF     SUB.B W0, #0xF, [W15]
0012B4  360017     BRA LEU, 0x12E4
79:                                LCD_Set(13, seg % 16, operation);
0012B6  90403E     MOV.B [W14+3], W0
0012B8  E00400     CP0.B W0
0012BA  320009     BRA Z, 0x12CE
0012BC  90401E     MOV.B [W14+1], W0
0012BE  FB8000     ZE W0, W0
0012C0  60006F     AND W0, #0xF, W0
0012C2  200011     MOV #0x1, W1
0012C4  DD0800     SL W1, W0, W0
0012C6  780080     MOV W0, W1
0012C8  802D50     MOV LCDDATA13, W0
0012CA  700001     IOR W0, W1, W0
0012CC  370009     BRA 0x12E0
0012CE  90401E     MOV.B [W14+1], W0
0012D0  FB8000     ZE W0, W0
0012D2  60006F     AND W0, #0xF, W0
0012D4  200011     MOV #0x1, W1
0012D6  DD0800     SL W1, W0, W0
0012D8  EA8000     COM W0, W0
0012DA  780080     MOV W0, W1
0012DC  802D50     MOV LCDDATA13, W0
0012DE  608000     AND W1, W0, W0
0012E0  882D50     MOV W0, LCDDATA13
80:                            else
81:                                LCD_Set(12, seg, operation);
0012E4  90403E     MOV.B [W14+3], W0
0012E6  E00400     CP0.B W0
0012E8  320008     BRA Z, 0x12FA
0012EA  90401E     MOV.B [W14+1], W0
0012EC  FB8000     ZE W0, W0
0012EE  200011     MOV #0x1, W1
0012F0  DD0800     SL W1, W0, W0
0012F2  780080     MOV W0, W1
0012F4  802D40     MOV LCDDATA12, W0
0012F6  700001     IOR W0, W1, W0
0012F8  370008     BRA 0x130A
0012FA  90401E     MOV.B [W14+1], W0
0012FC  FB8000     ZE W0, W0
0012FE  200011     MOV #0x1, W1
001300  DD0800     SL W1, W0, W0
001302  EA8000     COM W0, W0
001304  780080     MOV W0, W1
001306  802D40     MOV LCDDATA12, W0
001308  608000     AND W1, W0, W0
00130A  882D40     MOV W0, LCDDATA12
82:                            break;
0012E2  370015     BRA 0x130E
00130C  000000     NOP
83:                        }
84:                    }
85:                
86:                }
00130E  FA8000     ULNK
001310  060000     RETURN
87:                
88:                static void NUM_SHOW(uint8_t num, uint8_t pos) {
001312  FA0004     LNK #0x4
001314  984720     MOV.B W0, [W14+2]
001316  984731     MOV.B W1, [W14+3]
89:                    uint8_t cnt; //, tmp; //, offset = pos * 2;
90:                    bool show_or_hide = SHOW;
001318  B3C010     MOV.B #0x1, W0
00131A  984710     MOV.B W0, [W14+1]
91:                    //    bool IsHideflag = false;
92:                    for (cnt = 0; cnt < 8; cnt++) {
00131C  EB4000     CLR.B W0
00131E  784F00     MOV.B W0, [W14]
001320  370026     BRA 0x136E
00136C  E84F1E     INC.B [W14], [W14]
00136E  78401E     MOV.B [W14], W0
001370  504FE7     SUB.B W0, #0x7, [W15]
001372  36FFD7     BRA LEU, 0x1322
93:                        if ((LCD_NUM[num][cnt] == 0xff) && show_or_hide)//如果已经找到了OxFF，则接下来的数据都是隐藏,并且跳过0xff
001322  90402E     MOV.B [W14+2], W0
001324  FB8080     ZE W0, W1
001326  FB801E     ZE [W14], W0
001328  DD08C3     SL W1, #3, W1
00132A  408000     ADD W1, W0, W0
00132C  290661     MOV #0x9066, W1
00132E  784061     MOV.B [W1+W0], W0
001330  404FE1     ADD.B W0, #0x1, [W15]
001332  3A0006     BRA NZ, 0x1340
001334  90401E     MOV.B [W14+1], W0
001336  E00400     CP0.B W0
001338  320003     BRA Z, 0x1340
94:                        {
95:                            show_or_hide = HIDE;
00133A  EB4000     CLR.B W0
00133C  984710     MOV.B W0, [W14+1]
96:                            continue;
00133E  370016     BRA 0x136C
97:                        }
98:                        //        tmp = (LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72;
99:                        LCD_Show((LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72, show_or_hide);
001340  90402E     MOV.B [W14+2], W0
001342  FB8080     ZE W0, W1
001344  FB801E     ZE [W14], W0
001346  DD08C3     SL W1, #3, W1
001348  408000     ADD W1, W0, W0
00134A  290661     MOV #0x9066, W1
00134C  784061     MOV.B [W1+W0], W0
00134E  FB8080     ZE W0, W1
001350  90403E     MOV.B [W14+3], W0
001352  FB8000     ZE W0, W0
001354  290B62     MOV #0x90B6, W2
001356  784062     MOV.B [W2+W0], W0
001358  FB8000     ZE W0, W0
00135A  408080     ADD W1, W0, W1
00135C  200480     MOV #0x48, W0
00135E  780100     MOV W0, W2
001360  090011     REPEAT #0x11
001362  D80082     DIV.SW W1, W2
001364  FD0080     EXCH W0, W1
001366  784000     MOV.B W0, W0
001368  90409E     MOV.B [W14+1], W1
00136A  07FEF6     RCALL _LCD_Show
100:                   }
101:               }
001374  FA8000     ULNK
001376  060000     RETURN
102:               
103:               void BAT_SHOW(uint8_t bat) {
001378  FA0002     LNK #0x2
00137A  784F00     MOV.B W0, [W14]
104:                   switch (bat) {
00137C  FB801E     ZE [W14], W0
00137E  500FE1     SUB W0, #0x1, [W15]
001380  320017     BRA Z, 0x13B0
001382  500FE1     SUB W0, #0x1, [W15]
001384  3C0003     BRA GT, 0x138C
001386  E00000     CP0 W0
001388  320006     BRA Z, 0x1396
00138A  370039     BRA 0x13FE
00138C  500FE2     SUB W0, #0x2, [W15]
00138E  32001D     BRA Z, 0x13CA
001390  500FE3     SUB W0, #0x3, [W15]
001392  320028     BRA Z, 0x13E4
001394  370034     BRA 0x13FE
105:                       case 0:
106:                       {
107:                           LCD_Show(B_0, SHOW);
001396  B3C011     MOV.B #0x1, W1
001398  B3C3B0     MOV.B #0x3B, W0
00139A  07FEDE     RCALL _LCD_Show
108:                           LCD_Show(B_1, HIDE);
00139C  EB4080     CLR.B W1
00139E  B3C290     MOV.B #0x29, W0
0013A0  07FEDB     RCALL _LCD_Show
109:                           LCD_Show(B_2, HIDE);
0013A2  EB4080     CLR.B W1
0013A4  B3C170     MOV.B #0x17, W0
0013A6  07FED8     RCALL _LCD_Show
110:                           LCD_Show(B_3, HIDE);
0013A8  EB4080     CLR.B W1
0013AA  B3C050     MOV.B #0x5, W0
0013AC  07FED5     RCALL _LCD_Show
111:                           break;
0013AE  370034     BRA 0x1418
112:                       }
113:                       case 1:
114:                       {
115:                           LCD_Show(B_0, SHOW);
0013B0  B3C011     MOV.B #0x1, W1
0013B2  B3C3B0     MOV.B #0x3B, W0
0013B4  07FED1     RCALL _LCD_Show
116:                           LCD_Show(B_1, SHOW);
0013B6  B3C011     MOV.B #0x1, W1
0013B8  B3C290     MOV.B #0x29, W0
0013BA  07FECE     RCALL _LCD_Show
117:                           LCD_Show(B_2, HIDE);
0013BC  EB4080     CLR.B W1
0013BE  B3C170     MOV.B #0x17, W0
0013C0  07FECB     RCALL _LCD_Show
118:                           LCD_Show(B_3, HIDE);
0013C2  EB4080     CLR.B W1
0013C4  B3C050     MOV.B #0x5, W0
0013C6  07FEC8     RCALL _LCD_Show
119:                           break;
0013C8  370027     BRA 0x1418
120:                       }
121:                       case 2:
122:                       {
123:                           LCD_Show(B_0, SHOW);
0013CA  B3C011     MOV.B #0x1, W1
0013CC  B3C3B0     MOV.B #0x3B, W0
0013CE  07FEC4     RCALL _LCD_Show
124:                           LCD_Show(B_1, SHOW);
0013D0  B3C011     MOV.B #0x1, W1
0013D2  B3C290     MOV.B #0x29, W0
0013D4  07FEC1     RCALL _LCD_Show
125:                           LCD_Show(B_2, SHOW);
0013D6  B3C011     MOV.B #0x1, W1
0013D8  B3C170     MOV.B #0x17, W0
0013DA  07FEBE     RCALL _LCD_Show
126:                           LCD_Show(B_3, HIDE);
0013DC  EB4080     CLR.B W1
0013DE  B3C050     MOV.B #0x5, W0
0013E0  07FEBB     RCALL _LCD_Show
127:                           break;
0013E2  37001A     BRA 0x1418
128:                       }
129:                       case 3:
130:                       {
131:                           LCD_Show(B_0, SHOW);
0013E4  B3C011     MOV.B #0x1, W1
0013E6  B3C3B0     MOV.B #0x3B, W0
0013E8  07FEB7     RCALL _LCD_Show
132:                           LCD_Show(B_1, SHOW);
0013EA  B3C011     MOV.B #0x1, W1
0013EC  B3C290     MOV.B #0x29, W0
0013EE  07FEB4     RCALL _LCD_Show
133:                           LCD_Show(B_2, SHOW);
0013F0  B3C011     MOV.B #0x1, W1
0013F2  B3C170     MOV.B #0x17, W0
0013F4  07FEB1     RCALL _LCD_Show
134:                           LCD_Show(B_3, SHOW);
0013F6  B3C011     MOV.B #0x1, W1
0013F8  B3C050     MOV.B #0x5, W0
0013FA  07FEAE     RCALL _LCD_Show
135:                           break;
0013FC  37000D     BRA 0x1418
136:                       }
137:                       default:
138:                       {
139:                           LCD_Show(B_0, HIDE);
0013FE  EB4080     CLR.B W1
001400  B3C3B0     MOV.B #0x3B, W0
001402  07FEAA     RCALL _LCD_Show
140:                           LCD_Show(B_1, HIDE);
001404  EB4080     CLR.B W1
001406  B3C290     MOV.B #0x29, W0
001408  07FEA7     RCALL _LCD_Show
141:                           LCD_Show(B_2, HIDE);
00140A  EB4080     CLR.B W1
00140C  B3C170     MOV.B #0x17, W0
00140E  07FEA4     RCALL _LCD_Show
142:                           LCD_Show(B_3, HIDE);
001410  EB4080     CLR.B W1
001412  B3C050     MOV.B #0x5, W0
001414  07FEA1     RCALL _LCD_Show
143:                           break;
001416  000000     NOP
144:                       }
145:                   }
146:               }
001418  FA8000     ULNK
00141A  060000     RETURN
147:               
148:               void SIGN_SHOW(uint8_t sign) {
00141C  FA0002     LNK #0x2
00141E  784F00     MOV.B W0, [W14]
149:                   switch (sign) {
001420  FB801E     ZE [W14], W0
001422  500FE2     SUB W0, #0x2, [W15]
001424  320017     BRA Z, 0x1454
001426  500FE2     SUB W0, #0x2, [W15]
001428  3C0003     BRA GT, 0x1430
00142A  500FE1     SUB W0, #0x1, [W15]
00142C  320006     BRA Z, 0x143A
00142E  370039     BRA 0x14A2
001430  500FE3     SUB W0, #0x3, [W15]
001432  32001D     BRA Z, 0x146E
001434  500FE4     SUB W0, #0x4, [W15]
001436  320028     BRA Z, 0x1488
001438  370034     BRA 0x14A2
150:                       case 1:
151:                       {
152:                           LCD_Show(Sign0, SHOW);
00143A  B3C011     MOV.B #0x1, W1
00143C  B3C3C0     MOV.B #0x3C, W0
00143E  07FE8C     RCALL _LCD_Show
153:                           LCD_Show(Sign1, HIDE);
001440  EB4080     CLR.B W1
001442  B3C2A0     MOV.B #0x2A, W0
001444  07FE89     RCALL _LCD_Show
154:                           LCD_Show(Sign2, HIDE);
001446  EB4080     CLR.B W1
001448  B3C180     MOV.B #0x18, W0
00144A  07FE86     RCALL _LCD_Show
155:                           LCD_Show(Sign3, HIDE);
00144C  EB4080     CLR.B W1
00144E  B3C060     MOV.B #0x6, W0
001450  07FE83     RCALL _LCD_Show
156:                           break;
001452  370034     BRA 0x14BC
157:                       }
158:                       case 2:
159:                       {
160:                           LCD_Show(Sign0, SHOW);
001454  B3C011     MOV.B #0x1, W1
001456  B3C3C0     MOV.B #0x3C, W0
001458  07FE7F     RCALL _LCD_Show
161:                           LCD_Show(Sign1, SHOW);
00145A  B3C011     MOV.B #0x1, W1
00145C  B3C2A0     MOV.B #0x2A, W0
00145E  07FE7C     RCALL _LCD_Show
162:                           LCD_Show(Sign2, HIDE);
001460  EB4080     CLR.B W1
001462  B3C180     MOV.B #0x18, W0
001464  07FE79     RCALL _LCD_Show
163:                           LCD_Show(Sign3, HIDE);
001466  EB4080     CLR.B W1
001468  B3C060     MOV.B #0x6, W0
00146A  07FE76     RCALL _LCD_Show
164:                           break;
00146C  370027     BRA 0x14BC
165:                       }
166:                       case 3:
167:                       {
168:                           LCD_Show(Sign0, SHOW);
00146E  B3C011     MOV.B #0x1, W1
001470  B3C3C0     MOV.B #0x3C, W0
001472  07FE72     RCALL _LCD_Show
169:                           LCD_Show(Sign1, SHOW);
001474  B3C011     MOV.B #0x1, W1
001476  B3C2A0     MOV.B #0x2A, W0
001478  07FE6F     RCALL _LCD_Show
170:                           LCD_Show(Sign2, SHOW);
00147A  B3C011     MOV.B #0x1, W1
00147C  B3C180     MOV.B #0x18, W0
00147E  07FE6C     RCALL _LCD_Show
171:                           LCD_Show(Sign3, HIDE);
001480  EB4080     CLR.B W1
001482  B3C060     MOV.B #0x6, W0
001484  07FE69     RCALL _LCD_Show
172:                           break;
001486  37001A     BRA 0x14BC
173:                       }
174:                       case 4:
175:                       {
176:                           LCD_Show(Sign0, SHOW);
001488  B3C011     MOV.B #0x1, W1
00148A  B3C3C0     MOV.B #0x3C, W0
00148C  07FE65     RCALL _LCD_Show
177:                           LCD_Show(Sign1, SHOW);
00148E  B3C011     MOV.B #0x1, W1
001490  B3C2A0     MOV.B #0x2A, W0
001492  07FE62     RCALL _LCD_Show
178:                           LCD_Show(Sign2, SHOW);
001494  B3C011     MOV.B #0x1, W1
001496  B3C180     MOV.B #0x18, W0
001498  07FE5F     RCALL _LCD_Show
179:                           LCD_Show(Sign3, SHOW);
00149A  B3C011     MOV.B #0x1, W1
00149C  B3C060     MOV.B #0x6, W0
00149E  07FE5C     RCALL _LCD_Show
180:                           break;
0014A0  37000D     BRA 0x14BC
181:                       }
182:                       default:
183:                       {
184:                           LCD_Show(Sign0, HIDE);
0014A2  EB4080     CLR.B W1
0014A4  B3C3C0     MOV.B #0x3C, W0
0014A6  07FE58     RCALL _LCD_Show
185:                           LCD_Show(Sign1, HIDE);
0014A8  EB4080     CLR.B W1
0014AA  B3C2A0     MOV.B #0x2A, W0
0014AC  07FE55     RCALL _LCD_Show
186:                           LCD_Show(Sign2, HIDE);
0014AE  EB4080     CLR.B W1
0014B0  B3C180     MOV.B #0x18, W0
0014B2  07FE52     RCALL _LCD_Show
187:                           LCD_Show(Sign3, HIDE);
0014B4  EB4080     CLR.B W1
0014B6  B3C060     MOV.B #0x6, W0
0014B8  07FE4F     RCALL _LCD_Show
188:                           break;
0014BA  000000     NOP
189:                       }
190:                   }
191:               }
0014BC  FA8000     ULNK
0014BE  060000     RETURN
192:               
193:               void NUMS_SHOW(uint32_t num, uint8_t all_show) {
0014C0  FA000A     LNK #0xA
0014C2  BE9F88     MOV.D W8, [W15++]
0014C4  980720     MOV W0, [W14+4]
0014C6  980731     MOV W1, [W14+6]
0014C8  984F02     MOV.B W2, [W14+8]
194:                   char cnt; //
195:                   uint8_t num_tmp;
196:                   uint8_t IsFindHead = 0;
0014CA  EB4000     CLR.B W0
0014CC  984710     MOV.B W0, [W14+1]
197:                   //    uint8_t nums[7] = {0, 0, 0, 0, 0, 0, 0};
198:               
199:                   //获取数字位数
200:                   for (cnt = 6; cnt >= 0; cnt--) {
0014CE  B3C060     MOV.B #0x6, W0
0014D0  784F00     MOV.B W0, [W14]
0014D2  370025     BRA 0x151E
00151C  E94F1E     DEC.B [W14], [W14]
00151E  78401E     MOV.B [W14], W0
001520  E00400     CP0.B W0
001522  3DFFD8     BRA GE, 0x14D4
201:                       num_tmp = (uint32_t) (num / pow(10, cnt)) % 10;
0014D4  90002E     MOV [W14+4], W0
0014D6  9000BE     MOV [W14+6], W1
0014D8  07F973     RCALL 0x7C0
0014DA  BE0400     MOV.D W0, W8
0014DC  FB001E     SE [W14], W0
0014DE  DE80CF     ASR W0, #15, W1
0014E0  07F96C     RCALL 0x7BA
0014E2  BE0100     MOV.D W0, W2
0014E4  200000     MOV #0x0, W0
0014E6  241201     MOV #0x4120, W1
0014E8  07F9C0     RCALL 0x86A
0014EA  BE0100     MOV.D W0, W2
0014EC  BE0008     MOV.D W8, W0
0014EE  07F908     RCALL 0x700
0014F0  07F949     RCALL 0x784
0014F2  2000A2     MOV #0xA, W2
0014F4  200003     MOV #0x0, W3
0014F6  07FAAC     RCALL 0xA50
0014F8  984720     MOV.B W0, [W14+2]
202:                       if (num_tmp) {//如果字节为0的话，那么就pass
0014FA  90402E     MOV.B [W14+2], W0
0014FC  E00400     CP0.B W0
0014FE  320007     BRA Z, 0x150E
203:                           IsFindHead = 1;
001500  B3C010     MOV.B #0x1, W0
001502  984710     MOV.B W0, [W14+1]
204:                           NUM_SHOW(num_tmp, cnt);
001504  78401E     MOV.B [W14], W0
001506  784080     MOV.B W0, W1
001508  90402E     MOV.B [W14+2], W0
00150A  07FF03     RCALL _NUM_SHOW
00150C  370007     BRA 0x151C
205:                       } else {
206:                           if (IsFindHead)
00150E  90401E     MOV.B [W14+1], W0
001510  E00400     CP0.B W0
001512  320004     BRA Z, 0x151C
207:                               NUM_SHOW(num_tmp, cnt);
001514  78401E     MOV.B [W14], W0
001516  784080     MOV.B W0, W1
001518  90402E     MOV.B [W14+2], W0
00151A  07FEFB     RCALL _NUM_SHOW
208:                           //            else
209:                           //                NUM_SHOW(11, cnt);
210:                       }
211:                   }
212:               }
001524  BE044F     MOV.D [--W15], W8
001526  FA8000     ULNK
001528  060000     RETURN
213:               
214:               void DP_SHOW(uint8_t dp_pos) {
00152A  FA0002     LNK #0x2
00152C  784F00     MOV.B W0, [W14]
215:                   //显示小数点
216:                   switch (dp_pos) {
00152E  FB801E     ZE [W14], W0
001530  500FE2     SUB W0, #0x2, [W15]
001532  320017     BRA Z, 0x1562
001534  500FE2     SUB W0, #0x2, [W15]
001536  3C0003     BRA GT, 0x153E
001538  500FE1     SUB W0, #0x1, [W15]
00153A  320006     BRA Z, 0x1548
00153C  370039     BRA 0x15B0
00153E  500FE3     SUB W0, #0x3, [W15]
001540  32001D     BRA Z, 0x157C
001542  500FE4     SUB W0, #0x4, [W15]
001544  320028     BRA Z, 0x1596
001546  370034     BRA 0x15B0
217:                       case 1:
218:                       {
219:                           LCD_Show(P1, SHOW);
001548  B3C011     MOV.B #0x1, W1
00154A  B3C010     MOV.B #0x1, W0
00154C  07FE05     RCALL _LCD_Show
220:                           LCD_Show(P2, HIDE);
00154E  EB4080     CLR.B W1
001550  B3C030     MOV.B #0x3, W0
001552  07FE02     RCALL _LCD_Show
221:                           LCD_Show(P3, HIDE);
001554  EB4080     CLR.B W1
001556  B3C090     MOV.B #0x9, W0
001558  07FDFF     RCALL _LCD_Show
222:                           LCD_Show(P4, HIDE);
00155A  EB4080     CLR.B W1
00155C  B3C0B0     MOV.B #0xB, W0
00155E  07FDFC     RCALL _LCD_Show
223:                           break;
001560  370034     BRA 0x15CA
224:                       }
225:                       case 2:
226:                       {
227:                           LCD_Show(P1, HIDE);
001562  EB4080     CLR.B W1
001564  B3C010     MOV.B #0x1, W0
001566  07FDF8     RCALL _LCD_Show
228:                           LCD_Show(P2, SHOW);
001568  B3C011     MOV.B #0x1, W1
00156A  B3C030     MOV.B #0x3, W0
00156C  07FDF5     RCALL _LCD_Show
229:                           LCD_Show(P3, HIDE);
00156E  EB4080     CLR.B W1
001570  B3C090     MOV.B #0x9, W0
001572  07FDF2     RCALL _LCD_Show
230:                           LCD_Show(P4, HIDE);
001574  EB4080     CLR.B W1
001576  B3C0B0     MOV.B #0xB, W0
001578  07FDEF     RCALL _LCD_Show
231:                           break;
00157A  370027     BRA 0x15CA
232:                       }
233:                       case 3:
234:                       {
235:                           LCD_Show(P1, HIDE);
00157C  EB4080     CLR.B W1
00157E  B3C010     MOV.B #0x1, W0
001580  07FDEB     RCALL _LCD_Show
236:                           LCD_Show(P2, HIDE);
001582  EB4080     CLR.B W1
001584  B3C030     MOV.B #0x3, W0
001586  07FDE8     RCALL _LCD_Show
237:                           LCD_Show(P3, SHOW);
001588  B3C011     MOV.B #0x1, W1
00158A  B3C090     MOV.B #0x9, W0
00158C  07FDE5     RCALL _LCD_Show
238:                           LCD_Show(P4, HIDE);
00158E  EB4080     CLR.B W1
001590  B3C0B0     MOV.B #0xB, W0
001592  07FDE2     RCALL _LCD_Show
239:                           break;
001594  37001A     BRA 0x15CA
240:                       }
241:                       case 4:
242:                       {
243:                           LCD_Show(P1, HIDE);
001596  EB4080     CLR.B W1
001598  B3C010     MOV.B #0x1, W0
00159A  07FDDE     RCALL _LCD_Show
244:                           LCD_Show(P2, HIDE);
00159C  EB4080     CLR.B W1
00159E  B3C030     MOV.B #0x3, W0
0015A0  07FDDB     RCALL _LCD_Show
245:                           LCD_Show(P3, HIDE);
0015A2  EB4080     CLR.B W1
0015A4  B3C090     MOV.B #0x9, W0
0015A6  07FDD8     RCALL _LCD_Show
246:                           LCD_Show(P4, SHOW);
0015A8  B3C011     MOV.B #0x1, W1
0015AA  B3C0B0     MOV.B #0xB, W0
0015AC  07FDD5     RCALL _LCD_Show
247:                           break;
0015AE  37000D     BRA 0x15CA
248:                       }
249:                       default:
250:                       {
251:                           LCD_Show(P1, HIDE);
0015B0  EB4080     CLR.B W1
0015B2  B3C010     MOV.B #0x1, W0
0015B4  07FDD1     RCALL _LCD_Show
252:                           LCD_Show(P2, HIDE);
0015B6  EB4080     CLR.B W1
0015B8  B3C030     MOV.B #0x3, W0
0015BA  07FDCE     RCALL _LCD_Show
253:                           LCD_Show(P3, HIDE);
0015BC  EB4080     CLR.B W1
0015BE  B3C090     MOV.B #0x9, W0
0015C0  07FDCB     RCALL _LCD_Show
254:                           LCD_Show(P4, HIDE);
0015C2  EB4080     CLR.B W1
0015C4  B3C0B0     MOV.B #0xB, W0
0015C6  07FDC8     RCALL _LCD_Show
255:                           break;
0015C8  000000     NOP
256:                       }
257:                   }
258:               }
0015CA  FA8000     ULNK
0015CC  060000     RETURN
259:               
260:               void ClrNum(void) {
0015CE  FA0002     LNK #0x2
261:                   uint8_t x, y;
262:                   for (y = 0; y < 4; y++)
0015D0  EB4000     CLR.B W0
0015D2  984710     MOV.B W0, [W14+1]
0015D4  370011     BRA 0x15F8
0015F2  90401E     MOV.B [W14+1], W0
0015F4  E84000     INC.B W0, W0
0015F6  984710     MOV.B W0, [W14+1]
0015F8  90401E     MOV.B [W14+1], W0
0015FA  504FE3     SUB.B W0, #0x3, [W15]
0015FC  36FFEC     BRA LEU, 0x15D6
263:                       for (x = 0; x < 4; x++)
0015D6  EB4000     CLR.B W0
0015D8  784F00     MOV.B W0, [W14]
0015DA  370008     BRA 0x15EC
0015EA  E84F1E     INC.B [W14], [W14]
0015EC  78401E     MOV.B [W14], W0
0015EE  504FE3     SUB.B W0, #0x3, [W15]
0015F0  36FFF5     BRA LEU, 0x15DC
264:                           LCD_Show(x + y * SegCnt, HIDE);
0015DC  90401E     MOV.B [W14+1], W0
0015DE  B90072     MUL.SU W0, #18, W0
0015E0  780000     MOV W0, W0
0015E2  784000     MOV.B W0, W0
0015E4  40401E     ADD.B W0, [W14], W0
0015E6  EB4080     CLR.B W1
0015E8  07FDB7     RCALL _LCD_Show
265:                   for (y = 0; y < 4; y++)
0015FE  EB4000     CLR.B W0
001600  984710     MOV.B W0, [W14+1]
001602  370011     BRA 0x1626
001620  90401E     MOV.B [W14+1], W0
001622  E84000     INC.B W0, W0
001624  984710     MOV.B W0, [W14+1]
001626  90401E     MOV.B [W14+1], W0
001628  504FE3     SUB.B W0, #0x3, [W15]
00162A  36FFEC     BRA LEU, 0x1604
266:                       for (x = 8; x < SegCnt; x++)
001604  B3C080     MOV.B #0x8, W0
001606  784F00     MOV.B W0, [W14]
001608  370008     BRA 0x161A
001618  E84F1E     INC.B [W14], [W14]
00161A  78401E     MOV.B [W14], W0
00161C  504FF1     SUB.B W0, #0x11, [W15]
00161E  36FFF5     BRA LEU, 0x160A
267:                           LCD_Show(x + y * SegCnt, HIDE);
00160A  90401E     MOV.B [W14+1], W0
00160C  B90072     MUL.SU W0, #18, W0
00160E  780000     MOV W0, W0
001610  784000     MOV.B W0, W0
001612  40401E     ADD.B W0, [W14], W0
001614  EB4080     CLR.B W1
001616  07FDA0     RCALL _LCD_Show
268:               }
00162C  FA8000     ULNK
00162E  060000     RETURN
269:               
270:               void ClrScreen(void) {
001630  FA0002     LNK #0x2
271:                   uint8_t x, y;
272:                   for (y = 0; y < 4; y++)
001632  EB4000     CLR.B W0
001634  984710     MOV.B W0, [W14+1]
001636  370011     BRA 0x165A
001654  90401E     MOV.B [W14+1], W0
001656  E84000     INC.B W0, W0
001658  984710     MOV.B W0, [W14+1]
00165A  90401E     MOV.B [W14+1], W0
00165C  504FE3     SUB.B W0, #0x3, [W15]
00165E  36FFEC     BRA LEU, 0x1638
273:                       for (x = 0; x < SegCnt; x++)
001638  EB4000     CLR.B W0
00163A  784F00     MOV.B W0, [W14]
00163C  370008     BRA 0x164E
00164C  E84F1E     INC.B [W14], [W14]
00164E  78401E     MOV.B [W14], W0
001650  504FF1     SUB.B W0, #0x11, [W15]
001652  36FFF5     BRA LEU, 0x163E
274:                           LCD_Show(x + y * SegCnt, HIDE);
00163E  90401E     MOV.B [W14+1], W0
001640  B90072     MUL.SU W0, #18, W0
001642  780000     MOV W0, W0
001644  784000     MOV.B W0, W0
001646  40401E     ADD.B W0, [W14], W0
001648  EB4080     CLR.B W1
00164A  07FD86     RCALL _LCD_Show
275:               }
001660  FA8000     ULNK
276:               
277:               
278:               
279:               
280:               
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/INT.c  ---------------------------------------
1:                 #include "INT.h"
2:                 
3:                 void INT0_Init(void) {
002D8E  FA0000     LNK #0x0
4:                     TRISFbits.TRISF6 = 1; //设置为输入
002D90  A8C2E8     BSET TRISF, #6
5:                     INTCON2bits.INT0EP = 1; //  1 = 下降沿中断  0 = 上升沿中断
002D92  A80082     BSET INTCON2, #0
6:                     IPC0bits.INT0IP = 7; //优先级为2
002D94  800520     MOV IPC0, W0
002D96  B30070     IOR #0x7, W0
002D98  880520     MOV W0, IPC0
7:                     IFS0bits.INT0IF = 0; //清除标志位
002D9A  A90084     BCLR IFS0, #0
8:                     IEC0bits.INT0IE = 1; //使能中断
002D9C  A80094     BSET IEC0, #0
9:                 }
002D9E  FA8000     ULNK
002DA0  060000     RETURN
10:                
11:                void INT0_Open(void) {
002DA2  FA0000     LNK #0x0
12:                    IFS0bits.INT0IF = 0; //清除标志位
002DA4  A90084     BCLR IFS0, #0
13:                    IEC0bits.INT0IE = 1;
002DA6  A80094     BSET IEC0, #0
14:                }
002DA8  FA8000     ULNK
002DAA  060000     RETURN
15:                
16:                void INT0_Close(void) {
002DAC  FA0000     LNK #0x0
17:                    IFS0bits.INT0IF = 0; //清除标志位
002DAE  A90084     BCLR IFS0, #0
18:                    IEC0bits.INT0IE = 0;
002DB0  A90094     BCLR IEC0, #0
19:                }
002DB2  FA8000     ULNK
20:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/I2C.c  ---------------------------------------
1:                 #include "I2C.h"
2:                 
3:                 volatile uint8_t i2c1_state;
4:                 I2C1_Buffer i2c_buf;
5:                 
6:                 void I2C_Init(void) {
002DDE  FA0000     LNK #0x0
7:                     TRISGbits.TRISG2 = 0; //将SCL1设置为输出口
002DE0  A942F0     BCLR TRISG, #2
8:                     TRISGbits.TRISG3 = 0; //将SCK1设置为输出口
002DE2  A962F0     BCLR TRISG, #3
9:                     I2C1BRG = 0x9D; //100kHz Fcy=16000000
002DE4  2009D0     MOV #0x9D, W0
002DE6  881020     MOV W0, I2C1BRG
10:                    I2C1CONbits.I2CEN = 1; //使能I2C1
002DE8  A8E207     BSET 0x207, #7
11:                    I2C1CONbits.I2CSIDL = 0; //模块在空闲模式下继续工作
002DEA  A9A207     BCLR 0x207, #5
12:                    I2C1CONbits.IPMIEN = 0; //禁止IPMI模式
002DEC  A96207     BCLR 0x207, #3
13:                    I2C1CONbits.A10M = 0; //7位从地址
002DEE  A94207     BCLR 0x207, #2
14:                    IEC1bits.MI2C1IE = 1; //使能Master中断
002DF0  A82096     BSET IEC1, #1
15:                    IFS1bits.MI2C1IF = 0; //清楚Master标志位
002DF2  A92086     BCLR IFS1, #1
16:                    //    IEC1bits.SI2C1IE = 1;//使能Slave中断
17:                    //    IFS1bits.SI2C1IF = 0;//清楚Slave标志位
18:                    //    I2C1CONbits.I2CEN = 0; //关闭I2C1
19:                }
002DF4  FA8000     ULNK
002DF6  060000     RETURN
20:                
21:                void Start_I2C(void) {
002DF8  FA0000     LNK #0x0
22:                    //    IEC4bits.
23:                    //    I2C1CONbits.I2CEN = 1;
24:                    IFS1bits.MI2C1IF = 1;
002DFA  A82086     BSET IFS1, #1
25:                }
002DFC  FA8000     ULNK
26:                
27:                //void Stop_I2C(void) {
28:                //    IFS1bits.MI2C1IF = 0;
29:                //    I2C1CONbits.I2CEN = 0;
30:                //}
31:                
32:                //void Check_I2C(void) {
33:                //    if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
34:                //        I2C1STATbits.IWCOL = 0;
35:                //    }
36:                //}
37:                
38:                //void Clear_I2C_Sta(void) {
39:                //    i2c1_state = S_MASTER_IDLE;
40:                //}
41:                
42:                //void Send_I2C_Data(I2C1_Buffer* buf)
43:                //{
44:                //    buf
45:                //}
46:                
---  C:/Users/Administrator/Desktop/V1_1_5WCGforkjxm.X/BSP/DeepSleep.c  ---------------------------------
1:                 #include <DeepSleep.h>
2:                 #include <xc.h>
3:                 #include <stdint.h>
4:                 
5:                 /************
6:                  * 低压/保持稳压器仅在调用休眠模式或深度休眠模式时
7:                 可用。它由LPCFG配置位（CW1<10>）控制，在固件
8:                 中由 RETEN 位（RCON<12>）控制。必须将 LPCFG
9:                 编程为 0 并将 RETEN 位置 1，才能使能该稳压器。
10:                 ************************************************/
11:                void DeepSleep(void) {
002E00  FA0000     LNK #0x0
12:                    //    uint8_t Result;
13:                    //    if (RCONbits.WDTO) {
14:                    //        Result = 3;
15:                    //        RCONbits.WDTO = 0;
16:                    //        DSCONbits.RELEASE = 0;
17:                    //    } else if (RCONbits.EXTR) {
18:                    //        Result = 2;
19:                    //        RCONbits.EXTR = 0;
20:                    //        DSCONbits.RELEASE = 0;
21:                    //    } else if (RCONbits.DPSLP) {
22:                    //        Result = 1;
23:                    //        RCONbits.DPSLP = 0;
24:                    //        DSCONbits.RELEASE = 0;
25:                    //        if (DSWAKEbits.DSWDT) DSGPR0 = DSGPR0 + 1; /* count when wake from DSWDT */
26:                    //        if (DSWAKEbits.DSINT0) DSGPR1 = DSGPR1 + 1; /* count when wake from INT0  */
27:                    //    } else {
28:                    //        Result = 0; /* assume we are a Power On reset */
29:                    //        RCONbits.POR = 0;
30:                    //        DSGPR0 = 0;
31:                    //        DSGPR1 = 0;
32:                    //    }
33:                    //    if (Result == 0) {
34:                    RCONbits.RETEN = 1; // CONFIG1  #pragma config LPCFG = ON    // Low power regulator control->Disabled
002E02  A88741     BSET 0x741, #4
35:                    //    while (!RCONbits.RETEN)
36:                    //        RCONbits.RETEN = 1;
37:                    //    asm("disi #4");
38:                    //    asm("bset DSCON, #15");
39:                    //    asm("nop");
40:                    //    asm("nop");
41:                    //    asm("btss INTTREG, #15");
42:                    //    asm("pwrsav #0");
43:                    RCONbits.DPSLP = 0; /* clear all previous deep sleep wake flags */
002E04  A94741     BCLR 0x741, #2
44:                    DSWAKE = 0; /* clear all previous deep sleep wake flags */
002E06  EF275A     CLR DSWAKE
45:                    /* enter deep sleep code cut and paste from data sheet */
46:                    asm("disi #4");
002E08  FC0004     DISI #0x4
47:                    asm("bset  DSCON, #15");
002E0A  A8E759     BSET 0x759, #7
48:                    asm("nop");
002E0C  000000     NOP
49:                    asm("nop");
002E0E  000000     NOP
50:                    asm("nop");    
002E10  000000     NOP
51:                //    asm("bset  DSCON, #15");
52:                    asm("pwrsav #0");
002E12  FE4000     PWRSAV #0
53:                    //    }
54:                }
002E14  FA8000     ULNK
55:                
56:                
57:                
