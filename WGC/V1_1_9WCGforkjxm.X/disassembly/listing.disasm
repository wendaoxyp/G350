Disassembly Listing for V1_1_9WCGforkjxm
Generated From:
C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/dist/default/production/V1_1_9WCGforkjxm.X.production.elf
2017-11-8 20:10:20

---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                
25:                /*
26:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
27:                
28:                Microchip licenses to you the right to use, modify, copy and distribute
29:                Software only when embedded on a Microchip microcontroller or digital signal
30:                controller that is integrated into your product or third party product
31:                (pursuant to the sublicense terms in the accompanying license agreement).
32:                
33:                You should refer to the license agreement accompanying this Software for
34:                additional information regarding your rights and obligations.
35:                
36:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                 */
47:                
48:                
49:                #include <includes.h>
50:                #include "Configbits.h"
51:                
52:                #ifdef DEBUG_MAIN_VAR
53:                volatile uint32_t rtime;
54:                uint8_t main_cnt = 0;
55:                //uint32_t main_nums;
56:                //volatile uint8_t samplecount;
57:                //volatile uint8_t samplecount1;
58:                #endif
59:                
60:                /*
61:                                         Main application
62:                 */
63:                void main(void) {
0037E4  FA0000     LNK #0x0
64:                    //    uint32_t nums = 1;
65:                    //    uint8_t tmp[10];    
66:                    BSP_Init(); //底层驱动初始化
0037E6  07FF28     RCALL BSP_Init
67:                    NUMS_SHOW(1, 0);
0037E8  EB0080     CLR W1
0037EA  200010     MOV #0x1, W0
0037EC  07F2CA     RCALL NUMS_SHOW
68:                    IFS3bits.RTCIF = 1; //外设相关的中断标志状态位清零
0037EE  A8C08B     BSET 0x8B, #6
69:                    RS485SendString("Start", 5); //先发送一个字节，避免接收错误
0037F0  2914C0     MOV #0x914C, W0
0037F2  B3C051     MOV.B #0x5, W1
0037F4  07FCF7     RCALL RS485SendString
70:                
71:                    while (1) {
72:                        //        Delay1s(5);
73:                        //        WGCPCCop();
74:                        //优化低功耗，关闭模块
75:                        while (!WGCCON2bits.PC_Cop_FLAG && !WGCCON2bits.Send_FLAG) {//如果处于通讯阶段或是发送数据的话，那么就跳过循环
0037F6  370003     BRA 0x37FE
0037FE  804051     MOV WGCCON2bits, W1
003800  280000     MOV #0x8000, W0
003802  608000     AND W1, W0, W0
003804  E00000     CP0 W0
003806  3A0005     BRA NZ, 0x3812
003808  804051     MOV WGCCON2bits, W1
00380A  220000     MOV #0x2000, W0
00380C  608000     AND W1, W0, W0
00380E  E00000     CP0 W0
003810  32FFF3     BRA Z, 0x37F8
003828  37FFEA     BRA 0x37FE
76:                            //设置IO口 并关闭模块
77:                            //            CAT_WP_LAT = 1; //写保护
78:                            //            T1CONbits.TON = 0;
79:                            U1MODEbits.WAKE = 1;
0037F8  A8E220     BSET U1MODE, #7
80:                            Sleep();
0037FA  FE4000     PWRSAV #0
81:                //            DeepSleep();
82:                            U1MODEbits.WAKE = 1;
0037FC  A8E220     BSET U1MODE, #7
83:                        }
84:                        if (WGCCON2bits.Send_FLAG) {
003812  804051     MOV WGCCON2bits, W1
003814  220000     MOV #0x2000, W0
003816  608000     AND W1, W0, W0
003818  E00000     CP0 W0
00381A  320005     BRA Z, 0x3826
85:                            WGCCON2bits.Send_FLAG = 0;
00381C  A9A80B     BCLR 0x80B, #5
86:                            WGCCNTbits.Send_CNT++;
00381E  8040D0     MOV 0x81A, W0
003820  E80000     INC W0, W0
003822  8840D0     MOV W0, 0x81A
87:                            GPRS_Task();
003824  07ECBD     RCALL GPRS_Task
88:                        }
89:                    }
003826  000000     NOP
90:                }
91:                
92:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/WGC.c  --------------------------------------
1:                 #include "WGC.h"
2:                 
3:                 #define TIMEOFFSET 1483200000
4:                 const uint8_t WGC[] = "WGC";
5:                 #define TimeRegAdd 0x00
6:                 #define GPRSRegAdd 0x06
7:                 #define IDRegAdd 0x08
8:                 #define IPRegAdd 0x09
9:                 #define PortRegAdd 0x0d
10:                //#define TimeRegAdd 0x00
11:                const uint8_t RegAdd[] = {0x00, 0x06, 0x08, 0x0a, 0x0b, 0x0f, 0x11};
12:                //const uint8_t RegNum[] = {0x06, 0x01, 0x01, 0x01, 0x04, 0x02};
13:                
14:                //enum {Jan=31,Feb=30,Mar=31,Apr=30,May=31,Jun=30,Jul=31,Aug=31,Sep=30,Oct=31,Nov=30,Dec=31};
15:                //const uint8_t Month[12] = {31, 30, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
16:                const uint8_t GetPressureInt[] = {0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x85, 0xD4}; //获取压力的指令
17:                volatile WGCTIME0BITS WGCTIME0bits;
18:                volatile WGCTIME1BITS WGCTIME1bits;
19:                volatile WGCTIME2BITS WGCTIME2bits;
20:                volatile WGCCON0BITS WGCCON0bits;
21:                volatile WGCCON1BITS WGCCON1bits;
22:                volatile WGCCON2BITS WGCCON2bits;
23:                volatile WGCCON3BITS WGCCON3bits;
24:                volatile WGCCON4BITS WGCCON4bits;
25:                volatile WGCIPBITS WGCIPbits;
26:                volatile WGCCNTBITS WGCCNTbits;
27:                volatile uint16_t WGCPORT;
28:                //volatile WGCPERIODBITS WGCPeriodbits;
29:                volatile uint8_t WGC_Sta = 1;
30:                float f_p;
31:                //struct RTCC_Time_Node RT_node;
32:                
33:                //static volatile struct RTCC_Time_Node rtcc_sample;
34:                //static volatile struct RTCC_Time_Node rtcc_send;
35:                static uint8_t MKSendString(uint8_t* tmp);
36:                static uint8_t HandleArg(uint8_t funcode, uint8_t regadd, uint8_t *arg);
37:                static void RefreshReg(void);
38:                
39:                void WGC_Init(void) {
001152  FA0000     LNK #0x0
40:                    WGCIPbits.IP3 = 183; //设置IP地址
001154  B3CB70     MOV.B #0xB7, W0
001156  B7E817     MOV.B WREG, 0x817
41:                    WGCIPbits.IP2 = 246;
001158  B3CF60     MOV.B #0xF6, W0
00115A  B7E816     MOV.B WREG, 0x816
42:                    WGCIPbits.IP1 = 74;
00115C  B3C4A0     MOV.B #0x4A, W0
00115E  B7E815     MOV.B WREG, 0x815
43:                    WGCIPbits.IP0 = 68;
001160  B3C440     MOV.B #0x44, W0
001162  B7E814     MOV.B WREG, WGCIPbits
44:                    WGCPORT = 5070; //设置端口号
001164  213CE0     MOV #0x13CE, W0
001166  8840E0     MOV W0, WGCPORT
45:                    WGCCON0bits.Send_60s = 1440; //发送2分钟 mark1
001168  804031     MOV WGCCON0bits, W1
00116A  2F8000     MOV #0xF800, W0
00116C  608080     AND W1, W0, W1
00116E  205A00     MOV #0x5A0, W0
001170  700001     IOR W0, W1, W0
001172  884030     MOV W0, WGCCON0bits
46:                    WGCCON1bits.Sample_5s = 2; //采集5秒
001174  804041     MOV WGCCON1bits, W1
001176  280000     MOV #0x8000, W0
001178  608000     AND W1, W0, W0
00117A  A01000     BSET W0, #1
00117C  884040     MOV W0, WGCCON1bits
47:                    WGCCON2bits.E41_Is_Use_For_Send_Data = 0; //关闭E41
00117E  A9080B     BCLR 0x80B, #0
48:                    WGCCON2bits.Debug1 = WGCCON2bits.Debug2 = 0; //关闭E41
001180  A9480B     BCLR 0x80B, #2
001182  804050     MOV WGCCON2bits, W0
001184  DE004A     LSR W0, #10, W0
001186  604061     AND.B W0, #0x1, W0
001188  FB8000     ZE W0, W0
00118A  600061     AND W0, #0x1, W0
00118C  DD0049     SL W0, #9, W0
00118E  804051     MOV WGCCON2bits, W1
001190  A19001     BCLR W1, #9
001192  700001     IOR W0, W1, W0
001194  884050     MOV W0, WGCCON2bits
49:                    WGCCON2bits.WGC_ID = 0x03; //ID号
001196  B3C030     MOV.B #0x3, W0
001198  B7E80A     MOV.B WREG, WGCCON2bits
50:                    //    RTCC_TIME_Init(); //初始化RTCC_TIME数据结构
51:                    WGCCON2bits.Period_FLAG = 1; //初始化开始计算时间
00119A  A8680B     BSET 0x80B, #3
52:                    //    WGCPeriodbits.CNT = 0;
53:                    //    WGCCON2bits.Alarm_RST_FLAG = 0; //上电成重新计算
54:                }
00119C  FA8000     ULNK
00119E  060000     RETURN
55:                
56:                //static void GetPressure(void) {
57:                //    
58:                //}
59:                
60:                //bool WGC_CalcAlarmPeriod(void) {//设置下次报警时间
61:                //    struct tm now_time1, now_time2;
62:                //    uint32_t time1;
63:                //    //获取当前的时间，然后在这个时间的基础上加上秒数
64:                //    while (!RTC_Read_Time(&now_time1)); //容错设计
65:                //    //    while (!RTC_Read_Time(&now_time1)); //容错设计
66:                //    time1 = mktime(&now_time1);
67:                //    time1 += 10;
68:                //    now_time2 = *gmtime(&time1);
69:                //
70:                //    RTC_Set_Alarm(now_time1);
71:                //}
72:                
73:                void GPRS_Task(void) {
0011A0  FA0016     LNK #0x16
74:                    uint8_t tmp[20], bytes = 0, IsErr;
0011A2  EB4000     CLR.B W0
0011A4  784F00     MOV.B W0, [W14]
75:                    HL6528_GetIP_Port(); //每次通讯都更新下IP地址和端口号
0011A6  070DA5     RCALL HL6528_GetIP_Port
76:                    UART2_Open();
0011A8  07116E     RCALL UART2_Open
77:                    Delay1s(5); //避免串口检测不到 最好使用#ifdef
0011AA  B3C050     MOV.B #0x5, W0
0011AC  0708E6     RCALL Delay1s
78:                    WGC_Sta = GPRS_Dingling; //GPRS拨号
0011AE  B3C010     MOV.B #0x1, W0
0011B0  B7E844     MOV.B WREG, 0x844
79:                
80:                    IsErr = HL6528_DialingIsERR();
0011B2  070D16     RCALL HL6528_DialingIsERR
0011B4  984710     MOV.B W0, [W14+1]
81:                    //    RS485SendString1("GPRS ONline Now!!!");
82:                    if (!IsErr) {
0011B6  90401E     MOV.B [W14+1], W0
0011B8  E00400     CP0.B W0
0011BA  3A0016     BRA NZ, 0x11E8
83:                        LED_On();
0011BC  071250     RCALL LED_On
84:                        WGC_Sta = GPRS_Online; //GPRS发送数据
0011BE  B3C020     MOV.B #0x2, W0
0011C0  B7E844     MOV.B WREG, 0x844
85:                        Delay1s(1); //延时1s
0011C2  B3C010     MOV.B #0x1, W0
0011C4  0708DA     RCALL Delay1s
86:                        LED_Off();
0011C6  07124F     RCALL LED_Off
87:                        //        CAT24C512_Read(1, tmp); //获取数据  !!!添加判断 如果I2C错误
88:                        bytes = MKSendString(tmp);
0011C8  E8800E     INC2 W14, W0
0011CA  07039A     RCALL _MKSendString
0011CC  784F00     MOV.B W0, [W14]
89:                        //处理数据
90:                        UART2_SendString2(tmp, bytes); //发送传输数据
0011CE  E8800E     INC2 W14, W0
0011D0  78409E     MOV.B [W14], W1
0011D2  071184     RCALL UART2_SendString2
91:                        Delay1s(1); //延时1s
0011D4  B3C010     MOV.B #0x1, W0
0011D6  0708D1     RCALL Delay1s
92:                        if (WGCCON2bits.Debug2)//测试点2 GPRS
0011D8  804051     MOV WGCCON2bits, W1
0011DA  204000     MOV #0x400, W0
0011DC  608000     AND W1, W0, W0
0011DE  E00000     CP0 W0
0011E0  32000C     BRA Z, 0x11FA
93:                            RS485SendString1("GPRS ONline Now!!!");
0011E2  290DD0     MOV #0x90DD, W0
0011E4  07101A     RCALL RS485SendString1
0011E6  370009     BRA 0x11FA
94:                    } else {
95:                        WGC_Sta = GPRS_Err; //GPRS拨号失败
0011E8  B3C060     MOV.B #0x6, W0
0011EA  B7E844     MOV.B WREG, 0x844
96:                        if (WGCCON2bits.Debug2) {//测试点2 GPRS
0011EC  804051     MOV WGCCON2bits, W1
0011EE  204000     MOV #0x400, W0
0011F0  608000     AND W1, W0, W0
0011F2  E00000     CP0 W0
0011F4  320002     BRA Z, 0x11FA
97:                            RS485SendString1("\r\nGPRS DialingFail!!!Code:");
0011F6  290F00     MOV #0x90F0, W0
0011F8  071010     RCALL RS485SendString1
98:                        }
99:                    }
100:                   HL6528_Close(); //发送AT指令传输数据}
0011FA  070D42     RCALL HL6528_Close
101:                   //    if (IsErr) {
102:                   //        LED_On();
103:                   //        Delay1s(1); //延时1s
104:                   //        LED_Off();
105:                   //    }
106:               }
0011FC  FA8000     ULNK
0011FE  060000     RETURN
107:               
108:               bool Sample_Task(void) {
001200  FA00AC     LNK #0xAC
109:                   StrCmp pressure;
110:                   struct tm nowtime;
111:                   uint8_t Getstr[50] = {0x01, 0x03, 0x04}; //用于保存接收的数据
001202  78008E     MOV W14, W1
001204  B00201     ADD #0x20, W1
001206  090018     REPEAT #0x18
001208  EB1880     CLR [W1++]
00120A  B3C010     MOV.B #0x1, W0
00120C  986700     MOV.B W0, [W14+32]
00120E  B3C030     MOV.B #0x3, W0
001210  986710     MOV.B W0, [W14+33]
001212  B3C040     MOV.B #0x4, W0
001214  986720     MOV.B W0, [W14+34]
112:                   uint8_t Savstr[60] = {0x00}; //uart获取缓冲区数据01 03 04 3E F4 00 00 B6 29
001216  78008E     MOV W14, W1
001218  B00521     ADD #0x52, W1
00121A  09001D     REPEAT #0x1D
00121C  EB1880     CLR [W1++]
113:                   uint8_t Senstr[30] = {0};
00121E  78008E     MOV W14, W1
001220  B008E1     ADD #0x8E, W1
001222  09000E     REPEAT #0xE
001224  EB1880     CLR [W1++]
114:                   uint8_t cnt = 0; //计数
001226  EB4000     CLR.B W0
001228  784F00     MOV.B W0, [W14]
115:               
116:                   //    RS485SendString(Sendstr, 8);
117:                   //    //    RS485SendString(Sendstr, 8);
118:                   //    //    RS485SendString(Sendstr, 8);
119:                   //    Delay1s(1); //延时1s 需要测试下
120:                   //    RS485SendString(Sendstr, 8);
121:                   //    //    RS485SendString(Sendstr, 8);
122:                   //    //    RS485SendString(Sendstr, 8);
123:                   //    Delay1s(1); //延时1s 需要测试下
124:                   pressure.CheckData = Getstr;
00122A  200200     MOV #0x20, W0
00122C  40000E     ADD W0, W14, W0
00122E  980730     MOV W0, [W14+6]
125:                   pressure.Check_len = 3;
001230  B3C030     MOV.B #0x3, W0
001232  984F00     MOV.B W0, [W14+8]
126:                   pressure.GetData = Getstr;
001234  200200     MOV #0x20, W0
001236  40000E     ADD W0, W14, W0
001238  980750     MOV W0, [W14+10]
127:                   pressure.Get_len = 9;
00123A  B3C090     MOV.B #0x9, W0
00123C  984F40     MOV.B W0, [W14+12]
128:                   pressure.SourceData = Savstr;
00123E  200520     MOV #0x52, W0
001240  40000E     ADD W0, W14, W0
001242  980710     MOV W0, [W14+2]
129:               //    WGCPCCop()
130:               //    ClearBuffer(BufferRead_UART1);//避免数据过多导致缓冲区满接收失败
131:                   do {
132:                       cnt++;
001244  E84F1E     INC.B [W14], [W14]
133:                       if (cnt > 3)
001246  78401E     MOV.B [W14], W0
001248  504FE3     SUB.B W0, #0x3, [W15]
00124A  360002     BRA LEU, 0x1250
134:                           return false; //循环5次后，还未获取到有效的压力值，直接返回false 添加错误提示
00124C  EB4000     CLR.B W0
00124E  37003C     BRA 0x12C8
135:                       RS485SendString(GetPressureInt, 8);
001250  200081     MOV #0x8, W1
001252  290D50     MOV #0x90D5, W0
001254  070FC7     RCALL RS485SendString
136:                       Delay100ms(5); //延时2s 必须小于1s 避免其他指令获取数据导致数据丢失
001256  B3C050     MOV.B #0x5, W0
001258  070873     RCALL Delay100ms
137:                       pressure.Source_len = UARTGetData(BufferRead_UART1, Savstr, 50);
00125A  200520     MOV #0x52, W0
00125C  40000E     ADD W0, W14, W0
00125E  B3C322     MOV.B #0x32, W2
001260  780080     MOV W0, W1
001262  228DC0     MOV #0x28DC, W0
001264  070C50     RCALL UARTGetData
001266  984740     MOV.B W0, [W14+4]
138:               
139:                   } while (!UARTDataIsRight(&pressure));
001268  E8800E     INC2 W14, W0
00126A  070B8A     RCALL UARTDataIsRight
00126C  A20400     BTG.B W0, #0
00126E  E00400     CP0.B W0
001270  3AFFE9     BRA NZ, 0x1244
140:                   CharToFloat(&f_p, Getstr + 3);
001272  200200     MOV #0x20, W0
001274  40000E     ADD W0, W14, W0
001276  400063     ADD W0, #0x3, W0
001278  780080     MOV W0, W1
00127A  2081E0     MOV #0x81E, W0
00127C  07077F     RCALL CharToFloat
141:               //#ifdef DEBUG_PRESSURE
142:               //    RS485SendString1("\r\nGet Pressure!!!\r\n10Mp:");
143:               //    CharToFloat(&f_p, Getstr + 3);
144:               //    f_p *= 10;
145:               //    printnums((uint32_t) (f_p));
146:               //    RS485SendString1("\r\n");
147:               //    PrintTime(); //打印时间
148:               //#endif
149:                   RTC_Read_Time(&nowtime);
00127E  47006E     ADD W14, #0xE, W0
001280  0709A5     RCALL RTC_Read_Time
150:                   Senstr[0] = 0x20;
001282  B3C200     MOV.B #0x20, W0
001284  994F60     MOV.B W0, [W14+142]
151:                   Senstr[1] = nowtime.tm_year & 0x00ff;
001286  90084E     MOV [W14+24], W0
001288  784000     MOV.B W0, W0
00128A  994F70     MOV.B W0, [W14+143]
152:                   Senstr[2] = nowtime.tm_mon;
00128C  90083E     MOV [W14+22], W0
00128E  784000     MOV.B W0, W0
001290  995700     MOV.B W0, [W14+144]
153:                   Senstr[3] = nowtime.tm_mday;
001292  90082E     MOV [W14+20], W0
001294  784000     MOV.B W0, W0
001296  995710     MOV.B W0, [W14+145]
154:                   Senstr[4] = nowtime.tm_hour;
001298  90081E     MOV [W14+18], W0
00129A  784000     MOV.B W0, W0
00129C  995720     MOV.B W0, [W14+146]
155:                   Senstr[5] = nowtime.tm_min;
00129E  90080E     MOV [W14+16], W0
0012A0  784000     MOV.B W0, W0
0012A2  995730     MOV.B W0, [W14+147]
156:                   Senstr[6] = nowtime.tm_sec;
0012A4  90007E     MOV [W14+14], W0
0012A6  784000     MOV.B W0, W0
0012A8  995740     MOV.B W0, [W14+148]
157:                   CopyDat(Senstr + 7, Getstr + 3, 4); //赋值数据
0012AA  200200     MOV #0x20, W0
0012AC  40000E     ADD W0, W14, W0
0012AE  4000E3     ADD W0, #0x3, W1
0012B0  2008E0     MOV #0x8E, W0
0012B2  40000E     ADD W0, W14, W0
0012B4  400067     ADD W0, #0x7, W0
0012B6  B3C042     MOV.B #0x4, W2
0012B8  07087D     RCALL CopyDat
158:                   Senstr[11] = Sum_Check(Senstr, 11);
0012BA  2008E0     MOV #0x8E, W0
0012BC  40000E     ADD W0, W14, W0
0012BE  B3C0B1     MOV.B #0xB, W1
0012C0  07101E     RCALL Sum_Check
0012C2  784000     MOV.B W0, W0
0012C4  995F10     MOV.B W0, [W14+153]
159:                   //    CAT24C512_Write(Savstr); //存储数据
160:                   return true;
0012C6  B3C010     MOV.B #0x1, W0
161:               
162:                   //#ifdef DEBUG_PRESSURE
163:                   //    RS485SendString1("\r\nCan't get pressure!!!\r\n");
164:                   //#endif
165:               
166:               }
0012C8  FA8000     ULNK
0012CA  060000     RETURN
167:               
168:               
169:               
170:               //    if (WGCCON2bits.Alarm_RST_FLAG) {//如果需要重启的话,那么重新计算周期参数；反之，设置下次报警的时间
171:               //        WGCCON2bits.Alarm_RST_FLAG = 0; //清楚标志为
172:               //        if (WGCCON0bits.Send_60s < 3)//发送阈值判断
173:               //            WGCCON0bits.Send_60s = 3;
174:               //        else if (WGCCON0bits.Send_60s > 1440)
175:               //            WGCCON0bits.Send_60s = 1440;
176:               //        if (WGCCON1bits.Sample_5s < 1)//采集阈值判断
177:               //            WGCCON1bits.Sample_5s = 1;
178:               //        else if (WGCCON1bits.Sample_5s > 17280)
179:               //            WGCCON1bits.Sample_5s = 17280;
180:               //
181:               //        if (WGCCON1bits.Sample_5s > (WGCCON0bits.Send_60s * 12))//如果采集时间大于发送时间，那么将采集时间设置为发送时间
182:               //            WGCCON1bits.Sample_5s = WGCCON0bits.Send_60s * 12;
183:               //        WGCPeriodbits.B1 = (WGCCON0bits.Send_60s * 12) / WGCCON1bits.Sample_5s; //倍数
184:               //        WGCPeriodbits.Y2 = (WGCCON0bits.Send_60s * 12) % WGCCON1bits.Sample_5s; //余数     
185:               //        WGCPeriodbits.CNT = 0; //清楚计数
186:               //    }
187:               
188:               
189:               
190:               //    if (WGCPeriodbits.CNT == WGCPeriodbits.B1) {//下个时间就是发送的时间
191:               //        //设置报警时间为余数的时间
192:               //        if (!WGCPeriodbits.Y2) {//如果余数为0的话，那么直接设置下次采集时间（上传时间已经到了），反之，设置下次计算上传时间
193:               //            now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
194:               //            //开始调用GPRS上传数据
195:               //            WGCCON2bits.Send_FLAG = 1; //采集时间和发送时间均到了
196:               //            WGCPeriodbits.CNT = 0;
197:               //        } else {
198:               //            now_second += WGCPeriodbits.Y2 * 5; //设置上传时间
199:               //            WGCPeriodbits.CNT += 1;
200:               //        }
201:               //    } else if (WGCPeriodbits.CNT > WGCPeriodbits.B1) {
202:               //        now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
203:               //        //开始调用GPRS上传数据
204:               //        WGCPeriodbits.CNT = 0;
205:               //    } else {
206:               //        //设置报警时间为采集的时间
207:               //        WGCCON2bits.Sample_FLAG = 1;
208:               //        now_second += (WGCCON1bits.Sample_5s * 5); //加上报警的时间
209:               //        WGCPeriodbits.CNT += 1;
210:               //    }
211:               
212:               uint32_t CalaAlarmTime(void) {
0012CC  FA0004     LNK #0x4
213:                   static uint8_t cnt = 0;
214:                   static uint32_t all_alarm_time = 0;
215:                   uint32_t alarm_time = 0; //, tmp;
0012CE  B80060     MUL.UU W0, #0, W0
0012D0  BE8F00     MOV.D W0, [W14]
216:               
217:                   if (WGCCON2bits.Period_FLAG) {
0012D2  804051     MOV WGCCON2bits, W1
0012D4  208000     MOV #0x800, W0
0012D6  608000     AND W1, W0, W0
0012D8  E00000     CP0 W0
0012DA  32005B     BRA Z, 0x1392
218:                       WGCCON2bits.Period_FLAG = 0;
0012DC  A9680B     BCLR 0x80B, #3
219:               #ifdef DEBUG_RTCC_TIME
220:                       WGCCON3bits.delay = 10; //采集时间
221:                       WGCCON3bits.count = 6; //计算采集的次数
222:                       WGCCON4bits.delay = 0; //计算上传的时间 总时间为12*3+3=39s
223:                       WGCCON4bits.count = 0; //上传累计次数清零
224:               #else
225:                       WGCCON3bits.delay = WGCCON1bits.Sample_5s * 5; //采集时间
0012DE  804041     MOV WGCCON1bits, W1
0012E0  27FFF0     MOV #0x7FFF, W0
0012E2  608000     AND W1, W0, W0
0012E4  B90065     MUL.SU W0, #5, W0
0012E6  780000     MOV W0, W0
0012E8  DE80CF     ASR W0, #15, W1
0012EA  2FFFF2     MOV #0xFFFF, W2
0012EC  200013     MOV #0x1, W3
0012EE  780280     MOV W0, W5
0012F0  780081     MOV W1, W1
0012F2  780202     MOV W2, W4
0012F4  780003     MOV W3, W0
0012F6  628204     AND W5, W4, W4
0012F8  608000     AND W1, W0, W0
0012FA  EB0080     CLR W1
0012FC  DD00C0     SL W0, #0, W1
0012FE  200000     MOV #0x0, W0
001300  BE0100     MOV.D W0, W2
001302  B82061     MUL.UU W4, #1, W0
001304  710100     IOR W2, W0, W2
001306  718181     IOR W3, W1, W3
001308  BE0002     MOV.D W2, W0
00130A  884060     MOV W0, WGCCON3bits
00130C  608061     AND W1, #0x1, W0
00130E  804071     MOV 0x80E, W1
001310  A10001     BCLR W1, #0
001312  700001     IOR W0, W1, W0
001314  884070     MOV W0, 0x80E
226:                       WGCCON3bits.count = WGCCON0bits.Send_60s * 12 / WGCCON1bits.Sample_5s; //计算采集的次数 当WGCCON1bits.Sample_5s=0时触发数学错误
001316  804031     MOV WGCCON0bits, W1
001318  207FF0     MOV #0x7FF, W0
00131A  608000     AND W1, W0, W0
00131C  B9006C     MUL.SU W0, #12, W0
00131E  780080     MOV W0, W1
001320  804042     MOV WGCCON1bits, W2
001322  27FFF0     MOV #0x7FFF, W0
001324  610000     AND W2, W0, W0
001326  780100     MOV W0, W2
001328  090011     REPEAT #0x11
00132A  D80082     DIV.SW W1, W2
00132C  780080     MOV W0, W1
00132E  27FFF0     MOV #0x7FFF, W0
001330  608000     AND W1, W0, W0
001332  400000     ADD W0, W0, W0
001334  804071     MOV 0x80E, W1
001336  6080E1     AND W1, #0x1, W1
001338  700001     IOR W0, W1, W0
00133A  884070     MOV W0, 0x80E
227:                       WGCCON4bits.delay = WGCCON0bits.Send_60s * 60; //(WGCCON0bits.Send_60s * 12 % WGCCON1bits.Sample_5s)*5; //计算上传的时间
00133C  804031     MOV WGCCON0bits, W1
00133E  207FF0     MOV #0x7FF, W0
001340  608000     AND W1, W0, W0
001342  780080     MOV W0, W1
001344  2003C0     MOV #0x3C, W0
001346  B98800     MUL.SS W1, W0, W0
001348  780000     MOV W0, W0
00134A  DE80CF     ASR W0, #15, W1
00134C  2FFFF2     MOV #0xFFFF, W2
00134E  200013     MOV #0x1, W3
001350  780280     MOV W0, W5
001352  780081     MOV W1, W1
001354  780202     MOV W2, W4
001356  780003     MOV W3, W0
001358  628204     AND W5, W4, W4
00135A  608000     AND W1, W0, W0
00135C  EB0080     CLR W1
00135E  DD00C0     SL W0, #0, W1
001360  200000     MOV #0x0, W0
001362  BE0100     MOV.D W0, W2
001364  B82061     MUL.UU W4, #1, W0
001366  710100     IOR W2, W0, W2
001368  718181     IOR W3, W1, W3
00136A  BE0002     MOV.D W2, W0
00136C  884080     MOV W0, WGCCON4bits
00136E  608061     AND W1, #0x1, W0
001370  804091     MOV 0x812, W1
001372  A10001     BCLR W1, #0
001374  700001     IOR W0, W1, W0
001376  884090     MOV W0, 0x812
228:                       WGCCON4bits.count = 0; //上传累计次数清零
001378  804090     MOV 0x812, W0
00137A  600061     AND W0, #0x1, W0
00137C  884090     MOV W0, 0x812
229:                       WGCCON2bits.Sample_FLAG = 0;
00137E  A9880B     BCLR 0x80B, #4
230:                       WGCCON2bits.Send_FLAG = 0;
001380  A9A80B     BCLR 0x80B, #5
231:               #endif
232:                       //        WGCCON2bits.Cala_Time_Is_Mod = WGCCON4bits.delay % WGCCON3bits.delay;
233:                       alarm_time = WGCCON3bits.delay; //返回第一次采集时间
001382  804060     MOV WGCCON3bits, W0
001384  804072     MOV 0x80E, W2
001386  6100E1     AND W2, #0x1, W1
001388  BE8F00     MOV.D W0, [W14]
234:                       all_alarm_time = alarm_time; //将累计值初始化
00138A  BE011E     MOV.D [W14], W2
00138C  884112     MOV W2, all_alarm_time
00138E  884123     MOV W3, 0x824
001390  370098     BRA 0x14C2
235:                   } else {
236:                       if (cnt < WGCCON3bits.count - 1) {//如果技术的时间还没有到，那么继续将定时设置为采集的时间
001392  BFC826     MOV.B cnt, WREG
001394  FB8080     ZE W0, W1
001396  804070     MOV 0x80E, W0
001398  D10000     LSR W0, W0
00139A  E90000     DEC W0, W0
00139C  508F80     SUB W1, W0, [W15]
00139E  3D0012     BRA GE, 0x13C4
237:                           WGCCON2bits.Sample_FLAG = 1;
0013A0  A8880B     BSET 0x80B, #4
238:                           StartTMR2();
0013A2  071216     RCALL StartTMR2
239:                           IFS0bits.T2IF = 1;
0013A4  A8E084     BSET IFS0, #7
240:                           cnt += 1;
0013A6  BFC826     MOV.B cnt, WREG
0013A8  E84000     INC.B W0, W0
0013AA  B7E826     MOV.B WREG, cnt
241:               #ifdef DEBUG_RTCC_TIME
242:                           samplecount = cnt;
243:               #endif
244:                           alarm_time = WGCCON3bits.delay; //1160
0013AC  804060     MOV WGCCON3bits, W0
0013AE  804072     MOV 0x80E, W2
0013B0  6100E1     AND W2, #0x1, W1
0013B2  BE8F00     MOV.D W0, [W14]
245:                           all_alarm_time += alarm_time;
0013B4  804110     MOV all_alarm_time, W0
0013B6  804121     MOV 0x824, W1
0013B8  40013E     ADD W0, [W14++], W2
0013BA  4881AE     ADDC W1, [W14--], W3
0013BC  BE0002     MOV.D W2, W0
0013BE  884110     MOV W0, all_alarm_time
0013C0  884121     MOV W1, 0x824
0013C2  37007F     BRA 0x14C2
246:                       } else {//如果采集计数和规定的时间计数相同，那么需要判断是否采集时间是否是上传时间的整数倍
247:                           //            tmp = WGCCON3bits.delay * cnt + last_alarm_time; //
248:                           if (WGCCON4bits.delay != all_alarm_time) {//如果发送时间刚好是采集时间的整数倍的话，将控制寄存器2标志为置1、设置下次定时时间
0013C4  804080     MOV WGCCON4bits, W0
0013C6  804092     MOV 0x812, W2
0013C8  6100E1     AND W2, #0x1, W1
0013CA  BE0100     MOV.D W0, W2
0013CC  804110     MOV all_alarm_time, W0
0013CE  804121     MOV 0x824, W1
0013D0  510F80     SUB W2, W0, [W15]
0013D2  598F81     SUBB W3, W1, [W15]
0013D4  32004E     BRA Z, 0x1472
249:                               if (WGCCON4bits.count) {
0013D6  804090     MOV 0x812, W0
0013D8  A10000     BCLR W0, #0
0013DA  E00000     CP0 W0
0013DC  320033     BRA Z, 0x1444
250:                                   WGCCON4bits.count = 0;
0013DE  804090     MOV 0x812, W0
0013E0  600061     AND W0, #0x1, W0
0013E2  884090     MOV W0, 0x812
251:                                   WGCCON2bits.Send_FLAG = 1;
0013E4  A8A80B     BSET 0x80B, #5
252:                                   cnt = 0;
0013E6  EF6826     CLR.B cnt
253:                                   //                    alarm_time = WGCCON3bits.delay - all_alarm_time;
254:                                   all_alarm_time += WGCCON3bits.delay;
0013E8  804060     MOV WGCCON3bits, W0
0013EA  804072     MOV 0x80E, W2
0013EC  6100E1     AND W2, #0x1, W1
0013EE  BE0100     MOV.D W0, W2
0013F0  804110     MOV all_alarm_time, W0
0013F2  804121     MOV 0x824, W1
0013F4  400002     ADD W0, W2, W0
0013F6  488083     ADDC W1, W3, W1
0013F8  884110     MOV W0, all_alarm_time
0013FA  884121     MOV W1, 0x824
255:                                   alarm_time = all_alarm_time % WGCCON4bits.delay;
0013FC  804114     MOV all_alarm_time, W4
0013FE  804125     MOV 0x824, W5
001400  804080     MOV WGCCON4bits, W0
001402  804092     MOV 0x812, W2
001404  6100E1     AND W2, #0x1, W1
001406  BE0100     MOV.D W0, W2
001408  BE0004     MOV.D W4, W0
00140A  07FBBE     RCALL 0xB88
00140C  BE8F00     MOV.D W0, [W14]
256:                                   all_alarm_time = alarm_time;
00140E  BE011E     MOV.D [W14], W2
001410  884112     MOV W2, all_alarm_time
001412  884123     MOV W3, 0x824
257:                                   WGCCON3bits.count = (WGCCON4bits.delay - all_alarm_time) / WGCCON3bits.delay + 1; //重新计算上线的次数
001414  804080     MOV WGCCON4bits, W0
001416  804092     MOV 0x812, W2
001418  6100E1     AND W2, #0x1, W1
00141A  BE0100     MOV.D W0, W2
00141C  804110     MOV all_alarm_time, W0
00141E  804121     MOV 0x824, W1
001420  510200     SUB W2, W0, W4
001422  598281     SUBB W3, W1, W5
001424  804060     MOV WGCCON3bits, W0
001426  804072     MOV 0x80E, W2
001428  6100E1     AND W2, #0x1, W1
00142A  BE0100     MOV.D W0, W2
00142C  BE0004     MOV.D W4, W0
00142E  07FB9C     RCALL 0xB68
001430  780000     MOV W0, W0
001432  E80080     INC W0, W1
001434  27FFF0     MOV #0x7FFF, W0
001436  608000     AND W1, W0, W0
001438  400000     ADD W0, W0, W0
00143A  804071     MOV 0x80E, W1
00143C  6080E1     AND W1, #0x1, W1
00143E  700001     IOR W0, W1, W0
001440  884070     MOV W0, 0x80E
001442  37003F     BRA 0x14C2
258:                               } else {//一个周期的最后一次采集任务
259:               #ifdef DEBUG_RTCC_TIME
260:                                   samplecount = cnt + 1;
261:               #endif 
262:                                   WGCCON2bits.Sample_FLAG = 1;
001444  A8880B     BSET 0x80B, #4
263:                                   StartTMR2();
001446  0711C4     RCALL StartTMR2
264:                                   IFS0bits.T2IF = 1;
001448  A8E084     BSET IFS0, #7
265:                                   WGCCON4bits.count += 1; //上线次数加1
00144A  804090     MOV 0x812, W0
00144C  D10000     LSR W0, W0
00144E  E80000     INC W0, W0
001450  780080     MOV W0, W1
001452  27FFF0     MOV #0x7FFF, W0
001454  608000     AND W1, W0, W0
001456  400000     ADD W0, W0, W0
001458  804091     MOV 0x812, W1
00145A  6080E1     AND W1, #0x1, W1
00145C  700001     IOR W0, W1, W0
00145E  884090     MOV W0, 0x812
266:                                   alarm_time = WGCCON4bits.delay - all_alarm_time; //表示过n秒后到了上传的时间
001460  804080     MOV WGCCON4bits, W0
001462  804092     MOV 0x812, W2
001464  6100E1     AND W2, #0x1, W1
001466  BE0100     MOV.D W0, W2
001468  804110     MOV all_alarm_time, W0
00146A  804121     MOV 0x824, W1
00146C  511F00     SUB W2, W0, [W14++]
00146E  599701     SUBB W3, W1, [W14--]
001470  370028     BRA 0x14C2
267:                                   //                    all_alarm_time += ;
268:                               }
269:                           } else {//反之，采样时间==发送时间
270:               #ifdef DEBUG_RTCC_TIME
271:                               samplecount = cnt + 1;
272:               #endif
273:                               WGCCON2bits.Sample_FLAG = WGCCON2bits.Send_FLAG = 1;
001472  A8A80B     BSET 0x80B, #5
001474  804050     MOV WGCCON2bits, W0
001476  DE004D     LSR W0, #13, W0
001478  604061     AND.B W0, #0x1, W0
00147A  FB8000     ZE W0, W0
00147C  600061     AND W0, #0x1, W0
00147E  DD004C     SL W0, #12, W0
001480  804051     MOV WGCCON2bits, W1
001482  A1C001     BCLR W1, #12
001484  700001     IOR W0, W1, W0
001486  884050     MOV W0, WGCCON2bits
274:                               StartTMR2();
001488  0711A3     RCALL StartTMR2
275:                               IFS0bits.T2IF = 1;
00148A  A8E084     BSET IFS0, #7
276:                               cnt = 0; //清楚内部计数
00148C  EF6826     CLR.B cnt
277:                               alarm_time = WGCCON3bits.delay;
00148E  804060     MOV WGCCON3bits, W0
001490  804072     MOV 0x80E, W2
001492  6100E1     AND W2, #0x1, W1
001494  BE8F00     MOV.D W0, [W14]
278:                               all_alarm_time = WGCCON3bits.delay;
001496  804060     MOV WGCCON3bits, W0
001498  804072     MOV 0x80E, W2
00149A  6100E1     AND W2, #0x1, W1
00149C  884110     MOV W0, all_alarm_time
00149E  884121     MOV W1, 0x824
279:                               WGCCON3bits.count = WGCCON4bits.delay / WGCCON3bits.delay; //重新计算上线的次数
0014A0  804084     MOV WGCCON4bits, W4
0014A2  804090     MOV 0x812, W0
0014A4  6002E1     AND W0, #0x1, W5
0014A6  804060     MOV WGCCON3bits, W0
0014A8  804072     MOV 0x80E, W2
0014AA  6100E1     AND W2, #0x1, W1
0014AC  BE0100     MOV.D W0, W2
0014AE  BE0004     MOV.D W4, W0
0014B0  07FB5B     RCALL 0xB68
0014B2  780080     MOV W0, W1
0014B4  27FFF0     MOV #0x7FFF, W0
0014B6  608000     AND W1, W0, W0
0014B8  400000     ADD W0, W0, W0
0014BA  804071     MOV 0x80E, W1
0014BC  6080E1     AND W1, #0x1, W1
0014BE  700001     IOR W0, W1, W0
0014C0  884070     MOV W0, 0x80E
280:                           }
281:                       }
282:                   }
283:                   //    if (!last_alarm_time) {//如果最后一次设置的报警时间为0的话，那么直接
284:                   //        alarm_time = WGCCON3bits.delay;
285:                   //        last_alarm_time = 0;
286:                   //    }
287:               #ifdef DEBUG_RTCC_COUNT
288:                   if (WGCCON2bits.Sample_FLAG)
289:                       RS485SendString("/r/nsample:", 9);
290:                   if (WGCCON2bits.Send_FLAG)
291:                       RS485SendString("/r/nsend:", 7);
292:               #endif
293:                   return alarm_time;
0014C2  BE001E     MOV.D [W14], W0
294:               }
0014C4  FA8000     ULNK
0014C6  060000     RETURN
295:               
296:               void SetNextAlarm(uint32_t sample_sec) {
0014C8  FA0018     LNK #0x18
0014CA  980F20     MOV W0, [W14+20]
0014CC  980F31     MOV W1, [W14+22]
297:                   struct tm time1;
298:                   uint8_t tmp, tmp1;
299:               
300:                   enum {
301:                       sec, min, hour, day, mon, year
302:                   };
303:               
304:                   while (!RTC_Read_Time(&time1)); //容错设计
0014CE  000000     NOP
0014D0  E8800E     INC2 W14, W0
0014D2  07087C     RCALL RTC_Read_Time
0014D4  E00000     CP0 W0
0014D6  32FFFC     BRA Z, 0x14D0
305:                   tmp = (HCD(time1.tm_sec) + sample_sec); //计算秒数
0014D8  90001E     MOV [W14+2], W0
0014DA  784000     MOV.B W0, W0
0014DC  07067D     RCALL HCD
0014DE  9008AE     MOV [W14+20], W1
0014E0  784081     MOV.B W1, W1
0014E2  404F01     ADD.B W0, W1, [W14]
306:                   time1.tm_sec = DCH(tmp % 60);
0014E4  FB809E     ZE [W14], W1
0014E6  2003C0     MOV #0x3C, W0
0014E8  780100     MOV W0, W2
0014EA  090011     REPEAT #0x11
0014EC  D88082     DIV.UW W1, W2
0014EE  FD0080     EXCH W0, W1
0014F0  784000     MOV.B W0, W0
0014F2  070682     RCALL DCH
0014F4  FB8000     ZE W0, W0
0014F6  980710     MOV W0, [W14+2]
307:                   tmp1 = tmp / 60; //分钟是否溢出
0014F8  FB809E     ZE [W14], W1
0014FA  2003C0     MOV #0x3C, W0
0014FC  780100     MOV W0, W2
0014FE  090011     REPEAT #0x11
001500  D88082     DIV.UW W1, W2
001502  984710     MOV.B W0, [W14+1]
308:                   if (tmp1 > 0)//如果累加的时间大于60s
001504  90401E     MOV.B [W14+1], W0
001506  E00400     CP0.B W0
001508  32002D     BRA Z, 0x1564
309:                   {
310:                       tmp = (HCD(time1.tm_min) + tmp1);
00150A  90002E     MOV [W14+4], W0
00150C  784000     MOV.B W0, W0
00150E  070664     RCALL HCD
001510  90409E     MOV.B [W14+1], W1
001512  404F01     ADD.B W0, W1, [W14]
311:                       time1.tm_min = DCH(tmp % 60);
001514  FB809E     ZE [W14], W1
001516  2003C0     MOV #0x3C, W0
001518  780100     MOV W0, W2
00151A  090011     REPEAT #0x11
00151C  D88082     DIV.UW W1, W2
00151E  FD0080     EXCH W0, W1
001520  784000     MOV.B W0, W0
001522  07066A     RCALL DCH
001524  FB8000     ZE W0, W0
001526  980720     MOV W0, [W14+4]
312:                       tmp1 = tmp / 60;
001528  FB809E     ZE [W14], W1
00152A  2003C0     MOV #0x3C, W0
00152C  780100     MOV W0, W2
00152E  090011     REPEAT #0x11
001530  D88082     DIV.UW W1, W2
001532  984710     MOV.B W0, [W14+1]
313:                       if (tmp1 > 0) {
001534  90401E     MOV.B [W14+1], W0
001536  E00400     CP0.B W0
001538  320015     BRA Z, 0x1564
314:                           tmp = (HCD(time1.tm_hour) + tmp1);
00153A  90003E     MOV [W14+6], W0
00153C  784000     MOV.B W0, W0
00153E  07064C     RCALL HCD
001540  90409E     MOV.B [W14+1], W1
001542  404F01     ADD.B W0, W1, [W14]
315:                           time1.tm_hour = DCH(tmp % 24);
001544  FB809E     ZE [W14], W1
001546  200180     MOV #0x18, W0
001548  780100     MOV W0, W2
00154A  090011     REPEAT #0x11
00154C  D88082     DIV.UW W1, W2
00154E  FD0080     EXCH W0, W1
001550  784000     MOV.B W0, W0
001552  070652     RCALL DCH
001554  FB8000     ZE W0, W0
001556  980730     MOV W0, [W14+6]
316:                           tmp1 = tmp / 24;
001558  FB809E     ZE [W14], W1
00155A  200180     MOV #0x18, W0
00155C  780100     MOV W0, W2
00155E  090011     REPEAT #0x11
001560  D88082     DIV.UW W1, W2
001562  984710     MOV.B W0, [W14+1]
317:                       }
318:                   }
319:                   RTC_Set_Alarm(time1); //每日一次闹钟
001564  4787F2     ADD W15, #0x12, W15
001566  578072     SUB W15, #0x12, W0
001568  4700E2     ADD W14, #0x2, W1
00156A  090008     REPEAT #0x8
00156C  781831     MOV [W1++], [W0++]
00156E  B10120     SUB #0x12, W0
001570  0707FA     RCALL RTC_Set_Alarm
001572  5787F2     SUB W15, #0x12, W15
320:               }
001574  FA8000     ULNK
001576  060000     RETURN
321:               
322:               //void WGCGetArg(void) {
323:               //    do {
324:               //
325:               //    } while ();
326:               //}
327:               
328:               bool WGCPCCop(void) {
001578  FA00A4     LNK #0xA4
329:                   StrCmp stcp;
330:                   uint8_t tmp[50]; //串口接受到的数据
331:                   uint8_t tmp1[50]; //截取后的数据
332:                   uint8_t tmp2[50]; //处理后要发送的数据
333:                   uint8_t cnt;
334:               
335:                   stcp.SourceData = tmp;
00157A  47006E     ADD W14, #0xE, W0
00157C  980710     MOV W0, [W14+2]
336:                   stcp.Source_len = UARTGetData(BufferRead_UART1, stcp.SourceData, 50); //获取mark
00157E  90001E     MOV [W14+2], W0
001580  B3C322     MOV.B #0x32, W2
001582  780080     MOV W0, W1
001584  228DC0     MOV #0x28DC, W0
001586  070ABF     RCALL UARTGetData
001588  984740     MOV.B W0, [W14+4]
337:                   stcp.CheckData = (uint8_t*) WGC;
00158A  290CA0     MOV #0x90CA, W0
00158C  980730     MOV W0, [W14+6]
338:                   stcp.Check_len = 3;
00158E  B3C030     MOV.B #0x3, W0
001590  984F00     MOV.B W0, [W14+8]
339:                   stcp.GetData = tmp1;
001592  200400     MOV #0x40, W0
001594  40000E     ADD W0, W14, W0
001596  980750     MOV W0, [W14+10]
340:                   stcp.Get_len = 30;
001598  B3C1E0     MOV.B #0x1E, W0
00159A  984F40     MOV.B W0, [W14+12]
341:                   stcp.Real_len = 0;
00159C  EB4000     CLR.B W0
00159E  984F50     MOV.B W0, [W14+13]
342:               
343:                   if (UARTDataIsRight(&stcp) && CheckIsRight(CRC16_Check, tmp1, stcp.Real_len - 2)) {
0015A0  E8800E     INC2 W14, W0
0015A2  0709EE     RCALL UARTDataIsRight
0015A4  E00400     CP0.B W0
0015A6  3200AB     BRA Z, 0x16FE
0015A8  90485E     MOV.B [W14+13], W0
0015AA  E9C080     DEC2.B W0, W1
0015AC  200400     MOV #0x40, W0
0015AE  40000E     ADD W0, W14, W0
0015B0  784101     MOV.B W1, W2
0015B2  780080     MOV W0, W1
0015B4  2327C0     MOV #0x327C, W0
0015B6  070EB9     RCALL CheckIsRight
0015B8  E00400     CP0.B W0
0015BA  3200A1     BRA Z, 0x16FE
344:                       //根据寄存器地址、数量、数据长度和数据,判断进行设置数据
345:                       CopyDat(tmp2, tmp1, 4); //数据帧头+功能码  
0015BC  200401     MOV #0x40, W1
0015BE  40808E     ADD W1, W14, W1
0015C0  200720     MOV #0x72, W0
0015C2  40000E     ADD W0, W14, W0
0015C4  B3C042     MOV.B #0x4, W2
0015C6  0706F6     RCALL CopyDat
346:                       tmp2[4] = RegAdd[*(tmp1 + 4)+*(tmp1 + 5)] - RegAdd[*(tmp1 + 4)];
0015C8  200400     MOV #0x40, W0
0015CA  40000E     ADD W0, W14, W0
0015CC  400064     ADD W0, #0x4, W0
0015CE  784010     MOV.B [W0], W0
0015D0  FB8080     ZE W0, W1
0015D2  200400     MOV #0x40, W0
0015D4  40000E     ADD W0, W14, W0
0015D6  400065     ADD W0, #0x5, W0
0015D8  784010     MOV.B [W0], W0
0015DA  FB8000     ZE W0, W0
0015DC  408000     ADD W1, W0, W0
0015DE  290CE1     MOV #0x90CE, W1
0015E0  7840E1     MOV.B [W1+W0], W1
0015E2  200400     MOV #0x40, W0
0015E4  40000E     ADD W0, W14, W0
0015E6  400064     ADD W0, #0x4, W0
0015E8  784010     MOV.B [W0], W0
0015EA  FB8000     ZE W0, W0
0015EC  290CE2     MOV #0x90CE, W2
0015EE  784062     MOV.B [W2+W0], W0
0015F0  50C000     SUB.B W1, W0, W0
0015F2  98F760     MOV.B W0, [W14+118]
347:                       if (tmp2[4] > RegAdd[6])//避免数据溢出错误
0015F4  90F0EE     MOV.B [W14+118], W1
0015F6  290D40     MOV #0x90D4, W0
0015F8  784010     MOV.B [W0], W0
0015FA  50CF80     SUB.B W1, W0, [W15]
0015FC  360003     BRA LEU, 0x1604
348:                           tmp2[4] = RegAdd[6];
0015FE  290D40     MOV #0x90D4, W0
001600  784010     MOV.B [W0], W0
001602  98F760     MOV.B W0, [W14+118]
349:                       switch (*(tmp1 + 3)) {
001604  200400     MOV #0x40, W0
001606  40000E     ADD W0, W14, W0
001608  400063     ADD W0, #0x3, W0
00160A  784010     MOV.B [W0], W0
00160C  FB8000     ZE W0, W0
00160E  500FE3     SUB W0, #0x3, [W15]
001610  32005A     BRA Z, 0x16C6
001612  500FE4     SUB W0, #0x4, [W15]
001614  3A0072     BRA NZ, 0x16FA
350:                           case 0x04:
351:                           {
352:                               //加阈值保护                
353:                               // *send: 57 47 43 04 00 06 17 12 10 12 10 20 00 03 00 05 03 B7 F6 4A 44 12 CE 4E 09   
354:                               // *rec:57 47 43 04 11 17 12 10 12 10 20 00 03 00 05 03 B7 F6 4A 44 12 CE 6B A1
355:                               if ((((uint16_t) tmp1[12] << 8) + tmp1[13]) < 3) {//阈值处理
001616  90C84E     MOV.B [W14+76], W0
001618  FB8000     ZE W0, W0
00161A  DD00C8     SL W0, #8, W1
00161C  90C85E     MOV.B [W14+77], W0
00161E  FB8000     ZE W0, W0
001620  408000     ADD W1, W0, W0
001622  500FE2     SUB W0, #0x2, [W15]
001624  3E0005     BRA GTU, 0x1630
356:                                   tmp1[12] = 0;
001626  EB4000     CLR.B W0
001628  98CF40     MOV.B W0, [W14+76]
357:                                   tmp1[13] = 3;
00162A  B3C030     MOV.B #0x3, W0
00162C  98CF50     MOV.B W0, [W14+77]
00162E  37000D     BRA 0x164A
358:                               } else if ((((uint16_t) tmp1[12] << 8) + tmp1[13]) > 1440) {
001630  90C84E     MOV.B [W14+76], W0
001632  FB8000     ZE W0, W0
001634  DD00C8     SL W0, #8, W1
001636  90C85E     MOV.B [W14+77], W0
001638  FB8000     ZE W0, W0
00163A  408080     ADD W1, W0, W1
00163C  205A00     MOV #0x5A0, W0
00163E  508F80     SUB W1, W0, [W15]
001640  360004     BRA LEU, 0x164A
359:                                   tmp1[12] = 0x05;
001642  B3C050     MOV.B #0x5, W0
001644  98CF40     MOV.B W0, [W14+76]
360:                                   tmp1[13] = 0xA0;
001646  B3CA00     MOV.B #0xA0, W0
001648  98CF50     MOV.B W0, [W14+77]
361:                               }
362:                               if (((uint16_t) tmp1[14] << 8) + tmp1[15] < 2) {//阈值处理
00164A  90C86E     MOV.B [W14+78], W0
00164C  FB8000     ZE W0, W0
00164E  DD00C8     SL W0, #8, W1
001650  90C87E     MOV.B [W14+79], W0
001652  FB8000     ZE W0, W0
001654  408000     ADD W1, W0, W0
001656  500FE1     SUB W0, #0x1, [W15]
001658  3E0005     BRA GTU, 0x1664
363:                                   tmp1[15] = 0;
00165A  EB4000     CLR.B W0
00165C  98CF70     MOV.B W0, [W14+79]
364:                                   tmp1[15] = 2;
00165E  B3C020     MOV.B #0x2, W0
001660  98CF70     MOV.B W0, [W14+79]
001662  37000D     BRA 0x167E
365:                               } else if (((uint16_t) tmp1[14] << 8) + tmp1[15] > 17280) {
001664  90C86E     MOV.B [W14+78], W0
001666  FB8000     ZE W0, W0
001668  DD00C8     SL W0, #8, W1
00166A  90C87E     MOV.B [W14+79], W0
00166C  FB8000     ZE W0, W0
00166E  408080     ADD W1, W0, W1
001670  243800     MOV #0x4380, W0
001672  508F80     SUB W1, W0, [W15]
001674  360004     BRA LEU, 0x167E
366:                                   tmp1[14] = 0x43;
001676  B3C430     MOV.B #0x43, W0
001678  98CF60     MOV.B W0, [W14+78]
367:                                   tmp1[15] = 0x80;
00167A  B3C800     MOV.B #0x80, W0
00167C  98CF70     MOV.B W0, [W14+79]
368:                               }
369:                               CopyDat(tmp2 + 5, tmp1 + 6, tmp2[4]); //复制设置数据
00167E  90F16E     MOV.B [W14+118], W2
001680  200400     MOV #0x40, W0
001682  40000E     ADD W0, W14, W0
001684  4000E6     ADD W0, #0x6, W1
001686  200720     MOV #0x72, W0
001688  40000E     ADD W0, W14, W0
00168A  400065     ADD W0, #0x5, W0
00168C  070693     RCALL CopyDat
370:               
371:                               CRC16_Check(tmp2, tmp2[4] + 5); //计算CRC
00168E  90F06E     MOV.B [W14+118], W0
001690  4040E5     ADD.B W0, #0x5, W1
001692  200720     MOV #0x72, W0
001694  40000E     ADD W0, W14, W0
001696  070DF2     RCALL CRC16_Check
372:                               for (cnt = 0; cnt < tmp1[5]; cnt++)
001698  EB4000     CLR.B W0
00169A  784F00     MOV.B W0, [W14]
00169C  370007     BRA 0x16AC
0016AA  E84F1E     INC.B [W14], [W14]
0016AC  90C05E     MOV.B [W14+69], W0
0016AE  504F9E     SUB.B W0, [W14], [W15]
0016B0  3EFFF6     BRA GTU, 0x169E
373:                                   HandleArg(tmp1[3], tmp1[4] + cnt, tmp1);
00169E  90C04E     MOV.B [W14+68], W0
0016A0  40409E     ADD.B W0, [W14], W1
0016A2  90C03E     MOV.B [W14+67], W0
0016A4  200402     MOV #0x40, W2
0016A6  41010E     ADD W2, W14, W2
0016A8  07002D     RCALL _HandleArg
374:                               RTC_Refresh_Time();
0016B2  0707FC     RCALL RTC_Refresh_Time
375:                               WGCCON2bits.Period_FLAG = 1; //重新计算RTCC 导致输出下次定时的时间
0016B4  A8680B     BSET 0x80B, #3
376:                               IFS3bits.RTCIF = 1;
0016B6  A8C08B     BSET 0x8B, #6
377:                               RS485SendString(tmp2, tmp2[4] + 7); //发送数据 注意数据发送不要在中断里面
0016B8  90F06E     MOV.B [W14+118], W0
0016BA  FB8000     ZE W0, W0
0016BC  4000E7     ADD W0, #0x7, W1
0016BE  200720     MOV #0x72, W0
0016C0  40000E     ADD W0, W14, W0
0016C2  070D90     RCALL RS485SendString
378:                               break;
0016C4  37001A     BRA 0x16FA
379:                           }
380:                           case 0x03:
381:                           {
382:                               // * send: 57 47 43 03 00 05 9C 74
383:                               // * rec: 57 47 43 03 11 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 7A F2 
384:                               RefreshReg(); //刷新Arg参数RefreshReg
0016C6  070169     RCALL _RefreshReg
385:                               for (cnt = 0; cnt < tmp1[5]; cnt++)
0016C8  EB4000     CLR.B W0
0016CA  784F00     MOV.B W0, [W14]
0016CC  370007     BRA 0x16DC
0016DA  E84F1E     INC.B [W14], [W14]
0016DC  90C05E     MOV.B [W14+69], W0
0016DE  504F9E     SUB.B W0, [W14], [W15]
0016E0  3EFFF6     BRA GTU, 0x16CE
386:                                   HandleArg(tmp1[3], tmp1[4] + cnt, tmp2);
0016CE  90C04E     MOV.B [W14+68], W0
0016D0  40409E     ADD.B W0, [W14], W1
0016D2  90C03E     MOV.B [W14+67], W0
0016D4  200722     MOV #0x72, W2
0016D6  41010E     ADD W2, W14, W2
0016D8  070015     RCALL _HandleArg
387:                               CRC16_Check(tmp2, tmp2[4] + 5); //计算CRC
0016E2  90F06E     MOV.B [W14+118], W0
0016E4  4040E5     ADD.B W0, #0x5, W1
0016E6  200720     MOV #0x72, W0
0016E8  40000E     ADD W0, W14, W0
0016EA  070DC8     RCALL CRC16_Check
388:                               RS485SendString(tmp2, tmp2[4] + 7); //发送数据 注意数据发送不要在中断里面
0016EC  90F06E     MOV.B [W14+118], W0
0016EE  FB8000     ZE W0, W0
0016F0  4000E7     ADD W0, #0x7, W1
0016F2  200720     MOV #0x72, W0
0016F4  40000E     ADD W0, W14, W0
0016F6  070D76     RCALL RS485SendString
389:                               break;
0016F8  000000     NOP
390:                           }
391:                       }
392:                       return true;
0016FA  B3C010     MOV.B #0x1, W0
0016FC  370001     BRA 0x1700
393:                   }
394:                   return false;
0016FE  EB4000     CLR.B W0
395:               }
001700  FA8000     ULNK
001702  060000     RETURN
396:               
397:               static uint8_t HandleArg(uint8_t funcode, uint8_t regadd, uint8_t * arg) {
001704  FA0004     LNK #0x4
001706  784F00     MOV.B W0, [W14]
001708  984711     MOV.B W1, [W14+1]
00170A  980712     MOV W2, [W14+2]
398:                   //根据寄存器地址、数量、数据长度和数据,判断进行设置数据
399:                   //* send: 57 47 43 04 00 05 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 1A 6A
400:                   //* rec: 57 47 43 04 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH    
401:                   switch (funcode) {//根据功能码处理数据
00170C  FB801E     ZE [W14], W0
00170E  500FE3     SUB W0, #0x3, [W15]
001710  320080     BRA Z, 0x1812
001712  500FE4     SUB W0, #0x4, [W15]
001714  3A00F3     BRA NZ, 0x18FC
402:                       case 0x04://设置参数
403:                       {
404:                           switch (regadd) {//寄存器地址
001716  90401E     MOV.B [W14+1], W0
001718  FB8000     ZE W0, W0
00171A  500FE2     SUB W0, #0x2, [W15]
00171C  320057     BRA Z, 0x17CC
00171E  500FE2     SUB W0, #0x2, [W15]
001720  3C0005     BRA GT, 0x172C
001722  E00000     CP0 W0
001724  320008     BRA Z, 0x1736
001726  500FE1     SUB W0, #0x1, [W15]
001728  32001F     BRA Z, 0x1768
00172C  500FE3     SUB W0, #0x3, [W15]
00172E  320053     BRA Z, 0x17D6
001730  500FE4     SUB W0, #0x4, [W15]
001732  320062     BRA Z, 0x17F8
405:                               case 0://时间地址
406:                               {
407:                                   WGCTIME0bits.year = (*(arg + 6));
001736  90001E     MOV [W14+2], W0
001738  400066     ADD W0, #0x6, W0
00173A  784010     MOV.B [W0], W0
00173C  B7E800     MOV.B WREG, WGCTIME0bits
408:                                   WGCTIME0bits.month = (*(arg + 7));
00173E  90001E     MOV [W14+2], W0
001740  400067     ADD W0, #0x7, W0
001742  784010     MOV.B [W0], W0
001744  B7E801     MOV.B WREG, 0x801
409:                                   WGCTIME1bits.day = (*(arg + 8));
001746  90001E     MOV [W14+2], W0
001748  400068     ADD W0, #0x8, W0
00174A  784010     MOV.B [W0], W0
00174C  B7E802     MOV.B WREG, WGCTIME1bits
410:                                   WGCTIME1bits.hour = (*(arg + 9));
00174E  90001E     MOV [W14+2], W0
001750  400069     ADD W0, #0x9, W0
001752  784010     MOV.B [W0], W0
001754  B7E803     MOV.B WREG, 0x803
411:                                   WGCTIME2bits.min = (*(arg + 10));
001756  90001E     MOV [W14+2], W0
001758  40006A     ADD W0, #0xA, W0
00175A  784010     MOV.B [W0], W0
00175C  B7E804     MOV.B WREG, WGCTIME2bits
412:                                   WGCTIME2bits.sec = (*(arg + 11));
00175E  90001E     MOV [W14+2], W0
001760  40006B     ADD W0, #0xB, W0
001762  784010     MOV.B [W0], W0
001764  B7E805     MOV.B WREG, 0x805
413:                                   //                    bytes = 6;
414:                                   break;
001766  370054     BRA 0x1810
415:                               }
416:                               case 1://采集时间和发送时间
417:                               {
418:                                   WGCCON0bits.Send_60s = ((uint16_t)*(arg + 12) << 8)+*(arg + 13); //直接BCD码                    
001768  90001E     MOV [W14+2], W0
00176A  40006C     ADD W0, #0xC, W0
00176C  784010     MOV.B [W0], W0
00176E  FB8000     ZE W0, W0
001770  DD00C8     SL W0, #8, W1
001772  90001E     MOV [W14+2], W0
001774  40006D     ADD W0, #0xD, W0
001776  784010     MOV.B [W0], W0
001778  FB8000     ZE W0, W0
00177A  408080     ADD W1, W0, W1
00177C  207FF0     MOV #0x7FF, W0
00177E  608080     AND W1, W0, W1
001780  207FF0     MOV #0x7FF, W0
001782  608000     AND W1, W0, W0
001784  804032     MOV WGCCON0bits, W2
001786  2F8001     MOV #0xF800, W1
001788  610081     AND W2, W1, W1
00178A  700001     IOR W0, W1, W0
00178C  884030     MOV W0, WGCCON0bits
419:                                   DataIsVaild(WGCCON0bits.Send_60s, 3, 1440);
00178E  804031     MOV WGCCON0bits, W1
001790  207FF0     MOV #0x7FF, W0
001792  608000     AND W1, W0, W0
001794  205A02     MOV #0x5A0, W2
001796  200031     MOV #0x3, W1
001798  070547     RCALL DataIsVaild
420:                                   WGCCON1bits.Sample_5s = ((uint16_t)*(arg + 14))+*(arg + 15); //直接BCD码
00179A  90001E     MOV [W14+2], W0
00179C  40006E     ADD W0, #0xE, W0
00179E  784010     MOV.B [W0], W0
0017A0  FB8080     ZE W0, W1
0017A2  90001E     MOV [W14+2], W0
0017A4  40006F     ADD W0, #0xF, W0
0017A6  784010     MOV.B [W0], W0
0017A8  FB8000     ZE W0, W0
0017AA  408080     ADD W1, W0, W1
0017AC  27FFF0     MOV #0x7FFF, W0
0017AE  608080     AND W1, W0, W1
0017B0  27FFF0     MOV #0x7FFF, W0
0017B2  608000     AND W1, W0, W0
0017B4  804042     MOV WGCCON1bits, W2
0017B6  280001     MOV #0x8000, W1
0017B8  610081     AND W2, W1, W1
0017BA  700001     IOR W0, W1, W0
0017BC  884040     MOV W0, WGCCON1bits
421:                                   DataIsVaild(WGCCON1bits.Sample_5s, 2, 17280);
0017BE  804041     MOV WGCCON1bits, W1
0017C0  27FFF0     MOV #0x7FFF, W0
0017C2  608000     AND W1, W0, W0
0017C4  243802     MOV #0x4380, W2
0017C6  200021     MOV #0x2, W1
0017C8  07052F     RCALL DataIsVaild
422:                                   break;
0017CA  370022     BRA 0x1810
423:                               }
424:                               case 2://ID号
425:                               {
426:                                   WGCCON2bits.WGC_ID = *(arg + 16);
0017CC  90001E     MOV [W14+2], W0
0017CE  400070     ADD W0, #0x10, W0
0017D0  784010     MOV.B [W0], W0
0017D2  B7E80A     MOV.B WREG, WGCCON2bits
427:                                   //                    bytes = 1;
428:                                   break;
0017D4  37001D     BRA 0x1810
429:                               }
430:                               case 3://IP地址
431:                               {
432:                                   WGCIPbits.IP0 = *(arg + 17);
0017D6  90001E     MOV [W14+2], W0
0017D8  400071     ADD W0, #0x11, W0
0017DA  784010     MOV.B [W0], W0
0017DC  B7E814     MOV.B WREG, WGCIPbits
433:                                   WGCIPbits.IP1 = *(arg + 18);
0017DE  90001E     MOV [W14+2], W0
0017E0  400072     ADD W0, #0x12, W0
0017E2  784010     MOV.B [W0], W0
0017E4  B7E815     MOV.B WREG, 0x815
434:                                   WGCIPbits.IP2 = *(arg + 19);
0017E6  90001E     MOV [W14+2], W0
0017E8  400073     ADD W0, #0x13, W0
0017EA  784010     MOV.B [W0], W0
0017EC  B7E816     MOV.B WREG, 0x816
435:                                   WGCIPbits.IP3 = *(arg + 20);
0017EE  90001E     MOV [W14+2], W0
0017F0  400074     ADD W0, #0x14, W0
0017F2  784010     MOV.B [W0], W0
0017F4  B7E817     MOV.B WREG, 0x817
436:                                   //                    bytes = 4;
437:                                   break;
0017F6  37000C     BRA 0x1810
438:                               }
439:                               case 4://端口
440:                               {
441:                                   WGCPORT = (*(arg + 21) << 8)+*(arg + 22); //端口号 
0017F8  90001E     MOV [W14+2], W0
0017FA  400075     ADD W0, #0x15, W0
0017FC  784010     MOV.B [W0], W0
0017FE  FB8000     ZE W0, W0
001800  DD00C8     SL W0, #8, W1
001802  90001E     MOV [W14+2], W0
001804  400076     ADD W0, #0x16, W0
001806  784010     MOV.B [W0], W0
001808  FB8000     ZE W0, W0
00180A  408000     ADD W1, W0, W0
00180C  8840E0     MOV W0, WGCPORT
442:                                   //                    bytes = 2;
443:                                   break;
00180E  000000     NOP
444:                               }
445:                           }
446:                           break;
00172A  3700E8     BRA 0x18FC
001734  3700E3     BRA 0x18FC
001810  370075     BRA 0x18FC
447:                       }
448:                           // * send: 57 47 43 03 00 05 9C 74
449:                           // * rec: 57 47 43 03 11 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 7A F2 
450:                       case 0x03://读取参数
451:                       {
452:                           switch (regadd) {//寄存器地址
001812  90401E     MOV.B [W14+1], W0
001814  FB8000     ZE W0, W0
001816  500FE2     SUB W0, #0x2, [W15]
001818  32004A     BRA Z, 0x18AE
00181A  500FE2     SUB W0, #0x2, [W15]
00181C  3C0005     BRA GT, 0x1828
00181E  E00000     CP0 W0
001820  320008     BRA Z, 0x1832
001822  500FE1     SUB W0, #0x1, [W15]
001824  320025     BRA Z, 0x1870
001826  37006A     BRA 0x18FC
001828  500FE3     SUB W0, #0x3, [W15]
00182A  320047     BRA Z, 0x18BA
00182C  500FE4     SUB W0, #0x4, [W15]
00182E  32005A     BRA Z, 0x18E4
001830  370065     BRA 0x18FC
453:                               case 0:
454:                               {//时间地址
455:                                   arg[5] = WGCTIME0bits.year;
001832  90001E     MOV [W14+2], W0
001834  400065     ADD W0, #0x5, W0
001836  208001     MOV #0x800, W1
001838  784091     MOV.B [W1], W1
00183A  784801     MOV.B W1, [W0]
456:                                   arg[6] = WGCTIME0bits.month;
00183C  90001E     MOV [W14+2], W0
00183E  400066     ADD W0, #0x6, W0
001840  208011     MOV #0x801, W1
001842  784091     MOV.B [W1], W1
001844  784801     MOV.B W1, [W0]
457:                                   arg[7] = WGCTIME1bits.day;
001846  90001E     MOV [W14+2], W0
001848  400067     ADD W0, #0x7, W0
00184A  208021     MOV #0x802, W1
00184C  784091     MOV.B [W1], W1
00184E  784801     MOV.B W1, [W0]
458:                                   arg[8] = WGCTIME1bits.hour;
001850  90001E     MOV [W14+2], W0
001852  400068     ADD W0, #0x8, W0
001854  208031     MOV #0x803, W1
001856  784091     MOV.B [W1], W1
001858  784801     MOV.B W1, [W0]
459:                                   arg[9] = WGCTIME2bits.min;
00185A  90001E     MOV [W14+2], W0
00185C  400069     ADD W0, #0x9, W0
00185E  208041     MOV #0x804, W1
001860  784091     MOV.B [W1], W1
001862  784801     MOV.B W1, [W0]
460:                                   arg[10] = WGCTIME2bits.sec;
001864  90001E     MOV [W14+2], W0
001866  40006A     ADD W0, #0xA, W0
001868  208051     MOV #0x805, W1
00186A  784091     MOV.B [W1], W1
00186C  784801     MOV.B W1, [W0]
461:                                   break;
00186E  370046     BRA 0x18FC
462:                               }
463:                               case 1:
464:                               {//采集和发送时间
465:                                   arg[11] = WGCCON0bits.Send_60s >> 8;
001870  90001E     MOV [W14+2], W0
001872  40006B     ADD W0, #0xB, W0
001874  804032     MOV WGCCON0bits, W2
001876  207FF1     MOV #0x7FF, W1
001878  610081     AND W2, W1, W1
00187A  DE88C8     ASR W1, #8, W1
00187C  784081     MOV.B W1, W1
00187E  784801     MOV.B W1, [W0]
466:                                   arg[12] = (uint8_t) (WGCCON0bits.Send_60s & 0x00FF); //(WGCCON0bits.Sample_5s>>3);
001880  90001E     MOV [W14+2], W0
001882  40006C     ADD W0, #0xC, W0
001884  804032     MOV WGCCON0bits, W2
001886  207FF1     MOV #0x7FF, W1
001888  610081     AND W2, W1, W1
00188A  784081     MOV.B W1, W1
00188C  784801     MOV.B W1, [W0]
467:                                   arg[13] = WGCCON1bits.Sample_5s >> 8;
00188E  90001E     MOV [W14+2], W0
001890  40006D     ADD W0, #0xD, W0
001892  804042     MOV WGCCON1bits, W2
001894  27FFF1     MOV #0x7FFF, W1
001896  610081     AND W2, W1, W1
001898  DE88C8     ASR W1, #8, W1
00189A  784081     MOV.B W1, W1
00189C  784801     MOV.B W1, [W0]
468:                                   arg[14] = (uint8_t) (WGCCON1bits.Sample_5s & 0x00FF);
00189E  90001E     MOV [W14+2], W0
0018A0  40006E     ADD W0, #0xE, W0
0018A2  804042     MOV WGCCON1bits, W2
0018A4  27FFF1     MOV #0x7FFF, W1
0018A6  610081     AND W2, W1, W1
0018A8  784081     MOV.B W1, W1
0018AA  784801     MOV.B W1, [W0]
469:                                   break;
0018AC  370027     BRA 0x18FC
470:                               }
471:                               case 2:
472:                               {//ID号
473:                                   arg[15] = WGCCON2bits.WGC_ID;
0018AE  90001E     MOV [W14+2], W0
0018B0  40006F     ADD W0, #0xF, W0
0018B2  2080A1     MOV #0x80A, W1
0018B4  784091     MOV.B [W1], W1
0018B6  784801     MOV.B W1, [W0]
474:                                   break;
0018B8  370021     BRA 0x18FC
475:                               }
476:                               case 3:
477:                               {//IP地址
478:                                   arg[16] = WGCIPbits.IP3;
0018BA  90001E     MOV [W14+2], W0
0018BC  400070     ADD W0, #0x10, W0
0018BE  208171     MOV #0x817, W1
0018C0  784091     MOV.B [W1], W1
0018C2  784801     MOV.B W1, [W0]
479:                                   arg[17] = WGCIPbits.IP2;
0018C4  90001E     MOV [W14+2], W0
0018C6  400071     ADD W0, #0x11, W0
0018C8  208161     MOV #0x816, W1
0018CA  784091     MOV.B [W1], W1
0018CC  784801     MOV.B W1, [W0]
480:                                   arg[18] = WGCIPbits.IP1;
0018CE  90001E     MOV [W14+2], W0
0018D0  400072     ADD W0, #0x12, W0
0018D2  208151     MOV #0x815, W1
0018D4  784091     MOV.B [W1], W1
0018D6  784801     MOV.B W1, [W0]
481:                                   arg[19] = WGCIPbits.IP0;
0018D8  90001E     MOV [W14+2], W0
0018DA  400073     ADD W0, #0x13, W0
0018DC  208141     MOV #0x814, W1
0018DE  784091     MOV.B [W1], W1
0018E0  784801     MOV.B W1, [W0]
482:                                   break;
0018E2  37000C     BRA 0x18FC
483:                               }
484:                               case 4:
485:                               {//端口号
486:                                   arg[20] = WGCPORT >> 8;
0018E4  90001E     MOV [W14+2], W0
0018E6  400074     ADD W0, #0x14, W0
0018E8  8040E1     MOV WGCPORT, W1
0018EA  DE08C8     LSR W1, #8, W1
0018EC  784081     MOV.B W1, W1
0018EE  784801     MOV.B W1, [W0]
487:                                   arg[21] = WGCPORT & 0x00ff;
0018F0  90001E     MOV [W14+2], W0
0018F2  400075     ADD W0, #0x15, W0
0018F4  8040E1     MOV WGCPORT, W1
0018F6  784081     MOV.B W1, W1
0018F8  784801     MOV.B W1, [W0]
488:                                   break;
0018FA  000000     NOP
489:                               }
490:                           }
491:                       }
492:                   }
493:                   //    return bytes;
494:                   //根据寄存器地址、数量,判断进行读取数据
495:                   //* send: 57 47 43 03 00 05 CRCL CRCH
496:                   //* rec: 57 47 43 03 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
497:               }
0018FC  FA8000     ULNK
0018FE  060000     RETURN
498:               
499:               static uint8_t MKSendString(uint8_t * tmp) {//当组数据不小于20个字节
001900  FA0018     LNK #0x18
001902  980F30     MOV W0, [W14+22]
500:                   struct tm stm;
501:                   uint8_t bytes = 0; //添加帧头
001904  EB4000     CLR.B W0
001906  784F00     MOV.B W0, [W14]
502:                   uint16_t crc;
503:                   tmp[0] = 'A';
001908  90083E     MOV [W14+22], W0
00190A  B3C411     MOV.B #0x41, W1
00190C  784801     MOV.B W1, [W0]
504:                   tmp[1] = '2';
00190E  90083E     MOV [W14+22], W0
001910  E80000     INC W0, W0
001912  B3C321     MOV.B #0x32, W1
001914  784801     MOV.B W1, [W0]
505:                   tmp[2] = 20; //添加时间
001916  90083E     MOV [W14+22], W0
001918  E88000     INC2 W0, W0
00191A  B3C141     MOV.B #0x14, W1
00191C  784801     MOV.B W1, [W0]
506:                   while (!RTC_Read_Time(&stm));
00191E  000000     NOP
001920  470064     ADD W14, #0x4, W0
001922  070654     RCALL RTC_Read_Time
001924  E00000     CP0 W0
001926  32FFFC     BRA Z, 0x1920
507:                   tmp[3] = (stm.tm_year);
001928  90083E     MOV [W14+22], W0
00192A  400063     ADD W0, #0x3, W0
00192C  9000FE     MOV [W14+14], W1
00192E  784081     MOV.B W1, W1
001930  784801     MOV.B W1, [W0]
508:                   tmp[4] = (stm.tm_mon);
001932  90083E     MOV [W14+22], W0
001934  400064     ADD W0, #0x4, W0
001936  9000EE     MOV [W14+12], W1
001938  784081     MOV.B W1, W1
00193A  784801     MOV.B W1, [W0]
509:                   tmp[5] = (stm.tm_mday);
00193C  90083E     MOV [W14+22], W0
00193E  400065     ADD W0, #0x5, W0
001940  9000DE     MOV [W14+10], W1
001942  784081     MOV.B W1, W1
001944  784801     MOV.B W1, [W0]
510:                   tmp[6] = (stm.tm_hour);
001946  90083E     MOV [W14+22], W0
001948  400066     ADD W0, #0x6, W0
00194A  9000CE     MOV [W14+8], W1
00194C  784081     MOV.B W1, W1
00194E  784801     MOV.B W1, [W0]
511:                   tmp[7] = (stm.tm_min);
001950  90083E     MOV [W14+22], W0
001952  400067     ADD W0, #0x7, W0
001954  9000BE     MOV [W14+6], W1
001956  784081     MOV.B W1, W1
001958  784801     MOV.B W1, [W0]
512:                   tmp[8] = (stm.tm_sec);
00195A  90083E     MOV [W14+22], W0
00195C  400068     ADD W0, #0x8, W0
00195E  9000AE     MOV [W14+4], W1
001960  784081     MOV.B W1, W1
001962  784801     MOV.B W1, [W0]
513:                   bytes = 9;
001964  B3C090     MOV.B #0x9, W0
001966  784F00     MOV.B W0, [W14]
514:                   FloatToChar(&f_p, tmp + 9); //转化为压力值
001968  90083E     MOV [W14+22], W0
00196A  400069     ADD W0, #0x9, W0
00196C  780080     MOV W0, W1
00196E  2081E0     MOV #0x81E, W0
001970  0703EE     RCALL FloatToChar
515:                   crc = CRC16_Check(tmp, 13);
001972  B3C0D1     MOV.B #0xD, W1
001974  90083E     MOV [W14+22], W0
001976  070C82     RCALL CRC16_Check
001978  980710     MOV W0, [W14+2]
516:                   tmp[13] = crc >> 8;
00197A  90083E     MOV [W14+22], W0
00197C  40006D     ADD W0, #0xD, W0
00197E  90009E     MOV [W14+2], W1
001980  DE08C8     LSR W1, #8, W1
001982  784081     MOV.B W1, W1
001984  784801     MOV.B W1, [W0]
517:                   tmp[14] = crc - ((crc >> 8) << 8);
001986  90083E     MOV [W14+22], W0
001988  40006E     ADD W0, #0xE, W0
00198A  90009E     MOV [W14+2], W1
00198C  784081     MOV.B W1, W1
00198E  784801     MOV.B W1, [W0]
518:                   bytes = 15;
001990  B3C0F0     MOV.B #0xF, W0
001992  784F00     MOV.B W0, [W14]
519:                   //    strcat(tmp, tm); //添加压力
520:                   return bytes;
001994  78401E     MOV.B [W14], W0
521:               }
001996  FA8000     ULNK
001998  060000     RETURN
522:               
523:               static void RefreshReg(void) {
00199A  FA0012     LNK #0x12
524:                   struct tm tm_tmp;
525:                   while (!RTC_Read_Time(&tm_tmp));
00199C  000000     NOP
00199E  78000E     MOV W14, W0
0019A0  070615     RCALL RTC_Read_Time
0019A2  E00000     CP0 W0
0019A4  32FFFC     BRA Z, 0x199E
526:                   WGCTIME0bits.year = tm_tmp.tm_year;
0019A6  90005E     MOV [W14+10], W0
0019A8  784000     MOV.B W0, W0
0019AA  B7E800     MOV.B WREG, WGCTIME0bits
527:                   WGCTIME0bits.month = tm_tmp.tm_mon;
0019AC  90004E     MOV [W14+8], W0
0019AE  784000     MOV.B W0, W0
0019B0  B7E801     MOV.B WREG, 0x801
528:                   WGCTIME1bits.day = tm_tmp.tm_mday;
0019B2  90003E     MOV [W14+6], W0
0019B4  784000     MOV.B W0, W0
0019B6  B7E802     MOV.B WREG, WGCTIME1bits
529:                   WGCTIME1bits.hour = tm_tmp.tm_hour;
0019B8  90002E     MOV [W14+4], W0
0019BA  784000     MOV.B W0, W0
0019BC  B7E803     MOV.B WREG, 0x803
530:                   WGCTIME2bits.min = tm_tmp.tm_min;
0019BE  90001E     MOV [W14+2], W0
0019C0  784000     MOV.B W0, W0
0019C2  B7E804     MOV.B WREG, WGCTIME2bits
531:                   WGCTIME2bits.sec = tm_tmp.tm_sec;
0019C4  78001E     MOV [W14], W0
0019C6  784000     MOV.B W0, W0
0019C8  B7E805     MOV.B WREG, 0x805
532:               }
0019CA  FA8000     ULNK
533:               
534:               //static void LoadReg(void) {
535:               //    //    struct tm tm_tmp;
536:               //    //    while (!RTC_Read_Time(&tm_tmp));
537:               //    WGCTIME0bits.year; //= DCH(tm_tmp.tm_year);
538:               //    WGCTIME0bits.month; // = DCH(tm_tmp.tm_mon);
539:               //    WGCTIME1bits.day; //= DCH(tm_tmp.tm_mday);
540:               //    WGCTIME1bits.hour; // = DCH(tm_tmp.tm_hour);
541:               //    WGCTIME2bits.min; //= DCH(tm_tmp.tm_min);
542:               //    WGCTIME2bits.sec; //= DCH(tm_tmp.tm_sec);
543:               //}
544:               
545:               
546:               
547:               /*uint8_t [year,mon,day,hour,min,sec,Send_60s,Sample_5s.WGC_ID,IP0,IP1,IP2,IP3,PORT]
548:                *send：WGC+fun_code+reg+reg_num+CRC
549:                *rec：WGC+fuc_code+data_num+data[17]+CRC
550:                * fun_code 03:读取参数
551:                * fun_code 04:设置参数
552:                * /////////读取参数
553:                *send：WGC+03+reg+reg_num+CRC
554:                *rec：WGC+03+dat_num+dat[dat_num]+CRC
555:                * send: 57 47 43 03 00 05 CRCL CRCH
556:                * rec: 57 47 43 03 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
557:                * 
558:                * fun_code 03:读取参数
559:                * fun_code 04:设置参数
560:                * /////////读取参数
561:                *send：WGC+04+reg+reg_num+dat+CRC
562:                *rec：WGC+04+dat_num+dat+CRC
563:                * send: 57 47 43 04 00 05 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE 04 35
564:                * rec: 57 47 43 04 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
565:                * 
566:                * error handle:code 0x80
567:                * 
568:                */
569:               
570:               
571:               
572:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**********************************定义****************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 写数据到环形缓冲区
25:                Input: 串口号，1和2 
26:                Output: 无
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
00283E  FA0002     LNK #0x2
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {//如果缓冲区已满 写的速度比读的速度块
002840  BFC834     MOV.B bufferWptr_uart1, WREG
002842  FB8080     ZE W0, W1
002844  BFC835     MOV.B bufferRptr_uart1, WREG
002846  FB8000     ZE W0, W0
002848  E90000     DEC W0, W0
00284A  508F80     SUB W1, W0, [W15]
00284C  3A0003     BRA NZ, 0x2854
31:                        tmp = U1RXREG; //将溢出的数据，丢弃
00284E  801130     MOV U1RXREG, W0
002850  784F00     MOV.B W0, [W14]
32:                        return;
002852  37000C     BRA 0x286C
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
002854  BFC834     MOV.B bufferWptr_uart1, WREG
002856  FB8000     ZE W0, W0
002858  801131     MOV U1RXREG, W1
00285A  784101     MOV.B W1, W2
00285C  208481     MOV #0x848, W1
00285E  787082     MOV.B W2, [W1+W0]
35:                    bufferWptr_uart1++;
002860  BFC834     MOV.B bufferWptr_uart1, WREG
002862  E84000     INC.B W0, W0
002864  B7E834     MOV.B WREG, bufferWptr_uart1
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
002866  BFC834     MOV.B bufferWptr_uart1, WREG
002868  B243F0     AND.B #0x3F, W0
00286A  B7E834     MOV.B WREG, bufferWptr_uart1
37:                }
00286C  FA8000     ULNK
00286E  060000     RETURN
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 写数据到环形缓冲区
42:                Input: 串口号，1和2 
43:                Output: 无
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
002870  FA0002     LNK #0x2
46:                    uint8_t tmp = 0;
002872  EB4000     CLR.B W0
002874  784F00     MOV.B W0, [W14]
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {//如果缓冲区已满 写的速度比读的速度块
002876  BFC836     MOV.B bufferWptr_uart2, WREG
002878  FB8080     ZE W0, W1
00287A  BFC837     MOV.B bufferRptr_uart2, WREG
00287C  FB8000     ZE W0, W0
00287E  E90000     DEC W0, W0
002880  508F80     SUB W1, W0, [W15]
002882  3A0003     BRA NZ, 0x288A
48:                        tmp = U2RXREG; //将溢出的数据，丢弃
002884  8011B0     MOV U2RXREG, W0
002886  784F00     MOV.B W0, [W14]
49:                        return;
002888  37000C     BRA 0x28A2
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
00288A  BFC836     MOV.B bufferWptr_uart2, WREG
00288C  FB8000     ZE W0, W0
00288E  8011B1     MOV U2RXREG, W1
002890  784101     MOV.B W1, W2
002892  208881     MOV #0x888, W1
002894  787082     MOV.B W2, [W1+W0]
52:                    bufferWptr_uart2++;
002896  BFC836     MOV.B bufferWptr_uart2, WREG
002898  E84000     INC.B W0, W0
00289A  B7E836     MOV.B WREG, bufferWptr_uart2
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
00289C  BFC836     MOV.B bufferWptr_uart2, WREG
00289E  B243F0     AND.B #0x3F, W0
0028A0  B7E836     MOV.B WREG, bufferWptr_uart2
54:                }
0028A2  FA8000     ULNK
0028A4  060000     RETURN
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 写数据到环形缓冲区
59:                Input: 串口号，1和2 
60:                Output: 无
61:                 *************************************/
62:                void BufferWrite_UART3(void) {
0028A6  FA0002     LNK #0x2
63:                    uint8_t tmp = 0;
0028A8  EB4000     CLR.B W0
0028AA  784F00     MOV.B W0, [W14]
64:                    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {//如果缓冲区已满 写的速度比读的速度块
0028AC  BFC838     MOV.B bufferWptr_uart3, WREG
0028AE  FB8080     ZE W0, W1
0028B0  BFC839     MOV.B bufferRptr_uart3, WREG
0028B2  FB8000     ZE W0, W0
0028B4  E90000     DEC W0, W0
0028B6  508F80     SUB W1, W0, [W15]
0028B8  3A0003     BRA NZ, 0x28C0
65:                        tmp = U3RXREG; //将溢出的数据，丢弃
0028BA  8012B0     MOV U3RXREG, W0
0028BC  784F00     MOV.B W0, [W14]
66:                        return;
0028BE  37000C     BRA 0x28D8
67:                    }
68:                    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
0028C0  BFC838     MOV.B bufferWptr_uart3, WREG
0028C2  FB8000     ZE W0, W0
0028C4  8012B1     MOV U3RXREG, W1
0028C6  784101     MOV.B W1, W2
0028C8  208C81     MOV #0x8C8, W1
0028CA  787082     MOV.B W2, [W1+W0]
69:                    bufferWptr_uart3++;
0028CC  BFC838     MOV.B bufferWptr_uart3, WREG
0028CE  E84000     INC.B W0, W0
0028D0  B7E838     MOV.B WREG, bufferWptr_uart3
70:                    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
0028D2  BFC838     MOV.B bufferWptr_uart3, WREG
0028D4  B243F0     AND.B #0x3F, W0
0028D6  B7E838     MOV.B WREG, bufferWptr_uart3
71:                }
0028D8  FA8000     ULNK
0028DA  060000     RETURN
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 读环形缓冲区
76:                Input: 数据地址 
77:                Output: 1：读取成功，0：读取失败
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
0028DC  FA0002     LNK #0x2
0028DE  780F00     MOV W0, [W14]
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
0028E0  208351     MOV #0x835, W1
0028E2  784091     MOV.B [W1], W1
0028E4  BFC834     MOV.B bufferWptr_uart1, WREG
0028E6  50CF80     SUB.B W1, W0, [W15]
0028E8  3A0002     BRA NZ, 0x28EE
81:                        return 0;
0028EA  EB4000     CLR.B W0
0028EC  37000D     BRA 0x2908
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
0028EE  BFC835     MOV.B bufferRptr_uart1, WREG
0028F0  FB8000     ZE W0, W0
0028F2  208481     MOV #0x848, W1
0028F4  7840E1     MOV.B [W1+W0], W1
0028F6  78001E     MOV [W14], W0
0028F8  784801     MOV.B W1, [W0]
84:                    bufferRptr_uart1++;
0028FA  BFC835     MOV.B bufferRptr_uart1, WREG
0028FC  E84000     INC.B W0, W0
0028FE  B7E835     MOV.B WREG, bufferRptr_uart1
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
002900  BFC835     MOV.B bufferRptr_uart1, WREG
002902  B243F0     AND.B #0x3F, W0
002904  B7E835     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
002906  B3C010     MOV.B #0x1, W0
87:                }
002908  FA8000     ULNK
00290A  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 读环形缓冲区
92:                Input: 数据地址 
93:                Output: 1：读取成功，0：读取失败
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
00290C  FA0002     LNK #0x2
00290E  780F00     MOV W0, [W14]
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
002910  208371     MOV #0x837, W1
002912  784091     MOV.B [W1], W1
002914  BFC836     MOV.B bufferWptr_uart2, WREG
002916  50CF80     SUB.B W1, W0, [W15]
002918  3A0007     BRA NZ, 0x2928
97:                        if (U2STAbits.OERR)
00291A  801190     MOV U2STA, W0
00291C  600062     AND W0, #0x2, W0
00291E  E00000     CP0 W0
002920  320001     BRA Z, 0x2924
98:                            U2STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
002922  A92232     BCLR U2STA, #1
99:                        return 0;
002924  EB4000     CLR.B W0
002926  37000D     BRA 0x2942
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
002928  BFC837     MOV.B bufferRptr_uart2, WREG
00292A  FB8000     ZE W0, W0
00292C  208881     MOV #0x888, W1
00292E  7840E1     MOV.B [W1+W0], W1
002930  78001E     MOV [W14], W0
002932  784801     MOV.B W1, [W0]
102:                   bufferRptr_uart2++;
002934  BFC837     MOV.B bufferRptr_uart2, WREG
002936  E84000     INC.B W0, W0
002938  B7E837     MOV.B WREG, bufferRptr_uart2
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
00293A  BFC837     MOV.B bufferRptr_uart2, WREG
00293C  B243F0     AND.B #0x3F, W0
00293E  B7E837     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
002940  B3C010     MOV.B #0x1, W0
106:               }
002942  FA8000     ULNK
002944  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 读环形缓冲区
111:               Input: 数据地址 
112:               Output: 1：读取成功，0：读取失败
113:                *************************************/
114:               bool BufferRead_UART3(uint8_t *data) {
002946  FA0002     LNK #0x2
002948  780F00     MOV W0, [W14]
115:                   if (bufferRptr_uart3 == bufferWptr_uart3) {
00294A  208391     MOV #0x839, W1
00294C  784091     MOV.B [W1], W1
00294E  BFC838     MOV.B bufferWptr_uart3, WREG
002950  50CF80     SUB.B W1, W0, [W15]
002952  3A0007     BRA NZ, 0x2962
116:                       if (U3STAbits.OERR)
002954  801290     MOV U3STA, W0
002956  600062     AND W0, #0x2, W0
002958  E00000     CP0 W0
00295A  320001     BRA Z, 0x295E
117:                           U3STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
00295C  A92252     BCLR U3STA, #1
118:                       return 0;
00295E  EB4000     CLR.B W0
002960  37000D     BRA 0x297C
119:                   }
120:                   *data = Buffer_uart3[bufferRptr_uart3];
002962  BFC839     MOV.B bufferRptr_uart3, WREG
002964  FB8000     ZE W0, W0
002966  208C81     MOV #0x8C8, W1
002968  7840E1     MOV.B [W1+W0], W1
00296A  78001E     MOV [W14], W0
00296C  784801     MOV.B W1, [W0]
121:                   bufferRptr_uart3++;
00296E  BFC839     MOV.B bufferRptr_uart3, WREG
002970  E84000     INC.B W0, W0
002972  B7E839     MOV.B WREG, bufferRptr_uart3
122:                   bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
002974  BFC839     MOV.B bufferRptr_uart3, WREG
002976  B243F0     AND.B #0x3F, W0
002978  B7E839     MOV.B WREG, bufferRptr_uart3
123:                   //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:                   return 1;
00297A  B3C010     MOV.B #0x1, W0
125:               }
00297C  FA8000     ULNK
00297E  060000     RETURN
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 根据结构体的内容获取有效数据和有效长度
130:               Input: 数据结构体
131:               Output: 是否获取到数据
132:               Notice：字节数不能大于256 取数据的时间可能短   
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//注意
002980  FA0008     LNK #0x8
002982  980730     MOV W0, [W14+6]
135:                   bool IsFind = false; //记录字节数
002984  EB4000     CLR.B W0
002986  784F00     MOV.B W0, [W14]
136:                   uint8_t cnt = 0/*校验寻找循环地址*/, cnt1 = 0/*校验判断循环地址*/, cnt2/*赋值地址*/, /*offset,*/ byte = 0;
002988  EB4000     CLR.B W0
00298A  984710     MOV.B W0, [W14+1]
00298C  EB4000     CLR.B W0
00298E  984720     MOV.B W0, [W14+2]
002990  EB4000     CLR.B W0
002992  984740     MOV.B W0, [W14+4]
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//如果设置的字节数为0的话，返回错误
002994  90003E     MOV [W14+6], W0
002996  904060     MOV.B [W0+6], W0
002998  E00400     CP0.B W0
00299A  320004     BRA Z, 0x29A4
00299C  90003E     MOV [W14+6], W0
00299E  904020     MOV.B [W0+2], W0
0029A0  E00400     CP0.B W0
0029A2  3A0036     BRA NZ, 0x2A10
139:                       return false; //为获取
0029A4  EB4000     CLR.B W0
0029A6  3700AD     BRA 0x2B02
140:               
141:                   while (cnt < strcmp->Source_len) {
002A10  000000     NOP
002A12  90003E     MOV [W14+6], W0
002A14  9040A0     MOV.B [W0+2], W1
002A16  90401E     MOV.B [W14+1], W0
002A18  50CF80     SUB.B W1, W0, [W15]
002A1A  3EFFC6     BRA GTU, 0x29A8
002A1C  370001     BRA 0x2A20
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//如果数据==head的话           
0029A8  90003E     MOV [W14+6], W0
0029AA  780090     MOV [W0], W1
0029AC  90401E     MOV.B [W14+1], W0
0029AE  FB8000     ZE W0, W0
0029B0  408000     ADD W1, W0, W0
0029B2  784090     MOV.B [W0], W1
0029B4  90003E     MOV [W14+6], W0
0029B6  900020     MOV [W0+4], W0
0029B8  784010     MOV.B [W0], W0
0029BA  50CF80     SUB.B W1, W0, [W15]
0029BC  3A0022     BRA NZ, 0x2A02
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//获取帧头的数据长度               
0029BE  B3C010     MOV.B #0x1, W0
0029C0  984720     MOV.B W0, [W14+2]
0029C2  37001A     BRA 0x29F8
0029EA  90402E     MOV.B [W14+2], W0
0029EC  E84000     INC.B W0, W0
0029EE  984720     MOV.B W0, [W14+2]
0029F0  370003     BRA 0x29F8
0029F8  90003E     MOV [W14+6], W0
0029FA  9040E0     MOV.B [W0+6], W1
0029FC  90402E     MOV.B [W14+2], W0
0029FE  50CF80     SUB.B W1, W0, [W15]
002A00  3EFFE1     BRA GTU, 0x29C4
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//如果获取到数据和帧头一样，那么继续获取数据，反之退出
0029C4  90003E     MOV [W14+6], W0
0029C6  780090     MOV [W0], W1
0029C8  90401E     MOV.B [W14+1], W0
0029CA  FB8100     ZE W0, W2
0029CC  90402E     MOV.B [W14+2], W0
0029CE  FB8000     ZE W0, W0
0029D0  410000     ADD W2, W0, W0
0029D2  408000     ADD W1, W0, W0
0029D4  784090     MOV.B [W0], W1
0029D6  90003E     MOV [W14+6], W0
0029D8  900120     MOV [W0+4], W2
0029DA  90402E     MOV.B [W14+2], W0
0029DC  FB8000     ZE W0, W0
0029DE  410000     ADD W2, W0, W0
0029E0  784010     MOV.B [W0], W0
0029E2  50CF80     SUB.B W1, W0, [W15]
0029E4  3A0006     BRA NZ, 0x29F2
145:                                   IsFind = true;
0029E6  B3C010     MOV.B #0x1, W0
0029E8  784F00     MOV.B W0, [W14]
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
0029F2  EB4000     CLR.B W0
0029F4  784F00     MOV.B W0, [W14]
149:                                   break;
0029F6  370005     BRA 0x2A02
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //如果找到数据，退出寻找帧头程序
002A02  78401E     MOV.B [W14], W0
002A04  E00400     CP0.B W0
002A06  3A000B     BRA NZ, 0x2A1E
002A1E  000000     NOP
154:                       cnt++; //校验位置加1
002A08  90401E     MOV.B [W14+1], W0
002A0A  E84000     INC.B W0, W0
002A0C  984710     MOV.B W0, [W14+1]
002A0E  370001     BRA 0x2A12
155:                   }
156:               
157:                   if (IsFind) {//如果存在接受的字节数且找到帧头
002A20  78401E     MOV.B [W14], W0
002A22  E00400     CP0.B W0
002A24  32006A     BRA Z, 0x2AFA
158:                       if (strcmp->Get_len < strcmp->Check_len) {
002A26  90003E     MOV [W14+6], W0
002A28  9048A0     MOV.B [W0+10], W1
002A2A  90003E     MOV [W14+6], W0
002A2C  904060     MOV.B [W0+6], W0
002A2E  50CF80     SUB.B W1, W0, [W15]
002A30  31001A     BRA C, 0x2A66
159:                           byte = strcmp->Get_len; //获取字节小于校验字节,比如只需要校验不需要获取数据
002A32  90003E     MOV [W14+6], W0
002A34  9048A0     MOV.B [W0+10], W1
002A36  984741     MOV.B W1, [W14+4]
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //获取帧头数据
002A38  EB4000     CLR.B W0
002A3A  984730     MOV.B W0, [W14+3]
002A3C  37000F     BRA 0x2A5C
002A56  90403E     MOV.B [W14+3], W0
002A58  E84000     INC.B W0, W0
002A5A  984730     MOV.B W0, [W14+3]
002A5C  9040BE     MOV.B [W14+3], W1
002A5E  90404E     MOV.B [W14+4], W0
002A60  50CF80     SUB.B W1, W0, [W15]
002A62  39FFED     BRA NC, 0x2A3E
002A64  370045     BRA 0x2AF0
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
002A3E  90003E     MOV [W14+6], W0
002A40  9000C0     MOV [W0+8], W1
002A42  90403E     MOV.B [W14+3], W0
002A44  FB8000     ZE W0, W0
002A46  408000     ADD W1, W0, W0
002A48  9000BE     MOV [W14+6], W1
002A4A  900121     MOV [W1+4], W2
002A4C  9040BE     MOV.B [W14+3], W1
002A4E  FB8081     ZE W1, W1
002A50  410081     ADD W2, W1, W1
002A52  784091     MOV.B [W1], W1
002A54  784801     MOV.B W1, [W0]
162:                       } else {//如果要获取的字节数大于帧头数据，需要判断有效的剩余字节数数量
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//如果获取数据大于有效数据，
002A66  90003E     MOV [W14+6], W0
002A68  904020     MOV.B [W0+2], W0
002A6A  FB8080     ZE W0, W1
002A6C  90401E     MOV.B [W14+1], W0
002A6E  FB8000     ZE W0, W0
002A70  508080     SUB W1, W0, W1
002A72  90003E     MOV [W14+6], W0
002A74  904820     MOV.B [W0+10], W0
002A76  FB8000     ZE W0, W0
002A78  508F80     SUB W1, W0, [W15]
002A7A  3D0020     BRA GE, 0x2ABC
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //获取剩余数据
002A7C  EB4000     CLR.B W0
002A7E  984730     MOV.B W0, [W14+3]
002A80  370012     BRA 0x2AA6
002AA0  90403E     MOV.B [W14+3], W0
002AA2  E84000     INC.B W0, W0
002AA4  984730     MOV.B W0, [W14+3]
002AA6  90403E     MOV.B [W14+3], W0
002AA8  FB8080     ZE W0, W1
002AAA  90003E     MOV [W14+6], W0
002AAC  904020     MOV.B [W0+2], W0
002AAE  FB8100     ZE W0, W2
002AB0  90401E     MOV.B [W14+1], W0
002AB2  FB8000     ZE W0, W0
002AB4  510000     SUB W2, W0, W0
002AB6  508F80     SUB W1, W0, [W15]
002AB8  35FFE4     BRA LT, 0x2A82
002ABA  37001A     BRA 0x2AF0
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
002A82  90003E     MOV [W14+6], W0
002A84  9000C0     MOV [W0+8], W1
002A86  90403E     MOV.B [W14+3], W0
002A88  FB8000     ZE W0, W0
002A8A  408000     ADD W1, W0, W0
002A8C  9000BE     MOV [W14+6], W1
002A8E  780111     MOV [W1], W2
002A90  90409E     MOV.B [W14+1], W1
002A92  FB8181     ZE W1, W3
002A94  9040BE     MOV.B [W14+3], W1
002A96  FB8081     ZE W1, W1
002A98  418081     ADD W3, W1, W1
002A9A  410081     ADD W2, W1, W1
002A9C  784091     MOV.B [W1], W1
002A9E  784801     MOV.B W1, [W0]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //获取剩余数据
002ABC  EB4000     CLR.B W0
002ABE  984730     MOV.B W0, [W14+3]
002AC0  370012     BRA 0x2AE6
002AE0  90403E     MOV.B [W14+3], W0
002AE2  E84000     INC.B W0, W0
002AE4  984730     MOV.B W0, [W14+3]
002AE6  90003E     MOV [W14+6], W0
002AE8  9048A0     MOV.B [W0+10], W1
002AEA  90403E     MOV.B [W14+3], W0
002AEC  50CF80     SUB.B W1, W0, [W15]
002AEE  31FFE9     BRA C, 0x2AC2
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
002AC2  90003E     MOV [W14+6], W0
002AC4  9000C0     MOV [W0+8], W1
002AC6  90403E     MOV.B [W14+3], W0
002AC8  FB8000     ZE W0, W0
002ACA  408000     ADD W1, W0, W0
002ACC  9000BE     MOV [W14+6], W1
002ACE  780111     MOV [W1], W2
002AD0  90409E     MOV.B [W14+1], W1
002AD2  FB8181     ZE W1, W3
002AD4  9040BE     MOV.B [W14+3], W1
002AD6  FB8081     ZE W1, W1
002AD8  418081     ADD W3, W1, W1
002ADA  410081     ADD W2, W1, W1
002ADC  784091     MOV.B [W1], W1
002ADE  784801     MOV.B W1, [W0]
169:                       }
170:                       strcmp->Real_len = cnt2; //实际获取到的长度
002AF0  90003E     MOV [W14+6], W0
002AF2  9040BE     MOV.B [W14+3], W1
002AF4  984831     MOV.B W1, [W0+11]
171:                       return true;
002AF6  B3C010     MOV.B #0x1, W0
002AF8  370004     BRA 0x2B02
172:                   }
173:                   strcmp->Real_len = 0;
002AFA  90003E     MOV [W14+6], W0
002AFC  EB4080     CLR.B W1
002AFE  984831     MOV.B W1, [W0+11]
174:                   return false;
002B00  EB4000     CLR.B W0
175:               }
002B02  FA8000     ULNK
002B04  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 通过指定串口获取函数，获取数据保存至数据地址
180:               Input: UARTn获取函数，获取数据的地址
181:               Output: 字节数
182:               Notice：字节数不能大于256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data, uint8_t bytes) {//, const uint8_t get_size) {//注意'\0'
002B06  FA0008     LNK #0x8
002B08  980710     MOV W0, [W14+2]
002B0A  980721     MOV W1, [W14+4]
002B0C  984762     MOV.B W2, [W14+6]
185:                   uint8_t byte = 0;
002B0E  EB4000     CLR.B W0
002B10  784F00     MOV.B W0, [W14]
186:                   while (bytes > byte) {
002B12  370008     BRA 0x2B24
002B24  90406E     MOV.B [W14+6], W0
002B26  504F9E     SUB.B W0, [W14], [W15]
002B28  3EFFF5     BRA GTU, 0x2B14
002B2A  370001     BRA 0x2B2E
187:                       if (f_uart(Get_Data + byte))
002B14  FB801E     ZE [W14], W0
002B16  9000AE     MOV [W14+4], W1
002B18  408000     ADD W1, W0, W0
002B1A  90009E     MOV [W14+2], W1
002B1C  010001     CALL W1
002B1E  E00400     CP0.B W0
002B20  320005     BRA Z, 0x2B2C
188:                           byte++;
002B22  E84F1E     INC.B [W14], [W14]
189:                       else
190:                           break;
002B2C  000000     NOP
191:                   }
192:                   return byte;
002B2E  78401E     MOV.B [W14], W0
193:               }
002B30  FA8000     ULNK
002B32  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 清楚缓冲区数据
198:               Input: 指定清楚的串口
199:               Output: 无
200:               Notice：清楚串口缓冲区
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
002B34  FA0004     LNK #0x4
002B36  980710     MOV W0, [W14+2]
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
002B38  000000     NOP
002B3A  90009E     MOV [W14+2], W1
002B3C  78000E     MOV W14, W0
002B3E  010001     CALL W1
002B40  E00400     CP0.B W0
002B42  3AFFFB     BRA NZ, 0x2B3A
205:               }
002B44  FA8000     ULNK
206:               //将UARTGetData和
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //临时变量
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/HL6528.c  -----------------------------------
1:                 #include "HL6528.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 #include <stdlib.h>
5:                 #include  <libq.h>
6:                 #include "WGC.h"
7:                 #include "Common.h"
8:                 //#include "includes.h"
9:                 //#include <stdbool.h>
10:                //#include "cJSON.h"
11:                
12:                
13:                //extern OS_EVENT* sem1, *sem2; //上线拨号任务标志
14:                
15:                //struct ATCommand {
16:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
17:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
18:                const uint8_t AT[] = {"AT\r\n"};
19:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
20:                const uint8_t OK[] = {"OK"};
21:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
22:                const uint8_t READY[] = {"+CPIN: READY"};
23:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
24:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
25:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
26:                const uint8_t _5[] = {",5"};
27:                const uint8_t _1[] = {",1"};
28:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
29:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
30:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
31:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
32:                uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.140.140\",11811\r\n\n"};
33:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
34:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//移动ONENET
35:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
36:                const uint8_t CONNECT[] = {"CONNECT"};
37:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
38:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
39:                
40:                
41:                //static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
42:                
43:                void HL6528_Init(void) {
002B48  FA0000     LNK #0x0
44:                    //初始化端口
45:                    PWRON_TRIS = 0; //PWN_ON 6528芯片电源控制
002B4A  A9C2D8     BCLR TRISD, #6
46:                    PWR_TRIS = 0; //外部控制6528芯片电源
002B4C  A9E2D8     BCLR TRISD, #7
47:                    DSR_TRIS = 0; //数据设备请求    
002B4E  A922E8     BCLR TRISF, #1
48:                    DTR_TRIS = 0; //数据终端请求
002B50  A922D8     BCLR TRISD, #1
49:                    RTS_TRIS = 0; //请求发送数据
002B52  A982D8     BCLR TRISD, #4
50:                    CTS_TRIS = 0; //请求接受数据  
002B54  A9A2D8     BCLR TRISD, #5
51:                    PWR = 0;
002B56  A9E2DC     BCLR LATD, #7
52:                    PWRON = 0;
002B58  A9C2DC     BCLR LATD, #6
53:                    CTS = 0;
002B5A  A9A2DC     BCLR LATD, #5
54:                    RTS = 0;
002B5C  A982DC     BCLR LATD, #4
55:                    DSR = 0;
002B5E  A922EC     BCLR LATF, #1
56:                    DTR = 0;
002B60  A922DC     BCLR LATD, #1
57:                    //    UART2_Init();
58:                }
002B62  FA8000     ULNK
002B64  060000     RETURN
59:                
60:                /*输入变量：发送字符串地址ss、接受字符串、接受字符串长度、发送字符串长度、对比字符串地址、对比字符串长度、发送间隔时间、发送次数**/
61:                static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
002B66  FA0048     LNK #0x48
002B68  982700     MOV W0, [W14+64]
002B6A  982711     MOV W1, [W14+66]
002B6C  982722     MOV W2, [W14+68]
002B6E  98C763     MOV.B W3, [W14+70]
002B70  98C774     MOV.B W4, [W14+71]
62:                    uint8_t cnt_tmp = 0;
002B72  EB4000     CLR.B W0
002B74  784F00     MOV.B W0, [W14]
63:                    bool b_sta = false;
002B76  EB4000     CLR.B W0
002B78  984710     MOV.B W0, [W14+1]
64:                    StrCmp stcp;
65:                    uint8_t tmp[50];
66:                    do {
67:                        cnt_tmp += 1;
002B7A  E84F1E     INC.B [W14], [W14]
68:                        UART2_SendString(ss); //发送AT指令                               
002B7C  90200E     MOV [W14+64], W0
002B7E  07049B     RCALL UART2_SendString
69:                        Delay1s(3); //(0, 0, 3, 0); //延时1s
002B80  B3C030     MOV.B #0x3, W0
002B82  07FBFB     RCALL Delay1s
70:                        U2Rx4Byte();
002B84  0704CE     RCALL U2Rx4Byte
71:                        stcp.SourceData = tmp;
002B86  47006E     ADD W14, #0xE, W0
002B88  980710     MOV W0, [W14+2]
72:                        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 50); //获取mark
002B8A  90001E     MOV [W14+2], W0
002B8C  B3C322     MOV.B #0x32, W2
002B8E  780080     MOV W0, W1
002B90  2290C0     MOV #0x290C, W0
002B92  07FFB9     RCALL UARTGetData
002B94  984740     MOV.B W0, [W14+4]
73:                        stcp.CheckData = (uint8_t*) cs;
002B96  90209E     MOV [W14+66], W1
002B98  980731     MOV W1, [W14+6]
74:                        stcp.Check_len = csl;
002B9A  90C0EE     MOV.B [W14+70], W1
002B9C  984F01     MOV.B W1, [W14+8]
75:                        stcp.GetData = NULL;
002B9E  EB0000     CLR W0
002BA0  980750     MOV W0, [W14+10]
76:                        stcp.Get_len = 0;
002BA2  EB4000     CLR.B W0
002BA4  984F40     MOV.B W0, [W14+12]
77:                        stcp.Real_len = 0;
002BA6  EB4000     CLR.B W0
002BA8  984F50     MOV.B W0, [W14+13]
78:                
79:                        if (UARTDataIsRight(&stcp)) {
002BAA  E8800E     INC2 W14, W0
002BAC  07FEE9     RCALL UARTDataIsRight
002BAE  E00400     CP0.B W0
002BB0  320003     BRA Z, 0x2BB8
80:                            b_sta = true;
002BB2  B3C010     MOV.B #0x1, W0
002BB4  984710     MOV.B W0, [W14+1]
81:                            break;
002BB6  37000F     BRA 0x2BD6
82:                        }
83:                
84:                        if (cs1 != NULL) {//如果第二个校验数据不是NULL，那么进行第二个数据头的处理，判断处理。
002BB8  90202E     MOV [W14+68], W0
002BBA  E00000     CP0 W0
002BBC  320009     BRA Z, 0x2BD0
85:                            stcp.CheckData = (uint8_t*) cs1;
002BBE  9020AE     MOV [W14+68], W1
002BC0  980731     MOV W1, [W14+6]
86:                            if (UARTDataIsRight(&stcp)) {
002BC2  E8800E     INC2 W14, W0
002BC4  07FEDD     RCALL UARTDataIsRight
002BC6  E00400     CP0.B W0
002BC8  320003     BRA Z, 0x2BD0
87:                                b_sta = true;
002BCA  B3C010     MOV.B #0x1, W0
002BCC  984710     MOV.B W0, [W14+1]
88:                                break;
002BCE  370003     BRA 0x2BD6
89:                            }
90:                        }
91:                
92:                    } while (cnt > cnt_tmp);
002BD0  90C07E     MOV.B [W14+71], W0
002BD2  504F9E     SUB.B W0, [W14], [W15]
002BD4  3EFFD2     BRA GTU, 0x2B7A
93:                    ClearBuffer(BufferRead_UART2);
002BD6  2290C0     MOV #0x290C, W0
002BD8  07FFAD     RCALL ClearBuffer
94:                    return b_sta;
002BDA  90401E     MOV.B [W14+1], W0
95:                }
002BDC  FA8000     ULNK
002BDE  060000     RETURN
96:                
97:                uint8_t HL6528_DialingIsERR(void) {
002BE0  FA0002     LNK #0x2
98:                    uint8_t sta;
99:                    //    uint8_t ip_port[25] = {'\0'};
100:               
101:                   //    HL6528_GetIP_Port();
102:                   PWR = 1;
002BE2  A8E2DC     BSET LATD, #7
103:                   PWRON = 1;
002BE4  A8C2DC     BSET LATD, #6
104:                   CTS = 0;
002BE6  A9A2DC     BCLR LATD, #5
105:                   RTS = 0;
002BE8  A982DC     BCLR LATD, #4
106:                   DSR = 0;
002BEA  A922EC     BCLR LATF, #1
107:                   DTR = 0;
002BEC  A922DC     BCLR LATD, #1
108:                   Delay1s(2);
002BEE  B3C020     MOV.B #0x2, W0
002BF0  07FBC4     RCALL Delay1s
109:                   if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
002BF2  B3C024     MOV.B #0x2, W4
002BF4  B3C023     MOV.B #0x2, W3
002BF6  EB0100     CLR W2
002BF8  28F9B1     MOV #0x8F9B, W1
002BFA  28F820     MOV #0x8F82, W0
002BFC  07FFB4     RCALL _HL6528SendCmd
002BFE  E00400     CP0.B W0
002C00  32003A     BRA Z, 0x2C76
110:                       if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
002C02  B3C024     MOV.B #0x2, W4
002C04  B3C083     MOV.B #0x8, W3
002C06  EB0100     CLR W2
002C08  28FA91     MOV #0x8FA9, W1
002C0A  28F9E0     MOV #0x8F9E, W0
002C0C  07FFAC     RCALL _HL6528SendCmd
002C0E  E00400     CP0.B W0
002C10  32002F     BRA Z, 0x2C70
111:                           if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//设置网络模式
002C12  B3C0A4     MOV.B #0xA, W4
002C14  B3C023     MOV.B #0x2, W3
002C16  28FDA2     MOV #0x8FDA, W2
002C18  28FD71     MOV #0x8FD7, W1
002C1A  28FC00     MOV #0x8FC0, W0
002C1C  07FFA4     RCALL _HL6528SendCmd
002C1E  E00400     CP0.B W0
002C20  320024     BRA Z, 0x2C6A
112:                               if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
002C22  B3C034     MOV.B #0x3, W4
002C24  B3C023     MOV.B #0x2, W3
002C26  EB0100     CLR W2
002C28  28F9B1     MOV #0x8F9B, W1
002C2A  28FE70     MOV #0x8FE7, W0
002C2C  07FF9C     RCALL _HL6528SendCmd
002C2E  E00400     CP0.B W0
002C30  320019     BRA Z, 0x2C64
113:                                   //HL6528_GetIP_Port(); //刷新IP地址和端口号
114:                                   if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
002C32  B3C034     MOV.B #0x3, W4
002C34  B3C023     MOV.B #0x2, W3
002C36  EB0100     CLR W2
002C38  28F9B1     MOV #0x8F9B, W1
002C3A  209080     MOV #0x908, W0
002C3C  07FF94     RCALL _HL6528SendCmd
002C3E  E00400     CP0.B W0
002C40  32000E     BRA Z, 0x2C5E
115:                                       if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 5, 5)) {
002C42  B3C054     MOV.B #0x5, W4
002C44  B3C053     MOV.B #0x5, W3
002C46  EB0100     CLR W2
002C48  290431     MOV #0x9043, W1
002C4A  290320     MOV #0x9032, W0
002C4C  07FF8C     RCALL _HL6528SendCmd
002C4E  E00400     CP0.B W0
002C50  320003     BRA Z, 0x2C58
116:                                           sta = 0;
002C52  EB4000     CLR.B W0
002C54  784F00     MOV.B W0, [W14]
002C56  370011     BRA 0x2C7A
117:                                       } else
118:                                           sta = 6; //未开启TCP，
002C58  B3C060     MOV.B #0x6, W0
002C5A  784F00     MOV.B W0, [W14]
002C5C  37000E     BRA 0x2C7A
119:                                   } else
120:                                       sta = 5; //设置TCP失败
002C5E  B3C050     MOV.B #0x5, W0
002C60  784F00     MOV.B W0, [W14]
002C62  37000B     BRA 0x2C7A
121:                               } else
122:                                   sta = 4; //设置APN的问题
002C64  B3C040     MOV.B #0x4, W0
002C66  784F00     MOV.B W0, [W14]
002C68  370008     BRA 0x2C7A
123:                           } else
124:                               sta = 3; //手机信号未找到 电压不足可能导致
002C6A  B3C030     MOV.B #0x3, W0
002C6C  784F00     MOV.B W0, [W14]
002C6E  370005     BRA 0x2C7A
125:                       } else
126:                           sta = 2; //手机卡未插入
002C70  B3C020     MOV.B #0x2, W0
002C72  784F00     MOV.B W0, [W14]
002C74  370002     BRA 0x2C7A
127:                   } else
128:                       sta = 1; //模块损坏
002C76  B3C010     MOV.B #0x1, W0
002C78  784F00     MOV.B W0, [W14]
129:                   return sta;
002C7A  78401E     MOV.B [W14], W0
130:               }
002C7C  FA8000     ULNK
002C7E  060000     RETURN
131:               
132:               void HL6528_Close(void) {
002C80  FA0020     LNK #0x20
133:                   uint8_t tmp[20];
134:                   StrCmp stcp;
135:                   ClearBuffer(BufferRead_UART2);
002C82  2290C0     MOV #0x290C, W0
002C84  07FF57     RCALL ClearBuffer
136:                   do {
137:                       DSR = 1; //切换数据至AT命令 mark
002C86  A822EC     BSET LATF, #1
138:                       DTR = 1;
002C88  A822DC     BSET LATD, #1
139:                       Delay1s(1); //(0, 0, 1, 0); //延时1s
002C8A  B3C010     MOV.B #0x1, W0
002C8C  07FB76     RCALL Delay1s
140:                       DSR = 0; //请求发送数据
002C8E  A922EC     BCLR LATF, #1
141:                       DTR = 0;
002C90  A922DC     BCLR LATD, #1
142:                       Delay1s(1); //(0, 0, 1, 0); //延时1s
002C92  B3C010     MOV.B #0x1, W0
002C94  07FB72     RCALL Delay1s
143:                       stcp.SourceData = tmp;
002C96  980F2E     MOV W14, [W14+20]
144:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 20); //获取mark
002C98  90082E     MOV [W14+20], W0
002C9A  B3C142     MOV.B #0x14, W2
002C9C  780080     MOV W0, W1
002C9E  2290C0     MOV #0x290C, W0
002CA0  07FF32     RCALL UARTGetData
002CA2  985760     MOV.B W0, [W14+22]
145:                       stcp.CheckData = (uint8_t*) OK;
002CA4  28F9B0     MOV #0x8F9B, W0
002CA6  980F40     MOV W0, [W14+24]
146:                       stcp.Check_len = 2;
002CA8  B3C020     MOV.B #0x2, W0
002CAA  985F20     MOV.B W0, [W14+26]
147:                       stcp.GetData = NULL;
002CAC  EB0000     CLR W0
002CAE  980F60     MOV W0, [W14+28]
148:                       stcp.Get_len = 0;
002CB0  EB4000     CLR.B W0
002CB2  985F60     MOV.B W0, [W14+30]
149:                       stcp.Real_len = 0;
002CB4  EB4000     CLR.B W0
002CB6  985F70     MOV.B W0, [W14+31]
150:                   } while (UARTDataIsRight(&stcp)); //等待接受成功下线返回OK
002CB8  470074     ADD W14, #0x14, W0
002CBA  07FE62     RCALL UARTDataIsRight
002CBC  E00400     CP0.B W0
002CBE  3AFFE3     BRA NZ, 0x2C86
151:                   if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//关闭并删除TCP的ID通道
002CC0  B3C024     MOV.B #0x2, W4
002CC2  B3C023     MOV.B #0x2, W3
002CC4  EB0100     CLR W2
002CC6  28F9B1     MOV #0x8F9B, W1
002CC8  2904B0     MOV #0x904B, W0
002CCA  07FF4D     RCALL _HL6528SendCmd
002CCC  E00400     CP0.B W0
002CCE  320006     BRA Z, 0x2CDC
152:                       HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
002CD0  B3C024     MOV.B #0x2, W4
002CD2  B3C023     MOV.B #0x2, W3
002CD4  EB0100     CLR W2
002CD6  28F9B1     MOV #0x8F9B, W1
002CD8  2905E0     MOV #0x905E, W0
002CDA  07FF45     RCALL _HL6528SendCmd
153:                   Delay1s(1); // (0, 0, 1, 0); //延时1s    
002CDC  B3C010     MOV.B #0x1, W0
002CDE  07FB4D     RCALL Delay1s
154:                   PWR = 0; //电源控制
002CE0  A9E2DC     BCLR LATD, #7
155:                   PWRON = 0; //电源关闭
002CE2  A9C2DC     BCLR LATD, #6
156:                   CTS = 0; //请求接受
002CE4  A9A2DC     BCLR LATD, #5
157:                   RTS = 0; //请求发送
002CE6  A982DC     BCLR LATD, #4
158:                   DSR = 0; //设备
002CE8  A922EC     BCLR LATF, #1
159:                   DTR = 0; //终端
002CEA  A922DC     BCLR LATD, #1
160:                   UART2_Close();
002CEC  0703D2     RCALL UART2_Close
161:               }
002CEE  FA8000     ULNK
002CF0  060000     RETURN
162:               
163:               
164:               
165:               //static void HL6528_IOStart(void) {
166:               //    PWR = 1;
167:               //    PWRON = 1;
168:               //    CTS = 0;
169:               //    RTS = 0;
170:               //    DSR = 0;
171:               //    DTR = 0;
172:               //}
173:               //
174:               //static void HL6528_IOClose(void) {
175:               //    PWRON = 0;
176:               //    PWR = 0;
177:               //    CTS = 1;
178:               //    RTS = 1;
179:               //    DSR = 1;
180:               //    DTR = 1;
181:               //}
182:               
183:               void HL6528_GetIP_Port(void) {
002CF2  FA0020     LNK #0x20
184:                   uint8_t net_addr[25] = {'\0'};
002CF4  4700E2     ADD W14, #0x2, W1
002CF6  09000B     REPEAT #0xB
002CF8  EB1880     CLR [W1++]
002CFA  EB5880     CLR.B [W1++]
185:                   uint8_t str_tmp[4] = {1, 2, 3, 4};
002CFC  47017B     ADD W14, #0x1B, W2
002CFE  2906D1     MOV #0x906D, W1
002D00  090003     REPEAT #0x3
002D02  785931     MOV.B [W1++], [W2++]
186:                   uint8_t cnt;
187:                   uint8_t all_bytes = 0;
002D04  EB4000     CLR.B W0
002D06  984710     MOV.B W0, [W14+1]
188:               
189:                   //获取网络地址
190:                   all_bytes = my_itoa(WGCIPbits.IP3, net_addr);
002D08  BFC817     MOV.B 0x817, WREG
002D0A  FB8000     ZE W0, W0
002D0C  E8808E     INC2 W14, W1
002D0E  07FBA6     RCALL my_itoa
002D10  984710     MOV.B W0, [W14+1]
191:                   net_addr[all_bytes] = '.';
002D12  90401E     MOV.B [W14+1], W0
002D14  FB8000     ZE W0, W0
002D16  470000     ADD W14, W0, W0
002D18  B3C2E1     MOV.B #0x2E, W1
002D1A  984021     MOV.B W1, [W0+2]
192:                   net_addr[all_bytes + 1] = '\0';
002D1C  90401E     MOV.B [W14+1], W0
002D1E  FB8000     ZE W0, W0
002D20  E80000     INC W0, W0
002D22  470000     ADD W14, W0, W0
002D24  EB4080     CLR.B W1
002D26  984021     MOV.B W1, [W0+2]
193:                   all_bytes = all_bytes + 1;
002D28  90401E     MOV.B [W14+1], W0
002D2A  E84000     INC.B W0, W0
002D2C  984710     MOV.B W0, [W14+1]
194:               
195:                   all_bytes += my_itoa(WGCIPbits.IP2, str_tmp);
002D2E  BFC816     MOV.B 0x816, WREG
002D30  FB8000     ZE W0, W0
002D32  4700FB     ADD W14, #0x1B, W1
002D34  07FB93     RCALL my_itoa
002D36  90409E     MOV.B [W14+1], W1
002D38  40C000     ADD.B W1, W0, W0
002D3A  984710     MOV.B W0, [W14+1]
196:                   strcat(net_addr, str_tmp);
002D3C  4700FB     ADD W14, #0x1B, W1
002D3E  E8800E     INC2 W14, W0
002D40  07F112     RCALL 0xF66
197:                   net_addr[all_bytes ] = '.';
002D42  90401E     MOV.B [W14+1], W0
002D44  FB8000     ZE W0, W0
002D46  470000     ADD W14, W0, W0
002D48  B3C2E1     MOV.B #0x2E, W1
002D4A  984021     MOV.B W1, [W0+2]
198:                   net_addr[ all_bytes + 1] = '\0';
002D4C  90401E     MOV.B [W14+1], W0
002D4E  FB8000     ZE W0, W0
002D50  E80000     INC W0, W0
002D52  470000     ADD W14, W0, W0
002D54  EB4080     CLR.B W1
002D56  984021     MOV.B W1, [W0+2]
199:                   all_bytes = all_bytes + 1;
002D58  90401E     MOV.B [W14+1], W0
002D5A  E84000     INC.B W0, W0
002D5C  984710     MOV.B W0, [W14+1]
200:               
201:                   all_bytes += my_itoa(WGCIPbits.IP1, str_tmp);
002D5E  BFC815     MOV.B 0x815, WREG
002D60  FB8000     ZE W0, W0
002D62  4700FB     ADD W14, #0x1B, W1
002D64  07FB7B     RCALL my_itoa
002D66  90409E     MOV.B [W14+1], W1
002D68  40C000     ADD.B W1, W0, W0
002D6A  984710     MOV.B W0, [W14+1]
202:                   strcat(net_addr, str_tmp);
002D6C  4700FB     ADD W14, #0x1B, W1
002D6E  E8800E     INC2 W14, W0
002D70  07F0FA     RCALL 0xF66
203:                   net_addr[all_bytes ] = '.';
002D72  90401E     MOV.B [W14+1], W0
002D74  FB8000     ZE W0, W0
002D76  470000     ADD W14, W0, W0
002D78  B3C2E1     MOV.B #0x2E, W1
002D7A  984021     MOV.B W1, [W0+2]
204:                   net_addr[ all_bytes + 1] = '\0';
002D7C  90401E     MOV.B [W14+1], W0
002D7E  FB8000     ZE W0, W0
002D80  E80000     INC W0, W0
002D82  470000     ADD W14, W0, W0
002D84  EB4080     CLR.B W1
002D86  984021     MOV.B W1, [W0+2]
205:                   all_bytes = all_bytes + 1;
002D88  90401E     MOV.B [W14+1], W0
002D8A  E84000     INC.B W0, W0
002D8C  984710     MOV.B W0, [W14+1]
206:               
207:                   all_bytes += my_itoa(WGCIPbits.IP0, str_tmp);
002D8E  BFC814     MOV.B WGCIPbits, WREG
002D90  FB8000     ZE W0, W0
002D92  4700FB     ADD W14, #0x1B, W1
002D94  07FB63     RCALL my_itoa
002D96  90409E     MOV.B [W14+1], W1
002D98  40C000     ADD.B W1, W0, W0
002D9A  984710     MOV.B W0, [W14+1]
208:                   strcat(net_addr, str_tmp);
002D9C  4700FB     ADD W14, #0x1B, W1
002D9E  E8800E     INC2 W14, W0
002DA0  07F0E2     RCALL 0xF66
209:                   net_addr[ all_bytes ] = '"';
002DA2  90401E     MOV.B [W14+1], W0
002DA4  FB8000     ZE W0, W0
002DA6  470000     ADD W14, W0, W0
002DA8  B3C221     MOV.B #0x22, W1
002DAA  984021     MOV.B W1, [W0+2]
210:                   net_addr[all_bytes + 1 ] = ',';
002DAC  90401E     MOV.B [W14+1], W0
002DAE  FB8000     ZE W0, W0
002DB0  E80000     INC W0, W0
002DB2  470000     ADD W14, W0, W0
002DB4  B3C2C1     MOV.B #0x2C, W1
002DB6  984021     MOV.B W1, [W0+2]
211:                   net_addr[ all_bytes + 2] = '\0';
002DB8  90401E     MOV.B [W14+1], W0
002DBA  FB8000     ZE W0, W0
002DBC  E88000     INC2 W0, W0
002DBE  470000     ADD W14, W0, W0
002DC0  EB4080     CLR.B W1
002DC2  984021     MOV.B W1, [W0+2]
212:                   all_bytes = all_bytes + 2;
002DC4  90401E     MOV.B [W14+1], W0
002DC6  E8C000     INC2.B W0, W0
002DC8  984710     MOV.B W0, [W14+1]
213:               
214:                   all_bytes += my_itoa(WGCPORT, str_tmp);
002DCA  8040E0     MOV WGCPORT, W0
002DCC  4700FB     ADD W14, #0x1B, W1
002DCE  07FB46     RCALL my_itoa
002DD0  90409E     MOV.B [W14+1], W1
002DD2  40C000     ADD.B W1, W0, W0
002DD4  984710     MOV.B W0, [W14+1]
215:                   strcat(net_addr, str_tmp);
002DD6  4700FB     ADD W14, #0x1B, W1
002DD8  E8800E     INC2 W14, W0
002DDA  07F0C5     RCALL 0xF66
216:                   net_addr[ all_bytes ] = '\r';
002DDC  90401E     MOV.B [W14+1], W0
002DDE  FB8000     ZE W0, W0
002DE0  470000     ADD W14, W0, W0
002DE2  B3C0D1     MOV.B #0xD, W1
002DE4  984021     MOV.B W1, [W0+2]
217:                   net_addr[ all_bytes + 1] = '\n';
002DE6  90401E     MOV.B [W14+1], W0
002DE8  FB8000     ZE W0, W0
002DEA  E80000     INC W0, W0
002DEC  470000     ADD W14, W0, W0
002DEE  B3C0A1     MOV.B #0xA, W1
002DF0  984021     MOV.B W1, [W0+2]
218:                   net_addr[ all_bytes + 2] = '\0';
002DF2  90401E     MOV.B [W14+1], W0
002DF4  FB8000     ZE W0, W0
002DF6  E88000     INC2 W0, W0
002DF8  470000     ADD W14, W0, W0
002DFA  EB4080     CLR.B W1
002DFC  984021     MOV.B W1, [W0+2]
219:                   all_bytes = all_bytes + 2;
002DFE  90401E     MOV.B [W14+1], W0
002E00  E8C000     INC2.B W0, W0
002E02  984710     MOV.B W0, [W14+1]
220:                   //   uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
221:                   for (cnt = 0; cnt < all_bytes; cnt++)
002E04  EB4000     CLR.B W0
002E06  784F00     MOV.B W0, [W14]
002E08  37000A     BRA 0x2E1E
002E1C  E84F1E     INC.B [W14], [W14]
002E1E  90401E     MOV.B [W14+1], W0
002E20  78409E     MOV.B [W14], W1
002E22  50CF80     SUB.B W1, W0, [W15]
002E24  39FFF2     BRA NC, 0x2E0A
222:                       *(KTCPCFG1 + 16 + cnt) = *(net_addr + cnt);
002E0A  FB801E     ZE [W14], W0
002E0C  4000F0     ADD W0, #0x10, W1
002E0E  209080     MOV #0x908, W0
002E10  408000     ADD W1, W0, W0
002E12  FB809E     ZE [W14], W1
002E14  E8810E     INC2 W14, W2
002E16  410081     ADD W2, W1, W1
002E18  784091     MOV.B [W1], W1
002E1A  784801     MOV.B W1, [W0]
223:                   //    return all_bytes;
224:               }
002E26  FA8000     ULNK
225:               
226:               
227:               
228:               
229:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/E41.c  --------------------------------------
1:                 #include "E41.h"
2:                 
3:                 #define M0_TRIS TRISEbits.TRISE5
4:                 #define M1_TRIS TRISEbits.TRISE6
5:                 #define M0 LATEbits.LATE5
6:                 #define M1 LATEbits.LATE6
7:                 #define M0_PORT PORTEbits.RE5
8:                 #define M1_PORT PORTEbits.RE6
9:                 #define AUX PORTFbits.RF6
10:                
11:                #define WORK 0
12:                #define WAKE 1
13:                #define LOWPOWER 2
14:                #define SLEEP 3
15:                uint8_t E41_Arg[] = {0xC0, 0xff, 0xff, 0x18, 0x1, 0xfc};
16:                // FF FF 18 01 9C
17:                //static ADDBITS E41_ADD;
18:                //static ARG1BITS E41_ARG1;
19:                //static ARG2BITS E41_ARG2;
20:                
21:                /*
22:                模式切换和 AUX：在低功耗应用中，用户单片机可能需要切换工作模式，从而达到休眠、无线唤醒的目的。此时，
23:                AUX 引脚将起到关键作用。表现在如下几个方面：
24:                a) 复位后，模块自检期间 AUX 处理低电平，AUX 上升沿后，模块才开始?入工作状态。
25:                b) 从模式 3 切换到其他模式后，模块也会产生自检，AUX 逡辑状态等同于复位。
26:                c) 模式切换前，如果 AUX 是高电平，可以直接改发 M1M0 切换到新模式，2ms 生效。
27:                d) 模式切换前，如果 AUX 是低电平，可以直接改发 M1M0 切换到新模式，AUX 上升沿后 2ms 生效。
28:                 */
29:                static void E41_SetMode(uint8_t mode) {
003056  FA0002     LNK #0x2
003058  784F00     MOV.B W0, [W14]
30:                    //获取当前的模式
31:                    //    uint8_t now_mode = M0_PORT + (M1_PORT << 1);//mark
32:                    //设置当前模式
33:                    //    switch (mode) {
34:                    //        case SLEEP:
35:                    //        {
36:                    INT0_Close(); //关闭串口，避免切换模式导致错误接受
00305A  0703F6     RCALL INT0_Close
37:                    M0 = 0;
00305C  A9A2E4     BCLR LATE, #5
38:                    M1 = 0; //避免自检程序
00305E  A9C2E4     BCLR LATE, #6
39:                    Delay100ms(3); //(0, 0, 0, 250);
003060  200030     MOV #0x3, W0
003062  07F96E     RCALL Delay100ms
40:                    M0 = mode & 0x01;
003064  78409E     MOV.B [W14], W1
003066  60C061     AND.B W1, #0x1, W0
003068  604061     AND.B W0, #0x1, W0
00306A  604061     AND.B W0, #0x1, W0
00306C  FB8000     ZE W0, W0
00306E  600061     AND W0, #0x1, W0
003070  DD0045     SL W0, #5, W0
003072  801721     MOV LATE, W1
003074  A15001     BCLR W1, #5
003076  700001     IOR W0, W1, W0
003078  881720     MOV W0, LATE
41:                    M1 = (mode >> 1) & 0x01;
00307A  FB801E     ZE [W14], W0
00307C  D10000     LSR W0, W0
00307E  784000     MOV.B W0, W0
003080  604061     AND.B W0, #0x1, W0
003082  604061     AND.B W0, #0x1, W0
003084  604061     AND.B W0, #0x1, W0
003086  FB8000     ZE W0, W0
003088  600061     AND W0, #0x1, W0
00308A  DD0046     SL W0, #6, W0
00308C  801721     MOV LATE, W1
00308E  A16001     BCLR W1, #6
003090  700001     IOR W0, W1, W0
003092  881720     MOV W0, LATE
42:                    Delay10ms(1); //(0, 0, 0, 10);
003094  200010     MOV #0x1, W0
003096  07F93C     RCALL Delay10ms
43:                    INT0_Open();
003098  0703D2     RCALL INT0_Open
44:                    //            break;
45:                    //        }
46:                    //        case LOWPOWER:
47:                    //        {
48:                    //            break;
49:                    //        }
50:                    //        case WAKE:
51:                    //        {
52:                    //            break;
53:                    //        }
54:                    //        case WORK:
55:                    //        {
56:                    //            break;
57:                }
00309A  FA8000     ULNK
00309C  060000     RETURN
58:                //            M0 = mode & 0x01;
59:                //            M1 = (mode >> 1) & 0x01;
60:                //}
61:                //}
62:                
63:                void E41_Init(void) {
00309E  FA0002     LNK #0x2
64:                    uint8_t cnt;
65:                    M0_TRIS = 0; //设置引脚
0030A0  A9A2E0     BCLR TRISE, #5
66:                    M1_TRIS = 0;
0030A2  A9C2E0     BCLR TRISE, #6
67:                    //    uint8_t currentMode = E41_SetGetMode(10);
68:                    E41_SetMode(SLEEP);
0030A4  B3C030     MOV.B #0x3, W0
0030A6  07FFD7     RCALL _E41_SetMode
69:                    Delay100ms(3); //(0, 0, 0, 300); //必须加 300ms 避开自检
0030A8  200030     MOV #0x3, W0
0030AA  07F94A     RCALL Delay100ms
70:                    //    UART3_SendChar(0xC0);
71:                    for (cnt = 0; cnt < 3; cnt++) {
0030AC  EB4000     CLR.B W0
0030AE  784F00     MOV.B W0, [W14]
0030B0  370006     BRA 0x30BE
0030BC  E84F1E     INC.B [W14], [W14]
0030BE  78401E     MOV.B [W14], W0
0030C0  504FE2     SUB.B W0, #0x2, [W15]
0030C2  36FFF7     BRA LEU, 0x30B2
72:                        UART3_SendString(E41_Arg, 6);
0030B2  B3C061     MOV.B #0x6, W1
0030B4  2093C0     MOV #0x93C, W0
0030B6  070280     RCALL UART3_SendString
73:                        //    UART3_SendString(E41_Arg, 6);
74:                        Delay10ms(1);
0030B8  200010     MOV #0x1, W0
0030BA  07F92A     RCALL Delay10ms
75:                //        (0, 0, 0, 10);
76:                    }
77:                    //    E41_SetMode(LOWPOWER); //设置为低功耗模式
78:                    //    E41_SetMode(WORK); //设置为唤醒模式   
79:                    E41_SetMode(WAKE); //设置为唤醒模式   
0030C4  B3C010     MOV.B #0x1, W0
0030C6  07FFC7     RCALL _E41_SetMode
80:                }
0030C8  FA8000     ULNK
0030CA  060000     RETURN
81:                
82:                bool E41_PressureIsGet(float* pres) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
0030CC  FA004E     LNK #0x4E
0030CE  982760     MOV W0, [W14+76]
83:                    //判断接受到数据类型是仪表还是压力值
84:                    uint8_t tmp[10];
85:                    uint8_t Head[3] = {0x1, 0x3, 0x4};
0030D0  B3C010     MOV.B #0x1, W0
0030D2  984F20     MOV.B W0, [W14+10]
0030D4  B3C030     MOV.B #0x3, W0
0030D6  984F30     MOV.B W0, [W14+11]
0030D8  B3C040     MOV.B #0x4, W0
0030DA  984F40     MOV.B W0, [W14+12]
86:                    U3Rx4Byte();
0030DC  070291     RCALL U3Rx4Byte
87:                    StrCmp stcp;
88:                    uint8_t Source_tmp[50]; //临时变量
89:                
90:                    stcp.Source_len = UARTGetData(BufferRead_UART3, Source_tmp, 10);
0030DE  47007A     ADD W14, #0x1A, W0
0030E0  B3C0A2     MOV.B #0xA, W2
0030E2  780080     MOV W0, W1
0030E4  229460     MOV #0x2946, W0
0030E6  07FD0F     RCALL UARTGetData
0030E8  985700     MOV.B W0, [W14+16]
91:                    if (stcp.Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
0030EA  90508E     MOV.B [W14+16], W1
0030EC  B3C320     MOV.B #0x32, W0
0030EE  50CF80     SUB.B W1, W0, [W15]
0030F0  360002     BRA LEU, 0x30F6
92:                        stcp.Source_len = 50;
0030F2  B3C320     MOV.B #0x32, W0
0030F4  985700     MOV.B W0, [W14+16]
93:                    stcp.SourceData = Source_tmp;
0030F6  47007A     ADD W14, #0x1A, W0
0030F8  980770     MOV W0, [W14+14]
94:                    stcp.CheckData = Head;
0030FA  47006A     ADD W14, #0xA, W0
0030FC  980F10     MOV W0, [W14+18]
95:                    stcp.Check_len = 3;
0030FE  B3C030     MOV.B #0x3, W0
003100  985740     MOV.B W0, [W14+20]
96:                    stcp.GetData = tmp;
003102  980F3E     MOV W14, [W14+22]
97:                    stcp.Get_len = 8;
003104  B3C080     MOV.B #0x8, W0
003106  985F00     MOV.B W0, [W14+24]
98:                    stcp.Real_len = 0;
003108  EB4000     CLR.B W0
00310A  985F10     MOV.B W0, [W14+25]
99:                    UARTDataIsRight(&stcp);
00310C  47006E     ADD W14, #0xE, W0
00310E  07FC38     RCALL UARTDataIsRight
100:                   if ((stcp.Real_len == 9) && CRCIsRight(tmp, 7, tmp + 7)) {//注意优先的结合顺序
003110  90581E     MOV.B [W14+25], W0
003112  504FE9     SUB.B W0, #0x9, [W15]
003114  3A000D     BRA NZ, 0x3130
003116  470067     ADD W14, #0x7, W0
003118  780100     MOV W0, W2
00311A  B3C071     MOV.B #0x7, W1
00311C  78000E     MOV W14, W0
00311E  070125     RCALL CRCIsRight
003120  E00400     CP0.B W0
003122  320006     BRA Z, 0x3130
101:                       CharToFloat(pres, tmp + 3);
003124  470063     ADD W14, #0x3, W0
003126  780080     MOV W0, W1
003128  90206E     MOV [W14+76], W0
00312A  07F828     RCALL CharToFloat
102:                       return true;
00312C  B3C010     MOV.B #0x1, W0
00312E  370001     BRA 0x3132
103:                   }
104:                   return false;
003130  EB4000     CLR.B W0
105:               }
003132  FA8000     ULNK
003134  060000     RETURN
106:               
107:               void E41_Active_Send(void) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
003136  FA0014     LNK #0x14
108:                   //判断接受到数据类型是仪表还是压力值
109:                   uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34, 0x20, 0x30, 0x42}, cnt;
003138  090009     REPEAT #0x9
00313A  EB1F00     CLR [W14++]
00313C  B1014E     SUB #0x14, W14
00313E  B3C010     MOV.B #0x1, W0
003140  984710     MOV.B W0, [W14+1]
003142  B3C010     MOV.B #0x1, W0
003144  984720     MOV.B W0, [W14+2]
003146  B3C120     MOV.B #0x12, W0
003148  984730     MOV.B W0, [W14+3]
00314A  B3C340     MOV.B #0x34, W0
00314C  984740     MOV.B W0, [W14+4]
00314E  B3C200     MOV.B #0x20, W0
003150  984750     MOV.B W0, [W14+5]
003152  B3C300     MOV.B #0x30, W0
003154  984760     MOV.B W0, [W14+6]
003156  B3C420     MOV.B #0x42, W0
003158  984770     MOV.B W0, [W14+7]
110:                   E41_SetMode(WAKE); //设置为唤醒模式    
00315A  B3C010     MOV.B #0x1, W0
00315C  07FF7C     RCALL _E41_SetMode
111:                   Delay100ms(1); //(0, 0, 0, 100);
00315E  200010     MOV #0x1, W0
003160  07F8EF     RCALL Delay100ms
112:                   INT0_Close();
003162  070372     RCALL INT0_Close
113:                   //    for (cnt = 0; cnt < 3; cnt++) {
114:                   UART3_SendString(E41_tmp, 8);
003164  B3C081     MOV.B #0x8, W1
003166  78000E     MOV W14, W0
003168  070227     RCALL UART3_SendString
115:                   Delay10ms(1); //(0, 0, 0, 10);
00316A  200010     MOV #0x1, W0
00316C  07F8D1     RCALL Delay10ms
116:                   //必须加
117:                   //    }
118:                   INT0_Open();
00316E  070367     RCALL INT0_Open
119:                   Delay1s(10); //(0, 0, 10, 0);
003170  2000A0     MOV #0xA, W0
003172  07F903     RCALL Delay1s
120:                   E41_SetMode(LOWPOWER); //设置为低功耗模式    
003174  B3C020     MOV.B #0x2, W0
003176  07FF6F     RCALL _E41_SetMode
121:                   //    OSTimeDlyHMSM(0, 0, 10, 0);
122:               }
003178  FA8000     ULNK
123:               
124:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: 浮点数转化为char数组
6:                 Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
7:                 Output: 输出数值
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
00214E  FA0008     LNK #0x8
002150  980720     MOV W0, [W14+4]
002152  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
002154  9000AE     MOV [W14+4], W1
002156  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
002158  EB4000     CLR.B W0
00215A  784F00     MOV.B W0, [W14]
00215C  37000A     BRA 0x2172
002170  E84F1E     INC.B [W14], [W14]
002172  78401E     MOV.B [W14], W0
002174  504FE3     SUB.B W0, #0x3, [W15]
002176  36FFF3     BRA LEU, 0x215E
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
00215E  FB801E     ZE [W14], W0
002160  9000BE     MOV [W14+6], W1
002162  408000     ADD W1, W0, W0
002164  90011E     MOV [W14+2], W2
002166  FB809E     ZE [W14], W1
002168  1080E3     SUBR W1, #0x3, W1
00216A  410081     ADD W2, W1, W1
00216C  784091     MOV.B [W1], W1
00216E  784801     MOV.B W1, [W0]
16:                    }
17:                }
002178  FA8000     ULNK
00217A  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char数组转化为浮点数 
22:                Input: 输出数值    模式：4 单精度浮点数 8 双精度浮点数 
23:                Output: 输入浮点数
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
00217C  FA0008     LNK #0x8
00217E  980720     MOV W0, [W14+4]
002180  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
002182  9000AE     MOV [W14+4], W1
002184  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
002186  EB4000     CLR.B W0
002188  784F00     MOV.B W0, [W14]
00218A  37000A     BRA 0x21A0
00219E  E84F1E     INC.B [W14], [W14]
0021A0  78401E     MOV.B [W14], W0
0021A2  504FE3     SUB.B W0, #0x3, [W15]
0021A4  36FFF3     BRA LEU, 0x218C
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
00218C  90009E     MOV [W14+2], W1
00218E  FB801E     ZE [W14], W0
002190  408000     ADD W1, W0, W0
002192  FB809E     ZE [W14], W1
002194  1080E3     SUBR W1, #0x3, W1
002196  90013E     MOV [W14+6], W2
002198  410081     ADD W2, W1, W1
00219A  784091     MOV.B [W1], W1
00219C  784801     MOV.B W1, [W0]
32:                    }
33:                }
0021A6  FA8000     ULNK
0021A8  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: 浮点数转化为char数组
38:                Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
39:                Output: 输出数值
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
0021AA  FA0008     LNK #0x8
0021AC  980720     MOV W0, [W14+4]
0021AE  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
0021B0  9000AE     MOV [W14+4], W1
0021B2  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
0021B4  EB4000     CLR.B W0
0021B6  784F00     MOV.B W0, [W14]
0021B8  37000A     BRA 0x21CE
0021CC  E84F1E     INC.B [W14], [W14]
0021CE  78401E     MOV.B [W14], W0
0021D0  504FE7     SUB.B W0, #0x7, [W15]
0021D2  36FFF3     BRA LEU, 0x21BA
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
0021BA  FB801E     ZE [W14], W0
0021BC  9000BE     MOV [W14+6], W1
0021BE  408000     ADD W1, W0, W0
0021C0  90011E     MOV [W14+2], W2
0021C2  FB809E     ZE [W14], W1
0021C4  1080E7     SUBR W1, #0x7, W1
0021C6  410081     ADD W2, W1, W1
0021C8  784091     MOV.B [W1], W1
0021CA  784801     MOV.B W1, [W0]
48:                    }
49:                }
0021D4  FA8000     ULNK
0021D6  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 16进制转化为10进制
54:                Input: 数据，字节数
55:                Output: 输出数值
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
0021D8  FA0002     LNK #0x2
0021DA  781F88     MOV W8, [W15++]
0021DC  784F00     MOV.B W0, [W14]
58:                    return (dat >> 4)*10 + GetMod(dat, 4);
0021DE  FB801E     ZE [W14], W0
0021E0  DE0044     LSR W0, #4, W0
0021E2  784000     MOV.B W0, W0
0021E4  B9006A     MUL.SU W0, #10, W0
0021E6  780000     MOV W0, W0
0021E8  784400     MOV.B W0, W8
0021EA  FB801E     ZE [W14], W0
0021EC  B3C041     MOV.B #0x4, W1
0021EE  070126     RCALL GetMod
0021F0  444000     ADD.B W8, W0, W0
59:                }
0021F2  78044F     MOV [--W15], W8
0021F4  FA8000     ULNK
0021F6  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 10进制转化为16进制
64:                Input: 数据，字节数
65:                Output: 输出数值
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
0021F8  FA0004     LNK #0x4
0021FA  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
0021FC  FB809E     ZE [W14], W1
0021FE  2000A0     MOV #0xA, W0
002200  780100     MOV W0, W2
002202  090011     REPEAT #0x11
002204  D88082     DIV.UW W1, W2
002206  784000     MOV.B W0, W0
002208  FB8000     ZE W0, W0
00220A  DD0044     SL W0, #4, W0
00220C  784000     MOV.B W0, W0
00220E  984720     MOV.B W0, [W14+2]
002210  FB811E     ZE [W14], W2
002212  2000A0     MOV #0xA, W0
002214  780180     MOV W0, W3
002216  090011     REPEAT #0x11
002218  D88103     DIV.UW W2, W3
00221A  FD0080     EXCH W0, W1
00221C  784000     MOV.B W0, W0
00221E  60406F     AND.B W0, #0xF, W0
002220  9040AE     MOV.B [W14+2], W1
002222  70C000     IOR.B W1, W0, W0
69:                }
002224  FA8000     ULNK
002226  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x11（17）-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 判断数据是否有效
79:                Input: 是否
80:                Output: 输出数值
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
002228  FA0006     LNK #0x6
00222A  780F00     MOV W0, [W14]
00222C  980711     MOV W1, [W14+2]
00222E  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
002230  90001E     MOV [W14+2], W0
002232  78009E     MOV [W14], W1
002234  508F80     SUB W1, W0, [W15]
002236  360002     BRA LEU, 0x223C
002238  EB4000     CLR.B W0
00223A  370007     BRA 0x224A
84:                    else if (dat < min) return false;
00223C  90002E     MOV [W14+4], W0
00223E  78009E     MOV [W14], W1
002240  508F80     SUB W1, W0, [W15]
002242  310002     BRA C, 0x2248
002244  EB4000     CLR.B W0
002246  370001     BRA 0x224A
85:                    return true;
002248  B3C010     MOV.B #0x1, W0
86:                }
00224A  FA8000     ULNK
00224C  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 根据阀值设置参数
91:                Input: 是否
92:                Output: 输出数值
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
00224E  FA000A     LNK #0xA
002250  980710     MOV W0, [W14+2]
002252  980722     MOV W2, [W14+4]
002254  980733     MOV W3, [W14+6]
002256  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
002258  90001E     MOV [W14+2], W0
00225A  780010     MOV [W0], W0
00225C  DD00C8     SL W0, #8, W1
00225E  90001E     MOV [W14+2], W0
002260  E88000     INC2 W0, W0
002262  780010     MOV [W0], W0
002264  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
002266  78001E     MOV [W14], W0
002268  B80161     MUL.UU W0, #1, W2
00226A  90002E     MOV [W14+4], W0
00226C  9000BE     MOV [W14+6], W1
00226E  510F80     SUB W2, W0, [W15]
002270  598F81     SUBB W3, W1, [W15]
002272  360004     BRA LEU, 0x227C
98:                        *dat = max;
002274  9000AE     MOV [W14+4], W1
002276  90001E     MOV [W14+2], W0
002278  780801     MOV W1, [W0]
00227A  370007     BRA 0x228A
99:                    } else if (tmp < min) {
00227C  90004E     MOV [W14+8], W0
00227E  78009E     MOV [W14], W1
002280  508F80     SUB W1, W0, [W15]
002282  310003     BRA C, 0x228A
100:                       *dat = min;
002284  90001E     MOV [W14+2], W0
002286  9000CE     MOV [W14+8], W1
002288  780801     MOV W1, [W0]
101:                   }
102:               }
00228A  FA8000     ULNK
00228C  060000     RETURN
103:               //将数据反转
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
00228E  FA0006     LNK #0x6
002290  980710     MOV W0, [W14+2]
002292  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
002294  EB4000     CLR.B W0
002296  784F00     MOV.B W0, [W14]
002298  37001B     BRA 0x22D0
0022CE  E84F1E     INC.B [W14], [W14]
0022D0  90404E     MOV.B [W14+4], W0
0022D2  FB8000     ZE W0, W0
0022D4  D10000     LSR W0, W0
0022D6  784000     MOV.B W0, W0
0022D8  504F9E     SUB.B W0, [W14], [W15]
0022DA  3EFFDF     BRA GTU, 0x229A
109:                       tmp = dat[cnt];
00229A  FB801E     ZE [W14], W0
00229C  90009E     MOV [W14+2], W1
00229E  408000     ADD W1, W0, W0
0022A0  784090     MOV.B [W0], W1
0022A2  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
0022A4  FB801E     ZE [W14], W0
0022A6  90009E     MOV [W14+2], W1
0022A8  408000     ADD W1, W0, W0
0022AA  9040CE     MOV.B [W14+4], W1
0022AC  FB8081     ZE W1, W1
0022AE  E90101     DEC W1, W2
0022B0  FB809E     ZE [W14], W1
0022B2  510081     SUB W2, W1, W1
0022B4  90011E     MOV [W14+2], W2
0022B6  410081     ADD W2, W1, W1
0022B8  784091     MOV.B [W1], W1
0022BA  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
0022BC  90404E     MOV.B [W14+4], W0
0022BE  FB8000     ZE W0, W0
0022C0  E90080     DEC W0, W1
0022C2  FB801E     ZE [W14], W0
0022C4  508000     SUB W1, W0, W0
0022C6  90009E     MOV [W14+2], W1
0022C8  408000     ADD W1, W0, W0
0022CA  90409E     MOV.B [W14+1], W1
0022CC  784801     MOV.B W1, [W0]
112:                   }
113:               }
0022DC  FA8000     ULNK
0022DE  060000     RETURN
114:               
115:               //void Delayms(uint16_t time) {//不能大于1000,溢出
116:               //    TMR2 = 0; //清楚定时器2的计数器
117:               //    PR2 = 625 * time / 10; //设置定时时间
118:               //    IFS0bits.T2IF = 0;
119:               //    T2CONbits.TON = 1; //开启定时器二    
120:               //    while (!IFS0bits.T2IF); //等待定时时间到
121:               //    T2CONbits.TON = 0; //关闭定时器二
122:               //    IFS0bits.T2IF = 0; //清楚标志位
123:               //}
124:               //8MHz-》4Mhz 使用重载入的函数
125:               //0x0271 10ms
126:               
127:               //32Mhz
128:               
129:               void Delay1ms(char time) {
0022E0  FA0004     LNK #0x4
0022E2  984720     MOV.B W0, [W14+2]
130:                   uint16_t i;
131:                   while (time-- > 0)
0022E4  370009     BRA 0x22F8
0022F8  B3C010     MOV.B #0x1, W0
0022FA  9040AE     MOV.B [W14+2], W1
0022FC  E00401     CP0.B W1
0022FE  3C0001     BRA GT, 0x2302
002300  EB4000     CLR.B W0
002302  9040AE     MOV.B [W14+2], W1
002304  E94081     DEC.B W1, W1
002306  984721     MOV.B W1, [W14+2]
002308  E00400     CP0.B W0
00230A  3AFFED     BRA NZ, 0x22E6
132:                       for (i = 0; i < 144; i++)
0022E6  EB0000     CLR W0
0022E8  780F00     MOV W0, [W14]
0022EA  370002     BRA 0x22F0
0022EE  E80F1E     INC [W14], [W14]
0022F0  2008F0     MOV #0x8F, W0
0022F2  78009E     MOV [W14], W1
0022F4  508F80     SUB W1, W0, [W15]
0022F6  36FFFA     BRA LEU, 0x22EC
133:                           Nop();
0022EC  000000     NOP
134:               }
00230C  FA8000     ULNK
00230E  060000     RETURN
135:               
136:               void Delay10ms(char time) {
002310  FA0004     LNK #0x4
002312  984720     MOV.B W0, [W14+2]
137:                   uint16_t i;
138:                   while (time-- > 0)
002314  370009     BRA 0x2328
002328  B3C010     MOV.B #0x1, W0
00232A  9040AE     MOV.B [W14+2], W1
00232C  E00401     CP0.B W1
00232E  3C0001     BRA GT, 0x2332
002330  EB4000     CLR.B W0
002332  9040AE     MOV.B [W14+2], W1
002334  E94081     DEC.B W1, W1
002336  984721     MOV.B W1, [W14+2]
002338  E00400     CP0.B W0
00233A  3AFFED     BRA NZ, 0x2316
139:                       for (i = 0; i < 1440; i++)
002316  EB0000     CLR W0
002318  780F00     MOV W0, [W14]
00231A  370002     BRA 0x2320
00231E  E80F1E     INC [W14], [W14]
002320  2059F0     MOV #0x59F, W0
002322  78009E     MOV [W14], W1
002324  508F80     SUB W1, W0, [W15]
002326  36FFFA     BRA LEU, 0x231C
140:                           Nop();
00231C  000000     NOP
141:               }
00233C  FA8000     ULNK
00233E  060000     RETURN
142:               
143:               void Delay100ms(char time) {
002340  FA0006     LNK #0x6
002342  984740     MOV.B W0, [W14+4]
144:                   uint32_t i;
145:                   while (time-- > 0)
002344  37000E     BRA 0x2362
002362  B3C010     MOV.B #0x1, W0
002364  9040CE     MOV.B [W14+4], W1
002366  E00401     CP0.B W1
002368  3C0001     BRA GT, 0x236C
00236A  EB4000     CLR.B W0
00236C  9040CE     MOV.B [W14+4], W1
00236E  E94081     DEC.B W1, W1
002370  984741     MOV.B W1, [W14+4]
002372  E00400     CP0.B W0
002374  3AFFE8     BRA NZ, 0x2346
146:                       for (i = 0; i < 14400; i++)
002346  B80060     MUL.UU W0, #0, W0
002348  BE8F00     MOV.D W0, [W14]
00234A  370005     BRA 0x2356
00234E  200012     MOV #0x1, W2
002350  200003     MOV #0x0, W3
002352  410F1E     ADD W2, [W14], [W14]
002354  49975E     ADDC W3, [++W14], [W14--]
002356  2383F0     MOV #0x383F, W0
002358  200001     MOV #0x0, W1
00235A  BE011E     MOV.D [W14], W2
00235C  510F80     SUB W2, W0, [W15]
00235E  598F81     SUBB W3, W1, [W15]
002360  36FFF5     BRA LEU, 0x234C
147:                           Nop();
00234C  000000     NOP
148:               }
002376  FA8000     ULNK
002378  060000     RETURN
149:               
150:               void Delay1s(char time) {
00237A  FA0006     LNK #0x6
00237C  984740     MOV.B W0, [W14+4]
151:                   uint32_t i; //,j;
152:                   while (time-- > 0)
00237E  37000E     BRA 0x239C
00239C  B3C010     MOV.B #0x1, W0
00239E  9040CE     MOV.B [W14+4], W1
0023A0  E00401     CP0.B W1
0023A2  3C0001     BRA GT, 0x23A6
0023A4  EB4000     CLR.B W0
0023A6  9040CE     MOV.B [W14+4], W1
0023A8  E94081     DEC.B W1, W1
0023AA  984741     MOV.B W1, [W14+4]
0023AC  E00400     CP0.B W0
0023AE  3AFFE8     BRA NZ, 0x2380
153:                       for (i = 0; i < 144000; i++)
002380  B80060     MUL.UU W0, #0, W0
002382  BE8F00     MOV.D W0, [W14]
002384  370005     BRA 0x2390
002388  200012     MOV #0x1, W2
00238A  200003     MOV #0x0, W3
00238C  410F1E     ADD W2, [W14], [W14]
00238E  49975E     ADDC W3, [++W14], [W14--]
002390  2327F0     MOV #0x327F, W0
002392  200021     MOV #0x2, W1
002394  BE011E     MOV.D [W14], W2
002396  510F80     SUB W2, W0, [W15]
002398  598F81     SUBB W3, W1, [W15]
00239A  36FFF5     BRA LEU, 0x2386
154:                           Nop();
002386  000000     NOP
155:               }
0023B0  FA8000     ULNK
0023B2  060000     RETURN
156:               
157:               //void Delays(char time) {
158:               //    uint8_t cnt;
159:               //    for (cnt = 0; cnt < time; cnt++)
160:               //        Delayms(1000);
161:               //}
162:               
163:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
0023B4  FA0008     LNK #0x8
0023B6  980710     MOV W0, [W14+2]
0023B8  980721     MOV W1, [W14+4]
0023BA  984762     MOV.B W2, [W14+6]
164:                   uint8_t num;
165:                   for (num = 0; num < bytes; num++)
0023BC  EB4000     CLR.B W0
0023BE  784F00     MOV.B W0, [W14]
0023C0  370009     BRA 0x23D4
0023D2  E84F1E     INC.B [W14], [W14]
0023D4  90406E     MOV.B [W14+6], W0
0023D6  78409E     MOV.B [W14], W1
0023D8  50CF80     SUB.B W1, W0, [W15]
0023DA  39FFF3     BRA NC, 0x23C2
166:                       *(output + num) = *(input + num);
0023C2  FB801E     ZE [W14], W0
0023C4  90009E     MOV [W14+2], W1
0023C6  408000     ADD W1, W0, W0
0023C8  FB809E     ZE [W14], W1
0023CA  90012E     MOV [W14+4], W2
0023CC  410081     ADD W2, W1, W1
0023CE  784091     MOV.B [W1], W1
0023D0  784801     MOV.B W1, [W0]
167:               }
0023DC  FA8000     ULNK
0023DE  060000     RETURN
168:               
169:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
0023E0  FA0006     LNK #0x6
0023E2  980710     MOV W0, [W14+2]
0023E4  984741     MOV.B W1, [W14+4]
0023E6  984752     MOV.B W2, [W14+5]
170:                   uint8_t num;
171:                   for (num = 0; num < bytes; num++)
0023E8  EB4000     CLR.B W0
0023EA  784F00     MOV.B W0, [W14]
0023EC  370006     BRA 0x23FA
0023F8  E84F1E     INC.B [W14], [W14]
0023FA  90405E     MOV.B [W14+5], W0
0023FC  78409E     MOV.B [W14], W1
0023FE  50CF80     SUB.B W1, W0, [W15]
002400  39FFF6     BRA NC, 0x23EE
172:                       *(output + num) = dat;
0023EE  FB801E     ZE [W14], W0
0023F0  90009E     MOV [W14+2], W1
0023F2  408000     ADD W1, W0, W0
0023F4  9040CE     MOV.B [W14+4], W1
0023F6  784801     MOV.B W1, [W0]
173:               }
002402  FA8000     ULNK
002404  060000     RETURN
174:               
175:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
002406  FA0008     LNK #0x8
002408  980710     MOV W0, [W14+2]
00240A  980721     MOV W1, [W14+4]
00240C  984762     MOV.B W2, [W14+6]
176:                   uint8_t cnt;
177:                   for (cnt = 0; cnt < bytes; cnt++)
00240E  EB4000     CLR.B W0
002410  784F00     MOV.B W0, [W14]
002412  37000D     BRA 0x242E
00242C  E84F1E     INC.B [W14], [W14]
00242E  90406E     MOV.B [W14+6], W0
002430  78409E     MOV.B [W14], W1
002432  50CF80     SUB.B W1, W0, [W15]
002434  39FFEF     BRA NC, 0x2414
178:                       if (*(str1 + cnt) != *(str2 + cnt))
002414  FB801E     ZE [W14], W0
002416  90009E     MOV [W14+2], W1
002418  408000     ADD W1, W0, W0
00241A  784090     MOV.B [W0], W1
00241C  FB801E     ZE [W14], W0
00241E  90012E     MOV [W14+4], W2
002420  410000     ADD W2, W0, W0
002422  784010     MOV.B [W0], W0
002424  50CF80     SUB.B W1, W0, [W15]
002426  320002     BRA Z, 0x242C
179:                           return false;
002428  EB4000     CLR.B W0
00242A  370006     BRA 0x2438
180:                   return true;
002436  B3C010     MOV.B #0x1, W0
181:               }
002438  FA8000     ULNK
00243A  060000     RETURN
182:               
183:               //快速去余数
184:               
185:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
00243C  FA0004     LNK #0x4
00243E  780F00     MOV W0, [W14]
002440  984721     MOV.B W1, [W14+2]
186:                   return num - ((num >> mod_num) << mod_num);
002442  78001E     MOV [W14], W0
002444  784080     MOV.B W0, W1
002446  90402E     MOV.B [W14+2], W0
002448  FB8000     ZE W0, W0
00244A  78011E     MOV [W14], W2
00244C  DE1100     LSR W2, W0, W2
00244E  90402E     MOV.B [W14+2], W0
002450  FB8000     ZE W0, W0
002452  DD1000     SL W2, W0, W0
002454  784000     MOV.B W0, W0
002456  50C000     SUB.B W1, W0, W0
187:               }
002458  FA8000     ULNK
00245A  060000     RETURN
188:               
189:               //16位整数转化为字符串
190:               
191:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
00245C  FA0010     LNK #0x10
00245E  980750     MOV W0, [W14+10]
002460  980761     MOV W1, [W14+12]
192:                   uint8_t buf[6];
193:                   uint8_t cnt = 0, len;
002462  EB4000     CLR.B W0
002464  784F00     MOV.B W0, [W14]
194:                   uint16_t tmp = i;
002466  90005E     MOV [W14+10], W0
002468  980710     MOV W0, [W14+2]
195:                   if (!tmp) {
00246A  90001E     MOV [W14+2], W0
00246C  E00000     CP0 W0
00246E  3A001E     BRA NZ, 0x24AC
196:                       *str = '0';
002470  90006E     MOV [W14+12], W0
002472  B3C301     MOV.B #0x30, W1
002474  784801     MOV.B W1, [W0]
197:                       *(str + 1) = '\0';
002476  90006E     MOV [W14+12], W0
002478  E80000     INC W0, W0
00247A  EB4080     CLR.B W1
00247C  784801     MOV.B W1, [W0]
198:                       len = 1;
00247E  B3C010     MOV.B #0x1, W0
002480  984710     MOV.B W0, [W14+1]
002482  370034     BRA 0x24EC
199:                   } else {
200:                       while (tmp) {
0024AC  90001E     MOV [W14+2], W0
0024AE  E00000     CP0 W0
0024B0  3AFFE9     BRA NZ, 0x2484
201:                           *(buf + cnt++) = tmp % 10 + 0x30;
002484  FB801E     ZE [W14], W0
002486  4700E4     ADD W14, #0x4, W1
002488  408080     ADD W1, W0, W1
00248A  980771     MOV W1, [W14+14]
00248C  90011E     MOV [W14+2], W2
00248E  2000A1     MOV #0xA, W1
002490  780181     MOV W1, W3
002492  090011     REPEAT #0x11
002494  D88103     DIV.UW W2, W3
002496  784081     MOV.B W1, W1
002498  B04301     ADD.B #0x30, W1
00249A  90007E     MOV [W14+14], W0
00249C  784801     MOV.B W1, [W0]
00249E  E84F1E     INC.B [W14], [W14]
202:                           tmp /= 10;
0024A0  90009E     MOV [W14+2], W1
0024A2  2000A0     MOV #0xA, W0
0024A4  780100     MOV W0, W2
0024A6  090011     REPEAT #0x11
0024A8  D88082     DIV.UW W1, W2
0024AA  980710     MOV W0, [W14+2]
203:                       }
204:                       len = cnt;
0024B2  78419E     MOV.B [W14], W3
0024B4  984713     MOV.B W3, [W14+1]
205:                       cnt += 1;
0024B6  E84F1E     INC.B [W14], [W14]
206:                       while (cnt--) {
0024B8  37000C     BRA 0x24D2
0024D2  FB801E     ZE [W14], W0
0024D4  EA0000     NEG W0, W0
0024D6  DE004F     LSR W0, #15, W0
0024D8  784000     MOV.B W0, W0
0024DA  E94F1E     DEC.B [W14], [W14]
0024DC  E00400     CP0.B W0
0024DE  3AFFED     BRA NZ, 0x24BA
207:                           *(str + cnt - 1) = *(buf + len - cnt);
0024BA  FB801E     ZE [W14], W0
0024BC  E90000     DEC W0, W0
0024BE  9000EE     MOV [W14+12], W1
0024C0  408000     ADD W1, W0, W0
0024C2  90409E     MOV.B [W14+1], W1
0024C4  FB8101     ZE W1, W2
0024C6  FB809E     ZE [W14], W1
0024C8  510081     SUB W2, W1, W1
0024CA  470164     ADD W14, #0x4, W2
0024CC  410081     ADD W2, W1, W1
0024CE  784091     MOV.B [W1], W1
0024D0  784801     MOV.B W1, [W0]
208:                       }
209:                       *(str + len) = '\0';
0024E0  90401E     MOV.B [W14+1], W0
0024E2  FB8000     ZE W0, W0
0024E4  9000EE     MOV [W14+12], W1
0024E6  408000     ADD W1, W0, W0
0024E8  EB4080     CLR.B W1
0024EA  784801     MOV.B W1, [W0]
210:                   }
211:                   return len;
0024EC  90401E     MOV.B [W14+1], W0
212:               }
0024EE  FA8000     ULNK
213:               
214:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/CheckData.c  --------------------------------
1:                 //#include "user.h"
2:                 #include "CheckData.h"
3:                 
4:                 ///****************************************************************************
5:                 //名称: CRC16()
6:                 //说明: CRC16校验程序
7:                 //参数: *CRC_Buf:数据地址
8:                 //      CRC_Leni:数据长度
9:                 //返回: CRC校验值
10:                // *****************************************************************************/
11:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, const uint8_t CRC_Leni) {
12:                //    uint16_t i, j;
13:                //    uint16_t CRC_Sumx;
14:                //
15:                //    CRC_Sumx = 0xFFFF;
16:                //    for (i = 0; i < CRC_Leni; i++) {
17:                //        CRC_Sumx ^= *(CRC_Buf + i); //异或
18:                //        for (j = 0; j < 8; j++) {
19:                //            if (CRC_Sumx & 0x01) {
20:                //                CRC_Sumx >>= 1;
21:                //                CRC_Sumx ^= 0xA001;
22:                //            } else {
23:                //                CRC_Sumx >>= 1;
24:                //            }
25:                //        }
26:                //    }
27:                //    return (CRC_Sumx);
28:                //}
29:                
30:                /*************************************
31:                Function: CheckIsRight  
32:                Description: 判断接受dat，根据fp校验，返回数据正确性
33:                Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
34:                Output: 1：校验正确  0：校验错误
35:                 *************************************/
36:                bool CRCIsRight(uint8_t * CRC_Buf, const uint8_t CRC_Leni, const uint8_t* CHC_Dat) {
00336A  FA000C     LNK #0xC
00336C  980730     MOV W0, [W14+6]
00336E  984F01     MOV.B W1, [W14+8]
003370  980752     MOV W2, [W14+10]
37:                    uint16_t i, j;
38:                    uint16_t CRC_Sumx;
39:                
40:                    CRC_Sumx = 0xFFFF;
003372  EB8000     SETM W0
003374  980720     MOV W0, [W14+4]
41:                    for (i = 0; i < CRC_Leni; i++) {
003376  EB0000     CLR W0
003378  780F00     MOV W0, [W14]
00337A  370021     BRA 0x33BE
0033BC  E80F1E     INC [W14], [W14]
0033BE  90480E     MOV.B [W14+8], W0
0033C0  FB8000     ZE W0, W0
0033C2  500F9E     SUB W0, [W14], [W15]
0033C4  3EFFDB     BRA GTU, 0x337C
42:                        CRC_Sumx ^= *(CRC_Buf + i); //异或
00337C  90003E     MOV [W14+6], W0
00337E  40001E     ADD W0, [W14], W0
003380  784010     MOV.B [W0], W0
003382  FB8000     ZE W0, W0
003384  9000AE     MOV [W14+4], W1
003386  688000     XOR W1, W0, W0
003388  980720     MOV W0, [W14+4]
43:                        for (j = 0; j < 8; j++) {
00338A  EB0000     CLR W0
00338C  980710     MOV W0, [W14+2]
00338E  370013     BRA 0x33B6
0033B0  90001E     MOV [W14+2], W0
0033B2  E80000     INC W0, W0
0033B4  980710     MOV W0, [W14+2]
0033B6  90001E     MOV [W14+2], W0
0033B8  500FE7     SUB W0, #0x7, [W15]
0033BA  36FFEA     BRA LEU, 0x3390
44:                            if (CRC_Sumx & 0x01) {
003390  90002E     MOV [W14+4], W0
003392  600061     AND W0, #0x1, W0
003394  784000     MOV.B W0, W0
003396  E00400     CP0.B W0
003398  320008     BRA Z, 0x33AA
45:                                CRC_Sumx >>= 1;
00339A  90002E     MOV [W14+4], W0
00339C  D10000     LSR W0, W0
00339E  980720     MOV W0, [W14+4]
46:                                CRC_Sumx ^= 0xA001;
0033A0  9000AE     MOV [W14+4], W1
0033A2  2A0010     MOV #0xA001, W0
0033A4  688000     XOR W1, W0, W0
0033A6  980720     MOV W0, [W14+4]
0033A8  370003     BRA 0x33B0
47:                            } else {
48:                                CRC_Sumx >>= 1;
0033AA  90002E     MOV [W14+4], W0
0033AC  D10000     LSR W0, W0
0033AE  980720     MOV W0, [W14+4]
49:                            }
50:                        }
51:                    } //CRC校验
52:                    return (CRC_Sumx == (*CHC_Dat + (*(CHC_Dat + 1) << 8))); //校验数据+CRC
0033C6  90005E     MOV [W14+10], W0
0033C8  784010     MOV.B [W0], W0
0033CA  FB8080     ZE W0, W1
0033CC  90005E     MOV [W14+10], W0
0033CE  E80000     INC W0, W0
0033D0  784010     MOV.B [W0], W0
0033D2  FB8000     ZE W0, W0
0033D4  DD0048     SL W0, #8, W0
0033D6  408000     ADD W1, W0, W0
0033D8  780080     MOV W0, W1
0033DA  90002E     MOV [W14+4], W0
0033DC  688000     XOR W1, W0, W0
0033DE  A7F000     BTSC W0, #15
0033E0  EA0000     NEG W0, W0
0033E2  E90000     DEC W0, W0
0033E4  DE004F     LSR W0, #15, W0
0033E6  784000     MOV.B W0, W0
53:                }
0033E8  FA8000     ULNK
0033EA  060000     RETURN
54:                
55:                ///*************************************
56:                //Function: Sum_Check 
57:                //Description: 计算和校验的数值，
58:                //Input: frame：数据，bytes：字节数 
59:                //Output: 和校验结果值
60:                // *************************************/
61:                //uint16_t Sum_Check(uint8_t *frame, const uint8_t bytes) {
62:                //    uint16_t cksum = 0;
63:                //    uint16_t cnt = bytes;
64:                //    while (cnt > 0) {
65:                //        cksum += *frame++;
66:                //        cnt--;
67:                //    }
68:                //    return cksum;
69:                //}
70:                
71:                /*************************************
72:                Function: Sum_Check256
73:                Description: 计算和校验的数值，
74:                Input: frame：数据，bytes：字节数 
75:                Output: 和校验结果值
76:                 *************************************/
77:                bool SumCheckIsRight(uint8_t *frame, const uint16_t bytes, const uint8_t CheckSum) {
0033EC  FA000C     LNK #0xC
0033EE  980730     MOV W0, [W14+6]
0033F0  980741     MOV W1, [W14+8]
0033F2  984F22     MOV.B W2, [W14+10]
78:                    uint32_t ckSum = 0; //避免数据溢出
0033F4  B80060     MUL.UU W0, #0, W0
0033F6  BE8F00     MOV.D W0, [W14]
79:                    uint16_t cnt;
80:                
81:                    for (cnt = 0; cnt < bytes; cnt++)
0033F8  EB0000     CLR W0
0033FA  980720     MOV W0, [W14+4]
0033FC  37000C     BRA 0x3416
003410  90002E     MOV [W14+4], W0
003412  E80000     INC W0, W0
003414  980720     MOV W0, [W14+4]
003416  9000AE     MOV [W14+4], W1
003418  90004E     MOV [W14+8], W0
00341A  508F80     SUB W1, W0, [W15]
00341C  39FFF0     BRA NC, 0x33FE
82:                        ckSum += *frame++;
0033FE  90003E     MOV [W14+6], W0
003400  784010     MOV.B [W0], W0
003402  FB8000     ZE W0, W0
003404  EB0080     CLR W1
003406  400F1E     ADD W0, [W14], [W14]
003408  48975E     ADDC W1, [++W14], [W14--]
00340A  90003E     MOV [W14+6], W0
00340C  E80000     INC W0, W0
00340E  980730     MOV W0, [W14+6]
83:                
84:                    return (CheckSum == (ckSum - ((ckSum >> 8) << 8)));
00341E  90482E     MOV.B [W14+10], W0
003420  FB8200     ZE W0, W4
003422  EB0280     CLR W5
003424  200FF0     MOV #0xFF, W0
003426  200001     MOV #0x0, W1
003428  BE011E     MOV.D [W14], W2
00342A  780302     MOV W2, W6
00342C  780103     MOV W3, W2
00342E  780180     MOV W0, W3
003430  780001     MOV W1, W0
003432  630303     AND W6, W3, W6
003434  610000     AND W2, W0, W0
003436  EB0080     CLR W1
003438  DD00C0     SL W0, #0, W1
00343A  200000     MOV #0x0, W0
00343C  BE0100     MOV.D W0, W2
00343E  B83061     MUL.UU W6, #1, W0
003440  710100     IOR W2, W0, W2
003442  718181     IOR W3, W1, W3
003444  6A0002     XOR W4, W2, W0
003446  6A8083     XOR W5, W3, W1
003448  708000     IOR W1, W0, W0
00344A  A7F000     BTSC W0, #15
00344C  EA0000     NEG W0, W0
00344E  E90000     DEC W0, W0
003450  DE004F     LSR W0, #15, W0
003452  784000     MOV.B W0, W0
85:                }
003454  FA8000     ULNK
86:                
87:                
88:                
89:                //bool CheckSrting(uint8_t*dat1, uint8_t*dat2, const uint8_t num) {
90:                //    uint8_t cnt;
91:                //    for (cnt = 0; cnt < num; cnt++) {//判断EID
92:                //        if (*(dat1 + cnt) != *(dat2 + cnt)) {
93:                //            return false;
94:                //        }
95:                //    }
96:                //    return true;
97:                //}
98:                
99:                ///*************************************
100:               //Function: MD5encrypt  
101:               //Description: 
102:               //Input: 
103:               //Output:
104:               //*************************************/
105:               //void MD5encrypt(uint8_t* input,uint8_t *output)
106:               //{
107:               //    
108:               //}
109:               
110:               
111:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/User/CAT24C512.c  --------------------------------
1:                 #include "CAT24C512.h"
2:                 
3:                 uint16_t CAT_OperatID, CAT_StartID;
4:                 //CAT24Arg CAT24Argbits;
5:                 static void CAT24C512_ReadADD(void);
6:                 static void CAT24C512_WriteADD(uint8_t mode);
7:                 
8:                 void CAT24C512_Init(void) {
002E2A  FA0000     LNK #0x0
9:                     I2C_Init(); //初始化i2c,用于获取时钟和存储数据D
002E2C  070512     RCALL I2C_Init
10:                    TRISBbits.TRISB12 = 0; //WP引脚设置为输出    
002E2E  A982C9     BCLR 0x2C9, #4
11:                    //    CAT_WP = 0; //开启写保护
12:                    //    CAT24Argbits.ID = 0; //初始化结构体
13:                    //    CAT24Argbits.data = NULL;
14:                    //#
15:                    //        CAT_OperatID = 0xaaaa;
16:                    //        CAT_StartID = 0xFFFF;
17:                    //    CAT24C512_WriteADD(0); //刷新上次操作数据
18:                    CAT24C512_ReadADD();
002E30  07007F     RCALL _CAT24C512_ReadADD
19:                }
002E32  FA8000     ULNK
002E34  060000     RETURN
20:                
21:                void CAT24C512_Read(uint16_t id, uint8_t *tmp) {//读取一组数据
002E36  FA0006     LNK #0x6
002E38  980710     MOV W0, [W14+2]
002E3A  980721     MOV W1, [W14+4]
22:                    uint8_t cnt; //调试cat24c512 地址0xA8写操作地址     
23:                    if (CAT_StartID == CAT_OperatID)//提示错误
002E3C  804201     MOV CAT_StartID, W1
002E3E  8041F0     MOV CAT_OperatID, W0
002E40  508F80     SUB W1, W0, [W15]
002E42  32003C     BRA Z, 0x2EBC
24:                        return;
002EBC  000000     NOP
25:                    CAT_WP_LAT = 0; //写保护
002E44  A982CD     BCLR 0x2CD, #4
26:                    for (cnt = 0; cnt < BufferSize; cnt++) {
002E46  EB4000     CLR.B W0
002E48  784F00     MOV.B W0, [W14]
002E4A  370029     BRA 0x2E9E
002E9C  E84F1E     INC.B [W14], [W14]
002E9E  78401E     MOV.B [W14], W0
002EA0  504FEB     SUB.B W0, #0xB, [W15]
002EA2  36FFD4     BRA LEU, 0x2E4C
27:                        i2c_buf.operatcode = CAT_ADD;
002E4C  209320     MOV #0x932, W0
002E4E  B3CA81     MOV.B #0xA8, W1
002E50  784801     MOV.B W1, [W0]
28:                        i2c_buf.address = id * BufferSize + cnt;
002E52  90001E     MOV [W14+2], W0
002E54  B9006C     MUL.SU W0, #12, W0
002E56  780080     MOV W0, W1
002E58  FB801E     ZE [W14], W0
002E5A  408000     ADD W1, W0, W0
002E5C  8849A0     MOV W0, 0x934
29:                        i2c_buf.length = 1; //sizeof (tmp) / sizeof (uint8_t) - 1;
002E5E  209360     MOV #0x936, W0
002E60  B3C011     MOV.B #0x1, W1
002E62  784801     MOV.B W1, [W0]
30:                        i2c_buf.pbuffer = tmp + cnt;
002E64  FB801E     ZE [W14], W0
002E66  9000AE     MOV [W14+4], W1
002E68  408000     ADD W1, W0, W0
002E6A  8849C0     MOV W0, 0x938
31:                        i2c_buf.flag.F_IsSelectiveMode = 1;
002E6C  8049D0     MOV 0x93A, W0
002E6E  A00000     BSET W0, #0
002E70  8849D0     MOV W0, 0x93A
32:                        i2c_buf.flag.F_WriteOrRead = 1;
002E72  8049D0     MOV 0x93A, W0
002E74  A02000     BSET W0, #2
002E76  8849D0     MOV W0, 0x93A
33:                        i2c_buf.flag.F_Is16bitsDevice = 1;
002E78  8049D0     MOV 0x93A, W0
002E7A  A01000     BSET W0, #1
002E7C  8849D0     MOV W0, 0x93A
34:                        i2c1_state = S_MASTER_IDLE;
002E7E  EF6842     CLR.B i2c1_state
35:                        Delay10ms(1); //延时等待数据通讯完成
002E80  200010     MOV #0x1, W0
002E82  07FA46     RCALL Delay10ms
36:                        IFS1bits.MI2C1IF = 1; //开始I2C
002E84  A82086     BSET IFS1, #1
37:                        //等待数据发送完成或是数据异常
38:                        //发送数据给上位机
39:                        while (i2c1_state != S_MASTER_Finish) //等待发送完成，避免重复发送数据
002E86  370005     BRA 0x2E92
002E92  BFC842     MOV.B i2c1_state, WREG
002E94  504FED     SUB.B W0, #0xD, [W15]
002E96  3AFFF8     BRA NZ, 0x2E88
40:                            if (i2c1_state == S_MASTER_Fail) {
002E88  BFC842     MOV.B i2c1_state, WREG
002E8A  504FEE     SUB.B W0, #0xE, [W15]
002E8C  3A0002     BRA NZ, 0x2E92
41:                                CAT_WP_LAT = 1; //保护
002E8E  A882CD     BSET 0x2CD, #4
42:                                return; //提示错误信息
002E90  370016     BRA 0x2EBE
43:                            }
44:                        Delay1ms(1);
002E98  200010     MOV #0x1, W0
002E9A  07FA22     RCALL Delay1ms
45:                    }
46:                    CAT_WP_LAT = 1; //保护
002EA4  A882CD     BSET 0x2CD, #4
47:                    CAT_StartID += 1;
002EA6  804200     MOV CAT_StartID, W0
002EA8  E80000     INC W0, W0
002EAA  884200     MOV W0, CAT_StartID
48:                    CAT_StartID = CAT_StartID % CAT_NUMS;
002EAC  804201     MOV CAT_StartID, W1
002EAE  215550     MOV #0x1555, W0
002EB0  780100     MOV W0, W2
002EB2  090011     REPEAT #0x11
002EB4  D88082     DIV.UW W1, W2
002EB6  FD0080     EXCH W0, W1
002EB8  884200     MOV W0, CAT_StartID
002EBA  370001     BRA 0x2EBE
49:                }
002EBE  FA8000     ULNK
002EC0  060000     RETURN
50:                
51:                void CAT24C512_Write(uint8_t *tmp) {//页写 
002EC2  FA0002     LNK #0x2
002EC4  780F00     MOV W0, [W14]
52:                    CAT_WP_LAT = 0; //写保护
002EC6  A982CD     BCLR 0x2CD, #4
53:                    i2c_buf.operatcode = CAT_ADD;
002EC8  209320     MOV #0x932, W0
002ECA  B3CA81     MOV.B #0xA8, W1
002ECC  784801     MOV.B W1, [W0]
54:                    i2c_buf.address = CAT_OperatID*BufferSize;
002ECE  8041F0     MOV CAT_OperatID, W0
002ED0  B9006C     MUL.SU W0, #12, W0
002ED2  780000     MOV W0, W0
002ED4  8849A0     MOV W0, 0x934
55:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
002ED6  209360     MOV #0x936, W0
002ED8  B3C0C1     MOV.B #0xC, W1
002EDA  784801     MOV.B W1, [W0]
56:                    i2c_buf.pbuffer = tmp;
002EDC  78009E     MOV [W14], W1
002EDE  8849C1     MOV W1, 0x938
57:                    i2c_buf.flag.F_IsSelectiveMode = 1;
002EE0  8049D0     MOV 0x93A, W0
002EE2  A00000     BSET W0, #0
002EE4  8849D0     MOV W0, 0x93A
58:                    i2c_buf.flag.F_WriteOrRead = 0;
002EE6  8049D0     MOV 0x93A, W0
002EE8  A12000     BCLR W0, #2
002EEA  8849D0     MOV W0, 0x93A
59:                    i2c_buf.flag.F_Is16bitsDevice = 1;
002EEC  8049D0     MOV 0x93A, W0
002EEE  A01000     BSET W0, #1
002EF0  8849D0     MOV W0, 0x93A
60:                    i2c1_state = S_MASTER_IDLE;
002EF2  EF6842     CLR.B i2c1_state
61:                    IFS1bits.MI2C1IF = 1; //开始I2C通讯
002EF4  A82086     BSET IFS1, #1
62:                    //    I2C1CONbits.SEN =1;
63:                    Delay10ms(1); //延时等待数据通讯完成
002EF6  200010     MOV #0x1, W0
002EF8  07FA0B     RCALL Delay10ms
64:                    while (i2c1_state != S_MASTER_Finish) {//等待发送完成，避免重复发送数据
002EFA  BFC842     MOV.B i2c1_state, WREG
002EFC  504FED     SUB.B W0, #0xD, [W15]
002EFE  320009     BRA Z, 0x2F12
65:                        if (i2c1_state == S_MASTER_Fail) {
002F00  BFC842     MOV.B i2c1_state, WREG
002F02  504FEE     SUB.B W0, #0xE, [W15]
002F04  3A0002     BRA NZ, 0x2F0A
66:                            CAT_WP_LAT = 1; //保护
002F06  A882CD     BSET 0x2CD, #4
67:                            return; //提示错误信息
002F08  370011     BRA 0x2F2C
68:                        }
69:                        Delay10ms(1); //延时等待数据通讯完成
002F0A  200010     MOV #0x1, W0
002F0C  07FA01     RCALL Delay10ms
70:                        CAT_WP_LAT = 1; //保护
002F0E  A882CD     BSET 0x2CD, #4
71:                        return;//提示错误信息
002F10  37000D     BRA 0x2F2C
72:                    }
73:                    //等待数据发送完成或是数据异常
74:                    Delay10ms(1);
002F12  200010     MOV #0x1, W0
002F14  07F9FD     RCALL Delay10ms
75:                    CAT_WP_LAT = 1; //保护
002F16  A882CD     BSET 0x2CD, #4
76:                    CAT_OperatID += 1;
002F18  8041F0     MOV CAT_OperatID, W0
002F1A  E80000     INC W0, W0
002F1C  8841F0     MOV W0, CAT_OperatID
77:                    CAT_OperatID = CAT_OperatID % CAT_NUMS; //需要添加防止溢出的处理
002F1E  8041F1     MOV CAT_OperatID, W1
002F20  215550     MOV #0x1555, W0
002F22  780100     MOV W0, W2
002F24  090011     REPEAT #0x11
002F26  D88082     DIV.UW W1, W2
002F28  FD0080     EXCH W0, W1
002F2A  8841F0     MOV W0, CAT_OperatID
78:                }
002F2C  FA8000     ULNK
002F2E  060000     RETURN
79:                
80:                static void CAT24C512_ReadADD(void) {
002F30  FA0006     LNK #0x6
81:                    uint8_t tmp[4] = {0, 0};
002F32  B80060     MUL.UU W0, #0, W0
002F34  980710     MOV W0, [W14+2]
002F36  980721     MOV W1, [W14+4]
82:                    uint8_t cnt = 0, cnt1 = 0;
002F38  EB4000     CLR.B W0
002F3A  784F00     MOV.B W0, [W14]
002F3C  EB4000     CLR.B W0
002F3E  984710     MOV.B W0, [W14+1]
83:                
84:                    CAT_WP_LAT = 0; //写保护
002F40  A982CD     BCLR 0x2CD, #4
85:                    for (cnt = 0; cnt < 4; cnt++) {//选择读取        
002F42  EB4000     CLR.B W0
002F44  784F00     MOV.B W0, [W14]
002F46  370029     BRA 0x2F9A
002F98  E84F1E     INC.B [W14], [W14]
002F9A  78401E     MOV.B [W14], W0
002F9C  504FE3     SUB.B W0, #0x3, [W15]
002F9E  36FFD4     BRA LEU, 0x2F48
86:                
87:                        i2c_buf.operatcode = CAT_ADD;
002F48  209320     MOV #0x932, W0
002F4A  B3CA81     MOV.B #0xA8, W1
002F4C  784801     MOV.B W1, [W0]
88:                        i2c_buf.address = CAT_NOW_ADD + cnt;
002F4E  FB801E     ZE [W14], W0
002F50  500064     SUB W0, #0x4, W0
002F52  8849A0     MOV W0, 0x934
89:                        i2c_buf.length = 1; //sizeof (tmp) / sizeof (uint8_t) - 1;
002F54  209360     MOV #0x936, W0
002F56  B3C011     MOV.B #0x1, W1
002F58  784801     MOV.B W1, [W0]
90:                        i2c_buf.pbuffer = tmp + cnt;
002F5A  FB801E     ZE [W14], W0
002F5C  E8808E     INC2 W14, W1
002F5E  408000     ADD W1, W0, W0
002F60  8849C0     MOV W0, 0x938
91:                        i2c_buf.flag.F_IsSelectiveMode = 1;
002F62  8049D0     MOV 0x93A, W0
002F64  A00000     BSET W0, #0
002F66  8849D0     MOV W0, 0x93A
92:                        i2c_buf.flag.F_WriteOrRead = 1;
002F68  8049D0     MOV 0x93A, W0
002F6A  A02000     BSET W0, #2
002F6C  8849D0     MOV W0, 0x93A
93:                        i2c_buf.flag.F_Is16bitsDevice = 1;
002F6E  8049D0     MOV 0x93A, W0
002F70  A01000     BSET W0, #1
002F72  8849D0     MOV W0, 0x93A
94:                        i2c1_state = S_MASTER_IDLE;
002F74  EF6842     CLR.B i2c1_state
95:                        Delay10ms(1); //延时等待数据通讯完成
002F76  200010     MOV #0x1, W0
002F78  07F9CB     RCALL Delay10ms
96:                        IFS1bits.MI2C1IF = 1; //开始I2C通讯
002F7A  A82086     BSET IFS1, #1
97:                        while (i2c1_state != S_MASTER_Finish) {//等待发送完成，避免重复发送数据
002F7C  BFC842     MOV.B i2c1_state, WREG
002F7E  504FED     SUB.B W0, #0xD, [W15]
002F80  320009     BRA Z, 0x2F94
98:                            if (i2c1_state == S_MASTER_Fail) {
002F82  BFC842     MOV.B i2c1_state, WREG
002F84  504FEE     SUB.B W0, #0xE, [W15]
002F86  3A0002     BRA NZ, 0x2F8C
99:                                CAT_WP_LAT = 1; //保护
002F88  A882CD     BSET 0x2CD, #4
100:                               return; //提示错误信息
002F8A  370019     BRA 0x2FBE
101:                           }
102:                           Delay10ms(1); //延时等待数据通讯完成
002F8C  200010     MOV #0x1, W0
002F8E  07F9C0     RCALL Delay10ms
103:                           CAT_WP_LAT = 1; //保护
002F90  A882CD     BSET 0x2CD, #4
104:                           return;
002F92  370015     BRA 0x2FBE
105:                       }
106:                       //        i2c1_state = S_MASTER_IDLE;
107:                       //等待数据发送完成或是数据异常        
108:                       Delay1ms(1);
002F94  200010     MOV #0x1, W0
002F96  07F9A4     RCALL Delay1ms
109:                   }
110:                   CAT_WP_LAT = 1; //保护
002FA0  A882CD     BSET 0x2CD, #4
111:                   CAT_StartID = ((uint16_t) tmp[0] << 8) + tmp[1]; //刷新ID地址  
002FA2  90402E     MOV.B [W14+2], W0
002FA4  FB8000     ZE W0, W0
002FA6  DD00C8     SL W0, #8, W1
002FA8  90403E     MOV.B [W14+3], W0
002FAA  FB8000     ZE W0, W0
002FAC  408000     ADD W1, W0, W0
002FAE  884200     MOV W0, CAT_StartID
112:                   CAT_OperatID = ((uint16_t) tmp[2] << 8) + tmp[3]; //刷新ID地址  
002FB0  90404E     MOV.B [W14+4], W0
002FB2  FB8000     ZE W0, W0
002FB4  DD00C8     SL W0, #8, W1
002FB6  90405E     MOV.B [W14+5], W0
002FB8  FB8000     ZE W0, W0
002FBA  408000     ADD W1, W0, W0
002FBC  8841F0     MOV W0, CAT_OperatID
113:               }
002FBE  FA8000     ULNK
002FC0  060000     RETURN
114:               
115:               static void CAT24C512_WriteADD(uint8_t mode) {
002FC2  FA0006     LNK #0x6
002FC4  984740     MOV.B W0, [W14+4]
116:                   uint8_t tmp[4] = {0, 0};
002FC6  B80060     MUL.UU W0, #0, W0
002FC8  BE8F00     MOV.D W0, [W14]
117:                   //    CAT_StartID = ((uint16_t) tmp[2] << 8) + tmp[3]; //刷新ID地址 
118:                   tmp[0] = (CAT_StartID >> 8)& 0x00ff; //刷新ID地址  
002FCA  804200     MOV CAT_StartID, W0
002FCC  DE0048     LSR W0, #8, W0
002FCE  784000     MOV.B W0, W0
002FD0  784F00     MOV.B W0, [W14]
119:                   tmp[1] = CAT_StartID & 0x00ff;
002FD2  804200     MOV CAT_StartID, W0
002FD4  784000     MOV.B W0, W0
002FD6  984710     MOV.B W0, [W14+1]
120:                   tmp[2] = (CAT_OperatID >> 8)& 0x00ff; //刷新ID地址  
002FD8  8041F0     MOV CAT_OperatID, W0
002FDA  DE0048     LSR W0, #8, W0
002FDC  784000     MOV.B W0, W0
002FDE  984720     MOV.B W0, [W14+2]
121:                   tmp[3] = CAT_OperatID & 0x00ff;
002FE0  8041F0     MOV CAT_OperatID, W0
002FE2  784000     MOV.B W0, W0
002FE4  984730     MOV.B W0, [W14+3]
122:               
123:                   CAT_WP_LAT = 0; //写保护
002FE6  A982CD     BCLR 0x2CD, #4
124:                   i2c_buf.operatcode = CAT_ADD;
002FE8  209320     MOV #0x932, W0
002FEA  B3CA81     MOV.B #0xA8, W1
002FEC  784801     MOV.B W1, [W0]
125:                   if (mode == CAT_START_READ) {//表示开始读取地址写到EEROM中
002FEE  90404E     MOV.B [W14+4], W0
002FF0  504FE2     SUB.B W0, #0x2, [W15]
002FF2  3A0007     BRA NZ, 0x3002
126:                       i2c_buf.address = CAT_NOW_ADD;
002FF4  2FFFC0     MOV #0xFFFC, W0
002FF6  8849A0     MOV W0, 0x934
127:                       i2c_buf.length = 2; //
002FF8  209360     MOV #0x936, W0
002FFA  B3C021     MOV.B #0x2, W1
002FFC  784801     MOV.B W1, [W0]
128:                       i2c_buf.pbuffer = tmp;
002FFE  8849CE     MOV W14, 0x938
003000  370011     BRA 0x3024
129:                   } else if (mode == CAT_START_WRITE) {//表示数据写入地址写到EEROM中
003002  90404E     MOV.B [W14+4], W0
003004  504FE3     SUB.B W0, #0x3, [W15]
003006  3A0008     BRA NZ, 0x3018
130:                       i2c_buf.address = CAT_NOW_ADD + 2;
003008  2FFFE0     MOV #0xFFFE, W0
00300A  8849A0     MOV W0, 0x934
131:                       i2c_buf.length = 2; //        
00300C  209360     MOV #0x936, W0
00300E  B3C021     MOV.B #0x2, W1
003010  784801     MOV.B W1, [W0]
132:                       i2c_buf.pbuffer = tmp + 2;
003012  E8800E     INC2 W14, W0
003014  8849C0     MOV W0, 0x938
003016  370006     BRA 0x3024
133:                   } else {
134:                       i2c_buf.address = CAT_NOW_ADD; //更新全部
003018  2FFFC0     MOV #0xFFFC, W0
00301A  8849A0     MOV W0, 0x934
135:                       i2c_buf.length = 4; //        
00301C  209360     MOV #0x936, W0
00301E  B3C041     MOV.B #0x4, W1
003020  784801     MOV.B W1, [W0]
136:                       i2c_buf.pbuffer = tmp;
003022  8849CE     MOV W14, 0x938
137:                   }
138:                   i2c_buf.flag.F_IsSelectiveMode = 1;
003024  8049D0     MOV 0x93A, W0
003026  A00000     BSET W0, #0
003028  8849D0     MOV W0, 0x93A
139:                   i2c_buf.flag.F_WriteOrRead = 0;
00302A  8049D0     MOV 0x93A, W0
00302C  A12000     BCLR W0, #2
00302E  8849D0     MOV W0, 0x93A
140:                   i2c_buf.flag.F_Is16bitsDevice = 1;
003030  8049D0     MOV 0x93A, W0
003032  A01000     BSET W0, #1
003034  8849D0     MOV W0, 0x93A
141:                   i2c1_state = S_MASTER_IDLE;
003036  EF6842     CLR.B i2c1_state
142:                   //    while (IFS1bits.MI2C1IF);
143:                   IFS1bits.MI2C1IF = 1; //开始I2C通讯
003038  A82086     BSET IFS1, #1
144:                   while (i2c1_state != S_MASTER_SEND_STOP) //等待发送完成，避免重复发送数据
00303A  370005     BRA 0x3046
003046  BFC842     MOV.B i2c1_state, WREG
003048  504FE6     SUB.B W0, #0x6, [W15]
00304A  3AFFF8     BRA NZ, 0x303C
145:                       if (i2c1_state == S_MASTER_Fail) {
00303C  BFC842     MOV.B i2c1_state, WREG
00303E  504FEE     SUB.B W0, #0xE, [W15]
003040  3A0002     BRA NZ, 0x3046
146:                           CAT_WP_LAT = 1; //保护
003042  A882CD     BSET 0x2CD, #4
147:                           return; //提示错误信息
003044  370006     BRA 0x3052
148:                       }
149:                   //等待数据发送完成或是数据异常
150:                   Delay1ms(1);
00304C  200010     MOV #0x1, W0
00304E  07F948     RCALL Delay1ms
151:                   CAT_WP_LAT = 1; //保护
003050  A882CD     BSET 0x2CD, #4
152:               }
003052  FA8000     ULNK
153:               
154:               //void Get
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                //#include "HL6528.h"
18:                //#include "E41.h"
19:                //#include "xc.h"
20:                
21:                void OSCILLATOR_Initialize(void) {
00361E  FA0000     LNK #0x0
22:                    // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
23:                    CLKDIV = 0x3200;
003620  232000     MOV #0x3200, W0
003622  883A20     MOV W0, CLKDIV
24:                
25:                    // Set the secondary oscillator    
26:                    OSCCONbits.SOSCEN = 1; //开启辅助振荡器
003624  A82742     BSET OSCCON, #1
27:                    //    __builtin_write_OSCCONL(0x02);
28:                    __builtin_write_OSCCONL(0x00); //2M
003626  EB0100     CLR W2
003628  200460     MOV #0x46, W0
00362A  200571     MOV #0x57, W1
00362C  207423     MOV #0x742, W3
00362E  784980     MOV.B W0, [W3]
003630  784981     MOV.B W1, [W3]
003632  784982     MOV.B W2, [W3]
29:                    //    OSCCONbits.OSWEN = 1;
30:                    //    OSC_Unlock_Sequence(); //切换时钟
31:                }
003634  FA8000     ULNK
003636  060000     RETURN
32:                
33:                /*
34:                 *********************************************************************************************************
35:                 *                                         BSP INITIALIZATION
36:                 *
37:                 * Description : This function should be called by your application code before you make use of any of the
38:                 *               functions found in this module.
39:                 *
40:                 * Arguments   : none
41:                 *********************************************************************************************************
42:                 */
43:                
44:                void BSP_Init(void) {
003638  FA0000     LNK #0x0
45:                    //    RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
46:                    //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
47:                    //    BSP_PLL_Init(); /* Initialize the PLL                                       */
48:                    //#endif
49:                    OSCILLATOR_Initialize(); //初始化时钟
00363A  07FFF1     RCALL OSCILLATOR_Initialize
50:                    LED_Init(); //初始化LED
00363C  07000B     RCALL LED_Init
51:                    WGC_Init(); //初始化WGC参数
00363E  07ED89     RCALL WGC_Init
52:                    RTC_Init(); //初始化实时时钟
003640  07F758     RCALL RTC_Init
53:                    PPSInit(); //选择设备
003642  070076     RCALL PPSInit
54:                    UART2_Init(); //初始化串口2，用于GPRS通讯hl6528
003644  07FF09     RCALL UART2_Init
55:                //    UART3_Init(); //初始化串口3，用于短程无线通讯433
56:                    RS485_Init(); //初始化串口1，用于485通讯上位机通讯
003646  07FD9A     RCALL RS485_Init
57:                    //    INT0_Init(); //外部中断初始化
58:                    //    E41_Init(); //初始化短程无线
59:                    HL6528_Init(); /*Initialize the HL6528*/
003648  07FA7F     RCALL HL6528_Init
60:                    ////#ifdef CLOSE_6528
61:                    //        HL6528_Close();//注意：开启 容易导致初始化失败
62:                    UART2_Close();
00364A  07FF23     RCALL UART2_Close
63:                    ////#endif
64:                    //    CAT24C512_Init(); //应用程序初始化
65:                    // no use   //    PCF8583_Init();//初始化PCF8583
66:                    //    //        Close6528Cop(); /*Close UART2 */
67:                    LCD_Init();
00364C  07F1C0     RCALL LCD_Init
68:                    TMR1_Initialize();
00364E  0700A0     RCALL TMR1_Initialize
69:                    //    TMR2_Initialize();
70:                }
003650  FA8000     ULNK
003652  060000     RETURN
71:                
72:                /*
73:                 *********************************************************************************************************
74:                 *                                      BSP_PLL_Init()
75:                 *
76:                 * Description : This function configures and enables the PLL with the external oscillator
77:                 *               selected as the input clock to the PLL.
78:                 *
79:                 * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
80:                 *               2) FIN is the PLL input clock frequency, defined in bsp.h as
81:                 *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
82:                 *                  oscillator on the Explorer 16 Evaluation Board.
83:                 *               3) M is the desired PLL multiplier
84:                 *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
85:                 *               5) N2 is the PLL output divider (Post-Divider)
86:                 *
87:                 * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
88:                 *                  The processor clock is (1/2) of the PLL output.
89:                 *                  Performance = 40 MIPS.
90:                 *********************************************************************************************************
91:                 */
92:                //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
93:                //
94:                //static void BSP_PLL_Init(void) {
95:                //    PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
96:                //    CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
97:                //}
98:                //#endif
99:                
100:               /*
101:                *********************************************************************************************************
102:                *                                      BSP_CPU_ClkFrq()
103:               
104:                * Description : This function determines the CPU clock frequency (Fcy)
105:                * Returns     : The CPU frequency in (HZ)
106:                *********************************************************************************************************
107:                */
108:               
109:               //CPU_INT32U BSP_CPU_ClkFrq(void) {
110:               //    CPU_INT08U Clk_Selected;
111:               //    CPU_INT16U FRC_Div;
112:               //    CPU_INT32U CPU_Clk_Frq;
113:               //
114:               //
115:               //#if defined (__dsPIC33E__) || defined (__dsPIC33F__)
116:               //    CPU_INT08U PLL_n1;
117:               //    CPU_INT08U PLL_n2;
118:               //    CPU_INT16U PLL_m;
119:               //    PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
120:               //    PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
121:               //    PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
122:               //    PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
123:               //#endif
124:               //
125:               //    FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
126:               //    FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
127:               //
128:               //    Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
129:               //
130:               //    switch (Clk_Selected) {
131:               //        case 0: /* Fast Oscillator (FRC) Selected                           */
132:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
133:               //            break;
134:               //
135:               //        case 1:
136:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
137:               //            CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
138:               //                    (FRC_Div * PLL_n1 * PLL_n2));
139:               //#else
140:               //            /* Fast Oscillator (FRC) with PLL Selected                  */
141:               //            CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
142:               //#endif
143:               //            break;
144:               //
145:               //        case 2: /* Primary External Oscillator Selected                     */
146:               //            CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
147:               //            break;
148:               //
149:               //        case 3:
150:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
151:               //            CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
152:               //                    (PLL_n1 * PLL_n2));
153:               //#else
154:               //            /* Primary External Oscillator with PLL Selected            */
155:               //            CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
156:               //#endif
157:               //            break;
158:               //
159:               //        case 4: /* Secondary Oscillator Selected (SOCS)                     */
160:               //            CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
161:               //            break;
162:               //
163:               //        case 5: /* Low Power Oscillator (LPOSC) Selected                    */
164:               //            CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
165:               //            break;
166:               //
167:               //        case 6:
168:               //            CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
169:               //            break;
170:               //
171:               //        case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
172:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
173:               //            break;
174:               //
175:               //        default:
176:               //            CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
177:               //            break;
178:               //    }
179:               //
180:               //    CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
181:               //
182:               //    return (CPU_Clk_Frq); /* Return the operating frequency                           */
183:               //}
184:               
185:               /*
186:                *********************************************************************************************************
187:                *                                     DISABLE ALL INTERRUPTS
188:                *
189:                * Description : This function disables all interrupts from the interrupt controller.
190:                *
191:                * Arguments   : none
192:                *********************************************************************************************************
193:                */
194:               
195:               //void BSP_IntDisAll(void) {
196:               //}
197:               
198:               /*
199:                *********************************************************************************************************
200:                *                                         LED I/O INITIALIZATION
201:                *
202:                * Description : This function initializes the I/O Pins used by the onboard LEDs
203:                *
204:                * Arguments   : none
205:                *
206:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
207:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
208:                *********************************************************************************************************
209:                */
210:               
211:               void LED_Init(void) {
003654  FA0000     LNK #0x0
212:                   TRISBbits.TRISB13 = 0;
003656  A9A2C9     BCLR 0x2C9, #5
213:               
214:                   LED_Off(); /* Shut off all LEDs                                        */
003658  070006     RCALL LED_Off
215:               }
00365A  FA8000     ULNK
00365C  060000     RETURN
216:               
217:               /*
218:                *********************************************************************************************************
219:                *                                             LED ON
220:                *
221:                * Description : This function is used to control any or all the LEDs on the board.
222:                *
223:                * Arguments   : led    is the number of the LED to control
224:                *                      0    indicates that you want ALL the LEDs to be ON
225:                *                      1    turns ON LED1
226:                *                      2    turns ON LED2
227:                *                      ...
228:                *                      8    turns ON LED8
229:                *
230:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
231:                *********************************************************************************************************
232:                */
233:               
234:               void LED_On(void) {
00365E  FA0000     LNK #0x0
235:                   PORTBbits.RB13 = 1;
003660  A8A2CB     BSET 0x2CB, #5
236:               }
003662  FA8000     ULNK
003664  060000     RETURN
237:               
238:               /*
239:                *********************************************************************************************************
240:                *                                             LED OFF
241:                *
242:                * Description : This function is used to control any or all the LEDs on the board.
243:                *
244:                * Arguments   : led    is the number of the LED to turn OFF
245:                *                      0    indicates that you want ALL the LEDs to be OFF
246:                *                      1    turns OFF LED1
247:                *                      2    turns OFF LED2
248:                *                      .
249:                *                      8    turns OFF LED8
250:                *
251:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
252:                *********************************************************************************************************
253:                */
254:               
255:               void LED_Off(void) {
003666  FA0000     LNK #0x0
256:                   LATBbits.LATB13 = 0;
003668  A9A2CD     BCLR 0x2CD, #5
257:               }
00366A  FA8000     ULNK
00366C  060000     RETURN
258:               
259:               /*
260:                *********************************************************************************************************
261:                *                                             LED TOGGLE
262:                *
263:                * Description : This function is used to toggle any or all the LEDs on the board.
264:                *
265:                * Arguments   : led    is the number of the LED to control
266:                *                      0    indicates that you want to toggle ALL the LEDs
267:                *                      1    toggles LED1
268:                *                      2    toggles LED2
269:                *                      .
270:                *                      8    toggles LED8
271:                *
272:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
273:                *********************************************************************************************************
274:                */
275:               
276:               void LED_Toggle(void) {
00366E  FA0000     LNK #0x0
277:                   LATBbits.LATB13 ^= 1;
003670  801660     MOV LATB, W0
003672  DE004D     LSR W0, #13, W0
003674  604061     AND.B W0, #0x1, W0
003676  A20400     BTG.B W0, #0
003678  604061     AND.B W0, #0x1, W0
00367A  FB8000     ZE W0, W0
00367C  600061     AND W0, #0x1, W0
00367E  DD004D     SL W0, #13, W0
003680  801661     MOV LATB, W1
003682  A1D001     BCLR W1, #13
003684  700001     IOR W0, W1, W0
003686  881660     MOV W0, LATB
278:               }
003688  FA8000     ULNK
00368A  060000     RETURN
279:               
280:               void LED_Toggle1(uint8_t time, uint8_t count) {
00368C  FA0004     LNK #0x4
00368E  984720     MOV.B W0, [W14+2]
003690  984731     MOV.B W1, [W14+3]
281:                   int8_t cnt;
282:                   for (cnt = 0; cnt < count; cnt++) {
003692  EB4000     CLR.B W0
003694  784F00     MOV.B W0, [W14]
003696  37000F     BRA 0x36B6
0036B4  E84F1E     INC.B [W14], [W14]
0036B6  FB009E     SE [W14], W1
0036B8  90403E     MOV.B [W14+3], W0
0036BA  FB8000     ZE W0, W0
0036BC  508F80     SUB W1, W0, [W15]
0036BE  35FFEC     BRA LT, 0x3698
283:                       LATBbits.LATB13 ^= 1;
003698  801660     MOV LATB, W0
00369A  DE004D     LSR W0, #13, W0
00369C  604061     AND.B W0, #0x1, W0
00369E  A20400     BTG.B W0, #0
0036A0  604061     AND.B W0, #0x1, W0
0036A2  FB8000     ZE W0, W0
0036A4  600061     AND W0, #0x1, W0
0036A6  DD004D     SL W0, #13, W0
0036A8  801661     MOV LATB, W1
0036AA  A1D001     BCLR W1, #13
0036AC  700001     IOR W0, W1, W0
0036AE  881660     MOV W0, LATB
284:                       Delay100ms(time);
0036B0  90402E     MOV.B [W14+2], W0
0036B2  07F646     RCALL Delay100ms
285:                   }
286:               }
0036C0  FA8000     ULNK
287:               /*
288:                *********************************************************************************************************
289:                *                                   OSProbe_TmrInit()
290:                *
291:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
292:                *               free running timer that is used to make time measurements.
293:                *
294:                * Arguments   : none
295:                *
296:                * Returns     : none
297:                *
298:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
299:                *                  from Tmr_TickInit().
300:                *********************************************************************************************************
301:                */
302:               
303:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
304:               
305:               //void OSProbe_TmrInit(void) {
306:               //#if OS_PROBE_TIMER_SEL == 3
307:               //    T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
308:               //    TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
309:               //    PR3 = 0xFFFF; /* Set the period register to its maximum value             */
310:               //    T3CON |= TON; /* Start the timer                                          */
311:               //#endif
312:               //
313:               //#if OS_PROBE_TIMER_SEL == 5
314:               //    T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
315:               //    TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
316:               //    PR5 = 0xFFFF; /* Set the period register to its maximum value             */
317:               //    T5CON |= TON; /* Start the timer                                          */
318:               //#endif
319:               //}
320:               //#endif
321:               
322:               /*
323:                *********************************************************************************************************
324:                *                                   OSProbe_TmrRd()
325:                *
326:                * Description : This function is called to read the current counts of a 16 bit free running timer.
327:                *
328:                * Arguments   : none
329:                *
330:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
331:                *********************************************************************************************************
332:                */
333:               
334:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
335:               
336:               //CPU_INT32U OSProbe_TmrRd(void) {
337:               //#if OS_PROBE_TIMER_SEL == 3
338:               //    return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
339:               //#endif
340:               //
341:               //#if OS_PROBE_TIMER_SEL == 5
342:               //    return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
343:               //#endif
344:               //}
345:               //#endif
346:               
347:               /*
348:                *********************************************************************************************************
349:                *                                       TICKER INITIALIZATION
350:                *
351:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
352:                *               interrupts every 1 to 100 mS).
353:                *
354:                * Arguments   : none
355:                *
356:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
357:                *               2) The timer resets to 0 after period register match interrupt is generated
358:                *********************************************************************************************************
359:                */
360:               
361:               //static void Tmr_TickInit(void) {
362:               //    CPU_INT32U tmr_frq;
363:               //    CPU_INT16U cnts;
364:               //
365:               //
366:               //    tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
367:               //    cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
368:               //
369:               //#if BSP_OS_TMR_SEL == 2
370:               //    T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
371:               //    TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
372:               //    PR2 = cnts; /* Set the period register                                  */
373:               //    IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
374:               //    IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
375:               //    IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
376:               //    IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
377:               //    T2CON |= TON; /* Start the timer                                          */
378:               //#endif
379:               //
380:               //#if BSP_OS_TMR_SEL == 4
381:               //    T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
382:               //    TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
383:               //    PR4 = cnts; /* Set the period register                                  */
384:               //    IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
385:               //    IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
386:               //    IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
387:               //    IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
388:               //    T4CON |= TON; /* Start the timer                                          */
389:               //#endif
390:               //}
391:               
392:               /*
393:                *********************************************************************************************************
394:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
395:                *
396:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
397:                *********************************************************************************************************
398:                */
399:               
400:               //void OS_Tick_ISR_Handler(void) {
401:               //#if  BSP_OS_TMR_SEL == 2
402:               //    IFS0 &= ~T2IF;
403:               //#endif
404:               //
405:               //#if  BSP_OS_TMR_SEL == 4
406:               //    IFS1 &= ~T41F;
407:               //#endif
408:               //
409:               //    OSTimeTick();
410:               //}
411:               
412:               //void OSC_Unlock_Sequence(void) {
413:               //        //Place the new oscillator selection in W0
414:               //        //OSCCONH (high byte) Unlock Sequence
415:               //        asm("MOV #OSCCONH,w1");
416:               //        asm("MOV #0x78, w2");
417:               //        asm("MOV #0x9A, w3");
418:               //        asm("MOV.b w2, [w1]");
419:               //        asm("MOV.b w3, [w1]");
420:               //        //Set new oscillator selection
421:               //        asm("MOV.b WREG, OSCCONH");
422:               //        //OSCCONL (low byte) unlock sequence
423:               //        asm("MOV #OSCCONL,w1");
424:               //        asm("MOV.b #0x01, w0");
425:               //        asm("MOV #0x46, w2");
426:               //        asm("MOV #0x57, w3");
427:               //        asm("MOV.b w2, [w1]");
428:               //        asm("MOV.b w3, [w1]");
429:               //        //Start oscillator switch operation
430:               //        asm("MOV.b w0, [w1]");
431:               //    __builtin_write_OSCCONH(0x03);
432:               //    __builtin_write_OSCCONL(0x02);
433:               //    OSCCONbits.LOCK = 1;
434:               //    OSCCONbits.OSWEN = 1;
435:               //    OSCCONbits.LOCK = 0;
436:               //}
437:               //时钟初始化
438:               
439:               
440:               
441:               
442:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/UART3.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
003540  FA0000     LNK #0x0
6:                     TRISGbits.TRISG8 = 1; //设置为输入
003542  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //设置为输出
003544  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //已经为数字端口
003546  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
003548  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1; //漏极开路输出
00354A  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //设置为输入
12:                    //    TRISDbits.TRISD2 = 0; //设置为输出
13:                
14:                    U3MODEbits.BRGH = 0; //波特率使用标准模式1:16
00354C  A96250     BCLR U3MODE, #3
15:                    U3BRG = 0x19; //19200 103; //16000000/9600/16-1
00354E  200190     MOV #0x19, W0
003550  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //无奇偶校验
003552  801281     MOV U3MODE, W1
003554  2FFF90     MOV #0xFFF9, W0
003556  608000     AND W1, W0, W0
003558  881280     MOV W0, U3MODE
17:                    U3MODEbits.STSEL = 0; //1位停止位
00355A  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //使能串口
00355C  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
00355E  801291     MOV U3STA, W1
003560  200C00     MOV #0xC0, W0
003562  700001     IOR W0, W1, W0
003564  881290     MOV W0, U3STA
22:                    IFS5bits.U3RXIF = 0; //清除接收中断  
003566  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
003568  800661     MOV IPC20, W1
00356A  2F8FF0     MOV #0xF8FF, W0
00356C  608080     AND W1, W0, W1
00356E  206000     MOV #0x600, W0
003570  700001     IOR W0, W1, W0
003572  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //开启接受中断
003574  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
003576  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
003578  800661     MOV IPC20, W1
00357A  200700     MOV #0x70, W0
00357C  700001     IOR W0, W1, W0
00357E  880660     MOV W0, IPC20
27:                    IEC5bits.U3ERIE = 1;
003580  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003582  A84253     BSET 0x253, #2
29:                }
003584  FA8000     ULNK
003586  060000     RETURN
30:                
31:                void UART3_Open(void) {
003588  FA0000     LNK #0x0
32:                    U3MODEbits.UARTEN = 1; //使能串口
00358A  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
00358C  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
00358E  A8409E     BSET IEC5, #2
36:                }
003590  FA8000     ULNK
003592  060000     RETURN
37:                
38:                void UART3_Close(void) {
003594  FA0000     LNK #0x0
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
003596  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003598  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //使能串口发送    
00359A  A9E251     BCLR 0x251, #7
43:                }
00359C  FA8000     ULNK
00359E  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
0035A0  FA0002     LNK #0x2
0035A2  784F00     MOV.B W0, [W14]
46:                    U3TXREG = ch;
0035A4  FB801E     ZE [W14], W0
0035A6  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
0035A8  000000     NOP
0035AA  801291     MOV U3STA, W1
0035AC  201000     MOV #0x100, W0
0035AE  608000     AND W1, W0, W0
0035B0  E00000     CP0 W0
0035B2  32FFFB     BRA Z, 0x35AA
48:                }
0035B4  FA8000     ULNK
0035B6  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
0035B8  FA0006     LNK #0x6
0035BA  980710     MOV W0, [W14+2]
0035BC  984741     MOV.B W1, [W14+4]
51:                    uint8_t bytes = 0;
0035BE  EB4000     CLR.B W0
0035C0  784F00     MOV.B W0, [W14]
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
0035C2  EB4000     CLR.B W0
0035C4  784F00     MOV.B W0, [W14]
0035C6  370006     BRA 0x35D4
0035D2  E84F1E     INC.B [W14], [W14]
0035D4  90404E     MOV.B [W14+4], W0
0035D6  78409E     MOV.B [W14], W1
0035D8  50CF80     SUB.B W1, W0, [W15]
0035DA  39FFF6     BRA NC, 0x35C8
53:                        UART3_SendChar(*(str + bytes));
0035C8  FB801E     ZE [W14], W0
0035CA  90009E     MOV [W14+2], W1
0035CC  408000     ADD W1, W0, W0
0035CE  784010     MOV.B [W0], W0
0035D0  07FFE7     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
0035DC  78401E     MOV.B [W14], W0
57:                }
0035DE  FA8000     ULNK
0035E0  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
0035E2  FA0002     LNK #0x2
0035E4  780F00     MOV W0, [W14]
60:                    if (U3STAbits.URXDA) {
0035E6  801290     MOV U3STA, W0
0035E8  600061     AND W0, #0x1, W0
0035EA  E00000     CP0 W0
0035EC  320006     BRA Z, 0x35FA
61:                        *ch = U3RXREG;
0035EE  8012B0     MOV U3RXREG, W0
0035F0  784080     MOV.B W0, W1
0035F2  78001E     MOV [W14], W0
0035F4  784801     MOV.B W1, [W0]
62:                        return true;
0035F6  B3C010     MOV.B #0x1, W0
0035F8  370001     BRA 0x35FC
63:                    } else
64:                        return false;
0035FA  EB4000     CLR.B W0
65:                }
0035FC  FA8000     ULNK
0035FE  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
003600  FA0002     LNK #0x2
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
003602  EB4000     CLR.B W0
003604  784F00     MOV.B W0, [W14]
003606  370006     BRA 0x3614
003612  E84F1E     INC.B [W14], [W14]
003614  78401E     MOV.B [W14], W0
003616  504FE3     SUB.B W0, #0x3, [W15]
003618  36FFF7     BRA LEU, 0x3608
70:                        if (U3STAbits.URXDA) //没有接收到
003608  801290     MOV U3STA, W0
00360A  600061     AND W0, #0x1, W0
00360C  E00000     CP0 W0
00360E  320001     BRA Z, 0x3612
71:                            BufferWrite_UART3();
003610  07F94A     RCALL BufferWrite_UART3
72:                }
00361A  FA8000     ULNK
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/UART2.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART2.h"
3:                 
4:                 void UART2_Init(void) {
003458  FA0000     LNK #0x0
5:                     //已经为数字端口，
6:                     TRISDbits.TRISD2 = 1; //设置为输入
00345A  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //设置为输出
00345C  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //设置为输入
9:                     //    TRISDbits.TRISD2 = 0; //设置为输出
10:                
11:                    U2MODEbits.BRGH = 0; //波特率使用标准模式1:16
00345E  A96230     BCLR U2MODE, #3
12:                    U2BRG = 0x000C;//51; //19200 103; //16000000/9600/16-1
003460  2000C0     MOV #0xC, W0
003462  8811C0     MOV W0, U2BRG
13:                    U2MODEbits.PDSEL = 00; //无奇偶校验
003464  801181     MOV U2MODE, W1
003466  2FFF90     MOV #0xFFF9, W0
003468  608000     AND W1, W0, W0
00346A  881180     MOV W0, U2MODE
14:                    U2MODEbits.STSEL = 0; //1位停止位
00346C  A90230     BCLR U2MODE, #0
15:                
16:                    U2MODEbits.UARTEN = 1; //使能串口
00346E  A8E231     BSET 0x231, #7
17:                
18:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003470  A84233     BSET 0x233, #2
19:                    U2STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
003472  801191     MOV U2STA, W1
003474  200C00     MOV #0xC0, W0
003476  700001     IOR W0, W1, W0
003478  881190     MOV W0, U2STA
20:                    IEC1bits.U2RXIE = 1; //开启接受中断
00347A  A8C097     BSET 0x97, #6
21:                    IFS1bits.U2RXIF = 0; //清除接收中断
00347C  A9C087     BCLR 0x87, #6
22:                    IEC4bits.U2ERIE = 1;
00347E  A8409C     BSET IEC4, #2
23:                    IFS4bits.U2ERIF = 0;
003480  A9408C     BCLR IFS4, #2
24:                }
003482  FA8000     ULNK
003484  060000     RETURN
25:                
26:                void UART2_Open(void) {
003486  FA0000     LNK #0x0
27:                    U2MODEbits.UARTEN = 1; //使能串口
003488  A8E231     BSET 0x231, #7
28:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
00348A  A84233     BSET 0x233, #2
29:                    // IEC1bits.U2TXIE=1;
30:                    IEC1bits.U2RXIE = 1;
00348C  A8C097     BSET 0x97, #6
31:                }
00348E  FA8000     ULNK
003490  060000     RETURN
32:                
33:                void UART2_Close(void) {
003492  FA0000     LNK #0x0
34:                    // IEC1bits.U2TXIE=0;
35:                    IEC1bits.U2RXIE = 0;
003494  A9C097     BCLR 0x97, #6
36:                    U2STAbits.UTXEN = 0; //使能发送 必须先使能串口 在发送数据
003496  A94233     BCLR 0x233, #2
37:                    U2MODEbits.UARTEN = 0; //使能串口发送    
003498  A9E231     BCLR 0x231, #7
38:                }
00349A  FA8000     ULNK
00349C  060000     RETURN
39:                
40:                void UART2_SendChar(uint8_t ch) {
00349E  FA0002     LNK #0x2
0034A0  784F00     MOV.B W0, [W14]
41:                    U2TXREG = ch;
0034A2  FB801E     ZE [W14], W0
0034A4  8811A0     MOV W0, U2TXREG
42:                    while (!U2STAbits.TRMT);
0034A6  000000     NOP
0034A8  801191     MOV U2STA, W1
0034AA  201000     MOV #0x100, W0
0034AC  608000     AND W1, W0, W0
0034AE  E00000     CP0 W0
0034B0  32FFFB     BRA Z, 0x34A8
43:                }
0034B2  FA8000     ULNK
0034B4  060000     RETURN
44:                
45:                uint8_t UART2_SendString(const uint8_t *str) {
0034B6  FA0004     LNK #0x4
0034B8  980710     MOV W0, [W14+2]
46:                    uint8_t bytes = 0;
0034BA  EB4000     CLR.B W0
0034BC  784F00     MOV.B W0, [W14]
47:                    while (*str != '\0') {
0034BE  370007     BRA 0x34CE
0034CE  90001E     MOV [W14+2], W0
0034D0  784010     MOV.B [W0], W0
0034D2  E00400     CP0.B W0
0034D4  3AFFF5     BRA NZ, 0x34C0
48:                        UART2_SendChar(*str++);
0034C0  90001E     MOV [W14+2], W0
0034C2  784010     MOV.B [W0], W0
0034C4  90009E     MOV [W14+2], W1
0034C6  E80081     INC W1, W1
0034C8  980711     MOV W1, [W14+2]
0034CA  07FFE9     RCALL UART2_SendChar
49:                        bytes++;
0034CC  E84F1E     INC.B [W14], [W14]
50:                    }
51:                    return bytes;
0034D6  78401E     MOV.B [W14], W0
52:                }
0034D8  FA8000     ULNK
0034DA  060000     RETURN
53:                
54:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
0034DC  FA0006     LNK #0x6
0034DE  980710     MOV W0, [W14+2]
0034E0  984741     MOV.B W1, [W14+4]
55:                    uint8_t bytes = 0;
0034E2  EB4000     CLR.B W0
0034E4  784F00     MOV.B W0, [W14]
56:                    while (bytes < len) {
0034E6  370007     BRA 0x34F6
0034F6  90404E     MOV.B [W14+4], W0
0034F8  78409E     MOV.B [W14], W1
0034FA  50CF80     SUB.B W1, W0, [W15]
0034FC  39FFF5     BRA NC, 0x34E8
57:                        UART2_SendChar(*str++);
0034E8  90001E     MOV [W14+2], W0
0034EA  784010     MOV.B [W0], W0
0034EC  90009E     MOV [W14+2], W1
0034EE  E80081     INC W1, W1
0034F0  980711     MOV W1, [W14+2]
0034F2  07FFD5     RCALL UART2_SendChar
58:                        bytes++;
0034F4  E84F1E     INC.B [W14], [W14]
59:                    }
60:                    return bytes;
0034FE  78401E     MOV.B [W14], W0
61:                }
003500  FA8000     ULNK
003502  060000     RETURN
62:                
63:                bool UART2_ReceiveChar(uint8_t * ch) {
003504  FA0002     LNK #0x2
003506  780F00     MOV W0, [W14]
64:                    if (U2STAbits.URXDA) {
003508  801190     MOV U2STA, W0
00350A  600061     AND W0, #0x1, W0
00350C  E00000     CP0 W0
00350E  320006     BRA Z, 0x351C
65:                        *ch = U2RXREG;
003510  8011B0     MOV U2RXREG, W0
003512  784080     MOV.B W0, W1
003514  78001E     MOV [W14], W0
003516  784801     MOV.B W1, [W0]
66:                        return true;
003518  B3C010     MOV.B #0x1, W0
00351A  370001     BRA 0x351E
67:                    } else
68:                        return false;
00351C  EB4000     CLR.B W0
69:                }
00351E  FA8000     ULNK
003520  060000     RETURN
70:                
71:                void U2Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
003522  FA0002     LNK #0x2
72:                    uint8_t cnt;
73:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
003524  EB4000     CLR.B W0
003526  784F00     MOV.B W0, [W14]
003528  370006     BRA 0x3536
003534  E84F1E     INC.B [W14], [W14]
003536  78401E     MOV.B [W14], W0
003538  504FE3     SUB.B W0, #0x3, [W15]
00353A  36FFF7     BRA LEU, 0x352A
74:                        if (U2STAbits.URXDA) //没有接收到
00352A  801190     MOV U2STA, W0
00352C  600061     AND W0, #0x1, W0
00352E  E00000     CP0 W0
003530  320001     BRA Z, 0x3534
75:                            BufferWrite_UART2();
003532  07F99E     RCALL BufferWrite_UART2
76:                }
00353C  FA8000     ULNK
77:                
78:                
79:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/TIM.c  ---------------------------------------
1:                 #include <TIM.h>
2:                 //用于显示LCD
3:                 
4:                 void TMR1_Initialize(void) {
003790  FA0000     LNK #0x0
5:                     //TSIDL disabled; TGATE disabled; TCS External; TSYNC disabled; TCKPS 1:1; TECS SOSC; TON enabled; 
6:                     T1CON = 0x0002;
003792  200020     MOV #0x2, W0
003794  880820     MOV W0, T1CON
7:                     //TMR1 0; 
8:                     TMR1 = 0x0000;
003796  EF2100     CLR TMR1
9:                     //PR1 20; 
10:                    PR1 = 0x8000; //1s// 0xF230; //2s 
003798  280000     MOV #0x8000, W0
00379A  880810     MOV W0, PR1
11:                    T1CONbits.TON = 1;
00379C  A8E105     BSET 0x105, #7
12:                    IPC0bits.T1IP = 5;
00379E  800521     MOV IPC0, W1
0037A0  28FFF0     MOV #0x8FFF, W0
0037A2  608080     AND W1, W0, W1
0037A4  250000     MOV #0x5000, W0
0037A6  700001     IOR W0, W1, W0
0037A8  880520     MOV W0, IPC0
13:                    IFS0bits.T1IF = 0;
0037AA  A96084     BCLR IFS0, #3
14:                    IEC0bits.T1IE = 1;
0037AC  A86094     BSET IEC0, #3
15:                }
0037AE  FA8000     ULNK
0037B0  060000     RETURN
16:                //用于基本延时
17:                
18:                void TMR2_Initialize(void) {
0037B2  FA0000     LNK #0x0
19:                    //TSIDL disabled; TGATE disabled; TCS FOSC/2; TCKPS 1:256; T32 disabled; TON enabled; 
20:                    T2CON = 0x8030;
0037B4  280300     MOV #0x8030, W0
0037B6  880880     MOV W0, T2CON
21:                    //TMR2 0; 
22:                    TMR2 = 0x0000;
0037B8  EF2106     CLR TMR2
23:                    //Period Value = 10.000 ms; PR2 20000; 
24:                    PR2 = 0xffff; //0x4E20;
0037BA  EB8000     SETM W0
0037BC  880860     MOV W0, PR2
25:                    IPC1bits.T2IP = 1;
0037BE  800531     MOV IPC1, W1
0037C0  28FFF0     MOV #0x8FFF, W0
0037C2  608000     AND W1, W0, W0
0037C4  A0C000     BSET W0, #12
0037C6  880530     MOV W0, IPC1
26:                    T2CONbits.TON = 0;
0037C8  A9E111     BCLR 0x111, #7
27:                    IFS0bits.T2IF = 0;
0037CA  A9E084     BCLR IFS0, #7
28:                }
0037CC  FA8000     ULNK
0037CE  060000     RETURN
29:                
30:                void StartTMR2(void) {
0037D0  FA0000     LNK #0x0
31:                    IEC0bits.T2IE = 1;
0037D2  A8E094     BSET IEC0, #7
32:                    T2CONbits.TON = 1;
0037D4  A8E111     BSET 0x111, #7
33:                }
0037D6  FA8000     ULNK
0037D8  060000     RETURN
34:                
35:                void StopTMR2(void) {
0037DA  FA0000     LNK #0x0
36:                    IEC0bits.T2IE = 0;
0037DC  A9E094     BCLR IEC0, #7
37:                    T2CONbits.TON = 0;
0037DE  A9E111     BCLR 0x111, #7
38:                }
0037E0  FA8000     ULNK
39:                
40:                //void StartTMR2Int(void)
41:                //{
42:                //    
43:                //}
44:                
45:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/RTCC.c  --------------------------------------
1:                 #include "RTCC.h"
2:                 #include "WGC.h"
3:                 #include "RS485.h"
4:                 #include <xc.h>
5:                 
6:                 /*************************************
7:                 Function: RTC_Configuration 
8:                 Description: 实时时钟和闹钟初始化
9:                 Input: 无
10:                Output: 无
11:                 *************************************/
12:                void RTC_Init(void) {
0024F2  FA0008     LNK #0x8
13:                    uint8_t rtcc_tmp[7] = {0x20, 0x17, 0x10, 0x30, 0x12, 0x59, 0x00};
0024F4  291441     MOV #0x9144, W1
0024F6  090006     REPEAT #0x6
0024F8  785F31     MOV.B [W1++], [W14++]
0024FA  B1007E     SUB #0x7, W14
14:                    // Set the RTCWREN bit
15:                    __builtin_write_RTCWEN(); //unlock sequence
0024FC  200550     MOV #0x55, W0
0024FE  883B30     MOV W0, NVMKEY
002500  200AA0     MOV #0xAA, W0
002502  883B30     MOV W0, NVMKEY
002504  A8A627     BSET 0x627, #5
16:                
17:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
002506  803131     MOV RCFGCAL, W1
002508  203000     MOV #0x300, W0
00250A  700001     IOR W0, W1, W0
00250C  883130     MOV W0, RCFGCAL
18:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
00250E  90401E     MOV.B [W14+1], W0
002510  FB8000     ZE W0, W0
002512  883120     MOV W0, RTCVAL
19:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
002514  90402E     MOV.B [W14+2], W0
002516  FB8000     ZE W0, W0
002518  DD00C8     SL W0, #8, W1
00251A  90403E     MOV.B [W14+3], W0
00251C  FB8000     ZE W0, W0
00251E  408000     ADD W1, W0, W0
002520  883120     MOV W0, RTCVAL
20:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
002522  90404E     MOV.B [W14+4], W0
002524  FB8000     ZE W0, W0
002526  883120     MOV W0, RTCVAL
21:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //分钟 秒 
002528  90405E     MOV.B [W14+5], W0
00252A  FB8000     ZE W0, W0
00252C  DD00C8     SL W0, #8, W1
00252E  90406E     MOV.B [W14+6], W0
002530  FB8000     ZE W0, W0
002532  408000     ADD W1, W0, W0
002534  883120     MOV W0, RTCVAL
22:                
23:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
24:                    //    RTCPWC = 0x0000;
25:                
26:                    //    ALCFGRPTbits.AMASK = 0b0110; //每日中断//0b0011; -1s 闹钟掩码设置 0x11每分钟闹钟中断一次
27:                    //    ALCFGRPTbits.CHIME = 1; //1 = 使能响铃； ARPT<7:0> 允许从 00h 进位到 FFh
28:                    ALCFGRPTbits.ALRMEN = 0; //关闭报警
002536  A9E623     BCLR 0x623, #7
29:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
002538  803111     MOV ALCFGRPT, W1
00253A  2FCFF0     MOV #0xFCFF, W0
00253C  608000     AND W1, W0, W0
00253E  A09000     BSET W0, #9
002540  883110     MOV W0, ALCFGRPT
30:                    //        ALRMVAL = 0x0000; //none       
31:                    ALRMVAL = 0x0000; //month day 0001
002542  EF2620     CLR ALRMVAL
32:                    ALRMVAL = 0x0000; //week hour
002544  EF2620     CLR ALRMVAL
33:                    ALRMVAL = 0x0000; //minute second  0000
002546  EF2620     CLR ALRMVAL
34:                    //    ALRMVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
35:                    //    ALRMVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
36:                    //    ALRMVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
37:                    //    ALRMVAL = (rtcc_tmp[5] << 8) + 0x25; //rtcc_tmp[6] ; //0x3050; //分钟 秒 
38:                    //    ALCFGRPTbits.ARPT=0;
39:                    //    ALCFGRPTbits.ALRMEN = 1; //闹钟已使能 （每当 ARPT<7:0> = 00 和 CHIME = 0 时，发生闹钟事件后都自动清零）    
40:                
41:                    // ALRMEN enabled; ARPT 0; AMASK Every Second; CHIME enabled; ALRMPTR MIN_SEC; 
42:                    ALCFGRPT = 0xD800; //    every day once 
002548  2D8000     MOV #0xD800, W0
00254A  883110     MOV W0, ALCFGRPT
43:                    //    ALCFGRPT = 0xC800;
44:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
45:                    RTCPWC = 0x0000;
00254C  EF2628     CLR RTCPWC
46:                    IPC15bits.RTCIP = 6;
00254E  800611     MOV IPC15, W1
002550  2F8FF0     MOV #0xF8FF, W0
002552  608080     AND W1, W0, W1
002554  206000     MOV #0x600, W0
002556  700001     IOR W0, W1, W0
002558  880610     MOV W0, IPC15
47:                    IFS3bits.RTCIF = 0; //外设相关的中断标志状态位清零
00255A  A9C08B     BCLR 0x8B, #6
48:                    IEC3bits.RTCIE = 1; //开中断 =1
00255C  A8C09B     BSET 0x9B, #6
49:                
50:                    RCFGCALbits.RTCEN = 1; //使能 RTCC 模块
00255E  A8E627     BSET 0x627, #7
51:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
002560  A9A627     BCLR 0x627, #5
52:                }
002562  FA8000     ULNK
002564  060000     RETURN
53:                
54:                void RTC_Set_Alarm(struct tm initialTime) {//, uint8_t mask) {
002566  FA0002     LNK #0x2
55:                    //只能在禁止闹钟 （ALRMEN = 0）时更改定时器和闹钟值。建议在RTCSYNC = 0 时更改 ALCFGRPT 寄存器和 CHIME 位。
56:                    uint8_t cnt = 0;
002568  EB4080     CLR.B W1
00256A  784F01     MOV.B W1, [W14]
57:                    __builtin_write_RTCWEN(); //unlock sequence
00256C  200550     MOV #0x55, W0
00256E  883B30     MOV W0, NVMKEY
002570  200AA0     MOV #0xAA, W0
002572  883B30     MOV W0, NVMKEY
002574  A8A627     BSET 0x627, #5
58:                
59:                    ALCFGRPTbits.ALRMEN = 0; //关闭闹钟
002576  A9E623     BCLR 0x623, #7
60:                    while (RCFGCALbits.RTCSYNC) {
002578  37000A     BRA 0x258E
00258E  803131     MOV RCFGCAL, W1
002590  210000     MOV #0x1000, W0
002592  608000     AND W1, W0, W0
002594  E00000     CP0 W0
002596  3AFFF1     BRA NZ, 0x257A
002598  370001     BRA 0x259C
61:                        if (cnt++ < 3) //等待同步位
00257A  B3C010     MOV.B #0x1, W0
00257C  78409E     MOV.B [W14], W1
00257E  50CFE2     SUB.B W1, #0x2, [W15]
002580  360001     BRA LEU, 0x2584
002582  EB4000     CLR.B W0
002584  E84F1E     INC.B [W14], [W14]
002586  E00400     CP0.B W0
002588  320008     BRA Z, 0x259A
62:                            Delay1ms(1);
00258A  B3C010     MOV.B #0x1, W0
00258C  07FEA9     RCALL Delay1ms
63:                        else
64:                            break; //添加错误提示
00259A  000000     NOP
65:                    }
66:                
67:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
00259C  803111     MOV ALCFGRPT, W1
00259E  2FCFF0     MOV #0xFCFF, W0
0025A0  608000     AND W1, W0, W0
0025A2  A09000     BSET W0, #9
0025A4  883110     MOV W0, ALCFGRPT
68:                    ALRMVAL = ((initialTime.tm_mon) << 8) + (initialTime.tm_mday);
0025A6  97B80E     MOV [W14-16], W0
0025A8  DD00C8     SL W0, #8, W1
0025AA  97B07E     MOV [W14-18], W0
0025AC  408000     ADD W1, W0, W0
0025AE  883100     MOV W0, ALRMVAL
69:                    ALRMVAL = ((initialTime.tm_wday) << 8) + (initialTime.tm_hour);
0025B0  97B82E     MOV [W14-12], W0
0025B2  DD00C8     SL W0, #8, W1
0025B4  97B06E     MOV [W14-20], W0
0025B6  408000     ADD W1, W0, W0
0025B8  883100     MOV W0, ALRMVAL
70:                    ALRMVAL = ((initialTime.tm_min) << 8) + (initialTime.tm_sec);
0025BA  97B05E     MOV [W14-22], W0
0025BC  DD00C8     SL W0, #8, W1
0025BE  97B04E     MOV [W14-24], W0
0025C0  408000     ADD W1, W0, W0
0025C2  883100     MOV W0, ALRMVAL
71:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
0025C4  A9A627     BCLR 0x627, #5
72:                    ALCFGRPTbits.ALRMEN = 1; //开启闹钟
0025C6  A8E623     BSET 0x623, #7
73:                }
0025C8  FA8000     ULNK
0025CA  060000     RETURN
74:                
75:                /*************************************
76:                Function: RTC_ReadTime 
77:                Description: 获取实时时钟的时间
78:                Input: 4个u16类型数据 
79:                Output: 无
80:                 *************************************/
81:                bool RTC_Read_Time(struct tm*currentTime) {
0025CC  FA0004     LNK #0x4
0025CE  980710     MOV W0, [W14+2]
82:                    uint16_t time_tmp;
83:                    if (RCFGCALbits.RTCSYNC)//等待进入安全读取域
0025D0  803132     MOV RCFGCAL, W2
0025D2  210000     MOV #0x1000, W0
0025D4  610000     AND W2, W0, W0
0025D6  E00000     CP0 W0
0025D8  320002     BRA Z, 0x25DE
84:                        return false;
0025DA  EB4000     CLR.B W0
0025DC  370042     BRA 0x2662
85:                
86:                    __builtin_write_RTCWEN(); // Set the RTCWREN bit
0025DE  200551     MOV #0x55, W1
0025E0  883B31     MOV W1, NVMKEY
0025E2  200AA1     MOV #0xAA, W1
0025E4  883B31     MOV W1, NVMKEY
0025E6  A8A627     BSET 0x627, #5
87:                
88:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
0025E8  803131     MOV RCFGCAL, W1
0025EA  203000     MOV #0x300, W0
0025EC  700001     IOR W0, W1, W0
0025EE  883130     MOV W0, RCFGCAL
89:                    time_tmp = RTCVAL; //获取年份 
0025F0  803121     MOV RTCVAL, W1
0025F2  780F01     MOV W1, [W14]
90:                    currentTime->tm_year = time_tmp;
0025F4  78009E     MOV [W14], W1
0025F6  90001E     MOV [W14+2], W0
0025F8  980051     MOV W1, [W0+10]
91:                    RCFGCALbits.RTCPTR = 2;
0025FA  803131     MOV RCFGCAL, W1
0025FC  2FCFF0     MOV #0xFCFF, W0
0025FE  608000     AND W1, W0, W0
002600  A09000     BSET W0, #9
002602  883130     MOV W0, RCFGCAL
92:                    time_tmp = RTCVAL; //获取月日
002604  803121     MOV RTCVAL, W1
002606  780F01     MOV W1, [W14]
93:                    currentTime->tm_mon = (time_tmp & 0xFF00) >> 8;
002608  78001E     MOV [W14], W0
00260A  DE0048     LSR W0, #8, W0
00260C  780080     MOV W0, W1
00260E  90001E     MOV [W14+2], W0
002610  980041     MOV W1, [W0+8]
94:                    currentTime->tm_mday = time_tmp & 0x00FF;
002612  78009E     MOV [W14], W1
002614  200FF0     MOV #0xFF, W0
002616  608080     AND W1, W0, W1
002618  90001E     MOV [W14+2], W0
00261A  980031     MOV W1, [W0+6]
95:                    RCFGCALbits.RTCPTR = 1;
00261C  803131     MOV RCFGCAL, W1
00261E  2FCFF0     MOV #0xFCFF, W0
002620  608000     AND W1, W0, W0
002622  A08000     BSET W0, #8
002624  883130     MOV W0, RCFGCAL
96:                    time_tmp = RTCVAL; //获取小时
002626  803121     MOV RTCVAL, W1
002628  780F01     MOV W1, [W14]
97:                    currentTime->tm_wday = (time_tmp & 0xFF00) >> 8;
00262A  78001E     MOV [W14], W0
00262C  DE0048     LSR W0, #8, W0
00262E  780080     MOV W0, W1
002630  90001E     MOV [W14+2], W0
002632  980061     MOV W1, [W0+12]
98:                    currentTime->tm_hour = time_tmp & 0x00FF;
002634  78009E     MOV [W14], W1
002636  200FF0     MOV #0xFF, W0
002638  608080     AND W1, W0, W1
00263A  90001E     MOV [W14+2], W0
00263C  980021     MOV W1, [W0+4]
99:                    RCFGCALbits.RTCPTR = 0;
00263E  803131     MOV RCFGCAL, W1
002640  2FCFF0     MOV #0xFCFF, W0
002642  608000     AND W1, W0, W0
002644  883130     MOV W0, RCFGCAL
100:                   time_tmp = RTCVAL; //获取分钟秒
002646  803121     MOV RTCVAL, W1
002648  780F01     MOV W1, [W14]
101:                   currentTime->tm_min = (time_tmp & 0xFF00) >> 8;
00264A  78001E     MOV [W14], W0
00264C  DE0048     LSR W0, #8, W0
00264E  780080     MOV W0, W1
002650  90001E     MOV [W14+2], W0
002652  980011     MOV W1, [W0+2]
102:                   currentTime->tm_sec = time_tmp & 0x00FF;
002654  78009E     MOV [W14], W1
002656  200FF0     MOV #0xFF, W0
002658  608080     AND W1, W0, W1
00265A  90001E     MOV [W14+2], W0
00265C  780801     MOV W1, [W0]
103:                   //    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
104:                   //    time_tmp = RTCVAL; //获取年份 
105:                   //    currentTime->tm_year = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
106:                   //    RCFGCALbits.RTCPTR = 2;
107:                   //    time_tmp = RTCVAL; //获取月日
108:                   //    currentTime->tm_mon = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
109:                   //    currentTime->tm_mday = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
110:                   //    RCFGCALbits.RTCPTR = 1;
111:                   //    time_tmp = RTCVAL; //获取小时
112:                   //    currentTime->tm_wday = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
113:                   //    currentTime->tm_hour = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
114:                   //    RCFGCALbits.RTCPTR = 0;
115:                   //    time_tmp = RTCVAL; //获取分钟秒
116:                   //    currentTime->tm_min = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
117:                   //    currentTime->tm_sec = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
118:                   //    currentTime->tm_isdst
119:                   RCFGCALbits.RTCWREN = 0;
00265E  A9A627     BCLR 0x627, #5
120:               
121:                   return true;
002660  B3C010     MOV.B #0x1, W0
122:               }
002662  FA8000     ULNK
002664  060000     RETURN
123:               
124:               /*************************************
125:               Function: Check_RTCC 
126:               Description: 从仪表获取时间 赋值给RTCC
127:               Input: 6个u8类型数据
128:               Output: 无
129:                *************************************/
130:               void RTC_Set_Time(struct tm initialTime) {
002666  FA0000     LNK #0x0
131:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
002668  200550     MOV #0x55, W0
00266A  883B30     MOV W0, NVMKEY
00266C  200AA0     MOV #0xAA, W0
00266E  883B30     MOV W0, NVMKEY
002670  A8A627     BSET 0x627, #5
132:                   RCFGCALbits.RTCEN = 0; //Close RTCC
002672  A9E627     BCLR 0x627, #7
133:               
134:                   IFS3bits.RTCIF = false;
002674  A9C08B     BCLR 0x8B, #6
135:                   IEC3bits.RTCIE = 0;
002676  A9C09B     BCLR 0x9B, #6
136:               
137:                   // set RTCC initial time
138:                   RCFGCALbits.RTCPTR = 3; // start the sequence
002678  803131     MOV RCFGCAL, W1
00267A  203000     MOV #0x300, W0
00267C  700001     IOR W0, W1, W0
00267E  883130     MOV W0, RCFGCAL
139:                   RTCVAL = (initialTime.tm_year); // YEAR
002680  97B81E     MOV [W14-14], W0
002682  883120     MOV W0, RTCVAL
140:                   RTCVAL = (initialTime.tm_mon) << 8 + (initialTime.tm_mday); // MONTH-1/DAY-1
002684  97B88E     MOV [W14-16], W1
002686  97B07E     MOV [W14-18], W0
002688  400068     ADD W0, #0x8, W0
00268A  DD0800     SL W1, W0, W0
00268C  883120     MOV W0, RTCVAL
141:                   RTCVAL = (initialTime.tm_wday) << 8 + (initialTime.tm_hour); // WEEKDAY/HOURS
00268E  97B8AE     MOV [W14-12], W1
002690  97B06E     MOV [W14-20], W0
002692  400068     ADD W0, #0x8, W0
002694  DD0800     SL W1, W0, W0
002696  883120     MOV W0, RTCVAL
142:                   RTCVAL = (initialTime.tm_min) << 8 + (initialTime.tm_sec); // MINUTES/SECONDS   
002698  97B0DE     MOV [W14-22], W1
00269A  97B04E     MOV [W14-24], W0
00269C  400068     ADD W0, #0x8, W0
00269E  DD0800     SL W1, W0, W0
0026A0  883120     MOV W0, RTCVAL
143:               
144:                   // Enable RTCC, clear RTCWREN         
145:                   RCFGCALbits.RTCEN = 1;
0026A2  A8E627     BSET 0x627, #7
146:                   RCFGCALbits.RTCWREN = 0;
0026A4  A9A627     BCLR 0x627, #5
147:               
148:                   IEC3bits.RTCIE = 1;
0026A6  A8C09B     BSET 0x9B, #6
149:               }
0026A8  FA8000     ULNK
0026AA  060000     RETURN
150:               
151:               /*************************************
152:               Function: RTC_Refresh_Time 
153:               Description: 从仪表获取时间 赋值给RTCC
154:               Input: 6个u8类型数据
155:               Output: 无
156:                *************************************/
157:               
158:               void RTC_Refresh_Time(void) {
0026AC  FA0000     LNK #0x0
159:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
0026AE  200550     MOV #0x55, W0
0026B0  883B30     MOV W0, NVMKEY
0026B2  200AA0     MOV #0xAA, W0
0026B4  883B30     MOV W0, NVMKEY
0026B6  A8A627     BSET 0x627, #5
160:                   RCFGCALbits.RTCEN = 0; //Close RTCC
0026B8  A9E627     BCLR 0x627, #7
161:               
162:                   IFS3bits.RTCIF = false;
0026BA  A9C08B     BCLR 0x8B, #6
163:                   IEC3bits.RTCIE = 0;
0026BC  A9C09B     BCLR 0x9B, #6
164:               
165:                   // set RTCC initial time
166:                   RCFGCALbits.RTCPTR = 3; // start the sequence
0026BE  803131     MOV RCFGCAL, W1
0026C0  203000     MOV #0x300, W0
0026C2  700001     IOR W0, W1, W0
0026C4  883130     MOV W0, RCFGCAL
167:                   RTCVAL = WGCTIME0bits.year; // YEAR
0026C6  BFC800     MOV.B WGCTIME0bits, WREG
0026C8  FB8000     ZE W0, W0
0026CA  883120     MOV W0, RTCVAL
168:                   RTCVAL = (WGCTIME0bits.month << 8) + WGCTIME1bits.day; // MONTH-1/DAY-1
0026CC  BFC801     MOV.B 0x801, WREG
0026CE  FB8000     ZE W0, W0
0026D0  DD00C8     SL W0, #8, W1
0026D2  BFC802     MOV.B WGCTIME1bits, WREG
0026D4  FB8000     ZE W0, W0
0026D6  408000     ADD W1, W0, W0
0026D8  883120     MOV W0, RTCVAL
169:                   RTCVAL = WGCTIME1bits.hour; // WEEKDAY/HOURS
0026DA  BFC803     MOV.B 0x803, WREG
0026DC  FB8000     ZE W0, W0
0026DE  883120     MOV W0, RTCVAL
170:                   RTCVAL = (WGCTIME2bits.min << 8) + WGCTIME2bits.sec; // MINUTES/SECONDS   
0026E0  BFC804     MOV.B WGCTIME2bits, WREG
0026E2  FB8000     ZE W0, W0
0026E4  DD00C8     SL W0, #8, W1
0026E6  BFC805     MOV.B 0x805, WREG
0026E8  FB8000     ZE W0, W0
0026EA  408000     ADD W1, W0, W0
0026EC  883120     MOV W0, RTCVAL
171:                   // Enable RTCC, clear RTCWREN         
172:                   RCFGCALbits.RTCEN = 1;
0026EE  A8E627     BSET 0x627, #7
173:                   RCFGCALbits.RTCWREN = 0;
0026F0  A9A627     BCLR 0x627, #5
174:               
175:                   IEC3bits.RTCIE = 1;
0026F2  A8C09B     BSET 0x9B, #6
176:               }
0026F4  FA8000     ULNK
0026F6  060000     RETURN
177:               
178:               /*************************************
179:               Function: StartRTCC 
180:               Description: 
181:               Input: 
182:               Output: 
183:                *************************************/
184:               //void StartRTCC(void) {
185:               //
186:               //    IEC3bits.RTCIE = 1; //开启中断
187:               //    ALCFGRPTbits.ALRMEN = 1;
188:               //    RCFGCALbits.RTCEN = 1; //开启RTCC
189:               //}
190:               
191:               /*************************************
192:               Function: StopRTCC 
193:               Description: 
194:               Input: 
195:               Output: 
196:                *************************************/
197:               //void StopRTCC(void) {
198:               //    IEC3bits.RTCIE = 0; //关闭中断 
199:               //    ALCFGRPTbits.ALRMEN = 0;
200:               //    RCFGCALbits.RTCEN = 0; //关闭 RTCC 模块
201:               //}
202:               
203:               void PrintTime(void) {
0026F8  FA0028     LNK #0x28
204:                   struct tm time1;
205:                   uint8_t cnt=0;
0026FA  EB4000     CLR.B W0
0026FC  784F00     MOV.B W0, [W14]
206:                   uint8_t sendstr[20] = {"1234578901234567890"};
0026FE  291300     MOV #0x9130, W0
002700  4700F4     ADD W14, #0x14, W1
002702  090013     REPEAT #0x13
002704  7858B0     MOV.B [W0++], [W1++]
002706  B10140     SUB #0x14, W0
207:                   while (!RTC_Read_Time(&time1)) {
002708  370008     BRA 0x271A
00271A  E8800E     INC2 W14, W0
00271C  07FF57     RCALL RTC_Read_Time
00271E  A20400     BTG.B W0, #0
002720  E00400     CP0.B W0
002722  3AFFF3     BRA NZ, 0x270A
208:                       if(cnt++>3)
00270A  B3C010     MOV.B #0x1, W0
00270C  78409E     MOV.B [W14], W1
00270E  50CFE3     SUB.B W1, #0x3, [W15]
002710  3E0001     BRA GTU, 0x2714
002712  EB4000     CLR.B W0
002714  E84F1E     INC.B [W14], [W14]
002716  E00400     CP0.B W0
002718  3A007D     BRA NZ, 0x2814
209:                           return;//添加错误提示
002814  000000     NOP
210:                   }
211:               
212:                   sendstr[0] = (time1.tm_year / 16) + 0x30;
002724  9000EE     MOV [W14+12], W1
002726  200100     MOV #0x10, W0
002728  780100     MOV W0, W2
00272A  090011     REPEAT #0x11
00272C  D80082     DIV.SW W1, W2
00272E  784000     MOV.B W0, W0
002730  B04300     ADD.B #0x30, W0
002732  985740     MOV.B W0, [W14+20]
213:                   sendstr[1] = (time1.tm_year % 16) + 0x30;
002734  9000EE     MOV [W14+12], W1
002736  200100     MOV #0x10, W0
002738  780100     MOV W0, W2
00273A  090011     REPEAT #0x11
00273C  D80082     DIV.SW W1, W2
00273E  FD0080     EXCH W0, W1
002740  784000     MOV.B W0, W0
002742  B04300     ADD.B #0x30, W0
002744  985750     MOV.B W0, [W14+21]
214:                   sendstr[2] = '/';
002746  B3C2F0     MOV.B #0x2F, W0
002748  985760     MOV.B W0, [W14+22]
215:                   sendstr[3] = ((time1.tm_mon + 1) / 16) + 0x30;
00274A  90005E     MOV [W14+10], W0
00274C  E80080     INC W0, W1
00274E  200100     MOV #0x10, W0
002750  780100     MOV W0, W2
002752  090011     REPEAT #0x11
002754  D80082     DIV.SW W1, W2
002756  784000     MOV.B W0, W0
002758  B04300     ADD.B #0x30, W0
00275A  985770     MOV.B W0, [W14+23]
216:                   sendstr[4] = ((time1.tm_mon + 1) % 16) + 0x30;
00275C  90005E     MOV [W14+10], W0
00275E  E80080     INC W0, W1
002760  200100     MOV #0x10, W0
002762  780100     MOV W0, W2
002764  090011     REPEAT #0x11
002766  D80082     DIV.SW W1, W2
002768  FD0080     EXCH W0, W1
00276A  784000     MOV.B W0, W0
00276C  B04300     ADD.B #0x30, W0
00276E  985F00     MOV.B W0, [W14+24]
217:                   sendstr[5] = '/';
002770  B3C2F0     MOV.B #0x2F, W0
002772  985F10     MOV.B W0, [W14+25]
218:                   sendstr[6] = (time1.tm_mday / 16) + 0x30;
002774  9000CE     MOV [W14+8], W1
002776  200100     MOV #0x10, W0
002778  780100     MOV W0, W2
00277A  090011     REPEAT #0x11
00277C  D80082     DIV.SW W1, W2
00277E  784000     MOV.B W0, W0
002780  B04300     ADD.B #0x30, W0
002782  985F20     MOV.B W0, [W14+26]
219:                   sendstr[7] = (time1.tm_mday % 16) + 0x30;
002784  9000CE     MOV [W14+8], W1
002786  200100     MOV #0x10, W0
002788  780100     MOV W0, W2
00278A  090011     REPEAT #0x11
00278C  D80082     DIV.SW W1, W2
00278E  FD0080     EXCH W0, W1
002790  784000     MOV.B W0, W0
002792  B04300     ADD.B #0x30, W0
002794  985F30     MOV.B W0, [W14+27]
220:                   sendstr[8] = '-';
002796  B3C2D0     MOV.B #0x2D, W0
002798  985F40     MOV.B W0, [W14+28]
221:                   sendstr[9] = (time1.tm_hour / 16) + 0x30;
00279A  9000BE     MOV [W14+6], W1
00279C  200100     MOV #0x10, W0
00279E  780100     MOV W0, W2
0027A0  090011     REPEAT #0x11
0027A2  D80082     DIV.SW W1, W2
0027A4  784000     MOV.B W0, W0
0027A6  B04300     ADD.B #0x30, W0
0027A8  985F50     MOV.B W0, [W14+29]
222:                   sendstr[10] = (time1.tm_hour % 16) + 0x30;
0027AA  9000BE     MOV [W14+6], W1
0027AC  200100     MOV #0x10, W0
0027AE  780100     MOV W0, W2
0027B0  090011     REPEAT #0x11
0027B2  D80082     DIV.SW W1, W2
0027B4  FD0080     EXCH W0, W1
0027B6  784000     MOV.B W0, W0
0027B8  B04300     ADD.B #0x30, W0
0027BA  985F60     MOV.B W0, [W14+30]
223:                   sendstr[11] = ':';
0027BC  B3C3A0     MOV.B #0x3A, W0
0027BE  985F70     MOV.B W0, [W14+31]
224:                   sendstr[12] = (time1.tm_min / 16) + 0x30;
0027C0  9000AE     MOV [W14+4], W1
0027C2  200100     MOV #0x10, W0
0027C4  780100     MOV W0, W2
0027C6  090011     REPEAT #0x11
0027C8  D80082     DIV.SW W1, W2
0027CA  784000     MOV.B W0, W0
0027CC  B04300     ADD.B #0x30, W0
0027CE  986700     MOV.B W0, [W14+32]
225:                   sendstr[13] = (time1.tm_min % 16) + 0x30;
0027D0  9000AE     MOV [W14+4], W1
0027D2  200100     MOV #0x10, W0
0027D4  780100     MOV W0, W2
0027D6  090011     REPEAT #0x11
0027D8  D80082     DIV.SW W1, W2
0027DA  FD0080     EXCH W0, W1
0027DC  784000     MOV.B W0, W0
0027DE  B04300     ADD.B #0x30, W0
0027E0  986710     MOV.B W0, [W14+33]
226:                   sendstr[14] = ':';
0027E2  B3C3A0     MOV.B #0x3A, W0
0027E4  986720     MOV.B W0, [W14+34]
227:                   sendstr[15] = (time1.tm_sec / 16) + 0x30;
0027E6  90009E     MOV [W14+2], W1
0027E8  200100     MOV #0x10, W0
0027EA  780100     MOV W0, W2
0027EC  090011     REPEAT #0x11
0027EE  D80082     DIV.SW W1, W2
0027F0  784000     MOV.B W0, W0
0027F2  B04300     ADD.B #0x30, W0
0027F4  986730     MOV.B W0, [W14+35]
228:                   sendstr[16] = (time1.tm_sec % 16) + 0x30;
0027F6  90009E     MOV [W14+2], W1
0027F8  200100     MOV #0x10, W0
0027FA  780100     MOV W0, W2
0027FC  090011     REPEAT #0x11
0027FE  D80082     DIV.SW W1, W2
002800  FD0080     EXCH W0, W1
002802  784000     MOV.B W0, W0
002804  B04300     ADD.B #0x30, W0
002806  986740     MOV.B W0, [W14+36]
229:                   sendstr[17] = '\n';
002808  B3C0A0     MOV.B #0xA, W0
00280A  986750     MOV.B W0, [W14+37]
230:                   //        sendstr[18] = '\n';
231:                   //        sendstr[18] = '\0';
232:                   RS485SendString(sendstr, 18);
00280C  470074     ADD W14, #0x14, W0
00280E  B3C121     MOV.B #0x12, W1
002810  0704E9     RCALL RS485SendString
002812  370001     BRA 0x2816
233:                   //        OSTimeDlyHMSM();
234:               }
002816  FA8000     ULNK
002818  060000     RETURN
235:               #ifdef DEBUG_RTCC_TIME
236:               
237:               void printrtccArg(void) {
238:                   uint8_t tmp[10];
239:                   uint8_t strings[200] = {'\0'}; //clear history data
240:               
241:                   strcat(strings, "S1_t:");
242:                   my_itoa(WGCCON3bits.delay, tmp);
243:                   strcat(strings, tmp);
244:               
245:                   strcat(strings, ";\tS1_c:");
246:                   my_itoa(WGCCON3bits.count, tmp);
247:                   strcat(strings, tmp);
248:               
249:               
250:                   strcat(strings, ";\r\nS2_t:");
251:                   my_itoa(WGCCON4bits.delay, tmp);
252:                   strcat(strings, tmp);
253:               
254:                   strcat(strings, ";\tS2_c:");
255:                   my_itoa(WGCCON4bits.count, tmp);
256:                   strcat(strings, tmp);
257:                   RS485SendString1(strings); //无法正确输出
258:               }
259:               
260:               #endif
261:               
262:               void printnums(uint32_t settingtime) {
00281A  FA0040     LNK #0x40
00281C  981F60     MOV W0, [W14+60]
00281E  981F71     MOV W1, [W14+62]
263:                   uint8_t strings[50] = {'\0'}; //clear history data
002820  090018     REPEAT #0x18
002822  EB1F00     CLR [W14++]
002824  B1032E     SUB #0x32, W14
264:                   uint8_t tmp[10];
265:                   //    strcat(strings, ch);
266:                   my_itoa(settingtime, tmp); //最大16进制数
002826  90186E     MOV [W14+60], W0
002828  200321     MOV #0x32, W1
00282A  40808E     ADD W1, W14, W1
00282C  07FE17     RCALL my_itoa
267:                   strcat(strings, tmp);
00282E  200321     MOV #0x32, W1
002830  40808E     ADD W1, W14, W1
002832  78000E     MOV W14, W0
002834  07F398     RCALL 0xF66
268:                   RS485SendString1(strings); //无法正确输出
002836  78000E     MOV W14, W0
002838  0704F0     RCALL RS485SendString1
269:                   //    my_itoa(WGCCON3bits.count,tmp);
270:                   //    strcat(strings,tmp);
271:               
272:                   //    WGCCON3bits.delay;
273:                   //    WGCCON4bits.count;
274:                   //    WGCCON4bits.delay;
275:               
276:                   //     my_itoa(); 
277:               }
00283A  FA8000     ULNK
278:               
279:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485通讯初始化
13:                Input: 无 
14:                Output: 无
15:                 *************************************/
16:                void RS485_Init(void) {
00317C  FA0000     LNK #0x0
17:                
18:                    U1MODEbits.UARTEN = 1; //使能串口
00317E  A8E221     BSET 0x221, #7
19:                    U1MODEbits.BRGH = 1; //16
003180  A86220     BSET U1MODE, #3
20:                    U1BRG = 0x0019; //103; //16000000/9600/16-1
003182  200190     MOV #0x19, W0
003184  881140     MOV W0, U1BRG
21:                
22:                    U1MODEbits.PDSEL = 00; //无奇偶校验
003186  801101     MOV U1MODE, W1
003188  2FFF90     MOV #0xFFF9, W0
00318A  608000     AND W1, W0, W0
00318C  881100     MOV W0, U1MODE
23:                    U1MODEbits.STSEL = 0; //1位停止位
00318E  A90220     BCLR U1MODE, #0
24:                    U1MODEbits.USIDL = 0; //空闲模式下继续工作
003190  A9A221     BCLR 0x221, #5
25:                    U1MODEbits.WAKE = 1; //休眠状态下继续工作
003192  A8E220     BSET U1MODE, #7
26:                    //    U1MODEbits.UARTEN = 1; //使能串口
27:                    U1STAbits.UTXEN = 0; //使能发送 必须先使能串口 在发送数据
003194  A94223     BCLR 0x223, #2
28:                    U1STAbits.URXISEL = 3; //有 4个数据字符，中断标志位置 1
003196  801111     MOV U1STA, W1
003198  200C00     MOV #0xC0, W0
00319A  700001     IOR W0, W1, W0
00319C  881110     MOV W0, U1STA
29:                    U1TXREG = 0;
00319E  EF2224     CLR U1TXREG
30:                    U1RXREG = 0;
0031A0  EF2226     CLR U1RXREG
31:                    IPC2bits.U1RXIP = 7;
0031A2  800541     MOV IPC2, W1
0031A4  270000     MOV #0x7000, W0
0031A6  700001     IOR W0, W1, W0
0031A8  880540     MOV W0, IPC2
32:                    IFS0bits.U1RXIF = 0; //清除接收中断
0031AA  A96085     BCLR 0x85, #3
33:                    IEC0bits.U1RXIE = 1; //开启接受中断
0031AC  A86095     BSET 0x95, #3
34:                    IPC16bits.U1ERIP = 6;
0031AE  800621     MOV IPC16, W1
0031B0  2FF8F0     MOV #0xFF8F, W0
0031B2  608080     AND W1, W0, W1
0031B4  200600     MOV #0x60, W0
0031B6  700001     IOR W0, W1, W0
0031B8  880620     MOV W0, IPC16
35:                    IFS4bits.U1ERIF = 0; //清楚错误中断
0031BA  A9208C     BCLR IFS4, #1
36:                    IEC4bits.U1ERIE = 1; //开启错误中断    
0031BC  A8209C     BSET IEC4, #1
37:                    U1STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
0031BE  A84223     BSET 0x223, #2
38:                
39:                    //    U1MODE = 0x8008;
40:                    //    // UTXEN disabled; UTXINV disabled; URXISEL RX_ONE_CHAR; ADDEN disabled; UTXISEL0 TX_ONE_CHAR; UTXBRK COMPLETED; OERR NO_ERROR_cleared; 
41:                    //    U1STA = 0x0000;
42:                    //    // U1TXREG 0x0000; 
43:                    //    U1TXREG = 0x0000;
44:                    //    // U1RXREG 0x0000; 
45:                    //    U1RXREG = 0x0000;
46:                    //    // Baud Rate = 9600; BRG 416; 
47:                    //    U1BRG = 0x01A0;
48:                    //
49:                    //    IEC0bits.U1RXIE = 1;
50:                    //
51:                    //    U1STAbits.UTXEN = 1;
52:                }
0031C0  FA8000     ULNK
0031C2  060000     RETURN
53:                
54:                //void OpenAwake485(void) {//CN6电平通知中断唤醒设备
55:                //    RS485_RX_IN;
56:                //    CNEN1bits.CN6IE = 1; //RX1接受
57:                //}
58:                
59:                //void CloseAwake485(void) {
60:                //    CNEN1bits.CN6IE = 0;
61:                //}
62:                
63:                /*************************************
64:                Function: RS485_Send 待修改 
65:                Description: 485发送数据指令
66:                Input: 发送的数据 
67:                Output: 1:发送成功
68:                 *************************************/
69:                void RS485SendChar(const uint8_t dat) {
0031C4  FA0002     LNK #0x2
0031C6  784F00     MOV.B W0, [W14]
70:                    RS485_CON = 1; //发送
0031C8  A842CD     BSET 0x2CD, #2
71:                    U1TXREG = dat;
0031CA  FB801E     ZE [W14], W0
0031CC  881120     MOV W0, U1TXREG
72:                    while (!U1STAbits.TRMT);
0031CE  000000     NOP
0031D0  801111     MOV U1STA, W1
0031D2  201000     MOV #0x100, W0
0031D4  608000     AND W1, W0, W0
0031D6  E00000     CP0 W0
0031D8  32FFFB     BRA Z, 0x31D0
73:                    Delay10ms(1);
0031DA  200010     MOV #0x1, W0
0031DC  07F899     RCALL Delay10ms
74:                    RS485_CON = 0; //接收
0031DE  A942CD     BCLR 0x2CD, #2
75:                }
0031E0  FA8000     ULNK
0031E2  060000     RETURN
76:                
77:                /*************************************
78:                Function: RS485_SendString 
79:                Description: 485发送字符串
80:                Input: 字符串 字符串长度 
81:                Output: 无
82:                 *************************************/
83:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
0031E4  FA0006     LNK #0x6
0031E6  980710     MOV W0, [W14+2]
0031E8  984741     MOV.B W1, [W14+4]
84:                    uint8_t count = 0;
0031EA  EB4000     CLR.B W0
0031EC  784F00     MOV.B W0, [W14]
85:                
86:                    RS485_CON = 1; //发送    
0031EE  A842CD     BSET 0x2CD, #2
87:                    //    Delay10ms(1);
88:                    while (count < bytes) {
0031F0  37000D     BRA 0x320C
00320C  90404E     MOV.B [W14+4], W0
00320E  78409E     MOV.B [W14], W1
003210  50CF80     SUB.B W1, W0, [W15]
003212  39FFEF     BRA NC, 0x31F2
89:                        U1TXREG = *(dat + count);
0031F2  FB801E     ZE [W14], W0
0031F4  90009E     MOV [W14+2], W1
0031F6  408000     ADD W1, W0, W0
0031F8  784010     MOV.B [W0], W0
0031FA  FB8000     ZE W0, W0
0031FC  881120     MOV W0, U1TXREG
90:                        while (!U1STAbits.TRMT);
0031FE  000000     NOP
003200  801111     MOV U1STA, W1
003202  201000     MOV #0x100, W0
003204  608000     AND W1, W0, W0
003206  E00000     CP0 W0
003208  32FFFB     BRA Z, 0x3200
91:                        count++;
00320A  E84F1E     INC.B [W14], [W14]
92:                    }
93:                //    Delay1ms(10); //加一段延时
94:                    RS485_CON = 0; //接收
003214  A942CD     BCLR 0x2CD, #2
95:                }
003216  FA8000     ULNK
003218  060000     RETURN
96:                
97:                //#ifdef DEBUG_485_SEND_STR
98:                
99:                /*************************************
100:               Function: RS485_SendString 
101:               Description: 485发送字符串
102:               Input: 字符串 字符串长度 
103:               Output: 无
104:                *************************************/
105:               void RS485SendString1(const uint8_t* dat) {
00321A  FA0004     LNK #0x4
00321C  980710     MOV W0, [W14+2]
106:                   uint8_t count = 0;
00321E  EB4000     CLR.B W0
003220  784F00     MOV.B W0, [W14]
107:               
108:                   RS485_CON = 1; //发送    
003222  A842CD     BSET 0x2CD, #2
109:                   Delay100ms(1);
003224  200010     MOV #0x1, W0
003226  07F88C     RCALL Delay100ms
110:                   while (dat[count] != '\0') {
003228  37000D     BRA 0x3244
003244  FB801E     ZE [W14], W0
003246  90009E     MOV [W14+2], W1
003248  408000     ADD W1, W0, W0
00324A  784010     MOV.B [W0], W0
00324C  E00400     CP0.B W0
00324E  3AFFED     BRA NZ, 0x322A
111:                       U1TXREG = *(dat + count);
00322A  FB801E     ZE [W14], W0
00322C  90009E     MOV [W14+2], W1
00322E  408000     ADD W1, W0, W0
003230  784010     MOV.B [W0], W0
003232  FB8000     ZE W0, W0
003234  881120     MOV W0, U1TXREG
112:                       while (!U1STAbits.TRMT);
003236  000000     NOP
003238  801111     MOV U1STA, W1
00323A  201000     MOV #0x100, W0
00323C  608000     AND W1, W0, W0
00323E  E00000     CP0 W0
003240  32FFFB     BRA Z, 0x3238
113:                       count++;
003242  E84F1E     INC.B [W14], [W14]
114:                   }
115:                   Delay100ms(1);
003250  200010     MOV #0x1, W0
003252  07F876     RCALL Delay100ms
116:                   RS485_CON = 0; //接收
003254  A942CD     BCLR 0x2CD, #2
117:                   Delay10ms(1);
003256  200010     MOV #0x1, W0
003258  07F85B     RCALL Delay10ms
118:               }
00325A  FA8000     ULNK
00325C  060000     RETURN
119:               
120:               /*************************************
121:               Function: U1Rx4Byte 
122:               Description: 获取最后接收到的数据，因为4个字节一次中断，最后3个字节需要执行该函数获取
123:               Input: 无
124:               Output: 无
125:                *************************************/
126:               void U1Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
00325E  FA0002     LNK #0x2
127:                   uint8_t cnt;
128:                   for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
003260  EB4000     CLR.B W0
003262  784F00     MOV.B W0, [W14]
003264  370006     BRA 0x3272
003270  E84F1E     INC.B [W14], [W14]
003272  78401E     MOV.B [W14], W0
003274  504FE3     SUB.B W0, #0x3, [W15]
003276  36FFF7     BRA LEU, 0x3266
129:                       if (U1STAbits.URXDA) //没有接收到
003266  801110     MOV U1STA, W0
003268  600061     AND W0, #0x1, W0
00326A  E00000     CP0 W0
00326C  320001     BRA Z, 0x3270
130:                           BufferWrite_UART1();
00326E  07FAE7     RCALL BufferWrite_UART1
131:               }
003278  FA8000     ULNK
132:               
133:               
134:               
135:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/PPS.c  ---------------------------------------
1:                 /* 
2:                  * File:   PPS.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 2017年6月20日, 下午1:52
6:                  */
7:                 #include <xc.h>
8:                 
9:                 void PPSInit(void) {
003730  FA0000     LNK #0x0
10:                    TRISBbits.TRISB9 = 0; //控制口设置位输出 485_CON
003732  A922C9     BCLR 0x2C9, #1
11:                    TRISBbits.TRISB8 = 1; //设置为输入/
003734  A802C9     BSET 0x2C9, #0
12:                    TRISBbits.TRISB10 = 0; //设置为输出
003736  A942C9     BCLR 0x2C9, #2
13:                    ANSBbits.ANSB8 = 0; //数字输入
003738  A904E3     BCLR 0x4E3, #0
14:                    ANSBbits.ANSB9 = 0;
00373A  A924E3     BCLR 0x4E3, #1
15:                    ANSBbits.ANSB10 = 1;
00373C  A844E3     BSET 0x4E3, #2
16:                    //    LATBbits.LATB10 = 0;
17:                
18:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
00373E  803A11     MOV OSCCON, W1
003740  200BF0     MOV #0xBF, W0
003742  608100     AND W1, W0, W2
003744  200460     MOV #0x46, W0
003746  200571     MOV #0x57, W1
003748  207423     MOV #0x742, W3
00374A  784980     MOV.B W0, [W3]
00374C  784981     MOV.B W1, [W3]
00374E  784982     MOV.B W2, [W3]
19:                    //    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
20:                    //    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
21:                    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
003750  803641     MOV RPOR4, W1
003752  2C0FF0     MOV #0xC0FF, W0
003754  608080     AND W1, W0, W1
003756  203000     MOV #0x300, W0
003758  700001     IOR W0, W1, W0
00375A  883640     MOV W0, RPOR4
22:                    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
00375C  803521     MOV RPINR18, W1
00375E  2FFC00     MOV #0xFFC0, W0
003760  608000     AND W1, W0, W0
003762  A03000     BSET W0, #3
003764  883520     MOV W0, RPINR18
23:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
003766  8036B1     MOV RPOR11, W1
003768  2FFC00     MOV #0xFFC0, W0
00376A  608000     AND W1, W0, W0
00376C  B30050     IOR #0x5, W0
00376E  8836B0     MOV W0, RPOR11
24:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX 
003770  803531     MOV RPINR19, W1
003772  2FFC00     MOV #0xFFC0, W0
003774  608000     AND W1, W0, W0
003776  B30170     IOR #0x17, W0
003778  883530     MOV W0, RPINR19
25:                //    RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
26:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
27:                    //    RPINR3bits.
28:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
29:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
30:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
00377A  803A10     MOV OSCCON, W0
00377C  780100     MOV W0, W2
00377E  A06002     BSET W2, #6
003780  200460     MOV #0x46, W0
003782  200571     MOV #0x57, W1
003784  207423     MOV #0x742, W3
003786  784980     MOV.B W0, [W3]
003788  784981     MOV.B W1, [W3]
00378A  784982     MOV.B W2, [W3]
31:                }
00378C  FA8000     ULNK
32:                
33:                //RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
34:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX
35:                
36:                
37:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年6月6日, 上午8:48
6:                  */
7:                 #include "SerialBuffer.h"
8:                 #include "includes.h"
9:                 #include "stdbool.h"
10:                #include "stdio.h"
11:                #include "RTCC.h"
12:                #include "LCD.h"
13:                #include "WGC.h"
14:                #include "bsp.h"
15:                //#include "Debug.h"
16:                extern volatile uint8_t i2c1_state;
17:                extern I2C1_Buffer i2c_buf;
18:                static uint8_t T0_Cnt;
19:                
20:                /*************************************
21:                Function: RTCC中断
22:                Description: 
23:                Input: 无 
24:                Output: 无
25:                 *************************************/
26:                void __attribute__((interrupt, no_auto_psv)) _ISR _RTCCInterrupt(void) {
000314  F80036     PUSH RCOUNT
000316  BE9F80     MOV.D W0, [W15++]
000318  BE9F82     MOV.D W2, [W15++]
00031A  BE9F84     MOV.D W4, [W15++]
00031C  BE9F86     MOV.D W6, [W15++]
00031E  FA0002     LNK #0x2
27:                    uint8_t tmp = 0;
000320  EB4000     CLR.B W0
000322  784F00     MOV.B W0, [W14]
28:                    //    WGCCON2bits.Send_FLAG = 1; //添加时间计算避免时间上的误差
29:                    //    RS485SendString
30:                    tmp = CalaAlarmTime(); //计算下次闹钟的时间
000324  0707D3     RCALL CalaAlarmTime
000326  784F00     MOV.B W0, [W14]
31:                    SetNextAlarm(tmp); //设置下次闹钟时间
000328  FB801E     ZE [W14], W0
00032A  EB0080     CLR W1
00032C  0708CD     RCALL SetNextAlarm
32:                    if (WGCCON2bits.Debug1) {//如果测试点1 时间输出测试
00032E  804051     MOV WGCCON2bits, W1
000330  202000     MOV #0x200, W0
000332  608000     AND W1, W0, W0
000334  E00000     CP0 W0
000336  320013     BRA Z, 0x35E
33:                        RS485SendString1("WGC\r\n");
000338  2910C0     MOV #0x910C, W0
00033A  07176F     RCALL RS485SendString1
34:                        printnums(tmp);
00033C  FB801E     ZE [W14], W0
00033E  EB0080     CLR W1
000340  07126C     RCALL printnums
35:                        if (WGCCON2bits.Sample_FLAG) {
000342  804051     MOV WGCCON2bits, W1
000344  210000     MOV #0x1000, W0
000346  608000     AND W1, W0, W0
000348  E00000     CP0 W0
00034A  320002     BRA Z, 0x350
36:                            //        WGCCON2bits.Sample_FLAG = 0;
37:                            RS485SendString1("Sample\r\n");
00034C  291120     MOV #0x9112, W0
00034E  071765     RCALL RS485SendString1
38:                        }
39:                        if (WGCCON2bits.Send_FLAG) {
000350  804051     MOV WGCCON2bits, W1
000352  220000     MOV #0x2000, W0
000354  608000     AND W1, W0, W0
000356  E00000     CP0 W0
000358  320002     BRA Z, 0x35E
40:                            //        WGCCON2bits.Send_FLAG = 0;
41:                            RS485SendString1("Send\r\n");
00035A  2911B0     MOV #0x911B, W0
00035C  07175E     RCALL RS485SendString1
42:                        }
43:                    }
44:                    IFS3bits.RTCIF = false;
00035E  A9C08B     BCLR 0x8B, #6
45:                }
000360  FA8000     ULNK
000362  BE034F     MOV.D [--W15], W6
000364  BE024F     MOV.D [--W15], W4
000366  BE014F     MOV.D [--W15], W2
000368  BE004F     MOV.D [--W15], W0
00036A  F90036     POP RCOUNT
00036C  064000     RETFIE
46:                
47:                /*************************************
48:                Function: 外部终端0
49:                Description: 电压检测
50:                Input: 无 
51:                Output: 无
52:                 *************************************/
53:                void __attribute__((interrupt, no_auto_psv))_ISR _INT0Interrupt(void) {
00036E  FA0000     LNK #0x0
54:                
55:                    IFS0bits.INT0IF = 0;
000370  A90084     BCLR IFS0, #0
56:                }
000372  FA8000     ULNK
000374  064000     RETFIE
57:                /*************************************
58:                Function: 定时器中断 
59:                Description: 用于在GPRS上线过程中，定时时间
60:                Input: 无 
61:                Output: 无
62:                 *************************************/
63:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
64:                //    gT3Count++;
65:                //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
66:                //}
67:                
68:                /*************************************
69:                Function: 定时器中断 
70:                Description: 用于485通讯，时间延时
71:                Input: 无 
72:                Output: 无
73:                 *************************************/
74:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
000376  FEA000     PUSH.S
000378  F80036     PUSH RCOUNT
00037A  BE9F84     MOV.D W4, [W15++]
00037C  BE9F86     MOV.D W6, [W15++]
00037E  F80032     PUSH DSRPAG
000380  F80034     PUSH DSWPAG
000382  200014     MOV #0x1, W4
000384  8801A4     MOV W4, DSWPAG
000386  202004     MOV #0x200, W4
000388  880194     MOV W4, DSRPAG
00038A  FA0000     LNK #0x0
75:                    StopTMR2(); //停止计时
00038C  071A26     RCALL StopTMR2
76:                    if (WGCCON2bits.Sample_FLAG) {
00038E  804051     MOV WGCCON2bits, W1
000390  210000     MOV #0x1000, W0
000392  608000     AND W1, W0, W0
000394  E00000     CP0 W0
000396  320007     BRA Z, 0x3A6
77:                        //#ifdef DEBUG_SAMPLE
78:                        //        for (main_cnt = 0; main_cnt < 2; main_cnt++) {
79:                        //            Delay100ms(3);
80:                        //            LED_Toggle();
81:                        //        }
82:                        //        RS485SendString1("\r\nStart Sample!!! count:");
83:                        //        //            Delay100ms(3);
84:                        //        printnums(WGCCNTbits.Sample_CNT++);
85:                        //        NUMS_SHOW(WGCCNTbits.Sample_CNT, 0);
86:                        //#endif
87:                        if (Sample_Task()) {
000398  070733     RCALL Sample_Task
00039A  E00400     CP0.B W0
00039C  320004     BRA Z, 0x3A6
88:                            LED_Toggle1(2, 4);
00039E  B3C041     MOV.B #0x4, W1
0003A0  B3C020     MOV.B #0x2, W0
0003A2  071974     RCALL LED_Toggle1
89:                            //#ifdef DEBUG_PRESSURE
90:                            //            RS485SendString1("\r\nCan't get pressure!!!\r\n");
91:                            //#endif
92:                
93:                            WGCCON2bits.Sample_FLAG = 0; //等同与定时器2标志位
0003A4  A9880B     BCLR 0x80B, #4
94:                        }
95:                    }
96:                    IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
0003A6  A9E084     BCLR IFS0, #7
97:                }
0003A8  FA8000     ULNK
0003AA  F90034     POP DSWPAG
0003AC  F90032     POP DSRPAG
0003AE  BE034F     MOV.D [--W15], W6
0003B0  BE024F     MOV.D [--W15], W4
0003B2  F90036     POP RCOUNT
0003B4  FE8000     POP.S
0003B6  064000     RETFIE
98:                
99:                /*************************************
100:               Function: 定时器中断 
101:               Description: LCD显示
102:               Input: 无 
103:               Output: 无
104:                *************************************/
105:               void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {//cvery second
0003B8  FEA000     PUSH.S
0003BA  F80036     PUSH RCOUNT
0003BC  BE9F84     MOV.D W4, [W15++]
0003BE  BE9F86     MOV.D W6, [W15++]
0003C0  F80032     PUSH DSRPAG
0003C2  F80034     PUSH DSWPAG
0003C4  200014     MOV #0x1, W4
0003C6  8801A4     MOV W4, DSWPAG
0003C8  202004     MOV #0x200, W4
0003CA  880194     MOV W4, DSRPAG
0003CC  FA0002     LNK #0x2
106:                   //    struct tm tmptr;
107:                   uint16_t pressure10 = 0;
0003CE  EB0000     CLR W0
0003D0  780F00     MOV W0, [W14]
108:                   static cop_cnt = 0;
109:               
110:                   switch (T0_Cnt++ % 4) {
0003D2  208281     MOV #0x828, W1
0003D4  784091     MOV.B [W1], W1
0003D6  FB8001     ZE W1, W0
0003D8  600063     AND W0, #0x3, W0
0003DA  E84081     INC.B W1, W1
0003DC  784181     MOV.B W1, W3
0003DE  208282     MOV #0x828, W2
0003E0  784903     MOV.B W3, [W2]
0003E2  E00000     CP0 W0
0003E4  320003     BRA Z, 0x3EC
0003E6  500FE2     SUB W0, #0x2, [W15]
0003E8  320023     BRA Z, 0x430
0003EA  370030     BRA 0x44C
111:                       case 0:
112:                       {
113:                           pressure10 = f_p * 100;
0003EC  8040F0     MOV f_p, W0
0003EE  804101     MOV 0x820, W1
0003F0  200002     MOV #0x0, W2
0003F2  242C83     MOV #0x42C8, W3
0003F4  0702A2     RCALL 0x93A
0003F6  07022E     RCALL 0x854
0003F8  780F00     MOV W0, [W14]
114:                           if (pressure10) {//如果压力值为0
0003FA  78001E     MOV [W14], W0
0003FC  E00000     CP0 W0
0003FE  32000A     BRA Z, 0x414
115:                               //                NUMS_SHOW((uint32_t) pressure10, 0);
116:                               W_LCDCON.LCD_Flagbits.F_DP = 2;
000400  8041D1     MOV W_LCDCON, W1
000402  27FFF0     MOV #0x7FFF, W0
000404  608000     AND W1, W0, W0
000406  8841D0     MOV W0, W_LCDCON
000408  8041E1     MOV 0x83C, W1
00040A  2FFFC0     MOV #0xFFFC, W0
00040C  608000     AND W1, W0, W0
00040E  A00000     BSET W0, #0
000410  8841E0     MOV W0, 0x83C
000412  370008     BRA 0x424
117:                           } else {
118:                               W_LCDCON.LCD_Flagbits.F_DP = 0;
000414  8041D1     MOV W_LCDCON, W1
000416  27FFF0     MOV #0x7FFF, W0
000418  608000     AND W1, W0, W0
00041A  8841D0     MOV W0, W_LCDCON
00041C  8041E1     MOV 0x83C, W1
00041E  2FFFC0     MOV #0xFFFC, W0
000420  608000     AND W1, W0, W0
000422  8841E0     MOV W0, 0x83C
119:                               //                NUMS_SHOW(0, 0);
120:                           }
121:                           W_LCDCON.LCD_Flagbits.F_KPa = 1;
000424  A8683B     BSET 0x83B, #3
122:                           W_LCDCON.LCD_Flagbits.F_Num = 1;
000426  A8483C     BSET 0x83C, #2
123:                           LCD_Task(pressure10); //执行LCD刷新任务
000428  78001E     MOV [W14], W0
00042A  EB0080     CLR W1
00042C  070DC1     RCALL LCD_Task
124:                           break;
00042E  37000E     BRA 0x44C
125:                       }
126:                       case 2:
127:                       {
128:                           W_LCDCON.LCD_Flagbits.F_KPa = 0;
000430  A9683B     BCLR 0x83B, #3
129:                           W_LCDCON.LCD_Flagbits.F_DP = 0;
000432  8041D1     MOV W_LCDCON, W1
000434  27FFF0     MOV #0x7FFF, W0
000436  608000     AND W1, W0, W0
000438  8841D0     MOV W0, W_LCDCON
00043A  8041E1     MOV 0x83C, W1
00043C  2FFFC0     MOV #0xFFFC, W0
00043E  608000     AND W1, W0, W0
000440  8841E0     MOV W0, 0x83C
130:                           W_LCDCON.LCD_Flagbits.F_Time = 1;
000442  A8683C     BSET 0x83C, #3
131:                           LCD_Task(pressure10); //执行LCD刷新任务
000444  78001E     MOV [W14], W0
000446  EB0080     CLR W1
000448  070DB3     RCALL LCD_Task
132:                           break;
00044A  000000     NOP
133:                       }
134:                   }
135:               
136:                   if (WGCCON2bits.PC_Cop_FLAG) {
00044C  804051     MOV WGCCON2bits, W1
00044E  280000     MOV #0x8000, W0
000450  608000     AND W1, W0, W0
000452  E00000     CP0 W0
000454  32000B     BRA Z, 0x46C
137:                       if (cop_cnt > 1) {//接收数据1s后，在指令
000456  804190     MOV cop_cnt, W0
000458  500FE1     SUB W0, #0x1, [W15]
00045A  340005     BRA LE, 0x466
138:                           cop_cnt = 0;
00045C  EF2832     CLR cop_cnt
139:                           U1Rx4Byte(); //接收最后小于4字节的数据，
00045E  0716FF     RCALL U1Rx4Byte
140:                           WGCPCCop();
000460  07088B     RCALL WGCPCCop
141:                           //if (WGCPCCop())
142:                           //ClearBuffer(UART1_ReadBuf); //处理用户通讯交互任务
143:                           WGCCON2bits.PC_Cop_FLAG = 0;
000462  A9E80B     BCLR 0x80B, #7
000464  370003     BRA 0x46C
144:                       } else
145:                           cop_cnt += 1;
000466  804190     MOV cop_cnt, W0
000468  E80000     INC W0, W0
00046A  884190     MOV W0, cop_cnt
146:                   }
147:                   IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
00046C  A96084     BCLR IFS0, #3
148:               }
00046E  FA8000     ULNK
000470  F90034     POP DSWPAG
000472  F90032     POP DSRPAG
000474  BE034F     MOV.D [--W15], W6
000476  BE024F     MOV.D [--W15], W4
000478  F90036     POP RCOUNT
00047A  FE8000     POP.S
00047C  064000     RETFIE
149:               
150:               /*************************************
151:               Function: 定时器t4中断 
152:               Description: 用于采集数据的任务
153:               Input: 无 
154:               Output: 无
155:                *************************************/
156:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
157:               //    if (FLagArgbits.LowPowerGetDataFlag) {
158:               //        FLagArgbits.LowPowerGetDataFlag = 0;
159:               //        GetValueTask(LowPowerData); //获取报警时仪表的通讯数据
160:               //    } else if (FLagArgbits.TestGetDataFlag) {
161:               //        FLagArgbits.TestGetDataFlag = 0;
162:               //        GetValueTask(TestData); //获取报警时仪表的通讯数据
163:               //    } else
164:               //        GetValueTask(SampleData); //获取仪表的通讯数据
165:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //保存脉冲总量
166:               //
167:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
168:               //    CloseTime4();
169:               //}
170:               
171:               /*************************************
172:               Function: 电平变化中断 
173:               Description: 获取脉冲的任务
174:               Input: 无 
175:               Output: 无
176:                *************************************/
177:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //提醒更换电池
178:               //    if (S1) {//通过第二次上升获取数据
179:               //        gPulseCount++; //脉冲数+1
180:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//如果开启T1定时器而且是第二次进入，则采集数据
181:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //单位ms
182:               //            if (gPulseTime < 2000)//采集时间小于2s
183:               //                gPulseTime = 0;
184:               //            else {
185:               //                FLagArgbits.PulseTimeFlag = 1; // 如果已经获取到脉冲时间，那么需要关闭定时器
186:               //                FLagArgbits.T1CountFlag = 0;
187:               //                T1CONbits.TON = 0;
188:               //            }
189:               //        }
190:               //        TMR1 = 0;
191:               //        gT1Count = 0;
192:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //通过上升沿，关闭FLagArgbits.T1CountLastFlag
193:               //    }
194:               //    IFS1bits.CNIF = 0;
195:               //}
196:               
197:               /*************************************
198:               Function: UART1接收中断
199:               Description: 485通讯
200:               Input: 无 
201:               Output: 无
202:                *************************************/
203:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void) {
00047E  F80036     PUSH RCOUNT
000480  BE9F80     MOV.D W0, [W15++]
000482  BE9F82     MOV.D W2, [W15++]
000484  BE9F84     MOV.D W4, [W15++]
000486  BE9F86     MOV.D W6, [W15++]
000488  FA0002     LNK #0x2
204:                   uint8_t cnt = 0;
00048A  EB4000     CLR.B W0
00048C  784F00     MOV.B W0, [W14]
205:               
206:                   WGCCON2bits.PC_Cop_FLAG = 1; //表示PC正在和设备通讯
00048E  A8E80B     BSET 0x80B, #7
207:                   for (cnt = 0; cnt < 4; cnt++)
000490  EB4000     CLR.B W0
000492  784F00     MOV.B W0, [W14]
000494  370006     BRA 0x4A2
0004A0  E84F1E     INC.B [W14], [W14]
0004A2  78401E     MOV.B [W14], W0
0004A4  504FE3     SUB.B W0, #0x3, [W15]
0004A6  36FFF7     BRA LEU, 0x496
208:                       if (U1STAbits.URXDA) //没有接收到
000496  801110     MOV U1STA, W0
000498  600061     AND W0, #0x1, W0
00049A  E00000     CP0 W0
00049C  320001     BRA Z, 0x4A0
209:                           BufferWrite_UART1();
00049E  0711CF     RCALL BufferWrite_UART1
210:                   IFS0bits.U1RXIF = 0;
0004A8  A96085     BCLR 0x85, #3
211:               }
0004AA  FA8000     ULNK
0004AC  BE034F     MOV.D [--W15], W6
0004AE  BE024F     MOV.D [--W15], W4
0004B0  BE014F     MOV.D [--W15], W2
0004B2  BE004F     MOV.D [--W15], W0
0004B4  F90036     POP RCOUNT
0004B6  064000     RETFIE
212:               
213:               /*************************************
214:               Function: UART2接收中断
215:               Description: GPRS通讯
216:               Input: 无 
217:               Output: 无
218:                *************************************/
219:               void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt(void) {
0004B8  F80036     PUSH RCOUNT
0004BA  BE9F80     MOV.D W0, [W15++]
0004BC  BE9F82     MOV.D W2, [W15++]
0004BE  BE9F84     MOV.D W4, [W15++]
0004C0  BE9F86     MOV.D W6, [W15++]
0004C2  FA0002     LNK #0x2
220:                   uint8_t cnt = 0;
0004C4  EB4000     CLR.B W0
0004C6  784F00     MOV.B W0, [W14]
221:               
222:                   for (cnt = 0; cnt < 4; cnt++)
0004C8  EB4000     CLR.B W0
0004CA  784F00     MOV.B W0, [W14]
0004CC  370006     BRA 0x4DA
0004D8  E84F1E     INC.B [W14], [W14]
0004DA  78401E     MOV.B [W14], W0
0004DC  504FE3     SUB.B W0, #0x3, [W15]
0004DE  36FFF7     BRA LEU, 0x4CE
223:                       if (U2STAbits.URXDA == 1) //没有接收到        
0004CE  801190     MOV U2STA, W0
0004D0  600061     AND W0, #0x1, W0
0004D2  E00000     CP0 W0
0004D4  320001     BRA Z, 0x4D8
224:                           BufferWrite_UART2();
0004D6  0711CC     RCALL BufferWrite_UART2
225:                   IFS1bits.U2RXIF = 0;
0004E0  A9C087     BCLR 0x87, #6
226:               }
0004E2  FA8000     ULNK
0004E4  BE034F     MOV.D [--W15], W6
0004E6  BE024F     MOV.D [--W15], W4
0004E8  BE014F     MOV.D [--W15], W2
0004EA  BE004F     MOV.D [--W15], W0
0004EC  F90036     POP RCOUNT
0004EE  064000     RETFIE
227:               
228:               /*************************************
229:               Function: UART2接收中断
230:               Description: GPRS通讯
231:               Input: 无 
232:               Output: 无
233:                *************************************/
234:               void __attribute__((interrupt, no_auto_psv)) _U3RXInterrupt(void) {
0004F0  F80036     PUSH RCOUNT
0004F2  BE9F80     MOV.D W0, [W15++]
0004F4  BE9F82     MOV.D W2, [W15++]
0004F6  BE9F84     MOV.D W4, [W15++]
0004F8  BE9F86     MOV.D W6, [W15++]
0004FA  FA0002     LNK #0x2
235:                   uint8_t cnt = 0;
0004FC  EB4000     CLR.B W0
0004FE  784F00     MOV.B W0, [W14]
236:               
237:                   for (cnt = 0; cnt < 4; cnt++)
000500  EB4000     CLR.B W0
000502  784F00     MOV.B W0, [W14]
000504  370006     BRA 0x512
000510  E84F1E     INC.B [W14], [W14]
000512  78401E     MOV.B [W14], W0
000514  504FE3     SUB.B W0, #0x3, [W15]
000516  36FFF7     BRA LEU, 0x506
238:                       if (U3STAbits.URXDA == 1) //没有接收到        
000506  801290     MOV U3STA, W0
000508  600061     AND W0, #0x1, W0
00050A  E00000     CP0 W0
00050C  320001     BRA Z, 0x510
239:                           BufferWrite_UART3();
00050E  0711CB     RCALL BufferWrite_UART3
240:                   IFS5bits.U3RXIF = 0;
000518  A9408E     BCLR IFS5, #2
241:               }
00051A  FA8000     ULNK
00051C  BE034F     MOV.D [--W15], W6
00051E  BE024F     MOV.D [--W15], W4
000520  BE014F     MOV.D [--W15], W2
000522  BE004F     MOV.D [--W15], W0
000524  F90036     POP RCOUNT
000526  064000     RETFIE
242:               
243:               /*************************************
244:               Function: UART1错误终端
245:               Description: 无
246:               Input: 无 
247:               Output: 无
248:                *************************************/
249:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
000528  781F80     MOV W0, [W15++]
00052A  FA0000     LNK #0x0
250:               
251:                   if (U1STAbits.OERR)
00052C  801110     MOV U1STA, W0
00052E  600062     AND W0, #0x2, W0
000530  E00000     CP0 W0
000532  320001     BRA Z, 0x536
252:                       U1STAbits.OERR = 0;
000534  A92222     BCLR U1STA, #1
253:                   if (U1STAbits.FERR) {//mark
000536  801110     MOV U1STA, W0
000538  600064     AND W0, #0x4, W0
00053A  E00000     CP0 W0
00053C  320001     BRA Z, 0x540
254:                       //        U1RXREG = U1RXREG;
255:                       U1STAbits.FERR = 0;
00053E  A94222     BCLR U1STA, #2
256:                   }
257:                   if (U1STAbits.PERR)
000540  801110     MOV U1STA, W0
000542  600068     AND W0, #0x8, W0
000544  E00000     CP0 W0
000546  320001     BRA Z, 0x54A
258:                       U1STAbits.PERR = 0;
000548  A96222     BCLR U1STA, #3
259:                   IFS4bits.U1ERIF = 0;
00054A  A9208C     BCLR IFS4, #1
260:               
261:               }
00054C  FA8000     ULNK
00054E  78004F     MOV [--W15], W0
000550  064000     RETFIE
262:               
263:               /*************************************
264:               Function: UART2错误中断
265:               Description: 无
266:               Input: 无 
267:               Output: 无
268:                *************************************/
269:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
000552  781F80     MOV W0, [W15++]
000554  FA0000     LNK #0x0
270:               
271:                   if (U2STAbits.OERR == 1)
000556  801190     MOV U2STA, W0
000558  600062     AND W0, #0x2, W0
00055A  E00000     CP0 W0
00055C  320001     BRA Z, 0x560
272:                       U2STAbits.OERR = 0;
00055E  A92232     BCLR U2STA, #1
273:                   IFS4bits.U2ERIF = 0;
000560  A9408C     BCLR IFS4, #2
274:               
275:               }
000562  FA8000     ULNK
000564  78004F     MOV [--W15], W0
000566  064000     RETFIE
276:               
277:               /*************************************
278:               Function: UART2错误中断
279:               Description: 无
280:               Input: 无 
281:               Output: 无
282:                *************************************/
283:               void __attribute__((interrupt, no_auto_psv)) _U3ErrInterrupt(void) {
000568  781F80     MOV W0, [W15++]
00056A  FA0000     LNK #0x0
284:               
285:                   if (U3STAbits.OERR == 1)
00056C  801290     MOV U3STA, W0
00056E  600062     AND W0, #0x2, W0
000570  E00000     CP0 W0
000572  320001     BRA Z, 0x576
286:                       U3STAbits.OERR = 0;
000574  A92252     BCLR U3STA, #1
287:                   IFS5bits.U3ERIF = 0;
000576  A9208E     BCLR IFS5, #1
288:               
289:               }
000578  FA8000     ULNK
00057A  78004F     MOV [--W15], W0
00057C  064000     RETFIE
290:               
291:               /*************************************
292:               Function: 默认终端
293:               Description: 无
294:               Input: 无 
295:               Output: 无
296:                *************************************/
297:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
00057E  F80036     PUSH RCOUNT
000580  BE9F80     MOV.D W0, [W15++]
000582  BE9F82     MOV.D W2, [W15++]
000584  BE9F84     MOV.D W4, [W15++]
000586  BE9F86     MOV.D W6, [W15++]
000588  FA0000     LNK #0x0
298:                   RS485SendString1("\r\nDefaultInt:");
00058A  291220     MOV #0x9122, W0
00058C  071646     RCALL RS485SendString1
299:                   printnums(INTCON1);
00058E  800400     MOV INTCON1, W0
000590  EB0080     CLR W1
000592  071143     RCALL printnums
300:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
000594  800400     MOV INTCON1, W0
000596  600064     AND W0, #0x4, W0
000598  E00000     CP0 W0
00059A  320001     BRA Z, 0x59E
00059C  A94080     BCLR INTCON1, #2
301:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
00059E  800400     MOV INTCON1, W0
0005A0  600068     AND W0, #0x8, W0
0005A2  E00000     CP0 W0
0005A4  320001     BRA Z, 0x5A8
0005A6  A96080     BCLR INTCON1, #3
302:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
0005A8  800400     MOV INTCON1, W0
0005AA  600070     AND W0, #0x10, W0
0005AC  E00000     CP0 W0
0005AE  320001     BRA Z, 0x5B2
0005B0  A98080     BCLR INTCON1, #4
303:                   asm("GOTO __reset");
0005B2  040200     GOTO 0x200
0005B4  000000     NOP
304:                   //    Reset();
305:                   //    Sleep();
306:               }
0005B6  FA8000     ULNK
0005B8  BE034F     MOV.D [--W15], W6
0005BA  BE024F     MOV.D [--W15], W4
0005BC  BE014F     MOV.D [--W15], W2
0005BE  BE004F     MOV.D [--W15], W0
0005C0  F90036     POP RCOUNT
0005C2  064000     RETFIE
307:               
308:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
0005C4  BE9F80     MOV.D W0, [W15++]
0005C6  BE9F82     MOV.D W2, [W15++]
0005C8  FA0000     LNK #0x0
309:               
310:                   static uint16_t i2c_operatcode;
311:                   static uint8_t* pi2c_buf_ptr;
312:                   static uint16_t i2c_address;
313:                   static uint8_t i2c_bytes_left;
314:                   static I2C_Flag i2c_flag;
315:                   static bool i2c_IsResart; //设备是否重启
316:               
317:               
318:                   if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
0005CA  801041     MOV I2C1STAT, W1
0005CC  200800     MOV #0x80, W0
0005CE  608000     AND W1, W0, W0
0005D0  E00000     CP0 W0
0005D2  320002     BRA Z, 0x5D8
319:                       I2C1STATbits.IWCOL = 0;
0005D4  A9E208     BCLR I2C1STAT, #7
320:                       //        i2c_address_restart = 0;
321:                       //是否需要清楚数据
322:                       return;
0005D6  3700F7     BRA 0x7C6
323:                   }
324:                   /* Handle the correct i2c state */
325:                   switch (i2c1_state) {
0005D8  BFC842     MOV.B i2c1_state, WREG
0005DA  FB8000     ZE W0, W0
0005DC  DE80CF     ASR W0, #15, W1
0005DE  2000D2     MOV #0xD, W2
0005E0  200003     MOV #0x0, W3
0005E2  500F82     SUB W0, W2, [W15]
0005E4  588F83     SUBB W1, W3, [W15]
0005E6  3E00EE     BRA GTU, 0x7C4
0005E8  016000     BRA W0
0005EA  37000D     BRA 0x606
0005EC  370023     BRA 0x634
0005EE  370029     BRA 0x642
0005F0  37007E     BRA 0x6EE
0005F2  370052     BRA 0x698
0005F4  3700E7     BRA 0x7C4
0005F6  3700C8     BRA 0x788
0005F8  37009A     BRA 0x72E
0005FA  3700A8     BRA 0x74C
0005FC  3700C0     BRA 0x77E
0005FE  3700AA     BRA 0x754
000600  3700E1     BRA 0x7C4
000602  3700E0     BRA 0x7C4
000604  3700C5     BRA 0x790
326:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
327:                       {
328:                           if (i2c_bytes_left == 0) {//如果数据数据不为0的话
000606  BFC829     MOV.B i2c_bytes_left, WREG
000608  E00400     CP0.B W0
00060A  3A00DB     BRA NZ, 0x7C2
329:                               //                I2C1CONbits.SEN = 1; // 发送启动条件
330:                               //            } else {
331:                               I2C1CONbits.SEN = 1; // 发送启动条件
00060C  A80206     BSET I2C1CON, #0
332:                               i2c_operatcode = i2c_buf.operatcode; //赋值操作码
00060E  209320     MOV #0x932, W0
000610  784010     MOV.B [W0], W0
000612  FB8000     ZE W0, W0
000614  884150     MOV W0, i2c_operatcode
333:                               i2c_address = i2c_buf.address; //赋值地址
000616  8049A0     MOV 0x934, W0
000618  884160     MOV W0, i2c_address
334:                               i2c_bytes_left = i2c_buf.length; //赋值长度
00061A  209360     MOV #0x936, W0
00061C  784010     MOV.B [W0], W0
00061E  B7E829     MOV.B WREG, i2c_bytes_left
335:                               pi2c_buf_ptr = i2c_buf.pbuffer; //赋值数据地址
000620  8049C0     MOV 0x938, W0
000622  884170     MOV W0, pi2c_buf_ptr
336:                               i2c_flag = i2c_buf.flag; //将设备选择和工作模式均赋值
000624  2093A0     MOV #0x93A, W0
000626  784110     MOV.B [W0], W2
000628  208301     MOV #0x830, W1
00062A  784882     MOV.B W2, [W1]
337:                               i2c_IsResart = 0;
00062C  EF6831     CLR.B i2c_IsResart
338:                               i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
00062E  B3C020     MOV.B #0x2, W0
000630  B7E842     MOV.B WREG, i2c1_state
339:                           }
340:                           break;
000632  3700C8     BRA 0x7C4
0007C2  000000     NOP
341:                       }
342:                       case S_MASTER_RESTART:
343:                       {
344:                           I2C1CONbits.RSEN = 1; // 发送启动条件
000634  A82206     BSET I2C1CON, #1
345:                           i2c_bytes_left = i2c_buf.length; //赋值长度
000636  209360     MOV #0x936, W0
000638  784010     MOV.B [W0], W0
00063A  B7E829     MOV.B WREG, i2c_bytes_left
346:                           i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
00063C  B3C020     MOV.B #0x2, W0
00063E  B7E842     MOV.B WREG, i2c1_state
347:                           break;
000640  3700C1     BRA 0x7C4
348:                       }
349:                       case S_MASTER_SEND_ADDR:
350:                       {
351:                           if (!i2c_flag.F_IsSelectiveMode) {//表示不带地址读取数据 && i2c_IsResart) {
000642  BFC830     MOV.B i2c_flag, WREG
000644  604061     AND.B W0, #0x1, W0
000646  E00400     CP0.B W0
000648  3A000F     BRA NZ, 0x668
352:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
00064A  BFC830     MOV.B i2c_flag, WREG
00064C  604064     AND.B W0, #0x4, W0
00064E  E00400     CP0.B W0
000650  320006     BRA Z, 0x65E
353:                                   I2C1TRN = i2c_operatcode | 0x01;
000652  804150     MOV i2c_operatcode, W0
000654  A00000     BSET W0, #0
000656  881010     MOV W0, I2C1TRN
354:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作
000658  B3C070     MOV.B #0x7, W0
00065A  B7E842     MOV.B WREG, i2c1_state
355:                               } else {
356:                                   I2C1TRN = i2c_operatcode;
00065E  804150     MOV i2c_operatcode, W0
000660  881010     MOV W0, I2C1TRN
357:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
000662  B3C030     MOV.B #0x3, W0
000664  B7E842     MOV.B WREG, i2c1_state
358:                               }
359:                           } else if (!i2c_IsResart) {//如果是重启后的操作码，则根据操作码最后一个字节处理；反之,这
000668  BFC831     MOV.B i2c_IsResart, WREG
00066A  A20400     BTG.B W0, #0
00066C  E00400     CP0.B W0
00066E  320005     BRA Z, 0x67A
360:                               I2C1TRN = i2c_operatcode;
000670  804150     MOV i2c_operatcode, W0
000672  881010     MOV W0, I2C1TRN
361:                               i2c1_state = S_MASTER_SEND_ADDR_16BIT;
000674  B3C040     MOV.B #0x4, W0
000676  B7E842     MOV.B WREG, i2c1_state
362:                           } else {//就是跟读地址读写数据的后半段
363:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
00067A  BFC830     MOV.B i2c_flag, WREG
00067C  604064     AND.B W0, #0x4, W0
00067E  E00400     CP0.B W0
000680  320006     BRA Z, 0x68E
364:                                   I2C1TRN = i2c_operatcode | 0x01;
000682  804150     MOV i2c_operatcode, W0
000684  A00000     BSET W0, #0
000686  881010     MOV W0, I2C1TRN
365:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作                    
000688  B3C070     MOV.B #0x7, W0
00068A  B7E842     MOV.B WREG, i2c1_state
366:                               } else {
367:                                   I2C1TRN = i2c_operatcode;
00068E  804150     MOV i2c_operatcode, W0
000690  881010     MOV W0, I2C1TRN
368:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
000692  B3C030     MOV.B #0x3, W0
000694  B7E842     MOV.B WREG, i2c1_state
369:                               }
370:                           }
371:                           break;
00065C  3700B3     BRA 0x7C4
000666  3700AE     BRA 0x7C4
000678  3700A5     BRA 0x7C4
00068C  37009B     BRA 0x7C4
000696  370096     BRA 0x7C4
372:                       }
373:                       case S_MASTER_SEND_ADDR_16BIT:
374:                       {
375:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
000698  801041     MOV I2C1STAT, W1
00069A  280000     MOV #0x8000, W0
00069C  608000     AND W1, W0, W0
00069E  E00000     CP0 W0
0006A0  320006     BRA Z, 0x6AE
376:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
0006A2  A9E209     BCLR 0x209, #7
377:                               I2C1CONbits.PEN = 1; // 发送停止条件 
0006A4  A84206     BSET I2C1CON, #2
378:                               IFS1bits.MI2C1IF = 0; //清除标志
0006A6  A92086     BCLR IFS1, #1
379:                               i2c1_state = S_MASTER_Fail; //状态设置位空闲
0006A8  B3C0E0     MOV.B #0xE, W0
0006AA  B7E842     MOV.B WREG, i2c1_state
380:                           } else {
381:                               if (i2c_flag.F_Is16bitsDevice) {
0006AE  BFC830     MOV.B i2c_flag, WREG
0006B0  604062     AND.B W0, #0x2, W0
0006B2  E00400     CP0.B W0
0006B4  320009     BRA Z, 0x6C8
382:                                   i2c_flag.F_Is16bitsDevice = 0;
0006B6  A92830     BCLR i2c_flag, #1
383:                                   I2C1TRN = (uint8_t) (i2c_address >> 8); //发送16位高地址 
0006B8  804160     MOV i2c_address, W0
0006BA  DE0048     LSR W0, #8, W0
0006BC  784000     MOV.B W0, W0
0006BE  FB8000     ZE W0, W0
0006C0  881010     MOV W0, I2C1TRN
384:                                   i2c1_state = S_MASTER_SEND_ADDR_16BIT;
0006C2  B3C040     MOV.B #0x4, W0
0006C4  B7E842     MOV.B WREG, i2c1_state
385:                                   //                    break;
386:                               } else {
387:                                   I2C1TRN = (uint8_t) (i2c_address & 0x00FF); //发送16位低地址 
0006C8  804160     MOV i2c_address, W0
0006CA  784000     MOV.B W0, W0
0006CC  FB8000     ZE W0, W0
0006CE  881010     MOV W0, I2C1TRN
388:                                   if (i2c_flag.F_WriteOrRead)//如果是读取指令的话
0006D0  BFC830     MOV.B i2c_flag, WREG
0006D2  604064     AND.B W0, #0x4, W0
0006D4  E00400     CP0.B W0
0006D6  320008     BRA Z, 0x6E8
389:                                   {
390:                                       i2c_IsResart = 1;
0006D8  B3C010     MOV.B #0x1, W0
0006DA  B7E831     MOV.B WREG, i2c_IsResart
391:                                       //                        I2C1CONbits.RSEN = 1; // 发送启动条件
392:                                       i2c_operatcode |= 0x01; //将地址设置为读取
0006DC  804150     MOV i2c_operatcode, W0
0006DE  A00000     BSET W0, #0
0006E0  884150     MOV W0, i2c_operatcode
393:                                       i2c1_state = S_MASTER_RESTART;
0006E2  B3C010     MOV.B #0x1, W0
0006E4  B7E842     MOV.B WREG, i2c1_state
394:                                   } else
395:                                       i2c1_state = S_MASTER_SEND_DATA;
0006E8  B3C030     MOV.B #0x3, W0
0006EA  B7E842     MOV.B WREG, i2c1_state
396:                               }
397:                           }
398:                           break;
0006AC  37008B     BRA 0x7C4
0006C6  37007E     BRA 0x7C4
0006E6  37006E     BRA 0x7C4
0006EC  37006B     BRA 0x7C4
399:                       }
400:                       case S_MASTER_SEND_DATA:
401:                       {
402:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
0006EE  801041     MOV I2C1STAT, W1
0006F0  280000     MOV #0x8000, W0
0006F2  608000     AND W1, W0, W0
0006F4  E00000     CP0 W0
0006F6  320006     BRA Z, 0x704
403:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
0006F8  A9E209     BCLR 0x209, #7
404:                               I2C1CONbits.PEN = 1; // 发送停止条件 
0006FA  A84206     BSET I2C1CON, #2
405:                               IFS1bits.MI2C1IF = 0; //清除标志
0006FC  A92086     BCLR IFS1, #1
406:                               i2c1_state = S_MASTER_Fail; //状态设置位空闲
0006FE  B3C0E0     MOV.B #0xE, W0
000700  B7E842     MOV.B WREG, i2c1_state
000702  370015     BRA 0x72E
407:                           } else {
408:                               if (i2c_bytes_left-- == 0U) {//判断数据是否发送完毕
000704  BFC829     MOV.B i2c_bytes_left, WREG
000706  FB8080     ZE W0, W1
000708  E90081     DEC W1, W1
00070A  DE08CF     LSR W1, #15, W1
00070C  784081     MOV.B W1, W1
00070E  E94000     DEC.B W0, W0
000710  B7E829     MOV.B WREG, i2c_bytes_left
000712  E00401     CP0.B W1
000714  320005     BRA Z, 0x720
409:                                   I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000716  A84206     BSET I2C1CON, #2
410:                                   IFS1bits.MI2C1IF = 0; //清除标志
000718  A92086     BCLR IFS1, #1
411:                                   i2c1_state = S_MASTER_SEND_STOP; //状态设置为空闲
00071A  B3C060     MOV.B #0x6, W0
00071C  B7E842     MOV.B WREG, i2c1_state
412:                               } else {
413:                                   I2C1TRN = *pi2c_buf_ptr++; //发送数据
000720  804170     MOV pi2c_buf_ptr, W0
000722  784090     MOV.B [W0], W1
000724  FB8081     ZE W1, W1
000726  881011     MOV W1, I2C1TRN
000728  E80000     INC W0, W0
00072A  884170     MOV W0, pi2c_buf_ptr
414:                               }
415:                               break;
00071E  370052     BRA 0x7C4
00072C  37004B     BRA 0x7C4
416:                           }
417:                       }
418:                       case S_MASTER_ACK_ADDR://如果是读操作的话，
419:                       {
420:                           if (I2C1STATbits.ACKSTAT) { //如果上次检测到NACK
00072E  801041     MOV I2C1STAT, W1
000730  280000     MOV #0x8000, W0
000732  608000     AND W1, W0, W0
000734  E00000     CP0 W0
000736  320006     BRA Z, 0x744
421:                               I2C1CONbits.PEN = 1; //启动停止条件
000738  A84206     BSET I2C1CON, #2
422:                               IFS1bits.MI2C1IF = 0; //清除标志
00073A  A92086     BCLR IFS1, #1
423:                               i2c1_state = S_MASTER_Fail;
00073C  B3C0E0     MOV.B #0xE, W0
00073E  B7E842     MOV.B WREG, i2c1_state
424:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
000740  A9E209     BCLR 0x209, #7
425:                           } else {
426:                               I2C1CONbits.RCEN = 1; //启动接受
000744  A86206     BSET I2C1CON, #3
427:                               i2c1_state = S_MASTER_ACK_RCV_DATA; //状态为设置为接受数据
000746  B3C0A0     MOV.B #0xA, W0
000748  B7E842     MOV.B WREG, i2c1_state
428:                           }
429:                           break;
000742  370040     BRA 0x7C4
00074A  37003C     BRA 0x7C4
430:                       }
431:                       case S_MASTER_RCV_DATA:
432:                       {
433:                           i2c1_state = S_MASTER_ACK_RCV_DATA; //发送接受数据ACK
00074C  B3C0A0     MOV.B #0xA, W0
00074E  B7E842     MOV.B WREG, i2c1_state
434:                           I2C1CONbits.RCEN = 1; //使能接收
000750  A86206     BSET I2C1CON, #3
435:                           break;
000752  370038     BRA 0x7C4
436:                       }
437:                       case S_MASTER_ACK_RCV_DATA:
438:                       {
439:                           *pi2c_buf_ptr++ = I2C1RCV; //接收数据
000754  804170     MOV pi2c_buf_ptr, W0
000756  801001     MOV I2C1RCV, W1
000758  784081     MOV.B W1, W1
00075A  784801     MOV.B W1, [W0]
00075C  E80000     INC W0, W0
00075E  884170     MOV W0, pi2c_buf_ptr
440:                           if (--i2c_bytes_left) {
000760  BFC829     MOV.B i2c_bytes_left, WREG
000762  E94000     DEC.B W0, W0
000764  B7E829     MOV.B WREG, i2c_bytes_left
000766  BFC829     MOV.B i2c_bytes_left, WREG
000768  E00400     CP0.B W0
00076A  320004     BRA Z, 0x774
441:                               I2C1CONbits.ACKDT = 0; //发送ACK
00076C  A9A206     BCLR I2C1CON, #5
442:                               i2c1_state = S_MASTER_RCV_DATA; //启动接收
00076E  B3C080     MOV.B #0x8, W0
000770  B7E842     MOV.B WREG, i2c1_state
000772  370003     BRA 0x77A
443:                           } else {
444:               
445:                               // Yes, it's the last byte.  Don't ack it
446:                               // Flag that we will nak the data
447:                               I2C1CONbits.ACKDT = 1; // I2C ACK data control bit.
000774  A8A206     BSET I2C1CON, #5
448:               
449:                               //            I2C1_FunctionComplete();
450:                               i2c1_state = S_MASTER_RCV_STOP;
000776  B3C090     MOV.B #0x9, W0
000778  B7E842     MOV.B WREG, i2c1_state
451:                               //                break; //退出接收
452:                           }
453:               
454:                           // Initiate the acknowledge
455:                           I2C1CONbits.ACKEN = 1; // I2C 发送ACK .
00077A  A88206     BSET I2C1CON, #4
456:                           break;
00077C  370023     BRA 0x7C4
457:                       }
458:                       case S_MASTER_RCV_STOP:
459:                       {
460:                           I2C1CONbits.ACKDT = 0;
00077E  A9A206     BCLR I2C1CON, #5
461:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000780  A84206     BSET I2C1CON, #2
462:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
463:                           i2c1_state = S_MASTER_Finish;
000782  B3C0D0     MOV.B #0xD, W0
000784  B7E842     MOV.B WREG, i2c1_state
464:                           break;
000786  37001E     BRA 0x7C4
465:                       }
466:                       case S_MASTER_SEND_STOP:
467:                       {
468:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000788  A84206     BSET I2C1CON, #2
469:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
470:                           i2c1_state = S_MASTER_Finish;
00078A  B3C0D0     MOV.B #0xD, W0
00078C  B7E842     MOV.B WREG, i2c1_state
471:                           break;
00078E  37001A     BRA 0x7C4
472:                       }
473:                       case S_MASTER_Finish:
474:                       {
475:                           i2c_operatcode = 0;
000790  EF282A     CLR i2c_operatcode
476:                           pi2c_buf_ptr = NULL;
000792  EF282E     CLR pi2c_buf_ptr
477:                           i2c_address = 0;
000794  EF282C     CLR i2c_address
478:                           i2c_bytes_left = 0;
000796  EF6829     CLR.B i2c_bytes_left
479:                           i2c_flag.F_Is16bitsDevice = i2c_flag.F_IsSelectiveMode = i2c_flag.F_WriteOrRead = 0;
000798  A94830     BCLR i2c_flag, #2
00079A  804180     MOV i2c_flag, W0
00079C  DE0042     LSR W0, #2, W0
00079E  604061     AND.B W0, #0x1, W0
0007A0  604061     AND.B W0, #0x1, W0
0007A2  208301     MOV #0x830, W1
0007A4  784091     MOV.B [W1], W1
0007A6  A10401     BCLR.B W1, #0
0007A8  70C000     IOR.B W1, W0, W0
0007AA  B7E830     MOV.B WREG, i2c_flag
0007AC  804180     MOV i2c_flag, W0
0007AE  604061     AND.B W0, #0x1, W0
0007B0  604061     AND.B W0, #0x1, W0
0007B2  404000     ADD.B W0, W0, W0
0007B4  208301     MOV #0x830, W1
0007B6  784091     MOV.B [W1], W1
0007B8  A11401     BCLR.B W1, #1
0007BA  70C000     IOR.B W1, W0, W0
0007BC  B7E830     MOV.B WREG, i2c_flag
480:                           i2c_IsResart = 0; //设备是否重启
0007BE  EF6831     CLR.B i2c_IsResart
481:                           break;
0007C0  370001     BRA 0x7C4
482:                       }
483:               
484:                           //        default:
485:                           //
486:                           //            // This case should not happen, if it does then
487:                           //            // terminate the transfer
488:                           //            //    i2c1_object.i2cErrors++;
489:                           //        {
490:                           //            I2C1CONbits.PEN = 1; // I2C STOP control bit.  
491:                           //            //            IFS1bits.MI2C1IF = 0; //清除标志
492:                           //            //            i2c1_state = S_MASTER_IDLE;
493:                           //            break;
494:                           //        }
495:                   }
496:               
497:                   IFS1bits.MI2C1IF = 0; //清楚中断标志位
0007C4  A92086     BCLR IFS1, #1
498:               }
0007C6  FA8000     ULNK
499:               
500:               
501:               
502:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/LCD.c  ---------------------------------------
1:                 #include <time.h>
2:                 #include "LCD.h"
3:                 
4:                 union LCD_FLAGBITS W_LCDCON;
5:                 
6:                 //数字符号
7:                 const uint8_t LCD_NUM[10][8] = {
8:                     {N1A, N1B, N1C, N1D, N1E, N1F, 0xFF, N1G}, //[0]0xFF后面数据为HIDE
9:                     {N1B, N1C, 0xFF, N1A, N1D, N1E, N1F, N1G}, //[1]
10:                    {N1A, N1B, N1G, N1E, N1D, 0xFF, N1C, N1F}, //[2]
11:                    {N1A, N1B, N1C, N1D, N1G, 0xFF, N1E, N1F}, //[3]
12:                    {N1B, N1C, N1F, N1G, 0xFF, N1A, N1D, N1E}, //[4]
13:                    {N1A, N1C, N1D, N1F, N1G, 0xFF, N1B, N1E}, //[5]
14:                    {N1A, N1C, N1D, N1E, N1F, N1G, 0xFF, N1B}, //[6]
15:                    {N1A, N1B, N1C, 0xFF, N1D, N1E, N1F, N1G}, //[7]
16:                    {N1A, N1B, N1C, N1D, N1E, N1F, N1G, 0xFF}, //[8]
17:                    {N1A, N1B, N1C, N1D, N1F, N1G, 0xFF, N1E}, //[9]
18:                    //    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, //[10]
19:                };
20:                //数字偏移量
21:                const uint8_t LCD_NUM_OFFSET[7] = {0, 2, 8, 10, 12, 14, 16};
22:                
23:                static void LCD_Show(uint16_t value, bool operation);
24:                static void NUM_SHOW(uint8_t num, uint8_t pos);
25:                
26:                void LCD_Init(void) {
0019CE  FA0000     LNK #0x0
27:                    LCDSE0 = 0xFFFF; //设置SEG0-15为段驱动引脚
0019D0  EB8000     SETM W0
0019D2  882C40     MOV W0, LCDSE0
28:                    LCDSE1 = 0x0003; //设置SEG16-17为段驱动引脚
0019D4  200030     MOV #0x3, W0
0019D6  882C50     MOV W0, LCDSE1
29:                    LCDDATA0 = LCDDATA1 = LCDDATA4 = LCDDATA5 = 0;
0019D8  EF259A     CLR LCDDATA5
0019DA  802CD0     MOV LCDDATA5, W0
0019DC  882CC0     MOV W0, LCDDATA4
0019DE  802CC0     MOV LCDDATA4, W0
0019E0  882C90     MOV W0, LCDDATA1
0019E2  802C90     MOV LCDDATA1, W0
0019E4  882C80     MOV W0, LCDDATA0
30:                    LCDDATA8 = LCDDATA9 = LCDDATA16 = LCDDATA17 = 0;
0019E6  EF25B2     CLR LCDDATA17
0019E8  802D90     MOV LCDDATA17, W0
0019EA  882D80     MOV W0, LCDDATA16
0019EC  802D80     MOV LCDDATA16, W0
0019EE  882D10     MOV W0, LCDDATA9
0019F0  802D10     MOV LCDDATA9, W0
0019F2  882D00     MOV W0, LCDDATA8
31:                    LCDREG = 0x0004;
0019F4  200040     MOV #0x4, W0
0019F6  882C00     MOV W0, LCDREG
32:                    //	LCDREF=0x07F0;  //external
33:                    LCDREF = 0x805F; //internal regsistor ladder
0019F8  2805F0     MOV #0x805F, W0
0019FA  882C10     MOV W0, LCDREF
34:                    LCDPS = 0x0002;
0019FC  200020     MOV #0x2, W0
0019FE  882C30     MOV W0, LCDPS
35:                    LCDREFbits.LCDCST = 0;
001A00  802C11     MOV LCDREF, W1
001A02  2C7FF0     MOV #0xC7FF, W0
001A04  608000     AND W1, W0, W0
001A06  882C10     MOV W0, LCDREF
36:                    LCDCON = 0x800B; // 4 common
001A08  2800B0     MOV #0x800B, W0
001A0A  882C20     MOV W0, LCDCON
37:                }
001A0C  FA8000     ULNK
001A0E  060000     RETURN
38:                
39:                //void LCD_ShowTest(void) {
40:                //    LCD_Show(8, 0); //25
41:                //    Delay1s(1);
42:                //}
43:                
44:                void LCD_ShowTest(uint8_t value, bool operation) {
001A10  FA0002     LNK #0x2
001A12  784F00     MOV.B W0, [W14]
001A14  984711     MOV.B W1, [W14+1]
45:                    LCD_Show(value, operation); //25
001A16  FB801E     ZE [W14], W0
001A18  90409E     MOV.B [W14+1], W1
001A1A  070002     RCALL _LCD_Show
46:                    //    Delay1s(1);
47:                }
001A1C  FA8000     ULNK
001A1E  060000     RETURN
48:                //子函数
49:                
50:                static void LCD_Show(uint16_t value, bool operation) {
001A20  FA0006     LNK #0x6
001A22  980710     MOV W0, [W14+2]
001A24  984741     MOV.B W1, [W14+4]
51:                    uint8_t com = (value / SegCnt)&0x00ff; //获取公共码
001A26  90009E     MOV [W14+2], W1
001A28  200120     MOV #0x12, W0
001A2A  780100     MOV W0, W2
001A2C  090011     REPEAT #0x11
001A2E  D88082     DIV.UW W1, W2
001A30  784F00     MOV.B W0, [W14]
52:                    uint8_t seg = value % SegCnt; //获取段码
001A32  90009E     MOV [W14+2], W1
001A34  200120     MOV #0x12, W0
001A36  780100     MOV W0, W2
001A38  090011     REPEAT #0x11
001A3A  D88082     DIV.UW W1, W2
001A3C  FD0080     EXCH W0, W1
001A3E  984710     MOV.B W0, [W14+1]
53:                
54:                    switch (com) {
001A40  FB801E     ZE [W14], W0
001A42  500FE1     SUB W0, #0x1, [W15]
001A44  320039     BRA Z, 0x1AB8
001A46  500FE1     SUB W0, #0x1, [W15]
001A48  3C0003     BRA GT, 0x1A50
001A4A  E00000     CP0 W0
001A4C  320006     BRA Z, 0x1A5A
001A4E  3700C1     BRA 0x1BD2
001A50  500FE2     SUB W0, #0x2, [W15]
001A52  320061     BRA Z, 0x1B16
001A54  500FE3     SUB W0, #0x3, [W15]
001A56  32008E     BRA Z, 0x1B74
001A58  3700BC     BRA 0x1BD2
55:                        case COM0:
56:                        {
57:                            if (seg > 15)
001A5A  90401E     MOV.B [W14+1], W0
001A5C  504FEF     SUB.B W0, #0xF, [W15]
001A5E  360017     BRA LEU, 0x1A8E
58:                                LCD_Set(1, seg % 16, operation);
001A60  90404E     MOV.B [W14+4], W0
001A62  E00400     CP0.B W0
001A64  320009     BRA Z, 0x1A78
001A66  90401E     MOV.B [W14+1], W0
001A68  FB8000     ZE W0, W0
001A6A  60006F     AND W0, #0xF, W0
001A6C  200011     MOV #0x1, W1
001A6E  DD0800     SL W1, W0, W0
001A70  780080     MOV W0, W1
001A72  802C90     MOV LCDDATA1, W0
001A74  700001     IOR W0, W1, W0
001A76  370009     BRA 0x1A8A
001A78  90401E     MOV.B [W14+1], W0
001A7A  FB8000     ZE W0, W0
001A7C  60006F     AND W0, #0xF, W0
001A7E  200011     MOV #0x1, W1
001A80  DD0800     SL W1, W0, W0
001A82  EA8000     COM W0, W0
001A84  780080     MOV W0, W1
001A86  802C90     MOV LCDDATA1, W0
001A88  608000     AND W1, W0, W0
001A8A  882C90     MOV W0, LCDDATA1
59:                            else
60:                                LCD_Set(0, seg, operation);
001A8E  90404E     MOV.B [W14+4], W0
001A90  E00400     CP0.B W0
001A92  320008     BRA Z, 0x1AA4
001A94  90401E     MOV.B [W14+1], W0
001A96  FB8000     ZE W0, W0
001A98  200011     MOV #0x1, W1
001A9A  DD0800     SL W1, W0, W0
001A9C  780080     MOV W0, W1
001A9E  802C80     MOV LCDDATA0, W0
001AA0  700001     IOR W0, W1, W0
001AA2  370008     BRA 0x1AB4
001AA4  90401E     MOV.B [W14+1], W0
001AA6  FB8000     ZE W0, W0
001AA8  200011     MOV #0x1, W1
001AAA  DD0800     SL W1, W0, W0
001AAC  EA8000     COM W0, W0
001AAE  780080     MOV W0, W1
001AB0  802C80     MOV LCDDATA0, W0
001AB2  608000     AND W1, W0, W0
001AB4  882C80     MOV W0, LCDDATA0
61:                            break;
001A8C  3700A2     BRA 0x1BD2
001AB6  37008D     BRA 0x1BD2
62:                        }
63:                        case COM1:
64:                        {
65:                            if (seg > 15)
001AB8  90401E     MOV.B [W14+1], W0
001ABA  504FEF     SUB.B W0, #0xF, [W15]
001ABC  360017     BRA LEU, 0x1AEC
66:                                LCD_Set(5, seg % 16, operation);
001ABE  90404E     MOV.B [W14+4], W0
001AC0  E00400     CP0.B W0
001AC2  320009     BRA Z, 0x1AD6
001AC4  90401E     MOV.B [W14+1], W0
001AC6  FB8000     ZE W0, W0
001AC8  60006F     AND W0, #0xF, W0
001ACA  200011     MOV #0x1, W1
001ACC  DD0800     SL W1, W0, W0
001ACE  780080     MOV W0, W1
001AD0  802CD0     MOV LCDDATA5, W0
001AD2  700001     IOR W0, W1, W0
001AD4  370009     BRA 0x1AE8
001AD6  90401E     MOV.B [W14+1], W0
001AD8  FB8000     ZE W0, W0
001ADA  60006F     AND W0, #0xF, W0
001ADC  200011     MOV #0x1, W1
001ADE  DD0800     SL W1, W0, W0
001AE0  EA8000     COM W0, W0
001AE2  780080     MOV W0, W1
001AE4  802CD0     MOV LCDDATA5, W0
001AE6  608000     AND W1, W0, W0
001AE8  882CD0     MOV W0, LCDDATA5
67:                            else
68:                                LCD_Set(4, seg, operation);
001AEC  90404E     MOV.B [W14+4], W0
001AEE  E00400     CP0.B W0
001AF0  320008     BRA Z, 0x1B02
001AF2  90401E     MOV.B [W14+1], W0
001AF4  FB8000     ZE W0, W0
001AF6  200011     MOV #0x1, W1
001AF8  DD0800     SL W1, W0, W0
001AFA  780080     MOV W0, W1
001AFC  802CC0     MOV LCDDATA4, W0
001AFE  700001     IOR W0, W1, W0
001B00  370008     BRA 0x1B12
001B02  90401E     MOV.B [W14+1], W0
001B04  FB8000     ZE W0, W0
001B06  200011     MOV #0x1, W1
001B08  DD0800     SL W1, W0, W0
001B0A  EA8000     COM W0, W0
001B0C  780080     MOV W0, W1
001B0E  802CC0     MOV LCDDATA4, W0
001B10  608000     AND W1, W0, W0
001B12  882CC0     MOV W0, LCDDATA4
69:                            break;
001AEA  370073     BRA 0x1BD2
001B14  37005E     BRA 0x1BD2
70:                        }
71:                        case COM2:
72:                        {
73:                            if (seg > 15)
001B16  90401E     MOV.B [W14+1], W0
001B18  504FEF     SUB.B W0, #0xF, [W15]
001B1A  360017     BRA LEU, 0x1B4A
74:                                LCD_Set(9, seg % 16, operation);
001B1C  90404E     MOV.B [W14+4], W0
001B1E  E00400     CP0.B W0
001B20  320009     BRA Z, 0x1B34
001B22  90401E     MOV.B [W14+1], W0
001B24  FB8000     ZE W0, W0
001B26  60006F     AND W0, #0xF, W0
001B28  200011     MOV #0x1, W1
001B2A  DD0800     SL W1, W0, W0
001B2C  780080     MOV W0, W1
001B2E  802D10     MOV LCDDATA9, W0
001B30  700001     IOR W0, W1, W0
001B32  370009     BRA 0x1B46
001B34  90401E     MOV.B [W14+1], W0
001B36  FB8000     ZE W0, W0
001B38  60006F     AND W0, #0xF, W0
001B3A  200011     MOV #0x1, W1
001B3C  DD0800     SL W1, W0, W0
001B3E  EA8000     COM W0, W0
001B40  780080     MOV W0, W1
001B42  802D10     MOV LCDDATA9, W0
001B44  608000     AND W1, W0, W0
001B46  882D10     MOV W0, LCDDATA9
75:                            else
76:                                LCD_Set(8, seg, operation);
001B4A  90404E     MOV.B [W14+4], W0
001B4C  E00400     CP0.B W0
001B4E  320008     BRA Z, 0x1B60
001B50  90401E     MOV.B [W14+1], W0
001B52  FB8000     ZE W0, W0
001B54  200011     MOV #0x1, W1
001B56  DD0800     SL W1, W0, W0
001B58  780080     MOV W0, W1
001B5A  802D00     MOV LCDDATA8, W0
001B5C  700001     IOR W0, W1, W0
001B5E  370008     BRA 0x1B70
001B60  90401E     MOV.B [W14+1], W0
001B62  FB8000     ZE W0, W0
001B64  200011     MOV #0x1, W1
001B66  DD0800     SL W1, W0, W0
001B68  EA8000     COM W0, W0
001B6A  780080     MOV W0, W1
001B6C  802D00     MOV LCDDATA8, W0
001B6E  608000     AND W1, W0, W0
001B70  882D00     MOV W0, LCDDATA8
77:                            break;
001B48  370044     BRA 0x1BD2
001B72  37002F     BRA 0x1BD2
78:                        }
79:                        case COM3:
80:                        {
81:                            if (seg > 15)
001B74  90401E     MOV.B [W14+1], W0
001B76  504FEF     SUB.B W0, #0xF, [W15]
001B78  360017     BRA LEU, 0x1BA8
82:                                LCD_Set(13, seg % 16, operation);
001B7A  90404E     MOV.B [W14+4], W0
001B7C  E00400     CP0.B W0
001B7E  320009     BRA Z, 0x1B92
001B80  90401E     MOV.B [W14+1], W0
001B82  FB8000     ZE W0, W0
001B84  60006F     AND W0, #0xF, W0
001B86  200011     MOV #0x1, W1
001B88  DD0800     SL W1, W0, W0
001B8A  780080     MOV W0, W1
001B8C  802D50     MOV LCDDATA13, W0
001B8E  700001     IOR W0, W1, W0
001B90  370009     BRA 0x1BA4
001B92  90401E     MOV.B [W14+1], W0
001B94  FB8000     ZE W0, W0
001B96  60006F     AND W0, #0xF, W0
001B98  200011     MOV #0x1, W1
001B9A  DD0800     SL W1, W0, W0
001B9C  EA8000     COM W0, W0
001B9E  780080     MOV W0, W1
001BA0  802D50     MOV LCDDATA13, W0
001BA2  608000     AND W1, W0, W0
001BA4  882D50     MOV W0, LCDDATA13
83:                            else
84:                                LCD_Set(12, seg, operation);
001BA8  90404E     MOV.B [W14+4], W0
001BAA  E00400     CP0.B W0
001BAC  320008     BRA Z, 0x1BBE
001BAE  90401E     MOV.B [W14+1], W0
001BB0  FB8000     ZE W0, W0
001BB2  200011     MOV #0x1, W1
001BB4  DD0800     SL W1, W0, W0
001BB6  780080     MOV W0, W1
001BB8  802D40     MOV LCDDATA12, W0
001BBA  700001     IOR W0, W1, W0
001BBC  370008     BRA 0x1BCE
001BBE  90401E     MOV.B [W14+1], W0
001BC0  FB8000     ZE W0, W0
001BC2  200011     MOV #0x1, W1
001BC4  DD0800     SL W1, W0, W0
001BC6  EA8000     COM W0, W0
001BC8  780080     MOV W0, W1
001BCA  802D40     MOV LCDDATA12, W0
001BCC  608000     AND W1, W0, W0
001BCE  882D40     MOV W0, LCDDATA12
85:                            break;
001BA6  370015     BRA 0x1BD2
001BD0  000000     NOP
86:                        }
87:                    }
88:                }
001BD2  FA8000     ULNK
001BD4  060000     RETURN
89:                
90:                static void NUM_SHOW(uint8_t num, uint8_t pos) {
001BD6  FA0004     LNK #0x4
001BD8  984720     MOV.B W0, [W14+2]
001BDA  984731     MOV.B W1, [W14+3]
91:                    uint8_t cnt; //, tmp; //, offset = pos * 2;
92:                    bool show_or_hide = SHOW;
001BDC  B3C010     MOV.B #0x1, W0
001BDE  984710     MOV.B W0, [W14+1]
93:                    //    bool IsHideflag = false;
94:                    for (cnt = 0; cnt < 8; cnt++) {
001BE0  EB4000     CLR.B W0
001BE2  784F00     MOV.B W0, [W14]
001BE4  370025     BRA 0x1C30
001C2E  E84F1E     INC.B [W14], [W14]
001C30  78401E     MOV.B [W14], W0
001C32  504FE7     SUB.B W0, #0x7, [W15]
001C34  36FFD8     BRA LEU, 0x1BE6
95:                        if ((LCD_NUM[num][cnt] == 0xff) && show_or_hide)//如果已经找到了OxFF，则接下来的数据都是隐藏,并且跳过0xff
001BE6  90402E     MOV.B [W14+2], W0
001BE8  FB8080     ZE W0, W1
001BEA  FB801E     ZE [W14], W0
001BEC  DD08C3     SL W1, #3, W1
001BEE  408000     ADD W1, W0, W0
001BF0  290721     MOV #0x9072, W1
001BF2  784061     MOV.B [W1+W0], W0
001BF4  404FE1     ADD.B W0, #0x1, [W15]
001BF6  3A0006     BRA NZ, 0x1C04
001BF8  90401E     MOV.B [W14+1], W0
001BFA  E00400     CP0.B W0
001BFC  320003     BRA Z, 0x1C04
96:                        {
97:                            show_or_hide = HIDE;
001BFE  EB4000     CLR.B W0
001C00  984710     MOV.B W0, [W14+1]
98:                            continue;
001C02  370015     BRA 0x1C2E
99:                        }
100:                       //        tmp = (LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72;
101:                       LCD_Show((LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72, show_or_hide);
001C04  90402E     MOV.B [W14+2], W0
001C06  FB8080     ZE W0, W1
001C08  FB801E     ZE [W14], W0
001C0A  DD08C3     SL W1, #3, W1
001C0C  408000     ADD W1, W0, W0
001C0E  290721     MOV #0x9072, W1
001C10  784061     MOV.B [W1+W0], W0
001C12  FB8080     ZE W0, W1
001C14  90403E     MOV.B [W14+3], W0
001C16  FB8000     ZE W0, W0
001C18  290C22     MOV #0x90C2, W2
001C1A  784062     MOV.B [W2+W0], W0
001C1C  FB8000     ZE W0, W0
001C1E  408080     ADD W1, W0, W1
001C20  200480     MOV #0x48, W0
001C22  780100     MOV W0, W2
001C24  090011     REPEAT #0x11
001C26  D80082     DIV.SW W1, W2
001C28  FD0080     EXCH W0, W1
001C2A  90409E     MOV.B [W14+1], W1
001C2C  07FEF9     RCALL _LCD_Show
102:                   }
103:               }
001C36  FA8000     ULNK
001C38  060000     RETURN
104:               
105:               void BAT_SHOW(uint8_t bat) {
001C3A  FA0002     LNK #0x2
001C3C  784F00     MOV.B W0, [W14]
106:                   switch (bat) {
001C3E  FB801E     ZE [W14], W0
001C40  500FE1     SUB W0, #0x1, [W15]
001C42  320017     BRA Z, 0x1C72
001C44  500FE1     SUB W0, #0x1, [W15]
001C46  3C0003     BRA GT, 0x1C4E
001C48  E00000     CP0 W0
001C4A  320006     BRA Z, 0x1C58
001C4C  370039     BRA 0x1CC0
001C4E  500FE2     SUB W0, #0x2, [W15]
001C50  32001D     BRA Z, 0x1C8C
001C52  500FE3     SUB W0, #0x3, [W15]
001C54  320028     BRA Z, 0x1CA6
001C56  370034     BRA 0x1CC0
107:                       case 0:
108:                       {
109:                           LCD_Show(B_0, SHOW);
001C58  B3C011     MOV.B #0x1, W1
001C5A  2003B0     MOV #0x3B, W0
001C5C  07FEE1     RCALL _LCD_Show
110:                           LCD_Show(B_1, HIDE);
001C5E  EB4080     CLR.B W1
001C60  200290     MOV #0x29, W0
001C62  07FEDE     RCALL _LCD_Show
111:                           LCD_Show(B_2, HIDE);
001C64  EB4080     CLR.B W1
001C66  200170     MOV #0x17, W0
001C68  07FEDB     RCALL _LCD_Show
112:                           LCD_Show(B_3, HIDE);
001C6A  EB4080     CLR.B W1
001C6C  200050     MOV #0x5, W0
001C6E  07FED8     RCALL _LCD_Show
113:                           break;
001C70  370034     BRA 0x1CDA
114:                       }
115:                       case 1:
116:                       {
117:                           LCD_Show(B_0, SHOW);
001C72  B3C011     MOV.B #0x1, W1
001C74  2003B0     MOV #0x3B, W0
001C76  07FED4     RCALL _LCD_Show
118:                           LCD_Show(B_1, SHOW);
001C78  B3C011     MOV.B #0x1, W1
001C7A  200290     MOV #0x29, W0
001C7C  07FED1     RCALL _LCD_Show
119:                           LCD_Show(B_2, HIDE);
001C7E  EB4080     CLR.B W1
001C80  200170     MOV #0x17, W0
001C82  07FECE     RCALL _LCD_Show
120:                           LCD_Show(B_3, HIDE);
001C84  EB4080     CLR.B W1
001C86  200050     MOV #0x5, W0
001C88  07FECB     RCALL _LCD_Show
121:                           break;
001C8A  370027     BRA 0x1CDA
122:                       }
123:                       case 2:
124:                       {
125:                           LCD_Show(B_0, SHOW);
001C8C  B3C011     MOV.B #0x1, W1
001C8E  2003B0     MOV #0x3B, W0
001C90  07FEC7     RCALL _LCD_Show
126:                           LCD_Show(B_1, SHOW);
001C92  B3C011     MOV.B #0x1, W1
001C94  200290     MOV #0x29, W0
001C96  07FEC4     RCALL _LCD_Show
127:                           LCD_Show(B_2, SHOW);
001C98  B3C011     MOV.B #0x1, W1
001C9A  200170     MOV #0x17, W0
001C9C  07FEC1     RCALL _LCD_Show
128:                           LCD_Show(B_3, HIDE);
001C9E  EB4080     CLR.B W1
001CA0  200050     MOV #0x5, W0
001CA2  07FEBE     RCALL _LCD_Show
129:                           break;
001CA4  37001A     BRA 0x1CDA
130:                       }
131:                       case 3:
132:                       {
133:                           LCD_Show(B_0, SHOW);
001CA6  B3C011     MOV.B #0x1, W1
001CA8  2003B0     MOV #0x3B, W0
001CAA  07FEBA     RCALL _LCD_Show
134:                           LCD_Show(B_1, SHOW);
001CAC  B3C011     MOV.B #0x1, W1
001CAE  200290     MOV #0x29, W0
001CB0  07FEB7     RCALL _LCD_Show
135:                           LCD_Show(B_2, SHOW);
001CB2  B3C011     MOV.B #0x1, W1
001CB4  200170     MOV #0x17, W0
001CB6  07FEB4     RCALL _LCD_Show
136:                           LCD_Show(B_3, SHOW);
001CB8  B3C011     MOV.B #0x1, W1
001CBA  200050     MOV #0x5, W0
001CBC  07FEB1     RCALL _LCD_Show
137:                           break;
001CBE  37000D     BRA 0x1CDA
138:                       }
139:                       default:
140:                       {
141:                           LCD_Show(B_0, HIDE);
001CC0  EB4080     CLR.B W1
001CC2  2003B0     MOV #0x3B, W0
001CC4  07FEAD     RCALL _LCD_Show
142:                           LCD_Show(B_1, HIDE);
001CC6  EB4080     CLR.B W1
001CC8  200290     MOV #0x29, W0
001CCA  07FEAA     RCALL _LCD_Show
143:                           LCD_Show(B_2, HIDE);
001CCC  EB4080     CLR.B W1
001CCE  200170     MOV #0x17, W0
001CD0  07FEA7     RCALL _LCD_Show
144:                           LCD_Show(B_3, HIDE);
001CD2  EB4080     CLR.B W1
001CD4  200050     MOV #0x5, W0
001CD6  07FEA4     RCALL _LCD_Show
145:                           break;
001CD8  000000     NOP
146:                       }
147:                   }
148:               }
001CDA  FA8000     ULNK
001CDC  060000     RETURN
149:               
150:               void SIGN_SHOW(uint8_t sign) {
001CDE  FA0002     LNK #0x2
001CE0  784F00     MOV.B W0, [W14]
151:                   switch (sign) {
001CE2  FB801E     ZE [W14], W0
001CE4  500FE2     SUB W0, #0x2, [W15]
001CE6  320017     BRA Z, 0x1D16
001CE8  500FE2     SUB W0, #0x2, [W15]
001CEA  3C0003     BRA GT, 0x1CF2
001CEC  500FE1     SUB W0, #0x1, [W15]
001CEE  320006     BRA Z, 0x1CFC
001CF0  370039     BRA 0x1D64
001CF2  500FE3     SUB W0, #0x3, [W15]
001CF4  32001D     BRA Z, 0x1D30
001CF6  500FE4     SUB W0, #0x4, [W15]
001CF8  320028     BRA Z, 0x1D4A
001CFA  370034     BRA 0x1D64
152:                       case 1:
153:                       {
154:                           LCD_Show(Sign0, SHOW);
001CFC  B3C011     MOV.B #0x1, W1
001CFE  2003C0     MOV #0x3C, W0
001D00  07FE8F     RCALL _LCD_Show
155:                           LCD_Show(Sign1, HIDE);
001D02  EB4080     CLR.B W1
001D04  2002A0     MOV #0x2A, W0
001D06  07FE8C     RCALL _LCD_Show
156:                           LCD_Show(Sign2, HIDE);
001D08  EB4080     CLR.B W1
001D0A  200180     MOV #0x18, W0
001D0C  07FE89     RCALL _LCD_Show
157:                           LCD_Show(Sign3, HIDE);
001D0E  EB4080     CLR.B W1
001D10  200060     MOV #0x6, W0
001D12  07FE86     RCALL _LCD_Show
158:                           break;
001D14  370034     BRA 0x1D7E
159:                       }
160:                       case 2:
161:                       {
162:                           LCD_Show(Sign0, SHOW);
001D16  B3C011     MOV.B #0x1, W1
001D18  2003C0     MOV #0x3C, W0
001D1A  07FE82     RCALL _LCD_Show
163:                           LCD_Show(Sign1, SHOW);
001D1C  B3C011     MOV.B #0x1, W1
001D1E  2002A0     MOV #0x2A, W0
001D20  07FE7F     RCALL _LCD_Show
164:                           LCD_Show(Sign2, HIDE);
001D22  EB4080     CLR.B W1
001D24  200180     MOV #0x18, W0
001D26  07FE7C     RCALL _LCD_Show
165:                           LCD_Show(Sign3, HIDE);
001D28  EB4080     CLR.B W1
001D2A  200060     MOV #0x6, W0
001D2C  07FE79     RCALL _LCD_Show
166:                           break;
001D2E  370027     BRA 0x1D7E
167:                       }
168:                       case 3:
169:                       {
170:                           LCD_Show(Sign0, SHOW);
001D30  B3C011     MOV.B #0x1, W1
001D32  2003C0     MOV #0x3C, W0
001D34  07FE75     RCALL _LCD_Show
171:                           LCD_Show(Sign1, SHOW);
001D36  B3C011     MOV.B #0x1, W1
001D38  2002A0     MOV #0x2A, W0
001D3A  07FE72     RCALL _LCD_Show
172:                           LCD_Show(Sign2, SHOW);
001D3C  B3C011     MOV.B #0x1, W1
001D3E  200180     MOV #0x18, W0
001D40  07FE6F     RCALL _LCD_Show
173:                           LCD_Show(Sign3, HIDE);
001D42  EB4080     CLR.B W1
001D44  200060     MOV #0x6, W0
001D46  07FE6C     RCALL _LCD_Show
174:                           break;
001D48  37001A     BRA 0x1D7E
175:                       }
176:                       case 4:
177:                       {
178:                           LCD_Show(Sign0, SHOW);
001D4A  B3C011     MOV.B #0x1, W1
001D4C  2003C0     MOV #0x3C, W0
001D4E  07FE68     RCALL _LCD_Show
179:                           LCD_Show(Sign1, SHOW);
001D50  B3C011     MOV.B #0x1, W1
001D52  2002A0     MOV #0x2A, W0
001D54  07FE65     RCALL _LCD_Show
180:                           LCD_Show(Sign2, SHOW);
001D56  B3C011     MOV.B #0x1, W1
001D58  200180     MOV #0x18, W0
001D5A  07FE62     RCALL _LCD_Show
181:                           LCD_Show(Sign3, SHOW);
001D5C  B3C011     MOV.B #0x1, W1
001D5E  200060     MOV #0x6, W0
001D60  07FE5F     RCALL _LCD_Show
182:                           break;
001D62  37000D     BRA 0x1D7E
183:                       }
184:                       default:
185:                       {
186:                           LCD_Show(Sign0, HIDE);
001D64  EB4080     CLR.B W1
001D66  2003C0     MOV #0x3C, W0
001D68  07FE5B     RCALL _LCD_Show
187:                           LCD_Show(Sign1, HIDE);
001D6A  EB4080     CLR.B W1
001D6C  2002A0     MOV #0x2A, W0
001D6E  07FE58     RCALL _LCD_Show
188:                           LCD_Show(Sign2, HIDE);
001D70  EB4080     CLR.B W1
001D72  200180     MOV #0x18, W0
001D74  07FE55     RCALL _LCD_Show
189:                           LCD_Show(Sign3, HIDE);
001D76  EB4080     CLR.B W1
001D78  200060     MOV #0x6, W0
001D7A  07FE52     RCALL _LCD_Show
190:                           break;
001D7C  000000     NOP
191:                       }
192:                   }
193:               }
001D7E  FA8000     ULNK
001D80  060000     RETURN
194:               
195:               void NUMS_SHOW(uint32_t num, uint8_t all_show) {
001D82  FA000A     LNK #0xA
001D84  BE9F88     MOV.D W8, [W15++]
001D86  980720     MOV W0, [W14+4]
001D88  980731     MOV W1, [W14+6]
001D8A  984F02     MOV.B W2, [W14+8]
196:                   char cnt; //
197:                   uint8_t num_tmp;
198:                   uint8_t IsFindHead = 0;
001D8C  EB4000     CLR.B W0
001D8E  984710     MOV.B W0, [W14+1]
199:                   //    uint8_t nums[7] = {0, 0, 0, 0, 0, 0, 0};
200:               
201:                   //    ClrNum();
202:                   if (!num)
001D90  90002E     MOV [W14+4], W0
001D92  9000BE     MOV [W14+6], W1
001D94  500FE0     SUB W0, #0x0, [W15]
001D96  588FE0     SUBB W1, #0x0, [W15]
001D98  3A0004     BRA NZ, 0x1DA2
203:                       NUM_SHOW(0, 0);
001D9A  EB4080     CLR.B W1
001D9C  EB4000     CLR.B W0
001D9E  07FF1B     RCALL _NUM_SHOW
001DA0  37002B     BRA 0x1DF8
204:                   else
205:                       //获取数字位数
206:                       for (cnt = 6; cnt >= 0; cnt--) {
001DA2  B3C060     MOV.B #0x6, W0
001DA4  784F00     MOV.B W0, [W14]
001DA6  370025     BRA 0x1DF2
001DF0  E94F1E     DEC.B [W14], [W14]
001DF2  78401E     MOV.B [W14], W0
001DF4  E00400     CP0.B W0
001DF6  3DFFD8     BRA GE, 0x1DA8
207:                           num_tmp = (uint32_t) (num / pow(10, cnt)) % 10;
001DA8  90002E     MOV [W14+4], W0
001DAA  9000BE     MOV [W14+6], W1
001DAC  07F571     RCALL 0x890
001DAE  BE0400     MOV.D W0, W8
001DB0  FB001E     SE [W14], W0
001DB2  DE80CF     ASR W0, #15, W1
001DB4  07F56A     RCALL 0x88A
001DB6  BE0100     MOV.D W0, W2
001DB8  200000     MOV #0x0, W0
001DBA  241201     MOV #0x4120, W1
001DBC  07F5F2     RCALL 0x9A2
001DBE  BE0100     MOV.D W0, W2
001DC0  BE0008     MOV.D W8, W0
001DC2  07F506     RCALL 0x7D0
001DC4  07F547     RCALL 0x854
001DC6  2000A2     MOV #0xA, W2
001DC8  200003     MOV #0x0, W3
001DCA  07F6DE     RCALL 0xB88
001DCC  984720     MOV.B W0, [W14+2]
208:                           if (num_tmp) {//如果字节为0的话，那么就pass
001DCE  90402E     MOV.B [W14+2], W0
001DD0  E00400     CP0.B W0
001DD2  320007     BRA Z, 0x1DE2
209:                               IsFindHead = 1;
001DD4  B3C010     MOV.B #0x1, W0
001DD6  984710     MOV.B W0, [W14+1]
210:                               NUM_SHOW(num_tmp, cnt);
001DD8  78401E     MOV.B [W14], W0
001DDA  784080     MOV.B W0, W1
001DDC  90402E     MOV.B [W14+2], W0
001DDE  07FEFB     RCALL _NUM_SHOW
001DE0  370007     BRA 0x1DF0
211:                           } else {
212:                               if (IsFindHead)
001DE2  90401E     MOV.B [W14+1], W0
001DE4  E00400     CP0.B W0
001DE6  320004     BRA Z, 0x1DF0
213:                                   NUM_SHOW(num_tmp, cnt);
001DE8  78401E     MOV.B [W14], W0
001DEA  784080     MOV.B W0, W1
001DEC  90402E     MOV.B [W14+2], W0
001DEE  07FEF3     RCALL _NUM_SHOW
214:                               //            else
215:                               //                NUM_SHOW(11, cnt);
216:                           }
217:                       }
218:               }
001DF8  BE044F     MOV.D [--W15], W8
001DFA  FA8000     ULNK
001DFC  060000     RETURN
219:               
220:               void TIME_SHOW(void) {
001DFE  FA0014     LNK #0x14
221:                   struct tm tmptr;
222:                   uint8_t cnt;
223:                   ClrNum();
001E00  070084     RCALL ClrNum
224:               
225:                   while (!RTC_Read_Time(&tmptr))
001E02  370008     BRA 0x1E14
001E14  E8800E     INC2 W14, W0
001E16  0703DA     RCALL RTC_Read_Time
001E18  E00000     CP0 W0
001E1A  32FFF4     BRA Z, 0x1E04
226:                       if (cnt++ > 3)
001E04  B3C010     MOV.B #0x1, W0
001E06  78409E     MOV.B [W14], W1
001E08  50CFE3     SUB.B W1, #0x3, [W15]
001E0A  3E0001     BRA GTU, 0x1E0E
001E0C  EB4000     CLR.B W0
001E0E  E84F1E     INC.B [W14], [W14]
001E10  E00400     CP0.B W0
001E12  3A0026     BRA NZ, 0x1E60
227:                           return; //添加错误提示
001E60  000000     NOP
228:                   //    time->tm_year;//显示小时
229:                   NUM_SHOW(tmptr.tm_hour >> 4, 5);
001E1C  90003E     MOV [W14+6], W0
001E1E  DE8044     ASR W0, #4, W0
001E20  784000     MOV.B W0, W0
001E22  B3C051     MOV.B #0x5, W1
001E24  07FED8     RCALL _NUM_SHOW
230:                   NUM_SHOW(GetMod(tmptr.tm_hour, 4), 4);
001E26  90003E     MOV [W14+6], W0
001E28  200041     MOV #0x4, W1
001E2A  070308     RCALL GetMod
001E2C  784000     MOV.B W0, W0
001E2E  B3C041     MOV.B #0x4, W1
001E30  07FED2     RCALL _NUM_SHOW
231:                   //    DP_SHOW(4);
232:                   NUM_SHOW(tmptr.tm_min >> 4, 3);
001E32  90002E     MOV [W14+4], W0
001E34  DE8044     ASR W0, #4, W0
001E36  784000     MOV.B W0, W0
001E38  B3C031     MOV.B #0x3, W1
001E3A  07FECD     RCALL _NUM_SHOW
233:                   NUM_SHOW(GetMod(tmptr.tm_min, 4), 2);
001E3C  90002E     MOV [W14+4], W0
001E3E  200041     MOV #0x4, W1
001E40  0702FD     RCALL GetMod
001E42  784000     MOV.B W0, W0
001E44  B3C021     MOV.B #0x2, W1
001E46  07FEC7     RCALL _NUM_SHOW
234:                   //    DP_SHOW(2);
235:                   NUM_SHOW(tmptr.tm_sec >> 4, 1);
001E48  90001E     MOV [W14+2], W0
001E4A  DE8044     ASR W0, #4, W0
001E4C  784000     MOV.B W0, W0
001E4E  B3C011     MOV.B #0x1, W1
001E50  07FEC2     RCALL _NUM_SHOW
236:                   NUM_SHOW(GetMod(tmptr.tm_sec, 4), 0);
001E52  90001E     MOV [W14+2], W0
001E54  200041     MOV #0x4, W1
001E56  0702F2     RCALL GetMod
001E58  784000     MOV.B W0, W0
001E5A  EB4080     CLR.B W1
001E5C  07FEBC     RCALL _NUM_SHOW
001E5E  370001     BRA 0x1E62
237:               }
001E62  FA8000     ULNK
001E64  060000     RETURN
238:               
239:               void DP_SHOW(uint8_t dp_pos) {
001E66  FA0002     LNK #0x2
001E68  784F00     MOV.B W0, [W14]
240:                   //显示小数点
241:                   switch (dp_pos) {
001E6A  FB801E     ZE [W14], W0
001E6C  500FE2     SUB W0, #0x2, [W15]
001E6E  320017     BRA Z, 0x1E9E
001E70  500FE2     SUB W0, #0x2, [W15]
001E72  3C0003     BRA GT, 0x1E7A
001E74  500FE1     SUB W0, #0x1, [W15]
001E76  320006     BRA Z, 0x1E84
001E78  370039     BRA 0x1EEC
001E7A  500FE3     SUB W0, #0x3, [W15]
001E7C  32001D     BRA Z, 0x1EB8
001E7E  500FE4     SUB W0, #0x4, [W15]
001E80  320028     BRA Z, 0x1ED2
001E82  370034     BRA 0x1EEC
242:                       case 1:
243:                       {
244:                           LCD_Show(P1, SHOW);
001E84  B3C011     MOV.B #0x1, W1
001E86  200010     MOV #0x1, W0
001E88  07FDCB     RCALL _LCD_Show
245:                           LCD_Show(P2, HIDE);
001E8A  EB4080     CLR.B W1
001E8C  200030     MOV #0x3, W0
001E8E  07FDC8     RCALL _LCD_Show
246:                           LCD_Show(P3, HIDE);
001E90  EB4080     CLR.B W1
001E92  200090     MOV #0x9, W0
001E94  07FDC5     RCALL _LCD_Show
247:                           LCD_Show(P4, HIDE);
001E96  EB4080     CLR.B W1
001E98  2000B0     MOV #0xB, W0
001E9A  07FDC2     RCALL _LCD_Show
248:                           break;
001E9C  370034     BRA 0x1F06
249:                       }
250:                       case 2:
251:                       {
252:                           LCD_Show(P1, HIDE);
001E9E  EB4080     CLR.B W1
001EA0  200010     MOV #0x1, W0
001EA2  07FDBE     RCALL _LCD_Show
253:                           LCD_Show(P2, SHOW);
001EA4  B3C011     MOV.B #0x1, W1
001EA6  200030     MOV #0x3, W0
001EA8  07FDBB     RCALL _LCD_Show
254:                           LCD_Show(P3, HIDE);
001EAA  EB4080     CLR.B W1
001EAC  200090     MOV #0x9, W0
001EAE  07FDB8     RCALL _LCD_Show
255:                           LCD_Show(P4, HIDE);
001EB0  EB4080     CLR.B W1
001EB2  2000B0     MOV #0xB, W0
001EB4  07FDB5     RCALL _LCD_Show
256:                           break;
001EB6  370027     BRA 0x1F06
257:                       }
258:                       case 3:
259:                       {
260:                           LCD_Show(P1, HIDE);
001EB8  EB4080     CLR.B W1
001EBA  200010     MOV #0x1, W0
001EBC  07FDB1     RCALL _LCD_Show
261:                           LCD_Show(P2, HIDE);
001EBE  EB4080     CLR.B W1
001EC0  200030     MOV #0x3, W0
001EC2  07FDAE     RCALL _LCD_Show
262:                           LCD_Show(P3, SHOW);
001EC4  B3C011     MOV.B #0x1, W1
001EC6  200090     MOV #0x9, W0
001EC8  07FDAB     RCALL _LCD_Show
263:                           LCD_Show(P4, HIDE);
001ECA  EB4080     CLR.B W1
001ECC  2000B0     MOV #0xB, W0
001ECE  07FDA8     RCALL _LCD_Show
264:                           break;
001ED0  37001A     BRA 0x1F06
265:                       }
266:                       case 4:
267:                       {
268:                           LCD_Show(P1, HIDE);
001ED2  EB4080     CLR.B W1
001ED4  200010     MOV #0x1, W0
001ED6  07FDA4     RCALL _LCD_Show
269:                           LCD_Show(P2, HIDE);
001ED8  EB4080     CLR.B W1
001EDA  200030     MOV #0x3, W0
001EDC  07FDA1     RCALL _LCD_Show
270:                           LCD_Show(P3, HIDE);
001EDE  EB4080     CLR.B W1
001EE0  200090     MOV #0x9, W0
001EE2  07FD9E     RCALL _LCD_Show
271:                           LCD_Show(P4, SHOW);
001EE4  B3C011     MOV.B #0x1, W1
001EE6  2000B0     MOV #0xB, W0
001EE8  07FD9B     RCALL _LCD_Show
272:                           break;
001EEA  37000D     BRA 0x1F06
273:                       }
274:                       default:
275:                       {
276:                           LCD_Show(P1, HIDE);
001EEC  EB4080     CLR.B W1
001EEE  200010     MOV #0x1, W0
001EF0  07FD97     RCALL _LCD_Show
277:                           LCD_Show(P2, HIDE);
001EF2  EB4080     CLR.B W1
001EF4  200030     MOV #0x3, W0
001EF6  07FD94     RCALL _LCD_Show
278:                           LCD_Show(P3, HIDE);
001EF8  EB4080     CLR.B W1
001EFA  200090     MOV #0x9, W0
001EFC  07FD91     RCALL _LCD_Show
279:                           LCD_Show(P4, HIDE);
001EFE  EB4080     CLR.B W1
001F00  2000B0     MOV #0xB, W0
001F02  07FD8E     RCALL _LCD_Show
280:                           break;
001F04  000000     NOP
281:                       }
282:                   }
283:               }
001F06  FA8000     ULNK
001F08  060000     RETURN
284:               
285:               void ClrNum(void) {
001F0A  FA0004     LNK #0x4
286:                   uint8_t x, y, z, m;
287:                   for (y = 0; y < 4; y++)//清楚字母部分1
001F0C  EB4000     CLR.B W0
001F0E  984710     MOV.B W0, [W14+1]
001F10  370012     BRA 0x1F36
001F30  90401E     MOV.B [W14+1], W0
001F32  E84000     INC.B W0, W0
001F34  984710     MOV.B W0, [W14+1]
001F36  90401E     MOV.B [W14+1], W0
001F38  504FE3     SUB.B W0, #0x3, [W15]
001F3A  36FFEB     BRA LEU, 0x1F12
288:                       for (x = 0; x < 4; x++)
001F12  EB4000     CLR.B W0
001F14  784F00     MOV.B W0, [W14]
001F16  370009     BRA 0x1F2A
001F28  E84F1E     INC.B [W14], [W14]
001F2A  78401E     MOV.B [W14], W0
001F2C  504FE3     SUB.B W0, #0x3, [W15]
001F2E  36FFF4     BRA LEU, 0x1F18
289:                           LCD_Show(x + y * SegCnt, HIDE);
001F18  FB811E     ZE [W14], W2
001F1A  90401E     MOV.B [W14+1], W0
001F1C  FB8000     ZE W0, W0
001F1E  B90072     MUL.SU W0, #18, W0
001F20  780000     MOV W0, W0
001F22  410000     ADD W2, W0, W0
001F24  EB4080     CLR.B W1
001F26  07FD7C     RCALL _LCD_Show
290:               
291:                   for (z = 0; z < 4; z++)//清楚字母部分2
001F3C  EB4000     CLR.B W0
001F3E  984720     MOV.B W0, [W14+2]
001F40  370015     BRA 0x1F6C
001F66  90402E     MOV.B [W14+2], W0
001F68  E84000     INC.B W0, W0
001F6A  984720     MOV.B W0, [W14+2]
001F6C  90402E     MOV.B [W14+2], W0
001F6E  504FE3     SUB.B W0, #0x3, [W15]
001F70  36FFE8     BRA LEU, 0x1F42
292:                       for (m = 8; m < SegCnt; m++)
001F42  B3C080     MOV.B #0x8, W0
001F44  984730     MOV.B W0, [W14+3]
001F46  37000C     BRA 0x1F60
001F5A  90403E     MOV.B [W14+3], W0
001F5C  E84000     INC.B W0, W0
001F5E  984730     MOV.B W0, [W14+3]
001F60  90403E     MOV.B [W14+3], W0
001F62  504FF1     SUB.B W0, #0x11, [W15]
001F64  36FFF1     BRA LEU, 0x1F48
293:                           LCD_Show(m + z * SegCnt, HIDE);
001F48  90403E     MOV.B [W14+3], W0
001F4A  FB8100     ZE W0, W2
001F4C  90402E     MOV.B [W14+2], W0
001F4E  FB8000     ZE W0, W0
001F50  B90072     MUL.SU W0, #18, W0
001F52  780000     MOV W0, W0
001F54  410000     ADD W2, W0, W0
001F56  EB4080     CLR.B W1
001F58  07FD63     RCALL _LCD_Show
294:               }
001F72  FA8000     ULNK
001F74  060000     RETURN
295:               
296:               void ClrScreen(void) {
001F76  FA0004     LNK #0x4
297:                   uint16_t lcd_x = 0, lcd_y = 0;
001F78  EB0000     CLR W0
001F7A  780F00     MOV W0, [W14]
001F7C  EB0000     CLR W0
001F7E  980710     MOV W0, [W14+2]
298:                   for (lcd_y = 0; lcd_y < 4; lcd_y++)
001F80  EB0000     CLR W0
001F82  980710     MOV W0, [W14+2]
001F84  370010     BRA 0x1FA6
001FA0  90001E     MOV [W14+2], W0
001FA2  E80000     INC W0, W0
001FA4  980710     MOV W0, [W14+2]
001FA6  90001E     MOV [W14+2], W0
001FA8  500FE3     SUB W0, #0x3, [W15]
001FAA  36FFED     BRA LEU, 0x1F86
299:                       for (lcd_x = 0; lcd_x < SegCnt; lcd_x++)
001F86  EB0000     CLR W0
001F88  780F00     MOV W0, [W14]
001F8A  370007     BRA 0x1F9A
001F98  E80F1E     INC [W14], [W14]
001F9A  78001E     MOV [W14], W0
001F9C  500FF1     SUB W0, #0x11, [W15]
001F9E  36FFF6     BRA LEU, 0x1F8C
300:                           LCD_Show(lcd_x + lcd_y * SegCnt, HIDE);
001F8C  90001E     MOV [W14+2], W0
001F8E  B90072     MUL.SU W0, #18, W0
001F90  780000     MOV W0, W0
001F92  40001E     ADD W0, [W14], W0
001F94  EB4080     CLR.B W1
001F96  07FD44     RCALL _LCD_Show
301:               }
001FAC  FA8000     ULNK
001FAE  060000     RETURN
302:               
303:               void LCD_Task(uint32_t dat) {
001FB0  FA0004     LNK #0x4
001FB2  BE8F00     MOV.D W0, [W14]
304:                   ClrScreen();
001FB4  07FFE0     RCALL ClrScreen
305:                   (W_LCDCON.LCD_Flagbits.F_Bat1) ? BAT_SHOW(1) : BAT_SHOW(4);
001FB6  8041D0     MOV W_LCDCON, W0
001FB8  600070     AND W0, #0x10, W0
001FBA  E00000     CP0 W0
001FBC  320003     BRA Z, 0x1FC4
001FBE  B3C010     MOV.B #0x1, W0
001FC0  07FE3C     RCALL BAT_SHOW
001FC2  370002     BRA 0x1FC8
001FC4  B3C040     MOV.B #0x4, W0
001FC6  07FE39     RCALL BAT_SHOW
306:                   (W_LCDCON.LCD_Flagbits.F_Bat2) ? BAT_SHOW(2) : BAT_SHOW(4);
001FC8  8041D1     MOV W_LCDCON, W1
001FCA  200200     MOV #0x20, W0
001FCC  608000     AND W1, W0, W0
001FCE  E00000     CP0 W0
001FD0  320003     BRA Z, 0x1FD8
001FD2  B3C020     MOV.B #0x2, W0
001FD4  07FE32     RCALL BAT_SHOW
001FD6  370002     BRA 0x1FDC
001FD8  B3C040     MOV.B #0x4, W0
001FDA  07FE2F     RCALL BAT_SHOW
307:                   (W_LCDCON.LCD_Flagbits.F_Bat3) ? BAT_SHOW(3) : BAT_SHOW(4);
001FDC  8041D1     MOV W_LCDCON, W1
001FDE  200400     MOV #0x40, W0
001FE0  608000     AND W1, W0, W0
001FE2  E00000     CP0 W0
001FE4  320003     BRA Z, 0x1FEC
001FE6  B3C030     MOV.B #0x3, W0
001FE8  07FE28     RCALL BAT_SHOW
001FEA  370002     BRA 0x1FF0
001FEC  B3C040     MOV.B #0x4, W0
001FEE  07FE25     RCALL BAT_SHOW
308:                   (W_LCDCON.LCD_Flagbits.F_C) ? CC_SHOW(SHOW) : CC_SHOW(HIDE);
001FF0  8041D1     MOV W_LCDCON, W1
001FF2  240000     MOV #0x4000, W0
001FF4  608000     AND W1, W0, W0
001FF6  E00000     CP0 W0
001FF8  320005     BRA Z, 0x2004
001FFA  802C80     MOV LCDDATA0, W0
001FFC  A07000     BSET W0, #7
001FFE  882C80     MOV W0, LCDDATA0
002000  802C80     MOV LCDDATA0, W0
002002  370004     BRA 0x200C
002004  802C80     MOV LCDDATA0, W0
002006  A17000     BCLR W0, #7
002008  882C80     MOV W0, LCDDATA0
00200A  802C80     MOV LCDDATA0, W0
309:                   (W_LCDCON.LCD_Flagbits.F_M3) ? m3_SHOW(SHOW) : m3_SHOW(HIDE);
00200C  8041D1     MOV W_LCDCON, W1
00200E  210000     MOV #0x1000, W0
002010  608000     AND W1, W0, W0
002012  E00000     CP0 W0
002014  320005     BRA Z, 0x2020
002016  802D00     MOV LCDDATA8, W0
002018  A07000     BSET W0, #7
00201A  882D00     MOV W0, LCDDATA8
00201C  802D00     MOV LCDDATA8, W0
00201E  370004     BRA 0x2028
002020  802D00     MOV LCDDATA8, W0
002022  A17000     BCLR W0, #7
002024  882D00     MOV W0, LCDDATA8
002026  802D00     MOV LCDDATA8, W0
310:                   (W_LCDCON.LCD_Flagbits.F_KPa) ? kPa_SHOW(SHOW) : kPa_SHOW(HIDE);
002028  8041D1     MOV W_LCDCON, W1
00202A  208000     MOV #0x800, W0
00202C  608000     AND W1, W0, W0
00202E  E00000     CP0 W0
002030  320005     BRA Z, 0x203C
002032  802D40     MOV LCDDATA12, W0
002034  A07000     BSET W0, #7
002036  882D40     MOV W0, LCDDATA12
002038  802D40     MOV LCDDATA12, W0
00203A  370004     BRA 0x2044
00203C  802D40     MOV LCDDATA12, W0
00203E  A17000     BCLR W0, #7
002040  882D40     MOV W0, LCDDATA12
002042  802D40     MOV LCDDATA12, W0
311:                   (W_LCDCON.LCD_Flagbits.F_h) ? _h_SHOW(SHOW) : _h_SHOW(HIDE);
002044  8041D1     MOV W_LCDCON, W1
002046  220000     MOV #0x2000, W0
002048  608000     AND W1, W0, W0
00204A  E00000     CP0 W0
00204C  320005     BRA Z, 0x2058
00204E  802CC0     MOV LCDDATA4, W0
002050  A07000     BSET W0, #7
002052  882CC0     MOV W0, LCDDATA4
002054  802CC0     MOV LCDDATA4, W0
002056  370004     BRA 0x2060
002058  802CC0     MOV LCDDATA4, W0
00205A  A17000     BCLR W0, #7
00205C  882CC0     MOV W0, LCDDATA4
00205E  802CC0     MOV LCDDATA4, W0
312:                   (W_LCDCON.LCD_Flagbits.F_Charge) ? POW_SHOW(SHOW) : POW_SHOW(HIDE);
002060  8041D0     MOV W_LCDCON, W0
002062  600061     AND W0, #0x1, W0
002064  E00000     CP0 W0
002066  320005     BRA Z, 0x2072
002068  802D40     MOV LCDDATA12, W0
00206A  A04000     BSET W0, #4
00206C  882D40     MOV W0, LCDDATA12
00206E  802D40     MOV LCDDATA12, W0
002070  370004     BRA 0x207A
002072  802D40     MOV LCDDATA12, W0
002074  A14000     BCLR W0, #4
002076  882D40     MOV W0, LCDDATA12
002078  802D40     MOV LCDDATA12, W0
313:                   (W_LCDCON.LCD_Flagbits.F_Error) ? ERR_SHOW(SHOW) : ERR_SHOW(HIDE);
00207A  8041D0     MOV W_LCDCON, W0
00207C  600062     AND W0, #0x2, W0
00207E  E00000     CP0 W0
002080  320005     BRA Z, 0x208C
002082  802D00     MOV LCDDATA8, W0
002084  A04000     BSET W0, #4
002086  882D00     MOV W0, LCDDATA8
002088  802D00     MOV LCDDATA8, W0
00208A  370004     BRA 0x2094
00208C  802D00     MOV LCDDATA8, W0
00208E  A14000     BCLR W0, #4
002090  882D00     MOV W0, LCDDATA8
002092  802D00     MOV LCDDATA8, W0
314:                   (W_LCDCON.LCD_Flagbits.F_Qm) ? FOR_SHOW(SHOW) : FOR_SHOW(HIDE);
002094  8041D0     MOV W_LCDCON, W0
002096  600064     AND W0, #0x4, W0
002098  E00000     CP0 W0
00209A  320005     BRA Z, 0x20A6
00209C  802CC0     MOV LCDDATA4, W0
00209E  A04000     BSET W0, #4
0020A0  882CC0     MOV W0, LCDDATA4
0020A2  802CC0     MOV LCDDATA4, W0
0020A4  370004     BRA 0x20AE
0020A6  802CC0     MOV LCDDATA4, W0
0020A8  A14000     BCLR W0, #4
0020AA  882CC0     MOV W0, LCDDATA4
0020AC  802CC0     MOV LCDDATA4, W0
315:                   (W_LCDCON.LCD_Flagbits.F_Vm) ? BACK_SHOW(SHOW) : BACK_SHOW(HIDE);
0020AE  8041D0     MOV W_LCDCON, W0
0020B0  600068     AND W0, #0x8, W0
0020B2  E00000     CP0 W0
0020B4  320005     BRA Z, 0x20C0
0020B6  802C80     MOV LCDDATA0, W0
0020B8  A04000     BSET W0, #4
0020BA  882C80     MOV W0, LCDDATA0
0020BC  802C80     MOV LCDDATA0, W0
0020BE  370004     BRA 0x20C8
0020C0  802C80     MOV LCDDATA0, W0
0020C2  A14000     BCLR W0, #4
0020C4  882C80     MOV W0, LCDDATA0
0020C6  802C80     MOV LCDDATA0, W0
316:                   (W_LCDCON.LCD_Flagbits.F_Sign1) ? SIGN_SHOW(1) : SIGN_SHOW(0);
0020C8  8041D1     MOV W_LCDCON, W1
0020CA  200800     MOV #0x80, W0
0020CC  608000     AND W1, W0, W0
0020CE  E00000     CP0 W0
0020D0  320003     BRA Z, 0x20D8
0020D2  B3C010     MOV.B #0x1, W0
0020D4  07FE04     RCALL SIGN_SHOW
0020D6  370002     BRA 0x20DC
0020D8  EB4000     CLR.B W0
0020DA  07FE01     RCALL SIGN_SHOW
317:                   (W_LCDCON.LCD_Flagbits.F_Sign2) ? SIGN_SHOW(2) : SIGN_SHOW(0);
0020DC  8041D1     MOV W_LCDCON, W1
0020DE  201000     MOV #0x100, W0
0020E0  608000     AND W1, W0, W0
0020E2  E00000     CP0 W0
0020E4  320003     BRA Z, 0x20EC
0020E6  B3C020     MOV.B #0x2, W0
0020E8  07FDFA     RCALL SIGN_SHOW
0020EA  370002     BRA 0x20F0
0020EC  EB4000     CLR.B W0
0020EE  07FDF7     RCALL SIGN_SHOW
318:                   (W_LCDCON.LCD_Flagbits.F_Sign3) ? SIGN_SHOW(3) : SIGN_SHOW(0);
0020F0  8041D1     MOV W_LCDCON, W1
0020F2  202000     MOV #0x200, W0
0020F4  608000     AND W1, W0, W0
0020F6  E00000     CP0 W0
0020F8  320003     BRA Z, 0x2100
0020FA  B3C030     MOV.B #0x3, W0
0020FC  07FDF0     RCALL SIGN_SHOW
0020FE  370002     BRA 0x2104
002100  EB4000     CLR.B W0
002102  07FDED     RCALL SIGN_SHOW
319:                   (W_LCDCON.LCD_Flagbits.F_Sign4) ? SIGN_SHOW(4) : SIGN_SHOW(0);
002104  8041D1     MOV W_LCDCON, W1
002106  204000     MOV #0x400, W0
002108  608000     AND W1, W0, W0
00210A  E00000     CP0 W0
00210C  320003     BRA Z, 0x2114
00210E  B3C040     MOV.B #0x4, W0
002110  07FDE6     RCALL SIGN_SHOW
002112  370002     BRA 0x2118
002114  EB4000     CLR.B W0
002116  07FDE3     RCALL SIGN_SHOW
320:                   DP_SHOW(W_LCDCON.LCD_Flagbits.F_DP);
002118  8041D0     MOV W_LCDCON, W0
00211A  DE00CF     LSR W0, #15, W1
00211C  8041E0     MOV 0x83C, W0
00211E  600063     AND W0, #0x3, W0
002120  400000     ADD W0, W0, W0
002122  708000     IOR W1, W0, W0
002124  784000     MOV.B W0, W0
002126  07FE9F     RCALL DP_SHOW
321:               
322:                   if (W_LCDCON.LCD_Flagbits.F_Num)
002128  8041E0     MOV 0x83C, W0
00212A  600064     AND W0, #0x4, W0
00212C  E00000     CP0 W0
00212E  320004     BRA Z, 0x2138
323:                       NUMS_SHOW(dat, 0);
002130  EB4100     CLR.B W2
002132  BE001E     MOV.D [W14], W0
002134  07FE26     RCALL NUMS_SHOW
002136  370007     BRA 0x2146
324:                   else if (W_LCDCON.LCD_Flagbits.F_Time)
002138  8041E0     MOV 0x83C, W0
00213A  600068     AND W0, #0x8, W0
00213C  E00000     CP0 W0
00213E  320002     BRA Z, 0x2144
325:                       TIME_SHOW();
002140  07FE5E     RCALL TIME_SHOW
002142  370001     BRA 0x2146
326:                   else
327:                       Nop();
002144  000000     NOP
328:                   W_LCDCON.LCD_Flag = 0; //清楚所有标志
002146  EF283A     CLR W_LCDCON
002148  EF283C     CLR 0x83C
329:               }
00214A  FA8000     ULNK
330:               
331:               
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/INT.c  ---------------------------------------
1:                 #include "INT.h"
2:                 
3:                 void INT0_Init(void) {
00382A  FA0000     LNK #0x0
4:                     TRISFbits.TRISF6 = 1; //设置为输入
00382C  A8C2E8     BSET TRISF, #6
5:                     INTCON2bits.INT0EP = 1; //  1 = 下降沿中断  0 = 上升沿中断
00382E  A80082     BSET INTCON2, #0
6:                     IPC0bits.INT0IP = 7; //优先级为2
003830  800520     MOV IPC0, W0
003832  B30070     IOR #0x7, W0
003834  880520     MOV W0, IPC0
7:                     IFS0bits.INT0IF = 0; //清除标志位
003836  A90084     BCLR IFS0, #0
8:                     IEC0bits.INT0IE = 1; //使能中断
003838  A80094     BSET IEC0, #0
9:                 }
00383A  FA8000     ULNK
00383C  060000     RETURN
10:                
11:                void INT0_Open(void) {
00383E  FA0000     LNK #0x0
12:                    IFS0bits.INT0IF = 0; //清除标志位
003840  A90084     BCLR IFS0, #0
13:                    IEC0bits.INT0IE = 1;
003842  A80094     BSET IEC0, #0
14:                }
003844  FA8000     ULNK
003846  060000     RETURN
15:                
16:                void INT0_Close(void) {
003848  FA0000     LNK #0x0
17:                    IFS0bits.INT0IF = 0; //清除标志位
00384A  A90084     BCLR IFS0, #0
18:                    IEC0bits.INT0IE = 0;
00384C  A90094     BCLR IEC0, #0
19:                }
00384E  FA8000     ULNK
20:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/I2C.c  ---------------------------------------
1:                 #include "I2C.h"
2:                 
3:                 volatile uint8_t i2c1_state;
4:                 I2C1_Buffer i2c_buf;
5:                 
6:                 void I2C_Init(void) {
003852  FA0000     LNK #0x0
7:                     TRISGbits.TRISG2 = 0; //将SCL1设置为输出口
003854  A942F0     BCLR TRISG, #2
8:                     TRISGbits.TRISG3 = 0; //将SCK1设置为输出口
003856  A962F0     BCLR TRISG, #3
9:                     I2C1BRG = 0x9D; //100kHz Fcy=16000000
003858  2009D0     MOV #0x9D, W0
00385A  881020     MOV W0, I2C1BRG
10:                    I2C1CONbits.I2CEN = 1; //使能I2C1
00385C  A8E207     BSET 0x207, #7
11:                    I2C1CONbits.I2CSIDL = 0; //模块在空闲模式下继续工作
00385E  A9A207     BCLR 0x207, #5
12:                    I2C1CONbits.IPMIEN = 0; //禁止IPMI模式
003860  A96207     BCLR 0x207, #3
13:                    I2C1CONbits.A10M = 0; //7位从地址
003862  A94207     BCLR 0x207, #2
14:                    IFS1bits.MI2C1IF = 0; //清楚Master标志位
003864  A92086     BCLR IFS1, #1
15:                    IPC4bits.MI2C1IP = 5;
003866  800561     MOV IPC4, W1
003868  2FF8F0     MOV #0xFF8F, W0
00386A  608080     AND W1, W0, W1
00386C  200500     MOV #0x50, W0
00386E  700001     IOR W0, W1, W0
003870  880560     MOV W0, IPC4
16:                    IEC1bits.MI2C1IE = 1; //使能Master中断
003872  A82096     BSET IEC1, #1
17:                    //    IEC1bits.SI2C1IE = 1;//使能Slave中断
18:                    //    IFS1bits.SI2C1IF = 0;//清楚Slave标志位
19:                    //    I2C1CONbits.I2CEN = 0; //关闭I2C1
20:                }
003874  FA8000     ULNK
21:                
22:                //void Start_I2C(void) {
23:                //    //    IEC4bits.
24:                //    //    I2C1CONbits.I2CEN = 1;
25:                //    IFS1bits.MI2C1IF = 1;
26:                //}
27:                
28:                //void Stop_I2C(void) {
29:                //    IFS1bits.MI2C1IF = 0;
30:                //    I2C1CONbits.I2CEN = 0;
31:                //}
32:                
33:                //void Check_I2C(void) {
34:                //    if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
35:                //        I2C1STATbits.IWCOL = 0;
36:                //    }
37:                //}
38:                
39:                //void Clear_I2C_Sta(void) {
40:                //    i2c1_state = S_MASTER_IDLE;
41:                //}
42:                
43:                //void Send_I2C_Data(I2C1_Buffer* buf)
44:                //{
45:                //    buf
46:                //}
47:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/DeepSleep.c  ---------------------------------
1:                 #include <DeepSleep.h>
2:                 #include <xc.h>
3:                 #include <stdint.h>
4:                 
5:                 /************
6:                  * 低压/保持稳压器仅在调用休眠模式或深度休眠模式时
7:                 可用。它由LPCFG配置位（CW1<10>）控制，在固件
8:                 中由 RETEN 位（RCON<12>）控制。必须将 LPCFG
9:                 编程为 0 并将 RETEN 位置 1，才能使能该稳压器。
10:                 ************************************************/
11:                void DeepSleep(void) {
003878  FA0000     LNK #0x0
12:                    //    uint8_t Result;
13:                    //    if (RCONbits.WDTO) {
14:                    //        Result = 3;
15:                    //        RCONbits.WDTO = 0;
16:                    //        DSCONbits.RELEASE = 0;
17:                    //    } else if (RCONbits.EXTR) {
18:                    //        Result = 2;
19:                    //        RCONbits.EXTR = 0;
20:                    //        DSCONbits.RELEASE = 0;
21:                    //    } else if (RCONbits.DPSLP) {
22:                    //        Result = 1;
23:                    //        RCONbits.DPSLP = 0;
24:                    //        DSCONbits.RELEASE = 0;
25:                    //        if (DSWAKEbits.DSWDT) DSGPR0 = DSGPR0 + 1; /* count when wake from DSWDT */
26:                    //        if (DSWAKEbits.DSINT0) DSGPR1 = DSGPR1 + 1; /* count when wake from INT0  */
27:                    //    } else {
28:                    //        Result = 0; /* assume we are a Power On reset */
29:                    //        RCONbits.POR = 0;
30:                    //        DSGPR0 = 0;
31:                    //        DSGPR1 = 0;
32:                    //    }
33:                    //    if (Result == 0) {
34:                    RCONbits.RETEN = 1; // CONFIG1  #pragma config LPCFG = ON    // Low power regulator control->Disabled
00387A  A88741     BSET 0x741, #4
35:                    //    while (!RCONbits.RETEN)
36:                    //        RCONbits.RETEN = 1;
37:                    //    asm("disi #4");
38:                    //    asm("bset DSCON, #15");
39:                    //    asm("nop");
40:                    //    asm("nop");
41:                    //    asm("btss INTTREG, #15");
42:                    //    asm("pwrsav #0");
43:                    RCONbits.DPSLP = 0; /* clear all previous deep sleep wake flags */
00387C  A94741     BCLR 0x741, #2
44:                    DSWAKE = 0; /* clear all previous deep sleep wake flags */
00387E  EF275A     CLR DSWAKE
45:                    /* enter deep sleep code cut and paste from data sheet */
46:                    asm("disi #4");
003880  FC0004     DISI #0x4
47:                    asm("bset  DSCON, #15");
003882  A8E759     BSET 0x759, #7
48:                    asm("nop");
003884  000000     NOP
49:                    asm("nop");
003886  000000     NOP
50:                    asm("nop");    
003888  000000     NOP
51:                //    asm("bset  DSCON, #15");
52:                    asm("pwrsav #0");
00388A  FE4000     PWRSAV #0
53:                    //    }
54:                }
00388C  FA8000     ULNK
55:                
56:                
57:                
---  C:/Users/Administrator/Desktop/V1_1_9WCGforkjxm.X/BSP/CRC16.c  -------------------------------------
1:                 #include "CRC16.h"
2:                 //static const uint8_t aucCRCHi[] = {
3:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
4:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
5:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
6:                 //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
7:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
8:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
9:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
10:                //    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
11:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
12:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
13:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
14:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
15:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
16:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
17:                //    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
18:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
19:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
20:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
21:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
22:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
23:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
24:                //    0x00, 0xC1, 0x81, 0x40
25:                //};
26:                //static const uint8_t aucCRCLo[] = {
27:                //    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
28:                //    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
29:                //    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
30:                //    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
31:                //    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
32:                //    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
33:                //    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
34:                //    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
35:                //    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
36:                //    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
37:                //    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
38:                //    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
39:                //    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
40:                //    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
41:                //    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
42:                //    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
43:                //    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
44:                //    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
45:                //    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
46:                //    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
47:                //    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
48:                //    0x41, 0x81, 0x80, 0x40
49:                //};
50:                ///*************************************
51:                //Function: crc16 
52:                //Description: 计算CRC16的数值，
53:                //Input: 需计算数据，数据长度 
54:                //Output: CRC16的结果值
55:                //*************************************/
56:                //uint16_t crc16(uint8_t * frame, uint16_t len )
57:                //{
58:                //    uint8_t ucCRCHi = 0xFF;
59:                //    uint8_t ucCRCLo = 0xFF;
60:                //    long iIndex;
61:                //    
62:                //    while(len--)
63:                //    {
64:                //        iIndex = ucCRCLo ^ (*frame);
65:                //        ucCRCLo = (uint8_t)( ucCRCHi ^ aucCRCHi[iIndex]);
66:                //        ucCRCHi = aucCRCLo[iIndex];
67:                //    }
68:                //    return (uint16_t)( ucCRCHi|(ucCRCLo<<8));
69:                //}
70:                
71:                ///****************************************************************************
72:                //名称: CRC16()
73:                //说明: CRC16校验程序
74:                //参数: 		*CRC_Buf:数据地址
75:                //                       CRC_Leni:数据长度
76:                //返回:                   CRC_Sumx:校验值
77:                // *****************************************************************************/
78:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, uint8_t CRC_Leni) {
79:                //    uint8_t i, j;
80:                //    uint16_t CRC_Sumx;
81:                //
82:                //    CRC_Sumx = 0xFFFF;
83:                //    for (i = 0; i < CRC_Leni; i++) {
84:                //        CRC_Sumx ^= *(CRC_Buf + i); //异或
85:                //        for (j = 0; j < 8; j++) {
86:                //            if (CRC_Sumx & 0x01) {
87:                //                CRC_Sumx >>= 1;
88:                //                CRC_Sumx ^= 0xA001;
89:                //            } else {
90:                //                CRC_Sumx >>= 1;
91:                //            }
92:                //        }
93:                //    }
94:                //    return (CRC_Sumx);
95:                //}
96:                
97:                /****************************************************************************
98:                名称: CRC16()
99:                说明: CRC16校验程序
100:               参数: 		*CRC_Buf:数据地址
101:                                      CRC_Leni:数据长度
102:               返回:                   CRC_Sumx:校验值
103:                *****************************************************************************/
104:               uint16_t CRC16_Check(uint8_t *CRC_Buf, uint8_t CRC_Leni) {
00327C  FA0008     LNK #0x8
00327E  980720     MOV W0, [W14+4]
003280  984761     MOV.B W1, [W14+6]
105:                   uint8_t i, j;
106:                   uint16_t CRC_Sumx;
107:               
108:                   CRC_Sumx = 0xFFFF;
003282  EB8000     SETM W0
003284  980710     MOV W0, [W14+2]
109:                   for (i = 0; i < CRC_Leni; i++) {
003286  EB4000     CLR.B W0
003288  784F00     MOV.B W0, [W14]
00328A  370022     BRA 0x32D0
0032CE  E84F1E     INC.B [W14], [W14]
0032D0  90406E     MOV.B [W14+6], W0
0032D2  78409E     MOV.B [W14], W1
0032D4  50CF80     SUB.B W1, W0, [W15]
0032D6  39FFDA     BRA NC, 0x328C
110:                       CRC_Sumx ^= *(CRC_Buf + i); //异或
00328C  FB801E     ZE [W14], W0
00328E  9000AE     MOV [W14+4], W1
003290  408000     ADD W1, W0, W0
003292  784010     MOV.B [W0], W0
003294  FB8000     ZE W0, W0
003296  90009E     MOV [W14+2], W1
003298  688000     XOR W1, W0, W0
00329A  980710     MOV W0, [W14+2]
111:                       for (j = 0; j < 8; j++) {
00329C  EB4000     CLR.B W0
00329E  984710     MOV.B W0, [W14+1]
0032A0  370013     BRA 0x32C8
0032C2  90401E     MOV.B [W14+1], W0
0032C4  E84000     INC.B W0, W0
0032C6  984710     MOV.B W0, [W14+1]
0032C8  90401E     MOV.B [W14+1], W0
0032CA  504FE7     SUB.B W0, #0x7, [W15]
0032CC  36FFEA     BRA LEU, 0x32A2
112:                           if (CRC_Sumx & 0x01) {
0032A2  90001E     MOV [W14+2], W0
0032A4  600061     AND W0, #0x1, W0
0032A6  784000     MOV.B W0, W0
0032A8  E00400     CP0.B W0
0032AA  320008     BRA Z, 0x32BC
113:                               CRC_Sumx >>= 1;
0032AC  90001E     MOV [W14+2], W0
0032AE  D10000     LSR W0, W0
0032B0  980710     MOV W0, [W14+2]
114:                               CRC_Sumx ^= 0xA001;
0032B2  90009E     MOV [W14+2], W1
0032B4  2A0010     MOV #0xA001, W0
0032B6  688000     XOR W1, W0, W0
0032B8  980710     MOV W0, [W14+2]
0032BA  370003     BRA 0x32C2
115:                           } else {
116:                               CRC_Sumx >>= 1;
0032BC  90001E     MOV [W14+2], W0
0032BE  D10000     LSR W0, W0
0032C0  980710     MOV W0, [W14+2]
117:                           }
118:                       }
119:                   }
120:                   *(CRC_Buf + CRC_Leni) = CRC_Sumx & 0x00ff;//自动添加CRC的数据结果
0032D8  90406E     MOV.B [W14+6], W0
0032DA  FB8000     ZE W0, W0
0032DC  9000AE     MOV [W14+4], W1
0032DE  408000     ADD W1, W0, W0
0032E0  90009E     MOV [W14+2], W1
0032E2  784081     MOV.B W1, W1
0032E4  784801     MOV.B W1, [W0]
121:                   *(CRC_Buf + CRC_Leni + 1) = CRC_Sumx >> 8;
0032E6  90406E     MOV.B [W14+6], W0
0032E8  FB8000     ZE W0, W0
0032EA  E80000     INC W0, W0
0032EC  9000AE     MOV [W14+4], W1
0032EE  408000     ADD W1, W0, W0
0032F0  90009E     MOV [W14+2], W1
0032F2  DE08C8     LSR W1, #8, W1
0032F4  784081     MOV.B W1, W1
0032F6  784801     MOV.B W1, [W0]
122:                   return (CRC_Sumx);
0032F8  90001E     MOV [W14+2], W0
123:               }
0032FA  FA8000     ULNK
0032FC  060000     RETURN
124:               
125:               /*************************************
126:               Function: Sum_Check 
127:               Description: 计算和校验的数值，
128:               Input: 需计算数据，数据长度 
129:               Output: 和校验的结果值
130:                *************************************/
131:               uint16_t Sum_Check(uint8_t *frame, uint8_t bytes) {
0032FE  FA0006     LNK #0x6
003300  980710     MOV W0, [W14+2]
003302  984741     MOV.B W1, [W14+4]
132:                   uint16_t cksum = 0;
003304  EB0000     CLR W0
003306  780F00     MOV W0, [W14]
133:               
134:                   while (bytes > 0) {
003308  37000A     BRA 0x331E
00331E  90404E     MOV.B [W14+4], W0
003320  E00400     CP0.B W0
003322  3AFFF3     BRA NZ, 0x330A
135:                       cksum += *frame++;
00330A  90001E     MOV [W14+2], W0
00330C  784010     MOV.B [W0], W0
00330E  FB8000     ZE W0, W0
003310  400F1E     ADD W0, [W14], [W14]
003312  90001E     MOV [W14+2], W0
003314  E80000     INC W0, W0
003316  980710     MOV W0, [W14+2]
136:                       bytes--;
003318  90404E     MOV.B [W14+4], W0
00331A  E94000     DEC.B W0, W0
00331C  984740     MOV.B W0, [W14+4]
137:                   }
138:                   return cksum;
003324  78001E     MOV [W14], W0
139:               }
003326  FA8000     ULNK
003328  060000     RETURN
140:               
141:               /*************************************
142:               Function: CheckIsRight  
143:               Description: 判断接受dat，根据fp校验，返回数据正确性
144:               Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
145:               Output: 1：校验正确  0：校验错误
146:                *************************************/
147:               bool CheckIsRight(FP_CRC fp, uint8_t * dat, const uint8_t bytes) {
00332A  FA0008     LNK #0x8
00332C  980710     MOV W0, [W14+2]
00332E  980721     MOV W1, [W14+4]
003330  984762     MOV.B W2, [W14+6]
148:                   uint16_t CRCtep = fp(dat, bytes); //CRC校验
003332  90011E     MOV [W14+2], W2
003334  9040EE     MOV.B [W14+6], W1
003336  90002E     MOV [W14+4], W0
003338  010002     CALL W2
00333A  780F00     MOV W0, [W14]
149:                   return (CRCtep == (*(dat + bytes)+ (*(dat + bytes + 1) << 8))); //校验数据+CRC
00333C  90406E     MOV.B [W14+6], W0
00333E  FB8000     ZE W0, W0
003340  9000AE     MOV [W14+4], W1
003342  408000     ADD W1, W0, W0
003344  784010     MOV.B [W0], W0
003346  FB8080     ZE W0, W1
003348  90406E     MOV.B [W14+6], W0
00334A  FB8000     ZE W0, W0
00334C  E80000     INC W0, W0
00334E  90012E     MOV [W14+4], W2
003350  410000     ADD W2, W0, W0
003352  784010     MOV.B [W0], W0
003354  FB8000     ZE W0, W0
003356  DD0048     SL W0, #8, W0
003358  408000     ADD W1, W0, W0
00335A  68001E     XOR W0, [W14], W0
00335C  A7F000     BTSC W0, #15
00335E  EA0000     NEG W0, W0
003360  E90000     DEC W0, W0
003362  DE004F     LSR W0, #15, W0
003364  784000     MOV.B W0, W0
150:               }
003366  FA8000     ULNK
151:               
152:               
153:               
