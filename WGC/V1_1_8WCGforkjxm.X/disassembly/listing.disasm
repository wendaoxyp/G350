Disassembly Listing for V1_1_7WCGforkjxm
Generated From:
C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/dist/default/production/V1_1_7WCGforkjxm.X.production.elf
2017-11-1 10:36:33

---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/main.c  -------------------------------------
1:                 /**
2:                   Generated Main Source File
3:                 
4:                   Company:
5:                     Microchip Technology Inc.
6:                 
7:                   File Name:
8:                     main.c
9:                 
10:                  Summary:
11:                    This is the main file generated using MPLAB? Code Configurator
12:                
13:                  Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB? Code Configurator - v2.25.2
17:                        Device            :  PIC24FJ64GA306
18:                        Driver Version    :  2.00
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.24
21:                        MPLAB             :  MPLAB X v2.35 or v3.00
22:                 */
23:                
24:                
25:                /*
26:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
27:                
28:                Microchip licenses to you the right to use, modify, copy and distribute
29:                Software only when embedded on a Microchip microcontroller or digital signal
30:                controller that is integrated into your product or third party product
31:                (pursuant to the sublicense terms in the accompanying license agreement).
32:                
33:                You should refer to the license agreement accompanying this Software for
34:                additional information regarding your rights and obligations.
35:                
36:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                 */
47:                
48:                
49:                #include <includes.h>
50:                #include "Configbits.h"
51:                
52:                #ifdef DEBUG_MAIN_VAR
53:                volatile uint32_t rtime;
54:                uint8_t main_cnt = 0;
55:                //uint32_t main_nums;
56:                //volatile uint8_t samplecount;
57:                //volatile uint8_t samplecount1;
58:                #endif
59:                
60:                /*
61:                                         Main application
62:                 */
63:                void main(void) {
00368C  FA0000     LNK #0x0
64:                    //    uint32_t nums = 1;
65:                    //    uint8_t tmp[10];    
66:                    BSP_Init(); //底层驱动初始化
00368E  07FF18     RCALL BSP_Init
67:                    NUMS_SHOW(1, 0);
003690  EB0080     CLR W1
003692  200010     MOV #0x1, W0
003694  07F2F5     RCALL NUMS_SHOW
68:                    IFS3bits.RTCIF = 1; //外设相关的中断标志状态位清零
003696  A8C08B     BSET 0x8B, #6
69:                    RS485SendString("Start", 5); //先发送一个字节，避免接收错误
003698  290F60     MOV #0x90F6, W0
00369A  B3C051     MOV.B #0x5, W1
00369C  07FE58     RCALL RS485SendString
70:                    while (1) {
71:                        //        Delay1s(5);
72:                        //        WGCPCCop();
73:                        //优化低功耗，关闭模块
74:                        while (!WGCCON2bits.PC_Cop_FLAG && !WGCCON2bits.Send_FLAG) {//如果处于通讯阶段或是发送数据的话，那么就跳过循环
00369E  370003     BRA 0x36A6
0036A6  804051     MOV WGCCON2bits, W1
0036A8  280000     MOV #0x8000, W0
0036AA  608000     AND W1, W0, W0
0036AC  E00000     CP0 W0
0036AE  3A0005     BRA NZ, 0x36BA
0036B0  804051     MOV WGCCON2bits, W1
0036B2  220000     MOV #0x2000, W0
0036B4  608000     AND W1, W0, W0
0036B6  E00000     CP0 W0
0036B8  32FFF3     BRA Z, 0x36A0
0036D0  37FFEA     BRA 0x36A6
75:                            U1MODEbits.WAKE = 1;
0036A0  A8E220     BSET U1MODE, #7
76:                            Sleep();
0036A2  FE4000     PWRSAV #0
77:                            U1MODEbits.WAKE = 1;
0036A4  A8E220     BSET U1MODE, #7
78:                        }
79:                        //        U1MODEbits.WAKE = 1;
80:                        //#ifdef DEBUG_RTCC_TIME
81:                        //        while (!WGCCON2bits.SET_TIME_TEST_FLAG);
82:                        //        if (WGCCON2bits.SET_TIME_TEST_FLAG) {
83:                        //            WGCCON2bits.SET_TIME_TEST_FLAG = 0; //清楚标志位
84:                        //            RS485SendString1("\r\n/*********************************************************\r\n");
85:                        //            RS485SendString1("Nt:");
86:                        //            PrintTime(); //打印当前时间
87:                        //            //            RS485SendString("\tSetting Alarm Time is ", 12);
88:                        //            printrtccArg();
89:                        //            printnums(rtime);
90:                        //            RS485SendString1("\r\n**********************************************************/\r\n");
91:                        //        }
92:                        //#endif
93:                        //        CAT24C512_Write(0, "12S34567980124567890123456789");
94:                        if (WGCCON2bits.Send_FLAG) {
0036BA  804051     MOV WGCCON2bits, W1
0036BC  220000     MOV #0x2000, W0
0036BE  608000     AND W1, W0, W0
0036C0  E00000     CP0 W0
0036C2  320005     BRA Z, 0x36CE
95:                            WGCCON2bits.Send_FLAG = 0;
0036C4  A9A80B     BCLR 0x80B, #5
96:                            WGCCNTbits.Send_CNT++;
0036C6  8040D0     MOV 0x81A, W0
0036C8  E80000     INC W0, W0
0036CA  8840D0     MOV W0, 0x81A
97:                            GPRS_Task();
0036CC  07ED33     RCALL GPRS_Task
98:                        }
99:                        //        Delay100ms(1);
100:                       //        LED_Toggle();
101:                       //        if (WGCCON2bits.Sample_FLAG) {
102:               
103:                       //            }
104:                       //        }
105:                       //                Delay1ms(1);
106:                       //        LED_Toggle(); //  
107:                       //        printf("Hello world%d,\n",123);
108:                       //        NUMS_SHOW(nums++, 0);
109:                       //        RS485SendString("Now time is ", 12);
110:                       //        PrintTime();
111:                   }
0036CE  000000     NOP
112:               }
113:               
114:               /**
115:                End of File
116:                */
117:               
118:               //void Task1Led(void* p_arg) {
119:               ////    INT8U err;
120:               //    //    uint8_t cnt = 0;
121:               //    //    OS_EVENT sem1;
122:               //    while (1) {
123:               //        //        PrintTime();
124:               //        switch (WGC_sta) {
125:               //            case 1://进入睡眠模式
126:               //            {
127:               //                LED_Toggle();
128:               //                OSTimeDlyHMSM(0, 0, 1, 0); //延时1s 
129:               //                break;
130:               //            }
131:               //            case 2://上线过程
132:               //            {
133:               //                LED_Toggle();
134:               //                OSTimeDlyHMSM(0, 0, 0, 500); //延时1s  
135:               //                break;
136:               //            }
137:               //            case 3://发送数据
138:               //            {
139:               //                LED_On();
140:               //                OSTimeDlyHMSM(0, 0, 3, 0); //避免任务锁死  
141:               //                break;
142:               //            }
143:               //            case 4://采集数据
144:               //            {
145:               //                LED_Toggle();
146:               //                OSTimeDlyHMSM(0, 0, 0, 200); //延时1s  
147:               //                break;
148:               //            }
149:               //            default://工作模式
150:               //            {
151:               //                LED_Toggle();
152:               //                err = OSTimeDlyHMSM(0, 0, 0, 300); //延时1s                  
153:               //                break;
154:               //            }
155:               //
156:               //        }
157:               //    }
158:               //}
159:               
160:               //void Task2UseHL6528(void *p_arg) {
161:               ////    INT8U err;
162:               //    HL6528_Init(); /*Initialize the HL6528*/
163:               //    //    OSTimeDlyHMSM(0, 0, 5, 0);
164:               //    while (1) {
165:               //        //        OSSemPend(sem_send_pressure, 0, &err);
166:               //        HL6528_GetIP_Port(); //每次通讯都更新下IP地址和端口号
167:               //        UART2_Open();
168:               //        WGC_sta = 2; //GPRS拨号
169:               //        //        HL6528_GetIP_Port(tmp);
170:               //        if (!HL6528_DialingIsERR()) {
171:               //            WGC_sta = 3; //GPRS发送数据
172:               //            OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
173:               //            UART2_SendString("103.1");
174:               //            OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
175:               //        }
176:               //        HL6528_Close();
177:               //        WGC_sta = 0; //GPRS拨号
178:               //    }
179:               //}
180:               
181:               //void Task3UseE41(void *parg) {
182:               ////    uint8_t err;
183:               //    float f_dat;
184:               //    E41_Init();
185:               //    OSTimeDlyHMSM(0, 0, 1, 0); //延时1s
186:               //    //    uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34};
187:               //    //    E41_SetArg(); //E41设置参数
188:               //    while (1) {
189:               //        OSSemPend(sem_get_pressure, 0, &err); //等待主动采集指令
190:               //        E41_Active_Send();
191:               //        OSSemPend(sem_receive_pressure, 1000, &err);
192:               //        WGC_sta = 4;
193:               //        OSTimeDlyHMSM(0, 0, 3, 0); //延时1s
194:               //        //        LED_Toggle();
195:               //        //        OSTimeDlyHMSM(0, 0, 0, 200);
196:               //        if (E41_PressureIsGet(&f_dat)) {
197:               //            OSSemPost(sem_send_pressure);
198:               //            //            OSMboxPost(E41_Dat, &f_dat); //通过邮箱发送数据给服务器
199:               //        }
200:               //        WGC_sta = 0;
201:               //        //        UART3_SendString(E41_tmp, 5);
202:               //        //        OSTimeDlyHMSM(0, 0, 10, 0); //延时1s
203:               //    }
204:               //}
205:               
206:               //void Task4Use485(void *parg) {
207:               //    parg = parg;
208:               //    while (1) {
209:               //        RS485SendChar(0x30);
210:               //        //        RS485SendString("123", 3);
211:               //        OSTimeDlyHMSM(0, 0, 1, 0);
212:               //        //        OSSemPost(sem1);
213:               //    }
214:               //}
215:               
216:               //void Task5UseCAT24C512(void* parg) {
217:               //    INT8U err;
218:               //    parg = parg; //防止编译器警告
219:               //    CAT24C512_Init(); //应用程序初始化
220:               //
221:               //    while (1) {
222:               //        //等待使用互斥量信号
223:               //        //通过邮箱判断存储还是读取
224:               //        //
225:               ////        OSMutexPost();
226:               ////        OSMutexPend();
227:               ////        OSMBoxPost
228:               ////        OSSemPend(sem2, 0, &err); //, 0, &err);
229:               ////        -(0, tmp2);
230:               //    }
231:               //}
232:               
233:               //void Task6Sleep(void* p_arg) {
234:               //    p_arg = p_arg;
235:               //    LED_Off();
236:               //    
237:               //    OSSchedLock();//禁止任务调度
238:               //    while (1) {
239:               //        DeepSleep();
240:               //        OSSemPost(sem2); //, 0, &err);
241:               //        //        Sleep();
242:               //
243:               //    }
244:               ////    OSSchedUnlock();//允许任务调度
245:               //}
246:               
247:               //void Task7SetAlarm(void *p_arg) {
248:               ////    INT8U err;
249:               ////    WGC_sta = 0;
250:               ////    IFS3bits.RTCIF = 1; //启动闹钟一次，方便下次设置时间 用于测试
251:               ////
252:               ////    while (1) {
253:               ////        OSSemPend(sem_set_alarm, 0, &err);
254:               //////        PrintTime();
255:               ////        WGC_CalcAlarmPeriod(); //计算周期
256:               ////        //        OSSemPost(sem_get_pressure); //主动采集
257:               ////    }
258:               //}
259:               
260:               
261:               
262:               //        if (WGCCON2bits.PC_Cop_FLAG) {
263:               //            WGCCON2bits.PC_Cop_FLAG = 0;
264:               //            Delay1s(5);
265:               //            WGCPCCop(); //处理用户通讯交互任务
266:               //        }
267:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/WGC.c  --------------------------------------
1:                 #include "WGC.h"
2:                 
3:                 #define TIMEOFFSET 1483200000
4:                 const uint8_t WGC[] = "WGC";
5:                 #define TimeRegAdd 0x00
6:                 #define GPRSRegAdd 0x06
7:                 #define IDRegAdd 0x08
8:                 #define IPRegAdd 0x09
9:                 #define PortRegAdd 0x0d
10:                //#define TimeRegAdd 0x00
11:                const uint8_t RegAdd[] = {0x00, 0x06, 0x0a, 0x0b, 0x0f, 0x11};
12:                //const uint8_t RegNum[] = {0x06, 0x01, 0x01, 0x01, 0x04, 0x02};
13:                
14:                //enum {Jan=31,Feb=30,Mar=31,Apr=30,May=31,Jun=30,Jul=31,Aug=31,Sep=30,Oct=31,Nov=30,Dec=31};
15:                //const uint8_t Month[12] = {31, 30, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
16:                const uint8_t Sendstr[] = {0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x85, 0xD4}; //获取压力的指令
17:                volatile WGCTIME0BITS WGCTIME0bits;
18:                volatile WGCTIME1BITS WGCTIME1bits;
19:                volatile WGCTIME2BITS WGCTIME2bits;
20:                volatile WGCCON0BITS WGCCON0bits;
21:                volatile WGCCON1BITS WGCCON1bits;
22:                volatile WGCCON2BITS WGCCON2bits;
23:                volatile WGCCON3BITS WGCCON3bits;
24:                volatile WGCCON4BITS WGCCON4bits;
25:                volatile WGCIPBITS WGCIPbits;
26:                volatile WGCCNTBITS WGCCNTbits;
27:                volatile uint16_t WGCPORT;
28:                //volatile WGCPERIODBITS WGCPeriodbits;
29:                volatile uint8_t WGC_Sta = 1;
30:                float f_p;
31:                //struct RTCC_Time_Node RT_node;
32:                
33:                //static volatile struct RTCC_Time_Node rtcc_sample;
34:                //static volatile struct RTCC_Time_Node rtcc_send;
35:                static uint8_t MKSendString(uint8_t* tmp);
36:                static uint8_t HandleArg(uint8_t funcode, uint8_t regadd, uint8_t *arg);
37:                static void RefreshReg(void);
38:                
39:                void WGC_Init(void) {
0010FC  FA0000     LNK #0x0
40:                    WGCIPbits.IP3 = 183; //设置IP地址
0010FE  B3CB70     MOV.B #0xB7, W0
001100  B7E817     MOV.B WREG, 0x817
41:                    WGCIPbits.IP2 = 246;
001102  B3CF60     MOV.B #0xF6, W0
001104  B7E816     MOV.B WREG, 0x816
42:                    WGCIPbits.IP1 = 74;
001106  B3C4A0     MOV.B #0x4A, W0
001108  B7E815     MOV.B WREG, 0x815
43:                    WGCIPbits.IP0 = 68;
00110A  B3C440     MOV.B #0x44, W0
00110C  B7E814     MOV.B WREG, WGCIPbits
44:                    WGCPORT = 5070; //设置端口号
00110E  213CE0     MOV #0x13CE, W0
001110  8840E0     MOV W0, WGCPORT
45:                    WGCCON0bits.Send_60s = 2; //发送2分钟 mark1
001112  804031     MOV WGCCON0bits, W1
001114  2F8000     MOV #0xF800, W0
001116  608000     AND W1, W0, W0
001118  A01000     BSET W0, #1
00111A  884030     MOV W0, WGCCON0bits
46:                    WGCCON1bits.Sample_5s =12; //采集5秒
00111C  804041     MOV WGCCON1bits, W1
00111E  280000     MOV #0x8000, W0
001120  608000     AND W1, W0, W0
001122  B300C0     IOR #0xC, W0
001124  884040     MOV W0, WGCCON1bits
47:                    WGCCON2bits.E41_Is_Use_For_Send_Data = 0; //关闭E41
001126  A9080B     BCLR 0x80B, #0
48:                    WGCCON2bits.E41_Is_Use_For_Set_Arg = 0; //关闭E41
001128  A9280B     BCLR 0x80B, #1
49:                    WGCCON2bits.WGC_ID = 0x03; //ID号
00112A  B3C030     MOV.B #0x3, W0
00112C  B7E80A     MOV.B WREG, WGCCON2bits
50:                    //    RTCC_TIME_Init(); //初始化RTCC_TIME数据结构
51:                    WGCCON2bits.Period_FLAG = 1; //初始化开始计算时间
00112E  A8680B     BSET 0x80B, #3
52:                    //    WGCPeriodbits.CNT = 0;
53:                    //    WGCCON2bits.Alarm_RST_FLAG = 0; //上电成重新计算
54:                }
001130  FA8000     ULNK
001132  060000     RETURN
55:                
56:                //static void GetPressure(void) {
57:                //    
58:                //}
59:                
60:                //bool WGC_CalcAlarmPeriod(void) {//设置下次报警时间
61:                //    struct tm now_time1, now_time2;
62:                //    uint32_t time1;
63:                //    //获取当前的时间，然后在这个时间的基础上加上秒数
64:                //    while (!RTC_Read_Time(&now_time1)); //容错设计
65:                //    //    while (!RTC_Read_Time(&now_time1)); //容错设计
66:                //    time1 = mktime(&now_time1);
67:                //    time1 += 10;
68:                //    now_time2 = *gmtime(&time1);
69:                //
70:                //    RTC_Set_Alarm(now_time1);
71:                //}
72:                
73:                void GPRS_Task(void) {
001134  FA0016     LNK #0x16
74:                    uint8_t tmp[20], bytes = 0, IsErr;
001136  EB4000     CLR.B W0
001138  784F00     MOV.B W0, [W14]
75:                    HL6528_GetIP_Port(); //每次通讯都更新下IP地址和端口号
00113A  070D31     RCALL HL6528_GetIP_Port
76:                    UART2_Open();
00113C  071077     RCALL UART2_Open
77:                    Delay1s(5); //避免串口检测不到 最好使用#ifdef
00113E  B3C050     MOV.B #0x5, W0
001140  07088C     RCALL Delay1s
78:                    WGC_Sta = GPRS_Dingling; //GPRS拨号
001142  B3C010     MOV.B #0x1, W0
001144  B7E84A     MOV.B WREG, 0x84A
79:                
80:                    IsErr = HL6528_DialingIsERR();
001146  070CA2     RCALL HL6528_DialingIsERR
001148  984710     MOV.B W0, [W14+1]
81:                    //    RS485SendString1("GPRS ONline Now!!!");
82:                    if (!IsErr) {
00114A  90401E     MOV.B [W14+1], W0
00114C  E00400     CP0.B W0
00114E  3A0011     BRA NZ, 0x1172
83:                        LED_On();
001150  0711CC     RCALL LED_On
84:                        WGC_Sta = GPRS_Online; //GPRS发送数据
001152  B3C020     MOV.B #0x2, W0
001154  B7E84A     MOV.B WREG, 0x84A
85:                        Delay1s(1); //延时1s
001156  B3C010     MOV.B #0x1, W0
001158  070880     RCALL Delay1s
86:                        LED_Off();
00115A  0711CB     RCALL LED_Off
87:                        //        CAT24C512_Read(1, tmp); //获取数据  !!!添加判断 如果I2C错误
88:                        bytes = MKSendString(tmp);
00115C  E8800E     INC2 W14, W0
00115E  07034C     RCALL _MKSendString
001160  784F00     MOV.B W0, [W14]
89:                        //处理数据
90:                        UART2_SendString2(tmp, bytes); //发送传输数据
001162  E8800E     INC2 W14, W0
001164  78409E     MOV.B [W14], W1
001166  07108D     RCALL UART2_SendString2
91:                        Delay1s(1); //延时1s
001168  B3C010     MOV.B #0x1, W0
00116A  070877     RCALL Delay1s
92:                #ifdef DEBUG_SEND
93:                        RS485SendString1("GPRS ONline Now!!!");
00116C  290960     MOV #0x9096, W0
00116E  07110A     RCALL RS485SendString1
001170  370007     BRA 0x1180
94:                #endif 
95:                    } else {
96:                        WGC_Sta = GPRS_Err; //GPRS拨号失败
001172  B3C060     MOV.B #0x6, W0
001174  B7E84A     MOV.B WREG, 0x84A
97:                #ifdef DEBUG_SEND
98:                        RS485SendString1("\r\nGPRS DialingFail!!!Code:");
001176  290A90     MOV #0x90A9, W0
001178  071105     RCALL RS485SendString1
99:                        printnums(IsErr);
00117A  90401E     MOV.B [W14+1], W0
00117C  FB8000     ZE W0, W0
00117E  070AA3     RCALL printnums
100:               #endif
101:                   }
102:                   HL6528_Close(); //发送AT指令传输数据}
001180  070CD5     RCALL HL6528_Close
103:               //    if (IsErr) {
104:               //        LED_On();
105:               //        Delay1s(1); //延时1s
106:               //        LED_Off();
107:               //    }
108:               }
001182  FA8000     ULNK
001184  060000     RETURN
109:               
110:               bool Sample_Task(void) {
001186  FA0072     LNK #0x72
111:                   StrCmp pressure;
112:                   struct tm nowtime;
113:                   uint8_t Getstr[20] = {0x01, 0x03, 0x04}; //用于保存接收的数据
001188  78008E     MOV W14, W1
00118A  B00201     ADD #0x20, W1
00118C  090009     REPEAT #0x9
00118E  EB1880     CLR [W1++]
001190  B3C010     MOV.B #0x1, W0
001192  986700     MOV.B W0, [W14+32]
001194  B3C030     MOV.B #0x3, W0
001196  986710     MOV.B W0, [W14+33]
001198  B3C040     MOV.B #0x4, W0
00119A  986720     MOV.B W0, [W14+34]
114:                   uint8_t Savstr[50] = {0x00}; //uart获取缓冲区数据01 03 04 3E F4 00 00 B6 29
00119C  78008E     MOV W14, W1
00119E  B00341     ADD #0x34, W1
0011A0  090018     REPEAT #0x18
0011A2  EB1880     CLR [W1++]
115:                   uint8_t Senstr[12] = {0};
0011A4  78008E     MOV W14, W1
0011A6  B00661     ADD #0x66, W1
0011A8  090005     REPEAT #0x5
0011AA  EB1880     CLR [W1++]
116:                   uint8_t cnt = 0; //计数
0011AC  EB4000     CLR.B W0
0011AE  784F00     MOV.B W0, [W14]
117:               
118:                   //    RS485SendString(Sendstr, 8);
119:                   //    //    RS485SendString(Sendstr, 8);
120:                   //    //    RS485SendString(Sendstr, 8);
121:                   //    Delay1s(1); //延时1s 需要测试下
122:                   //    RS485SendString(Sendstr, 8);
123:                   //    //    RS485SendString(Sendstr, 8);
124:                   //    //    RS485SendString(Sendstr, 8);
125:                   //    Delay1s(1); //延时1s 需要测试下
126:                   pressure.CheckData = Getstr;
0011B0  200200     MOV #0x20, W0
0011B2  40000E     ADD W0, W14, W0
0011B4  980730     MOV W0, [W14+6]
127:                   pressure.Check_len = 3;
0011B6  B3C030     MOV.B #0x3, W0
0011B8  984F00     MOV.B W0, [W14+8]
128:                   pressure.GetData = Getstr;
0011BA  200200     MOV #0x20, W0
0011BC  40000E     ADD W0, W14, W0
0011BE  980750     MOV W0, [W14+10]
129:                   pressure.Get_len = 9;
0011C0  B3C090     MOV.B #0x9, W0
0011C2  984F40     MOV.B W0, [W14+12]
130:                   pressure.SourceData = Savstr;
0011C4  200340     MOV #0x34, W0
0011C6  40000E     ADD W0, W14, W0
0011C8  980710     MOV W0, [W14+2]
131:                   do {
132:                       cnt++;
0011CA  E84F1E     INC.B [W14], [W14]
133:                       if (cnt > 5)
0011CC  78401E     MOV.B [W14], W0
0011CE  504FE5     SUB.B W0, #0x5, [W15]
0011D0  360002     BRA LEU, 0x11D6
134:                           return false; //循环5次后，还未获取到有效的压力值，直接返回false
0011D2  EB4000     CLR.B W0
0011D4  37003F     BRA 0x1254
135:                       RS485SendString(Sendstr, 8);
0011D6  200081     MOV #0x8, W1
0011D8  2908E0     MOV #0x908E, W0
0011DA  0710B9     RCALL RS485SendString
136:                       Delay1s(1); //延时1s 
0011DC  B3C010     MOV.B #0x1, W0
0011DE  07083D     RCALL Delay1s
137:                       pressure.Source_len = UARTGetData(BufferRead_UART1, Savstr, 50);
0011E0  200340     MOV #0x34, W0
0011E2  40000E     ADD W0, W14, W0
0011E4  B3C322     MOV.B #0x32, W2
0011E6  780080     MOV W0, W1
0011E8  227880     MOV #0x2788, W0
0011EA  070BE3     RCALL UARTGetData
0011EC  984740     MOV.B W0, [W14+4]
138:               
139:                   } while (!UARTDataIsRight(&pressure));
0011EE  E8800E     INC2 W14, W0
0011F0  070B1D     RCALL UARTDataIsRight
0011F2  A20400     BTG.B W0, #0
0011F4  E00400     CP0.B W0
0011F6  3AFFE9     BRA NZ, 0x11CA
140:                   CharToFloat(&f_p, Getstr + 3);
0011F8  200200     MOV #0x20, W0
0011FA  40000E     ADD W0, W14, W0
0011FC  400063     ADD W0, #0x3, W0
0011FE  780080     MOV W0, W1
001200  2081E0     MOV #0x81E, W0
001202  07072C     RCALL CharToFloat
141:               #ifdef DEBUG_PRESSURE
142:                   RS485SendString1("\r\nGet Pressure!!!\r\n10Mp:");
143:                   CharToFloat(&f_p, Getstr + 3);
144:                   f_p *= 10;
145:                   printnums((uint32_t) (f_p));
146:                   RS485SendString1("\r\n");
147:                   PrintTime(); //打印时间
148:               #endif
149:                   RTC_Read_Time(&nowtime);
001204  47006E     ADD W14, #0xE, W0
001206  070944     RCALL RTC_Read_Time
150:                   Senstr[0] = 0x20;
001208  B3C200     MOV.B #0x20, W0
00120A  98E760     MOV.B W0, [W14+102]
151:                   Senstr[1] = nowtime.tm_year & 0x00ff;
00120C  90084E     MOV [W14+24], W0
00120E  784000     MOV.B W0, W0
001210  98E770     MOV.B W0, [W14+103]
152:                   Senstr[2] = nowtime.tm_mon;
001212  90083E     MOV [W14+22], W0
001214  784000     MOV.B W0, W0
001216  98EF00     MOV.B W0, [W14+104]
153:                   Senstr[3] = nowtime.tm_mday;
001218  90082E     MOV [W14+20], W0
00121A  784000     MOV.B W0, W0
00121C  98EF10     MOV.B W0, [W14+105]
154:                   Senstr[4] = nowtime.tm_hour;
00121E  90081E     MOV [W14+18], W0
001220  784000     MOV.B W0, W0
001222  98EF20     MOV.B W0, [W14+106]
155:                   Senstr[5] = nowtime.tm_min;
001224  90080E     MOV [W14+16], W0
001226  784000     MOV.B W0, W0
001228  98EF30     MOV.B W0, [W14+107]
156:                   Senstr[6] = nowtime.tm_sec;
00122A  90007E     MOV [W14+14], W0
00122C  784000     MOV.B W0, W0
00122E  98EF40     MOV.B W0, [W14+108]
157:                   CopyDat(Senstr + 7, Getstr + 3, 4); //赋值数据
001230  200200     MOV #0x20, W0
001232  40000E     ADD W0, W14, W0
001234  4000E3     ADD W0, #0x3, W1
001236  200660     MOV #0x66, W0
001238  40000E     ADD W0, W14, W0
00123A  400067     ADD W0, #0x7, W0
00123C  B3C042     MOV.B #0x4, W2
00123E  07082A     RCALL CopyDat
158:                   Senstr[11] = Sum_Check(Senstr, 11);
001240  200660     MOV #0x66, W0
001242  40000E     ADD W0, W14, W0
001244  B3C0B1     MOV.B #0xB, W1
001246  070F2E     RCALL Sum_Check
001248  784000     MOV.B W0, W0
00124A  98F710     MOV.B W0, [W14+113]
159:                   CAT24C512_Write(Savstr); //存储数据
00124C  200340     MOV #0x34, W0
00124E  40000E     ADD W0, W14, W0
001250  070D8E     RCALL CAT24C512_Write
160:                   return true;
001252  B3C010     MOV.B #0x1, W0
161:               
162:                   //#ifdef DEBUG_PRESSURE
163:                   //    RS485SendString1("\r\nCan't get pressure!!!\r\n");
164:                   //#endif
165:               
166:               }
001254  FA8000     ULNK
001256  060000     RETURN
167:               
168:               
169:               
170:               //    if (WGCCON2bits.Alarm_RST_FLAG) {//如果需要重启的话,那么重新计算周期参数；反之，设置下次报警的时间
171:               //        WGCCON2bits.Alarm_RST_FLAG = 0; //清楚标志为
172:               //        if (WGCCON0bits.Send_60s < 3)//发送阈值判断
173:               //            WGCCON0bits.Send_60s = 3;
174:               //        else if (WGCCON0bits.Send_60s > 1440)
175:               //            WGCCON0bits.Send_60s = 1440;
176:               //        if (WGCCON1bits.Sample_5s < 1)//采集阈值判断
177:               //            WGCCON1bits.Sample_5s = 1;
178:               //        else if (WGCCON1bits.Sample_5s > 17280)
179:               //            WGCCON1bits.Sample_5s = 17280;
180:               //
181:               //        if (WGCCON1bits.Sample_5s > (WGCCON0bits.Send_60s * 12))//如果采集时间大于发送时间，那么将采集时间设置为发送时间
182:               //            WGCCON1bits.Sample_5s = WGCCON0bits.Send_60s * 12;
183:               //        WGCPeriodbits.B1 = (WGCCON0bits.Send_60s * 12) / WGCCON1bits.Sample_5s; //倍数
184:               //        WGCPeriodbits.Y2 = (WGCCON0bits.Send_60s * 12) % WGCCON1bits.Sample_5s; //余数     
185:               //        WGCPeriodbits.CNT = 0; //清楚计数
186:               //    }
187:               
188:               
189:               
190:               //    if (WGCPeriodbits.CNT == WGCPeriodbits.B1) {//下个时间就是发送的时间
191:               //        //设置报警时间为余数的时间
192:               //        if (!WGCPeriodbits.Y2) {//如果余数为0的话，那么直接设置下次采集时间（上传时间已经到了），反之，设置下次计算上传时间
193:               //            now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
194:               //            //开始调用GPRS上传数据
195:               //            WGCCON2bits.Send_FLAG = 1; //采集时间和发送时间均到了
196:               //            WGCPeriodbits.CNT = 0;
197:               //        } else {
198:               //            now_second += WGCPeriodbits.Y2 * 5; //设置上传时间
199:               //            WGCPeriodbits.CNT += 1;
200:               //        }
201:               //    } else if (WGCPeriodbits.CNT > WGCPeriodbits.B1) {
202:               //        now_second += (WGCCON1bits.Sample_5s * 5); //设置下次报警的时间
203:               //        //开始调用GPRS上传数据
204:               //        WGCPeriodbits.CNT = 0;
205:               //    } else {
206:               //        //设置报警时间为采集的时间
207:               //        WGCCON2bits.Sample_FLAG = 1;
208:               //        now_second += (WGCCON1bits.Sample_5s * 5); //加上报警的时间
209:               //        WGCPeriodbits.CNT += 1;
210:               //    }
211:               
212:               uint32_t CalaAlarmTime(void) {
001258  FA0004     LNK #0x4
213:                   static uint8_t cnt = 0;
214:                   static uint32_t all_alarm_time = 0;
215:                   uint32_t alarm_time = 0; //, tmp;
00125A  B80060     MUL.UU W0, #0, W0
00125C  BE8F00     MOV.D W0, [W14]
216:               
217:                   if (WGCCON2bits.Period_FLAG) {
00125E  804051     MOV WGCCON2bits, W1
001260  208000     MOV #0x800, W0
001262  608000     AND W1, W0, W0
001264  E00000     CP0 W0
001266  320059     BRA Z, 0x131A
218:                       WGCCON2bits.Period_FLAG = 0;
001268  A9680B     BCLR 0x80B, #3
219:               #ifdef DEBUG_RTCC_TIME
220:                       WGCCON3bits.delay = 10; //采集时间
221:                       WGCCON3bits.count = 6; //计算采集的次数
222:                       WGCCON4bits.delay = 0; //计算上传的时间 总时间为12*3+3=39s
223:                       WGCCON4bits.count = 0; //上传累计次数清零
224:               #else
225:                       WGCCON3bits.delay = WGCCON1bits.Sample_5s * 5; //采集时间
00126A  804041     MOV WGCCON1bits, W1
00126C  27FFF0     MOV #0x7FFF, W0
00126E  608000     AND W1, W0, W0
001270  B90065     MUL.SU W0, #5, W0
001272  780000     MOV W0, W0
001274  DE80CF     ASR W0, #15, W1
001276  2FFFF2     MOV #0xFFFF, W2
001278  200013     MOV #0x1, W3
00127A  780280     MOV W0, W5
00127C  780081     MOV W1, W1
00127E  780202     MOV W2, W4
001280  780003     MOV W3, W0
001282  628204     AND W5, W4, W4
001284  608000     AND W1, W0, W0
001286  EB0080     CLR W1
001288  DD00C0     SL W0, #0, W1
00128A  200000     MOV #0x0, W0
00128C  BE0100     MOV.D W0, W2
00128E  B82061     MUL.UU W4, #1, W0
001290  710100     IOR W2, W0, W2
001292  718181     IOR W3, W1, W3
001294  BE0002     MOV.D W2, W0
001296  884060     MOV W0, WGCCON3bits
001298  608061     AND W1, #0x1, W0
00129A  804071     MOV 0x80E, W1
00129C  A10001     BCLR W1, #0
00129E  700001     IOR W0, W1, W0
0012A0  884070     MOV W0, 0x80E
226:                       WGCCON3bits.count = WGCCON0bits.Send_60s * 12 / WGCCON1bits.Sample_5s; //计算采集的次数
0012A2  804031     MOV WGCCON0bits, W1
0012A4  207FF0     MOV #0x7FF, W0
0012A6  608000     AND W1, W0, W0
0012A8  B9006C     MUL.SU W0, #12, W0
0012AA  780080     MOV W0, W1
0012AC  804042     MOV WGCCON1bits, W2
0012AE  27FFF0     MOV #0x7FFF, W0
0012B0  610000     AND W2, W0, W0
0012B2  780100     MOV W0, W2
0012B4  090011     REPEAT #0x11
0012B6  D80082     DIV.SW W1, W2
0012B8  780080     MOV W0, W1
0012BA  27FFF0     MOV #0x7FFF, W0
0012BC  608000     AND W1, W0, W0
0012BE  400000     ADD W0, W0, W0
0012C0  804071     MOV 0x80E, W1
0012C2  6080E1     AND W1, #0x1, W1
0012C4  700001     IOR W0, W1, W0
0012C6  884070     MOV W0, 0x80E
227:                       WGCCON4bits.delay = WGCCON0bits.Send_60s * 60; //(WGCCON0bits.Send_60s * 12 % WGCCON1bits.Sample_5s)*5; //计算上传的时间
0012C8  804031     MOV WGCCON0bits, W1
0012CA  207FF0     MOV #0x7FF, W0
0012CC  608000     AND W1, W0, W0
0012CE  780080     MOV W0, W1
0012D0  2003C0     MOV #0x3C, W0
0012D2  B98800     MUL.SS W1, W0, W0
0012D4  780000     MOV W0, W0
0012D6  DE80CF     ASR W0, #15, W1
0012D8  2FFFF2     MOV #0xFFFF, W2
0012DA  200013     MOV #0x1, W3
0012DC  780280     MOV W0, W5
0012DE  780081     MOV W1, W1
0012E0  780202     MOV W2, W4
0012E2  780003     MOV W3, W0
0012E4  628204     AND W5, W4, W4
0012E6  608000     AND W1, W0, W0
0012E8  EB0080     CLR W1
0012EA  DD00C0     SL W0, #0, W1
0012EC  200000     MOV #0x0, W0
0012EE  BE0100     MOV.D W0, W2
0012F0  B82061     MUL.UU W4, #1, W0
0012F2  710100     IOR W2, W0, W2
0012F4  718181     IOR W3, W1, W3
0012F6  BE0002     MOV.D W2, W0
0012F8  884080     MOV W0, WGCCON4bits
0012FA  608061     AND W1, #0x1, W0
0012FC  804091     MOV 0x812, W1
0012FE  A10001     BCLR W1, #0
001300  700001     IOR W0, W1, W0
001302  884090     MOV W0, 0x812
228:                       WGCCON4bits.count = 0; //上传累计次数清零
001304  804090     MOV 0x812, W0
001306  600061     AND W0, #0x1, W0
001308  884090     MOV W0, 0x812
229:               #endif
230:                       //        WGCCON2bits.Cala_Time_Is_Mod = WGCCON4bits.delay % WGCCON3bits.delay;
231:                       alarm_time = WGCCON3bits.delay; //返回第一次采集时间
00130A  804060     MOV WGCCON3bits, W0
00130C  804072     MOV 0x80E, W2
00130E  6100E1     AND W2, #0x1, W1
001310  BE8F00     MOV.D W0, [W14]
232:                       all_alarm_time = alarm_time; //将累计值初始化
001312  BE011E     MOV.D [W14], W2
001314  884112     MOV W2, all_alarm_time
001316  884123     MOV W3, 0x824
001318  370098     BRA 0x144A
233:                   } else {
234:                       if (cnt < WGCCON3bits.count - 1) {//如果技术的时间还没有到，那么继续将定时设置为采集的时间
00131A  BFC826     MOV.B cnt, WREG
00131C  FB8080     ZE W0, W1
00131E  804070     MOV 0x80E, W0
001320  D10000     LSR W0, W0
001322  E90000     DEC W0, W0
001324  508F80     SUB W1, W0, [W15]
001326  3D0012     BRA GE, 0x134C
235:                           WGCCON2bits.Sample_FLAG = 1;
001328  A8880B     BSET 0x80B, #4
236:                           StartTMR2();
00132A  0711A6     RCALL StartTMR2
237:                           IFS0bits.T2IF = 1;
00132C  A8E084     BSET IFS0, #7
238:                           cnt += 1;
00132E  BFC826     MOV.B cnt, WREG
001330  E84000     INC.B W0, W0
001332  B7E826     MOV.B WREG, cnt
239:               #ifdef DEBUG_RTCC_TIME
240:                           samplecount = cnt;
241:               #endif
242:                           alarm_time = WGCCON3bits.delay; //1160
001334  804060     MOV WGCCON3bits, W0
001336  804072     MOV 0x80E, W2
001338  6100E1     AND W2, #0x1, W1
00133A  BE8F00     MOV.D W0, [W14]
243:                           all_alarm_time += alarm_time;
00133C  804110     MOV all_alarm_time, W0
00133E  804121     MOV 0x824, W1
001340  40013E     ADD W0, [W14++], W2
001342  4881AE     ADDC W1, [W14--], W3
001344  BE0002     MOV.D W2, W0
001346  884110     MOV W0, all_alarm_time
001348  884121     MOV W1, 0x824
00134A  37007F     BRA 0x144A
244:                       } else {//如果采集计数和规定的时间计数相同，那么需要判断是否采集时间是否是上传时间的整数倍
245:                           //            tmp = WGCCON3bits.delay * cnt + last_alarm_time; //
246:                           if (WGCCON4bits.delay != all_alarm_time) {//如果发送时间刚好是采集时间的整数倍的话，将控制寄存器2标志为置1、设置下次定时时间
00134C  804080     MOV WGCCON4bits, W0
00134E  804092     MOV 0x812, W2
001350  6100E1     AND W2, #0x1, W1
001352  BE0100     MOV.D W0, W2
001354  804110     MOV all_alarm_time, W0
001356  804121     MOV 0x824, W1
001358  510F80     SUB W2, W0, [W15]
00135A  598F81     SUBB W3, W1, [W15]
00135C  32004E     BRA Z, 0x13FA
247:                               if (WGCCON4bits.count) {
00135E  804090     MOV 0x812, W0
001360  A10000     BCLR W0, #0
001362  E00000     CP0 W0
001364  320033     BRA Z, 0x13CC
248:                                   WGCCON4bits.count = 0;
001366  804090     MOV 0x812, W0
001368  600061     AND W0, #0x1, W0
00136A  884090     MOV W0, 0x812
249:                                   WGCCON2bits.Send_FLAG = 1;
00136C  A8A80B     BSET 0x80B, #5
250:                                   cnt = 0;
00136E  EF6826     CLR.B cnt
251:                                   //                    alarm_time = WGCCON3bits.delay - all_alarm_time;
252:                                   all_alarm_time += WGCCON3bits.delay;
001370  804060     MOV WGCCON3bits, W0
001372  804072     MOV 0x80E, W2
001374  6100E1     AND W2, #0x1, W1
001376  BE0100     MOV.D W0, W2
001378  804110     MOV all_alarm_time, W0
00137A  804121     MOV 0x824, W1
00137C  400002     ADD W0, W2, W0
00137E  488083     ADDC W1, W3, W1
001380  884110     MOV W0, all_alarm_time
001382  884121     MOV W1, 0x824
253:                                   alarm_time = all_alarm_time % WGCCON4bits.delay;
001384  804114     MOV all_alarm_time, W4
001386  804125     MOV 0x824, W5
001388  804080     MOV WGCCON4bits, W0
00138A  804092     MOV 0x812, W2
00138C  6100E1     AND W2, #0x1, W1
00138E  BE0100     MOV.D W0, W2
001390  BE0004     MOV.D W4, W0
001392  07FBD7     RCALL 0xB42
001394  BE8F00     MOV.D W0, [W14]
254:                                   all_alarm_time = alarm_time;
001396  BE011E     MOV.D [W14], W2
001398  884112     MOV W2, all_alarm_time
00139A  884123     MOV W3, 0x824
255:                                   WGCCON3bits.count = (WGCCON4bits.delay - all_alarm_time) / WGCCON3bits.delay + 1; //重新计算上线的次数
00139C  804080     MOV WGCCON4bits, W0
00139E  804092     MOV 0x812, W2
0013A0  6100E1     AND W2, #0x1, W1
0013A2  BE0100     MOV.D W0, W2
0013A4  804110     MOV all_alarm_time, W0
0013A6  804121     MOV 0x824, W1
0013A8  510200     SUB W2, W0, W4
0013AA  598281     SUBB W3, W1, W5
0013AC  804060     MOV WGCCON3bits, W0
0013AE  804072     MOV 0x80E, W2
0013B0  6100E1     AND W2, #0x1, W1
0013B2  BE0100     MOV.D W0, W2
0013B4  BE0004     MOV.D W4, W0
0013B6  07FBB5     RCALL 0xB22
0013B8  780000     MOV W0, W0
0013BA  E80080     INC W0, W1
0013BC  27FFF0     MOV #0x7FFF, W0
0013BE  608000     AND W1, W0, W0
0013C0  400000     ADD W0, W0, W0
0013C2  804071     MOV 0x80E, W1
0013C4  6080E1     AND W1, #0x1, W1
0013C6  700001     IOR W0, W1, W0
0013C8  884070     MOV W0, 0x80E
0013CA  37003F     BRA 0x144A
256:                               } else {//一个周期的最后一次采集任务
257:               #ifdef DEBUG_RTCC_TIME
258:                                   samplecount = cnt + 1;
259:               #endif 
260:                                   WGCCON2bits.Sample_FLAG = 1;
0013CC  A8880B     BSET 0x80B, #4
261:                                   StartTMR2();
0013CE  071154     RCALL StartTMR2
262:                                   IFS0bits.T2IF = 1;
0013D0  A8E084     BSET IFS0, #7
263:                                   WGCCON4bits.count += 1; //上线次数加1
0013D2  804090     MOV 0x812, W0
0013D4  D10000     LSR W0, W0
0013D6  E80000     INC W0, W0
0013D8  780080     MOV W0, W1
0013DA  27FFF0     MOV #0x7FFF, W0
0013DC  608000     AND W1, W0, W0
0013DE  400000     ADD W0, W0, W0
0013E0  804091     MOV 0x812, W1
0013E2  6080E1     AND W1, #0x1, W1
0013E4  700001     IOR W0, W1, W0
0013E6  884090     MOV W0, 0x812
264:                                   alarm_time = WGCCON4bits.delay - all_alarm_time; //表示过n秒后到了上传的时间
0013E8  804080     MOV WGCCON4bits, W0
0013EA  804092     MOV 0x812, W2
0013EC  6100E1     AND W2, #0x1, W1
0013EE  BE0100     MOV.D W0, W2
0013F0  804110     MOV all_alarm_time, W0
0013F2  804121     MOV 0x824, W1
0013F4  511F00     SUB W2, W0, [W14++]
0013F6  599701     SUBB W3, W1, [W14--]
0013F8  370028     BRA 0x144A
265:                                   //                    all_alarm_time += ;
266:                               }
267:                           } else {//反之，采样时间==发送时间
268:               #ifdef DEBUG_RTCC_TIME
269:                               samplecount = cnt + 1;
270:               #endif
271:                               WGCCON2bits.Sample_FLAG = WGCCON2bits.Send_FLAG = 1;
0013FA  A8A80B     BSET 0x80B, #5
0013FC  804050     MOV WGCCON2bits, W0
0013FE  DE004D     LSR W0, #13, W0
001400  604061     AND.B W0, #0x1, W0
001402  FB8000     ZE W0, W0
001404  600061     AND W0, #0x1, W0
001406  DD004C     SL W0, #12, W0
001408  804051     MOV WGCCON2bits, W1
00140A  A1C001     BCLR W1, #12
00140C  700001     IOR W0, W1, W0
00140E  884050     MOV W0, WGCCON2bits
272:                               StartTMR2();
001410  071133     RCALL StartTMR2
273:                               IFS0bits.T2IF = 1;
001412  A8E084     BSET IFS0, #7
274:                               cnt = 0; //清楚内部计数
001414  EF6826     CLR.B cnt
275:                               alarm_time = WGCCON3bits.delay;
001416  804060     MOV WGCCON3bits, W0
001418  804072     MOV 0x80E, W2
00141A  6100E1     AND W2, #0x1, W1
00141C  BE8F00     MOV.D W0, [W14]
276:                               all_alarm_time = WGCCON3bits.delay;
00141E  804060     MOV WGCCON3bits, W0
001420  804072     MOV 0x80E, W2
001422  6100E1     AND W2, #0x1, W1
001424  884110     MOV W0, all_alarm_time
001426  884121     MOV W1, 0x824
277:                               WGCCON3bits.count = WGCCON4bits.delay / WGCCON3bits.delay; //重新计算上线的次数
001428  804084     MOV WGCCON4bits, W4
00142A  804090     MOV 0x812, W0
00142C  6002E1     AND W0, #0x1, W5
00142E  804060     MOV WGCCON3bits, W0
001430  804072     MOV 0x80E, W2
001432  6100E1     AND W2, #0x1, W1
001434  BE0100     MOV.D W0, W2
001436  BE0004     MOV.D W4, W0
001438  07FB74     RCALL 0xB22
00143A  780080     MOV W0, W1
00143C  27FFF0     MOV #0x7FFF, W0
00143E  608000     AND W1, W0, W0
001440  400000     ADD W0, W0, W0
001442  804071     MOV 0x80E, W1
001444  6080E1     AND W1, #0x1, W1
001446  700001     IOR W0, W1, W0
001448  884070     MOV W0, 0x80E
278:                           }
279:                       }
280:                   }
281:                   //    if (!last_alarm_time) {//如果最后一次设置的报警时间为0的话，那么直接
282:                   //        alarm_time = WGCCON3bits.delay;
283:                   //        last_alarm_time = 0;
284:                   //    }
285:               #ifdef DEBUG_RTCC_COUNT
286:                   if (WGCCON2bits.Sample_FLAG)
287:                       RS485SendString("/r/nsample:", 9);
288:                   if (WGCCON2bits.Send_FLAG)
289:                       RS485SendString("/r/nsend:", 7);
290:               #endif
291:                   return alarm_time;
00144A  BE001E     MOV.D [W14], W0
292:               }
00144C  FA8000     ULNK
00144E  060000     RETURN
293:               
294:               void SetNextAlarm(uint32_t sample_sec) {
001450  FA0018     LNK #0x18
001452  980F20     MOV W0, [W14+20]
001454  980F31     MOV W1, [W14+22]
295:                   struct tm time1;
296:                   uint8_t tmp, tmp1;
297:               
298:                   enum {
299:                       sec, min, hour, day, mon, year
300:                   };
301:               
302:                   while (!RTC_Read_Time(&time1)); //容错设计
001456  000000     NOP
001458  E8800E     INC2 W14, W0
00145A  07081A     RCALL RTC_Read_Time
00145C  E00000     CP0 W0
00145E  32FFFC     BRA Z, 0x1458
303:                   tmp = (HCD(time1.tm_sec) + sample_sec); //计算秒数
001460  90001E     MOV [W14+2], W0
001462  784000     MOV.B W0, W0
001464  070629     RCALL HCD
001466  9008AE     MOV [W14+20], W1
001468  784081     MOV.B W1, W1
00146A  404F01     ADD.B W0, W1, [W14]
304:                   time1.tm_sec = DCH(tmp % 60);
00146C  FB809E     ZE [W14], W1
00146E  2003C0     MOV #0x3C, W0
001470  780100     MOV W0, W2
001472  090011     REPEAT #0x11
001474  D88082     DIV.UW W1, W2
001476  FD0080     EXCH W0, W1
001478  784000     MOV.B W0, W0
00147A  07062E     RCALL DCH
00147C  FB8000     ZE W0, W0
00147E  980710     MOV W0, [W14+2]
305:                   tmp1 = tmp / 60; //分钟是否溢出
001480  FB809E     ZE [W14], W1
001482  2003C0     MOV #0x3C, W0
001484  780100     MOV W0, W2
001486  090011     REPEAT #0x11
001488  D88082     DIV.UW W1, W2
00148A  984710     MOV.B W0, [W14+1]
306:                   if (tmp1 > 0)//如果累加的时间大于60s
00148C  90401E     MOV.B [W14+1], W0
00148E  E00400     CP0.B W0
001490  32002D     BRA Z, 0x14EC
307:                   {
308:                       tmp = (HCD(time1.tm_min) + tmp1);
001492  90002E     MOV [W14+4], W0
001494  784000     MOV.B W0, W0
001496  070610     RCALL HCD
001498  90409E     MOV.B [W14+1], W1
00149A  404F01     ADD.B W0, W1, [W14]
309:                       time1.tm_min = DCH(tmp % 60);
00149C  FB809E     ZE [W14], W1
00149E  2003C0     MOV #0x3C, W0
0014A0  780100     MOV W0, W2
0014A2  090011     REPEAT #0x11
0014A4  D88082     DIV.UW W1, W2
0014A6  FD0080     EXCH W0, W1
0014A8  784000     MOV.B W0, W0
0014AA  070616     RCALL DCH
0014AC  FB8000     ZE W0, W0
0014AE  980720     MOV W0, [W14+4]
310:                       tmp1 = tmp / 60;
0014B0  FB809E     ZE [W14], W1
0014B2  2003C0     MOV #0x3C, W0
0014B4  780100     MOV W0, W2
0014B6  090011     REPEAT #0x11
0014B8  D88082     DIV.UW W1, W2
0014BA  984710     MOV.B W0, [W14+1]
311:                       if (tmp1 > 0) {
0014BC  90401E     MOV.B [W14+1], W0
0014BE  E00400     CP0.B W0
0014C0  320015     BRA Z, 0x14EC
312:                           tmp = (HCD(time1.tm_hour) + tmp1);
0014C2  90003E     MOV [W14+6], W0
0014C4  784000     MOV.B W0, W0
0014C6  0705F8     RCALL HCD
0014C8  90409E     MOV.B [W14+1], W1
0014CA  404F01     ADD.B W0, W1, [W14]
313:                           time1.tm_hour = DCH(tmp % 24);
0014CC  FB809E     ZE [W14], W1
0014CE  200180     MOV #0x18, W0
0014D0  780100     MOV W0, W2
0014D2  090011     REPEAT #0x11
0014D4  D88082     DIV.UW W1, W2
0014D6  FD0080     EXCH W0, W1
0014D8  784000     MOV.B W0, W0
0014DA  0705FE     RCALL DCH
0014DC  FB8000     ZE W0, W0
0014DE  980730     MOV W0, [W14+6]
314:                           tmp1 = tmp / 24;
0014E0  FB809E     ZE [W14], W1
0014E2  200180     MOV #0x18, W0
0014E4  780100     MOV W0, W2
0014E6  090011     REPEAT #0x11
0014E8  D88082     DIV.UW W1, W2
0014EA  984710     MOV.B W0, [W14+1]
315:                       }
316:                   }
317:                   RTC_Set_Alarm(time1); //每日一次闹钟
0014EC  4787F2     ADD W15, #0x12, W15
0014EE  578072     SUB W15, #0x12, W0
0014F0  4700E2     ADD W14, #0x2, W1
0014F2  090008     REPEAT #0x8
0014F4  781831     MOV [W1++], [W0++]
0014F6  B10120     SUB #0x12, W0
0014F8  0707A6     RCALL RTC_Set_Alarm
0014FA  5787F2     SUB W15, #0x12, W15
318:               }
0014FC  FA8000     ULNK
0014FE  060000     RETURN
319:               
320:               //void WGCGetArg(void) {
321:               //    do {
322:               //
323:               //    } while ();
324:               //}
325:               
326:               bool WGCPCCop(void) {
001500  FA007C     LNK #0x7C
327:                   StrCmp stcp;
328:                   uint8_t tmp[50]; //串口接受到的数据
329:                   uint8_t tmp1[30]; //截取后的数据
330:                   uint8_t tmp2[30]; //处理后要发送的数据
331:                   uint8_t cnt;
332:               
333:                   stcp.SourceData = tmp;
001502  47006E     ADD W14, #0xE, W0
001504  980710     MOV W0, [W14+2]
334:                   stcp.Source_len = UARTGetData(BufferRead_UART1, stcp.SourceData, 50); //获取mark
001506  90001E     MOV [W14+2], W0
001508  B3C322     MOV.B #0x32, W2
00150A  780080     MOV W0, W1
00150C  227880     MOV #0x2788, W0
00150E  070A51     RCALL UARTGetData
001510  984740     MOV.B W0, [W14+4]
335:                   stcp.CheckData = (uint8_t*) WGC;
001512  290840     MOV #0x9084, W0
001514  980730     MOV W0, [W14+6]
336:                   stcp.Check_len = 3;
001516  B3C030     MOV.B #0x3, W0
001518  984F00     MOV.B W0, [W14+8]
337:                   stcp.GetData = tmp1;
00151A  200400     MOV #0x40, W0
00151C  40000E     ADD W0, W14, W0
00151E  980750     MOV W0, [W14+10]
338:                   stcp.Get_len = 30;
001520  B3C1E0     MOV.B #0x1E, W0
001522  984F40     MOV.B W0, [W14+12]
339:                   stcp.Real_len = 0;
001524  EB4000     CLR.B W0
001526  984F50     MOV.B W0, [W14+13]
340:               
341:                   if (UARTDataIsRight(&stcp) && CheckIsRight(CRC16_Check, tmp1, stcp.Real_len - 2)) {
001528  E8800E     INC2 W14, W0
00152A  070980     RCALL UARTDataIsRight
00152C  E00400     CP0.B W0
00152E  32006F     BRA Z, 0x160E
001530  90485E     MOV.B [W14+13], W0
001532  E9C080     DEC2.B W0, W1
001534  200400     MOV #0x40, W0
001536  40000E     ADD W0, W14, W0
001538  784101     MOV.B W1, W2
00153A  780080     MOV W0, W1
00153C  230220     MOV #0x3022, W0
00153E  070DC8     RCALL CheckIsRight
001540  E00400     CP0.B W0
001542  320065     BRA Z, 0x160E
342:                       //根据寄存器地址、数量、数据长度和数据,判断进行设置数据
343:                       CopyDat(tmp2, tmp1, 4); //数据帧头+功能码  
001544  200401     MOV #0x40, W1
001546  40808E     ADD W1, W14, W1
001548  2005E0     MOV #0x5E, W0
00154A  40000E     ADD W0, W14, W0
00154C  B3C042     MOV.B #0x4, W2
00154E  0706A2     RCALL CopyDat
344:                       tmp2[4] = RegAdd[*(tmp1 + 4)+*(tmp1 + 5)] - RegAdd[*(tmp1 + 4)];
001550  200400     MOV #0x40, W0
001552  40000E     ADD W0, W14, W0
001554  400064     ADD W0, #0x4, W0
001556  784010     MOV.B [W0], W0
001558  FB8080     ZE W0, W1
00155A  200400     MOV #0x40, W0
00155C  40000E     ADD W0, W14, W0
00155E  400065     ADD W0, #0x5, W0
001560  784010     MOV.B [W0], W0
001562  FB8000     ZE W0, W0
001564  408000     ADD W1, W0, W0
001566  290881     MOV #0x9088, W1
001568  7840E1     MOV.B [W1+W0], W1
00156A  200400     MOV #0x40, W0
00156C  40000E     ADD W0, W14, W0
00156E  400064     ADD W0, #0x4, W0
001570  784010     MOV.B [W0], W0
001572  FB8000     ZE W0, W0
001574  290882     MOV #0x9088, W2
001576  784062     MOV.B [W2+W0], W0
001578  50C000     SUB.B W1, W0, W0
00157A  98E720     MOV.B W0, [W14+98]
345:                       switch (*(tmp1 + 3)) {
00157C  200400     MOV #0x40, W0
00157E  40000E     ADD W0, W14, W0
001580  400063     ADD W0, #0x3, W0
001582  784010     MOV.B [W0], W0
001584  FB8000     ZE W0, W0
001586  500FE3     SUB W0, #0x3, [W15]
001588  320026     BRA Z, 0x15D6
00158A  500FE4     SUB W0, #0x4, [W15]
00158C  3A003E     BRA NZ, 0x160A
346:                           case 0x04:
347:                           {
348:                               // * send: 57 47 43 04 00 05 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 13 CE 1B FA
349:                               // * rec: 57 47 43 04 11 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 73 75 F2 54 69 
350:                               CopyDat(tmp2 + 5, tmp1 + 6, tmp2[4]); //复制设置数据
00158E  90E12E     MOV.B [W14+98], W2
001590  200400     MOV #0x40, W0
001592  40000E     ADD W0, W14, W0
001594  4000E6     ADD W0, #0x6, W1
001596  2005E0     MOV #0x5E, W0
001598  40000E     ADD W0, W14, W0
00159A  400065     ADD W0, #0x5, W0
00159C  07067B     RCALL CopyDat
351:                               CRC16_Check(tmp2, tmp2[4] + 5); //计算CRC
00159E  90E02E     MOV.B [W14+98], W0
0015A0  4040E5     ADD.B W0, #0x5, W1
0015A2  2005E0     MOV #0x5E, W0
0015A4  40000E     ADD W0, W14, W0
0015A6  070D3D     RCALL CRC16_Check
352:                               for (cnt = 0; cnt < tmp1[5]; cnt++)
0015A8  EB4000     CLR.B W0
0015AA  784F00     MOV.B W0, [W14]
0015AC  370007     BRA 0x15BC
0015BA  E84F1E     INC.B [W14], [W14]
0015BC  90C05E     MOV.B [W14+69], W0
0015BE  504F9E     SUB.B W0, [W14], [W15]
0015C0  3EFFF6     BRA GTU, 0x15AE
353:                                   HandleArg(tmp1[3], tmp1[4] + cnt, tmp1);
0015AE  90C04E     MOV.B [W14+68], W0
0015B0  40409E     ADD.B W0, [W14], W1
0015B2  90C03E     MOV.B [W14+67], W0
0015B4  200402     MOV #0x40, W2
0015B6  41010E     ADD W2, W14, W2
0015B8  07002D     RCALL _HandleArg
354:                               RTC_Refresh_Time();
0015C2  0707D6     RCALL RTC_Refresh_Time
355:                               WGCCON2bits.Period_FLAG = 1; //重新计算RTCC
0015C4  A8680B     BSET 0x80B, #3
356:                               IFS3bits.RTCIF = 1;
0015C6  A8C08B     BSET 0x8B, #6
357:                               RS485SendString(tmp2, tmp2[4] + 7); //发送数据 注意数据发送不要在中断里面
0015C8  90E02E     MOV.B [W14+98], W0
0015CA  FB8000     ZE W0, W0
0015CC  4000E7     ADD W0, #0x7, W1
0015CE  2005E0     MOV #0x5E, W0
0015D0  40000E     ADD W0, W14, W0
0015D2  070EBD     RCALL RS485SendString
358:                               break;
0015D4  37001A     BRA 0x160A
359:                           }
360:                           case 0x03:
361:                           {
362:                               // * send: 57 47 43 03 00 05 9C 74
363:                               // * rec: 57 47 43 03 11 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 7A F2 
364:                               RefreshReg(); //刷新Arg参数RefreshReg
0015D6  07015D     RCALL _RefreshReg
365:                               for (cnt = 0; cnt < tmp1[5]; cnt++)
0015D8  EB4000     CLR.B W0
0015DA  784F00     MOV.B W0, [W14]
0015DC  370007     BRA 0x15EC
0015EA  E84F1E     INC.B [W14], [W14]
0015EC  90C05E     MOV.B [W14+69], W0
0015EE  504F9E     SUB.B W0, [W14], [W15]
0015F0  3EFFF6     BRA GTU, 0x15DE
366:                                   HandleArg(tmp1[3], tmp1[4] + cnt, tmp2);
0015DE  90C04E     MOV.B [W14+68], W0
0015E0  40409E     ADD.B W0, [W14], W1
0015E2  90C03E     MOV.B [W14+67], W0
0015E4  2005E2     MOV #0x5E, W2
0015E6  41010E     ADD W2, W14, W2
0015E8  070015     RCALL _HandleArg
367:                               CRC16_Check(tmp2, tmp2[4] + 5); //计算CRC
0015F2  90E02E     MOV.B [W14+98], W0
0015F4  4040E5     ADD.B W0, #0x5, W1
0015F6  2005E0     MOV #0x5E, W0
0015F8  40000E     ADD W0, W14, W0
0015FA  070D13     RCALL CRC16_Check
368:                               RS485SendString(tmp2, tmp2[4] + 7); //发送数据 注意数据发送不要在中断里面
0015FC  90E02E     MOV.B [W14+98], W0
0015FE  FB8000     ZE W0, W0
001600  4000E7     ADD W0, #0x7, W1
001602  2005E0     MOV #0x5E, W0
001604  40000E     ADD W0, W14, W0
001606  070EA3     RCALL RS485SendString
369:                               break;
001608  000000     NOP
370:                           }
371:                       }
372:                       return true;
00160A  B3C010     MOV.B #0x1, W0
00160C  370001     BRA 0x1610
373:                   }
374:                   return false;
00160E  EB4000     CLR.B W0
375:               }
001610  FA8000     ULNK
001612  060000     RETURN
376:               
377:               static uint8_t HandleArg(uint8_t funcode, uint8_t regadd, uint8_t * arg) {
001614  FA0004     LNK #0x4
001616  784F00     MOV.B W0, [W14]
001618  984711     MOV.B W1, [W14+1]
00161A  980712     MOV W2, [W14+2]
378:                   //    uint8_t bytes;
379:                   //根据寄存器地址、数量、数据长度和数据,判断进行设置数据
380:                   //* send: 57 47 43 04 00 05 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 1A 6A
381:                   //* rec: 57 47 43 04 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
382:                   switch (funcode) {//根据功能码处理数据
00161C  FB801E     ZE [W14], W0
00161E  500FE3     SUB W0, #0x3, [W15]
001620  320074     BRA Z, 0x170A
001622  500FE4     SUB W0, #0x4, [W15]
001624  3A00E7     BRA NZ, 0x17F4
383:                       case 0x04://设置参数
384:                       {
385:                           switch (regadd) {//寄存器地址
001626  90401E     MOV.B [W14+1], W0
001628  FB8000     ZE W0, W0
00162A  500FE2     SUB W0, #0x2, [W15]
00162C  32004B     BRA Z, 0x16C4
00162E  500FE2     SUB W0, #0x2, [W15]
001630  3C0005     BRA GT, 0x163C
001632  E00000     CP0 W0
001634  320008     BRA Z, 0x1646
001636  500FE1     SUB W0, #0x1, [W15]
001638  32001F     BRA Z, 0x1678
00163C  500FE3     SUB W0, #0x3, [W15]
00163E  320047     BRA Z, 0x16CE
001640  500FE4     SUB W0, #0x4, [W15]
001642  320056     BRA Z, 0x16F0
386:                               case 0://时间地址
387:                               {
388:                                   WGCTIME0bits.year = (*(arg + 6));
001646  90001E     MOV [W14+2], W0
001648  400066     ADD W0, #0x6, W0
00164A  784010     MOV.B [W0], W0
00164C  B7E800     MOV.B WREG, WGCTIME0bits
389:                                   WGCTIME0bits.month = (*(arg + 7));
00164E  90001E     MOV [W14+2], W0
001650  400067     ADD W0, #0x7, W0
001652  784010     MOV.B [W0], W0
001654  B7E801     MOV.B WREG, 0x801
390:                                   WGCTIME1bits.day = (*(arg + 8));
001656  90001E     MOV [W14+2], W0
001658  400068     ADD W0, #0x8, W0
00165A  784010     MOV.B [W0], W0
00165C  B7E802     MOV.B WREG, WGCTIME1bits
391:                                   WGCTIME1bits.hour = (*(arg + 9));
00165E  90001E     MOV [W14+2], W0
001660  400069     ADD W0, #0x9, W0
001662  784010     MOV.B [W0], W0
001664  B7E803     MOV.B WREG, 0x803
392:                                   WGCTIME2bits.min = (*(arg + 10));
001666  90001E     MOV [W14+2], W0
001668  40006A     ADD W0, #0xA, W0
00166A  784010     MOV.B [W0], W0
00166C  B7E804     MOV.B WREG, WGCTIME2bits
393:                                   WGCTIME2bits.sec = (*(arg + 11));
00166E  90001E     MOV [W14+2], W0
001670  40006B     ADD W0, #0xB, W0
001672  784010     MOV.B [W0], W0
001674  B7E805     MOV.B WREG, 0x805
394:                                   //                    bytes = 6;
395:                                   break;
001676  370048     BRA 0x1708
396:                               }
397:                               case 1://采集时间和发送时间
398:                               {
399:                                   WGCCON0bits.Send_60s = ((uint16_t)*(arg + 12) << 8)+*(arg + 13); //直接BCD码
001678  90001E     MOV [W14+2], W0
00167A  40006C     ADD W0, #0xC, W0
00167C  784010     MOV.B [W0], W0
00167E  FB8000     ZE W0, W0
001680  DD00C8     SL W0, #8, W1
001682  90001E     MOV [W14+2], W0
001684  40006D     ADD W0, #0xD, W0
001686  784010     MOV.B [W0], W0
001688  FB8000     ZE W0, W0
00168A  408080     ADD W1, W0, W1
00168C  207FF0     MOV #0x7FF, W0
00168E  608080     AND W1, W0, W1
001690  207FF0     MOV #0x7FF, W0
001692  608000     AND W1, W0, W0
001694  804032     MOV WGCCON0bits, W2
001696  2F8001     MOV #0xF800, W1
001698  610081     AND W2, W1, W1
00169A  700001     IOR W0, W1, W0
00169C  884030     MOV W0, WGCCON0bits
400:                                   WGCCON1bits.Sample_5s = ((uint16_t)*(arg + 14))+*(arg + 15); //直接BCD码
00169E  90001E     MOV [W14+2], W0
0016A0  40006E     ADD W0, #0xE, W0
0016A2  784010     MOV.B [W0], W0
0016A4  FB8080     ZE W0, W1
0016A6  90001E     MOV [W14+2], W0
0016A8  40006F     ADD W0, #0xF, W0
0016AA  784010     MOV.B [W0], W0
0016AC  FB8000     ZE W0, W0
0016AE  408080     ADD W1, W0, W1
0016B0  27FFF0     MOV #0x7FFF, W0
0016B2  608080     AND W1, W0, W1
0016B4  27FFF0     MOV #0x7FFF, W0
0016B6  608000     AND W1, W0, W0
0016B8  804042     MOV WGCCON1bits, W2
0016BA  280001     MOV #0x8000, W1
0016BC  610081     AND W2, W1, W1
0016BE  700001     IOR W0, W1, W0
0016C0  884040     MOV W0, WGCCON1bits
401:                                   //                    bytes = 2;
402:                                   break;
0016C2  370022     BRA 0x1708
403:                               }
404:                               case 2://ID号
405:                               {
406:                                   WGCCON2bits.WGC_ID = *(arg + 16);
0016C4  90001E     MOV [W14+2], W0
0016C6  400070     ADD W0, #0x10, W0
0016C8  784010     MOV.B [W0], W0
0016CA  B7E80A     MOV.B WREG, WGCCON2bits
407:                                   //                    bytes = 1;
408:                                   break;
0016CC  37001D     BRA 0x1708
409:                               }
410:                               case 3://IP地址
411:                               {
412:                                   WGCIPbits.IP0 = *(arg + 17);
0016CE  90001E     MOV [W14+2], W0
0016D0  400071     ADD W0, #0x11, W0
0016D2  784010     MOV.B [W0], W0
0016D4  B7E814     MOV.B WREG, WGCIPbits
413:                                   WGCIPbits.IP1 = *(arg + 18);
0016D6  90001E     MOV [W14+2], W0
0016D8  400072     ADD W0, #0x12, W0
0016DA  784010     MOV.B [W0], W0
0016DC  B7E815     MOV.B WREG, 0x815
414:                                   WGCIPbits.IP2 = *(arg + 19);
0016DE  90001E     MOV [W14+2], W0
0016E0  400073     ADD W0, #0x13, W0
0016E2  784010     MOV.B [W0], W0
0016E4  B7E816     MOV.B WREG, 0x816
415:                                   WGCIPbits.IP3 = *(arg + 20);
0016E6  90001E     MOV [W14+2], W0
0016E8  400074     ADD W0, #0x14, W0
0016EA  784010     MOV.B [W0], W0
0016EC  B7E817     MOV.B WREG, 0x817
416:                                   //                    bytes = 4;
417:                                   break;
0016EE  37000C     BRA 0x1708
418:                               }
419:                               case 4://端口
420:                               {
421:                                   WGCPORT = (*(arg + 21) << 8)+*(arg + 22); //端口号 
0016F0  90001E     MOV [W14+2], W0
0016F2  400075     ADD W0, #0x15, W0
0016F4  784010     MOV.B [W0], W0
0016F6  FB8000     ZE W0, W0
0016F8  DD00C8     SL W0, #8, W1
0016FA  90001E     MOV [W14+2], W0
0016FC  400076     ADD W0, #0x16, W0
0016FE  784010     MOV.B [W0], W0
001700  FB8000     ZE W0, W0
001702  408000     ADD W1, W0, W0
001704  8840E0     MOV W0, WGCPORT
422:                                   //                    bytes = 2;
423:                                   break;
001706  000000     NOP
424:                               }
425:                           }
426:                           break;
00163A  3700DC     BRA 0x17F4
001644  3700D7     BRA 0x17F4
001708  370075     BRA 0x17F4
427:                       }
428:                           // * send: 57 47 43 03 00 05 9C 74
429:                           // * rec: 57 47 43 03 11 17 12 10 12 10 20 00 03 00 20 05 B7 F6 4A 44 12 CE 7A F2 
430:                       case 0x03://读取参数
431:                       {
432:                           switch (regadd) {//寄存器地址
00170A  90401E     MOV.B [W14+1], W0
00170C  FB8000     ZE W0, W0
00170E  500FE2     SUB W0, #0x2, [W15]
001710  32004A     BRA Z, 0x17A6
001712  500FE2     SUB W0, #0x2, [W15]
001714  3C0005     BRA GT, 0x1720
001716  E00000     CP0 W0
001718  320008     BRA Z, 0x172A
00171A  500FE1     SUB W0, #0x1, [W15]
00171C  320025     BRA Z, 0x1768
00171E  37006A     BRA 0x17F4
001720  500FE3     SUB W0, #0x3, [W15]
001722  320047     BRA Z, 0x17B2
001724  500FE4     SUB W0, #0x4, [W15]
001726  32005A     BRA Z, 0x17DC
001728  370065     BRA 0x17F4
433:                               case 0:
434:                               {//时间地址
435:                                   arg[5] = WGCTIME0bits.year;
00172A  90001E     MOV [W14+2], W0
00172C  400065     ADD W0, #0x5, W0
00172E  208001     MOV #0x800, W1
001730  784091     MOV.B [W1], W1
001732  784801     MOV.B W1, [W0]
436:                                   arg[6] = WGCTIME0bits.month;
001734  90001E     MOV [W14+2], W0
001736  400066     ADD W0, #0x6, W0
001738  208011     MOV #0x801, W1
00173A  784091     MOV.B [W1], W1
00173C  784801     MOV.B W1, [W0]
437:                                   arg[7] = WGCTIME1bits.day;
00173E  90001E     MOV [W14+2], W0
001740  400067     ADD W0, #0x7, W0
001742  208021     MOV #0x802, W1
001744  784091     MOV.B [W1], W1
001746  784801     MOV.B W1, [W0]
438:                                   arg[8] = WGCTIME1bits.hour;
001748  90001E     MOV [W14+2], W0
00174A  400068     ADD W0, #0x8, W0
00174C  208031     MOV #0x803, W1
00174E  784091     MOV.B [W1], W1
001750  784801     MOV.B W1, [W0]
439:                                   arg[9] = WGCTIME2bits.min;
001752  90001E     MOV [W14+2], W0
001754  400069     ADD W0, #0x9, W0
001756  208041     MOV #0x804, W1
001758  784091     MOV.B [W1], W1
00175A  784801     MOV.B W1, [W0]
440:                                   arg[10] = WGCTIME2bits.sec;
00175C  90001E     MOV [W14+2], W0
00175E  40006A     ADD W0, #0xA, W0
001760  208051     MOV #0x805, W1
001762  784091     MOV.B [W1], W1
001764  784801     MOV.B W1, [W0]
441:                                   break;
001766  370046     BRA 0x17F4
442:                               }
443:                               case 1:
444:                               {//采集和发送时间
445:                                   arg[11] = WGCCON0bits.Send_60s >> 8;
001768  90001E     MOV [W14+2], W0
00176A  40006B     ADD W0, #0xB, W0
00176C  804032     MOV WGCCON0bits, W2
00176E  207FF1     MOV #0x7FF, W1
001770  610081     AND W2, W1, W1
001772  DE88C8     ASR W1, #8, W1
001774  784081     MOV.B W1, W1
001776  784801     MOV.B W1, [W0]
446:                                   arg[12] = (uint8_t) (WGCCON0bits.Send_60s & 0x00FF); //(WGCCON0bits.Sample_5s>>3);
001778  90001E     MOV [W14+2], W0
00177A  40006C     ADD W0, #0xC, W0
00177C  804032     MOV WGCCON0bits, W2
00177E  207FF1     MOV #0x7FF, W1
001780  610081     AND W2, W1, W1
001782  784081     MOV.B W1, W1
001784  784801     MOV.B W1, [W0]
447:                                   arg[13] = WGCCON1bits.Sample_5s >> 8;
001786  90001E     MOV [W14+2], W0
001788  40006D     ADD W0, #0xD, W0
00178A  804042     MOV WGCCON1bits, W2
00178C  27FFF1     MOV #0x7FFF, W1
00178E  610081     AND W2, W1, W1
001790  DE88C8     ASR W1, #8, W1
001792  784081     MOV.B W1, W1
001794  784801     MOV.B W1, [W0]
448:                                   arg[14] = (uint8_t) (WGCCON1bits.Sample_5s & 0x00FF);
001796  90001E     MOV [W14+2], W0
001798  40006E     ADD W0, #0xE, W0
00179A  804042     MOV WGCCON1bits, W2
00179C  27FFF1     MOV #0x7FFF, W1
00179E  610081     AND W2, W1, W1
0017A0  784081     MOV.B W1, W1
0017A2  784801     MOV.B W1, [W0]
449:                                   break;
0017A4  370027     BRA 0x17F4
450:                               }
451:                               case 2:
452:                               {//ID号
453:                                   arg[15] = WGCCON2bits.WGC_ID;
0017A6  90001E     MOV [W14+2], W0
0017A8  40006F     ADD W0, #0xF, W0
0017AA  2080A1     MOV #0x80A, W1
0017AC  784091     MOV.B [W1], W1
0017AE  784801     MOV.B W1, [W0]
454:                                   break;
0017B0  370021     BRA 0x17F4
455:                               }
456:                               case 3:
457:                               {//IP地址
458:                                   arg[16] = WGCIPbits.IP3;
0017B2  90001E     MOV [W14+2], W0
0017B4  400070     ADD W0, #0x10, W0
0017B6  208171     MOV #0x817, W1
0017B8  784091     MOV.B [W1], W1
0017BA  784801     MOV.B W1, [W0]
459:                                   arg[17] = WGCIPbits.IP2;
0017BC  90001E     MOV [W14+2], W0
0017BE  400071     ADD W0, #0x11, W0
0017C0  208161     MOV #0x816, W1
0017C2  784091     MOV.B [W1], W1
0017C4  784801     MOV.B W1, [W0]
460:                                   arg[18] = WGCIPbits.IP1;
0017C6  90001E     MOV [W14+2], W0
0017C8  400072     ADD W0, #0x12, W0
0017CA  208151     MOV #0x815, W1
0017CC  784091     MOV.B [W1], W1
0017CE  784801     MOV.B W1, [W0]
461:                                   arg[19] = WGCIPbits.IP0;
0017D0  90001E     MOV [W14+2], W0
0017D2  400073     ADD W0, #0x13, W0
0017D4  208141     MOV #0x814, W1
0017D6  784091     MOV.B [W1], W1
0017D8  784801     MOV.B W1, [W0]
462:                                   break;
0017DA  37000C     BRA 0x17F4
463:                               }
464:                               case 4:
465:                               {//端口号
466:                                   arg[20] = WGCPORT >> 8;
0017DC  90001E     MOV [W14+2], W0
0017DE  400074     ADD W0, #0x14, W0
0017E0  8040E1     MOV WGCPORT, W1
0017E2  DE08C8     LSR W1, #8, W1
0017E4  784081     MOV.B W1, W1
0017E6  784801     MOV.B W1, [W0]
467:                                   arg[21] = WGCPORT & 0x00ff;
0017E8  90001E     MOV [W14+2], W0
0017EA  400075     ADD W0, #0x15, W0
0017EC  8040E1     MOV WGCPORT, W1
0017EE  784081     MOV.B W1, W1
0017F0  784801     MOV.B W1, [W0]
468:                                   break;
0017F2  000000     NOP
469:                               }
470:                           }
471:                       }
472:                   }
473:                   //    return bytes;
474:                   //根据寄存器地址、数量,判断进行读取数据
475:                   //* send: 57 47 43 03 00 05 CRCL CRCH
476:                   //* rec: 57 47 43 03 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
477:               }
0017F4  FA8000     ULNK
0017F6  060000     RETURN
478:               
479:               static uint8_t MKSendString(uint8_t * tmp) {//当组数据不小于20个字节
0017F8  FA0018     LNK #0x18
0017FA  980F30     MOV W0, [W14+22]
480:                   struct tm stm;
481:                   uint8_t bytes = 0; //添加帧头
0017FC  EB4000     CLR.B W0
0017FE  784F00     MOV.B W0, [W14]
482:                   uint16_t crc;
483:                   tmp[0] = 'A';
001800  90083E     MOV [W14+22], W0
001802  B3C411     MOV.B #0x41, W1
001804  784801     MOV.B W1, [W0]
484:                   tmp[1] = '2';
001806  90083E     MOV [W14+22], W0
001808  E80000     INC W0, W0
00180A  B3C321     MOV.B #0x32, W1
00180C  784801     MOV.B W1, [W0]
485:                   tmp[2] = 20; //添加时间
00180E  90083E     MOV [W14+22], W0
001810  E88000     INC2 W0, W0
001812  B3C141     MOV.B #0x14, W1
001814  784801     MOV.B W1, [W0]
486:                   while (!RTC_Read_Time(&stm));
001816  000000     NOP
001818  470064     ADD W14, #0x4, W0
00181A  07063A     RCALL RTC_Read_Time
00181C  E00000     CP0 W0
00181E  32FFFC     BRA Z, 0x1818
487:                   tmp[3] = (stm.tm_year);
001820  90083E     MOV [W14+22], W0
001822  400063     ADD W0, #0x3, W0
001824  9000FE     MOV [W14+14], W1
001826  784081     MOV.B W1, W1
001828  784801     MOV.B W1, [W0]
488:                   tmp[4] = (stm.tm_mon);
00182A  90083E     MOV [W14+22], W0
00182C  400064     ADD W0, #0x4, W0
00182E  9000EE     MOV [W14+12], W1
001830  784081     MOV.B W1, W1
001832  784801     MOV.B W1, [W0]
489:                   tmp[5] = (stm.tm_mday);
001834  90083E     MOV [W14+22], W0
001836  400065     ADD W0, #0x5, W0
001838  9000DE     MOV [W14+10], W1
00183A  784081     MOV.B W1, W1
00183C  784801     MOV.B W1, [W0]
490:                   tmp[6] = (stm.tm_hour);
00183E  90083E     MOV [W14+22], W0
001840  400066     ADD W0, #0x6, W0
001842  9000CE     MOV [W14+8], W1
001844  784081     MOV.B W1, W1
001846  784801     MOV.B W1, [W0]
491:                   tmp[7] = (stm.tm_min);
001848  90083E     MOV [W14+22], W0
00184A  400067     ADD W0, #0x7, W0
00184C  9000BE     MOV [W14+6], W1
00184E  784081     MOV.B W1, W1
001850  784801     MOV.B W1, [W0]
492:                   tmp[8] = (stm.tm_sec);
001852  90083E     MOV [W14+22], W0
001854  400068     ADD W0, #0x8, W0
001856  9000AE     MOV [W14+4], W1
001858  784081     MOV.B W1, W1
00185A  784801     MOV.B W1, [W0]
493:                   bytes = 9;
00185C  B3C090     MOV.B #0x9, W0
00185E  784F00     MOV.B W0, [W14]
494:                   FloatToChar(&f_p, tmp + 9); //转化为压力值
001860  90083E     MOV [W14+22], W0
001862  400069     ADD W0, #0x9, W0
001864  780080     MOV W0, W1
001866  2081E0     MOV #0x81E, W0
001868  0703E2     RCALL FloatToChar
495:                   crc = CRC16_Check(tmp, 13);
00186A  B3C0D1     MOV.B #0xD, W1
00186C  90083E     MOV [W14+22], W0
00186E  070BD9     RCALL CRC16_Check
001870  980710     MOV W0, [W14+2]
496:                   tmp[13] = crc >> 8;
001872  90083E     MOV [W14+22], W0
001874  40006D     ADD W0, #0xD, W0
001876  90009E     MOV [W14+2], W1
001878  DE08C8     LSR W1, #8, W1
00187A  784081     MOV.B W1, W1
00187C  784801     MOV.B W1, [W0]
497:                   tmp[14] = crc - ((crc >> 8) << 8);
00187E  90083E     MOV [W14+22], W0
001880  40006E     ADD W0, #0xE, W0
001882  90009E     MOV [W14+2], W1
001884  784081     MOV.B W1, W1
001886  784801     MOV.B W1, [W0]
498:                   bytes = 15;
001888  B3C0F0     MOV.B #0xF, W0
00188A  784F00     MOV.B W0, [W14]
499:                   //    strcat(tmp, tm); //添加压力
500:                   return bytes;
00188C  78401E     MOV.B [W14], W0
501:               }
00188E  FA8000     ULNK
001890  060000     RETURN
502:               
503:               static void RefreshReg(void) {
001892  FA0012     LNK #0x12
504:                   struct tm tm_tmp;
505:                   while (!RTC_Read_Time(&tm_tmp));
001894  000000     NOP
001896  78000E     MOV W14, W0
001898  0705FB     RCALL RTC_Read_Time
00189A  E00000     CP0 W0
00189C  32FFFC     BRA Z, 0x1896
506:                   WGCTIME0bits.year = tm_tmp.tm_year;
00189E  90005E     MOV [W14+10], W0
0018A0  784000     MOV.B W0, W0
0018A2  B7E800     MOV.B WREG, WGCTIME0bits
507:                   WGCTIME0bits.month = tm_tmp.tm_mon;
0018A4  90004E     MOV [W14+8], W0
0018A6  784000     MOV.B W0, W0
0018A8  B7E801     MOV.B WREG, 0x801
508:                   WGCTIME1bits.day = tm_tmp.tm_mday;
0018AA  90003E     MOV [W14+6], W0
0018AC  784000     MOV.B W0, W0
0018AE  B7E802     MOV.B WREG, WGCTIME1bits
509:                   WGCTIME1bits.hour = tm_tmp.tm_hour;
0018B0  90002E     MOV [W14+4], W0
0018B2  784000     MOV.B W0, W0
0018B4  B7E803     MOV.B WREG, 0x803
510:                   WGCTIME2bits.min = tm_tmp.tm_min;
0018B6  90001E     MOV [W14+2], W0
0018B8  784000     MOV.B W0, W0
0018BA  B7E804     MOV.B WREG, WGCTIME2bits
511:                   WGCTIME2bits.sec = tm_tmp.tm_sec;
0018BC  78001E     MOV [W14], W0
0018BE  784000     MOV.B W0, W0
0018C0  B7E805     MOV.B WREG, 0x805
512:               }
0018C2  FA8000     ULNK
513:               
514:               //static void LoadReg(void) {
515:               //    //    struct tm tm_tmp;
516:               //    //    while (!RTC_Read_Time(&tm_tmp));
517:               //    WGCTIME0bits.year; //= DCH(tm_tmp.tm_year);
518:               //    WGCTIME0bits.month; // = DCH(tm_tmp.tm_mon);
519:               //    WGCTIME1bits.day; //= DCH(tm_tmp.tm_mday);
520:               //    WGCTIME1bits.hour; // = DCH(tm_tmp.tm_hour);
521:               //    WGCTIME2bits.min; //= DCH(tm_tmp.tm_min);
522:               //    WGCTIME2bits.sec; //= DCH(tm_tmp.tm_sec);
523:               //}
524:               
525:               
526:               
527:               /*uint8_t [year,mon,day,hour,min,sec,Send_60s,Sample_5s.WGC_ID,IP0,IP1,IP2,IP3,PORT]
528:                *send：WGC+fun_code+reg+reg_num+CRC
529:                *rec：WGC+fuc_code+data_num+data[17]+CRC
530:                * fun_code 03:读取参数
531:                * fun_code 04:设置参数
532:                * /////////读取参数
533:                *send：WGC+03+reg+reg_num+CRC
534:                *rec：WGC+03+dat_num+dat[dat_num]+CRC
535:                * send: 57 47 43 03 00 05 CRCL CRCH
536:                * rec: 57 47 43 03 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
537:                * 
538:                * fun_code 03:读取参数
539:                * fun_code 04:设置参数
540:                * /////////读取参数
541:                *send：WGC+04+reg+reg_num+dat+CRC
542:                *rec：WGC+04+dat_num+dat+CRC
543:                * send: 57 47 43 04 00 05 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE 04 35
544:                * rec: 57 47 43 04 10 17 12 10 12 10 20 03 20 05 B7 F6 4A 44 12 CE CRCL CRCH
545:                * 
546:                * error handle:code 0x80
547:                * 
548:                */
549:               
550:               
551:               
552:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/SerialBuffer.c  -----------------------------
1:                 //#include "user.h"
2:                 //#include "string.h"
3:                 //#include "p24FV32KA301.h"
4:                 #include "SerialBuffer.h"
5:                 
6:                 /**********************************定义****************************************/
7:                 #define BUFFERMAX 64
8:                 //static uint8_t Buffer_uart1[BUFFERMAX];
9:                 uint8_t Buffer_uart1[BUFFERMAX];
10:                /*static*/ uint8_t bufferWptr_uart1 = 0;
11:                /*static */uint8_t bufferRptr_uart1 = 0;
12:                
13:                //static uint8_t Buffer_uart2[BUFFERMAX];
14:                uint8_t Buffer_uart2[BUFFERMAX];
15:                /*static*/ uint8_t bufferWptr_uart2 = 0;
16:                /*static*/ uint8_t bufferRptr_uart2 = 0;
17:                
18:                uint8_t Buffer_uart3[BUFFERMAX];
19:                /*static*/ uint8_t bufferWptr_uart3 = 0;
20:                /*static*/ uint8_t bufferRptr_uart3 = 0;
21:                
22:                /*************************************
23:                Function: BufferWrite 
24:                Description: 写数据到环形缓冲区
25:                Input: 串口号，1和2 
26:                Output: 无
27:                 *************************************/
28:                void BufferWrite_UART1(void) {
0026EA  FA0002     LNK #0x2
29:                    uint8_t tmp;
30:                    if (bufferWptr_uart1 == (bufferRptr_uart1 - 1)) {//如果缓冲区已满 写的速度比读的速度块
0026EC  BFC834     MOV.B bufferWptr_uart1, WREG
0026EE  FB8080     ZE W0, W1
0026F0  BFC835     MOV.B bufferRptr_uart1, WREG
0026F2  FB8000     ZE W0, W0
0026F4  E90000     DEC W0, W0
0026F6  508F80     SUB W1, W0, [W15]
0026F8  3A0003     BRA NZ, 0x2700
31:                        tmp = U1RXREG; //将溢出的数据，丢弃
0026FA  801130     MOV U1RXREG, W0
0026FC  784F00     MOV.B W0, [W14]
32:                        return;
0026FE  37000C     BRA 0x2718
33:                    }
34:                    Buffer_uart1[bufferWptr_uart1] = U1RXREG;
002700  BFC834     MOV.B bufferWptr_uart1, WREG
002702  FB8000     ZE W0, W0
002704  801131     MOV U1RXREG, W1
002706  784101     MOV.B W1, W2
002708  2084E1     MOV #0x84E, W1
00270A  787082     MOV.B W2, [W1+W0]
35:                    bufferWptr_uart1++;
00270C  BFC834     MOV.B bufferWptr_uart1, WREG
00270E  E84000     INC.B W0, W0
002710  B7E834     MOV.B WREG, bufferWptr_uart1
36:                    bufferWptr_uart1 = bufferWptr_uart1 - ((bufferWptr_uart1 >> 6) << 6);
002712  BFC834     MOV.B bufferWptr_uart1, WREG
002714  B243F0     AND.B #0x3F, W0
002716  B7E834     MOV.B WREG, bufferWptr_uart1
37:                }
002718  FA8000     ULNK
00271A  060000     RETURN
38:                
39:                /*************************************
40:                Function: BufferWrite 
41:                Description: 写数据到环形缓冲区
42:                Input: 串口号，1和2 
43:                Output: 无
44:                 *************************************/
45:                void BufferWrite_UART2(void) {
00271C  FA0002     LNK #0x2
46:                    uint8_t tmp = 0;
00271E  EB4000     CLR.B W0
002720  784F00     MOV.B W0, [W14]
47:                    if (bufferWptr_uart2 == (bufferRptr_uart2 - 1)) {//如果缓冲区已满 写的速度比读的速度块
002722  BFC836     MOV.B bufferWptr_uart2, WREG
002724  FB8080     ZE W0, W1
002726  BFC837     MOV.B bufferRptr_uart2, WREG
002728  FB8000     ZE W0, W0
00272A  E90000     DEC W0, W0
00272C  508F80     SUB W1, W0, [W15]
00272E  3A0003     BRA NZ, 0x2736
48:                        tmp = U2RXREG; //将溢出的数据，丢弃
002730  8011B0     MOV U2RXREG, W0
002732  784F00     MOV.B W0, [W14]
49:                        return;
002734  37000C     BRA 0x274E
50:                    }
51:                    Buffer_uart2[bufferWptr_uart2] = U2RXREG;
002736  BFC836     MOV.B bufferWptr_uart2, WREG
002738  FB8000     ZE W0, W0
00273A  8011B1     MOV U2RXREG, W1
00273C  784101     MOV.B W1, W2
00273E  2088E1     MOV #0x88E, W1
002740  787082     MOV.B W2, [W1+W0]
52:                    bufferWptr_uart2++;
002742  BFC836     MOV.B bufferWptr_uart2, WREG
002744  E84000     INC.B W0, W0
002746  B7E836     MOV.B WREG, bufferWptr_uart2
53:                    bufferWptr_uart2 = bufferWptr_uart2 - ((bufferWptr_uart2 >> 6) << 6); //bufferWptr_uart2%BUFFERMAX
002748  BFC836     MOV.B bufferWptr_uart2, WREG
00274A  B243F0     AND.B #0x3F, W0
00274C  B7E836     MOV.B WREG, bufferWptr_uart2
54:                }
00274E  FA8000     ULNK
002750  060000     RETURN
55:                
56:                /*************************************
57:                Function: BufferWrite 
58:                Description: 写数据到环形缓冲区
59:                Input: 串口号，1和2 
60:                Output: 无
61:                 *************************************/
62:                void BufferWrite_UART3(void) {
002752  FA0002     LNK #0x2
63:                    uint8_t tmp = 0;
002754  EB4000     CLR.B W0
002756  784F00     MOV.B W0, [W14]
64:                    if (bufferWptr_uart3 == (bufferRptr_uart3 - 1)) {//如果缓冲区已满 写的速度比读的速度块
002758  BFC838     MOV.B bufferWptr_uart3, WREG
00275A  FB8080     ZE W0, W1
00275C  BFC839     MOV.B bufferRptr_uart3, WREG
00275E  FB8000     ZE W0, W0
002760  E90000     DEC W0, W0
002762  508F80     SUB W1, W0, [W15]
002764  3A0003     BRA NZ, 0x276C
65:                        tmp = U3RXREG; //将溢出的数据，丢弃
002766  8012B0     MOV U3RXREG, W0
002768  784F00     MOV.B W0, [W14]
66:                        return;
00276A  37000C     BRA 0x2784
67:                    }
68:                    Buffer_uart3[bufferWptr_uart3] = U3RXREG;
00276C  BFC838     MOV.B bufferWptr_uart3, WREG
00276E  FB8000     ZE W0, W0
002770  8012B1     MOV U3RXREG, W1
002772  784101     MOV.B W1, W2
002774  208CE1     MOV #0x8CE, W1
002776  787082     MOV.B W2, [W1+W0]
69:                    bufferWptr_uart3++;
002778  BFC838     MOV.B bufferWptr_uart3, WREG
00277A  E84000     INC.B W0, W0
00277C  B7E838     MOV.B WREG, bufferWptr_uart3
70:                    bufferWptr_uart3 = bufferWptr_uart3 - ((bufferWptr_uart3 >> 6) << 6); //bufferWptr_uart3%BUFFERMAX
00277E  BFC838     MOV.B bufferWptr_uart3, WREG
002780  B243F0     AND.B #0x3F, W0
002782  B7E838     MOV.B WREG, bufferWptr_uart3
71:                }
002784  FA8000     ULNK
002786  060000     RETURN
72:                
73:                /*************************************
74:                Function:  BufferRead
75:                Description: 读环形缓冲区
76:                Input: 数据地址 
77:                Output: 1：读取成功，0：读取失败
78:                 *************************************/
79:                bool BufferRead_UART1(uint8_t *data) {
002788  FA0002     LNK #0x2
00278A  780F00     MOV W0, [W14]
80:                    if (bufferRptr_uart1 == bufferWptr_uart1) {
00278C  208351     MOV #0x835, W1
00278E  784091     MOV.B [W1], W1
002790  BFC834     MOV.B bufferWptr_uart1, WREG
002792  50CF80     SUB.B W1, W0, [W15]
002794  3A0002     BRA NZ, 0x279A
81:                        return 0;
002796  EB4000     CLR.B W0
002798  37000D     BRA 0x27B4
82:                    }
83:                    *data = Buffer_uart1[bufferRptr_uart1];
00279A  BFC835     MOV.B bufferRptr_uart1, WREG
00279C  FB8000     ZE W0, W0
00279E  2084E1     MOV #0x84E, W1
0027A0  7840E1     MOV.B [W1+W0], W1
0027A2  78001E     MOV [W14], W0
0027A4  784801     MOV.B W1, [W0]
84:                    bufferRptr_uart1++;
0027A6  BFC835     MOV.B bufferRptr_uart1, WREG
0027A8  E84000     INC.B W0, W0
0027AA  B7E835     MOV.B WREG, bufferRptr_uart1
85:                    bufferRptr_uart1 = bufferRptr_uart1 - ((bufferRptr_uart1 >> 6) << 6); //bufferRptr_uart1 % BUFFERMAX; 
0027AC  BFC835     MOV.B bufferRptr_uart1, WREG
0027AE  B243F0     AND.B #0x3F, W0
0027B0  B7E835     MOV.B WREG, bufferRptr_uart1
86:                    return 1;
0027B2  B3C010     MOV.B #0x1, W0
87:                }
0027B4  FA8000     ULNK
0027B6  060000     RETURN
88:                
89:                /*************************************
90:                Function:  BufferRead
91:                Description: 读环形缓冲区
92:                Input: 数据地址 
93:                Output: 1：读取成功，0：读取失败
94:                 *************************************/
95:                bool BufferRead_UART2(uint8_t *data) {
0027B8  FA0002     LNK #0x2
0027BA  780F00     MOV W0, [W14]
96:                    if (bufferRptr_uart2 == bufferWptr_uart2) {
0027BC  208371     MOV #0x837, W1
0027BE  784091     MOV.B [W1], W1
0027C0  BFC836     MOV.B bufferWptr_uart2, WREG
0027C2  50CF80     SUB.B W1, W0, [W15]
0027C4  3A0007     BRA NZ, 0x27D4
97:                        if (U2STAbits.OERR)
0027C6  801190     MOV U2STA, W0
0027C8  600062     AND W0, #0x2, W0
0027CA  E00000     CP0 W0
0027CC  320001     BRA Z, 0x27D0
98:                            U2STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
0027CE  A92232     BCLR U2STA, #1
99:                        return 0;
0027D0  EB4000     CLR.B W0
0027D2  37000D     BRA 0x27EE
100:                   }
101:                   *data = Buffer_uart2[bufferRptr_uart2];
0027D4  BFC837     MOV.B bufferRptr_uart2, WREG
0027D6  FB8000     ZE W0, W0
0027D8  2088E1     MOV #0x88E, W1
0027DA  7840E1     MOV.B [W1+W0], W1
0027DC  78001E     MOV [W14], W0
0027DE  784801     MOV.B W1, [W0]
102:                   bufferRptr_uart2++;
0027E0  BFC837     MOV.B bufferRptr_uart2, WREG
0027E2  E84000     INC.B W0, W0
0027E4  B7E837     MOV.B WREG, bufferRptr_uart2
103:                   bufferRptr_uart2 = bufferRptr_uart2 - ((bufferRptr_uart2 >> 6) << 6);
0027E6  BFC837     MOV.B bufferRptr_uart2, WREG
0027E8  B243F0     AND.B #0x3F, W0
0027EA  B7E837     MOV.B WREG, bufferRptr_uart2
104:                   //bufferRptr_uart2 % BUFFERMAX;//bufferRptr_uart2-(bufferRptr_uart2>>8)<<8;
105:                   return 1;
0027EC  B3C010     MOV.B #0x1, W0
106:               }
0027EE  FA8000     ULNK
0027F0  060000     RETURN
107:               
108:               /*************************************
109:               Function:  BufferRead
110:               Description: 读环形缓冲区
111:               Input: 数据地址 
112:               Output: 1：读取成功，0：读取失败
113:                *************************************/
114:               bool BufferRead_UART3(uint8_t *data) {
0027F2  FA0002     LNK #0x2
0027F4  780F00     MOV W0, [W14]
115:                   if (bufferRptr_uart3 == bufferWptr_uart3) {
0027F6  208391     MOV #0x839, W1
0027F8  784091     MOV.B [W1], W1
0027FA  BFC838     MOV.B bufferWptr_uart3, WREG
0027FC  50CF80     SUB.B W1, W0, [W15]
0027FE  3A0007     BRA NZ, 0x280E
116:                       if (U3STAbits.OERR)
002800  801290     MOV U3STA, W0
002802  600062     AND W0, #0x2, W0
002804  E00000     CP0 W0
002806  320001     BRA Z, 0x280A
117:                           U3STAbits.OERR = 0; //写数据满导致FIFO溢出，而没有清除，接受数据没有
002808  A92252     BCLR U3STA, #1
118:                       return 0;
00280A  EB4000     CLR.B W0
00280C  37000D     BRA 0x2828
119:                   }
120:                   *data = Buffer_uart3[bufferRptr_uart3];
00280E  BFC839     MOV.B bufferRptr_uart3, WREG
002810  FB8000     ZE W0, W0
002812  208CE1     MOV #0x8CE, W1
002814  7840E1     MOV.B [W1+W0], W1
002816  78001E     MOV [W14], W0
002818  784801     MOV.B W1, [W0]
121:                   bufferRptr_uart3++;
00281A  BFC839     MOV.B bufferRptr_uart3, WREG
00281C  E84000     INC.B W0, W0
00281E  B7E839     MOV.B WREG, bufferRptr_uart3
122:                   bufferRptr_uart3 = bufferRptr_uart3 - ((bufferRptr_uart3 >> 6) << 6);
002820  BFC839     MOV.B bufferRptr_uart3, WREG
002822  B243F0     AND.B #0x3F, W0
002824  B7E839     MOV.B WREG, bufferRptr_uart3
123:                   //bufferRptr_uart3 % BUFFERMAX;//bufferRptr_uart3-(bufferRptr_uart3>>8)<<8;
124:                   return 1;
002826  B3C010     MOV.B #0x1, W0
125:               }
002828  FA8000     ULNK
00282A  060000     RETURN
126:               
127:               /*************************************
128:               Function: UARTDataIsRight
129:               Description: 根据结构体的内容获取有效数据和有效长度
130:               Input: 数据结构体
131:               Output: 是否获取到数据
132:               Notice：字节数不能大于256 取数据的时间可能短   
133:                *************************************/
134:               bool UARTDataIsRight(StrCmp * strcmp) {//注意
00282C  FA0008     LNK #0x8
00282E  980730     MOV W0, [W14+6]
135:                   bool IsFind = false; //记录字节数
002830  EB4000     CLR.B W0
002832  784F00     MOV.B W0, [W14]
136:                   uint8_t cnt = 0/*校验寻找循环地址*/, cnt1 = 0/*校验判断循环地址*/, cnt2/*赋值地址*/, /*offset,*/ byte = 0;
002834  EB4000     CLR.B W0
002836  984710     MOV.B W0, [W14+1]
002838  EB4000     CLR.B W0
00283A  984720     MOV.B W0, [W14+2]
00283C  EB4000     CLR.B W0
00283E  984740     MOV.B W0, [W14+4]
137:               
138:                   if (!(strcmp->Check_len) || !(strcmp->Source_len))//如果设置的字节数为0的话，返回错误
002840  90003E     MOV [W14+6], W0
002842  904060     MOV.B [W0+6], W0
002844  E00400     CP0.B W0
002846  320004     BRA Z, 0x2850
002848  90003E     MOV [W14+6], W0
00284A  904020     MOV.B [W0+2], W0
00284C  E00400     CP0.B W0
00284E  3A0036     BRA NZ, 0x28BC
139:                       return false; //为获取
002850  EB4000     CLR.B W0
002852  3700AD     BRA 0x29AE
140:               
141:                   while (cnt < strcmp->Source_len) {
0028BC  000000     NOP
0028BE  90003E     MOV [W14+6], W0
0028C0  9040A0     MOV.B [W0+2], W1
0028C2  90401E     MOV.B [W14+1], W0
0028C4  50CF80     SUB.B W1, W0, [W15]
0028C6  3EFFC6     BRA GTU, 0x2854
0028C8  370001     BRA 0x28CC
142:                       if (*(strcmp->SourceData + cnt) == *(strcmp->CheckData)) {//如果数据==head的话           
002854  90003E     MOV [W14+6], W0
002856  780090     MOV [W0], W1
002858  90401E     MOV.B [W14+1], W0
00285A  FB8000     ZE W0, W0
00285C  408000     ADD W1, W0, W0
00285E  784090     MOV.B [W0], W1
002860  90003E     MOV [W14+6], W0
002862  900020     MOV [W0+4], W0
002864  784010     MOV.B [W0], W0
002866  50CF80     SUB.B W1, W0, [W15]
002868  3A0022     BRA NZ, 0x28AE
143:                           for (cnt1 = 1; cnt1 < strcmp->Check_len; cnt1++) {//获取帧头的数据长度               
00286A  B3C010     MOV.B #0x1, W0
00286C  984720     MOV.B W0, [W14+2]
00286E  37001A     BRA 0x28A4
002896  90402E     MOV.B [W14+2], W0
002898  E84000     INC.B W0, W0
00289A  984720     MOV.B W0, [W14+2]
00289C  370003     BRA 0x28A4
0028A4  90003E     MOV [W14+6], W0
0028A6  9040E0     MOV.B [W0+6], W1
0028A8  90402E     MOV.B [W14+2], W0
0028AA  50CF80     SUB.B W1, W0, [W15]
0028AC  3EFFE1     BRA GTU, 0x2870
144:                               if (*(strcmp->SourceData + cnt + cnt1) == *(strcmp->CheckData + cnt1)) {//如果获取到数据和帧头一样，那么继续获取数据，反之退出
002870  90003E     MOV [W14+6], W0
002872  780090     MOV [W0], W1
002874  90401E     MOV.B [W14+1], W0
002876  FB8100     ZE W0, W2
002878  90402E     MOV.B [W14+2], W0
00287A  FB8000     ZE W0, W0
00287C  410000     ADD W2, W0, W0
00287E  408000     ADD W1, W0, W0
002880  784090     MOV.B [W0], W1
002882  90003E     MOV [W14+6], W0
002884  900120     MOV [W0+4], W2
002886  90402E     MOV.B [W14+2], W0
002888  FB8000     ZE W0, W0
00288A  410000     ADD W2, W0, W0
00288C  784010     MOV.B [W0], W0
00288E  50CF80     SUB.B W1, W0, [W15]
002890  3A0006     BRA NZ, 0x289E
145:                                   IsFind = true;
002892  B3C010     MOV.B #0x1, W0
002894  784F00     MOV.B W0, [W14]
146:                                   continue;
147:                               } else {
148:                                   IsFind = false;
00289E  EB4000     CLR.B W0
0028A0  784F00     MOV.B W0, [W14]
149:                                   break;
0028A2  370005     BRA 0x28AE
150:                               }
151:                           }
152:                       }
153:                       if (IsFind) break; //如果找到数据，退出寻找帧头程序
0028AE  78401E     MOV.B [W14], W0
0028B0  E00400     CP0.B W0
0028B2  3A000B     BRA NZ, 0x28CA
0028CA  000000     NOP
154:                       cnt++; //校验位置加1
0028B4  90401E     MOV.B [W14+1], W0
0028B6  E84000     INC.B W0, W0
0028B8  984710     MOV.B W0, [W14+1]
0028BA  370001     BRA 0x28BE
155:                   }
156:               
157:                   if (IsFind) {//如果存在接受的字节数且找到帧头
0028CC  78401E     MOV.B [W14], W0
0028CE  E00400     CP0.B W0
0028D0  32006A     BRA Z, 0x29A6
158:                       if (strcmp->Get_len < strcmp->Check_len) {
0028D2  90003E     MOV [W14+6], W0
0028D4  9048A0     MOV.B [W0+10], W1
0028D6  90003E     MOV [W14+6], W0
0028D8  904060     MOV.B [W0+6], W0
0028DA  50CF80     SUB.B W1, W0, [W15]
0028DC  31001A     BRA C, 0x2912
159:                           byte = strcmp->Get_len; //获取字节小于校验字节,比如只需要校验不需要获取数据
0028DE  90003E     MOV [W14+6], W0
0028E0  9048A0     MOV.B [W0+10], W1
0028E2  984741     MOV.B W1, [W14+4]
160:                           for (cnt2 = 0; cnt2 < byte; cnt2++) //获取帧头数据
0028E4  EB4000     CLR.B W0
0028E6  984730     MOV.B W0, [W14+3]
0028E8  37000F     BRA 0x2908
002902  90403E     MOV.B [W14+3], W0
002904  E84000     INC.B W0, W0
002906  984730     MOV.B W0, [W14+3]
002908  9040BE     MOV.B [W14+3], W1
00290A  90404E     MOV.B [W14+4], W0
00290C  50CF80     SUB.B W1, W0, [W15]
00290E  39FFED     BRA NC, 0x28EA
002910  370045     BRA 0x299C
161:                               *(strcmp->GetData + cnt2) = *(strcmp->CheckData + cnt2);
0028EA  90003E     MOV [W14+6], W0
0028EC  9000C0     MOV [W0+8], W1
0028EE  90403E     MOV.B [W14+3], W0
0028F0  FB8000     ZE W0, W0
0028F2  408000     ADD W1, W0, W0
0028F4  9000BE     MOV [W14+6], W1
0028F6  900121     MOV [W1+4], W2
0028F8  9040BE     MOV.B [W14+3], W1
0028FA  FB8081     ZE W1, W1
0028FC  410081     ADD W2, W1, W1
0028FE  784091     MOV.B [W1], W1
002900  784801     MOV.B W1, [W0]
162:                       } else {//如果要获取的字节数大于帧头数据，需要判断有效的剩余字节数数量
163:                           if (strcmp->Source_len - cnt < strcmp->Get_len)//如果获取数据大于有效数据，
002912  90003E     MOV [W14+6], W0
002914  904020     MOV.B [W0+2], W0
002916  FB8080     ZE W0, W1
002918  90401E     MOV.B [W14+1], W0
00291A  FB8000     ZE W0, W0
00291C  508080     SUB W1, W0, W1
00291E  90003E     MOV [W14+6], W0
002920  904820     MOV.B [W0+10], W0
002922  FB8000     ZE W0, W0
002924  508F80     SUB W1, W0, [W15]
002926  3D0020     BRA GE, 0x2968
164:                               for (cnt2 = 0; cnt2 < strcmp->Source_len - cnt; cnt2++) //获取剩余数据
002928  EB4000     CLR.B W0
00292A  984730     MOV.B W0, [W14+3]
00292C  370012     BRA 0x2952
00294C  90403E     MOV.B [W14+3], W0
00294E  E84000     INC.B W0, W0
002950  984730     MOV.B W0, [W14+3]
002952  90403E     MOV.B [W14+3], W0
002954  FB8080     ZE W0, W1
002956  90003E     MOV [W14+6], W0
002958  904020     MOV.B [W0+2], W0
00295A  FB8100     ZE W0, W2
00295C  90401E     MOV.B [W14+1], W0
00295E  FB8000     ZE W0, W0
002960  510000     SUB W2, W0, W0
002962  508F80     SUB W1, W0, [W15]
002964  35FFE4     BRA LT, 0x292E
002966  37001A     BRA 0x299C
165:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + cnt + cnt2);
00292E  90003E     MOV [W14+6], W0
002930  9000C0     MOV [W0+8], W1
002932  90403E     MOV.B [W14+3], W0
002934  FB8000     ZE W0, W0
002936  408000     ADD W1, W0, W0
002938  9000BE     MOV [W14+6], W1
00293A  780111     MOV [W1], W2
00293C  90409E     MOV.B [W14+1], W1
00293E  FB8181     ZE W1, W3
002940  9040BE     MOV.B [W14+3], W1
002942  FB8081     ZE W1, W1
002944  418081     ADD W3, W1, W1
002946  410081     ADD W2, W1, W1
002948  784091     MOV.B [W1], W1
00294A  784801     MOV.B W1, [W0]
166:                           else
167:                               for (cnt2 = 0; cnt2 <= strcmp->Get_len; cnt2++) //获取剩余数据
002968  EB4000     CLR.B W0
00296A  984730     MOV.B W0, [W14+3]
00296C  370012     BRA 0x2992
00298C  90403E     MOV.B [W14+3], W0
00298E  E84000     INC.B W0, W0
002990  984730     MOV.B W0, [W14+3]
002992  90003E     MOV [W14+6], W0
002994  9048A0     MOV.B [W0+10], W1
002996  90403E     MOV.B [W14+3], W0
002998  50CF80     SUB.B W1, W0, [W15]
00299A  31FFE9     BRA C, 0x296E
168:                                   *(strcmp->GetData + cnt2) = *(strcmp->SourceData + +cnt + cnt2);
00296E  90003E     MOV [W14+6], W0
002970  9000C0     MOV [W0+8], W1
002972  90403E     MOV.B [W14+3], W0
002974  FB8000     ZE W0, W0
002976  408000     ADD W1, W0, W0
002978  9000BE     MOV [W14+6], W1
00297A  780111     MOV [W1], W2
00297C  90409E     MOV.B [W14+1], W1
00297E  FB8181     ZE W1, W3
002980  9040BE     MOV.B [W14+3], W1
002982  FB8081     ZE W1, W1
002984  418081     ADD W3, W1, W1
002986  410081     ADD W2, W1, W1
002988  784091     MOV.B [W1], W1
00298A  784801     MOV.B W1, [W0]
169:                       }
170:                       strcmp->Real_len = cnt2; //实际获取到的长度
00299C  90003E     MOV [W14+6], W0
00299E  9040BE     MOV.B [W14+3], W1
0029A0  984831     MOV.B W1, [W0+11]
171:                       return true;
0029A2  B3C010     MOV.B #0x1, W0
0029A4  370004     BRA 0x29AE
172:                   }
173:                   strcmp->Real_len = 0;
0029A6  90003E     MOV [W14+6], W0
0029A8  EB4080     CLR.B W1
0029AA  984831     MOV.B W1, [W0+11]
174:                   return false;
0029AC  EB4000     CLR.B W0
175:               }
0029AE  FA8000     ULNK
0029B0  060000     RETURN
176:               
177:               /*************************************
178:               Function: UARTGetData  
179:               Description: 通过指定串口获取函数，获取数据保存至数据地址
180:               Input: UARTn获取函数，获取数据的地址
181:               Output: 字节数
182:               Notice：字节数不能大于256    
183:                *************************************/
184:               uint8_t UARTGetData(UARTn f_uart, uint8_t*Get_Data, uint8_t bytes) {//, const uint8_t get_size) {//注意'\0'
0029B2  FA0008     LNK #0x8
0029B4  980710     MOV W0, [W14+2]
0029B6  980721     MOV W1, [W14+4]
0029B8  984762     MOV.B W2, [W14+6]
185:                   uint8_t byte = 0;
0029BA  EB4000     CLR.B W0
0029BC  784F00     MOV.B W0, [W14]
186:                   while (bytes > byte) {
0029BE  370008     BRA 0x29D0
0029D0  90406E     MOV.B [W14+6], W0
0029D2  504F9E     SUB.B W0, [W14], [W15]
0029D4  3EFFF5     BRA GTU, 0x29C0
0029D6  370001     BRA 0x29DA
187:                       if (f_uart(Get_Data + byte))
0029C0  FB801E     ZE [W14], W0
0029C2  9000AE     MOV [W14+4], W1
0029C4  408000     ADD W1, W0, W0
0029C6  90009E     MOV [W14+2], W1
0029C8  010001     CALL W1
0029CA  E00400     CP0.B W0
0029CC  320005     BRA Z, 0x29D8
188:                           byte++;
0029CE  E84F1E     INC.B [W14], [W14]
189:                       else
190:                           break;
0029D8  000000     NOP
191:                   }
192:                   return byte;
0029DA  78401E     MOV.B [W14], W0
193:               }
0029DC  FA8000     ULNK
0029DE  060000     RETURN
194:               
195:               /*************************************
196:               Function: ClearBuffer
197:               Description: 清楚缓冲区数据
198:               Input: 指定清楚的串口
199:               Output: 无
200:               Notice：清楚串口缓冲区
201:                *************************************/
202:               void ClearBuffer(UARTn f_uart) {
0029E0  FA0004     LNK #0x4
0029E2  980710     MOV W0, [W14+2]
203:                   uint8_t tmp;
204:                   while (f_uart(&tmp));
0029E4  000000     NOP
0029E6  90009E     MOV [W14+2], W1
0029E8  78000E     MOV W14, W0
0029EA  010001     CALL W1
0029EC  E00400     CP0.B W0
0029EE  3AFFFB     BRA NZ, 0x29E6
205:               }
0029F0  FA8000     ULNK
206:               //将UARTGetData和
207:               
208:               //bool UARTIsGet(UARTn f_uart, uint8_t*Get_Source, const uint8_t get_size, const uint8_t *head, const uint8_t head_size) {
209:               //    StrCmp stcp;
210:               //    uint8_t Source_tmp[50]; //临时变量
211:               //    //    bool b = false;
212:               //
213:               //    stcp->Source_len = UARTGetData(f_uart, Source_tmp);
214:               //    if (stcp->Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
215:               //        stcp->Source_len = 50;
216:               //    stcp->SourceData = Source_tmp;
217:               //    stcp->CheckData = head;
218:               //    stcp->Check_len = head_size;
219:               //    stcp->GetData = Get_Source;
220:               //    stcp->Get_len = get_size;
221:               //
222:               //    return UARTDataIsRight(stcp);
223:               //}
224:               
225:               
226:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/HL6528.c  -----------------------------------
1:                 #include "HL6528.h"
2:                 #include <string.h>
3:                 //#include <math.h>
4:                 #include <stdlib.h>
5:                 #include  <libq.h>
6:                 #include "WGC.h"
7:                 #include "Common.h"
8:                 //#include "includes.h"
9:                 //#include <stdbool.h>
10:                //#include "cJSON.h"
11:                
12:                
13:                //extern OS_EVENT* sem1, *sem2; //上线拨号任务标志
14:                
15:                //struct ATCommand {
16:                const uint8_t K3[] = {"AT&K3\r\n"}; //{"AT&K3\r\n"};
17:                const uint8_t D1[] = {"AT&D1\r\n"}; //{"AT&K3\r\n"};
18:                const uint8_t AT[] = {"AT\r\n"};
19:                const uint8_t CREG_2[] = {"AT+CREG=2\r\n"};
20:                const uint8_t OK[] = {"OK"};
21:                const uint8_t CPIN[] = {"AT+CPIN?\r\n"};
22:                const uint8_t READY[] = {"+CPIN: READY"};
23:                const uint8_t CIMI[] = {"AT+CIMI\r\n"};
24:                const uint8_t CREG[] = {"AT+CREG?\r\n"};
25:                const uint8_t CGREG[] = {"AT+CGREG?\r\n"};
26:                const uint8_t _5[] = {",5"};
27:                const uint8_t _1[] = {",1"};
28:                const uint8_t CSCA[] = {"AT+CSCA\r\n"};
29:                //const uint8_t KCNXCFG[] = {"AT+KCNXCFG"};
30:                const uint8_t KCNXCFG[] = {"AT+KCNXCFG=1,\"GPRS\",\"CMNET\"\r\n"};
31:                const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"};//139.196.122.159\",5080\r\n\n"};
32:                uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.140.140\",11811\r\n\n"};
33:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.246.74.68\",5070\r\n"};//TR 
34:                //const uint8_t KTCPCFG[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n"};//移动ONENET
35:                const uint8_t KTCPSTART[] = {"AT+KTCPSTART=1\r\n"};
36:                const uint8_t CONNECT[] = {"CONNECT"};
37:                const uint8_t KTCPCLOSE[] = {"AT+KTCPCLOSE=1,1\r\n"};
38:                const uint8_t KTCPDEL[] = {"AT+KTCPDEL=1\r\n"};
39:                
40:                
41:                //static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt);
42:                
43:                void HL6528_Init(void) {
0029F4  FA0000     LNK #0x0
44:                    //初始化端口
45:                    PWRON_TRIS = 0; //PWN_ON 6528芯片电源控制
0029F6  A9C2D8     BCLR TRISD, #6
46:                    PWR_TRIS = 0; //外部控制6528芯片电源
0029F8  A9E2D8     BCLR TRISD, #7
47:                    DSR_TRIS = 0; //数据设备请求    
0029FA  A922E8     BCLR TRISF, #1
48:                    DTR_TRIS = 0; //数据终端请求
0029FC  A922D8     BCLR TRISD, #1
49:                    RTS_TRIS = 0; //请求发送数据
0029FE  A982D8     BCLR TRISD, #4
50:                    CTS_TRIS = 0; //请求接受数据  
002A00  A9A2D8     BCLR TRISD, #5
51:                    PWR = 0;
002A02  A9E2DC     BCLR LATD, #7
52:                    PWRON = 0;
002A04  A9C2DC     BCLR LATD, #6
53:                    CTS = 0;
002A06  A9A2DC     BCLR LATD, #5
54:                    RTS = 0;
002A08  A982DC     BCLR LATD, #4
55:                    DSR = 0;
002A0A  A922EC     BCLR LATF, #1
56:                    DTR = 0;
002A0C  A922DC     BCLR LATD, #1
57:                    //    UART2_Init();
58:                }
002A0E  FA8000     ULNK
002A10  060000     RETURN
59:                
60:                /*输入变量：发送字符串地址ss、接受字符串、接受字符串长度、发送字符串长度、对比字符串地址、对比字符串长度、发送间隔时间、发送次数**/
61:                static bool HL6528SendCmd(const uint8_t *ss, const uint8_t* cs, const uint8_t* cs1, const uint8_t csl, const uint8_t cnt) {
002A12  FA0048     LNK #0x48
002A14  982700     MOV W0, [W14+64]
002A16  982711     MOV W1, [W14+66]
002A18  982722     MOV W2, [W14+68]
002A1A  98C763     MOV.B W3, [W14+70]
002A1C  98C774     MOV.B W4, [W14+71]
62:                    uint8_t cnt_tmp = 0;
002A1E  EB4000     CLR.B W0
002A20  784F00     MOV.B W0, [W14]
63:                    bool b_sta = false;
002A22  EB4000     CLR.B W0
002A24  984710     MOV.B W0, [W14+1]
64:                    StrCmp stcp;
65:                    uint8_t tmp[50];
66:                    do {
67:                        cnt_tmp += 1;
002A26  E84F1E     INC.B [W14], [W14]
68:                        UART2_SendString(ss); //发送AT指令                               
002A28  90200E     MOV [W14+64], W0
002A2A  070418     RCALL UART2_SendString
69:                        Delay1s(3); //(0, 0, 3, 0); //延时1s
002A2C  B3C030     MOV.B #0x3, W0
002A2E  07FC15     RCALL Delay1s
70:                        U2Rx4Byte();
002A30  07044B     RCALL U2Rx4Byte
71:                        stcp.SourceData = tmp;
002A32  47006E     ADD W14, #0xE, W0
002A34  980710     MOV W0, [W14+2]
72:                        stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 50); //获取mark
002A36  90001E     MOV [W14+2], W0
002A38  B3C322     MOV.B #0x32, W2
002A3A  780080     MOV W0, W1
002A3C  227B80     MOV #0x27B8, W0
002A3E  07FFB9     RCALL UARTGetData
002A40  984740     MOV.B W0, [W14+4]
73:                        stcp.CheckData = (uint8_t*) cs;
002A42  90209E     MOV [W14+66], W1
002A44  980731     MOV W1, [W14+6]
74:                        stcp.Check_len = csl;
002A46  90C0EE     MOV.B [W14+70], W1
002A48  984F01     MOV.B W1, [W14+8]
75:                        stcp.GetData = NULL;
002A4A  EB0000     CLR W0
002A4C  980750     MOV W0, [W14+10]
76:                        stcp.Get_len = 0;
002A4E  EB4000     CLR.B W0
002A50  984F40     MOV.B W0, [W14+12]
77:                        stcp.Real_len = 0;
002A52  EB4000     CLR.B W0
002A54  984F50     MOV.B W0, [W14+13]
78:                
79:                        if (UARTDataIsRight(&stcp)) {
002A56  E8800E     INC2 W14, W0
002A58  07FEE9     RCALL UARTDataIsRight
002A5A  E00400     CP0.B W0
002A5C  320003     BRA Z, 0x2A64
80:                            b_sta = true;
002A5E  B3C010     MOV.B #0x1, W0
002A60  984710     MOV.B W0, [W14+1]
81:                            break;
002A62  37000F     BRA 0x2A82
82:                        }
83:                
84:                        if (cs1 != NULL) {//如果第二个校验数据不是NULL，那么进行第二个数据头的处理，判断处理。
002A64  90202E     MOV [W14+68], W0
002A66  E00000     CP0 W0
002A68  320009     BRA Z, 0x2A7C
85:                            stcp.CheckData = (uint8_t*) cs1;
002A6A  9020AE     MOV [W14+68], W1
002A6C  980731     MOV W1, [W14+6]
86:                            if (UARTDataIsRight(&stcp)) {
002A6E  E8800E     INC2 W14, W0
002A70  07FEDD     RCALL UARTDataIsRight
002A72  E00400     CP0.B W0
002A74  320003     BRA Z, 0x2A7C
87:                                b_sta = true;
002A76  B3C010     MOV.B #0x1, W0
002A78  984710     MOV.B W0, [W14+1]
88:                                break;
002A7A  370003     BRA 0x2A82
89:                            }
90:                        }
91:                
92:                    } while (cnt > cnt_tmp);
002A7C  90C07E     MOV.B [W14+71], W0
002A7E  504F9E     SUB.B W0, [W14], [W15]
002A80  3EFFD2     BRA GTU, 0x2A26
93:                    ClearBuffer(BufferRead_UART2);
002A82  227B80     MOV #0x27B8, W0
002A84  07FFAD     RCALL ClearBuffer
94:                    return b_sta;
002A86  90401E     MOV.B [W14+1], W0
95:                }
002A88  FA8000     ULNK
002A8A  060000     RETURN
96:                
97:                uint8_t HL6528_DialingIsERR(void) {
002A8C  FA0002     LNK #0x2
98:                    uint8_t sta;
99:                    //    uint8_t ip_port[25] = {'\0'};
100:               
101:                   //    HL6528_GetIP_Port();
102:                   PWR = 1;
002A8E  A8E2DC     BSET LATD, #7
103:                   PWRON = 1;
002A90  A8C2DC     BSET LATD, #6
104:                   CTS = 0;
002A92  A9A2DC     BCLR LATD, #5
105:                   RTS = 0;
002A94  A982DC     BCLR LATD, #4
106:                   DSR = 0;
002A96  A922EC     BCLR LATF, #1
107:                   DTR = 0;
002A98  A922DC     BCLR LATD, #1
108:                   Delay1s(2);
002A9A  B3C020     MOV.B #0x2, W0
002A9C  07FBDE     RCALL Delay1s
109:                   if (HL6528SendCmd(D1, OK, NULL, 2, 2)) {
002A9E  B3C024     MOV.B #0x2, W4
002AA0  B3C023     MOV.B #0x2, W3
002AA2  EB0100     CLR W2
002AA4  28F551     MOV #0x8F55, W1
002AA6  28F3C0     MOV #0x8F3C, W0
002AA8  07FFB4     RCALL _HL6528SendCmd
002AAA  E00400     CP0.B W0
002AAC  32003A     BRA Z, 0x2B22
110:                       if (HL6528SendCmd(CPIN, READY, NULL, 8, 2)) {
002AAE  B3C024     MOV.B #0x2, W4
002AB0  B3C083     MOV.B #0x8, W3
002AB2  EB0100     CLR W2
002AB4  28F631     MOV #0x8F63, W1
002AB6  28F580     MOV #0x8F58, W0
002AB8  07FFAC     RCALL _HL6528SendCmd
002ABA  E00400     CP0.B W0
002ABC  32002F     BRA Z, 0x2B1C
111:                           if (HL6528SendCmd(CREG, _5, _1, 2, 10)) {//设置网络模式
002ABE  B3C0A4     MOV.B #0xA, W4
002AC0  B3C023     MOV.B #0x2, W3
002AC2  28F942     MOV #0x8F94, W2
002AC4  28F911     MOV #0x8F91, W1
002AC6  28F7A0     MOV #0x8F7A, W0
002AC8  07FFA4     RCALL _HL6528SendCmd
002ACA  E00400     CP0.B W0
002ACC  320024     BRA Z, 0x2B16
112:                               if (HL6528SendCmd(KCNXCFG, OK, NULL, 2, 3)) {
002ACE  B3C034     MOV.B #0x3, W4
002AD0  B3C023     MOV.B #0x2, W3
002AD2  EB0100     CLR W2
002AD4  28F551     MOV #0x8F55, W1
002AD6  28FA10     MOV #0x8FA1, W0
002AD8  07FF9C     RCALL _HL6528SendCmd
002ADA  E00400     CP0.B W0
002ADC  320019     BRA Z, 0x2B10
113:                                   //HL6528_GetIP_Port(); //刷新IP地址和端口号
114:                                   if (HL6528SendCmd(KTCPCFG1, OK, NULL, 2, 3)) {
002ADE  B3C034     MOV.B #0x3, W4
002AE0  B3C023     MOV.B #0x2, W3
002AE2  EB0100     CLR W2
002AE4  28F551     MOV #0x8F55, W1
002AE6  2090E0     MOV #0x90E, W0
002AE8  07FF94     RCALL _HL6528SendCmd
002AEA  E00400     CP0.B W0
002AEC  32000E     BRA Z, 0x2B0A
115:                                       if (HL6528SendCmd(KTCPSTART, CONNECT, NULL, 5, 5)) {
002AEE  B3C054     MOV.B #0x5, W4
002AF0  B3C053     MOV.B #0x5, W3
002AF2  EB0100     CLR W2
002AF4  28FFD1     MOV #0x8FFD, W1
002AF6  28FEC0     MOV #0x8FEC, W0
002AF8  07FF8C     RCALL _HL6528SendCmd
002AFA  E00400     CP0.B W0
002AFC  320003     BRA Z, 0x2B04
116:                                           sta = 0;
002AFE  EB4000     CLR.B W0
002B00  784F00     MOV.B W0, [W14]
002B02  370011     BRA 0x2B26
117:                                       } else
118:                                           sta = 6; //未开启TCP，
002B04  B3C060     MOV.B #0x6, W0
002B06  784F00     MOV.B W0, [W14]
002B08  37000E     BRA 0x2B26
119:                                   } else
120:                                       sta = 5; //设置TCP失败
002B0A  B3C050     MOV.B #0x5, W0
002B0C  784F00     MOV.B W0, [W14]
002B0E  37000B     BRA 0x2B26
121:                               } else
122:                                   sta = 4; //设置APN的问题
002B10  B3C040     MOV.B #0x4, W0
002B12  784F00     MOV.B W0, [W14]
002B14  370008     BRA 0x2B26
123:                           } else
124:                               sta = 3; //手机信号未找到 电压不足可能导致
002B16  B3C030     MOV.B #0x3, W0
002B18  784F00     MOV.B W0, [W14]
002B1A  370005     BRA 0x2B26
125:                       } else
126:                           sta = 2; //手机卡未插入
002B1C  B3C020     MOV.B #0x2, W0
002B1E  784F00     MOV.B W0, [W14]
002B20  370002     BRA 0x2B26
127:                   } else
128:                       sta = 1; //模块损坏
002B22  B3C010     MOV.B #0x1, W0
002B24  784F00     MOV.B W0, [W14]
129:                   return sta;
002B26  78401E     MOV.B [W14], W0
130:               }
002B28  FA8000     ULNK
002B2A  060000     RETURN
131:               
132:               void HL6528_Close(void) {
002B2C  FA0020     LNK #0x20
133:                   uint8_t tmp[20];
134:                   StrCmp stcp;
135:                   ClearBuffer(BufferRead_UART2);
002B2E  227B80     MOV #0x27B8, W0
002B30  07FF57     RCALL ClearBuffer
136:                   do {
137:                       DSR = 1; //切换数据至AT命令 mark
002B32  A822EC     BSET LATF, #1
138:                       DTR = 1;
002B34  A822DC     BSET LATD, #1
139:                       Delay1s(1); //(0, 0, 1, 0); //延时1s
002B36  B3C010     MOV.B #0x1, W0
002B38  07FB90     RCALL Delay1s
140:                       DSR = 0; //请求发送数据
002B3A  A922EC     BCLR LATF, #1
141:                       DTR = 0;
002B3C  A922DC     BCLR LATD, #1
142:                       Delay1s(1); //(0, 0, 1, 0); //延时1s
002B3E  B3C010     MOV.B #0x1, W0
002B40  07FB8C     RCALL Delay1s
143:                       stcp.SourceData = tmp;
002B42  980F2E     MOV W14, [W14+20]
144:                       stcp.Source_len = UARTGetData(BufferRead_UART2, stcp.SourceData, 20); //获取mark
002B44  90082E     MOV [W14+20], W0
002B46  B3C142     MOV.B #0x14, W2
002B48  780080     MOV W0, W1
002B4A  227B80     MOV #0x27B8, W0
002B4C  07FF32     RCALL UARTGetData
002B4E  985760     MOV.B W0, [W14+22]
145:                       stcp.CheckData = (uint8_t*) OK;
002B50  28F550     MOV #0x8F55, W0
002B52  980F40     MOV W0, [W14+24]
146:                       stcp.Check_len = 2;
002B54  B3C020     MOV.B #0x2, W0
002B56  985F20     MOV.B W0, [W14+26]
147:                       stcp.GetData = NULL;
002B58  EB0000     CLR W0
002B5A  980F60     MOV W0, [W14+28]
148:                       stcp.Get_len = 0;
002B5C  EB4000     CLR.B W0
002B5E  985F60     MOV.B W0, [W14+30]
149:                       stcp.Real_len = 0;
002B60  EB4000     CLR.B W0
002B62  985F70     MOV.B W0, [W14+31]
150:                   } while (UARTDataIsRight(&stcp)); //等待接受成功下线返回OK
002B64  470074     ADD W14, #0x14, W0
002B66  07FE62     RCALL UARTDataIsRight
002B68  E00400     CP0.B W0
002B6A  3AFFE3     BRA NZ, 0x2B32
151:                   if (HL6528SendCmd(KTCPCLOSE, OK, NULL, 2, 2))//关闭并删除TCP的ID通道
002B6C  B3C024     MOV.B #0x2, W4
002B6E  B3C023     MOV.B #0x2, W3
002B70  EB0100     CLR W2
002B72  28F551     MOV #0x8F55, W1
002B74  290050     MOV #0x9005, W0
002B76  07FF4D     RCALL _HL6528SendCmd
002B78  E00400     CP0.B W0
002B7A  320006     BRA Z, 0x2B88
152:                       HL6528SendCmd(KTCPDEL, OK, NULL, 2, 2);
002B7C  B3C024     MOV.B #0x2, W4
002B7E  B3C023     MOV.B #0x2, W3
002B80  EB0100     CLR W2
002B82  28F551     MOV #0x8F55, W1
002B84  290180     MOV #0x9018, W0
002B86  07FF45     RCALL _HL6528SendCmd
153:                   Delay1s(1); // (0, 0, 1, 0); //延时1s    
002B88  B3C010     MOV.B #0x1, W0
002B8A  07FB67     RCALL Delay1s
154:                   PWR = 0; //电源控制
002B8C  A9E2DC     BCLR LATD, #7
155:                   PWRON = 0; //电源关闭
002B8E  A9C2DC     BCLR LATD, #6
156:                   CTS = 0; //请求接受
002B90  A9A2DC     BCLR LATD, #5
157:                   RTS = 0; //请求发送
002B92  A982DC     BCLR LATD, #4
158:                   DSR = 0; //设备
002B94  A922EC     BCLR LATF, #1
159:                   DTR = 0; //终端
002B96  A922DC     BCLR LATD, #1
160:                   UART2_Close();
002B98  07034F     RCALL UART2_Close
161:               }
002B9A  FA8000     ULNK
002B9C  060000     RETURN
162:               
163:               
164:               
165:               //static void HL6528_IOStart(void) {
166:               //    PWR = 1;
167:               //    PWRON = 1;
168:               //    CTS = 0;
169:               //    RTS = 0;
170:               //    DSR = 0;
171:               //    DTR = 0;
172:               //}
173:               //
174:               //static void HL6528_IOClose(void) {
175:               //    PWRON = 0;
176:               //    PWR = 0;
177:               //    CTS = 1;
178:               //    RTS = 1;
179:               //    DSR = 1;
180:               //    DTR = 1;
181:               //}
182:               
183:               void HL6528_GetIP_Port(void) {
002B9E  FA0020     LNK #0x20
184:                   uint8_t net_addr[25] = {'\0'};
002BA0  4700E2     ADD W14, #0x2, W1
002BA2  09000B     REPEAT #0xB
002BA4  EB1880     CLR [W1++]
002BA6  EB5880     CLR.B [W1++]
185:                   uint8_t str_tmp[4] = {1, 2, 3, 4};
002BA8  47017B     ADD W14, #0x1B, W2
002BAA  290271     MOV #0x9027, W1
002BAC  090003     REPEAT #0x3
002BAE  785931     MOV.B [W1++], [W2++]
186:                   uint8_t cnt;
187:                   uint8_t all_bytes = 0;
002BB0  EB4000     CLR.B W0
002BB2  984710     MOV.B W0, [W14+1]
188:               
189:                   //获取网络地址
190:                   all_bytes = my_itoa(WGCIPbits.IP3, net_addr);
002BB4  BFC817     MOV.B 0x817, WREG
002BB6  FB8000     ZE W0, W0
002BB8  E8808E     INC2 W14, W1
002BBA  07FBC0     RCALL my_itoa
002BBC  984710     MOV.B W0, [W14+1]
191:                   net_addr[all_bytes] = '.';
002BBE  90401E     MOV.B [W14+1], W0
002BC0  FB8000     ZE W0, W0
002BC2  470000     ADD W14, W0, W0
002BC4  B3C2E1     MOV.B #0x2E, W1
002BC6  984021     MOV.B W1, [W0+2]
192:                   net_addr[all_bytes + 1] = '\0';
002BC8  90401E     MOV.B [W14+1], W0
002BCA  FB8000     ZE W0, W0
002BCC  E80000     INC W0, W0
002BCE  470000     ADD W14, W0, W0
002BD0  EB4080     CLR.B W1
002BD2  984021     MOV.B W1, [W0+2]
193:                   all_bytes = all_bytes + 1;
002BD4  90401E     MOV.B [W14+1], W0
002BD6  E84000     INC.B W0, W0
002BD8  984710     MOV.B W0, [W14+1]
194:               
195:                   all_bytes += my_itoa(WGCIPbits.IP2, str_tmp);
002BDA  BFC816     MOV.B 0x816, WREG
002BDC  FB8000     ZE W0, W0
002BDE  4700FB     ADD W14, #0x1B, W1
002BE0  07FBAD     RCALL my_itoa
002BE2  90409E     MOV.B [W14+1], W1
002BE4  40C000     ADD.B W1, W0, W0
002BE6  984710     MOV.B W0, [W14+1]
196:                   strcat(net_addr, str_tmp);
002BE8  4700FB     ADD W14, #0x1B, W1
002BEA  E8800E     INC2 W14, W0
002BEC  07F199     RCALL 0xF20
197:                   net_addr[all_bytes ] = '.';
002BEE  90401E     MOV.B [W14+1], W0
002BF0  FB8000     ZE W0, W0
002BF2  470000     ADD W14, W0, W0
002BF4  B3C2E1     MOV.B #0x2E, W1
002BF6  984021     MOV.B W1, [W0+2]
198:                   net_addr[ all_bytes + 1] = '\0';
002BF8  90401E     MOV.B [W14+1], W0
002BFA  FB8000     ZE W0, W0
002BFC  E80000     INC W0, W0
002BFE  470000     ADD W14, W0, W0
002C00  EB4080     CLR.B W1
002C02  984021     MOV.B W1, [W0+2]
199:                   all_bytes = all_bytes + 1;
002C04  90401E     MOV.B [W14+1], W0
002C06  E84000     INC.B W0, W0
002C08  984710     MOV.B W0, [W14+1]
200:               
201:                   all_bytes += my_itoa(WGCIPbits.IP1, str_tmp);
002C0A  BFC815     MOV.B 0x815, WREG
002C0C  FB8000     ZE W0, W0
002C0E  4700FB     ADD W14, #0x1B, W1
002C10  07FB95     RCALL my_itoa
002C12  90409E     MOV.B [W14+1], W1
002C14  40C000     ADD.B W1, W0, W0
002C16  984710     MOV.B W0, [W14+1]
202:                   strcat(net_addr, str_tmp);
002C18  4700FB     ADD W14, #0x1B, W1
002C1A  E8800E     INC2 W14, W0
002C1C  07F181     RCALL 0xF20
203:                   net_addr[all_bytes ] = '.';
002C1E  90401E     MOV.B [W14+1], W0
002C20  FB8000     ZE W0, W0
002C22  470000     ADD W14, W0, W0
002C24  B3C2E1     MOV.B #0x2E, W1
002C26  984021     MOV.B W1, [W0+2]
204:                   net_addr[ all_bytes + 1] = '\0';
002C28  90401E     MOV.B [W14+1], W0
002C2A  FB8000     ZE W0, W0
002C2C  E80000     INC W0, W0
002C2E  470000     ADD W14, W0, W0
002C30  EB4080     CLR.B W1
002C32  984021     MOV.B W1, [W0+2]
205:                   all_bytes = all_bytes + 1;
002C34  90401E     MOV.B [W14+1], W0
002C36  E84000     INC.B W0, W0
002C38  984710     MOV.B W0, [W14+1]
206:               
207:                   all_bytes += my_itoa(WGCIPbits.IP0, str_tmp);
002C3A  BFC814     MOV.B WGCIPbits, WREG
002C3C  FB8000     ZE W0, W0
002C3E  4700FB     ADD W14, #0x1B, W1
002C40  07FB7D     RCALL my_itoa
002C42  90409E     MOV.B [W14+1], W1
002C44  40C000     ADD.B W1, W0, W0
002C46  984710     MOV.B W0, [W14+1]
208:                   strcat(net_addr, str_tmp);
002C48  4700FB     ADD W14, #0x1B, W1
002C4A  E8800E     INC2 W14, W0
002C4C  07F169     RCALL 0xF20
209:                   net_addr[ all_bytes ] = '"';
002C4E  90401E     MOV.B [W14+1], W0
002C50  FB8000     ZE W0, W0
002C52  470000     ADD W14, W0, W0
002C54  B3C221     MOV.B #0x22, W1
002C56  984021     MOV.B W1, [W0+2]
210:                   net_addr[all_bytes + 1 ] = ',';
002C58  90401E     MOV.B [W14+1], W0
002C5A  FB8000     ZE W0, W0
002C5C  E80000     INC W0, W0
002C5E  470000     ADD W14, W0, W0
002C60  B3C2C1     MOV.B #0x2C, W1
002C62  984021     MOV.B W1, [W0+2]
211:                   net_addr[ all_bytes + 2] = '\0';
002C64  90401E     MOV.B [W14+1], W0
002C66  FB8000     ZE W0, W0
002C68  E88000     INC2 W0, W0
002C6A  470000     ADD W14, W0, W0
002C6C  EB4080     CLR.B W1
002C6E  984021     MOV.B W1, [W0+2]
212:                   all_bytes = all_bytes + 2;
002C70  90401E     MOV.B [W14+1], W0
002C72  E8C000     INC2.B W0, W0
002C74  984710     MOV.B W0, [W14+1]
213:               
214:                   all_bytes += my_itoa(WGCPORT, str_tmp);
002C76  8040E0     MOV WGCPORT, W0
002C78  4700FB     ADD W14, #0x1B, W1
002C7A  07FB60     RCALL my_itoa
002C7C  90409E     MOV.B [W14+1], W1
002C7E  40C000     ADD.B W1, W0, W0
002C80  984710     MOV.B W0, [W14+1]
215:                   strcat(net_addr, str_tmp);
002C82  4700FB     ADD W14, #0x1B, W1
002C84  E8800E     INC2 W14, W0
002C86  07F14C     RCALL 0xF20
216:                   net_addr[ all_bytes ] = '\r';
002C88  90401E     MOV.B [W14+1], W0
002C8A  FB8000     ZE W0, W0
002C8C  470000     ADD W14, W0, W0
002C8E  B3C0D1     MOV.B #0xD, W1
002C90  984021     MOV.B W1, [W0+2]
217:                   net_addr[ all_bytes + 1] = '\n';
002C92  90401E     MOV.B [W14+1], W0
002C94  FB8000     ZE W0, W0
002C96  E80000     INC W0, W0
002C98  470000     ADD W14, W0, W0
002C9A  B3C0A1     MOV.B #0xA, W1
002C9C  984021     MOV.B W1, [W0+2]
218:                   net_addr[ all_bytes + 2] = '\0';
002C9E  90401E     MOV.B [W14+1], W0
002CA0  FB8000     ZE W0, W0
002CA2  E88000     INC2 W0, W0
002CA4  470000     ADD W14, W0, W0
002CA6  EB4080     CLR.B W1
002CA8  984021     MOV.B W1, [W0+2]
219:                   all_bytes = all_bytes + 2;
002CAA  90401E     MOV.B [W14+1], W0
002CAC  E8C000     INC2.B W0, W0
002CAE  984710     MOV.B W0, [W14+1]
220:                   //   uint8_t KTCPCFG1[] = {"AT+KTCPCFG=1,0,\"183.230.40.40\",1811\r\n\n"};
221:                   for (cnt = 0; cnt < all_bytes; cnt++)
002CB0  EB4000     CLR.B W0
002CB2  784F00     MOV.B W0, [W14]
002CB4  37000A     BRA 0x2CCA
002CC8  E84F1E     INC.B [W14], [W14]
002CCA  90401E     MOV.B [W14+1], W0
002CCC  78409E     MOV.B [W14], W1
002CCE  50CF80     SUB.B W1, W0, [W15]
002CD0  39FFF2     BRA NC, 0x2CB6
222:                       *(KTCPCFG1 + 16 + cnt) = *(net_addr + cnt);
002CB6  FB801E     ZE [W14], W0
002CB8  4000F0     ADD W0, #0x10, W1
002CBA  2090E0     MOV #0x90E, W0
002CBC  408000     ADD W1, W0, W0
002CBE  FB809E     ZE [W14], W1
002CC0  E8810E     INC2 W14, W2
002CC2  410081     ADD W2, W1, W1
002CC4  784091     MOV.B [W1], W1
002CC6  784801     MOV.B W1, [W0]
223:                   //    return all_bytes;
224:               }
002CD2  FA8000     ULNK
225:               
226:               
227:               
228:               
229:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/E41.c  --------------------------------------
1:                 #include "E41.h"
2:                 
3:                 #define M0_TRIS TRISEbits.TRISE5
4:                 #define M1_TRIS TRISEbits.TRISE6
5:                 #define M0 LATEbits.LATE5
6:                 #define M1 LATEbits.LATE6
7:                 #define M0_PORT PORTEbits.RE5
8:                 #define M1_PORT PORTEbits.RE6
9:                 #define AUX PORTFbits.RF6
10:                
11:                #define WORK 0
12:                #define WAKE 1
13:                #define LOWPOWER 2
14:                #define SLEEP 3
15:                uint8_t E41_Arg[] = {0xC0, 0xff, 0xff, 0x18, 0x1, 0xfc};
16:                // FF FF 18 01 9C
17:                //static ADDBITS E41_ADD;
18:                //static ARG1BITS E41_ARG1;
19:                //static ARG2BITS E41_ARG2;
20:                
21:                /*
22:                模式切换和 AUX：在低功耗应用中，用户单片机可能需要切换工作模式，从而达到休眠、无线唤醒的目的。此时，
23:                AUX 引脚将起到关键作用。表现在如下几个方面：
24:                a) 复位后，模块自检期间 AUX 处理低电平，AUX 上升沿后，模块才开始?入工作状态。
25:                b) 从模式 3 切换到其他模式后，模块也会产生自检，AUX 逡辑状态等同于复位。
26:                c) 模式切换前，如果 AUX 是高电平，可以直接改发 M1M0 切换到新模式，2ms 生效。
27:                d) 模式切换前，如果 AUX 是低电平，可以直接改发 M1M0 切换到新模式，AUX 上升沿后 2ms 生效。
28:                 */
29:                static void E41_SetMode(uint8_t mode) {
002EFC  FA0002     LNK #0x2
002EFE  784F00     MOV.B W0, [W14]
30:                    //获取当前的模式
31:                    //    uint8_t now_mode = M0_PORT + (M1_PORT << 1);//mark
32:                    //设置当前模式
33:                    //    switch (mode) {
34:                    //        case SLEEP:
35:                    //        {
36:                    INT0_Close(); //关闭串口，避免切换模式导致错误接受
002F00  0703F7     RCALL INT0_Close
37:                    M0 = 0;
002F02  A9A2E4     BCLR LATE, #5
38:                    M1 = 0; //避免自检程序
002F04  A9C2E4     BCLR LATE, #6
39:                    Delay100ms(3); //(0, 0, 0, 250);
002F06  200030     MOV #0x3, W0
002F08  07F98B     RCALL Delay100ms
40:                    M0 = mode & 0x01;
002F0A  78409E     MOV.B [W14], W1
002F0C  60C061     AND.B W1, #0x1, W0
002F0E  604061     AND.B W0, #0x1, W0
002F10  604061     AND.B W0, #0x1, W0
002F12  FB8000     ZE W0, W0
002F14  600061     AND W0, #0x1, W0
002F16  DD0045     SL W0, #5, W0
002F18  801721     MOV LATE, W1
002F1A  A15001     BCLR W1, #5
002F1C  700001     IOR W0, W1, W0
002F1E  881720     MOV W0, LATE
41:                    M1 = (mode >> 1) & 0x01;
002F20  FB801E     ZE [W14], W0
002F22  D10000     LSR W0, W0
002F24  784000     MOV.B W0, W0
002F26  604061     AND.B W0, #0x1, W0
002F28  604061     AND.B W0, #0x1, W0
002F2A  604061     AND.B W0, #0x1, W0
002F2C  FB8000     ZE W0, W0
002F2E  600061     AND W0, #0x1, W0
002F30  DD0046     SL W0, #6, W0
002F32  801721     MOV LATE, W1
002F34  A16001     BCLR W1, #6
002F36  700001     IOR W0, W1, W0
002F38  881720     MOV W0, LATE
42:                    Delay10ms(1); //(0, 0, 0, 10);
002F3A  200010     MOV #0x1, W0
002F3C  07F959     RCALL Delay10ms
43:                    INT0_Open();
002F3E  0703D3     RCALL INT0_Open
44:                    //            break;
45:                    //        }
46:                    //        case LOWPOWER:
47:                    //        {
48:                    //            break;
49:                    //        }
50:                    //        case WAKE:
51:                    //        {
52:                    //            break;
53:                    //        }
54:                    //        case WORK:
55:                    //        {
56:                    //            break;
57:                }
002F40  FA8000     ULNK
002F42  060000     RETURN
58:                //            M0 = mode & 0x01;
59:                //            M1 = (mode >> 1) & 0x01;
60:                //}
61:                //}
62:                
63:                void E41_Init(void) {
002F44  FA0002     LNK #0x2
64:                    uint8_t cnt;
65:                    M0_TRIS = 0; //设置引脚
002F46  A9A2E0     BCLR TRISE, #5
66:                    M1_TRIS = 0;
002F48  A9C2E0     BCLR TRISE, #6
67:                    //    uint8_t currentMode = E41_SetGetMode(10);
68:                    E41_SetMode(SLEEP);
002F4A  B3C030     MOV.B #0x3, W0
002F4C  07FFD7     RCALL _E41_SetMode
69:                    Delay100ms(3); //(0, 0, 0, 300); //必须加 300ms 避开自检
002F4E  200030     MOV #0x3, W0
002F50  07F967     RCALL Delay100ms
70:                    //    UART3_SendChar(0xC0);
71:                    for (cnt = 0; cnt < 3; cnt++) {
002F52  EB4000     CLR.B W0
002F54  784F00     MOV.B W0, [W14]
002F56  370006     BRA 0x2F64
002F62  E84F1E     INC.B [W14], [W14]
002F64  78401E     MOV.B [W14], W0
002F66  504FE2     SUB.B W0, #0x2, [W15]
002F68  36FFF7     BRA LEU, 0x2F58
72:                        UART3_SendString(E41_Arg, 6);
002F58  B3C061     MOV.B #0x6, W1
002F5A  209420     MOV #0x942, W0
002F5C  070271     RCALL UART3_SendString
73:                        //    UART3_SendString(E41_Arg, 6);
74:                        Delay10ms(1);
002F5E  200010     MOV #0x1, W0
002F60  07F947     RCALL Delay10ms
75:                //        (0, 0, 0, 10);
76:                    }
77:                    //    E41_SetMode(LOWPOWER); //设置为低功耗模式
78:                    //    E41_SetMode(WORK); //设置为唤醒模式   
79:                    E41_SetMode(WAKE); //设置为唤醒模式   
002F6A  B3C010     MOV.B #0x1, W0
002F6C  07FFC7     RCALL _E41_SetMode
80:                }
002F6E  FA8000     ULNK
002F70  060000     RETURN
81:                
82:                bool E41_PressureIsGet(float* pres) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
002F72  FA004E     LNK #0x4E
002F74  982760     MOV W0, [W14+76]
83:                    //判断接受到数据类型是仪表还是压力值
84:                    uint8_t tmp[10];
85:                    uint8_t Head[3] = {0x1, 0x3, 0x4};
002F76  B3C010     MOV.B #0x1, W0
002F78  984F20     MOV.B W0, [W14+10]
002F7A  B3C030     MOV.B #0x3, W0
002F7C  984F30     MOV.B W0, [W14+11]
002F7E  B3C040     MOV.B #0x4, W0
002F80  984F40     MOV.B W0, [W14+12]
86:                    U3Rx4Byte();
002F82  070282     RCALL U3Rx4Byte
87:                    StrCmp stcp;
88:                    uint8_t Source_tmp[50]; //临时变量
89:                
90:                    stcp.Source_len = UARTGetData(BufferRead_UART3, Source_tmp, 10);
002F84  47007A     ADD W14, #0x1A, W0
002F86  B3C0A2     MOV.B #0xA, W2
002F88  780080     MOV W0, W1
002F8A  227F20     MOV #0x27F2, W0
002F8C  07FD12     RCALL UARTGetData
002F8E  985700     MOV.B W0, [W14+16]
91:                    if (stcp.Source_len>sizeof (Source_tmp) / sizeof (uint8_t))//限制处理，单次采集数据大于50个字节，如果大于50个字节，那么设置为50个字节
002F90  90508E     MOV.B [W14+16], W1
002F92  B3C320     MOV.B #0x32, W0
002F94  50CF80     SUB.B W1, W0, [W15]
002F96  360002     BRA LEU, 0x2F9C
92:                        stcp.Source_len = 50;
002F98  B3C320     MOV.B #0x32, W0
002F9A  985700     MOV.B W0, [W14+16]
93:                    stcp.SourceData = Source_tmp;
002F9C  47007A     ADD W14, #0x1A, W0
002F9E  980770     MOV W0, [W14+14]
94:                    stcp.CheckData = Head;
002FA0  47006A     ADD W14, #0xA, W0
002FA2  980F10     MOV W0, [W14+18]
95:                    stcp.Check_len = 3;
002FA4  B3C030     MOV.B #0x3, W0
002FA6  985740     MOV.B W0, [W14+20]
96:                    stcp.GetData = tmp;
002FA8  980F3E     MOV W14, [W14+22]
97:                    stcp.Get_len = 8;
002FAA  B3C080     MOV.B #0x8, W0
002FAC  985F00     MOV.B W0, [W14+24]
98:                    stcp.Real_len = 0;
002FAE  EB4000     CLR.B W0
002FB0  985F10     MOV.B W0, [W14+25]
99:                    UARTDataIsRight(&stcp);
002FB2  47006E     ADD W14, #0xE, W0
002FB4  07FC3B     RCALL UARTDataIsRight
100:                   if ((stcp.Real_len == 9) && CRCIsRight(tmp, 7, tmp + 7)) {//注意优先的结合顺序
002FB6  90581E     MOV.B [W14+25], W0
002FB8  504FE9     SUB.B W0, #0x9, [W15]
002FBA  3A000D     BRA NZ, 0x2FD6
002FBC  470067     ADD W14, #0x7, W0
002FBE  780100     MOV W0, W2
002FC0  B3C071     MOV.B #0x7, W1
002FC2  78000E     MOV W14, W0
002FC4  0700A5     RCALL CRCIsRight
002FC6  E00400     CP0.B W0
002FC8  320006     BRA Z, 0x2FD6
101:                       CharToFloat(pres, tmp + 3);
002FCA  470063     ADD W14, #0x3, W0
002FCC  780080     MOV W0, W1
002FCE  90206E     MOV [W14+76], W0
002FD0  07F845     RCALL CharToFloat
102:                       return true;
002FD2  B3C010     MOV.B #0x1, W0
002FD4  370001     BRA 0x2FD8
103:                   }
104:                   return false;
002FD6  EB4000     CLR.B W0
105:               }
002FD8  FA8000     ULNK
002FDA  060000     RETURN
106:               
107:               void E41_Active_Send(void) {//接受到的压力值为01 03 04 3E F4 00 00 B6 29（16进制）
002FDC  FA0014     LNK #0x14
108:                   //判断接受到数据类型是仪表还是压力值
109:                   uint8_t E41_tmp[20] = {0x00, 0x01, 0x01, 0x12, 0x34, 0x20, 0x30, 0x42}, cnt;
002FDE  090009     REPEAT #0x9
002FE0  EB1F00     CLR [W14++]
002FE2  B1014E     SUB #0x14, W14
002FE4  B3C010     MOV.B #0x1, W0
002FE6  984710     MOV.B W0, [W14+1]
002FE8  B3C010     MOV.B #0x1, W0
002FEA  984720     MOV.B W0, [W14+2]
002FEC  B3C120     MOV.B #0x12, W0
002FEE  984730     MOV.B W0, [W14+3]
002FF0  B3C340     MOV.B #0x34, W0
002FF2  984740     MOV.B W0, [W14+4]
002FF4  B3C200     MOV.B #0x20, W0
002FF6  984750     MOV.B W0, [W14+5]
002FF8  B3C300     MOV.B #0x30, W0
002FFA  984760     MOV.B W0, [W14+6]
002FFC  B3C420     MOV.B #0x42, W0
002FFE  984770     MOV.B W0, [W14+7]
110:                   E41_SetMode(WAKE); //设置为唤醒模式    
003000  B3C010     MOV.B #0x1, W0
003002  07FF7C     RCALL _E41_SetMode
111:                   Delay100ms(1); //(0, 0, 0, 100);
003004  200010     MOV #0x1, W0
003006  07F90C     RCALL Delay100ms
112:                   INT0_Close();
003008  070373     RCALL INT0_Close
113:                   //    for (cnt = 0; cnt < 3; cnt++) {
114:                   UART3_SendString(E41_tmp, 8);
00300A  B3C081     MOV.B #0x8, W1
00300C  78000E     MOV W14, W0
00300E  070218     RCALL UART3_SendString
115:                   Delay10ms(1); //(0, 0, 0, 10);
003010  200010     MOV #0x1, W0
003012  07F8EE     RCALL Delay10ms
116:                   //必须加
117:                   //    }
118:                   INT0_Open();
003014  070368     RCALL INT0_Open
119:                   Delay1s(10); //(0, 0, 10, 0);
003016  2000A0     MOV #0xA, W0
003018  07F920     RCALL Delay1s
120:                   E41_SetMode(LOWPOWER); //设置为低功耗模式    
00301A  B3C020     MOV.B #0x2, W0
00301C  07FF6F     RCALL _E41_SetMode
121:                   //    OSTimeDlyHMSM(0, 0, 10, 0);
122:               }
00301E  FA8000     ULNK
123:               
124:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/Common.c  -----------------------------------
1:                 #include "Common.h"
2:                 
3:                 /*************************************
4:                 Function: FloatToChar 
5:                 Description: 浮点数转化为char数组
6:                 Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
7:                 Output: 输出数值
8:                  *************************************/
9:                 void FloatToChar(float *f, uint8_t *ch) {
00202E  FA0008     LNK #0x8
002030  980720     MOV W0, [W14+4]
002032  980731     MOV W1, [W14+6]
10:                    uint8_t count;
11:                    void * pf;
12:                    pf = f;
002034  9000AE     MOV [W14+4], W1
002036  980711     MOV W1, [W14+2]
13:                
14:                    for (count = 0; count < 4; count++) {
002038  EB4000     CLR.B W0
00203A  784F00     MOV.B W0, [W14]
00203C  37000A     BRA 0x2052
002050  E84F1E     INC.B [W14], [W14]
002052  78401E     MOV.B [W14], W0
002054  504FE3     SUB.B W0, #0x3, [W15]
002056  36FFF3     BRA LEU, 0x203E
15:                        *(ch + count) = *((uint8_t *) pf + 3 - count);
00203E  FB801E     ZE [W14], W0
002040  9000BE     MOV [W14+6], W1
002042  408000     ADD W1, W0, W0
002044  90011E     MOV [W14+2], W2
002046  FB809E     ZE [W14], W1
002048  1080E3     SUBR W1, #0x3, W1
00204A  410081     ADD W2, W1, W1
00204C  784091     MOV.B [W1], W1
00204E  784801     MOV.B W1, [W0]
16:                    }
17:                }
002058  FA8000     ULNK
00205A  060000     RETURN
18:                
19:                /*************************************
20:                Function: CharToFloat 
21:                Description: char数组转化为浮点数 
22:                Input: 输出数值    模式：4 单精度浮点数 8 双精度浮点数 
23:                Output: 输入浮点数
24:                 *************************************/
25:                void CharToFloat(float *f, uint8_t *ch) {
00205C  FA0008     LNK #0x8
00205E  980720     MOV W0, [W14+4]
002060  980731     MOV W1, [W14+6]
26:                    uint8_t count;
27:                    void *pf;
28:                    pf = f;
002062  9000AE     MOV [W14+4], W1
002064  980711     MOV W1, [W14+2]
29:                
30:                    for (count = 0; count < 4; count++) {
002066  EB4000     CLR.B W0
002068  784F00     MOV.B W0, [W14]
00206A  37000A     BRA 0x2080
00207E  E84F1E     INC.B [W14], [W14]
002080  78401E     MOV.B [W14], W0
002082  504FE3     SUB.B W0, #0x3, [W15]
002084  36FFF3     BRA LEU, 0x206C
31:                        *((uint8_t *) pf + count) = *(ch + 3 - count);
00206C  90009E     MOV [W14+2], W1
00206E  FB801E     ZE [W14], W0
002070  408000     ADD W1, W0, W0
002072  FB809E     ZE [W14], W1
002074  1080E3     SUBR W1, #0x3, W1
002076  90013E     MOV [W14+6], W2
002078  410081     ADD W2, W1, W1
00207A  784091     MOV.B [W1], W1
00207C  784801     MOV.B W1, [W0]
32:                    }
33:                }
002086  FA8000     ULNK
002088  060000     RETURN
34:                
35:                /*************************************
36:                Function: FloatToChar 
37:                Description: 浮点数转化为char数组
38:                Input: 输入浮点数 模式：4 单精度浮点数 8 双精度浮点数 
39:                Output: 输出数值
40:                 *************************************/
41:                void DoubleToChar(long double *d, uint8_t *ch) {
00208A  FA0008     LNK #0x8
00208C  980720     MOV W0, [W14+4]
00208E  980731     MOV W1, [W14+6]
42:                    uint8_t count;
43:                    void * pf;
44:                    pf = d;
002090  9000AE     MOV [W14+4], W1
002092  980711     MOV W1, [W14+2]
45:                
46:                    for (count = 0; count < 8; count++) {
002094  EB4000     CLR.B W0
002096  784F00     MOV.B W0, [W14]
002098  37000A     BRA 0x20AE
0020AC  E84F1E     INC.B [W14], [W14]
0020AE  78401E     MOV.B [W14], W0
0020B0  504FE7     SUB.B W0, #0x7, [W15]
0020B2  36FFF3     BRA LEU, 0x209A
47:                        *(ch + count) = *((uint8_t *) pf + 7 - count);
00209A  FB801E     ZE [W14], W0
00209C  9000BE     MOV [W14+6], W1
00209E  408000     ADD W1, W0, W0
0020A0  90011E     MOV [W14+2], W2
0020A2  FB809E     ZE [W14], W1
0020A4  1080E7     SUBR W1, #0x7, W1
0020A6  410081     ADD W2, W1, W1
0020A8  784091     MOV.B [W1], W1
0020AA  784801     MOV.B W1, [W0]
48:                    }
49:                }
0020B4  FA8000     ULNK
0020B6  060000     RETURN
50:                
51:                /*************************************
52:                Function: HCD 
53:                Description: 16进制转化为10进制
54:                Input: 数据，字节数
55:                Output: 输出数值
56:                 *************************************/
57:                uint8_t HCD(uint8_t dat) {
0020B8  FA0002     LNK #0x2
0020BA  781F88     MOV W8, [W15++]
0020BC  784F00     MOV.B W0, [W14]
58:                    return (dat >> 4)*10 + GetMod(dat, 4);
0020BE  FB801E     ZE [W14], W0
0020C0  DE0044     LSR W0, #4, W0
0020C2  784000     MOV.B W0, W0
0020C4  B9006A     MUL.SU W0, #10, W0
0020C6  780000     MOV W0, W0
0020C8  784400     MOV.B W0, W8
0020CA  FB801E     ZE [W14], W0
0020CC  B3C041     MOV.B #0x4, W1
0020CE  070126     RCALL GetMod
0020D0  444000     ADD.B W8, W0, W0
59:                }
0020D2  78044F     MOV [--W15], W8
0020D4  FA8000     ULNK
0020D6  060000     RETURN
60:                
61:                /*************************************
62:                Function: DCH 
63:                Description: 10进制转化为16进制
64:                Input: 数据，字节数
65:                Output: 输出数值
66:                 *************************************/
67:                uint8_t DCH(uint8_t dat) { //0x11 17
0020D8  FA0004     LNK #0x4
0020DA  784F00     MOV.B W0, [W14]
68:                    return ((dat / 10 << 4)&0xF0) | ((dat % 10)&0x0F);
0020DC  FB809E     ZE [W14], W1
0020DE  2000A0     MOV #0xA, W0
0020E0  780100     MOV W0, W2
0020E2  090011     REPEAT #0x11
0020E4  D88082     DIV.UW W1, W2
0020E6  784000     MOV.B W0, W0
0020E8  FB8000     ZE W0, W0
0020EA  DD0044     SL W0, #4, W0
0020EC  784000     MOV.B W0, W0
0020EE  984720     MOV.B W0, [W14+2]
0020F0  FB811E     ZE [W14], W2
0020F2  2000A0     MOV #0xA, W0
0020F4  780180     MOV W0, W3
0020F6  090011     REPEAT #0x11
0020F8  D88103     DIV.UW W2, W3
0020FA  FD0080     EXCH W0, W1
0020FC  784000     MOV.B W0, W0
0020FE  60406F     AND.B W0, #0xF, W0
002100  9040AE     MOV.B [W14+2], W1
002102  70C000     IOR.B W1, W0, W0
69:                }
002104  FA8000     ULNK
002106  060000     RETURN
70:                
71:                //uint8_t D2Hex(uint8_t dat)//0x11（17）-> 0x17  
72:                //{
73:                //    if(dat>)
74:                //}
75:                
76:                /*************************************
77:                Function: DataIsVaild 
78:                Description: 判断数据是否有效
79:                Input: 是否
80:                Output: 输出数值
81:                 *************************************/
82:                bool DataIsVaild(uint16_t dat, const uint16_t max, const uint16_t min) {
002108  FA0006     LNK #0x6
00210A  780F00     MOV W0, [W14]
00210C  980711     MOV W1, [W14+2]
00210E  980722     MOV W2, [W14+4]
83:                    if (dat > max) return false;
002110  90001E     MOV [W14+2], W0
002112  78009E     MOV [W14], W1
002114  508F80     SUB W1, W0, [W15]
002116  360002     BRA LEU, 0x211C
002118  EB4000     CLR.B W0
00211A  370007     BRA 0x212A
84:                    else if (dat < min) return false;
00211C  90002E     MOV [W14+4], W0
00211E  78009E     MOV [W14], W1
002120  508F80     SUB W1, W0, [W15]
002122  310002     BRA C, 0x2128
002124  EB4000     CLR.B W0
002126  370001     BRA 0x212A
85:                    return true;
002128  B3C010     MOV.B #0x1, W0
86:                }
00212A  FA8000     ULNK
00212C  060000     RETURN
87:                
88:                /*************************************
89:                Function: SetVaildData 
90:                Description: 根据阀值设置参数
91:                Input: 是否
92:                Output: 输出数值
93:                 *************************************/
94:                void SetVaildData(uint16_t * dat, const uint32_t max, const uint16_t min) {
00212E  FA000A     LNK #0xA
002130  980710     MOV W0, [W14+2]
002132  980722     MOV W2, [W14+4]
002134  980733     MOV W3, [W14+6]
002136  980741     MOV W1, [W14+8]
95:                    uint16_t tmp = ((*dat) << 8) + *(dat + 1);
002138  90001E     MOV [W14+2], W0
00213A  780010     MOV [W0], W0
00213C  DD00C8     SL W0, #8, W1
00213E  90001E     MOV [W14+2], W0
002140  E88000     INC2 W0, W0
002142  780010     MOV [W0], W0
002144  408F00     ADD W1, W0, [W14]
96:                
97:                    if (tmp > max) {
002146  78001E     MOV [W14], W0
002148  B80161     MUL.UU W0, #1, W2
00214A  90002E     MOV [W14+4], W0
00214C  9000BE     MOV [W14+6], W1
00214E  510F80     SUB W2, W0, [W15]
002150  598F81     SUBB W3, W1, [W15]
002152  360004     BRA LEU, 0x215C
98:                        *dat = max;
002154  9000AE     MOV [W14+4], W1
002156  90001E     MOV [W14+2], W0
002158  780801     MOV W1, [W0]
00215A  370007     BRA 0x216A
99:                    } else if (tmp < min) {
00215C  90004E     MOV [W14+8], W0
00215E  78009E     MOV [W14], W1
002160  508F80     SUB W1, W0, [W15]
002162  310003     BRA C, 0x216A
100:                       *dat = min;
002164  90001E     MOV [W14+2], W0
002166  9000CE     MOV [W14+8], W1
002168  780801     MOV W1, [W0]
101:                   }
102:               }
00216A  FA8000     ULNK
00216C  060000     RETURN
103:               //将数据反转
104:               
105:               void DataReverse(uint8_t *dat, const uint8_t byte) {
00216E  FA0006     LNK #0x6
002170  980710     MOV W0, [W14+2]
002172  984741     MOV.B W1, [W14+4]
106:                   uint8_t tmp, cnt;
107:               
108:                   for (cnt = 0; cnt < byte / 2; cnt++) {
002174  EB4000     CLR.B W0
002176  784F00     MOV.B W0, [W14]
002178  37001B     BRA 0x21B0
0021AE  E84F1E     INC.B [W14], [W14]
0021B0  90404E     MOV.B [W14+4], W0
0021B2  FB8000     ZE W0, W0
0021B4  D10000     LSR W0, W0
0021B6  784000     MOV.B W0, W0
0021B8  504F9E     SUB.B W0, [W14], [W15]
0021BA  3EFFDF     BRA GTU, 0x217A
109:                       tmp = dat[cnt];
00217A  FB801E     ZE [W14], W0
00217C  90009E     MOV [W14+2], W1
00217E  408000     ADD W1, W0, W0
002180  784090     MOV.B [W0], W1
002182  984711     MOV.B W1, [W14+1]
110:                       dat[cnt] = dat[byte - 1 - cnt];
002184  FB801E     ZE [W14], W0
002186  90009E     MOV [W14+2], W1
002188  408000     ADD W1, W0, W0
00218A  9040CE     MOV.B [W14+4], W1
00218C  FB8081     ZE W1, W1
00218E  E90101     DEC W1, W2
002190  FB809E     ZE [W14], W1
002192  510081     SUB W2, W1, W1
002194  90011E     MOV [W14+2], W2
002196  410081     ADD W2, W1, W1
002198  784091     MOV.B [W1], W1
00219A  784801     MOV.B W1, [W0]
111:                       dat[byte - 1 - cnt] = tmp;
00219C  90404E     MOV.B [W14+4], W0
00219E  FB8000     ZE W0, W0
0021A0  E90080     DEC W0, W1
0021A2  FB801E     ZE [W14], W0
0021A4  508000     SUB W1, W0, W0
0021A6  90009E     MOV [W14+2], W1
0021A8  408000     ADD W1, W0, W0
0021AA  90409E     MOV.B [W14+1], W1
0021AC  784801     MOV.B W1, [W0]
112:                   }
113:               }
0021BC  FA8000     ULNK
0021BE  060000     RETURN
114:               
115:               //void Delayms(uint16_t time) {//不能大于1000,溢出
116:               //    TMR2 = 0; //清楚定时器2的计数器
117:               //    PR2 = 625 * time / 10; //设置定时时间
118:               //    IFS0bits.T2IF = 0;
119:               //    T2CONbits.TON = 1; //开启定时器二    
120:               //    while (!IFS0bits.T2IF); //等待定时时间到
121:               //    T2CONbits.TON = 0; //关闭定时器二
122:               //    IFS0bits.T2IF = 0; //清楚标志位
123:               //}
124:               //8MHz-》4Mhz 使用重载入的函数
125:               //0x0271 10ms
126:               
127:               //32Mhz
128:               
129:               void Delay1ms(char time) {
0021C0  FA0004     LNK #0x4
0021C2  984720     MOV.B W0, [W14+2]
130:                   uint16_t i;
131:                   while (time-- > 0)
0021C4  370009     BRA 0x21D8
0021D8  B3C010     MOV.B #0x1, W0
0021DA  9040AE     MOV.B [W14+2], W1
0021DC  E00401     CP0.B W1
0021DE  3C0001     BRA GT, 0x21E2
0021E0  EB4000     CLR.B W0
0021E2  9040AE     MOV.B [W14+2], W1
0021E4  E94081     DEC.B W1, W1
0021E6  984721     MOV.B W1, [W14+2]
0021E8  E00400     CP0.B W0
0021EA  3AFFED     BRA NZ, 0x21C6
132:                       for (i = 0; i < 2300; i++)
0021C6  EB0000     CLR W0
0021C8  780F00     MOV W0, [W14]
0021CA  370002     BRA 0x21D0
0021CE  E80F1E     INC [W14], [W14]
0021D0  208FB0     MOV #0x8FB, W0
0021D2  78009E     MOV [W14], W1
0021D4  508F80     SUB W1, W0, [W15]
0021D6  36FFFA     BRA LEU, 0x21CC
133:                           Nop();
0021CC  000000     NOP
134:               }
0021EC  FA8000     ULNK
0021EE  060000     RETURN
135:               
136:               void Delay10ms(char time) {
0021F0  FA0004     LNK #0x4
0021F2  984720     MOV.B W0, [W14+2]
137:                   uint16_t i;
138:                   while (time-- > 0)
0021F4  370009     BRA 0x2208
002208  B3C010     MOV.B #0x1, W0
00220A  9040AE     MOV.B [W14+2], W1
00220C  E00401     CP0.B W1
00220E  3C0001     BRA GT, 0x2212
002210  EB4000     CLR.B W0
002212  9040AE     MOV.B [W14+2], W1
002214  E94081     DEC.B W1, W1
002216  984721     MOV.B W1, [W14+2]
002218  E00400     CP0.B W0
00221A  3AFFED     BRA NZ, 0x21F6
139:                       for (i = 0; i < 23000; i++)
0021F6  EB0000     CLR W0
0021F8  780F00     MOV W0, [W14]
0021FA  370002     BRA 0x2200
0021FE  E80F1E     INC [W14], [W14]
002200  259D70     MOV #0x59D7, W0
002202  78009E     MOV [W14], W1
002204  508F80     SUB W1, W0, [W15]
002206  36FFFA     BRA LEU, 0x21FC
140:                           Nop();
0021FC  000000     NOP
141:               }
00221C  FA8000     ULNK
00221E  060000     RETURN
142:               
143:               void Delay100ms(char time) {
002220  FA0006     LNK #0x6
002222  984740     MOV.B W0, [W14+4]
144:                   uint32_t i;
145:                   while (time-- > 0)
002224  37000E     BRA 0x2242
002242  B3C010     MOV.B #0x1, W0
002244  9040CE     MOV.B [W14+4], W1
002246  E00401     CP0.B W1
002248  3C0001     BRA GT, 0x224C
00224A  EB4000     CLR.B W0
00224C  9040CE     MOV.B [W14+4], W1
00224E  E94081     DEC.B W1, W1
002250  984741     MOV.B W1, [W14+4]
002252  E00400     CP0.B W0
002254  3AFFE8     BRA NZ, 0x2226
146:                       for (i = 0; i < 122500; i++)
002226  B80060     MUL.UU W0, #0, W0
002228  BE8F00     MOV.D W0, [W14]
00222A  370005     BRA 0x2236
00222E  200012     MOV #0x1, W2
002230  200003     MOV #0x0, W3
002232  410F1E     ADD W2, [W14], [W14]
002234  49975E     ADDC W3, [++W14], [W14--]
002236  2DE830     MOV #0xDE83, W0
002238  200011     MOV #0x1, W1
00223A  BE011E     MOV.D [W14], W2
00223C  510F80     SUB W2, W0, [W15]
00223E  598F81     SUBB W3, W1, [W15]
002240  36FFF5     BRA LEU, 0x222C
147:                           Nop();
00222C  000000     NOP
148:               }
002256  FA8000     ULNK
002258  060000     RETURN
149:               
150:               void Delay1s(char time) {
00225A  FA0006     LNK #0x6
00225C  984740     MOV.B W0, [W14+4]
151:                   uint32_t i; //,j;
152:                   while (time-- > 0)
00225E  37000E     BRA 0x227C
00227C  B3C010     MOV.B #0x1, W0
00227E  9040CE     MOV.B [W14+4], W1
002280  E00401     CP0.B W1
002282  3C0001     BRA GT, 0x2286
002284  EB4000     CLR.B W0
002286  9040CE     MOV.B [W14+4], W1
002288  E94081     DEC.B W1, W1
00228A  984741     MOV.B W1, [W14+4]
00228C  E00400     CP0.B W0
00228E  3AFFE8     BRA NZ, 0x2260
153:                       for (i = 0; i < 1235000; i++)
002260  B80060     MUL.UU W0, #0, W0
002262  BE8F00     MOV.D W0, [W14]
002264  370005     BRA 0x2270
002268  200012     MOV #0x1, W2
00226A  200003     MOV #0x0, W3
00226C  410F1E     ADD W2, [W14], [W14]
00226E  49975E     ADDC W3, [++W14], [W14--]
002270  2D8370     MOV #0xD837, W0
002272  200121     MOV #0x12, W1
002274  BE011E     MOV.D [W14], W2
002276  510F80     SUB W2, W0, [W15]
002278  598F81     SUBB W3, W1, [W15]
00227A  36FFF5     BRA LEU, 0x2266
154:                           Nop();
002266  000000     NOP
155:               }
002290  FA8000     ULNK
002292  060000     RETURN
156:               
157:               //void Delays(char time) {
158:               //    uint8_t cnt;
159:               //    for (cnt = 0; cnt < time; cnt++)
160:               //        Delayms(1000);
161:               //}
162:               
163:               void CopyDat(uint8_t* output, const uint8_t *input, const uint8_t bytes) {
002294  FA0008     LNK #0x8
002296  980710     MOV W0, [W14+2]
002298  980721     MOV W1, [W14+4]
00229A  984762     MOV.B W2, [W14+6]
164:                   uint8_t num;
165:                   for (num = 0; num < bytes; num++)
00229C  EB4000     CLR.B W0
00229E  784F00     MOV.B W0, [W14]
0022A0  370009     BRA 0x22B4
0022B2  E84F1E     INC.B [W14], [W14]
0022B4  90406E     MOV.B [W14+6], W0
0022B6  78409E     MOV.B [W14], W1
0022B8  50CF80     SUB.B W1, W0, [W15]
0022BA  39FFF3     BRA NC, 0x22A2
166:                       *(output + num) = *(input + num);
0022A2  FB801E     ZE [W14], W0
0022A4  90009E     MOV [W14+2], W1
0022A6  408000     ADD W1, W0, W0
0022A8  FB809E     ZE [W14], W1
0022AA  90012E     MOV [W14+4], W2
0022AC  410081     ADD W2, W1, W1
0022AE  784091     MOV.B [W1], W1
0022B0  784801     MOV.B W1, [W0]
167:               }
0022BC  FA8000     ULNK
0022BE  060000     RETURN
168:               
169:               void ClearDat(uint8_t *output, const uint8_t dat, const uint8_t bytes) {
0022C0  FA0006     LNK #0x6
0022C2  980710     MOV W0, [W14+2]
0022C4  984741     MOV.B W1, [W14+4]
0022C6  984752     MOV.B W2, [W14+5]
170:                   uint8_t num;
171:                   for (num = 0; num < bytes; num++)
0022C8  EB4000     CLR.B W0
0022CA  784F00     MOV.B W0, [W14]
0022CC  370006     BRA 0x22DA
0022D8  E84F1E     INC.B [W14], [W14]
0022DA  90405E     MOV.B [W14+5], W0
0022DC  78409E     MOV.B [W14], W1
0022DE  50CF80     SUB.B W1, W0, [W15]
0022E0  39FFF6     BRA NC, 0x22CE
172:                       *(output + num) = dat;
0022CE  FB801E     ZE [W14], W0
0022D0  90009E     MOV [W14+2], W1
0022D2  408000     ADD W1, W0, W0
0022D4  9040CE     MOV.B [W14+4], W1
0022D6  784801     MOV.B W1, [W0]
173:               }
0022E2  FA8000     ULNK
0022E4  060000     RETURN
174:               
175:               bool ValueIsEqual(const uint8_t *str1, const uint8_t *str2, const uint8_t bytes) {
0022E6  FA0008     LNK #0x8
0022E8  980710     MOV W0, [W14+2]
0022EA  980721     MOV W1, [W14+4]
0022EC  984762     MOV.B W2, [W14+6]
176:                   uint8_t cnt;
177:                   for (cnt = 0; cnt < bytes; cnt++)
0022EE  EB4000     CLR.B W0
0022F0  784F00     MOV.B W0, [W14]
0022F2  37000D     BRA 0x230E
00230C  E84F1E     INC.B [W14], [W14]
00230E  90406E     MOV.B [W14+6], W0
002310  78409E     MOV.B [W14], W1
002312  50CF80     SUB.B W1, W0, [W15]
002314  39FFEF     BRA NC, 0x22F4
178:                       if (*(str1 + cnt) != *(str2 + cnt))
0022F4  FB801E     ZE [W14], W0
0022F6  90009E     MOV [W14+2], W1
0022F8  408000     ADD W1, W0, W0
0022FA  784090     MOV.B [W0], W1
0022FC  FB801E     ZE [W14], W0
0022FE  90012E     MOV [W14+4], W2
002300  410000     ADD W2, W0, W0
002302  784010     MOV.B [W0], W0
002304  50CF80     SUB.B W1, W0, [W15]
002306  320002     BRA Z, 0x230C
179:                           return false;
002308  EB4000     CLR.B W0
00230A  370006     BRA 0x2318
180:                   return true;
002316  B3C010     MOV.B #0x1, W0
181:               }
002318  FA8000     ULNK
00231A  060000     RETURN
182:               
183:               //快速去余数
184:               
185:               uint8_t GetMod(uint16_t num, uint8_t mod_num) {
00231C  FA0004     LNK #0x4
00231E  780F00     MOV W0, [W14]
002320  984721     MOV.B W1, [W14+2]
186:                   return num - ((num >> mod_num) << mod_num);
002322  78001E     MOV [W14], W0
002324  784080     MOV.B W0, W1
002326  90402E     MOV.B [W14+2], W0
002328  FB8000     ZE W0, W0
00232A  78011E     MOV [W14], W2
00232C  DE1100     LSR W2, W0, W2
00232E  90402E     MOV.B [W14+2], W0
002330  FB8000     ZE W0, W0
002332  DD1000     SL W2, W0, W0
002334  784000     MOV.B W0, W0
002336  50C000     SUB.B W1, W0, W0
187:               }
002338  FA8000     ULNK
00233A  060000     RETURN
188:               
189:               //16位整数转化为字符串
190:               
191:               uint8_t my_itoa(uint16_t i, uint8_t *str) {
00233C  FA0010     LNK #0x10
00233E  980750     MOV W0, [W14+10]
002340  980761     MOV W1, [W14+12]
192:                   uint8_t buf[6];
193:                   uint8_t cnt = 0, len;
002342  EB4000     CLR.B W0
002344  784F00     MOV.B W0, [W14]
194:                   uint16_t tmp = i;
002346  90005E     MOV [W14+10], W0
002348  980710     MOV W0, [W14+2]
195:                   if (!tmp) {
00234A  90001E     MOV [W14+2], W0
00234C  E00000     CP0 W0
00234E  3A001E     BRA NZ, 0x238C
196:                       *str = '0';
002350  90006E     MOV [W14+12], W0
002352  B3C301     MOV.B #0x30, W1
002354  784801     MOV.B W1, [W0]
197:                       *(str + 1) = '\0';
002356  90006E     MOV [W14+12], W0
002358  E80000     INC W0, W0
00235A  EB4080     CLR.B W1
00235C  784801     MOV.B W1, [W0]
198:                       len = 1;
00235E  B3C010     MOV.B #0x1, W0
002360  984710     MOV.B W0, [W14+1]
002362  370034     BRA 0x23CC
199:                   } else {
200:                       while (tmp) {
00238C  90001E     MOV [W14+2], W0
00238E  E00000     CP0 W0
002390  3AFFE9     BRA NZ, 0x2364
201:                           *(buf + cnt++) = tmp % 10 + 0x30;
002364  FB801E     ZE [W14], W0
002366  4700E4     ADD W14, #0x4, W1
002368  408080     ADD W1, W0, W1
00236A  980771     MOV W1, [W14+14]
00236C  90011E     MOV [W14+2], W2
00236E  2000A1     MOV #0xA, W1
002370  780181     MOV W1, W3
002372  090011     REPEAT #0x11
002374  D88103     DIV.UW W2, W3
002376  784081     MOV.B W1, W1
002378  B04301     ADD.B #0x30, W1
00237A  90007E     MOV [W14+14], W0
00237C  784801     MOV.B W1, [W0]
00237E  E84F1E     INC.B [W14], [W14]
202:                           tmp /= 10;
002380  90009E     MOV [W14+2], W1
002382  2000A0     MOV #0xA, W0
002384  780100     MOV W0, W2
002386  090011     REPEAT #0x11
002388  D88082     DIV.UW W1, W2
00238A  980710     MOV W0, [W14+2]
203:                       }
204:                       len = cnt;
002392  78419E     MOV.B [W14], W3
002394  984713     MOV.B W3, [W14+1]
205:                       cnt += 1;
002396  E84F1E     INC.B [W14], [W14]
206:                       while (cnt--) {
002398  37000C     BRA 0x23B2
0023B2  FB801E     ZE [W14], W0
0023B4  EA0000     NEG W0, W0
0023B6  DE004F     LSR W0, #15, W0
0023B8  784000     MOV.B W0, W0
0023BA  E94F1E     DEC.B [W14], [W14]
0023BC  E00400     CP0.B W0
0023BE  3AFFED     BRA NZ, 0x239A
207:                           *(str + cnt - 1) = *(buf + len - cnt);
00239A  FB801E     ZE [W14], W0
00239C  E90000     DEC W0, W0
00239E  9000EE     MOV [W14+12], W1
0023A0  408000     ADD W1, W0, W0
0023A2  90409E     MOV.B [W14+1], W1
0023A4  FB8101     ZE W1, W2
0023A6  FB809E     ZE [W14], W1
0023A8  510081     SUB W2, W1, W1
0023AA  470164     ADD W14, #0x4, W2
0023AC  410081     ADD W2, W1, W1
0023AE  784091     MOV.B [W1], W1
0023B0  784801     MOV.B W1, [W0]
208:                       }
209:                       *(str + len) = '\0';
0023C0  90401E     MOV.B [W14+1], W0
0023C2  FB8000     ZE W0, W0
0023C4  9000EE     MOV [W14+12], W1
0023C6  408000     ADD W1, W0, W0
0023C8  EB4080     CLR.B W1
0023CA  784801     MOV.B W1, [W0]
210:                   }
211:                   return len;
0023CC  90401E     MOV.B [W14+1], W0
212:               }
0023CE  FA8000     ULNK
213:               
214:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/CheckData.c  --------------------------------
1:                 //#include "user.h"
2:                 #include "CheckData.h"
3:                 
4:                 ///****************************************************************************
5:                 //名称: CRC16()
6:                 //说明: CRC16校验程序
7:                 //参数: *CRC_Buf:数据地址
8:                 //      CRC_Leni:数据长度
9:                 //返回: CRC校验值
10:                // *****************************************************************************/
11:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, const uint8_t CRC_Leni) {
12:                //    uint16_t i, j;
13:                //    uint16_t CRC_Sumx;
14:                //
15:                //    CRC_Sumx = 0xFFFF;
16:                //    for (i = 0; i < CRC_Leni; i++) {
17:                //        CRC_Sumx ^= *(CRC_Buf + i); //异或
18:                //        for (j = 0; j < 8; j++) {
19:                //            if (CRC_Sumx & 0x01) {
20:                //                CRC_Sumx >>= 1;
21:                //                CRC_Sumx ^= 0xA001;
22:                //            } else {
23:                //                CRC_Sumx >>= 1;
24:                //            }
25:                //        }
26:                //    }
27:                //    return (CRC_Sumx);
28:                //}
29:                
30:                /*************************************
31:                Function: CheckIsRight  
32:                Description: 判断接受dat，根据fp校验，返回数据正确性
33:                Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
34:                Output: 1：校验正确  0：校验错误
35:                 *************************************/
36:                bool CRCIsRight(uint8_t * CRC_Buf, const uint8_t CRC_Leni, const uint8_t* CHC_Dat) {
003110  FA000C     LNK #0xC
003112  980730     MOV W0, [W14+6]
003114  984F01     MOV.B W1, [W14+8]
003116  980752     MOV W2, [W14+10]
37:                    uint16_t i, j;
38:                    uint16_t CRC_Sumx;
39:                
40:                    CRC_Sumx = 0xFFFF;
003118  EB8000     SETM W0
00311A  980720     MOV W0, [W14+4]
41:                    for (i = 0; i < CRC_Leni; i++) {
00311C  EB0000     CLR W0
00311E  780F00     MOV W0, [W14]
003120  370021     BRA 0x3164
003162  E80F1E     INC [W14], [W14]
003164  90480E     MOV.B [W14+8], W0
003166  FB8000     ZE W0, W0
003168  500F9E     SUB W0, [W14], [W15]
00316A  3EFFDB     BRA GTU, 0x3122
42:                        CRC_Sumx ^= *(CRC_Buf + i); //异或
003122  90003E     MOV [W14+6], W0
003124  40001E     ADD W0, [W14], W0
003126  784010     MOV.B [W0], W0
003128  FB8000     ZE W0, W0
00312A  9000AE     MOV [W14+4], W1
00312C  688000     XOR W1, W0, W0
00312E  980720     MOV W0, [W14+4]
43:                        for (j = 0; j < 8; j++) {
003130  EB0000     CLR W0
003132  980710     MOV W0, [W14+2]
003134  370013     BRA 0x315C
003156  90001E     MOV [W14+2], W0
003158  E80000     INC W0, W0
00315A  980710     MOV W0, [W14+2]
00315C  90001E     MOV [W14+2], W0
00315E  500FE7     SUB W0, #0x7, [W15]
003160  36FFEA     BRA LEU, 0x3136
44:                            if (CRC_Sumx & 0x01) {
003136  90002E     MOV [W14+4], W0
003138  600061     AND W0, #0x1, W0
00313A  784000     MOV.B W0, W0
00313C  E00400     CP0.B W0
00313E  320008     BRA Z, 0x3150
45:                                CRC_Sumx >>= 1;
003140  90002E     MOV [W14+4], W0
003142  D10000     LSR W0, W0
003144  980720     MOV W0, [W14+4]
46:                                CRC_Sumx ^= 0xA001;
003146  9000AE     MOV [W14+4], W1
003148  2A0010     MOV #0xA001, W0
00314A  688000     XOR W1, W0, W0
00314C  980720     MOV W0, [W14+4]
00314E  370003     BRA 0x3156
47:                            } else {
48:                                CRC_Sumx >>= 1;
003150  90002E     MOV [W14+4], W0
003152  D10000     LSR W0, W0
003154  980720     MOV W0, [W14+4]
49:                            }
50:                        }
51:                    }; //CRC校验
52:                    return (CRC_Sumx == (*CHC_Dat + (*(CHC_Dat + 1) << 8))); //校验数据+CRC
00316C  90005E     MOV [W14+10], W0
00316E  784010     MOV.B [W0], W0
003170  FB8080     ZE W0, W1
003172  90005E     MOV [W14+10], W0
003174  E80000     INC W0, W0
003176  784010     MOV.B [W0], W0
003178  FB8000     ZE W0, W0
00317A  DD0048     SL W0, #8, W0
00317C  408000     ADD W1, W0, W0
00317E  780080     MOV W0, W1
003180  90002E     MOV [W14+4], W0
003182  688000     XOR W1, W0, W0
003184  A7F000     BTSC W0, #15
003186  EA0000     NEG W0, W0
003188  E90000     DEC W0, W0
00318A  DE004F     LSR W0, #15, W0
00318C  784000     MOV.B W0, W0
53:                }
00318E  FA8000     ULNK
003190  060000     RETURN
54:                
55:                ///*************************************
56:                //Function: Sum_Check 
57:                //Description: 计算和校验的数值，
58:                //Input: frame：数据，bytes：字节数 
59:                //Output: 和校验结果值
60:                // *************************************/
61:                //uint16_t Sum_Check(uint8_t *frame, const uint8_t bytes) {
62:                //    uint16_t cksum = 0;
63:                //    uint16_t cnt = bytes;
64:                //    while (cnt > 0) {
65:                //        cksum += *frame++;
66:                //        cnt--;
67:                //    }
68:                //    return cksum;
69:                //}
70:                
71:                /*************************************
72:                Function: Sum_Check256
73:                Description: 计算和校验的数值，
74:                Input: frame：数据，bytes：字节数 
75:                Output: 和校验结果值
76:                 *************************************/
77:                bool SumCheckIsRight(uint8_t *frame, const uint16_t bytes, const uint8_t CheckSum) {
003192  FA000C     LNK #0xC
003194  980730     MOV W0, [W14+6]
003196  980741     MOV W1, [W14+8]
003198  984F22     MOV.B W2, [W14+10]
78:                    uint32_t ckSum = 0; //避免数据溢出
00319A  B80060     MUL.UU W0, #0, W0
00319C  BE8F00     MOV.D W0, [W14]
79:                    uint16_t cnt;
80:                
81:                    for (cnt = 0; cnt < bytes; cnt++)
00319E  EB0000     CLR W0
0031A0  980720     MOV W0, [W14+4]
0031A2  37000C     BRA 0x31BC
0031B6  90002E     MOV [W14+4], W0
0031B8  E80000     INC W0, W0
0031BA  980720     MOV W0, [W14+4]
0031BC  9000AE     MOV [W14+4], W1
0031BE  90004E     MOV [W14+8], W0
0031C0  508F80     SUB W1, W0, [W15]
0031C2  39FFF0     BRA NC, 0x31A4
82:                        ckSum += *frame++;
0031A4  90003E     MOV [W14+6], W0
0031A6  784010     MOV.B [W0], W0
0031A8  FB8000     ZE W0, W0
0031AA  EB0080     CLR W1
0031AC  400F1E     ADD W0, [W14], [W14]
0031AE  48975E     ADDC W1, [++W14], [W14--]
0031B0  90003E     MOV [W14+6], W0
0031B2  E80000     INC W0, W0
0031B4  980730     MOV W0, [W14+6]
83:                
84:                    return (CheckSum == (ckSum - ((ckSum >> 8) << 8)));
0031C4  90482E     MOV.B [W14+10], W0
0031C6  FB8200     ZE W0, W4
0031C8  EB0280     CLR W5
0031CA  200FF0     MOV #0xFF, W0
0031CC  200001     MOV #0x0, W1
0031CE  BE011E     MOV.D [W14], W2
0031D0  780302     MOV W2, W6
0031D2  780103     MOV W3, W2
0031D4  780180     MOV W0, W3
0031D6  780001     MOV W1, W0
0031D8  630303     AND W6, W3, W6
0031DA  610000     AND W2, W0, W0
0031DC  EB0080     CLR W1
0031DE  DD00C0     SL W0, #0, W1
0031E0  200000     MOV #0x0, W0
0031E2  BE0100     MOV.D W0, W2
0031E4  B83061     MUL.UU W6, #1, W0
0031E6  710100     IOR W2, W0, W2
0031E8  718181     IOR W3, W1, W3
0031EA  6A0002     XOR W4, W2, W0
0031EC  6A8083     XOR W5, W3, W1
0031EE  708000     IOR W1, W0, W0
0031F0  A7F000     BTSC W0, #15
0031F2  EA0000     NEG W0, W0
0031F4  E90000     DEC W0, W0
0031F6  DE004F     LSR W0, #15, W0
0031F8  784000     MOV.B W0, W0
85:                }
0031FA  FA8000     ULNK
86:                
87:                
88:                
89:                //bool CheckSrting(uint8_t*dat1, uint8_t*dat2, const uint8_t num) {
90:                //    uint8_t cnt;
91:                //    for (cnt = 0; cnt < num; cnt++) {//判断EID
92:                //        if (*(dat1 + cnt) != *(dat2 + cnt)) {
93:                //            return false;
94:                //        }
95:                //    }
96:                //    return true;
97:                //}
98:                
99:                ///*************************************
100:               //Function: MD5encrypt  
101:               //Description: 
102:               //Input: 
103:               //Output:
104:               //*************************************/
105:               //void MD5encrypt(uint8_t* input,uint8_t *output)
106:               //{
107:               //    
108:               //}
109:               
110:               
111:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/User/CAT24C512.c  --------------------------------
1:                 #include "CAT24C512.h"
2:                 
3:                 uint16_t CAT_OperatID, CAT_StartID;
4:                 //CAT24Arg CAT24Argbits;
5:                 static void CAT24C512_ReadADD(void);
6:                 static void CAT24C512_WriteADD(uint8_t mode);
7:                 
8:                 void CAT24C512_Init(void) {
002CD6  FA0000     LNK #0x0
9:                     I2C_Init(); //初始化i2c,用于获取时钟和存储数据D
002CD8  070510     RCALL I2C_Init
10:                    TRISBbits.TRISB12 = 0; //WP引脚设置为输出    
002CDA  A982C9     BCLR 0x2C9, #4
11:                    //    CAT_WP = 0; //开启写保护
12:                    //    CAT24Argbits.ID = 0; //初始化结构体
13:                    //    CAT24Argbits.data = NULL;
14:                    //#
15:                    //        CAT_OperatID = 0xaaaa;
16:                    //        CAT_StartID = 0xFFFF;
17:                    //    CAT24C512_WriteADD(0); //刷新上次操作数据
18:                    CAT24C512_ReadADD();
002CDC  07007C     RCALL _CAT24C512_ReadADD
19:                }
002CDE  FA8000     ULNK
002CE0  060000     RETURN
20:                
21:                void CAT24C512_Read(uint16_t id, uint8_t *tmp) {//读取一组数据
002CE2  FA0006     LNK #0x6
002CE4  980710     MOV W0, [W14+2]
002CE6  980721     MOV W1, [W14+4]
22:                    uint8_t cnt; //调试cat24c512 地址0xA8写操作地址     
23:                    if (CAT_StartID == CAT_OperatID)//提示错误
002CE8  804231     MOV CAT_StartID, W1
002CEA  804220     MOV CAT_OperatID, W0
002CEC  508F80     SUB W1, W0, [W15]
002CEE  32003C     BRA Z, 0x2D68
24:                        return;
002D68  000000     NOP
25:                    CAT_WP = 0; //写保护
002CF0  A982CD     BCLR 0x2CD, #4
26:                    for (cnt = 0; cnt < BufferSize; cnt++) {
002CF2  EB4000     CLR.B W0
002CF4  784F00     MOV.B W0, [W14]
002CF6  370029     BRA 0x2D4A
002D48  E84F1E     INC.B [W14], [W14]
002D4A  78401E     MOV.B [W14], W0
002D4C  504FEB     SUB.B W0, #0xB, [W15]
002D4E  36FFD4     BRA LEU, 0x2CF8
27:                        i2c_buf.operatcode = CAT_ADD;
002CF8  209380     MOV #0x938, W0
002CFA  B3CA81     MOV.B #0xA8, W1
002CFC  784801     MOV.B W1, [W0]
28:                        i2c_buf.address = id * BufferSize + cnt;
002CFE  90001E     MOV [W14+2], W0
002D00  B9006C     MUL.SU W0, #12, W0
002D02  780080     MOV W0, W1
002D04  FB801E     ZE [W14], W0
002D06  408000     ADD W1, W0, W0
002D08  8849D0     MOV W0, 0x93A
29:                        i2c_buf.length = 1; //sizeof (tmp) / sizeof (uint8_t) - 1;
002D0A  2093C0     MOV #0x93C, W0
002D0C  B3C011     MOV.B #0x1, W1
002D0E  784801     MOV.B W1, [W0]
30:                        i2c_buf.pbuffer = tmp + cnt;
002D10  FB801E     ZE [W14], W0
002D12  9000AE     MOV [W14+4], W1
002D14  408000     ADD W1, W0, W0
002D16  8849F0     MOV W0, 0x93E
31:                        i2c_buf.flag.F_IsSelectiveMode = 1;
002D18  804A00     MOV 0x940, W0
002D1A  A00000     BSET W0, #0
002D1C  884A00     MOV W0, 0x940
32:                        i2c_buf.flag.F_WriteOrRead = 1;
002D1E  804A00     MOV 0x940, W0
002D20  A02000     BSET W0, #2
002D22  884A00     MOV W0, 0x940
33:                        i2c_buf.flag.F_Is16bitsDevice = 1;
002D24  804A00     MOV 0x940, W0
002D26  A01000     BSET W0, #1
002D28  884A00     MOV W0, 0x940
34:                        i2c1_state = S_MASTER_IDLE;
002D2A  EF6848     CLR.B i2c1_state
35:                        Delay10ms(1); //延时等待数据通讯完成
002D2C  200010     MOV #0x1, W0
002D2E  07FA60     RCALL Delay10ms
36:                        IFS1bits.MI2C1IF = 1; //开始I2C
002D30  A82086     BSET IFS1, #1
37:                        //等待数据发送完成或是数据异常
38:                        //发送数据给上位机
39:                        while (i2c1_state != S_MASTER_Finish) //等待发送完成，避免重复发送数据
002D32  370005     BRA 0x2D3E
002D3E  BFC848     MOV.B i2c1_state, WREG
002D40  504FED     SUB.B W0, #0xD, [W15]
002D42  3AFFF8     BRA NZ, 0x2D34
40:                            if (i2c1_state == S_MASTER_Fail) {
002D34  BFC848     MOV.B i2c1_state, WREG
002D36  504FEE     SUB.B W0, #0xE, [W15]
002D38  3A0002     BRA NZ, 0x2D3E
41:                                CAT_WP = 1; //保护
002D3A  A882CD     BSET 0x2CD, #4
42:                                return; //提示错误信息
002D3C  370016     BRA 0x2D6A
43:                            }
44:                        Delay1ms(1);
002D44  200010     MOV #0x1, W0
002D46  07FA3C     RCALL Delay1ms
45:                    }
46:                    CAT_WP = 1; //保护
002D50  A882CD     BSET 0x2CD, #4
47:                    CAT_StartID += 1;
002D52  804230     MOV CAT_StartID, W0
002D54  E80000     INC W0, W0
002D56  884230     MOV W0, CAT_StartID
48:                    CAT_StartID = CAT_StartID % CAT_NUMS;
002D58  804231     MOV CAT_StartID, W1
002D5A  215550     MOV #0x1555, W0
002D5C  780100     MOV W0, W2
002D5E  090011     REPEAT #0x11
002D60  D88082     DIV.UW W1, W2
002D62  FD0080     EXCH W0, W1
002D64  884230     MOV W0, CAT_StartID
002D66  370001     BRA 0x2D6A
49:                }
002D6A  FA8000     ULNK
002D6C  060000     RETURN
50:                
51:                void CAT24C512_Write(uint8_t *tmp) {//页写 
002D6E  FA0002     LNK #0x2
002D70  780F00     MOV W0, [W14]
52:                    CAT_WP = 0; //写保护
002D72  A982CD     BCLR 0x2CD, #4
53:                    i2c_buf.operatcode = CAT_ADD;
002D74  209380     MOV #0x938, W0
002D76  B3CA81     MOV.B #0xA8, W1
002D78  784801     MOV.B W1, [W0]
54:                    i2c_buf.address = CAT_OperatID*BufferSize;
002D7A  804220     MOV CAT_OperatID, W0
002D7C  B9006C     MUL.SU W0, #12, W0
002D7E  780000     MOV W0, W0
002D80  8849D0     MOV W0, 0x93A
55:                    i2c_buf.length = BufferSize; //sizeof (tmp) / sizeof (uint8_t) - 1;
002D82  2093C0     MOV #0x93C, W0
002D84  B3C0C1     MOV.B #0xC, W1
002D86  784801     MOV.B W1, [W0]
56:                    i2c_buf.pbuffer = tmp;
002D88  78009E     MOV [W14], W1
002D8A  8849F1     MOV W1, 0x93E
57:                    i2c_buf.flag.F_IsSelectiveMode = 1;
002D8C  804A00     MOV 0x940, W0
002D8E  A00000     BSET W0, #0
002D90  884A00     MOV W0, 0x940
58:                    i2c_buf.flag.F_WriteOrRead = 0;
002D92  804A00     MOV 0x940, W0
002D94  A12000     BCLR W0, #2
002D96  884A00     MOV W0, 0x940
59:                    i2c_buf.flag.F_Is16bitsDevice = 1;
002D98  804A00     MOV 0x940, W0
002D9A  A01000     BSET W0, #1
002D9C  884A00     MOV W0, 0x940
60:                    i2c1_state = S_MASTER_IDLE;
002D9E  EF6848     CLR.B i2c1_state
61:                    IFS1bits.MI2C1IF = 1; //开始I2C通讯
002DA0  A82086     BSET IFS1, #1
62:                    //    I2C1CONbits.SEN =1;
63:                    Delay10ms(1); //延时等待数据通讯完成
002DA2  200010     MOV #0x1, W0
002DA4  07FA25     RCALL Delay10ms
64:                    while (i2c1_state != S_MASTER_Finish) //等待发送完成，避免重复发送数据
002DA6  370005     BRA 0x2DB2
002DB2  BFC848     MOV.B i2c1_state, WREG
002DB4  504FED     SUB.B W0, #0xD, [W15]
002DB6  3AFFF8     BRA NZ, 0x2DA8
65:                        if (i2c1_state == S_MASTER_Fail) {
002DA8  BFC848     MOV.B i2c1_state, WREG
002DAA  504FEE     SUB.B W0, #0xE, [W15]
002DAC  3A0002     BRA NZ, 0x2DB2
66:                            CAT_WP = 1; //保护
002DAE  A882CD     BSET 0x2CD, #4
67:                            return; //提示错误信息
002DB0  370010     BRA 0x2DD2
68:                        }
69:                    //等待数据发送完成或是数据异常
70:                    Delay10ms(1);
002DB8  200010     MOV #0x1, W0
002DBA  07FA1A     RCALL Delay10ms
71:                    CAT_WP = 1; //保护
002DBC  A882CD     BSET 0x2CD, #4
72:                    CAT_OperatID += 1;
002DBE  804220     MOV CAT_OperatID, W0
002DC0  E80000     INC W0, W0
002DC2  884220     MOV W0, CAT_OperatID
73:                    CAT_OperatID = CAT_OperatID % CAT_NUMS; //需要添加防止溢出的处理
002DC4  804221     MOV CAT_OperatID, W1
002DC6  215550     MOV #0x1555, W0
002DC8  780100     MOV W0, W2
002DCA  090011     REPEAT #0x11
002DCC  D88082     DIV.UW W1, W2
002DCE  FD0080     EXCH W0, W1
002DD0  884220     MOV W0, CAT_OperatID
74:                }
002DD2  FA8000     ULNK
002DD4  060000     RETURN
75:                
76:                static void CAT24C512_ReadADD(void) {
002DD6  FA0006     LNK #0x6
77:                    uint8_t tmp[4] = {0, 0};
002DD8  B80060     MUL.UU W0, #0, W0
002DDA  980710     MOV W0, [W14+2]
002DDC  980721     MOV W1, [W14+4]
78:                    uint8_t cnt = 0, cnt1 = 0;
002DDE  EB4000     CLR.B W0
002DE0  784F00     MOV.B W0, [W14]
002DE2  EB4000     CLR.B W0
002DE4  984710     MOV.B W0, [W14+1]
79:                
80:                    CAT_WP = 0; //写保护
002DE6  A982CD     BCLR 0x2CD, #4
81:                    for (cnt = 0; cnt < 4; cnt++) {//选择读取        
002DE8  EB4000     CLR.B W0
002DEA  784F00     MOV.B W0, [W14]
002DEC  370029     BRA 0x2E40
002E3E  E84F1E     INC.B [W14], [W14]
002E40  78401E     MOV.B [W14], W0
002E42  504FE3     SUB.B W0, #0x3, [W15]
002E44  36FFD4     BRA LEU, 0x2DEE
82:                
83:                        i2c_buf.operatcode = CAT_ADD;
002DEE  209380     MOV #0x938, W0
002DF0  B3CA81     MOV.B #0xA8, W1
002DF2  784801     MOV.B W1, [W0]
84:                        i2c_buf.address = CAT_NOW_ADD + cnt;
002DF4  FB801E     ZE [W14], W0
002DF6  500064     SUB W0, #0x4, W0
002DF8  8849D0     MOV W0, 0x93A
85:                        i2c_buf.length = 1; //sizeof (tmp) / sizeof (uint8_t) - 1;
002DFA  2093C0     MOV #0x93C, W0
002DFC  B3C011     MOV.B #0x1, W1
002DFE  784801     MOV.B W1, [W0]
86:                        i2c_buf.pbuffer = tmp + cnt;
002E00  FB801E     ZE [W14], W0
002E02  E8808E     INC2 W14, W1
002E04  408000     ADD W1, W0, W0
002E06  8849F0     MOV W0, 0x93E
87:                        i2c_buf.flag.F_IsSelectiveMode = 1;
002E08  804A00     MOV 0x940, W0
002E0A  A00000     BSET W0, #0
002E0C  884A00     MOV W0, 0x940
88:                        i2c_buf.flag.F_WriteOrRead = 1;
002E0E  804A00     MOV 0x940, W0
002E10  A02000     BSET W0, #2
002E12  884A00     MOV W0, 0x940
89:                        i2c_buf.flag.F_Is16bitsDevice = 1;
002E14  804A00     MOV 0x940, W0
002E16  A01000     BSET W0, #1
002E18  884A00     MOV W0, 0x940
90:                        i2c1_state = S_MASTER_IDLE;
002E1A  EF6848     CLR.B i2c1_state
91:                        Delay10ms(1); //延时等待数据通讯完成
002E1C  200010     MOV #0x1, W0
002E1E  07F9E8     RCALL Delay10ms
92:                        IFS1bits.MI2C1IF = 1; //开始I2C通讯
002E20  A82086     BSET IFS1, #1
93:                        while (i2c1_state != S_MASTER_Finish) {//等待发送完成，避免重复发送数据
002E22  BFC848     MOV.B i2c1_state, WREG
002E24  504FED     SUB.B W0, #0xD, [W15]
002E26  320009     BRA Z, 0x2E3A
94:                            if (i2c1_state == S_MASTER_Fail) {
002E28  BFC848     MOV.B i2c1_state, WREG
002E2A  504FEE     SUB.B W0, #0xE, [W15]
002E2C  3A0002     BRA NZ, 0x2E32
95:                                CAT_WP = 1; //保护
002E2E  A882CD     BSET 0x2CD, #4
96:                                return; //提示错误信息
002E30  370019     BRA 0x2E64
97:                            }
98:                            Delay10ms(1); //延时等待数据通讯完成
002E32  200010     MOV #0x1, W0
002E34  07F9DD     RCALL Delay10ms
99:                            CAT_WP = 1; //保护
002E36  A882CD     BSET 0x2CD, #4
100:                           return;
002E38  370015     BRA 0x2E64
101:                       }
102:                       //        i2c1_state = S_MASTER_IDLE;
103:                       //等待数据发送完成或是数据异常        
104:                       Delay1ms(1);
002E3A  200010     MOV #0x1, W0
002E3C  07F9C1     RCALL Delay1ms
105:                   }
106:                   CAT_WP = 1; //保护
002E46  A882CD     BSET 0x2CD, #4
107:                   CAT_StartID = ((uint16_t) tmp[0] << 8) + tmp[1]; //刷新ID地址  
002E48  90402E     MOV.B [W14+2], W0
002E4A  FB8000     ZE W0, W0
002E4C  DD00C8     SL W0, #8, W1
002E4E  90403E     MOV.B [W14+3], W0
002E50  FB8000     ZE W0, W0
002E52  408000     ADD W1, W0, W0
002E54  884230     MOV W0, CAT_StartID
108:                   CAT_OperatID = ((uint16_t) tmp[2] << 8) + tmp[3]; //刷新ID地址  
002E56  90404E     MOV.B [W14+4], W0
002E58  FB8000     ZE W0, W0
002E5A  DD00C8     SL W0, #8, W1
002E5C  90405E     MOV.B [W14+5], W0
002E5E  FB8000     ZE W0, W0
002E60  408000     ADD W1, W0, W0
002E62  884220     MOV W0, CAT_OperatID
109:               }
002E64  FA8000     ULNK
002E66  060000     RETURN
110:               
111:               static void CAT24C512_WriteADD(uint8_t mode) {
002E68  FA0006     LNK #0x6
002E6A  984740     MOV.B W0, [W14+4]
112:                   uint8_t tmp[4] = {0, 0};
002E6C  B80060     MUL.UU W0, #0, W0
002E6E  BE8F00     MOV.D W0, [W14]
113:                   //    CAT_StartID = ((uint16_t) tmp[2] << 8) + tmp[3]; //刷新ID地址 
114:                   tmp[0] = (CAT_StartID >> 8)& 0x00ff; //刷新ID地址  
002E70  804230     MOV CAT_StartID, W0
002E72  DE0048     LSR W0, #8, W0
002E74  784000     MOV.B W0, W0
002E76  784F00     MOV.B W0, [W14]
115:                   tmp[1] = CAT_StartID & 0x00ff;
002E78  804230     MOV CAT_StartID, W0
002E7A  784000     MOV.B W0, W0
002E7C  984710     MOV.B W0, [W14+1]
116:                   tmp[2] = (CAT_OperatID >> 8)& 0x00ff; //刷新ID地址  
002E7E  804220     MOV CAT_OperatID, W0
002E80  DE0048     LSR W0, #8, W0
002E82  784000     MOV.B W0, W0
002E84  984720     MOV.B W0, [W14+2]
117:                   tmp[3] = CAT_OperatID & 0x00ff;
002E86  804220     MOV CAT_OperatID, W0
002E88  784000     MOV.B W0, W0
002E8A  984730     MOV.B W0, [W14+3]
118:               
119:                   CAT_WP = 0; //写保护
002E8C  A982CD     BCLR 0x2CD, #4
120:                   i2c_buf.operatcode = CAT_ADD;
002E8E  209380     MOV #0x938, W0
002E90  B3CA81     MOV.B #0xA8, W1
002E92  784801     MOV.B W1, [W0]
121:                   if (mode == CAT_START_READ) {//表示开始读取地址写到EEROM中
002E94  90404E     MOV.B [W14+4], W0
002E96  504FE2     SUB.B W0, #0x2, [W15]
002E98  3A0007     BRA NZ, 0x2EA8
122:                       i2c_buf.address = CAT_NOW_ADD;
002E9A  2FFFC0     MOV #0xFFFC, W0
002E9C  8849D0     MOV W0, 0x93A
123:                       i2c_buf.length = 2; //
002E9E  2093C0     MOV #0x93C, W0
002EA0  B3C021     MOV.B #0x2, W1
002EA2  784801     MOV.B W1, [W0]
124:                       i2c_buf.pbuffer = tmp;
002EA4  8849FE     MOV W14, 0x93E
002EA6  370011     BRA 0x2ECA
125:                   } else if (mode == CAT_START_WRITE) {//表示数据写入地址写到EEROM中
002EA8  90404E     MOV.B [W14+4], W0
002EAA  504FE3     SUB.B W0, #0x3, [W15]
002EAC  3A0008     BRA NZ, 0x2EBE
126:                       i2c_buf.address = CAT_NOW_ADD + 2;
002EAE  2FFFE0     MOV #0xFFFE, W0
002EB0  8849D0     MOV W0, 0x93A
127:                       i2c_buf.length = 2; //        
002EB2  2093C0     MOV #0x93C, W0
002EB4  B3C021     MOV.B #0x2, W1
002EB6  784801     MOV.B W1, [W0]
128:                       i2c_buf.pbuffer = tmp + 2;
002EB8  E8800E     INC2 W14, W0
002EBA  8849F0     MOV W0, 0x93E
002EBC  370006     BRA 0x2ECA
129:                   } else {
130:                       i2c_buf.address = CAT_NOW_ADD; //更新全部
002EBE  2FFFC0     MOV #0xFFFC, W0
002EC0  8849D0     MOV W0, 0x93A
131:                       i2c_buf.length = 4; //        
002EC2  2093C0     MOV #0x93C, W0
002EC4  B3C041     MOV.B #0x4, W1
002EC6  784801     MOV.B W1, [W0]
132:                       i2c_buf.pbuffer = tmp;
002EC8  8849FE     MOV W14, 0x93E
133:                   }
134:                   i2c_buf.flag.F_IsSelectiveMode = 1;
002ECA  804A00     MOV 0x940, W0
002ECC  A00000     BSET W0, #0
002ECE  884A00     MOV W0, 0x940
135:                   i2c_buf.flag.F_WriteOrRead = 0;
002ED0  804A00     MOV 0x940, W0
002ED2  A12000     BCLR W0, #2
002ED4  884A00     MOV W0, 0x940
136:                   i2c_buf.flag.F_Is16bitsDevice = 1;
002ED6  804A00     MOV 0x940, W0
002ED8  A01000     BSET W0, #1
002EDA  884A00     MOV W0, 0x940
137:                   i2c1_state = S_MASTER_IDLE;
002EDC  EF6848     CLR.B i2c1_state
138:                   //    while (IFS1bits.MI2C1IF);
139:                   IFS1bits.MI2C1IF = 1; //开始I2C通讯
002EDE  A82086     BSET IFS1, #1
140:                   while (i2c1_state != S_MASTER_SEND_STOP) //等待发送完成，避免重复发送数据
002EE0  370005     BRA 0x2EEC
002EEC  BFC848     MOV.B i2c1_state, WREG
002EEE  504FE6     SUB.B W0, #0x6, [W15]
002EF0  3AFFF8     BRA NZ, 0x2EE2
141:                       if (i2c1_state == S_MASTER_Fail) {
002EE2  BFC848     MOV.B i2c1_state, WREG
002EE4  504FEE     SUB.B W0, #0xE, [W15]
002EE6  3A0002     BRA NZ, 0x2EEC
142:                           CAT_WP = 1; //保护
002EE8  A882CD     BSET 0x2CD, #4
143:                           return; //提示错误信息
002EEA  370006     BRA 0x2EF8
144:                       }
145:                   //等待数据发送完成或是数据异常
146:                   Delay1ms(1);
002EF2  200010     MOV #0x1, W0
002EF4  07F965     RCALL Delay1ms
147:                   CAT_WP = 1; //保护
002EF6  A882CD     BSET 0x2CD, #4
148:               }
002EF8  FA8000     ULNK
149:               
150:               //void Get
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/bsp.c  ---------------------------------------
1:                 /*
2:                  *********************************************************************************************************
3:                  *                                             Microchip dsPIC33FJ
4:                  *                                            Board Support Package
5:                  *
6:                  *                                                   Micrium
7:                  *                                    (c) Copyright 2005, Micrium, Weston, FL
8:                  *                                              All Rights Reserved
9:                  *
10:                 *
11:                 * File : BSP.C
12:                 * By   : Eric Shufro
13:                 *********************************************************************************************************
14:                 */
15:                
16:                #include <includes.h>
17:                //#include "HL6528.h"
18:                //#include "E41.h"
19:                //#include "xc.h"
20:                
21:                void OSCILLATOR_Initialize(void) {
0034A6  FA0000     LNK #0x0
22:                    // DOZEN disabled; DOZE 1:8; RCDIV FRC/1; ROI disabled; 
23:                    CLKDIV = 0x3000;
0034A8  230000     MOV #0x3000, W0
0034AA  883A20     MOV W0, CLKDIV
24:                
25:                    // Set the secondary oscillator    
26:                    OSCCONbits.SOSCEN = 1; //开启辅助振荡器
0034AC  A82742     BSET OSCCON, #1
27:                    __builtin_write_OSCCONL(0x02);
0034AE  200022     MOV #0x2, W2
0034B0  200460     MOV #0x46, W0
0034B2  200571     MOV #0x57, W1
0034B4  207423     MOV #0x742, W3
0034B6  784980     MOV.B W0, [W3]
0034B8  784981     MOV.B W1, [W3]
0034BA  784982     MOV.B W2, [W3]
28:                    //    OSCCONbits.OSWEN = 1;
29:                    //    OSC_Unlock_Sequence(); //切换时钟
30:                }
0034BC  FA8000     ULNK
0034BE  060000     RETURN
31:                
32:                /*
33:                 *********************************************************************************************************
34:                 *                                         BSP INITIALIZATION
35:                 *
36:                 * Description : This function should be called by your application code before you make use of any of the
37:                 *               functions found in this module.
38:                 *
39:                 * Arguments   : none
40:                 *********************************************************************************************************
41:                 */
42:                
43:                void BSP_Init(void) {
0034C0  FA0000     LNK #0x0
44:                    //    RCON &= ~SWDTEN; /* Ensure Watchdog disabled via IDE CONFIG bits and SW.     */
45:                    //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
46:                    //    BSP_PLL_Init(); /* Initialize the PLL                                       */
47:                    //#endif
48:                    OSCILLATOR_Initialize(); //初始化时钟
0034C2  07FFF1     RCALL OSCILLATOR_Initialize
49:                    LED_Init(); //初始化LED
0034C4  07000D     RCALL LED_Init
50:                    WGC_Init(); //初始化WGC参数
0034C6  07EE1A     RCALL WGC_Init
51:                    RTC_Init(); //初始化实时时钟
0034C8  07F784     RCALL RTC_Init
52:                    PPSInit(); //选择设备
0034CA  070042     RCALL PPSInit
53:                    UART2_Init(); //初始化串口2，用于GPRS通讯hl6528
0034CC  07FE98     RCALL UART2_Init
54:                    UART3_Init(); //初始化串口3，用于短程无线通讯433
0034CE  07FF7C     RCALL UART3_Init
55:                    RS485_Init(); //初始化串口1，用于485通讯上位机通讯
0034D0  07FF0A     RCALL RS485_Init
56:                    //    INT0_Init(); //外部中断初始化
57:                    //    E41_Init(); //初始化短程无线
58:                    HL6528_Init(); /*Initialize the HL6528*/
0034D2  07FA90     RCALL HL6528_Init
59:                    ////#ifdef CLOSE_6528
60:                    //        HL6528_Close();//注意：开启 容易导致初始化失败
61:                    UART2_Close();
0034D4  07FEB1     RCALL UART2_Close
62:                    ////#endif
63:                    CAT24C512_Init(); //应用程序初始化
0034D6  07FBFF     RCALL CAT24C512_Init
64:                    // no use   //    PCF8583_Init();//初始化PCF8583
65:                    //    //        Close6528Cop(); /*Close UART2 */
66:                    LCD_Init();
0034D8  07F1F6     RCALL LCD_Init
67:                    TMR1_Initialize();
0034DA  0700AE     RCALL TMR1_Initialize
68:                    //    TMR2_Initialize();
69:                }
0034DC  FA8000     ULNK
0034DE  060000     RETURN
70:                
71:                /*
72:                 *********************************************************************************************************
73:                 *                                      BSP_PLL_Init()
74:                 *
75:                 * Description : This function configures and enables the PLL with the external oscillator
76:                 *               selected as the input clock to the PLL.
77:                 *
78:                 * Notes       : 1) The PLL output frequency is calculated by FIN * (M / (N1 * N2)).
79:                 *               2) FIN is the PLL input clock frequency, defined in bsp.h as
80:                 *                  CPU_PRIMARY_OSC_FR. This is the same as the external primary
81:                 *                  oscillator on the Explorer 16 Evaluation Board.
82:                 *               3) M is the desired PLL multiplier
83:                 *               4) N1 is the divider for FIN before FIN enters the PLL block (Pre-Divider)
84:                 *               5) N2 is the PLL output divider (Post-Divider)
85:                 *
86:                 * Summary     :    The PLL is configured as (8MHZ) * (40 / (2 * 2)) = 80MHZ
87:                 *                  The processor clock is (1/2) of the PLL output.
88:                 *                  Performance = 40 MIPS.
89:                 *********************************************************************************************************
90:                 */
91:                //#if defined (__dsPIC33F__) || defined(__dsPIC33E__)
92:                //
93:                //static void BSP_PLL_Init(void) {
94:                //    PLLFBD = 38; /* Set the Multiplier (M) to 40 (2 added automatically) 	*/
95:                //    CLKDIV = 0; /* Clear the PLL Pre Divider bits, N1 = N2 = 2              */
96:                //}
97:                //#endif
98:                
99:                /*
100:                *********************************************************************************************************
101:                *                                      BSP_CPU_ClkFrq()
102:               
103:                * Description : This function determines the CPU clock frequency (Fcy)
104:                * Returns     : The CPU frequency in (HZ)
105:                *********************************************************************************************************
106:                */
107:               
108:               //CPU_INT32U BSP_CPU_ClkFrq(void) {
109:               //    CPU_INT08U Clk_Selected;
110:               //    CPU_INT16U FRC_Div;
111:               //    CPU_INT32U CPU_Clk_Frq;
112:               //
113:               //
114:               //#if defined (__dsPIC33E__) || defined (__dsPIC33F__)
115:               //    CPU_INT08U PLL_n1;
116:               //    CPU_INT08U PLL_n2;
117:               //    CPU_INT16U PLL_m;
118:               //    PLL_m = (PLLFBD & PLLDIV_MASK) + 2; /* Get the Multiplier value                                 */
119:               //    PLL_n1 = (CLKDIV & PLLPRE_MASK) + 2; /* Computer the Pre Divider value                           */
120:               //    PLL_n2 = ((CLKDIV & PLLPOST_MASK) >> 6); /* Get the Post Divider register value                      */
121:               //    PLL_n2 = ((PLL_n2 * 2) + 2); /* Compute the Post Divider value */
122:               //#endif
123:               //
124:               //    FRC_Div = ((CLKDIV & FRCDIV_MASK) >> 8); /* Get the FRC Oscillator Divider register value            */
125:               //    FRC_Div = ((1 << FRC_Div) * 2); /* Compute the FRC Divider value                            */
126:               //
127:               //    Clk_Selected = (OSCCON & COSC_MASK) >> 12; /* Determine which clock source is currently selected       */
128:               //
129:               //    switch (Clk_Selected) {
130:               //        case 0: /* Fast Oscillator (FRC) Selected                           */
131:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ; /* Return the frequency of the internal fast oscillator     */
132:               //            break;
133:               //
134:               //        case 1:
135:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
136:               //            CPU_Clk_Frq = ((CPU_FRC_OSC_FRQ * PLL_m) / /* Compute the PLL output frequency using the FRC as FIN    */
137:               //                    (FRC_Div * PLL_n1 * PLL_n2));
138:               //#else
139:               //            /* Fast Oscillator (FRC) with PLL Selected                  */
140:               //            CPU_Clk_Frq = (CPU_FRC_OSC_FRQ * 4); /* Compute the PLL output frequency  = (FRC * 4)            */
141:               //#endif
142:               //            break;
143:               //
144:               //        case 2: /* Primary External Oscillator Selected                     */
145:               //            CPU_Clk_Frq = CPU_PRIMARY_OSC_FRQ; /* Return the frequency of the primary external oscillator  */
146:               //            break;
147:               //
148:               //        case 3:
149:               //#if defined (__dsPIC33E__) || defined(__dsPIC33F__)
150:               //            CPU_Clk_Frq = ((CPU_PRIMARY_OSC_FRQ * PLL_m) / /* Compute the PLL output frq using the PRI EXT OSC as FIN  */
151:               //                    (PLL_n1 * PLL_n2));
152:               //#else
153:               //            /* Primary External Oscillator with PLL Selected            */
154:               //            CPU_Clk_Frq = (CPU_PRIMARY_OSC_FRQ * 4); /* Compute the PLL output frq as (CPU_PRIMARY_OSC_FRQ * 4)  */
155:               //#endif
156:               //            break;
157:               //
158:               //        case 4: /* Secondary Oscillator Selected (SOCS)                     */
159:               //            CPU_Clk_Frq = CPU_SECONDARY_OSC_FRQ; /* Return the frq of the external secondary oscillator      */
160:               //            break;
161:               //
162:               //        case 5: /* Low Power Oscillator (LPOSC) Selected                    */
163:               //            CPU_Clk_Frq = CPU_LOW_POWER_OSC_FRQ; /* Return the frq of the Low Power Oscillator               */
164:               //            break;
165:               //
166:               //        case 6:
167:               //            CPU_Clk_Frq = 0; /* Return 0 for the Reserved clock setting                  */
168:               //            break;
169:               //
170:               //        case 7: /* Fast Oscillator (FRC) with FRCDIV Selected               */
171:               //            CPU_Clk_Frq = CPU_FRC_OSC_FRQ / FRC_Div; /* Return the clock frequency of FRC / FRC_Div              */
172:               //            break;
173:               //
174:               //        default:
175:               //            CPU_Clk_Frq = 0; /* Return 0 if the clock source cannot be determined        */
176:               //            break;
177:               //    }
178:               //
179:               //    CPU_Clk_Frq /= 2; /* Divide the final frq by 2, get the actual CPU Frq (Fcy)  */
180:               //
181:               //    return (CPU_Clk_Frq); /* Return the operating frequency                           */
182:               //}
183:               
184:               /*
185:                *********************************************************************************************************
186:                *                                     DISABLE ALL INTERRUPTS
187:                *
188:                * Description : This function disables all interrupts from the interrupt controller.
189:                *
190:                * Arguments   : none
191:                *********************************************************************************************************
192:                */
193:               
194:               //void BSP_IntDisAll(void) {
195:               //}
196:               
197:               /*
198:                *********************************************************************************************************
199:                *                                         LED I/O INITIALIZATION
200:                *
201:                * Description : This function initializes the I/O Pins used by the onboard LEDs
202:                *
203:                * Arguments   : none
204:                *
205:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
206:                *               2) JTAG must be DISABLED in order to utilize all of PORTA I/O Lines for LEDs
207:                *********************************************************************************************************
208:                */
209:               
210:               void LED_Init(void) {
0034E0  FA0000     LNK #0x0
211:                   TRISBbits.TRISB13 = 0;
0034E2  A9A2C9     BCLR 0x2C9, #5
212:               
213:                   LED_Off(); /* Shut off all LEDs                                        */
0034E4  070006     RCALL LED_Off
214:               }
0034E6  FA8000     ULNK
0034E8  060000     RETURN
215:               
216:               /*
217:                *********************************************************************************************************
218:                *                                             LED ON
219:                *
220:                * Description : This function is used to control any or all the LEDs on the board.
221:                *
222:                * Arguments   : led    is the number of the LED to control
223:                *                      0    indicates that you want ALL the LEDs to be ON
224:                *                      1    turns ON LED1
225:                *                      2    turns ON LED2
226:                *                      ...
227:                *                      8    turns ON LED8
228:                *
229:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
230:                *********************************************************************************************************
231:                */
232:               
233:               void LED_On(void) {
0034EA  FA0000     LNK #0x0
234:                   PORTBbits.RB13 = 1;
0034EC  A8A2CB     BSET 0x2CB, #5
235:               }
0034EE  FA8000     ULNK
0034F0  060000     RETURN
236:               
237:               /*
238:                *********************************************************************************************************
239:                *                                             LED OFF
240:                *
241:                * Description : This function is used to control any or all the LEDs on the board.
242:                *
243:                * Arguments   : led    is the number of the LED to turn OFF
244:                *                      0    indicates that you want ALL the LEDs to be OFF
245:                *                      1    turns OFF LED1
246:                *                      2    turns OFF LED2
247:                *                      .
248:                *                      8    turns OFF LED8
249:                *
250:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
251:                *********************************************************************************************************
252:                */
253:               
254:               void LED_Off(void) {
0034F2  FA0000     LNK #0x0
255:                   LATBbits.LATB13 = 0;
0034F4  A9A2CD     BCLR 0x2CD, #5
256:               }
0034F6  FA8000     ULNK
0034F8  060000     RETURN
257:               
258:               /*
259:                *********************************************************************************************************
260:                *                                             LED TOGGLE
261:                *
262:                * Description : This function is used to toggle any or all the LEDs on the board.
263:                *
264:                * Arguments   : led    is the number of the LED to control
265:                *                      0    indicates that you want to toggle ALL the LEDs
266:                *                      1    toggles LED1
267:                *                      2    toggles LED2
268:                *                      .
269:                *                      8    toggles LED8
270:                *
271:                * Notes       : 1) Jumper JP2 on the Explorer 16 board must be connected to enable the onboard LEDs
272:                *********************************************************************************************************
273:                */
274:               
275:               void LED_Toggle(void) {
0034FA  FA0000     LNK #0x0
276:                   LATBbits.LATB13 ^= 1;
0034FC  801660     MOV LATB, W0
0034FE  DE004D     LSR W0, #13, W0
003500  604061     AND.B W0, #0x1, W0
003502  A20400     BTG.B W0, #0
003504  604061     AND.B W0, #0x1, W0
003506  FB8000     ZE W0, W0
003508  600061     AND W0, #0x1, W0
00350A  DD004D     SL W0, #13, W0
00350C  801661     MOV LATB, W1
00350E  A1D001     BCLR W1, #13
003510  700001     IOR W0, W1, W0
003512  881660     MOV W0, LATB
277:               }
003514  FA8000     ULNK
003516  060000     RETURN
278:               
279:               void LED_Toggle1(uint8_t time, uint8_t count) {
003518  FA0004     LNK #0x4
00351A  984720     MOV.B W0, [W14+2]
00351C  984731     MOV.B W1, [W14+3]
280:                   int8_t cnt;
281:                   for (cnt = 0; cnt < count; cnt++) {
00351E  EB4000     CLR.B W0
003520  784F00     MOV.B W0, [W14]
003522  37000F     BRA 0x3542
003540  E84F1E     INC.B [W14], [W14]
003542  FB009E     SE [W14], W1
003544  90403E     MOV.B [W14+3], W0
003546  FB8000     ZE W0, W0
003548  508F80     SUB W1, W0, [W15]
00354A  35FFEC     BRA LT, 0x3524
282:                       LATBbits.LATB13 ^= 1;
003524  801660     MOV LATB, W0
003526  DE004D     LSR W0, #13, W0
003528  604061     AND.B W0, #0x1, W0
00352A  A20400     BTG.B W0, #0
00352C  604061     AND.B W0, #0x1, W0
00352E  FB8000     ZE W0, W0
003530  600061     AND W0, #0x1, W0
003532  DD004D     SL W0, #13, W0
003534  801661     MOV LATB, W1
003536  A1D001     BCLR W1, #13
003538  700001     IOR W0, W1, W0
00353A  881660     MOV W0, LATB
283:                       Delay100ms(time);
00353C  90402E     MOV.B [W14+2], W0
00353E  07F670     RCALL Delay100ms
284:                   }
285:               }
00354C  FA8000     ULNK
286:               /*
287:                *********************************************************************************************************
288:                *                                   OSProbe_TmrInit()
289:                *
290:                * Description : This function is called to by uC/Probe Plug-In for uC/OS-II to initialize the
291:                *               free running timer that is used to make time measurements.
292:                *
293:                * Arguments   : none
294:                *
295:                * Returns     : none
296:                *
297:                * Note(s)     : 1) This timer is shared with the uC/OS-II time tick and is initialized
298:                *                  from Tmr_TickInit().
299:                *********************************************************************************************************
300:                */
301:               
302:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
303:               
304:               //void OSProbe_TmrInit(void) {
305:               //#if OS_PROBE_TIMER_SEL == 3
306:               //    T3CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
307:               //    TMR3 = 0; /* Start counting from 0 and clear the prescaler count      */
308:               //    PR3 = 0xFFFF; /* Set the period register to its maximum value             */
309:               //    T3CON |= TON; /* Start the timer                                          */
310:               //#endif
311:               //
312:               //#if OS_PROBE_TIMER_SEL == 5
313:               //    T5CON = 0; /* Use Internal Osc (Fosc / 4), 16 bit mode, prescaler = 1  */
314:               //    TMR5 = 0; /* Start counting from 0 and clear the prescaler count      */
315:               //    PR5 = 0xFFFF; /* Set the period register to its maximum value             */
316:               //    T5CON |= TON; /* Start the timer                                          */
317:               //#endif
318:               //}
319:               //#endif
320:               
321:               /*
322:                *********************************************************************************************************
323:                *                                   OSProbe_TmrRd()
324:                *
325:                * Description : This function is called to read the current counts of a 16 bit free running timer.
326:                *
327:                * Arguments   : none
328:                *
329:                * Returns     ; The 16 bit count (in a 32 bit variable) of the timer assuming the timer is an UP counter.
330:                *********************************************************************************************************
331:                */
332:               
333:               //#if (uC_PROBE_OS_PLUGIN > 0) && (OS_PROBE_HOOKS_EN == 1)
334:               
335:               //CPU_INT32U OSProbe_TmrRd(void) {
336:               //#if OS_PROBE_TIMER_SEL == 3
337:               //    return ((CPU_INT32U) TMR3); /* Return the value of timer 3 if selected                  */
338:               //#endif
339:               //
340:               //#if OS_PROBE_TIMER_SEL == 5
341:               //    return ((CPU_INT32U) TMR5); /* Return the value of timer 5 if selected                  */
342:               //#endif
343:               //}
344:               //#endif
345:               
346:               /*
347:                *********************************************************************************************************
348:                *                                       TICKER INITIALIZATION
349:                *
350:                * Description : This function is called to initialize uC/OS-II's tick source (typically a timer generating
351:                *               interrupts every 1 to 100 mS).
352:                *
353:                * Arguments   : none
354:                *
355:                * Note(s)     : 1) The timer operates at a frequency of Fosc / 4
356:                *               2) The timer resets to 0 after period register match interrupt is generated
357:                *********************************************************************************************************
358:                */
359:               
360:               //static void Tmr_TickInit(void) {
361:               //    CPU_INT32U tmr_frq;
362:               //    CPU_INT16U cnts;
363:               //
364:               //
365:               //    tmr_frq = BSP_CPU_ClkFrq(); /* Get the CPU Clock Frequency (Hz) (Fcy)                   */
366:               //    cnts = (tmr_frq / OS_TICKS_PER_SEC) - 1; /* Calaculate the number of timer ticks between interrupts  */
367:               //
368:               //#if BSP_OS_TMR_SEL == 2
369:               //    T2CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
370:               //    TMR2 = 0; /* Start counting from 0 and clear the prescaler count      */
371:               //    PR2 = cnts; /* Set the period register                                  */
372:               //    IPC1 &= ~T2IP_MASK; /* Clear all timer 2 interrupt priority bits                */
373:               //    IPC1 |= (TIMER_INT_PRIO << 12); /* Set timer 2 to operate with an interrupt priority of 4   */
374:               //    IFS0 &= ~T2IF; /* Clear the interrupt for timer 2                          */
375:               //    IEC0 |= T2IE; /* Enable interrupts for timer 2                            */
376:               //    T2CON |= TON; /* Start the timer                                          */
377:               //#endif
378:               //
379:               //#if BSP_OS_TMR_SEL == 4
380:               //    T4CON = 0; /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1  		*/
381:               //    TMR4 = 0; /* Start counting from 0 and clear the prescaler count      */
382:               //    PR4 = cnts; /* Set the period register                                  */
383:               //    IPC6 &= ~T4IP_MASK; /* Clear all timer 4 interrupt priority bits                */
384:               //    IPC6 |= (TIMER_INT_PRIO << 12); /* Set timer 4 to operate with an interrupt priority of 4   */
385:               //    IFS1 &= ~T4IF; /* Clear the interrupt for timer 4                          */
386:               //    IEC1 |= T4IE; /* Enable interrupts for timer 4                            */
387:               //    T4CON |= TON; /* Start the timer                                          */
388:               //#endif
389:               //}
390:               
391:               /*
392:                *********************************************************************************************************
393:                *                                     OS TICK INTERRUPT SERVICE ROUTINE
394:                *
395:                * Description : This function handles the timer interrupt that is used to generate TICKs for uC/OS-II.
396:                *********************************************************************************************************
397:                */
398:               
399:               //void OS_Tick_ISR_Handler(void) {
400:               //#if  BSP_OS_TMR_SEL == 2
401:               //    IFS0 &= ~T2IF;
402:               //#endif
403:               //
404:               //#if  BSP_OS_TMR_SEL == 4
405:               //    IFS1 &= ~T41F;
406:               //#endif
407:               //
408:               //    OSTimeTick();
409:               //}
410:               
411:               //void OSC_Unlock_Sequence(void) {
412:               //        //Place the new oscillator selection in W0
413:               //        //OSCCONH (high byte) Unlock Sequence
414:               //        asm("MOV #OSCCONH,w1");
415:               //        asm("MOV #0x78, w2");
416:               //        asm("MOV #0x9A, w3");
417:               //        asm("MOV.b w2, [w1]");
418:               //        asm("MOV.b w3, [w1]");
419:               //        //Set new oscillator selection
420:               //        asm("MOV.b WREG, OSCCONH");
421:               //        //OSCCONL (low byte) unlock sequence
422:               //        asm("MOV #OSCCONL,w1");
423:               //        asm("MOV.b #0x01, w0");
424:               //        asm("MOV #0x46, w2");
425:               //        asm("MOV #0x57, w3");
426:               //        asm("MOV.b w2, [w1]");
427:               //        asm("MOV.b w3, [w1]");
428:               //        //Start oscillator switch operation
429:               //        asm("MOV.b w0, [w1]");
430:               //    __builtin_write_OSCCONH(0x03);
431:               //    __builtin_write_OSCCONL(0x02);
432:               //    OSCCONbits.LOCK = 1;
433:               //    OSCCONbits.OSWEN = 1;
434:               //    OSCCONbits.LOCK = 0;
435:               //}
436:               //时钟初始化
437:               
438:               
439:               
440:               
441:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/UART3.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART3.h"
3:                 #include <xc.h>
4:                 
5:                 void UART3_Init(void) {
0033C8  FA0000     LNK #0x0
6:                     TRISGbits.TRISG8 = 1; //设置为输入
0033CA  A802F1     BSET 0x2F1, #0
7:                     TRISGbits.TRISG7 = 0; //设置为输出
0033CC  A9E2F0     BCLR TRISG, #7
8:                     ANSGbits.ANSG7 = 0; //已经为数字端口
0033CE  A9E4EC     BCLR ANSG, #7
9:                     ANSGbits.ANSG8 = 0;
0033D0  A904ED     BCLR 0x4ED, #0
10:                    ODCGbits.ODG8 = 1;//漏极开路输出
0033D2  A802F7     BSET 0x2F7, #0
11:                    //    TRISDbits.TRISD3 = 1; //设置为输入
12:                    //    TRISDbits.TRISD2 = 0; //设置为输出
13:                
14:                    U3MODEbits.BRGH = 0; //波特率使用标准模式1:16
0033D4  A96250     BCLR U3MODE, #3
15:                    U3BRG = 103; //19200 103; //16000000/9600/16-1
0033D6  200670     MOV #0x67, W0
0033D8  8812C0     MOV W0, U3BRG
16:                    U3MODEbits.PDSEL = 00; //无奇偶校验
0033DA  801281     MOV U3MODE, W1
0033DC  2FFF90     MOV #0xFFF9, W0
0033DE  608000     AND W1, W0, W0
0033E0  881280     MOV W0, U3MODE
17:                    U3MODEbits.STSEL = 0; //1位停止位
0033E2  A90250     BCLR U3MODE, #0
18:                
19:                    U3MODEbits.UARTEN = 1; //使能串口
0033E4  A8E251     BSET 0x251, #7
20:                
21:                    U3STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
0033E6  801291     MOV U3STA, W1
0033E8  200C00     MOV #0xC0, W0
0033EA  700001     IOR W0, W1, W0
0033EC  881290     MOV W0, U3STA
22:                    IFS5bits.U3RXIF = 0; //清除接收中断  
0033EE  A9408E     BCLR IFS5, #2
23:                    IPC20bits.U3RXIP = 6;
0033F0  800661     MOV IPC20, W1
0033F2  2F8FF0     MOV #0xF8FF, W0
0033F4  608080     AND W1, W0, W1
0033F6  206000     MOV #0x600, W0
0033F8  700001     IOR W0, W1, W0
0033FA  880660     MOV W0, IPC20
24:                    IEC5bits.U3RXIE = 1; //开启接受中断
0033FC  A8409E     BSET IEC5, #2
25:                    IFS5bits.U3ERIF = 0;
0033FE  A9208E     BCLR IFS5, #1
26:                    IPC20bits.U3ERIP = 7;
003400  800661     MOV IPC20, W1
003402  200700     MOV #0x70, W0
003404  700001     IOR W0, W1, W0
003406  880660     MOV W0, IPC20
27:                    IEC5bits.U3ERIE = 1;
003408  A8209E     BSET IEC5, #1
28:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
00340A  A84253     BSET 0x253, #2
29:                }
00340C  FA8000     ULNK
00340E  060000     RETURN
30:                
31:                void UART3_Open(void) {
003410  FA0000     LNK #0x0
32:                    U3MODEbits.UARTEN = 1; //使能串口
003412  A8E251     BSET 0x251, #7
33:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003414  A84253     BSET 0x253, #2
34:                    // IEC1bits.U3TXIE=1;
35:                    IEC5bits.U3RXIE = 1;
003416  A8409E     BSET IEC5, #2
36:                }
003418  FA8000     ULNK
00341A  060000     RETURN
37:                
38:                void UART3_Close(void) {
00341C  FA0000     LNK #0x0
39:                    // IEC1bits.U3TXIE=0;
40:                    IEC5bits.U3RXIE = 0;
00341E  A9409E     BCLR IEC5, #2
41:                    U3STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003420  A84253     BSET 0x253, #2
42:                    U3MODEbits.UARTEN = 0; //使能串口发送    
003422  A9E251     BCLR 0x251, #7
43:                }
003424  FA8000     ULNK
003426  060000     RETURN
44:                
45:                void UART3_SendChar(uint8_t ch) {
003428  FA0002     LNK #0x2
00342A  784F00     MOV.B W0, [W14]
46:                    U3TXREG = ch;
00342C  FB801E     ZE [W14], W0
00342E  8812A0     MOV W0, U3TXREG
47:                    while (!U3STAbits.TRMT);
003430  000000     NOP
003432  801291     MOV U3STA, W1
003434  201000     MOV #0x100, W0
003436  608000     AND W1, W0, W0
003438  E00000     CP0 W0
00343A  32FFFB     BRA Z, 0x3432
48:                }
00343C  FA8000     ULNK
00343E  060000     RETURN
49:                
50:                uint8_t UART3_SendString(const uint8_t *str, const uint8_t len) {
003440  FA0006     LNK #0x6
003442  980710     MOV W0, [W14+2]
003444  984741     MOV.B W1, [W14+4]
51:                    uint8_t bytes = 0;
003446  EB4000     CLR.B W0
003448  784F00     MOV.B W0, [W14]
52:                    for (bytes = 0; bytes < len; bytes++) {//(bytes++ < len) {
00344A  EB4000     CLR.B W0
00344C  784F00     MOV.B W0, [W14]
00344E  370006     BRA 0x345C
00345A  E84F1E     INC.B [W14], [W14]
00345C  90404E     MOV.B [W14+4], W0
00345E  78409E     MOV.B [W14], W1
003460  50CF80     SUB.B W1, W0, [W15]
003462  39FFF6     BRA NC, 0x3450
53:                        UART3_SendChar(*(str + bytes));
003450  FB801E     ZE [W14], W0
003452  90009E     MOV [W14+2], W1
003454  408000     ADD W1, W0, W0
003456  784010     MOV.B [W0], W0
003458  07FFE7     RCALL UART3_SendChar
54:                        //        bytes++;
55:                    }
56:                    return bytes;
003464  78401E     MOV.B [W14], W0
57:                }
003466  FA8000     ULNK
003468  060000     RETURN
58:                
59:                bool UART3_ReceiveChar(uint8_t * ch) {
00346A  FA0002     LNK #0x2
00346C  780F00     MOV W0, [W14]
60:                    if (U3STAbits.URXDA) {
00346E  801290     MOV U3STA, W0
003470  600061     AND W0, #0x1, W0
003472  E00000     CP0 W0
003474  320006     BRA Z, 0x3482
61:                        *ch = U3RXREG;
003476  8012B0     MOV U3RXREG, W0
003478  784080     MOV.B W0, W1
00347A  78001E     MOV [W14], W0
00347C  784801     MOV.B W1, [W0]
62:                        return true;
00347E  B3C010     MOV.B #0x1, W0
003480  370001     BRA 0x3484
63:                    } else
64:                        return false;
003482  EB4000     CLR.B W0
65:                }
003484  FA8000     ULNK
003486  060000     RETURN
66:                
67:                void U3Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
003488  FA0002     LNK #0x2
68:                    uint8_t cnt;
69:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
00348A  EB4000     CLR.B W0
00348C  784F00     MOV.B W0, [W14]
00348E  370006     BRA 0x349C
00349A  E84F1E     INC.B [W14], [W14]
00349C  78401E     MOV.B [W14], W0
00349E  504FE3     SUB.B W0, #0x3, [W15]
0034A0  36FFF7     BRA LEU, 0x3490
70:                        if (U3STAbits.URXDA) //没有接收到
003490  801290     MOV U3STA, W0
003492  600061     AND W0, #0x1, W0
003494  E00000     CP0 W0
003496  320001     BRA Z, 0x349A
71:                            BufferWrite_UART3();
003498  07F95C     RCALL BufferWrite_UART3
72:                }
0034A2  FA8000     ULNK
73:                
74:                
75:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/UART2.c  -------------------------------------
1:                 //#include "includes.h"
2:                 #include "UART2.h"
3:                 
4:                 void UART2_Init(void) {
0031FE  FA0000     LNK #0x0
5:                     //已经为数字端口，
6:                     TRISDbits.TRISD2 = 1; //设置为输入
003200  A842D8     BSET TRISD, #2
7:                     TRISDbits.TRISD3 = 0; //设置为输出
003202  A962D8     BCLR TRISD, #3
8:                     //    TRISDbits.TRISD3 = 1; //设置为输入
9:                     //    TRISDbits.TRISD2 = 0; //设置为输出
10:                
11:                    U2MODEbits.BRGH = 0; //波特率使用标准模式1:16
003204  A96230     BCLR U2MODE, #3
12:                    U2BRG = 51; //19200 103; //16000000/9600/16-1
003206  200330     MOV #0x33, W0
003208  8811C0     MOV W0, U2BRG
13:                    U2MODEbits.PDSEL = 00; //无奇偶校验
00320A  801181     MOV U2MODE, W1
00320C  2FFF90     MOV #0xFFF9, W0
00320E  608000     AND W1, W0, W0
003210  881180     MOV W0, U2MODE
14:                    U2MODEbits.STSEL = 0; //1位停止位
003212  A90230     BCLR U2MODE, #0
15:                
16:                    U2MODEbits.UARTEN = 1; //使能串口
003214  A8E231     BSET 0x231, #7
17:                
18:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003216  A84233     BSET 0x233, #2
19:                    U2STAbits.URXISEL = 3; //有 4 个数据字符，中断标志位置 1
003218  801191     MOV U2STA, W1
00321A  200C00     MOV #0xC0, W0
00321C  700001     IOR W0, W1, W0
00321E  881190     MOV W0, U2STA
20:                    IEC1bits.U2RXIE = 1; //开启接受中断
003220  A8C097     BSET 0x97, #6
21:                    IFS1bits.U2RXIF = 0; //清除接收中断
003222  A9C087     BCLR 0x87, #6
22:                    IEC4bits.U2ERIE = 1;
003224  A8409C     BSET IEC4, #2
23:                    IFS4bits.U2ERIF = 0;
003226  A9408C     BCLR IFS4, #2
24:                }
003228  FA8000     ULNK
00322A  060000     RETURN
25:                
26:                void UART2_Open(void) {
00322C  FA0000     LNK #0x0
27:                    U2MODEbits.UARTEN = 1; //使能串口
00322E  A8E231     BSET 0x231, #7
28:                    U2STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003230  A84233     BSET 0x233, #2
29:                    // IEC1bits.U2TXIE=1;
30:                    IEC1bits.U2RXIE = 1;
003232  A8C097     BSET 0x97, #6
31:                }
003234  FA8000     ULNK
003236  060000     RETURN
32:                
33:                void UART2_Close(void) {
003238  FA0000     LNK #0x0
34:                    // IEC1bits.U2TXIE=0;
35:                    IEC1bits.U2RXIE = 0;
00323A  A9C097     BCLR 0x97, #6
36:                    U2STAbits.UTXEN = 0; //使能发送 必须先使能串口 在发送数据
00323C  A94233     BCLR 0x233, #2
37:                    U2MODEbits.UARTEN = 0; //使能串口发送    
00323E  A9E231     BCLR 0x231, #7
38:                }
003240  FA8000     ULNK
003242  060000     RETURN
39:                
40:                void UART2_SendChar(uint8_t ch) {
003244  FA0002     LNK #0x2
003246  784F00     MOV.B W0, [W14]
41:                    U2TXREG = ch;
003248  FB801E     ZE [W14], W0
00324A  8811A0     MOV W0, U2TXREG
42:                    while (!U2STAbits.TRMT);
00324C  000000     NOP
00324E  801191     MOV U2STA, W1
003250  201000     MOV #0x100, W0
003252  608000     AND W1, W0, W0
003254  E00000     CP0 W0
003256  32FFFB     BRA Z, 0x324E
43:                }
003258  FA8000     ULNK
00325A  060000     RETURN
44:                
45:                uint8_t UART2_SendString(const uint8_t *str) {
00325C  FA0004     LNK #0x4
00325E  980710     MOV W0, [W14+2]
46:                    uint8_t bytes = 0;
003260  EB4000     CLR.B W0
003262  784F00     MOV.B W0, [W14]
47:                    while (*str != '\0') {
003264  370007     BRA 0x3274
003274  90001E     MOV [W14+2], W0
003276  784010     MOV.B [W0], W0
003278  E00400     CP0.B W0
00327A  3AFFF5     BRA NZ, 0x3266
48:                        UART2_SendChar(*str++);
003266  90001E     MOV [W14+2], W0
003268  784010     MOV.B [W0], W0
00326A  90009E     MOV [W14+2], W1
00326C  E80081     INC W1, W1
00326E  980711     MOV W1, [W14+2]
003270  07FFE9     RCALL UART2_SendChar
49:                        bytes++;
003272  E84F1E     INC.B [W14], [W14]
50:                    }
51:                    return bytes;
00327C  78401E     MOV.B [W14], W0
52:                }
00327E  FA8000     ULNK
003280  060000     RETURN
53:                
54:                uint8_t UART2_SendString2(const uint8_t *str, uint8_t len) {
003282  FA0006     LNK #0x6
003284  980710     MOV W0, [W14+2]
003286  984741     MOV.B W1, [W14+4]
55:                    uint8_t bytes = 0;
003288  EB4000     CLR.B W0
00328A  784F00     MOV.B W0, [W14]
56:                    while (bytes < len) {
00328C  370007     BRA 0x329C
00329C  90404E     MOV.B [W14+4], W0
00329E  78409E     MOV.B [W14], W1
0032A0  50CF80     SUB.B W1, W0, [W15]
0032A2  39FFF5     BRA NC, 0x328E
57:                        UART2_SendChar(*str++);
00328E  90001E     MOV [W14+2], W0
003290  784010     MOV.B [W0], W0
003292  90009E     MOV [W14+2], W1
003294  E80081     INC W1, W1
003296  980711     MOV W1, [W14+2]
003298  07FFD5     RCALL UART2_SendChar
58:                        bytes++;
00329A  E84F1E     INC.B [W14], [W14]
59:                    }
60:                    return bytes;
0032A4  78401E     MOV.B [W14], W0
61:                }
0032A6  FA8000     ULNK
0032A8  060000     RETURN
62:                
63:                bool UART2_ReceiveChar(uint8_t * ch) {
0032AA  FA0002     LNK #0x2
0032AC  780F00     MOV W0, [W14]
64:                    if (U2STAbits.URXDA) {
0032AE  801190     MOV U2STA, W0
0032B0  600061     AND W0, #0x1, W0
0032B2  E00000     CP0 W0
0032B4  320006     BRA Z, 0x32C2
65:                        *ch = U2RXREG;
0032B6  8011B0     MOV U2RXREG, W0
0032B8  784080     MOV.B W0, W1
0032BA  78001E     MOV [W14], W0
0032BC  784801     MOV.B W1, [W0]
66:                        return true;
0032BE  B3C010     MOV.B #0x1, W0
0032C0  370001     BRA 0x32C4
67:                    } else
68:                        return false;
0032C2  EB4000     CLR.B W0
69:                }
0032C4  FA8000     ULNK
0032C6  060000     RETURN
70:                
71:                void U2Rx4Byte(void) {//获取终端里面的最后几个数据，每4个字节中断
0032C8  FA0002     LNK #0x2
72:                    uint8_t cnt;
73:                    for (cnt = 0; cnt < 4; cnt++)//串口最后四个字节没有接受到，中断原因
0032CA  EB4000     CLR.B W0
0032CC  784F00     MOV.B W0, [W14]
0032CE  370006     BRA 0x32DC
0032DA  E84F1E     INC.B [W14], [W14]
0032DC  78401E     MOV.B [W14], W0
0032DE  504FE3     SUB.B W0, #0x3, [W15]
0032E0  36FFF7     BRA LEU, 0x32D0
74:                        if (U2STAbits.URXDA) //没有接收到
0032D0  801190     MOV U2STA, W0
0032D2  600061     AND W0, #0x1, W0
0032D4  E00000     CP0 W0
0032D6  320001     BRA Z, 0x32DA
75:                            BufferWrite_UART2();
0032D8  07FA21     RCALL BufferWrite_UART2
76:                }
0032E2  FA8000     ULNK
77:                
78:                
79:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/TIM.c  ---------------------------------------
1:                 #include <TIM.h>
2:                 //用于显示LCD
3:                 
4:                 void TMR1_Initialize(void) {
003638  FA0000     LNK #0x0
5:                     //TSIDL disabled; TGATE disabled; TCS External; TSYNC disabled; TCKPS 1:1; TECS SOSC; TON enabled; 
6:                     T1CON = 0x0002;
00363A  200020     MOV #0x2, W0
00363C  880820     MOV W0, T1CON
7:                     //TMR1 0; 
8:                     TMR1 = 0x0000;
00363E  EF2100     CLR TMR1
9:                     //PR1 20; 
10:                    PR1 = 0x7918; //1s// 0xF230; //2s 
003640  279180     MOV #0x7918, W0
003642  880810     MOV W0, PR1
11:                    T1CONbits.TON = 1;
003644  A8E105     BSET 0x105, #7
12:                    IPC0bits.T1IP = 5;
003646  800521     MOV IPC0, W1
003648  28FFF0     MOV #0x8FFF, W0
00364A  608080     AND W1, W0, W1
00364C  250000     MOV #0x5000, W0
00364E  700001     IOR W0, W1, W0
003650  880520     MOV W0, IPC0
13:                    IFS0bits.T1IF = 0;
003652  A96084     BCLR IFS0, #3
14:                    IEC0bits.T1IE = 1;
003654  A86094     BSET IEC0, #3
15:                }
003656  FA8000     ULNK
003658  060000     RETURN
16:                //用于基本延时
17:                
18:                void TMR2_Initialize(void) {
00365A  FA0000     LNK #0x0
19:                    //TSIDL disabled; TGATE disabled; TCS FOSC/2; TCKPS 1:256; T32 disabled; TON enabled; 
20:                    T2CON = 0x8030;
00365C  280300     MOV #0x8030, W0
00365E  880880     MOV W0, T2CON
21:                    //TMR2 0; 
22:                    TMR2 = 0x0000;
003660  EF2106     CLR TMR2
23:                    //Period Value = 10.000 ms; PR2 20000; 
24:                    PR2 = 0xffff; //0x4E20;
003662  EB8000     SETM W0
003664  880860     MOV W0, PR2
25:                    IPC1bits.T2IP = 1;
003666  800531     MOV IPC1, W1
003668  28FFF0     MOV #0x8FFF, W0
00366A  608000     AND W1, W0, W0
00366C  A0C000     BSET W0, #12
00366E  880530     MOV W0, IPC1
26:                    T2CONbits.TON = 0;
003670  A9E111     BCLR 0x111, #7
27:                    IFS0bits.T2IF = 0;
003672  A9E084     BCLR IFS0, #7
28:                }
003674  FA8000     ULNK
003676  060000     RETURN
29:                
30:                void StartTMR2(void) {
003678  FA0000     LNK #0x0
31:                    IEC0bits.T2IE = 1;
00367A  A8E094     BSET IEC0, #7
32:                    T2CONbits.TON = 1;
00367C  A8E111     BSET 0x111, #7
33:                }
00367E  FA8000     ULNK
003680  060000     RETURN
34:                
35:                void StopTMR2(void) {
003682  FA0000     LNK #0x0
36:                    IEC0bits.T2IE = 0;
003684  A9E094     BCLR IEC0, #7
37:                    T2CONbits.TON = 0;
003686  A9E111     BCLR 0x111, #7
38:                }
003688  FA8000     ULNK
39:                
40:                //void StartTMR2Int(void)
41:                //{
42:                //    
43:                //}
44:                
45:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/RTCC.c  --------------------------------------
1:                 #include "RTCC.h"
2:                 #include "WGC.h"
3:                 #include "RS485.h"
4:                 #include <xc.h>
5:                 
6:                 /*************************************
7:                 Function: RTC_Configuration 
8:                 Description: 实时时钟和闹钟初始化
9:                 Input: 无
10:                Output: 无
11:                 *************************************/
12:                void RTC_Init(void) {
0023D2  FA0008     LNK #0x8
13:                    uint8_t rtcc_tmp[7] = {0x20, 0x17, 0x10, 0x30, 0x12, 0x59, 0x00};
0023D4  290D81     MOV #0x90D8, W1
0023D6  090006     REPEAT #0x6
0023D8  785F31     MOV.B [W1++], [W14++]
0023DA  B1007E     SUB #0x7, W14
14:                    // Set the RTCWREN bit
15:                    __builtin_write_RTCWEN(); //unlock sequence
0023DC  200550     MOV #0x55, W0
0023DE  883B30     MOV W0, NVMKEY
0023E0  200AA0     MOV #0xAA, W0
0023E2  883B30     MOV W0, NVMKEY
0023E4  A8A627     BSET 0x627, #5
16:                
17:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
0023E6  803131     MOV RCFGCAL, W1
0023E8  203000     MOV #0x300, W0
0023EA  700001     IOR W0, W1, W0
0023EC  883130     MOV W0, RCFGCAL
18:                    RTCVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
0023EE  90401E     MOV.B [W14+1], W0
0023F0  FB8000     ZE W0, W0
0023F2  883120     MOV W0, RTCVAL
19:                    RTCVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
0023F4  90402E     MOV.B [W14+2], W0
0023F6  FB8000     ZE W0, W0
0023F8  DD00C8     SL W0, #8, W1
0023FA  90403E     MOV.B [W14+3], W0
0023FC  FB8000     ZE W0, W0
0023FE  408000     ADD W1, W0, W0
002400  883120     MOV W0, RTCVAL
20:                    RTCVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
002402  90404E     MOV.B [W14+4], W0
002404  FB8000     ZE W0, W0
002406  883120     MOV W0, RTCVAL
21:                    RTCVAL = (rtcc_tmp[5] << 8) + rtcc_tmp[6]; //0x3050; //分钟 秒 
002408  90405E     MOV.B [W14+5], W0
00240A  FB8000     ZE W0, W0
00240C  DD00C8     SL W0, #8, W1
00240E  90406E     MOV.B [W14+6], W0
002410  FB8000     ZE W0, W0
002412  408000     ADD W1, W0, W0
002414  883120     MOV W0, RTCVAL
22:                
23:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
24:                    //    RTCPWC = 0x0000;
25:                
26:                    //    ALCFGRPTbits.AMASK = 0b0110; //每日中断//0b0011; -1s 闹钟掩码设置 0x11每分钟闹钟中断一次
27:                    //    ALCFGRPTbits.CHIME = 1; //1 = 使能响铃； ARPT<7:0> 允许从 00h 进位到 FFh
28:                    ALCFGRPTbits.ALRMEN = 0; //关闭报警
002416  A9E623     BCLR 0x623, #7
29:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
002418  803111     MOV ALCFGRPT, W1
00241A  2FCFF0     MOV #0xFCFF, W0
00241C  608000     AND W1, W0, W0
00241E  A09000     BSET W0, #9
002420  883110     MOV W0, ALCFGRPT
30:                    //        ALRMVAL = 0x0000; //none       
31:                    ALRMVAL = 0x0000; //month day 0001
002422  EF2620     CLR ALRMVAL
32:                    ALRMVAL = 0x0000; //week hour
002424  EF2620     CLR ALRMVAL
33:                    ALRMVAL = 0x0000; //minute second  0000
002426  EF2620     CLR ALRMVAL
34:                    //    ALRMVAL = rtcc_tmp[1] & 0x00FF; //0x0016; //年份  2016.6.1. 3 13:10:10
35:                    //    ALRMVAL = (rtcc_tmp[2] << 8) + rtcc_tmp[3]; //0x1022; //月份 日期
36:                    //    ALRMVAL = rtcc_tmp[4] & 0x00FF; //0x0008; //星期  小时
37:                    //    ALRMVAL = (rtcc_tmp[5] << 8) + 0x25; //rtcc_tmp[6] ; //0x3050; //分钟 秒 
38:                    //    ALCFGRPTbits.ARPT=0;
39:                    //    ALCFGRPTbits.ALRMEN = 1; //闹钟已使能 （每当 ARPT<7:0> = 00 和 CHIME = 0 时，发生闹钟事件后都自动清零）    
40:                
41:                    // ALRMEN enabled; ARPT 0; AMASK Every Second; CHIME enabled; ALRMPTR MIN_SEC; 
42:                    ALCFGRPT = 0xD800; //    every day once 
002428  2D8000     MOV #0xD800, W0
00242A  883110     MOV W0, ALCFGRPT
43:                    //    ALCFGRPT = 0xC800;
44:                    // PWCPOL disabled; PWCEN disabled; RTCLK SOSC; PWCPRE disabled; RTCOUT Alarm Pulse; PWSPRE disabled; 
45:                    RTCPWC = 0x0000;
00242C  EF2628     CLR RTCPWC
46:                    IPC15bits.RTCIP = 6;
00242E  800611     MOV IPC15, W1
002430  2F8FF0     MOV #0xF8FF, W0
002432  608080     AND W1, W0, W1
002434  206000     MOV #0x600, W0
002436  700001     IOR W0, W1, W0
002438  880610     MOV W0, IPC15
47:                    IFS3bits.RTCIF = 0; //外设相关的中断标志状态位清零
00243A  A9C08B     BCLR 0x8B, #6
48:                    IEC3bits.RTCIE = 1; //开中断 =1
00243C  A8C09B     BSET 0x9B, #6
49:                
50:                    RCFGCALbits.RTCEN = 1; //使能 RTCC 模块
00243E  A8E627     BSET 0x627, #7
51:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
002440  A9A627     BCLR 0x627, #5
52:                }
002442  FA8000     ULNK
002444  060000     RETURN
53:                
54:                void RTC_Set_Alarm(struct tm initialTime) {//, uint8_t mask) {
002446  FA0000     LNK #0x0
55:                    //只能在禁止闹钟 （ALRMEN = 0）时更改定时器和闹钟值。建议在RTCSYNC = 0 时更改 ALCFGRPT 寄存器和 CHIME 位。
56:                    __builtin_write_RTCWEN(); //unlock sequence
002448  200550     MOV #0x55, W0
00244A  883B30     MOV W0, NVMKEY
00244C  200AA0     MOV #0xAA, W0
00244E  883B30     MOV W0, NVMKEY
002450  A8A627     BSET 0x627, #5
57:                
58:                    ALCFGRPTbits.ALRMEN = 0; //关闭闹钟
002452  A9E623     BCLR 0x623, #7
59:                    while (RCFGCALbits.RTCSYNC); //等待同步位
002454  000000     NOP
002456  803131     MOV RCFGCAL, W1
002458  210000     MOV #0x1000, W0
00245A  608000     AND W1, W0, W0
00245C  E00000     CP0 W0
00245E  3AFFFB     BRA NZ, 0x2456
60:                
61:                    ALCFGRPTbits.ALRMPTR = 2; //闹钟值寄存器窗口指针位
002460  803111     MOV ALCFGRPT, W1
002462  2FCFF0     MOV #0xFCFF, W0
002464  608000     AND W1, W0, W0
002466  A09000     BSET W0, #9
002468  883110     MOV W0, ALCFGRPT
62:                    ALRMVAL = ((initialTime.tm_mon) << 8) + (initialTime.tm_mday);
00246A  97B80E     MOV [W14-16], W0
00246C  DD00C8     SL W0, #8, W1
00246E  97B07E     MOV [W14-18], W0
002470  408000     ADD W1, W0, W0
002472  883100     MOV W0, ALRMVAL
63:                    ALRMVAL = ((initialTime.tm_wday) << 8) + (initialTime.tm_hour);
002474  97B82E     MOV [W14-12], W0
002476  DD00C8     SL W0, #8, W1
002478  97B06E     MOV [W14-20], W0
00247A  408000     ADD W1, W0, W0
00247C  883100     MOV W0, ALRMVAL
64:                    ALRMVAL = ((initialTime.tm_min) << 8) + (initialTime.tm_sec);
00247E  97B05E     MOV [W14-22], W0
002480  DD00C8     SL W0, #8, W1
002482  97B04E     MOV [W14-24], W0
002484  408000     ADD W1, W0, W0
002486  883100     MOV W0, ALRMVAL
65:                    RCFGCALbits.RTCWREN = 0; //关闭RTCC写使能
002488  A9A627     BCLR 0x627, #5
66:                    ALCFGRPTbits.ALRMEN = 1; //开启闹钟
00248A  A8E623     BSET 0x623, #7
67:                }
00248C  FA8000     ULNK
00248E  060000     RETURN
68:                
69:                /*************************************
70:                Function: RTC_ReadTime 
71:                Description: 获取实时时钟的时间
72:                Input: 4个u16类型数据 
73:                Output: 无
74:                 *************************************/
75:                bool RTC_Read_Time(struct tm*currentTime) {
002490  FA0004     LNK #0x4
002492  980710     MOV W0, [W14+2]
76:                    uint16_t time_tmp;
77:                    if (RCFGCALbits.RTCSYNC)//等待进入安全读取域
002494  803132     MOV RCFGCAL, W2
002496  210000     MOV #0x1000, W0
002498  610000     AND W2, W0, W0
00249A  E00000     CP0 W0
00249C  320002     BRA Z, 0x24A2
78:                        return false;
00249E  EB4000     CLR.B W0
0024A0  370042     BRA 0x2526
79:                
80:                    __builtin_write_RTCWEN(); // Set the RTCWREN bit
0024A2  200551     MOV #0x55, W1
0024A4  883B31     MOV W1, NVMKEY
0024A6  200AA1     MOV #0xAA, W1
0024A8  883B31     MOV W1, NVMKEY
0024AA  A8A627     BSET 0x627, #5
81:                
82:                    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
0024AC  803131     MOV RCFGCAL, W1
0024AE  203000     MOV #0x300, W0
0024B0  700001     IOR W0, W1, W0
0024B2  883130     MOV W0, RCFGCAL
83:                    time_tmp = RTCVAL; //获取年份 
0024B4  803121     MOV RTCVAL, W1
0024B6  780F01     MOV W1, [W14]
84:                    currentTime->tm_year = time_tmp;
0024B8  78009E     MOV [W14], W1
0024BA  90001E     MOV [W14+2], W0
0024BC  980051     MOV W1, [W0+10]
85:                    RCFGCALbits.RTCPTR = 2;
0024BE  803131     MOV RCFGCAL, W1
0024C0  2FCFF0     MOV #0xFCFF, W0
0024C2  608000     AND W1, W0, W0
0024C4  A09000     BSET W0, #9
0024C6  883130     MOV W0, RCFGCAL
86:                    time_tmp = RTCVAL; //获取月日
0024C8  803121     MOV RTCVAL, W1
0024CA  780F01     MOV W1, [W14]
87:                    currentTime->tm_mon = (time_tmp & 0xFF00) >> 8;
0024CC  78001E     MOV [W14], W0
0024CE  DE0048     LSR W0, #8, W0
0024D0  780080     MOV W0, W1
0024D2  90001E     MOV [W14+2], W0
0024D4  980041     MOV W1, [W0+8]
88:                    currentTime->tm_mday = time_tmp & 0x00FF;
0024D6  78009E     MOV [W14], W1
0024D8  200FF0     MOV #0xFF, W0
0024DA  608080     AND W1, W0, W1
0024DC  90001E     MOV [W14+2], W0
0024DE  980031     MOV W1, [W0+6]
89:                    RCFGCALbits.RTCPTR = 1;
0024E0  803131     MOV RCFGCAL, W1
0024E2  2FCFF0     MOV #0xFCFF, W0
0024E4  608000     AND W1, W0, W0
0024E6  A08000     BSET W0, #8
0024E8  883130     MOV W0, RCFGCAL
90:                    time_tmp = RTCVAL; //获取小时
0024EA  803121     MOV RTCVAL, W1
0024EC  780F01     MOV W1, [W14]
91:                    currentTime->tm_wday = (time_tmp & 0xFF00) >> 8;
0024EE  78001E     MOV [W14], W0
0024F0  DE0048     LSR W0, #8, W0
0024F2  780080     MOV W0, W1
0024F4  90001E     MOV [W14+2], W0
0024F6  980061     MOV W1, [W0+12]
92:                    currentTime->tm_hour = time_tmp & 0x00FF;
0024F8  78009E     MOV [W14], W1
0024FA  200FF0     MOV #0xFF, W0
0024FC  608080     AND W1, W0, W1
0024FE  90001E     MOV [W14+2], W0
002500  980021     MOV W1, [W0+4]
93:                    RCFGCALbits.RTCPTR = 0;
002502  803131     MOV RCFGCAL, W1
002504  2FCFF0     MOV #0xFCFF, W0
002506  608000     AND W1, W0, W0
002508  883130     MOV W0, RCFGCAL
94:                    time_tmp = RTCVAL; //获取分钟秒
00250A  803121     MOV RTCVAL, W1
00250C  780F01     MOV W1, [W14]
95:                    currentTime->tm_min = (time_tmp & 0xFF00) >> 8;
00250E  78001E     MOV [W14], W0
002510  DE0048     LSR W0, #8, W0
002512  780080     MOV W0, W1
002514  90001E     MOV [W14+2], W0
002516  980011     MOV W1, [W0+2]
96:                    currentTime->tm_sec = time_tmp & 0x00FF;
002518  78009E     MOV [W14], W1
00251A  200FF0     MOV #0xFF, W0
00251C  608080     AND W1, W0, W1
00251E  90001E     MOV [W14+2], W0
002520  780801     MOV W1, [W0]
97:                    //    RCFGCALbits.RTCPTR = 3; //RTCC 值寄存器窗口指针位
98:                    //    time_tmp = RTCVAL; //获取年份 
99:                    //    currentTime->tm_year = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
100:                   //    RCFGCALbits.RTCPTR = 2;
101:                   //    time_tmp = RTCVAL; //获取月日
102:                   //    currentTime->tm_mon = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
103:                   //    currentTime->tm_mday = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
104:                   //    RCFGCALbits.RTCPTR = 1;
105:                   //    time_tmp = RTCVAL; //获取小时
106:                   //    currentTime->tm_wday = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
107:                   //    currentTime->tm_hour = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
108:                   //    RCFGCALbits.RTCPTR = 0;
109:                   //    time_tmp = RTCVAL; //获取分钟秒
110:                   //    currentTime->tm_min = (((((time_tmp & 0xFF00) >> 8) & 0xF0) >> 4)* 10 + (((time_tmp & 0xFF00) >> 8) & 0x0F));
111:                   //    currentTime->tm_sec = ((((time_tmp & 0x00FF) & 0xF0) >> 4)* 10 + ((time_tmp & 0x00FF) & 0x0F));
112:                   //    currentTime->tm_isdst
113:                   RCFGCALbits.RTCWREN = 0;
002522  A9A627     BCLR 0x627, #5
114:               
115:                   return true;
002524  B3C010     MOV.B #0x1, W0
116:               }
002526  FA8000     ULNK
002528  060000     RETURN
117:               
118:               /*************************************
119:               Function: Check_RTCC 
120:               Description: 从仪表获取时间 赋值给RTCC
121:               Input: 6个u8类型数据
122:               Output: 无
123:                *************************************/
124:               void RTC_Set_Time(struct tm initialTime) {
00252A  FA0000     LNK #0x0
125:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
00252C  200550     MOV #0x55, W0
00252E  883B30     MOV W0, NVMKEY
002530  200AA0     MOV #0xAA, W0
002532  883B30     MOV W0, NVMKEY
002534  A8A627     BSET 0x627, #5
126:                   RCFGCALbits.RTCEN = 0; //Close RTCC
002536  A9E627     BCLR 0x627, #7
127:               
128:                   IFS3bits.RTCIF = false;
002538  A9C08B     BCLR 0x8B, #6
129:                   IEC3bits.RTCIE = 0;
00253A  A9C09B     BCLR 0x9B, #6
130:               
131:                   // set RTCC initial time
132:                   RCFGCALbits.RTCPTR = 3; // start the sequence
00253C  803131     MOV RCFGCAL, W1
00253E  203000     MOV #0x300, W0
002540  700001     IOR W0, W1, W0
002542  883130     MOV W0, RCFGCAL
133:                   RTCVAL = (initialTime.tm_year); // YEAR
002544  97B81E     MOV [W14-14], W0
002546  883120     MOV W0, RTCVAL
134:                   RTCVAL = (initialTime.tm_mon) << 8 + (initialTime.tm_mday); // MONTH-1/DAY-1
002548  97B88E     MOV [W14-16], W1
00254A  97B07E     MOV [W14-18], W0
00254C  400068     ADD W0, #0x8, W0
00254E  DD0800     SL W1, W0, W0
002550  883120     MOV W0, RTCVAL
135:                   RTCVAL = (initialTime.tm_wday) << 8 + (initialTime.tm_hour); // WEEKDAY/HOURS
002552  97B8AE     MOV [W14-12], W1
002554  97B06E     MOV [W14-20], W0
002556  400068     ADD W0, #0x8, W0
002558  DD0800     SL W1, W0, W0
00255A  883120     MOV W0, RTCVAL
136:                   RTCVAL = (initialTime.tm_min) << 8 + (initialTime.tm_sec); // MINUTES/SECONDS   
00255C  97B0DE     MOV [W14-22], W1
00255E  97B04E     MOV [W14-24], W0
002560  400068     ADD W0, #0x8, W0
002562  DD0800     SL W1, W0, W0
002564  883120     MOV W0, RTCVAL
137:               
138:                   // Enable RTCC, clear RTCWREN         
139:                   RCFGCALbits.RTCEN = 1;
002566  A8E627     BSET 0x627, #7
140:                   RCFGCALbits.RTCWREN = 0;
002568  A9A627     BCLR 0x627, #5
141:               
142:                   IEC3bits.RTCIE = 1;
00256A  A8C09B     BSET 0x9B, #6
143:               }
00256C  FA8000     ULNK
00256E  060000     RETURN
144:               
145:               /*************************************
146:               Function: RTC_Refresh_Time 
147:               Description: 从仪表获取时间 赋值给RTCC
148:               Input: 6个u8类型数据
149:               Output: 无
150:                *************************************/
151:               
152:               void RTC_Refresh_Time(void) {
002570  FA0000     LNK #0x0
153:                   __builtin_write_RTCWEN(); // Set the RTCWREN bit
002572  200550     MOV #0x55, W0
002574  883B30     MOV W0, NVMKEY
002576  200AA0     MOV #0xAA, W0
002578  883B30     MOV W0, NVMKEY
00257A  A8A627     BSET 0x627, #5
154:                   RCFGCALbits.RTCEN = 0; //Close RTCC
00257C  A9E627     BCLR 0x627, #7
155:               
156:                   IFS3bits.RTCIF = false;
00257E  A9C08B     BCLR 0x8B, #6
157:                   IEC3bits.RTCIE = 0;
002580  A9C09B     BCLR 0x9B, #6
158:               
159:                   // set RTCC initial time
160:                   RCFGCALbits.RTCPTR = 3; // start the sequence
002582  803131     MOV RCFGCAL, W1
002584  203000     MOV #0x300, W0
002586  700001     IOR W0, W1, W0
002588  883130     MOV W0, RCFGCAL
161:                   RTCVAL = WGCTIME0bits.year; // YEAR
00258A  BFC800     MOV.B WGCTIME0bits, WREG
00258C  FB8000     ZE W0, W0
00258E  883120     MOV W0, RTCVAL
162:                   RTCVAL = (WGCTIME0bits.month << 8) + WGCTIME1bits.day; // MONTH-1/DAY-1
002590  BFC801     MOV.B 0x801, WREG
002592  FB8000     ZE W0, W0
002594  DD00C8     SL W0, #8, W1
002596  BFC802     MOV.B WGCTIME1bits, WREG
002598  FB8000     ZE W0, W0
00259A  408000     ADD W1, W0, W0
00259C  883120     MOV W0, RTCVAL
163:                   RTCVAL = WGCTIME1bits.hour; // WEEKDAY/HOURS
00259E  BFC803     MOV.B 0x803, WREG
0025A0  FB8000     ZE W0, W0
0025A2  883120     MOV W0, RTCVAL
164:                   RTCVAL = (WGCTIME2bits.min << 8) + WGCTIME2bits.sec; // MINUTES/SECONDS   
0025A4  BFC804     MOV.B WGCTIME2bits, WREG
0025A6  FB8000     ZE W0, W0
0025A8  DD00C8     SL W0, #8, W1
0025AA  BFC805     MOV.B 0x805, WREG
0025AC  FB8000     ZE W0, W0
0025AE  408000     ADD W1, W0, W0
0025B0  883120     MOV W0, RTCVAL
165:                   // Enable RTCC, clear RTCWREN         
166:                   RCFGCALbits.RTCEN = 1;
0025B2  A8E627     BSET 0x627, #7
167:                   RCFGCALbits.RTCWREN = 0;
0025B4  A9A627     BCLR 0x627, #5
168:               
169:                   IEC3bits.RTCIE = 1;
0025B6  A8C09B     BSET 0x9B, #6
170:               }
0025B8  FA8000     ULNK
0025BA  060000     RETURN
171:               
172:               /*************************************
173:               Function: StartRTCC 
174:               Description: 
175:               Input: 
176:               Output: 
177:                *************************************/
178:               //void StartRTCC(void) {
179:               //
180:               //    IEC3bits.RTCIE = 1; //开启中断
181:               //    ALCFGRPTbits.ALRMEN = 1;
182:               //    RCFGCALbits.RTCEN = 1; //开启RTCC
183:               //}
184:               
185:               /*************************************
186:               Function: StopRTCC 
187:               Description: 
188:               Input: 
189:               Output: 
190:                *************************************/
191:               //void StopRTCC(void) {
192:               //    IEC3bits.RTCIE = 0; //关闭中断 
193:               //    ALCFGRPTbits.ALRMEN = 0;
194:               //    RCFGCALbits.RTCEN = 0; //关闭 RTCC 模块
195:               //}
196:               
197:               void PrintTime(void) {
0025BC  FA0026     LNK #0x26
198:                   struct tm time1;
199:                   uint8_t sendstr[20] = {"1234578901234567890"};
0025BE  290C40     MOV #0x90C4, W0
0025C0  4700F2     ADD W14, #0x12, W1
0025C2  090013     REPEAT #0x13
0025C4  7858B0     MOV.B [W0++], [W1++]
0025C6  B10140     SUB #0x14, W0
200:                   while (!RTC_Read_Time(&time1));
0025C8  000000     NOP
0025CA  78000E     MOV W14, W0
0025CC  07FF61     RCALL RTC_Read_Time
0025CE  A20400     BTG.B W0, #0
0025D0  E00400     CP0.B W0
0025D2  3AFFFB     BRA NZ, 0x25CA
201:               
202:                   sendstr[0] = (time1.tm_year / 16) + 0x30;
0025D4  9000DE     MOV [W14+10], W1
0025D6  200100     MOV #0x10, W0
0025D8  780100     MOV W0, W2
0025DA  090011     REPEAT #0x11
0025DC  D80082     DIV.SW W1, W2
0025DE  784000     MOV.B W0, W0
0025E0  B04300     ADD.B #0x30, W0
0025E2  985720     MOV.B W0, [W14+18]
203:                   sendstr[1] = (time1.tm_year % 16) + 0x30;
0025E4  9000DE     MOV [W14+10], W1
0025E6  200100     MOV #0x10, W0
0025E8  780100     MOV W0, W2
0025EA  090011     REPEAT #0x11
0025EC  D80082     DIV.SW W1, W2
0025EE  FD0080     EXCH W0, W1
0025F0  784000     MOV.B W0, W0
0025F2  B04300     ADD.B #0x30, W0
0025F4  985730     MOV.B W0, [W14+19]
204:                   sendstr[2] = '/';
0025F6  B3C2F0     MOV.B #0x2F, W0
0025F8  985740     MOV.B W0, [W14+20]
205:                   sendstr[3] = ((time1.tm_mon + 1) / 16) + 0x30;
0025FA  90004E     MOV [W14+8], W0
0025FC  E80080     INC W0, W1
0025FE  200100     MOV #0x10, W0
002600  780100     MOV W0, W2
002602  090011     REPEAT #0x11
002604  D80082     DIV.SW W1, W2
002606  784000     MOV.B W0, W0
002608  B04300     ADD.B #0x30, W0
00260A  985750     MOV.B W0, [W14+21]
206:                   sendstr[4] = ((time1.tm_mon + 1) % 16) + 0x30;
00260C  90004E     MOV [W14+8], W0
00260E  E80080     INC W0, W1
002610  200100     MOV #0x10, W0
002612  780100     MOV W0, W2
002614  090011     REPEAT #0x11
002616  D80082     DIV.SW W1, W2
002618  FD0080     EXCH W0, W1
00261A  784000     MOV.B W0, W0
00261C  B04300     ADD.B #0x30, W0
00261E  985760     MOV.B W0, [W14+22]
207:                   sendstr[5] = '/';
002620  B3C2F0     MOV.B #0x2F, W0
002622  985770     MOV.B W0, [W14+23]
208:                   sendstr[6] = (time1.tm_mday / 16) + 0x30;
002624  9000BE     MOV [W14+6], W1
002626  200100     MOV #0x10, W0
002628  780100     MOV W0, W2
00262A  090011     REPEAT #0x11
00262C  D80082     DIV.SW W1, W2
00262E  784000     MOV.B W0, W0
002630  B04300     ADD.B #0x30, W0
002632  985F00     MOV.B W0, [W14+24]
209:                   sendstr[7] = (time1.tm_mday % 16) + 0x30;
002634  9000BE     MOV [W14+6], W1
002636  200100     MOV #0x10, W0
002638  780100     MOV W0, W2
00263A  090011     REPEAT #0x11
00263C  D80082     DIV.SW W1, W2
00263E  FD0080     EXCH W0, W1
002640  784000     MOV.B W0, W0
002642  B04300     ADD.B #0x30, W0
002644  985F10     MOV.B W0, [W14+25]
210:                   sendstr[8] = '-';
002646  B3C2D0     MOV.B #0x2D, W0
002648  985F20     MOV.B W0, [W14+26]
211:                   sendstr[9] = (time1.tm_hour / 16) + 0x30;
00264A  9000AE     MOV [W14+4], W1
00264C  200100     MOV #0x10, W0
00264E  780100     MOV W0, W2
002650  090011     REPEAT #0x11
002652  D80082     DIV.SW W1, W2
002654  784000     MOV.B W0, W0
002656  B04300     ADD.B #0x30, W0
002658  985F30     MOV.B W0, [W14+27]
212:                   sendstr[10] = (time1.tm_hour % 16) + 0x30;
00265A  9000AE     MOV [W14+4], W1
00265C  200100     MOV #0x10, W0
00265E  780100     MOV W0, W2
002660  090011     REPEAT #0x11
002662  D80082     DIV.SW W1, W2
002664  FD0080     EXCH W0, W1
002666  784000     MOV.B W0, W0
002668  B04300     ADD.B #0x30, W0
00266A  985F40     MOV.B W0, [W14+28]
213:                   sendstr[11] = ':';
00266C  B3C3A0     MOV.B #0x3A, W0
00266E  985F50     MOV.B W0, [W14+29]
214:                   sendstr[12] = (time1.tm_min / 16) + 0x30;
002670  90009E     MOV [W14+2], W1
002672  200100     MOV #0x10, W0
002674  780100     MOV W0, W2
002676  090011     REPEAT #0x11
002678  D80082     DIV.SW W1, W2
00267A  784000     MOV.B W0, W0
00267C  B04300     ADD.B #0x30, W0
00267E  985F60     MOV.B W0, [W14+30]
215:                   sendstr[13] = (time1.tm_min % 16) + 0x30;
002680  90009E     MOV [W14+2], W1
002682  200100     MOV #0x10, W0
002684  780100     MOV W0, W2
002686  090011     REPEAT #0x11
002688  D80082     DIV.SW W1, W2
00268A  FD0080     EXCH W0, W1
00268C  784000     MOV.B W0, W0
00268E  B04300     ADD.B #0x30, W0
002690  985F70     MOV.B W0, [W14+31]
216:                   sendstr[14] = ':';
002692  B3C3A0     MOV.B #0x3A, W0
002694  986700     MOV.B W0, [W14+32]
217:                   sendstr[15] = (time1.tm_sec / 16) + 0x30;
002696  78009E     MOV [W14], W1
002698  200100     MOV #0x10, W0
00269A  780100     MOV W0, W2
00269C  090011     REPEAT #0x11
00269E  D80082     DIV.SW W1, W2
0026A0  784000     MOV.B W0, W0
0026A2  B04300     ADD.B #0x30, W0
0026A4  986710     MOV.B W0, [W14+33]
218:                   sendstr[16] = (time1.tm_sec % 16) + 0x30;
0026A6  78009E     MOV [W14], W1
0026A8  200100     MOV #0x10, W0
0026AA  780100     MOV W0, W2
0026AC  090011     REPEAT #0x11
0026AE  D80082     DIV.SW W1, W2
0026B0  FD0080     EXCH W0, W1
0026B2  784000     MOV.B W0, W0
0026B4  B04300     ADD.B #0x30, W0
0026B6  986720     MOV.B W0, [W14+34]
219:                   sendstr[17] = '\n';
0026B8  B3C0A0     MOV.B #0xA, W0
0026BA  986730     MOV.B W0, [W14+35]
220:                   //        sendstr[18] = '\n';
221:                   //        sendstr[18] = '\0';
222:                   RS485SendString(sendstr, 18);
0026BC  470072     ADD W14, #0x12, W0
0026BE  B3C121     MOV.B #0x12, W1
0026C0  070646     RCALL RS485SendString
223:                   //        OSTimeDlyHMSM();
224:               }
0026C2  FA8000     ULNK
0026C4  060000     RETURN
225:               #ifdef DEBUG_RTCC_TIME
226:               
227:               void printrtccArg(void) {
228:                   uint8_t tmp[10];
229:                   uint8_t strings[200] = {'\0'}; //clear history data
230:               
231:                   strcat(strings, "S1_t:");
232:                   my_itoa(WGCCON3bits.delay, tmp);
233:                   strcat(strings, tmp);
234:               
235:                   strcat(strings, ";\tS1_c:");
236:                   my_itoa(WGCCON3bits.count, tmp);
237:                   strcat(strings, tmp);
238:               
239:               
240:                   strcat(strings, ";\r\nS2_t:");
241:                   my_itoa(WGCCON4bits.delay, tmp);
242:                   strcat(strings, tmp);
243:               
244:                   strcat(strings, ";\tS2_c:");
245:                   my_itoa(WGCCON4bits.count, tmp);
246:                   strcat(strings, tmp);
247:                   RS485SendString1(strings); //无法正确输出
248:               }
249:               
250:               #endif
251:               
252:               void printnums(uint32_t settingtime) {
0026C6  FA0040     LNK #0x40
0026C8  981F60     MOV W0, [W14+60]
0026CA  981F71     MOV W1, [W14+62]
253:                   uint8_t strings[50] = {'\0'}; //clear history data
0026CC  090018     REPEAT #0x18
0026CE  EB1F00     CLR [W14++]
0026D0  B1032E     SUB #0x32, W14
254:                   uint8_t tmp[10];
255:                   //    strcat(strings, ch);
256:                   my_itoa(settingtime, tmp); //最大16进制数
0026D2  90186E     MOV [W14+60], W0
0026D4  200321     MOV #0x32, W1
0026D6  40808E     ADD W1, W14, W1
0026D8  07FE31     RCALL my_itoa
257:                   strcat(strings, tmp);
0026DA  200321     MOV #0x32, W1
0026DC  40808E     ADD W1, W14, W1
0026DE  78000E     MOV W14, W0
0026E0  07F41F     RCALL 0xF20
258:                   RS485SendString1(strings); //无法正确输出
0026E2  78000E     MOV W14, W0
0026E4  07064F     RCALL RS485SendString1
259:                   //    my_itoa(WGCCON3bits.count,tmp);
260:                   //    strcat(strings,tmp);
261:               
262:                   //    WGCCON3bits.delay;
263:                   //    WGCCON4bits.count;
264:                   //    WGCCON4bits.delay;
265:               
266:                   //     my_itoa(); 
267:               }
0026E6  FA8000     ULNK
268:               
269:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/RS485.c  -------------------------------------
1:                 #include "RS485.h"
2:                 
3:                 #define RS485_TRIS TRISBbits.TRISB10
4:                 #define RS485_CON LATBbits.LATB10 //TRISBbits.TRISB10 
5:                 #define RS485_IN_TRIS TRISBbits.TRISB8
6:                 //#define RS485_IN LATBbits.LATB8
7:                 #define RS485_OUT_TRIS TRISBbits.TRISB9
8:                 #define RS485_OUT LATBbits.LATB9
9:                 
10:                /*************************************
11:                Function: RS485_Init 
12:                Description: 485通讯初始化
13:                Input: 无 
14:                Output: 无
15:                 *************************************/
16:                void RS485_Init(void) {
0032E6  FA0000     LNK #0x0
17:                
18:                    U1MODEbits.UARTEN = 1; //使能串口
0032E8  A8E221     BSET 0x221, #7
19:                    U1MODEbits.BRGH = 0; //16
0032EA  A96220     BCLR U1MODE, #3
20:                    U1BRG = 103; //16000000/9600/16-1
0032EC  200670     MOV #0x67, W0
0032EE  881140     MOV W0, U1BRG
21:                
22:                    U1MODEbits.PDSEL = 00; //无奇偶校验
0032F0  801101     MOV U1MODE, W1
0032F2  2FFF90     MOV #0xFFF9, W0
0032F4  608000     AND W1, W0, W0
0032F6  881100     MOV W0, U1MODE
23:                    U1MODEbits.STSEL = 0; //1位停止位
0032F8  A90220     BCLR U1MODE, #0
24:                    U1MODEbits.USIDL = 0; //空闲模式下继续工作
0032FA  A9A221     BCLR 0x221, #5
25:                    U1MODEbits.WAKE = 1; //休眠状态下继续工作
0032FC  A8E220     BSET U1MODE, #7
26:                    //    U1MODEbits.UARTEN = 1; //使能串口
27:                    U1STAbits.UTXEN = 0; //使能发送 必须先使能串口 在发送数据
0032FE  A94223     BCLR 0x223, #2
28:                    U1STAbits.URXISEL = 3; //有 4个数据字符，中断标志位置 1
003300  801111     MOV U1STA, W1
003302  200C00     MOV #0xC0, W0
003304  700001     IOR W0, W1, W0
003306  881110     MOV W0, U1STA
29:                    U1TXREG = 0;
003308  EF2224     CLR U1TXREG
30:                    U1RXREG = 0;
00330A  EF2226     CLR U1RXREG
31:                    IPC2bits.U1RXIP = 7;
00330C  800541     MOV IPC2, W1
00330E  270000     MOV #0x7000, W0
003310  700001     IOR W0, W1, W0
003312  880540     MOV W0, IPC2
32:                    IFS0bits.U1RXIF = 0; //清除接收中断
003314  A96085     BCLR 0x85, #3
33:                    IEC0bits.U1RXIE = 1; //开启接受中断
003316  A86095     BSET 0x95, #3
34:                    IPC16bits.U1ERIP = 6;
003318  800621     MOV IPC16, W1
00331A  2FF8F0     MOV #0xFF8F, W0
00331C  608080     AND W1, W0, W1
00331E  200600     MOV #0x60, W0
003320  700001     IOR W0, W1, W0
003322  880620     MOV W0, IPC16
35:                    IFS4bits.U1ERIF = 0; //清楚错误中断
003324  A9208C     BCLR IFS4, #1
36:                    IEC4bits.U1ERIE = 1; //开启错误中断    
003326  A8209C     BSET IEC4, #1
37:                    U1STAbits.UTXEN = 1; //使能发送 必须先使能串口 在发送数据
003328  A84223     BSET 0x223, #2
38:                
39:                    //    U1MODE = 0x8008;
40:                    //    // UTXEN disabled; UTXINV disabled; URXISEL RX_ONE_CHAR; ADDEN disabled; UTXISEL0 TX_ONE_CHAR; UTXBRK COMPLETED; OERR NO_ERROR_cleared; 
41:                    //    U1STA = 0x0000;
42:                    //    // U1TXREG 0x0000; 
43:                    //    U1TXREG = 0x0000;
44:                    //    // U1RXREG 0x0000; 
45:                    //    U1RXREG = 0x0000;
46:                    //    // Baud Rate = 9600; BRG 416; 
47:                    //    U1BRG = 0x01A0;
48:                    //
49:                    //    IEC0bits.U1RXIE = 1;
50:                    //
51:                    //    U1STAbits.UTXEN = 1;
52:                }
00332A  FA8000     ULNK
00332C  060000     RETURN
53:                
54:                //void OpenAwake485(void) {//CN6电平通知中断唤醒设备
55:                //    RS485_RX_IN;
56:                //    CNEN1bits.CN6IE = 1; //RX1接受
57:                //}
58:                
59:                //void CloseAwake485(void) {
60:                //    CNEN1bits.CN6IE = 0;
61:                //}
62:                
63:                /*************************************
64:                Function: RS485_Send 待修改 
65:                Description: 485发送数据指令
66:                Input: 发送的数据 
67:                Output: 1:发送成功
68:                 *************************************/
69:                void RS485SendChar(const uint8_t dat) {
00332E  FA0002     LNK #0x2
003330  784F00     MOV.B W0, [W14]
70:                    RS485_CON = 1; //发送
003332  A842CD     BSET 0x2CD, #2
71:                    U1TXREG = dat;
003334  FB801E     ZE [W14], W0
003336  881120     MOV W0, U1TXREG
72:                    while (!U1STAbits.TRMT); //while (!U2STAbits.TRMT);
003338  000000     NOP
00333A  801111     MOV U1STA, W1
00333C  201000     MOV #0x100, W0
00333E  608000     AND W1, W0, W0
003340  E00000     CP0 W0
003342  32FFFB     BRA Z, 0x333A
73:                    Delay10ms(1);
003344  200010     MOV #0x1, W0
003346  07F754     RCALL Delay10ms
74:                    RS485_CON = 0; //接收
003348  A942CD     BCLR 0x2CD, #2
75:                }
00334A  FA8000     ULNK
00334C  060000     RETURN
76:                
77:                /*************************************
78:                Function: RS485_SendString 
79:                Description: 485发送字符串
80:                Input: 字符串 字符串长度 
81:                Output: 无
82:                 *************************************/
83:                void RS485SendString(const uint8_t* dat, uint8_t bytes) {
00334E  FA0006     LNK #0x6
003350  980710     MOV W0, [W14+2]
003352  984741     MOV.B W1, [W14+4]
84:                    uint8_t count = 0;
003354  EB4000     CLR.B W0
003356  784F00     MOV.B W0, [W14]
85:                
86:                    RS485_CON = 1; //发送    
003358  A842CD     BSET 0x2CD, #2
87:                    //    Delay10ms(1);
88:                    while (count < bytes) {
00335A  37000D     BRA 0x3376
003376  90404E     MOV.B [W14+4], W0
003378  78409E     MOV.B [W14], W1
00337A  50CF80     SUB.B W1, W0, [W15]
00337C  39FFEF     BRA NC, 0x335C
89:                        U1TXREG = *(dat + count);
00335C  FB801E     ZE [W14], W0
00335E  90009E     MOV [W14+2], W1
003360  408000     ADD W1, W0, W0
003362  784010     MOV.B [W0], W0
003364  FB8000     ZE W0, W0
003366  881120     MOV W0, U1TXREG
90:                        while (!U1STAbits.TRMT);
003368  000000     NOP
00336A  801111     MOV U1STA, W1
00336C  201000     MOV #0x100, W0
00336E  608000     AND W1, W0, W0
003370  E00000     CP0 W0
003372  32FFFB     BRA Z, 0x336A
91:                        count++;
003374  E84F1E     INC.B [W14], [W14]
92:                    }
93:                    //    Delay1ms(10);//加一段延时
94:                    RS485_CON = 0; //接收
00337E  A942CD     BCLR 0x2CD, #2
95:                    //    Delay10ms(1);
96:                }
003380  FA8000     ULNK
003382  060000     RETURN
97:                
98:                //#ifdef DEBUG_485_SEND_STR
99:                
100:               /*************************************
101:               Function: RS485_SendString 
102:               Description: 485发送字符串
103:               Input: 字符串 字符串长度 
104:               Output: 无
105:                *************************************/
106:               void RS485SendString1(const uint8_t* dat) {
003384  FA0004     LNK #0x4
003386  980710     MOV W0, [W14+2]
107:                   uint8_t count = 0;
003388  EB4000     CLR.B W0
00338A  784F00     MOV.B W0, [W14]
108:               
109:                   RS485_CON = 1; //发送    
00338C  A842CD     BSET 0x2CD, #2
110:                   Delay100ms(1);
00338E  200010     MOV #0x1, W0
003390  07F747     RCALL Delay100ms
111:                   while (dat[count] != '\0') {
003392  37000D     BRA 0x33AE
0033AE  FB801E     ZE [W14], W0
0033B0  90009E     MOV [W14+2], W1
0033B2  408000     ADD W1, W0, W0
0033B4  784010     MOV.B [W0], W0
0033B6  E00400     CP0.B W0
0033B8  3AFFED     BRA NZ, 0x3394
112:                       U1TXREG = *(dat + count);
003394  FB801E     ZE [W14], W0
003396  90009E     MOV [W14+2], W1
003398  408000     ADD W1, W0, W0
00339A  784010     MOV.B [W0], W0
00339C  FB8000     ZE W0, W0
00339E  881120     MOV W0, U1TXREG
113:                       while (!U1STAbits.TRMT);
0033A0  000000     NOP
0033A2  801111     MOV U1STA, W1
0033A4  201000     MOV #0x100, W0
0033A6  608000     AND W1, W0, W0
0033A8  E00000     CP0 W0
0033AA  32FFFB     BRA Z, 0x33A2
114:                       count++;
0033AC  E84F1E     INC.B [W14], [W14]
115:                   }
116:                   Delay100ms(1);
0033BA  200010     MOV #0x1, W0
0033BC  07F731     RCALL Delay100ms
117:                   RS485_CON = 0; //接收
0033BE  A942CD     BCLR 0x2CD, #2
118:                   Delay10ms(1);
0033C0  200010     MOV #0x1, W0
0033C2  07F716     RCALL Delay10ms
119:                   //    OSTimeDlyHMSM(0, 0, 0, 1);
120:               }
0033C4  FA8000     ULNK
121:               //#endif
122:               ///*************************************
123:               //Function: OpenRS485 
124:               //Description: 打开485通讯
125:               //Input: 字符串 字符串长度 
126:               //Output: 无
127:               // *************************************/
128:               //void OpenRS485(void) {
129:               //    IEC0bits.U1RXIE = 1;
130:               //    U1STAbits.UTXEN = 1; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
131:               //}
132:               //
133:               ///*************************************
134:               //Function: RS485_SendString 
135:               //Description: 关闭485通讯
136:               //Input: 字符串 字符串长度 
137:               //Output: 无
138:               // *************************************/
139:               //void CloseRS485(void) {
140:               //    IEC0bits.U1RXIE = 0;
141:               //    U1STAbits.UTXEN = 0; //UARTx transmitter is enabled 关闭串口以免设备一串口供电??????????
142:               //}
143:               /*************************************
144:               Function: RS485_test 
145:               Description: 485通讯测试
146:               Input: 无 
147:               Output: 无
148:                *************************************/
149:               //void RS485test(void)
150:               //{
151:               //    uint8_t dat='6';
152:               
153:               //RS485Send('T');
154:               //    if(!RS485Receive(&dat))
155:               //    {
156:               //        RS485Send(dat);
157:               //        RS485Send('T');
158:               //    }
159:               //}
160:               
161:               /*************************************
162:               Function: RS485_Receive  待修改
163:               Description: 485接收数据指令
164:               Input: 接收数据的指针 
165:               Output: 1：接收到数据
166:                ************************************
167:               bool RS485Receive(uint8_t* dat) {
168:               
169:                   bool b = true;
170:               //    uint8_t timeCount;
171:                   
172:               //    RS485_CON = 0; //接收
173:               
174:                   if (U1STAbits.OERR)
175:                       U1STAbits.OERR = 0;
176:                   
177:               //    gT23Count=0;
178:               //    T2CONbits.TON = 1;//开定时器 提高通讯稳定性
179:                  
180:                   while (!U1STAbits.URXDA) //没有接收到
181:                   {
182:               //        timeCount = gT23Count;
183:               //        if( T100msIsOver(timeCount,10) ) {//1s没有接收到数据
184:               //            b = false;
185:               //            break;
186:               //        }
187:                   }
188:               //    T2CONbits.TON = 0;//关定时器
189:               //    gT23Count=0;           //清除计数
190:               //    TMR3 = 0x0000; //Clear contents of the timer3 register
191:               //    TMR2 = 0x0000;
192:                   
193:               //    if(b)
194:               //        *dat = U1RXREG;
195:               
196:                   return b;
197:               }*/
198:               
199:               
200:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/PPS.c  ---------------------------------------
1:                 /* 
2:                  * File:   PPS.c
3:                  * Author: Administrator
4:                  *
5:                  * Created on 2017年6月20日, 下午1:52
6:                  */
7:                 #include <xc.h>
8:                 
9:                 void PPSInit(void) {
003550  FA0000     LNK #0x0
10:                    TRISBbits.TRISB9 = 0; //控制口设置位输出 485_CON
003552  A922C9     BCLR 0x2C9, #1
11:                    TRISBbits.TRISB8 = 1; //设置为输入/
003554  A802C9     BSET 0x2C9, #0
12:                    TRISBbits.TRISB10 = 0; //设置为输出
003556  A942C9     BCLR 0x2C9, #2
13:                    ANSBbits.ANSB8 = 0; //数字输入
003558  A904E3     BCLR 0x4E3, #0
14:                    ANSBbits.ANSB9 = 0;
00355A  A924E3     BCLR 0x4E3, #1
15:                    ANSBbits.ANSB10 = 1;
00355C  A844E3     BSET 0x4E3, #2
16:                    //    LATBbits.LATB10 = 0;
17:                
18:                    __builtin_write_OSCCONL(OSCCON & 0xbf); // unlock PPS
00355E  803A11     MOV OSCCON, W1
003560  200BF0     MOV #0xBF, W0
003562  608100     AND W1, W0, W2
003564  200460     MOV #0x46, W0
003566  200571     MOV #0x57, W1
003568  207423     MOV #0x742, W3
00356A  784980     MOV.B W0, [W3]
00356C  784981     MOV.B W1, [W3]
00356E  784982     MOV.B W2, [W3]
19:                    //    RPOR4bits.RP8R = 0x03; // B9->UART1:U1TX
20:                    //    RPINR18bits.U1RXR = 0x09; // B8->UART1:U1RX 
21:                    RPOR4bits.RP9R = 0x03; // RB9->UART1:U1TX
003570  803641     MOV RPOR4, W1
003572  2C0FF0     MOV #0xC0FF, W0
003574  608080     AND W1, W0, W1
003576  203000     MOV #0x300, W0
003578  700001     IOR W0, W1, W0
00357A  883640     MOV W0, RPOR4
22:                    RPINR18bits.U1RXR = 0x08; // RB8->UART1:U1RX
00357C  803521     MOV RPINR18, W1
00357E  2FFC00     MOV #0xFFC0, W0
003580  608000     AND W1, W0, W0
003582  A03000     BSET W0, #3
003584  883520     MOV W0, RPINR18
23:                    RPOR11bits.RP22R = 0x05; // RD3->UART2:U2TX
003586  8036B1     MOV RPOR11, W1
003588  2FFC00     MOV #0xFFC0, W0
00358A  608000     AND W1, W0, W0
00358C  B30050     IOR #0x5, W0
00358E  8836B0     MOV W0, RPOR11
24:                    RPINR19bits.U2RXR = 0x17; // RD2->UART2:U2RX 
003590  803531     MOV RPINR19, W1
003592  2FFC00     MOV #0xFFC0, W0
003594  608000     AND W1, W0, W0
003596  B30170     IOR #0x17, W0
003598  883530     MOV W0, RPINR19
25:                    RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
00359A  8036D1     MOV RPOR13, W1
00359C  2FFC00     MOV #0xFFC0, W0
00359E  608000     AND W1, W0, W0
0035A0  B301C0     IOR #0x1C, W0
0035A2  8836D0     MOV W0, RPOR13
26:                    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX 
0035A4  803511     MOV RPINR17, W1
0035A6  2C0FF0     MOV #0xC0FF, W0
0035A8  608080     AND W1, W0, W1
0035AA  213000     MOV #0x1300, W0
0035AC  700001     IOR W0, W1, W0
0035AE  883510     MOV W0, RPINR17
27:                    //    RPINR3bits.
28:                    //    RPOR11bits.RP23R = 0x05; // RD2->UART2:U2TX
29:                    //    RPINR19bits.U2RXR = 0x16; // RD3->UART2:U2RX RPG23=>17
30:                    __builtin_write_OSCCONL(OSCCON | 0x40); // lock   PPS
0035B0  803A10     MOV OSCCON, W0
0035B2  780100     MOV W0, W2
0035B4  A06002     BSET W2, #6
0035B6  200460     MOV #0x46, W0
0035B8  200571     MOV #0x57, W1
0035BA  207423     MOV #0x742, W3
0035BC  784980     MOV.B W0, [W3]
0035BE  784981     MOV.B W1, [W3]
0035C0  784982     MOV.B W2, [W3]
31:                }
0035C2  FA8000     ULNK
32:                
33:                //RPOR13bits.RP26R = 0x1C; // RG7->UART3:U3TX
34:                //    RPINR17bits.U3RXR = 0x13; // RG8->UART3:U3RX
35:                
36:                
37:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/NVIC.c  --------------------------------------
1:                 /* 
2:                  * File:   NVIC.c
3:                  * Author: TURONG62
4:                  *
5:                  * Created on 2016年6月6日, 上午8:48
6:                  */
7:                 #include "SerialBuffer.h"
8:                 #include "includes.h"
9:                 #include "stdbool.h"
10:                #include "stdio.h"
11:                #include "RTCC.h"
12:                #include "LCD.h"
13:                #include "WGC.h"
14:                #include "bsp.h"
15:                //#include "Debug.h"
16:                extern volatile uint8_t i2c1_state;
17:                extern I2C1_Buffer i2c_buf;
18:                static uint8_t T0_Cnt;
19:                
20:                /*************************************
21:                Function: RTCC中断
22:                Description: 
23:                Input: 无 
24:                Output: 无
25:                 *************************************/
26:                void __attribute__((interrupt, no_auto_psv)) _ISR _RTCCInterrupt(void) {
000314  F80036     PUSH RCOUNT
000316  BE9F80     MOV.D W0, [W15++]
000318  BE9F82     MOV.D W2, [W15++]
00031A  BE9F84     MOV.D W4, [W15++]
00031C  BE9F86     MOV.D W6, [W15++]
00031E  FA0002     LNK #0x2
27:                    uint8_t tmp = 0;
000320  EB4000     CLR.B W0
000322  784F00     MOV.B W0, [W14]
28:                    //    WGCCON2bits.Send_FLAG = 1; //添加时间计算避免时间上的误差
29:                    //    RS485SendString
30:                    tmp = CalaAlarmTime(); //计算下次闹钟的时间
000324  070799     RCALL CalaAlarmTime
000326  784F00     MOV.B W0, [W14]
31:                #ifdef DEBUG_RTCC_TIME
32:                    rtime = tmp;
33:                #endif
34:                    SetNextAlarm(tmp); //设置下次闹钟时间
000328  FB801E     ZE [W14], W0
00032A  EB0080     CLR W1
00032C  070891     RCALL SetNextAlarm
35:                #ifdef DEBUG_RTCC_TIME1
36:                    RS485SendString1("WGC\r\n");
00032E  290E00     MOV #0x90E0, W0
000330  071829     RCALL RS485SendString1
37:                    printnums(tmp);
000332  FB801E     ZE [W14], W0
000334  EB0080     CLR W1
000336  0711C7     RCALL printnums
38:                    if (WGCCON2bits.Sample_FLAG) {
000338  804051     MOV WGCCON2bits, W1
00033A  210000     MOV #0x1000, W0
00033C  608000     AND W1, W0, W0
00033E  E00000     CP0 W0
000340  320002     BRA Z, 0x346
39:                        //        WGCCON2bits.Sample_FLAG = 0;
40:                        RS485SendString1("Sample\r\n");
000342  290E60     MOV #0x90E6, W0
000344  07181F     RCALL RS485SendString1
41:                    }
42:                    if (WGCCON2bits.Send_FLAG) {
000346  804051     MOV WGCCON2bits, W1
000348  220000     MOV #0x2000, W0
00034A  608000     AND W1, W0, W0
00034C  E00000     CP0 W0
00034E  320002     BRA Z, 0x354
43:                        //        WGCCON2bits.Send_FLAG = 0;
44:                        RS485SendString1("Send\r\n");
000350  290EF0     MOV #0x90EF, W0
000352  071818     RCALL RS485SendString1
45:                    }
46:                #endif
47:                    IFS3bits.RTCIF = false;
000354  A9C08B     BCLR 0x8B, #6
48:                }
000356  FA8000     ULNK
000358  BE034F     MOV.D [--W15], W6
00035A  BE024F     MOV.D [--W15], W4
00035C  BE014F     MOV.D [--W15], W2
00035E  BE004F     MOV.D [--W15], W0
000360  F90036     POP RCOUNT
000362  064000     RETFIE
49:                
50:                /*************************************
51:                Function: 外部终端0
52:                Description: 电压检测
53:                Input: 无 
54:                Output: 无
55:                 *************************************/
56:                void __attribute__((interrupt, no_auto_psv))_ISR _INT0Interrupt(void) {
000364  FA0000     LNK #0x0
57:                
58:                    IFS0bits.INT0IF = 0;
000366  A90084     BCLR IFS0, #0
59:                }
000368  FA8000     ULNK
00036A  064000     RETFIE
60:                /*************************************
61:                Function: 定时器中断 
62:                Description: 用于在GPRS上线过程中，定时时间
63:                Input: 无 
64:                Output: 无
65:                 *************************************/
66:                //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T3Interrupt(void) {
67:                //    gT3Count++;
68:                //    IFS0bits.T3IF = 0; //Reset Timer1 interrupt flag and Return from ISR
69:                //}
70:                
71:                /*************************************
72:                Function: 定时器中断 
73:                Description: 用于485通讯，时间延时
74:                Input: 无 
75:                Output: 无
76:                 *************************************/
77:                void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T2Interrupt(void) {
00036C  FEA000     PUSH.S
00036E  F80036     PUSH RCOUNT
000370  BE9F84     MOV.D W4, [W15++]
000372  BE9F86     MOV.D W6, [W15++]
000374  F80032     PUSH DSRPAG
000376  F80034     PUSH DSWPAG
000378  200014     MOV #0x1, W4
00037A  8801A4     MOV W4, DSWPAG
00037C  202004     MOV #0x200, W4
00037E  880194     MOV W4, DSRPAG
000380  FA0000     LNK #0x0
78:                    //    uint8_t main_cnt;
79:                    //    while (!U1STAbits.RIDLE);
80:                    //    PC_Cop();
81:                    //    T2CONbits.TON = 0;
82:                    //    TMR2 = 0;
83:                    //    FLagArgbits.TestFlag = 0; //退出调试模式
84:                    StopTMR2();
000382  07197F     RCALL StopTMR2
85:                    if (WGCCON2bits.Sample_FLAG) {
000384  804051     MOV WGCCON2bits, W1
000386  210000     MOV #0x1000, W0
000388  608000     AND W1, W0, W0
00038A  E00000     CP0 W0
00038C  320007     BRA Z, 0x39C
86:                        WGCCON2bits.Sample_FLAG = 0; //等同与定时器2标志位
00038E  A9880B     BCLR 0x80B, #4
87:                #ifdef DEBUG_SAMPLE
88:                        for (main_cnt = 0; main_cnt < 2; main_cnt++) {
89:                            Delay100ms(3);
90:                            LED_Toggle();
91:                        }
92:                        RS485SendString1("\r\nStart Sample!!! count:");
93:                        //            Delay100ms(3);
94:                        printnums(WGCCNTbits.Sample_CNT++);
95:                        NUMS_SHOW(WGCCNTbits.Sample_CNT, 0);
96:                #endif
97:                        if (Sample_Task()) {
000390  0706FA     RCALL Sample_Task
000392  E00400     CP0.B W0
000394  320003     BRA Z, 0x39C
98:                            LED_Toggle1(2, 4);
000396  B3C041     MOV.B #0x4, W1
000398  B3C020     MOV.B #0x2, W0
00039A  0718BE     RCALL LED_Toggle1
99:                        }
100:               #ifdef DEBUG_PRESSURE
101:                       RS485SendString1("\r\nCan't get pressure!!!\r\n");
102:               #endif
103:                       //        main_cnt = 0;
104:                       //        Sample_Task();
105:                       //    WGCPCCop();
106:                   }
107:                   IFS0bits.T2IF = 0; //Reset Timer1 interrupt flag and Return from ISR
00039C  A9E084     BCLR IFS0, #7
108:               }
00039E  FA8000     ULNK
0003A0  F90034     POP DSWPAG
0003A2  F90032     POP DSRPAG
0003A4  BE034F     MOV.D [--W15], W6
0003A6  BE024F     MOV.D [--W15], W4
0003A8  F90036     POP RCOUNT
0003AA  FE8000     POP.S
0003AC  064000     RETFIE
109:               
110:               /*************************************
111:               Function: 定时器中断 
112:               Description: LCD显示
113:               Input: 无 
114:               Output: 无
115:                *************************************/
116:               void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T1Interrupt(void) {//cvery second
0003AE  FEA000     PUSH.S
0003B0  F80036     PUSH RCOUNT
0003B2  BE9F84     MOV.D W4, [W15++]
0003B4  BE9F86     MOV.D W6, [W15++]
0003B6  F80032     PUSH DSRPAG
0003B8  F80034     PUSH DSWPAG
0003BA  200014     MOV #0x1, W4
0003BC  8801A4     MOV W4, DSWPAG
0003BE  202004     MOV #0x200, W4
0003C0  880194     MOV W4, DSRPAG
0003C2  FA0002     LNK #0x2
117:                   //    struct tm tmptr;
118:                   uint16_t pressure10 = 0;
0003C4  EB0000     CLR W0
0003C6  780F00     MOV W0, [W14]
119:                   static cop_cnt = 0;
120:               
121:                   switch (T0_Cnt++ % 4) {
0003C8  208281     MOV #0x828, W1
0003CA  784091     MOV.B [W1], W1
0003CC  FB8001     ZE W1, W0
0003CE  600063     AND W0, #0x3, W0
0003D0  E84081     INC.B W1, W1
0003D2  784181     MOV.B W1, W3
0003D4  208282     MOV #0x828, W2
0003D6  784903     MOV.B W3, [W2]
0003D8  E00000     CP0 W0
0003DA  320003     BRA Z, 0x3E2
0003DC  500FE2     SUB W0, #0x2, [W15]
0003DE  320023     BRA Z, 0x426
0003E0  370030     BRA 0x442
122:                       case 0:
123:                       {
124:                           pressure10 = f_p * 100;
0003E2  8040F0     MOV f_p, W0
0003E4  804101     MOV 0x820, W1
0003E6  200002     MOV #0x0, W2
0003E8  242C83     MOV #0x42C8, W3
0003EA  070284     RCALL 0x8F4
0003EC  070210     RCALL 0x80E
0003EE  780F00     MOV W0, [W14]
125:                           if (pressure10) {//如果压力值为0
0003F0  78001E     MOV [W14], W0
0003F2  E00000     CP0 W0
0003F4  32000A     BRA Z, 0x40A
126:                               //                NUMS_SHOW((uint32_t) pressure10, 0);
127:                               W_LCDCON.LCD_Flagbits.F_DP = 2;
0003F6  804201     MOV W_LCDCON, W1
0003F8  27FFF0     MOV #0x7FFF, W0
0003FA  608000     AND W1, W0, W0
0003FC  884200     MOV W0, W_LCDCON
0003FE  804211     MOV 0x842, W1
000400  2FFFC0     MOV #0xFFFC, W0
000402  608000     AND W1, W0, W0
000404  A00000     BSET W0, #0
000406  884210     MOV W0, 0x842
000408  370008     BRA 0x41A
128:                           } else {
129:                               W_LCDCON.LCD_Flagbits.F_DP = 0;
00040A  804201     MOV W_LCDCON, W1
00040C  27FFF0     MOV #0x7FFF, W0
00040E  608000     AND W1, W0, W0
000410  884200     MOV W0, W_LCDCON
000412  804211     MOV 0x842, W1
000414  2FFFC0     MOV #0xFFFC, W0
000416  608000     AND W1, W0, W0
000418  884210     MOV W0, 0x842
130:                               //                NUMS_SHOW(0, 0);
131:                           }
132:                           W_LCDCON.LCD_Flagbits.F_KPa = 1;
00041A  A86841     BSET 0x841, #3
133:                           W_LCDCON.LCD_Flagbits.F_Num = 1;
00041C  A84842     BSET 0x842, #2
134:                           LCD_Task(pressure10); //执行LCD刷新任务
00041E  78001E     MOV [W14], W0
000420  EB0080     CLR W1
000422  070D36     RCALL LCD_Task
135:                           break;
000424  37000E     BRA 0x442
136:                       }
137:                       case 2:
138:                       {
139:                           W_LCDCON.LCD_Flagbits.F_KPa = 0;
000426  A96841     BCLR 0x841, #3
140:                           W_LCDCON.LCD_Flagbits.F_DP = 0;
000428  804201     MOV W_LCDCON, W1
00042A  27FFF0     MOV #0x7FFF, W0
00042C  608000     AND W1, W0, W0
00042E  884200     MOV W0, W_LCDCON
000430  804211     MOV 0x842, W1
000432  2FFFC0     MOV #0xFFFC, W0
000434  608000     AND W1, W0, W0
000436  884210     MOV W0, 0x842
141:                           W_LCDCON.LCD_Flagbits.F_Time = 1;
000438  A86842     BSET 0x842, #3
142:                           LCD_Task(pressure10); //执行LCD刷新任务
00043A  78001E     MOV [W14], W0
00043C  EB0080     CLR W1
00043E  070D28     RCALL LCD_Task
143:                           break;
000440  000000     NOP
144:                       }
145:                   }
146:               
147:                   //    if (WGCCON2bits.PC_Cop_FLAG) {
148:                   //        if (cop_cnt > 0) {//接收数据1s后，在指令
149:                   //            WGCCON2bits.PC_Cop_FLAG = 0;
150:                   //            LED_Off();
151:                   //            cop_cnt = 0;
152:                   //            WGCPCCop(); //处理用户通讯交互任务
153:                   //        } else
154:                   //            cop_cnt += 1;
155:                   //    }
156:                   IFS0bits.T1IF = 0; //Reset Timer1 interrupt flag and Return from ISR
000442  A96084     BCLR IFS0, #3
157:               }
000444  FA8000     ULNK
000446  F90034     POP DSWPAG
000448  F90032     POP DSRPAG
00044A  BE034F     MOV.D [--W15], W6
00044C  BE024F     MOV.D [--W15], W4
00044E  F90036     POP RCOUNT
000450  FE8000     POP.S
000452  064000     RETFIE
158:               
159:               /*************************************
160:               Function: 定时器t4中断 
161:               Description: 用于采集数据的任务
162:               Input: 无 
163:               Output: 无
164:                *************************************/
165:               //void __attribute__((__interrupt__, __auto_psv__, __shadow__)) _T4Interrupt(void) {
166:               //    if (FLagArgbits.LowPowerGetDataFlag) {
167:               //        FLagArgbits.LowPowerGetDataFlag = 0;
168:               //        GetValueTask(LowPowerData); //获取报警时仪表的通讯数据
169:               //    } else if (FLagArgbits.TestGetDataFlag) {
170:               //        FLagArgbits.TestGetDataFlag = 0;
171:               //        GetValueTask(TestData); //获取报警时仪表的通讯数据
172:               //    } else
173:               //        GetValueTask(SampleData); //获取仪表的通讯数据
174:               //    FM25L64B_Write(BOR_Pulse, (u8*) (&gPulseCount), 4); //保存脉冲总量
175:               //
176:               //    IFS1bits.T4IF = 0; //Reset Timer1 interrupt flag and Return from ISR 
177:               //    CloseTime4();
178:               //}
179:               
180:               /*************************************
181:               Function: 电平变化中断 
182:               Description: 获取脉冲的任务
183:               Input: 无 
184:               Output: 无
185:                *************************************/
186:               //void __attribute__((__interrupt__, __auto_psv__)) _CNInterrupt(void) { //提醒更换电池
187:               //    if (S1) {//通过第二次上升获取数据
188:               //        gPulseCount++; //脉冲数+1
189:               //        if (FLagArgbits.T1CountFlag && FLagArgbits.T1CountLastFlag) {//如果开启T1定时器而且是第二次进入，则采集数据
190:               //            gPulseTime = gT1Count * 1000 + (((u32) TMR1) * 1000 >> 15) + 100; //单位ms
191:               //            if (gPulseTime < 2000)//采集时间小于2s
192:               //                gPulseTime = 0;
193:               //            else {
194:               //                FLagArgbits.PulseTimeFlag = 1; // 如果已经获取到脉冲时间，那么需要关闭定时器
195:               //                FLagArgbits.T1CountFlag = 0;
196:               //                T1CONbits.TON = 0;
197:               //            }
198:               //        }
199:               //        TMR1 = 0;
200:               //        gT1Count = 0;
201:               //        FLagArgbits.T1CountLastFlag = FLagArgbits.T1CountFlag; //通过上升沿，关闭FLagArgbits.T1CountLastFlag
202:               //    }
203:               //    IFS1bits.CNIF = 0;
204:               //}
205:               
206:               /*************************************
207:               Function: UART1接收中断
208:               Description: 485通讯
209:               Input: 无 
210:               Output: 无
211:                *************************************/
212:               void __attribute__((interrupt, no_auto_psv)) _U1RXInterrupt(void) {
000454  F80036     PUSH RCOUNT
000456  BE9F80     MOV.D W0, [W15++]
000458  BE9F82     MOV.D W2, [W15++]
00045A  BE9F84     MOV.D W4, [W15++]
00045C  BE9F86     MOV.D W6, [W15++]
00045E  FA0002     LNK #0x2
213:                   uint8_t cnt = 0;
000460  EB4000     CLR.B W0
000462  784F00     MOV.B W0, [W14]
214:                   //    OSIntEnter(); 
215:                   //    if (!U1MODEbits.WAKE)
216:                   //        Delay10ms(10);
217:                   for (cnt = 0; cnt < 4; cnt++)
000464  EB4000     CLR.B W0
000466  784F00     MOV.B W0, [W14]
000468  370006     BRA 0x476
000474  E84F1E     INC.B [W14], [W14]
000476  78401E     MOV.B [W14], W0
000478  504FE3     SUB.B W0, #0x3, [W15]
00047A  36FFF7     BRA LEU, 0x46A
218:                       if (U1STAbits.URXDA) //没有接收到
00046A  801110     MOV U1STA, W0
00046C  600061     AND W0, #0x1, W0
00046E  E00000     CP0 W0
000470  320001     BRA Z, 0x474
219:                           BufferWrite_UART1();
000472  07113B     RCALL BufferWrite_UART1
220:                   //    WGCCON2bits.PC_Cop_FLAG = 1;
221:                   //    LED_On();
222:                   IFS0bits.U1RXIF = 0;
00047C  A96085     BCLR 0x85, #3
223:                   //    OSIntExit();
224:               }
00047E  FA8000     ULNK
000480  BE034F     MOV.D [--W15], W6
000482  BE024F     MOV.D [--W15], W4
000484  BE014F     MOV.D [--W15], W2
000486  BE004F     MOV.D [--W15], W0
000488  F90036     POP RCOUNT
00048A  064000     RETFIE
225:               
226:               /*************************************
227:               Function: UART2接收中断
228:               Description: GPRS通讯
229:               Input: 无 
230:               Output: 无
231:                *************************************/
232:               void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt(void) {
00048C  F80036     PUSH RCOUNT
00048E  BE9F80     MOV.D W0, [W15++]
000490  BE9F82     MOV.D W2, [W15++]
000492  BE9F84     MOV.D W4, [W15++]
000494  BE9F86     MOV.D W6, [W15++]
000496  FA0002     LNK #0x2
233:                   uint8_t cnt = 0;
000498  EB4000     CLR.B W0
00049A  784F00     MOV.B W0, [W14]
234:                   //    OSIntEnter();
235:                   for (cnt = 0; cnt < 4; cnt++)
00049C  EB4000     CLR.B W0
00049E  784F00     MOV.B W0, [W14]
0004A0  370006     BRA 0x4AE
0004AC  E84F1E     INC.B [W14], [W14]
0004AE  78401E     MOV.B [W14], W0
0004B0  504FE3     SUB.B W0, #0x3, [W15]
0004B2  36FFF7     BRA LEU, 0x4A2
236:                       if (U2STAbits.URXDA == 1) //没有接收到        
0004A2  801190     MOV U2STA, W0
0004A4  600061     AND W0, #0x1, W0
0004A6  E00000     CP0 W0
0004A8  320001     BRA Z, 0x4AC
237:                           BufferWrite_UART2();
0004AA  071138     RCALL BufferWrite_UART2
238:                   IFS1bits.U2RXIF = 0;
0004B4  A9C087     BCLR 0x87, #6
239:                   //    OSIntExit();
240:               }
0004B6  FA8000     ULNK
0004B8  BE034F     MOV.D [--W15], W6
0004BA  BE024F     MOV.D [--W15], W4
0004BC  BE014F     MOV.D [--W15], W2
0004BE  BE004F     MOV.D [--W15], W0
0004C0  F90036     POP RCOUNT
0004C2  064000     RETFIE
241:               
242:               /*************************************
243:               Function: UART2接收中断
244:               Description: GPRS通讯
245:               Input: 无 
246:               Output: 无
247:                *************************************/
248:               void __attribute__((interrupt, no_auto_psv)) _U3RXInterrupt(void) {
0004C4  F80036     PUSH RCOUNT
0004C6  BE9F80     MOV.D W0, [W15++]
0004C8  BE9F82     MOV.D W2, [W15++]
0004CA  BE9F84     MOV.D W4, [W15++]
0004CC  BE9F86     MOV.D W6, [W15++]
0004CE  FA0002     LNK #0x2
249:                   uint8_t cnt = 0;
0004D0  EB4000     CLR.B W0
0004D2  784F00     MOV.B W0, [W14]
250:                   //    OSIntEnter();
251:                   for (cnt = 0; cnt < 4; cnt++)
0004D4  EB4000     CLR.B W0
0004D6  784F00     MOV.B W0, [W14]
0004D8  370006     BRA 0x4E6
0004E4  E84F1E     INC.B [W14], [W14]
0004E6  78401E     MOV.B [W14], W0
0004E8  504FE3     SUB.B W0, #0x3, [W15]
0004EA  36FFF7     BRA LEU, 0x4DA
252:                       if (U3STAbits.URXDA == 1) //没有接收到        
0004DA  801290     MOV U3STA, W0
0004DC  600061     AND W0, #0x1, W0
0004DE  E00000     CP0 W0
0004E0  320001     BRA Z, 0x4E4
253:                           BufferWrite_UART3();
0004E2  071137     RCALL BufferWrite_UART3
254:                   IFS5bits.U3RXIF = 0;
0004EC  A9408E     BCLR IFS5, #2
255:                   //    OSIntExit();
256:               }
0004EE  FA8000     ULNK
0004F0  BE034F     MOV.D [--W15], W6
0004F2  BE024F     MOV.D [--W15], W4
0004F4  BE014F     MOV.D [--W15], W2
0004F6  BE004F     MOV.D [--W15], W0
0004F8  F90036     POP RCOUNT
0004FA  064000     RETFIE
257:               
258:               /*************************************
259:               Function: UART2发送中断
260:               Description: GPRS通讯
261:               Input: 无 
262:               Output: 无
263:                *************************************/
264:               //void __attribute__((interrupt, no_auto_psv)) _U2TXInterrupt(void) {
265:               //    u8 cnt = 0;
266:               //    while ((cnt < UART2Argbits.bytes2) && (!(U2STAbits.UTXBF == 1))) {
267:               //        U2TXREG = *(UART2Argbits.dat2 + cnt); //发送数据
268:               //
269:               //        while (!U2STAbits.TRMT);
270:               //        cnt++;
271:               //    }
272:               //    IFS1bits.U2TXIF = 0;
273:               //}
274:               
275:               /*************************************
276:               Function: UART1错误终端
277:               Description: 无
278:               Input: 无 
279:               Output: 无
280:                *************************************/
281:               void __attribute__((interrupt, no_auto_psv)) _U1ErrInterrupt(void) {
0004FC  781F80     MOV W0, [W15++]
0004FE  FA0000     LNK #0x0
282:                   //    OSIntEnter();
283:                   if (U1STAbits.OERR)
000500  801110     MOV U1STA, W0
000502  600062     AND W0, #0x2, W0
000504  E00000     CP0 W0
000506  320001     BRA Z, 0x50A
284:                       U1STAbits.OERR = 0;
000508  A92222     BCLR U1STA, #1
285:                   if (U1STAbits.FERR) {//mark
00050A  801110     MOV U1STA, W0
00050C  600064     AND W0, #0x4, W0
00050E  E00000     CP0 W0
000510  320001     BRA Z, 0x514
286:                       //        U1RXREG = U1RXREG;
287:                       U1STAbits.FERR = 0;
000512  A94222     BCLR U1STA, #2
288:                   }
289:                   if (U1STAbits.PERR)
000514  801110     MOV U1STA, W0
000516  600068     AND W0, #0x8, W0
000518  E00000     CP0 W0
00051A  320001     BRA Z, 0x51E
290:                       U1STAbits.PERR = 0;
00051C  A96222     BCLR U1STA, #3
291:                   IFS4bits.U1ERIF = 0;
00051E  A9208C     BCLR IFS4, #1
292:                   //    OSIntExit();
293:               }
000520  FA8000     ULNK
000522  78004F     MOV [--W15], W0
000524  064000     RETFIE
294:               
295:               /*************************************
296:               Function: UART2错误中断
297:               Description: 无
298:               Input: 无 
299:               Output: 无
300:                *************************************/
301:               void __attribute__((interrupt, no_auto_psv)) _U2ErrInterrupt(void) {
000526  781F80     MOV W0, [W15++]
000528  FA0000     LNK #0x0
302:                   //    OSIntEnter();
303:                   if (U2STAbits.OERR == 1)
00052A  801190     MOV U2STA, W0
00052C  600062     AND W0, #0x2, W0
00052E  E00000     CP0 W0
000530  320001     BRA Z, 0x534
304:                       U2STAbits.OERR = 0;
000532  A92232     BCLR U2STA, #1
305:                   IFS4bits.U2ERIF = 0;
000534  A9408C     BCLR IFS4, #2
306:                   //    OSIntExit();
307:               }
000536  FA8000     ULNK
000538  78004F     MOV [--W15], W0
00053A  064000     RETFIE
308:               
309:               /*************************************
310:               Function: UART2错误中断
311:               Description: 无
312:               Input: 无 
313:               Output: 无
314:                *************************************/
315:               void __attribute__((interrupt, no_auto_psv)) _U3ErrInterrupt(void) {
00053C  781F80     MOV W0, [W15++]
00053E  FA0000     LNK #0x0
316:                   //    OSIntEnter();
317:                   if (U3STAbits.OERR == 1)
000540  801290     MOV U3STA, W0
000542  600062     AND W0, #0x2, W0
000544  E00000     CP0 W0
000546  320001     BRA Z, 0x54A
318:                       U3STAbits.OERR = 0;
000548  A92252     BCLR U3STA, #1
319:                   IFS5bits.U3ERIF = 0;
00054A  A9208E     BCLR IFS5, #1
320:                   //    OSIntExit();
321:               }
00054C  FA8000     ULNK
00054E  78004F     MOV [--W15], W0
000550  064000     RETFIE
322:               
323:               /*************************************
324:               Function: 默认终端
325:               Description: 无
326:               Input: 无 
327:               Output: 无
328:                *************************************/
329:               void __attribute__((interrupt, no_auto_psv)) _DefaultInterrupt(void) {
000552  781F80     MOV W0, [W15++]
000554  FA0000     LNK #0x0
330:                   if (INTCON1bits.STKERR)INTCON1bits.STKERR = 0;
000556  800400     MOV INTCON1, W0
000558  600064     AND W0, #0x4, W0
00055A  E00000     CP0 W0
00055C  320001     BRA Z, 0x560
00055E  A94080     BCLR INTCON1, #2
331:                   if (INTCON1bits.ADDRERR)INTCON1bits.ADDRERR = 0;
000560  800400     MOV INTCON1, W0
000562  600068     AND W0, #0x8, W0
000564  E00000     CP0 W0
000566  320001     BRA Z, 0x56A
000568  A96080     BCLR INTCON1, #3
332:                   if (INTCON1bits.MATHERR)INTCON1bits.MATHERR = 0;
00056A  800400     MOV INTCON1, W0
00056C  600070     AND W0, #0x10, W0
00056E  E00000     CP0 W0
000570  320001     BRA Z, 0x574
000572  A98080     BCLR INTCON1, #4
333:                   asm("GOTO __reset");
000574  040200     GOTO 0x200
000576  000000     NOP
334:               }
000578  FA8000     ULNK
00057A  78004F     MOV [--W15], W0
00057C  064000     RETFIE
335:               
336:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
00057E  BE9F80     MOV.D W0, [W15++]
000580  BE9F82     MOV.D W2, [W15++]
000582  FA0000     LNK #0x0
337:                   //    OSIntEnter();
338:                   static uint16_t i2c_operatcode;
339:                   static uint8_t* pi2c_buf_ptr;
340:                   static uint16_t i2c_address;
341:                   static uint8_t i2c_bytes_left;
342:                   static I2C_Flag i2c_flag;
343:                   static bool i2c_IsResart; //设备是否重启
344:               
345:               
346:                   if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
000584  801041     MOV I2C1STAT, W1
000586  200800     MOV #0x80, W0
000588  608000     AND W1, W0, W0
00058A  E00000     CP0 W0
00058C  320002     BRA Z, 0x592
347:                       I2C1STATbits.IWCOL = 0;
00058E  A9E208     BCLR I2C1STAT, #7
348:                       //        i2c_address_restart = 0;
349:                       //是否需要清楚数据
350:                       return;
000590  3700F7     BRA 0x780
351:                   }
352:                   /* Handle the correct i2c state */
353:                   switch (i2c1_state) {
000592  BFC848     MOV.B i2c1_state, WREG
000594  FB8000     ZE W0, W0
000596  DE80CF     ASR W0, #15, W1
000598  2000D2     MOV #0xD, W2
00059A  200003     MOV #0x0, W3
00059C  500F82     SUB W0, W2, [W15]
00059E  588F83     SUBB W1, W3, [W15]
0005A0  3E00EE     BRA GTU, 0x77E
0005A2  016000     BRA W0
0005A4  37000D     BRA 0x5C0
0005A6  370023     BRA 0x5EE
0005A8  370029     BRA 0x5FC
0005AA  37007E     BRA 0x6A8
0005AC  370052     BRA 0x652
0005AE  3700E7     BRA 0x77E
0005B0  3700C8     BRA 0x742
0005B2  37009A     BRA 0x6E8
0005B4  3700A8     BRA 0x706
0005B6  3700C0     BRA 0x738
0005B8  3700AA     BRA 0x70E
0005BA  3700E1     BRA 0x77E
0005BC  3700E0     BRA 0x77E
0005BE  3700C5     BRA 0x74A
354:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
355:                       {
356:                           if (i2c_bytes_left == 0) {//如果数据数据不为0的话
0005C0  BFC829     MOV.B i2c_bytes_left, WREG
0005C2  E00400     CP0.B W0
0005C4  3A00DB     BRA NZ, 0x77C
357:                               //                I2C1CONbits.SEN = 1; // 发送启动条件
358:                               //            } else {
359:                               I2C1CONbits.SEN = 1; // 发送启动条件
0005C6  A80206     BSET I2C1CON, #0
360:                               i2c_operatcode = i2c_buf.operatcode; //赋值操作码
0005C8  209380     MOV #0x938, W0
0005CA  784010     MOV.B [W0], W0
0005CC  FB8000     ZE W0, W0
0005CE  884150     MOV W0, i2c_operatcode
361:                               i2c_address = i2c_buf.address; //赋值地址
0005D0  8049D0     MOV 0x93A, W0
0005D2  884160     MOV W0, i2c_address
362:                               i2c_bytes_left = i2c_buf.length; //赋值长度
0005D4  2093C0     MOV #0x93C, W0
0005D6  784010     MOV.B [W0], W0
0005D8  B7E829     MOV.B WREG, i2c_bytes_left
363:                               pi2c_buf_ptr = i2c_buf.pbuffer; //赋值数据地址
0005DA  8049F0     MOV 0x93E, W0
0005DC  884170     MOV W0, pi2c_buf_ptr
364:                               i2c_flag = i2c_buf.flag; //将设备选择和工作模式均赋值
0005DE  209400     MOV #0x940, W0
0005E0  784110     MOV.B [W0], W2
0005E2  208301     MOV #0x830, W1
0005E4  784882     MOV.B W2, [W1]
365:                               i2c_IsResart = 0;
0005E6  EF6831     CLR.B i2c_IsResart
366:                               i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
0005E8  B3C020     MOV.B #0x2, W0
0005EA  B7E848     MOV.B WREG, i2c1_state
367:                           }
368:                           break;
0005EC  3700C8     BRA 0x77E
00077C  000000     NOP
369:                       }
370:                       case S_MASTER_RESTART:
371:                       {
372:                           I2C1CONbits.RSEN = 1; // 发送启动条件
0005EE  A82206     BSET I2C1CON, #1
373:                           i2c_bytes_left = i2c_buf.length; //赋值长度
0005F0  2093C0     MOV #0x93C, W0
0005F2  784010     MOV.B [W0], W0
0005F4  B7E829     MOV.B WREG, i2c_bytes_left
374:                           i2c1_state = S_MASTER_SEND_ADDR; //状态设置为发送地址
0005F6  B3C020     MOV.B #0x2, W0
0005F8  B7E848     MOV.B WREG, i2c1_state
375:                           break;
0005FA  3700C1     BRA 0x77E
376:                       }
377:                       case S_MASTER_SEND_ADDR:
378:                       {
379:                           if (!i2c_flag.F_IsSelectiveMode) {//表示不带地址读取数据 && i2c_IsResart) {
0005FC  BFC830     MOV.B i2c_flag, WREG
0005FE  604061     AND.B W0, #0x1, W0
000600  E00400     CP0.B W0
000602  3A000F     BRA NZ, 0x622
380:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
000604  BFC830     MOV.B i2c_flag, WREG
000606  604064     AND.B W0, #0x4, W0
000608  E00400     CP0.B W0
00060A  320006     BRA Z, 0x618
381:                                   I2C1TRN = i2c_operatcode | 0x01;
00060C  804150     MOV i2c_operatcode, W0
00060E  A00000     BSET W0, #0
000610  881010     MOV W0, I2C1TRN
382:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作
000612  B3C070     MOV.B #0x7, W0
000614  B7E848     MOV.B WREG, i2c1_state
383:                               } else {
384:                                   I2C1TRN = i2c_operatcode;
000618  804150     MOV i2c_operatcode, W0
00061A  881010     MOV W0, I2C1TRN
385:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
00061C  B3C030     MOV.B #0x3, W0
00061E  B7E848     MOV.B WREG, i2c1_state
386:                               }
387:                           } else if (!i2c_IsResart) {//如果是重启后的操作码，则根据操作码最后一个字节处理；反之,这
000622  BFC831     MOV.B i2c_IsResart, WREG
000624  A20400     BTG.B W0, #0
000626  E00400     CP0.B W0
000628  320005     BRA Z, 0x634
388:                               I2C1TRN = i2c_operatcode;
00062A  804150     MOV i2c_operatcode, W0
00062C  881010     MOV W0, I2C1TRN
389:                               i2c1_state = S_MASTER_SEND_ADDR_16BIT;
00062E  B3C040     MOV.B #0x4, W0
000630  B7E848     MOV.B WREG, i2c1_state
390:                           } else {//就是跟读地址读写数据的后半段
391:                               if (i2c_flag.F_WriteOrRead) {//如果是读指令=1，那么状态设置为地址ACK
000634  BFC830     MOV.B i2c_flag, WREG
000636  604064     AND.B W0, #0x4, W0
000638  E00400     CP0.B W0
00063A  320006     BRA Z, 0x648
392:                                   I2C1TRN = i2c_operatcode | 0x01;
00063C  804150     MOV i2c_operatcode, W0
00063E  A00000     BSET W0, #0
000640  881010     MOV W0, I2C1TRN
393:                                   i2c1_state = S_MASTER_ACK_ADDR; //读操作                    
000642  B3C070     MOV.B #0x7, W0
000644  B7E848     MOV.B WREG, i2c1_state
394:                               } else {
395:                                   I2C1TRN = i2c_operatcode;
000648  804150     MOV i2c_operatcode, W0
00064A  881010     MOV W0, I2C1TRN
396:                                   i2c1_state = S_MASTER_SEND_DATA; //状态设置为发送数据
00064C  B3C030     MOV.B #0x3, W0
00064E  B7E848     MOV.B WREG, i2c1_state
397:                               }
398:                           }
399:                           break;
000616  3700B3     BRA 0x77E
000620  3700AE     BRA 0x77E
000632  3700A5     BRA 0x77E
000646  37009B     BRA 0x77E
000650  370096     BRA 0x77E
400:                       }
401:                       case S_MASTER_SEND_ADDR_16BIT:
402:                       {
403:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
000652  801041     MOV I2C1STAT, W1
000654  280000     MOV #0x8000, W0
000656  608000     AND W1, W0, W0
000658  E00000     CP0 W0
00065A  320006     BRA Z, 0x668
404:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
00065C  A9E209     BCLR 0x209, #7
405:                               I2C1CONbits.PEN = 1; // 发送停止条件 
00065E  A84206     BSET I2C1CON, #2
406:                               IFS1bits.MI2C1IF = 0; //清除标志
000660  A92086     BCLR IFS1, #1
407:                               i2c1_state = S_MASTER_Fail; //状态设置位空闲
000662  B3C0E0     MOV.B #0xE, W0
000664  B7E848     MOV.B WREG, i2c1_state
408:                           } else {
409:                               if (i2c_flag.F_Is16bitsDevice) {
000668  BFC830     MOV.B i2c_flag, WREG
00066A  604062     AND.B W0, #0x2, W0
00066C  E00400     CP0.B W0
00066E  320009     BRA Z, 0x682
410:                                   i2c_flag.F_Is16bitsDevice = 0;
000670  A92830     BCLR i2c_flag, #1
411:                                   I2C1TRN = (uint8_t) (i2c_address >> 8); //发送16位高地址 
000672  804160     MOV i2c_address, W0
000674  DE0048     LSR W0, #8, W0
000676  784000     MOV.B W0, W0
000678  FB8000     ZE W0, W0
00067A  881010     MOV W0, I2C1TRN
412:                                   i2c1_state = S_MASTER_SEND_ADDR_16BIT;
00067C  B3C040     MOV.B #0x4, W0
00067E  B7E848     MOV.B WREG, i2c1_state
413:                                   //                    break;
414:                               } else {
415:                                   I2C1TRN = (uint8_t) (i2c_address & 0x00FF); //发送16位低地址 
000682  804160     MOV i2c_address, W0
000684  784000     MOV.B W0, W0
000686  FB8000     ZE W0, W0
000688  881010     MOV W0, I2C1TRN
416:                                   if (i2c_flag.F_WriteOrRead)//如果是读取指令的话
00068A  BFC830     MOV.B i2c_flag, WREG
00068C  604064     AND.B W0, #0x4, W0
00068E  E00400     CP0.B W0
000690  320008     BRA Z, 0x6A2
417:                                   {
418:                                       i2c_IsResart = 1;
000692  B3C010     MOV.B #0x1, W0
000694  B7E831     MOV.B WREG, i2c_IsResart
419:                                       //                        I2C1CONbits.RSEN = 1; // 发送启动条件
420:                                       i2c_operatcode |= 0x01; //将地址设置为读取
000696  804150     MOV i2c_operatcode, W0
000698  A00000     BSET W0, #0
00069A  884150     MOV W0, i2c_operatcode
421:                                       i2c1_state = S_MASTER_RESTART;
00069C  B3C010     MOV.B #0x1, W0
00069E  B7E848     MOV.B WREG, i2c1_state
422:                                   } else
423:                                       i2c1_state = S_MASTER_SEND_DATA;
0006A2  B3C030     MOV.B #0x3, W0
0006A4  B7E848     MOV.B WREG, i2c1_state
424:                               }
425:                           }
426:                           break;
000666  37008B     BRA 0x77E
000680  37007E     BRA 0x77E
0006A0  37006E     BRA 0x77E
0006A6  37006B     BRA 0x77E
427:                       }
428:                       case S_MASTER_SEND_DATA:
429:                       {
430:                           if (I2C1STATbits.ACKSTAT) {//如果检测到上次NACK
0006A8  801041     MOV I2C1STAT, W1
0006AA  280000     MOV #0x8000, W0
0006AC  608000     AND W1, W0, W0
0006AE  E00000     CP0 W0
0006B0  320006     BRA Z, 0x6BE
431:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
0006B2  A9E209     BCLR 0x209, #7
432:                               I2C1CONbits.PEN = 1; // 发送停止条件 
0006B4  A84206     BSET I2C1CON, #2
433:                               IFS1bits.MI2C1IF = 0; //清除标志
0006B6  A92086     BCLR IFS1, #1
434:                               i2c1_state = S_MASTER_Fail; //状态设置位空闲
0006B8  B3C0E0     MOV.B #0xE, W0
0006BA  B7E848     MOV.B WREG, i2c1_state
0006BC  370015     BRA 0x6E8
435:                           } else {
436:                               if (i2c_bytes_left-- == 0U) {//判断数据是否发送完毕
0006BE  BFC829     MOV.B i2c_bytes_left, WREG
0006C0  FB8080     ZE W0, W1
0006C2  E90081     DEC W1, W1
0006C4  DE08CF     LSR W1, #15, W1
0006C6  784081     MOV.B W1, W1
0006C8  E94000     DEC.B W0, W0
0006CA  B7E829     MOV.B WREG, i2c_bytes_left
0006CC  E00401     CP0.B W1
0006CE  320005     BRA Z, 0x6DA
437:                                   I2C1CONbits.PEN = 1; // I2C STOP control bit.   
0006D0  A84206     BSET I2C1CON, #2
438:                                   IFS1bits.MI2C1IF = 0; //清除标志
0006D2  A92086     BCLR IFS1, #1
439:                                   i2c1_state = S_MASTER_SEND_STOP; //状态设置为空闲
0006D4  B3C060     MOV.B #0x6, W0
0006D6  B7E848     MOV.B WREG, i2c1_state
440:                               } else {
441:                                   I2C1TRN = *pi2c_buf_ptr++; //发送数据
0006DA  804170     MOV pi2c_buf_ptr, W0
0006DC  784090     MOV.B [W0], W1
0006DE  FB8081     ZE W1, W1
0006E0  881011     MOV W1, I2C1TRN
0006E2  E80000     INC W0, W0
0006E4  884170     MOV W0, pi2c_buf_ptr
442:                               }
443:                               break;
0006D8  370052     BRA 0x77E
0006E6  37004B     BRA 0x77E
444:                           }
445:                       }
446:                       case S_MASTER_ACK_ADDR://如果是读操作的话，
447:                       {
448:                           if (I2C1STATbits.ACKSTAT) { //如果上次检测到NACK
0006E8  801041     MOV I2C1STAT, W1
0006EA  280000     MOV #0x8000, W0
0006EC  608000     AND W1, W0, W0
0006EE  E00000     CP0 W0
0006F0  320006     BRA Z, 0x6FE
449:                               I2C1CONbits.PEN = 1; //启动停止条件
0006F2  A84206     BSET I2C1CON, #2
450:                               IFS1bits.MI2C1IF = 0; //清除标志
0006F4  A92086     BCLR IFS1, #1
451:                               i2c1_state = S_MASTER_Fail;
0006F6  B3C0E0     MOV.B #0xE, W0
0006F8  B7E848     MOV.B WREG, i2c1_state
452:                               I2C1STATbits.ACKSTAT = 0; //复位ACK
0006FA  A9E209     BCLR 0x209, #7
453:                           } else {
454:                               I2C1CONbits.RCEN = 1; //启动接受
0006FE  A86206     BSET I2C1CON, #3
455:                               i2c1_state = S_MASTER_ACK_RCV_DATA; //状态为设置为接受数据
000700  B3C0A0     MOV.B #0xA, W0
000702  B7E848     MOV.B WREG, i2c1_state
456:                           }
457:                           break;
0006FC  370040     BRA 0x77E
000704  37003C     BRA 0x77E
458:                       }
459:                       case S_MASTER_RCV_DATA:
460:                       {
461:                           i2c1_state = S_MASTER_ACK_RCV_DATA; //发送接受数据ACK
000706  B3C0A0     MOV.B #0xA, W0
000708  B7E848     MOV.B WREG, i2c1_state
462:                           I2C1CONbits.RCEN = 1; //使能接收
00070A  A86206     BSET I2C1CON, #3
463:                           break;
00070C  370038     BRA 0x77E
464:                       }
465:                       case S_MASTER_ACK_RCV_DATA:
466:                       {
467:                           *pi2c_buf_ptr++ = I2C1RCV; //接收数据
00070E  804170     MOV pi2c_buf_ptr, W0
000710  801001     MOV I2C1RCV, W1
000712  784081     MOV.B W1, W1
000714  784801     MOV.B W1, [W0]
000716  E80000     INC W0, W0
000718  884170     MOV W0, pi2c_buf_ptr
468:                           if (--i2c_bytes_left) {
00071A  BFC829     MOV.B i2c_bytes_left, WREG
00071C  E94000     DEC.B W0, W0
00071E  B7E829     MOV.B WREG, i2c_bytes_left
000720  BFC829     MOV.B i2c_bytes_left, WREG
000722  E00400     CP0.B W0
000724  320004     BRA Z, 0x72E
469:                               I2C1CONbits.ACKDT = 0; //发送ACK
000726  A9A206     BCLR I2C1CON, #5
470:                               i2c1_state = S_MASTER_RCV_DATA; //启动接收
000728  B3C080     MOV.B #0x8, W0
00072A  B7E848     MOV.B WREG, i2c1_state
00072C  370003     BRA 0x734
471:                           } else {
472:               
473:                               // Yes, it's the last byte.  Don't ack it
474:                               // Flag that we will nak the data
475:                               I2C1CONbits.ACKDT = 1; // I2C ACK data control bit.
00072E  A8A206     BSET I2C1CON, #5
476:               
477:                               //            I2C1_FunctionComplete();
478:                               i2c1_state = S_MASTER_RCV_STOP;
000730  B3C090     MOV.B #0x9, W0
000732  B7E848     MOV.B WREG, i2c1_state
479:                               //                break; //退出接收
480:                           }
481:               
482:                           // Initiate the acknowledge
483:                           I2C1CONbits.ACKEN = 1; // I2C 发送ACK .
000734  A88206     BSET I2C1CON, #4
484:                           break;
000736  370023     BRA 0x77E
485:                       }
486:                       case S_MASTER_RCV_STOP:
487:                       {
488:                           I2C1CONbits.ACKDT = 0;
000738  A9A206     BCLR I2C1CON, #5
489:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
00073A  A84206     BSET I2C1CON, #2
490:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
491:                           i2c1_state = S_MASTER_Finish;
00073C  B3C0D0     MOV.B #0xD, W0
00073E  B7E848     MOV.B WREG, i2c1_state
492:                           break;
000740  37001E     BRA 0x77E
493:                       }
494:                       case S_MASTER_SEND_STOP:
495:                       {
496:                           I2C1CONbits.PEN = 1; // I2C STOP control bit.   
000742  A84206     BSET I2C1CON, #2
497:                           //            IFS1bits.MI2C1IF = 0; //清除标志 
498:                           i2c1_state = S_MASTER_Finish;
000744  B3C0D0     MOV.B #0xD, W0
000746  B7E848     MOV.B WREG, i2c1_state
499:                           break;
000748  37001A     BRA 0x77E
500:                       }
501:                       case S_MASTER_Finish:
502:                       {
503:                           i2c_operatcode = 0;
00074A  EF282A     CLR i2c_operatcode
504:                           pi2c_buf_ptr = NULL;
00074C  EF282E     CLR pi2c_buf_ptr
505:                           i2c_address = 0;
00074E  EF282C     CLR i2c_address
506:                           i2c_bytes_left = 0;
000750  EF6829     CLR.B i2c_bytes_left
507:                           i2c_flag.F_Is16bitsDevice = i2c_flag.F_IsSelectiveMode = i2c_flag.F_WriteOrRead = 0;
000752  A94830     BCLR i2c_flag, #2
000754  804180     MOV i2c_flag, W0
000756  DE0042     LSR W0, #2, W0
000758  604061     AND.B W0, #0x1, W0
00075A  604061     AND.B W0, #0x1, W0
00075C  208301     MOV #0x830, W1
00075E  784091     MOV.B [W1], W1
000760  A10401     BCLR.B W1, #0
000762  70C000     IOR.B W1, W0, W0
000764  B7E830     MOV.B WREG, i2c_flag
000766  804180     MOV i2c_flag, W0
000768  604061     AND.B W0, #0x1, W0
00076A  604061     AND.B W0, #0x1, W0
00076C  404000     ADD.B W0, W0, W0
00076E  208301     MOV #0x830, W1
000770  784091     MOV.B [W1], W1
000772  A11401     BCLR.B W1, #1
000774  70C000     IOR.B W1, W0, W0
000776  B7E830     MOV.B WREG, i2c_flag
508:                           i2c_IsResart = 0; //设备是否重启
000778  EF6831     CLR.B i2c_IsResart
509:                           break;
00077A  370001     BRA 0x77E
510:                       }
511:               
512:                           //        default:
513:                           //
514:                           //            // This case should not happen, if it does then
515:                           //            // terminate the transfer
516:                           //            //    i2c1_object.i2cErrors++;
517:                           //        {
518:                           //            I2C1CONbits.PEN = 1; // I2C STOP control bit.  
519:                           //            //            IFS1bits.MI2C1IF = 0; //清除标志
520:                           //            //            i2c1_state = S_MASTER_IDLE;
521:                           //            break;
522:                           //        }
523:                   }
524:                   //    OSIntExit();
525:                   IFS1bits.MI2C1IF = 0; //清楚中断标志位
00077E  A92086     BCLR IFS1, #1
526:               }
000780  FA8000     ULNK
527:               
528:               
529:               
530:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/LCD.c  ---------------------------------------
1:                 #include <time.h>
2:                 #include "LCD.h"
3:                 
4:                 union LCD_FLAGBITS W_LCDCON;
5:                 
6:                 //数字符号
7:                 const uint8_t LCD_NUM[10][8] = {
8:                     {N1A, N1B, N1C, N1D, N1E, N1F, 0xFF, N1G}, //[0]0xFF后面数据为HIDE
9:                     {N1B, N1C, 0xFF, N1A, N1D, N1E, N1F, N1G}, //[1]
10:                    {N1A, N1B, N1G, N1E, N1D, 0xFF, N1C, N1F}, //[2]
11:                    {N1A, N1B, N1C, N1D, N1G, 0xFF, N1E, N1F}, //[3]
12:                    {N1B, N1C, N1F, N1G, 0xFF, N1A, N1D, N1E}, //[4]
13:                    {N1A, N1C, N1D, N1F, N1G, 0xFF, N1B, N1E}, //[5]
14:                    {N1A, N1C, N1D, N1E, N1F, N1G, 0xFF, N1B}, //[6]
15:                    {N1A, N1B, N1C, 0xFF, N1D, N1E, N1F, N1G}, //[7]
16:                    {N1A, N1B, N1C, N1D, N1E, N1F, N1G, 0xFF}, //[8]
17:                    {N1A, N1B, N1C, N1D, N1F, N1G, 0xFF, N1E}, //[9]
18:                    //    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, //[10]
19:                };
20:                //数字偏移量
21:                const uint8_t LCD_NUM_OFFSET[7] = {0, 2, 8, 10, 12, 14, 16};
22:                
23:                static void LCD_Show(uint8_t value, bool operation);
24:                static void NUM_SHOW(uint8_t num, uint8_t pos);
25:                
26:                void LCD_Init(void) {
0018C6  FA0000     LNK #0x0
27:                    LCDSE0 = 0xFFFF; //设置SEG0-15为段驱动引脚
0018C8  EB8000     SETM W0
0018CA  882C40     MOV W0, LCDSE0
28:                    LCDSE1 = 0x0003; //设置SEG16-17为段驱动引脚
0018CC  200030     MOV #0x3, W0
0018CE  882C50     MOV W0, LCDSE1
29:                    LCDDATA0 = LCDDATA1 = LCDDATA4 = LCDDATA5 = 0;
0018D0  EF259A     CLR LCDDATA5
0018D2  802CD0     MOV LCDDATA5, W0
0018D4  882CC0     MOV W0, LCDDATA4
0018D6  802CC0     MOV LCDDATA4, W0
0018D8  882C90     MOV W0, LCDDATA1
0018DA  802C90     MOV LCDDATA1, W0
0018DC  882C80     MOV W0, LCDDATA0
30:                    LCDDATA8 = LCDDATA9 = LCDDATA16 = LCDDATA17 = 0;
0018DE  EF25B2     CLR LCDDATA17
0018E0  802D90     MOV LCDDATA17, W0
0018E2  882D80     MOV W0, LCDDATA16
0018E4  802D80     MOV LCDDATA16, W0
0018E6  882D10     MOV W0, LCDDATA9
0018E8  802D10     MOV LCDDATA9, W0
0018EA  882D00     MOV W0, LCDDATA8
31:                    LCDREG = 0x0004;
0018EC  200040     MOV #0x4, W0
0018EE  882C00     MOV W0, LCDREG
32:                    //	LCDREF=0x07F0;  //external
33:                    LCDREF = 0x80FF; //internal regsistor ladder
0018F0  280FF0     MOV #0x80FF, W0
0018F2  882C10     MOV W0, LCDREF
34:                    LCDPS = 0x0002;
0018F4  200020     MOV #0x2, W0
0018F6  882C30     MOV W0, LCDPS
35:                    LCDREFbits.LCDCST = 0;
0018F8  802C11     MOV LCDREF, W1
0018FA  2C7FF0     MOV #0xC7FF, W0
0018FC  608000     AND W1, W0, W0
0018FE  882C10     MOV W0, LCDREF
36:                    LCDCON = 0x800B; // 4 common
001900  2800B0     MOV #0x800B, W0
001902  882C20     MOV W0, LCDCON
37:                }
001904  FA8000     ULNK
001906  060000     RETURN
38:                
39:                //void LCD_ShowTest(void) {
40:                //    LCD_Show(8, 0); //25
41:                //    Delay1s(1);
42:                //}
43:                
44:                void LCD_ShowTest(uint8_t value, bool operation) {
001908  FA0002     LNK #0x2
00190A  784F00     MOV.B W0, [W14]
00190C  984711     MOV.B W1, [W14+1]
45:                    LCD_Show(value, operation); //25
00190E  90409E     MOV.B [W14+1], W1
001910  78401E     MOV.B [W14], W0
001912  070002     RCALL _LCD_Show
46:                    //    Delay1s(1);
47:                }
001914  FA8000     ULNK
001916  060000     RETURN
48:                //子函数
49:                
50:                static void LCD_Show(uint8_t value, bool operation) {
001918  FA0004     LNK #0x4
00191A  984720     MOV.B W0, [W14+2]
00191C  984731     MOV.B W1, [W14+3]
51:                    uint8_t com = value / SegCnt; //获取公共码
00191E  90402E     MOV.B [W14+2], W0
001920  FB8080     ZE W0, W1
001922  200120     MOV #0x12, W0
001924  780100     MOV W0, W2
001926  090011     REPEAT #0x11
001928  D88082     DIV.UW W1, W2
00192A  784F00     MOV.B W0, [W14]
52:                    uint8_t seg = value % SegCnt; //获取段码
00192C  90402E     MOV.B [W14+2], W0
00192E  FB8080     ZE W0, W1
001930  200120     MOV #0x12, W0
001932  780100     MOV W0, W2
001934  090011     REPEAT #0x11
001936  D88082     DIV.UW W1, W2
001938  FD0080     EXCH W0, W1
00193A  984710     MOV.B W0, [W14+1]
53:                
54:                    switch (com) {
00193C  FB801E     ZE [W14], W0
00193E  500FE1     SUB W0, #0x1, [W15]
001940  320039     BRA Z, 0x19B4
001942  500FE1     SUB W0, #0x1, [W15]
001944  3C0003     BRA GT, 0x194C
001946  E00000     CP0 W0
001948  320006     BRA Z, 0x1956
00194A  3700C1     BRA 0x1ACE
00194C  500FE2     SUB W0, #0x2, [W15]
00194E  320061     BRA Z, 0x1A12
001950  500FE3     SUB W0, #0x3, [W15]
001952  32008E     BRA Z, 0x1A70
001954  3700BC     BRA 0x1ACE
55:                        case COM0:
56:                        {
57:                            if (seg > 15)
001956  90401E     MOV.B [W14+1], W0
001958  504FEF     SUB.B W0, #0xF, [W15]
00195A  360017     BRA LEU, 0x198A
58:                                LCD_Set(1, seg % 16, operation);
00195C  90403E     MOV.B [W14+3], W0
00195E  E00400     CP0.B W0
001960  320009     BRA Z, 0x1974
001962  90401E     MOV.B [W14+1], W0
001964  FB8000     ZE W0, W0
001966  60006F     AND W0, #0xF, W0
001968  200011     MOV #0x1, W1
00196A  DD0800     SL W1, W0, W0
00196C  780080     MOV W0, W1
00196E  802C90     MOV LCDDATA1, W0
001970  700001     IOR W0, W1, W0
001972  370009     BRA 0x1986
001974  90401E     MOV.B [W14+1], W0
001976  FB8000     ZE W0, W0
001978  60006F     AND W0, #0xF, W0
00197A  200011     MOV #0x1, W1
00197C  DD0800     SL W1, W0, W0
00197E  EA8000     COM W0, W0
001980  780080     MOV W0, W1
001982  802C90     MOV LCDDATA1, W0
001984  608000     AND W1, W0, W0
001986  882C90     MOV W0, LCDDATA1
59:                            else
60:                                LCD_Set(0, seg, operation);
00198A  90403E     MOV.B [W14+3], W0
00198C  E00400     CP0.B W0
00198E  320008     BRA Z, 0x19A0
001990  90401E     MOV.B [W14+1], W0
001992  FB8000     ZE W0, W0
001994  200011     MOV #0x1, W1
001996  DD0800     SL W1, W0, W0
001998  780080     MOV W0, W1
00199A  802C80     MOV LCDDATA0, W0
00199C  700001     IOR W0, W1, W0
00199E  370008     BRA 0x19B0
0019A0  90401E     MOV.B [W14+1], W0
0019A2  FB8000     ZE W0, W0
0019A4  200011     MOV #0x1, W1
0019A6  DD0800     SL W1, W0, W0
0019A8  EA8000     COM W0, W0
0019AA  780080     MOV W0, W1
0019AC  802C80     MOV LCDDATA0, W0
0019AE  608000     AND W1, W0, W0
0019B0  882C80     MOV W0, LCDDATA0
61:                            break;
001988  3700A2     BRA 0x1ACE
0019B2  37008D     BRA 0x1ACE
62:                        }
63:                        case COM1:
64:                        {
65:                            if (seg > 15)
0019B4  90401E     MOV.B [W14+1], W0
0019B6  504FEF     SUB.B W0, #0xF, [W15]
0019B8  360017     BRA LEU, 0x19E8
66:                                LCD_Set(5, seg % 16, operation);
0019BA  90403E     MOV.B [W14+3], W0
0019BC  E00400     CP0.B W0
0019BE  320009     BRA Z, 0x19D2
0019C0  90401E     MOV.B [W14+1], W0
0019C2  FB8000     ZE W0, W0
0019C4  60006F     AND W0, #0xF, W0
0019C6  200011     MOV #0x1, W1
0019C8  DD0800     SL W1, W0, W0
0019CA  780080     MOV W0, W1
0019CC  802CD0     MOV LCDDATA5, W0
0019CE  700001     IOR W0, W1, W0
0019D0  370009     BRA 0x19E4
0019D2  90401E     MOV.B [W14+1], W0
0019D4  FB8000     ZE W0, W0
0019D6  60006F     AND W0, #0xF, W0
0019D8  200011     MOV #0x1, W1
0019DA  DD0800     SL W1, W0, W0
0019DC  EA8000     COM W0, W0
0019DE  780080     MOV W0, W1
0019E0  802CD0     MOV LCDDATA5, W0
0019E2  608000     AND W1, W0, W0
0019E4  882CD0     MOV W0, LCDDATA5
67:                            else
68:                                LCD_Set(4, seg, operation);
0019E8  90403E     MOV.B [W14+3], W0
0019EA  E00400     CP0.B W0
0019EC  320008     BRA Z, 0x19FE
0019EE  90401E     MOV.B [W14+1], W0
0019F0  FB8000     ZE W0, W0
0019F2  200011     MOV #0x1, W1
0019F4  DD0800     SL W1, W0, W0
0019F6  780080     MOV W0, W1
0019F8  802CC0     MOV LCDDATA4, W0
0019FA  700001     IOR W0, W1, W0
0019FC  370008     BRA 0x1A0E
0019FE  90401E     MOV.B [W14+1], W0
001A00  FB8000     ZE W0, W0
001A02  200011     MOV #0x1, W1
001A04  DD0800     SL W1, W0, W0
001A06  EA8000     COM W0, W0
001A08  780080     MOV W0, W1
001A0A  802CC0     MOV LCDDATA4, W0
001A0C  608000     AND W1, W0, W0
001A0E  882CC0     MOV W0, LCDDATA4
69:                            break;
0019E6  370073     BRA 0x1ACE
001A10  37005E     BRA 0x1ACE
70:                        }
71:                        case COM2:
72:                        {
73:                            if (seg > 15)
001A12  90401E     MOV.B [W14+1], W0
001A14  504FEF     SUB.B W0, #0xF, [W15]
001A16  360017     BRA LEU, 0x1A46
74:                                LCD_Set(9, seg % 16, operation);
001A18  90403E     MOV.B [W14+3], W0
001A1A  E00400     CP0.B W0
001A1C  320009     BRA Z, 0x1A30
001A1E  90401E     MOV.B [W14+1], W0
001A20  FB8000     ZE W0, W0
001A22  60006F     AND W0, #0xF, W0
001A24  200011     MOV #0x1, W1
001A26  DD0800     SL W1, W0, W0
001A28  780080     MOV W0, W1
001A2A  802D10     MOV LCDDATA9, W0
001A2C  700001     IOR W0, W1, W0
001A2E  370009     BRA 0x1A42
001A30  90401E     MOV.B [W14+1], W0
001A32  FB8000     ZE W0, W0
001A34  60006F     AND W0, #0xF, W0
001A36  200011     MOV #0x1, W1
001A38  DD0800     SL W1, W0, W0
001A3A  EA8000     COM W0, W0
001A3C  780080     MOV W0, W1
001A3E  802D10     MOV LCDDATA9, W0
001A40  608000     AND W1, W0, W0
001A42  882D10     MOV W0, LCDDATA9
75:                            else
76:                                LCD_Set(8, seg, operation);
001A46  90403E     MOV.B [W14+3], W0
001A48  E00400     CP0.B W0
001A4A  320008     BRA Z, 0x1A5C
001A4C  90401E     MOV.B [W14+1], W0
001A4E  FB8000     ZE W0, W0
001A50  200011     MOV #0x1, W1
001A52  DD0800     SL W1, W0, W0
001A54  780080     MOV W0, W1
001A56  802D00     MOV LCDDATA8, W0
001A58  700001     IOR W0, W1, W0
001A5A  370008     BRA 0x1A6C
001A5C  90401E     MOV.B [W14+1], W0
001A5E  FB8000     ZE W0, W0
001A60  200011     MOV #0x1, W1
001A62  DD0800     SL W1, W0, W0
001A64  EA8000     COM W0, W0
001A66  780080     MOV W0, W1
001A68  802D00     MOV LCDDATA8, W0
001A6A  608000     AND W1, W0, W0
001A6C  882D00     MOV W0, LCDDATA8
77:                            break;
001A44  370044     BRA 0x1ACE
001A6E  37002F     BRA 0x1ACE
78:                        }
79:                        case COM3:
80:                        {
81:                            if (seg > 15)
001A70  90401E     MOV.B [W14+1], W0
001A72  504FEF     SUB.B W0, #0xF, [W15]
001A74  360017     BRA LEU, 0x1AA4
82:                                LCD_Set(13, seg % 16, operation);
001A76  90403E     MOV.B [W14+3], W0
001A78  E00400     CP0.B W0
001A7A  320009     BRA Z, 0x1A8E
001A7C  90401E     MOV.B [W14+1], W0
001A7E  FB8000     ZE W0, W0
001A80  60006F     AND W0, #0xF, W0
001A82  200011     MOV #0x1, W1
001A84  DD0800     SL W1, W0, W0
001A86  780080     MOV W0, W1
001A88  802D50     MOV LCDDATA13, W0
001A8A  700001     IOR W0, W1, W0
001A8C  370009     BRA 0x1AA0
001A8E  90401E     MOV.B [W14+1], W0
001A90  FB8000     ZE W0, W0
001A92  60006F     AND W0, #0xF, W0
001A94  200011     MOV #0x1, W1
001A96  DD0800     SL W1, W0, W0
001A98  EA8000     COM W0, W0
001A9A  780080     MOV W0, W1
001A9C  802D50     MOV LCDDATA13, W0
001A9E  608000     AND W1, W0, W0
001AA0  882D50     MOV W0, LCDDATA13
83:                            else
84:                                LCD_Set(12, seg, operation);
001AA4  90403E     MOV.B [W14+3], W0
001AA6  E00400     CP0.B W0
001AA8  320008     BRA Z, 0x1ABA
001AAA  90401E     MOV.B [W14+1], W0
001AAC  FB8000     ZE W0, W0
001AAE  200011     MOV #0x1, W1
001AB0  DD0800     SL W1, W0, W0
001AB2  780080     MOV W0, W1
001AB4  802D40     MOV LCDDATA12, W0
001AB6  700001     IOR W0, W1, W0
001AB8  370008     BRA 0x1ACA
001ABA  90401E     MOV.B [W14+1], W0
001ABC  FB8000     ZE W0, W0
001ABE  200011     MOV #0x1, W1
001AC0  DD0800     SL W1, W0, W0
001AC2  EA8000     COM W0, W0
001AC4  780080     MOV W0, W1
001AC6  802D40     MOV LCDDATA12, W0
001AC8  608000     AND W1, W0, W0
001ACA  882D40     MOV W0, LCDDATA12
85:                            break;
001AA2  370015     BRA 0x1ACE
001ACC  000000     NOP
86:                        }
87:                    }
88:                }
001ACE  FA8000     ULNK
001AD0  060000     RETURN
89:                
90:                static void NUM_SHOW(uint8_t num, uint8_t pos) {
001AD2  FA0004     LNK #0x4
001AD4  984720     MOV.B W0, [W14+2]
001AD6  984731     MOV.B W1, [W14+3]
91:                    uint8_t cnt; //, tmp; //, offset = pos * 2;
92:                    bool show_or_hide = SHOW;
001AD8  B3C010     MOV.B #0x1, W0
001ADA  984710     MOV.B W0, [W14+1]
93:                    //    bool IsHideflag = false;
94:                    for (cnt = 0; cnt < 8; cnt++) {
001ADC  EB4000     CLR.B W0
001ADE  784F00     MOV.B W0, [W14]
001AE0  370026     BRA 0x1B2E
001B2C  E84F1E     INC.B [W14], [W14]
001B2E  78401E     MOV.B [W14], W0
001B30  504FE7     SUB.B W0, #0x7, [W15]
001B32  36FFD7     BRA LEU, 0x1AE2
95:                        if ((LCD_NUM[num][cnt] == 0xff) && show_or_hide)//如果已经找到了OxFF，则接下来的数据都是隐藏,并且跳过0xff
001AE2  90402E     MOV.B [W14+2], W0
001AE4  FB8080     ZE W0, W1
001AE6  FB801E     ZE [W14], W0
001AE8  DD08C3     SL W1, #3, W1
001AEA  408000     ADD W1, W0, W0
001AEC  2902C1     MOV #0x902C, W1
001AEE  784061     MOV.B [W1+W0], W0
001AF0  404FE1     ADD.B W0, #0x1, [W15]
001AF2  3A0006     BRA NZ, 0x1B00
001AF4  90401E     MOV.B [W14+1], W0
001AF6  E00400     CP0.B W0
001AF8  320003     BRA Z, 0x1B00
96:                        {
97:                            show_or_hide = HIDE;
001AFA  EB4000     CLR.B W0
001AFC  984710     MOV.B W0, [W14+1]
98:                            continue;
001AFE  370016     BRA 0x1B2C
99:                        }
100:                       //        tmp = (LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72;
101:                       LCD_Show((LCD_NUM[num][cnt] + LCD_NUM_OFFSET[pos]) % 72, show_or_hide);
001B00  90402E     MOV.B [W14+2], W0
001B02  FB8080     ZE W0, W1
001B04  FB801E     ZE [W14], W0
001B06  DD08C3     SL W1, #3, W1
001B08  408000     ADD W1, W0, W0
001B0A  2902C1     MOV #0x902C, W1
001B0C  784061     MOV.B [W1+W0], W0
001B0E  FB8080     ZE W0, W1
001B10  90403E     MOV.B [W14+3], W0
001B12  FB8000     ZE W0, W0
001B14  2907C2     MOV #0x907C, W2
001B16  784062     MOV.B [W2+W0], W0
001B18  FB8000     ZE W0, W0
001B1A  408080     ADD W1, W0, W1
001B1C  200480     MOV #0x48, W0
001B1E  780100     MOV W0, W2
001B20  090011     REPEAT #0x11
001B22  D80082     DIV.SW W1, W2
001B24  FD0080     EXCH W0, W1
001B26  784000     MOV.B W0, W0
001B28  90409E     MOV.B [W14+1], W1
001B2A  07FEF6     RCALL _LCD_Show
102:                   }
103:               }
001B34  FA8000     ULNK
001B36  060000     RETURN
104:               
105:               void BAT_SHOW(uint8_t bat) {
001B38  FA0002     LNK #0x2
001B3A  784F00     MOV.B W0, [W14]
106:                   switch (bat) {
001B3C  FB801E     ZE [W14], W0
001B3E  500FE1     SUB W0, #0x1, [W15]
001B40  320017     BRA Z, 0x1B70
001B42  500FE1     SUB W0, #0x1, [W15]
001B44  3C0003     BRA GT, 0x1B4C
001B46  E00000     CP0 W0
001B48  320006     BRA Z, 0x1B56
001B4A  370039     BRA 0x1BBE
001B4C  500FE2     SUB W0, #0x2, [W15]
001B4E  32001D     BRA Z, 0x1B8A
001B50  500FE3     SUB W0, #0x3, [W15]
001B52  320028     BRA Z, 0x1BA4
001B54  370034     BRA 0x1BBE
107:                       case 0:
108:                       {
109:                           LCD_Show(B_0, SHOW);
001B56  B3C011     MOV.B #0x1, W1
001B58  B3C3B0     MOV.B #0x3B, W0
001B5A  07FEDE     RCALL _LCD_Show
110:                           LCD_Show(B_1, HIDE);
001B5C  EB4080     CLR.B W1
001B5E  B3C290     MOV.B #0x29, W0
001B60  07FEDB     RCALL _LCD_Show
111:                           LCD_Show(B_2, HIDE);
001B62  EB4080     CLR.B W1
001B64  B3C170     MOV.B #0x17, W0
001B66  07FED8     RCALL _LCD_Show
112:                           LCD_Show(B_3, HIDE);
001B68  EB4080     CLR.B W1
001B6A  B3C050     MOV.B #0x5, W0
001B6C  07FED5     RCALL _LCD_Show
113:                           break;
001B6E  370034     BRA 0x1BD8
114:                       }
115:                       case 1:
116:                       {
117:                           LCD_Show(B_0, SHOW);
001B70  B3C011     MOV.B #0x1, W1
001B72  B3C3B0     MOV.B #0x3B, W0
001B74  07FED1     RCALL _LCD_Show
118:                           LCD_Show(B_1, SHOW);
001B76  B3C011     MOV.B #0x1, W1
001B78  B3C290     MOV.B #0x29, W0
001B7A  07FECE     RCALL _LCD_Show
119:                           LCD_Show(B_2, HIDE);
001B7C  EB4080     CLR.B W1
001B7E  B3C170     MOV.B #0x17, W0
001B80  07FECB     RCALL _LCD_Show
120:                           LCD_Show(B_3, HIDE);
001B82  EB4080     CLR.B W1
001B84  B3C050     MOV.B #0x5, W0
001B86  07FEC8     RCALL _LCD_Show
121:                           break;
001B88  370027     BRA 0x1BD8
122:                       }
123:                       case 2:
124:                       {
125:                           LCD_Show(B_0, SHOW);
001B8A  B3C011     MOV.B #0x1, W1
001B8C  B3C3B0     MOV.B #0x3B, W0
001B8E  07FEC4     RCALL _LCD_Show
126:                           LCD_Show(B_1, SHOW);
001B90  B3C011     MOV.B #0x1, W1
001B92  B3C290     MOV.B #0x29, W0
001B94  07FEC1     RCALL _LCD_Show
127:                           LCD_Show(B_2, SHOW);
001B96  B3C011     MOV.B #0x1, W1
001B98  B3C170     MOV.B #0x17, W0
001B9A  07FEBE     RCALL _LCD_Show
128:                           LCD_Show(B_3, HIDE);
001B9C  EB4080     CLR.B W1
001B9E  B3C050     MOV.B #0x5, W0
001BA0  07FEBB     RCALL _LCD_Show
129:                           break;
001BA2  37001A     BRA 0x1BD8
130:                       }
131:                       case 3:
132:                       {
133:                           LCD_Show(B_0, SHOW);
001BA4  B3C011     MOV.B #0x1, W1
001BA6  B3C3B0     MOV.B #0x3B, W0
001BA8  07FEB7     RCALL _LCD_Show
134:                           LCD_Show(B_1, SHOW);
001BAA  B3C011     MOV.B #0x1, W1
001BAC  B3C290     MOV.B #0x29, W0
001BAE  07FEB4     RCALL _LCD_Show
135:                           LCD_Show(B_2, SHOW);
001BB0  B3C011     MOV.B #0x1, W1
001BB2  B3C170     MOV.B #0x17, W0
001BB4  07FEB1     RCALL _LCD_Show
136:                           LCD_Show(B_3, SHOW);
001BB6  B3C011     MOV.B #0x1, W1
001BB8  B3C050     MOV.B #0x5, W0
001BBA  07FEAE     RCALL _LCD_Show
137:                           break;
001BBC  37000D     BRA 0x1BD8
138:                       }
139:                       default:
140:                       {
141:                           LCD_Show(B_0, HIDE);
001BBE  EB4080     CLR.B W1
001BC0  B3C3B0     MOV.B #0x3B, W0
001BC2  07FEAA     RCALL _LCD_Show
142:                           LCD_Show(B_1, HIDE);
001BC4  EB4080     CLR.B W1
001BC6  B3C290     MOV.B #0x29, W0
001BC8  07FEA7     RCALL _LCD_Show
143:                           LCD_Show(B_2, HIDE);
001BCA  EB4080     CLR.B W1
001BCC  B3C170     MOV.B #0x17, W0
001BCE  07FEA4     RCALL _LCD_Show
144:                           LCD_Show(B_3, HIDE);
001BD0  EB4080     CLR.B W1
001BD2  B3C050     MOV.B #0x5, W0
001BD4  07FEA1     RCALL _LCD_Show
145:                           break;
001BD6  000000     NOP
146:                       }
147:                   }
148:               }
001BD8  FA8000     ULNK
001BDA  060000     RETURN
149:               
150:               void SIGN_SHOW(uint8_t sign) {
001BDC  FA0002     LNK #0x2
001BDE  784F00     MOV.B W0, [W14]
151:                   switch (sign) {
001BE0  FB801E     ZE [W14], W0
001BE2  500FE2     SUB W0, #0x2, [W15]
001BE4  320017     BRA Z, 0x1C14
001BE6  500FE2     SUB W0, #0x2, [W15]
001BE8  3C0003     BRA GT, 0x1BF0
001BEA  500FE1     SUB W0, #0x1, [W15]
001BEC  320006     BRA Z, 0x1BFA
001BEE  370039     BRA 0x1C62
001BF0  500FE3     SUB W0, #0x3, [W15]
001BF2  32001D     BRA Z, 0x1C2E
001BF4  500FE4     SUB W0, #0x4, [W15]
001BF6  320028     BRA Z, 0x1C48
001BF8  370034     BRA 0x1C62
152:                       case 1:
153:                       {
154:                           LCD_Show(Sign0, SHOW);
001BFA  B3C011     MOV.B #0x1, W1
001BFC  B3C3C0     MOV.B #0x3C, W0
001BFE  07FE8C     RCALL _LCD_Show
155:                           LCD_Show(Sign1, HIDE);
001C00  EB4080     CLR.B W1
001C02  B3C2A0     MOV.B #0x2A, W0
001C04  07FE89     RCALL _LCD_Show
156:                           LCD_Show(Sign2, HIDE);
001C06  EB4080     CLR.B W1
001C08  B3C180     MOV.B #0x18, W0
001C0A  07FE86     RCALL _LCD_Show
157:                           LCD_Show(Sign3, HIDE);
001C0C  EB4080     CLR.B W1
001C0E  B3C060     MOV.B #0x6, W0
001C10  07FE83     RCALL _LCD_Show
158:                           break;
001C12  370034     BRA 0x1C7C
159:                       }
160:                       case 2:
161:                       {
162:                           LCD_Show(Sign0, SHOW);
001C14  B3C011     MOV.B #0x1, W1
001C16  B3C3C0     MOV.B #0x3C, W0
001C18  07FE7F     RCALL _LCD_Show
163:                           LCD_Show(Sign1, SHOW);
001C1A  B3C011     MOV.B #0x1, W1
001C1C  B3C2A0     MOV.B #0x2A, W0
001C1E  07FE7C     RCALL _LCD_Show
164:                           LCD_Show(Sign2, HIDE);
001C20  EB4080     CLR.B W1
001C22  B3C180     MOV.B #0x18, W0
001C24  07FE79     RCALL _LCD_Show
165:                           LCD_Show(Sign3, HIDE);
001C26  EB4080     CLR.B W1
001C28  B3C060     MOV.B #0x6, W0
001C2A  07FE76     RCALL _LCD_Show
166:                           break;
001C2C  370027     BRA 0x1C7C
167:                       }
168:                       case 3:
169:                       {
170:                           LCD_Show(Sign0, SHOW);
001C2E  B3C011     MOV.B #0x1, W1
001C30  B3C3C0     MOV.B #0x3C, W0
001C32  07FE72     RCALL _LCD_Show
171:                           LCD_Show(Sign1, SHOW);
001C34  B3C011     MOV.B #0x1, W1
001C36  B3C2A0     MOV.B #0x2A, W0
001C38  07FE6F     RCALL _LCD_Show
172:                           LCD_Show(Sign2, SHOW);
001C3A  B3C011     MOV.B #0x1, W1
001C3C  B3C180     MOV.B #0x18, W0
001C3E  07FE6C     RCALL _LCD_Show
173:                           LCD_Show(Sign3, HIDE);
001C40  EB4080     CLR.B W1
001C42  B3C060     MOV.B #0x6, W0
001C44  07FE69     RCALL _LCD_Show
174:                           break;
001C46  37001A     BRA 0x1C7C
175:                       }
176:                       case 4:
177:                       {
178:                           LCD_Show(Sign0, SHOW);
001C48  B3C011     MOV.B #0x1, W1
001C4A  B3C3C0     MOV.B #0x3C, W0
001C4C  07FE65     RCALL _LCD_Show
179:                           LCD_Show(Sign1, SHOW);
001C4E  B3C011     MOV.B #0x1, W1
001C50  B3C2A0     MOV.B #0x2A, W0
001C52  07FE62     RCALL _LCD_Show
180:                           LCD_Show(Sign2, SHOW);
001C54  B3C011     MOV.B #0x1, W1
001C56  B3C180     MOV.B #0x18, W0
001C58  07FE5F     RCALL _LCD_Show
181:                           LCD_Show(Sign3, SHOW);
001C5A  B3C011     MOV.B #0x1, W1
001C5C  B3C060     MOV.B #0x6, W0
001C5E  07FE5C     RCALL _LCD_Show
182:                           break;
001C60  37000D     BRA 0x1C7C
183:                       }
184:                       default:
185:                       {
186:                           LCD_Show(Sign0, HIDE);
001C62  EB4080     CLR.B W1
001C64  B3C3C0     MOV.B #0x3C, W0
001C66  07FE58     RCALL _LCD_Show
187:                           LCD_Show(Sign1, HIDE);
001C68  EB4080     CLR.B W1
001C6A  B3C2A0     MOV.B #0x2A, W0
001C6C  07FE55     RCALL _LCD_Show
188:                           LCD_Show(Sign2, HIDE);
001C6E  EB4080     CLR.B W1
001C70  B3C180     MOV.B #0x18, W0
001C72  07FE52     RCALL _LCD_Show
189:                           LCD_Show(Sign3, HIDE);
001C74  EB4080     CLR.B W1
001C76  B3C060     MOV.B #0x6, W0
001C78  07FE4F     RCALL _LCD_Show
190:                           break;
001C7A  000000     NOP
191:                       }
192:                   }
193:               }
001C7C  FA8000     ULNK
001C7E  060000     RETURN
194:               
195:               void NUMS_SHOW(uint32_t num, uint8_t all_show) {
001C80  FA000A     LNK #0xA
001C82  BE9F88     MOV.D W8, [W15++]
001C84  980720     MOV W0, [W14+4]
001C86  980731     MOV W1, [W14+6]
001C88  984F02     MOV.B W2, [W14+8]
196:                   char cnt; //
197:                   uint8_t num_tmp;
198:                   uint8_t IsFindHead = 0;
001C8A  EB4000     CLR.B W0
001C8C  984710     MOV.B W0, [W14+1]
199:                   //    uint8_t nums[7] = {0, 0, 0, 0, 0, 0, 0};
200:               
201:               //    ClrNum();
202:                   if (!num)
001C8E  90002E     MOV [W14+4], W0
001C90  9000BE     MOV [W14+6], W1
001C92  500FE0     SUB W0, #0x0, [W15]
001C94  588FE0     SUBB W1, #0x0, [W15]
001C96  3A0004     BRA NZ, 0x1CA0
203:                       NUM_SHOW(0, 0);
001C98  EB4080     CLR.B W1
001C9A  EB4000     CLR.B W0
001C9C  07FF1A     RCALL _NUM_SHOW
001C9E  37002B     BRA 0x1CF6
204:                   else
205:                       //获取数字位数
206:                       for (cnt = 6; cnt >= 0; cnt--) {
001CA0  B3C060     MOV.B #0x6, W0
001CA2  784F00     MOV.B W0, [W14]
001CA4  370025     BRA 0x1CF0
001CEE  E94F1E     DEC.B [W14], [W14]
001CF0  78401E     MOV.B [W14], W0
001CF2  E00400     CP0.B W0
001CF4  3DFFD8     BRA GE, 0x1CA6
207:                           num_tmp = (uint32_t) (num / pow(10, cnt)) % 10;
001CA6  90002E     MOV [W14+4], W0
001CA8  9000BE     MOV [W14+6], W1
001CAA  07F5CF     RCALL 0x84A
001CAC  BE0400     MOV.D W0, W8
001CAE  FB001E     SE [W14], W0
001CB0  DE80CF     ASR W0, #15, W1
001CB2  07F5C8     RCALL 0x844
001CB4  BE0100     MOV.D W0, W2
001CB6  200000     MOV #0x0, W0
001CB8  241201     MOV #0x4120, W1
001CBA  07F650     RCALL 0x95C
001CBC  BE0100     MOV.D W0, W2
001CBE  BE0008     MOV.D W8, W0
001CC0  07F564     RCALL 0x78A
001CC2  07F5A5     RCALL 0x80E
001CC4  2000A2     MOV #0xA, W2
001CC6  200003     MOV #0x0, W3
001CC8  07F73C     RCALL 0xB42
001CCA  984720     MOV.B W0, [W14+2]
208:                           if (num_tmp) {//如果字节为0的话，那么就pass
001CCC  90402E     MOV.B [W14+2], W0
001CCE  E00400     CP0.B W0
001CD0  320007     BRA Z, 0x1CE0
209:                               IsFindHead = 1;
001CD2  B3C010     MOV.B #0x1, W0
001CD4  984710     MOV.B W0, [W14+1]
210:                               NUM_SHOW(num_tmp, cnt);
001CD6  78401E     MOV.B [W14], W0
001CD8  784080     MOV.B W0, W1
001CDA  90402E     MOV.B [W14+2], W0
001CDC  07FEFA     RCALL _NUM_SHOW
001CDE  370007     BRA 0x1CEE
211:                           } else {
212:                               if (IsFindHead)
001CE0  90401E     MOV.B [W14+1], W0
001CE2  E00400     CP0.B W0
001CE4  320004     BRA Z, 0x1CEE
213:                                   NUM_SHOW(num_tmp, cnt);
001CE6  78401E     MOV.B [W14], W0
001CE8  784080     MOV.B W0, W1
001CEA  90402E     MOV.B [W14+2], W0
001CEC  07FEF2     RCALL _NUM_SHOW
214:                               //            else
215:                               //                NUM_SHOW(11, cnt);
216:                           }
217:                       }
218:               }
001CF6  BE044F     MOV.D [--W15], W8
001CF8  FA8000     ULNK
001CFA  060000     RETURN
219:               
220:               void TIME_SHOW(void) {
001CFC  FA0012     LNK #0x12
221:                   struct tm tmptr;
222:                   ClrNum();
001CFE  07007A     RCALL ClrNum
223:               
224:                   while (!RTC_Read_Time(&tmptr));
001D00  000000     NOP
001D02  78000E     MOV W14, W0
001D04  0703C5     RCALL RTC_Read_Time
001D06  E00000     CP0 W0
001D08  32FFFC     BRA Z, 0x1D02
225:                   //    time->tm_year;//显示小时
226:                   NUM_SHOW(tmptr.tm_hour >> 4, 5);
001D0A  90002E     MOV [W14+4], W0
001D0C  DE8044     ASR W0, #4, W0
001D0E  784000     MOV.B W0, W0
001D10  B3C051     MOV.B #0x5, W1
001D12  07FEDF     RCALL _NUM_SHOW
227:                   NUM_SHOW(GetMod(tmptr.tm_hour, 4), 4);
001D14  90002E     MOV [W14+4], W0
001D16  200041     MOV #0x4, W1
001D18  070301     RCALL GetMod
001D1A  784000     MOV.B W0, W0
001D1C  B3C041     MOV.B #0x4, W1
001D1E  07FED9     RCALL _NUM_SHOW
228:                   //    DP_SHOW(4);
229:                   NUM_SHOW(tmptr.tm_min >> 4, 3);
001D20  90001E     MOV [W14+2], W0
001D22  DE8044     ASR W0, #4, W0
001D24  784000     MOV.B W0, W0
001D26  B3C031     MOV.B #0x3, W1
001D28  07FED4     RCALL _NUM_SHOW
230:                   NUM_SHOW(GetMod(tmptr.tm_min, 4), 2);
001D2A  90001E     MOV [W14+2], W0
001D2C  200041     MOV #0x4, W1
001D2E  0702F6     RCALL GetMod
001D30  784000     MOV.B W0, W0
001D32  B3C021     MOV.B #0x2, W1
001D34  07FECE     RCALL _NUM_SHOW
231:                   //    DP_SHOW(2);
232:                   NUM_SHOW(tmptr.tm_sec >> 4, 1);
001D36  78001E     MOV [W14], W0
001D38  DE8044     ASR W0, #4, W0
001D3A  784000     MOV.B W0, W0
001D3C  B3C011     MOV.B #0x1, W1
001D3E  07FEC9     RCALL _NUM_SHOW
233:                   NUM_SHOW(GetMod(tmptr.tm_sec, 4), 0);
001D40  78001E     MOV [W14], W0
001D42  200041     MOV #0x4, W1
001D44  0702EB     RCALL GetMod
001D46  784000     MOV.B W0, W0
001D48  EB4080     CLR.B W1
001D4A  07FEC3     RCALL _NUM_SHOW
234:               }
001D4C  FA8000     ULNK
001D4E  060000     RETURN
235:               
236:               void DP_SHOW(uint8_t dp_pos) {
001D50  FA0002     LNK #0x2
001D52  784F00     MOV.B W0, [W14]
237:                   //显示小数点
238:                   switch (dp_pos) {
001D54  FB801E     ZE [W14], W0
001D56  500FE2     SUB W0, #0x2, [W15]
001D58  320017     BRA Z, 0x1D88
001D5A  500FE2     SUB W0, #0x2, [W15]
001D5C  3C0003     BRA GT, 0x1D64
001D5E  500FE1     SUB W0, #0x1, [W15]
001D60  320006     BRA Z, 0x1D6E
001D62  370039     BRA 0x1DD6
001D64  500FE3     SUB W0, #0x3, [W15]
001D66  32001D     BRA Z, 0x1DA2
001D68  500FE4     SUB W0, #0x4, [W15]
001D6A  320028     BRA Z, 0x1DBC
001D6C  370034     BRA 0x1DD6
239:                       case 1:
240:                       {
241:                           LCD_Show(P1, SHOW);
001D6E  B3C011     MOV.B #0x1, W1
001D70  B3C010     MOV.B #0x1, W0
001D72  07FDD2     RCALL _LCD_Show
242:                           LCD_Show(P2, HIDE);
001D74  EB4080     CLR.B W1
001D76  B3C030     MOV.B #0x3, W0
001D78  07FDCF     RCALL _LCD_Show
243:                           LCD_Show(P3, HIDE);
001D7A  EB4080     CLR.B W1
001D7C  B3C090     MOV.B #0x9, W0
001D7E  07FDCC     RCALL _LCD_Show
244:                           LCD_Show(P4, HIDE);
001D80  EB4080     CLR.B W1
001D82  B3C0B0     MOV.B #0xB, W0
001D84  07FDC9     RCALL _LCD_Show
245:                           break;
001D86  370034     BRA 0x1DF0
246:                       }
247:                       case 2:
248:                       {
249:                           LCD_Show(P1, HIDE);
001D88  EB4080     CLR.B W1
001D8A  B3C010     MOV.B #0x1, W0
001D8C  07FDC5     RCALL _LCD_Show
250:                           LCD_Show(P2, SHOW);
001D8E  B3C011     MOV.B #0x1, W1
001D90  B3C030     MOV.B #0x3, W0
001D92  07FDC2     RCALL _LCD_Show
251:                           LCD_Show(P3, HIDE);
001D94  EB4080     CLR.B W1
001D96  B3C090     MOV.B #0x9, W0
001D98  07FDBF     RCALL _LCD_Show
252:                           LCD_Show(P4, HIDE);
001D9A  EB4080     CLR.B W1
001D9C  B3C0B0     MOV.B #0xB, W0
001D9E  07FDBC     RCALL _LCD_Show
253:                           break;
001DA0  370027     BRA 0x1DF0
254:                       }
255:                       case 3:
256:                       {
257:                           LCD_Show(P1, HIDE);
001DA2  EB4080     CLR.B W1
001DA4  B3C010     MOV.B #0x1, W0
001DA6  07FDB8     RCALL _LCD_Show
258:                           LCD_Show(P2, HIDE);
001DA8  EB4080     CLR.B W1
001DAA  B3C030     MOV.B #0x3, W0
001DAC  07FDB5     RCALL _LCD_Show
259:                           LCD_Show(P3, SHOW);
001DAE  B3C011     MOV.B #0x1, W1
001DB0  B3C090     MOV.B #0x9, W0
001DB2  07FDB2     RCALL _LCD_Show
260:                           LCD_Show(P4, HIDE);
001DB4  EB4080     CLR.B W1
001DB6  B3C0B0     MOV.B #0xB, W0
001DB8  07FDAF     RCALL _LCD_Show
261:                           break;
001DBA  37001A     BRA 0x1DF0
262:                       }
263:                       case 4:
264:                       {
265:                           LCD_Show(P1, HIDE);
001DBC  EB4080     CLR.B W1
001DBE  B3C010     MOV.B #0x1, W0
001DC0  07FDAB     RCALL _LCD_Show
266:                           LCD_Show(P2, HIDE);
001DC2  EB4080     CLR.B W1
001DC4  B3C030     MOV.B #0x3, W0
001DC6  07FDA8     RCALL _LCD_Show
267:                           LCD_Show(P3, HIDE);
001DC8  EB4080     CLR.B W1
001DCA  B3C090     MOV.B #0x9, W0
001DCC  07FDA5     RCALL _LCD_Show
268:                           LCD_Show(P4, SHOW);
001DCE  B3C011     MOV.B #0x1, W1
001DD0  B3C0B0     MOV.B #0xB, W0
001DD2  07FDA2     RCALL _LCD_Show
269:                           break;
001DD4  37000D     BRA 0x1DF0
270:                       }
271:                       default:
272:                       {
273:                           LCD_Show(P1, HIDE);
001DD6  EB4080     CLR.B W1
001DD8  B3C010     MOV.B #0x1, W0
001DDA  07FD9E     RCALL _LCD_Show
274:                           LCD_Show(P2, HIDE);
001DDC  EB4080     CLR.B W1
001DDE  B3C030     MOV.B #0x3, W0
001DE0  07FD9B     RCALL _LCD_Show
275:                           LCD_Show(P3, HIDE);
001DE2  EB4080     CLR.B W1
001DE4  B3C090     MOV.B #0x9, W0
001DE6  07FD98     RCALL _LCD_Show
276:                           LCD_Show(P4, HIDE);
001DE8  EB4080     CLR.B W1
001DEA  B3C0B0     MOV.B #0xB, W0
001DEC  07FD95     RCALL _LCD_Show
277:                           break;
001DEE  000000     NOP
278:                       }
279:                   }
280:               }
001DF0  FA8000     ULNK
001DF2  060000     RETURN
281:               
282:               void ClrNum(void) {
001DF4  FA0004     LNK #0x4
283:                   uint8_t x, y, z, m;
284:                   for (y = 0; y < 4; y++)//清楚字母部分1
001DF6  EB4000     CLR.B W0
001DF8  984710     MOV.B W0, [W14+1]
001DFA  370011     BRA 0x1E1E
001E18  90401E     MOV.B [W14+1], W0
001E1A  E84000     INC.B W0, W0
001E1C  984710     MOV.B W0, [W14+1]
001E1E  90401E     MOV.B [W14+1], W0
001E20  504FE3     SUB.B W0, #0x3, [W15]
001E22  36FFEC     BRA LEU, 0x1DFC
285:                       for (x = 0; x < 4; x++)
001DFC  EB4000     CLR.B W0
001DFE  784F00     MOV.B W0, [W14]
001E00  370008     BRA 0x1E12
001E10  E84F1E     INC.B [W14], [W14]
001E12  78401E     MOV.B [W14], W0
001E14  504FE3     SUB.B W0, #0x3, [W15]
001E16  36FFF5     BRA LEU, 0x1E02
286:                           LCD_Show(x + y * SegCnt, HIDE);
001E02  90401E     MOV.B [W14+1], W0
001E04  B90072     MUL.SU W0, #18, W0
001E06  780000     MOV W0, W0
001E08  784000     MOV.B W0, W0
001E0A  40401E     ADD.B W0, [W14], W0
001E0C  EB4080     CLR.B W1
001E0E  07FD84     RCALL _LCD_Show
287:               
288:                   for (z = 0; z < 4; z++)//清楚字母部分2
001E24  EB4000     CLR.B W0
001E26  984720     MOV.B W0, [W14+2]
001E28  370014     BRA 0x1E52
001E4C  90402E     MOV.B [W14+2], W0
001E4E  E84000     INC.B W0, W0
001E50  984720     MOV.B W0, [W14+2]
001E52  90402E     MOV.B [W14+2], W0
001E54  504FE3     SUB.B W0, #0x3, [W15]
001E56  36FFE9     BRA LEU, 0x1E2A
289:                       for (m = 8; m < SegCnt; m++)
001E2A  B3C080     MOV.B #0x8, W0
001E2C  984730     MOV.B W0, [W14+3]
001E2E  37000B     BRA 0x1E46
001E40  90403E     MOV.B [W14+3], W0
001E42  E84000     INC.B W0, W0
001E44  984730     MOV.B W0, [W14+3]
001E46  90403E     MOV.B [W14+3], W0
001E48  504FF1     SUB.B W0, #0x11, [W15]
001E4A  36FFF2     BRA LEU, 0x1E30
290:                           LCD_Show(m + z * SegCnt, HIDE);
001E30  90402E     MOV.B [W14+2], W0
001E32  B90072     MUL.SU W0, #18, W0
001E34  780000     MOV W0, W0
001E36  784080     MOV.B W0, W1
001E38  90403E     MOV.B [W14+3], W0
001E3A  40C000     ADD.B W1, W0, W0
001E3C  EB4080     CLR.B W1
001E3E  07FD6C     RCALL _LCD_Show
291:               }
001E58  FA8000     ULNK
001E5A  060000     RETURN
292:               
293:               void ClrScreen(void) {
001E5C  FA0002     LNK #0x2
294:                   uint8_t x, y;
295:                   for (y = 0; y < 4; y++)
001E5E  EB4000     CLR.B W0
001E60  984710     MOV.B W0, [W14+1]
001E62  370011     BRA 0x1E86
001E80  90401E     MOV.B [W14+1], W0
001E82  E84000     INC.B W0, W0
001E84  984710     MOV.B W0, [W14+1]
001E86  90401E     MOV.B [W14+1], W0
001E88  504FE3     SUB.B W0, #0x3, [W15]
001E8A  36FFEC     BRA LEU, 0x1E64
296:                       for (x = 0; x < SegCnt; x++)
001E64  EB4000     CLR.B W0
001E66  784F00     MOV.B W0, [W14]
001E68  370008     BRA 0x1E7A
001E78  E84F1E     INC.B [W14], [W14]
001E7A  78401E     MOV.B [W14], W0
001E7C  504FF1     SUB.B W0, #0x11, [W15]
001E7E  36FFF5     BRA LEU, 0x1E6A
297:                           LCD_Show(x + y * SegCnt, HIDE);
001E6A  90401E     MOV.B [W14+1], W0
001E6C  B90072     MUL.SU W0, #18, W0
001E6E  780000     MOV W0, W0
001E70  784000     MOV.B W0, W0
001E72  40401E     ADD.B W0, [W14], W0
001E74  EB4080     CLR.B W1
001E76  07FD50     RCALL _LCD_Show
298:               }
001E8C  FA8000     ULNK
001E8E  060000     RETURN
299:               
300:               void LCD_Task(uint32_t dat) {
001E90  FA0004     LNK #0x4
001E92  BE8F00     MOV.D W0, [W14]
301:                   ClrScreen();
001E94  07FFE3     RCALL ClrScreen
302:                   (W_LCDCON.LCD_Flagbits.F_Bat1) ? BAT_SHOW(1) : BAT_SHOW(4);
001E96  804200     MOV W_LCDCON, W0
001E98  600070     AND W0, #0x10, W0
001E9A  E00000     CP0 W0
001E9C  320003     BRA Z, 0x1EA4
001E9E  B3C010     MOV.B #0x1, W0
001EA0  07FE4B     RCALL BAT_SHOW
001EA2  370002     BRA 0x1EA8
001EA4  B3C040     MOV.B #0x4, W0
001EA6  07FE48     RCALL BAT_SHOW
303:                   (W_LCDCON.LCD_Flagbits.F_Bat2) ? BAT_SHOW(2) : BAT_SHOW(4);
001EA8  804201     MOV W_LCDCON, W1
001EAA  200200     MOV #0x20, W0
001EAC  608000     AND W1, W0, W0
001EAE  E00000     CP0 W0
001EB0  320003     BRA Z, 0x1EB8
001EB2  B3C020     MOV.B #0x2, W0
001EB4  07FE41     RCALL BAT_SHOW
001EB6  370002     BRA 0x1EBC
001EB8  B3C040     MOV.B #0x4, W0
001EBA  07FE3E     RCALL BAT_SHOW
304:                   (W_LCDCON.LCD_Flagbits.F_Bat3) ? BAT_SHOW(3) : BAT_SHOW(4);
001EBC  804201     MOV W_LCDCON, W1
001EBE  200400     MOV #0x40, W0
001EC0  608000     AND W1, W0, W0
001EC2  E00000     CP0 W0
001EC4  320003     BRA Z, 0x1ECC
001EC6  B3C030     MOV.B #0x3, W0
001EC8  07FE37     RCALL BAT_SHOW
001ECA  370002     BRA 0x1ED0
001ECC  B3C040     MOV.B #0x4, W0
001ECE  07FE34     RCALL BAT_SHOW
305:                   (W_LCDCON.LCD_Flagbits.F_C) ? CC_SHOW(SHOW) : CC_SHOW(HIDE);
001ED0  804201     MOV W_LCDCON, W1
001ED2  240000     MOV #0x4000, W0
001ED4  608000     AND W1, W0, W0
001ED6  E00000     CP0 W0
001ED8  320005     BRA Z, 0x1EE4
001EDA  802C80     MOV LCDDATA0, W0
001EDC  A07000     BSET W0, #7
001EDE  882C80     MOV W0, LCDDATA0
001EE0  802C80     MOV LCDDATA0, W0
001EE2  370004     BRA 0x1EEC
001EE4  802C80     MOV LCDDATA0, W0
001EE6  A17000     BCLR W0, #7
001EE8  882C80     MOV W0, LCDDATA0
001EEA  802C80     MOV LCDDATA0, W0
306:                   (W_LCDCON.LCD_Flagbits.F_M3) ? m3_SHOW(SHOW) : m3_SHOW(HIDE);
001EEC  804201     MOV W_LCDCON, W1
001EEE  210000     MOV #0x1000, W0
001EF0  608000     AND W1, W0, W0
001EF2  E00000     CP0 W0
001EF4  320005     BRA Z, 0x1F00
001EF6  802D00     MOV LCDDATA8, W0
001EF8  A07000     BSET W0, #7
001EFA  882D00     MOV W0, LCDDATA8
001EFC  802D00     MOV LCDDATA8, W0
001EFE  370004     BRA 0x1F08
001F00  802D00     MOV LCDDATA8, W0
001F02  A17000     BCLR W0, #7
001F04  882D00     MOV W0, LCDDATA8
001F06  802D00     MOV LCDDATA8, W0
307:                   (W_LCDCON.LCD_Flagbits.F_KPa) ? kPa_SHOW(SHOW) : kPa_SHOW(HIDE);
001F08  804201     MOV W_LCDCON, W1
001F0A  208000     MOV #0x800, W0
001F0C  608000     AND W1, W0, W0
001F0E  E00000     CP0 W0
001F10  320005     BRA Z, 0x1F1C
001F12  802D40     MOV LCDDATA12, W0
001F14  A07000     BSET W0, #7
001F16  882D40     MOV W0, LCDDATA12
001F18  802D40     MOV LCDDATA12, W0
001F1A  370004     BRA 0x1F24
001F1C  802D40     MOV LCDDATA12, W0
001F1E  A17000     BCLR W0, #7
001F20  882D40     MOV W0, LCDDATA12
001F22  802D40     MOV LCDDATA12, W0
308:                   (W_LCDCON.LCD_Flagbits.F_h) ? _h_SHOW(SHOW) : _h_SHOW(HIDE);
001F24  804201     MOV W_LCDCON, W1
001F26  220000     MOV #0x2000, W0
001F28  608000     AND W1, W0, W0
001F2A  E00000     CP0 W0
001F2C  320005     BRA Z, 0x1F38
001F2E  802CC0     MOV LCDDATA4, W0
001F30  A07000     BSET W0, #7
001F32  882CC0     MOV W0, LCDDATA4
001F34  802CC0     MOV LCDDATA4, W0
001F36  370004     BRA 0x1F40
001F38  802CC0     MOV LCDDATA4, W0
001F3A  A17000     BCLR W0, #7
001F3C  882CC0     MOV W0, LCDDATA4
001F3E  802CC0     MOV LCDDATA4, W0
309:                   (W_LCDCON.LCD_Flagbits.F_Charge) ? POW_SHOW(SHOW) : POW_SHOW(HIDE);
001F40  804200     MOV W_LCDCON, W0
001F42  600061     AND W0, #0x1, W0
001F44  E00000     CP0 W0
001F46  320005     BRA Z, 0x1F52
001F48  802D40     MOV LCDDATA12, W0
001F4A  A04000     BSET W0, #4
001F4C  882D40     MOV W0, LCDDATA12
001F4E  802D40     MOV LCDDATA12, W0
001F50  370004     BRA 0x1F5A
001F52  802D40     MOV LCDDATA12, W0
001F54  A14000     BCLR W0, #4
001F56  882D40     MOV W0, LCDDATA12
001F58  802D40     MOV LCDDATA12, W0
310:                   (W_LCDCON.LCD_Flagbits.F_Error) ? ERR_SHOW(SHOW) : ERR_SHOW(HIDE);
001F5A  804200     MOV W_LCDCON, W0
001F5C  600062     AND W0, #0x2, W0
001F5E  E00000     CP0 W0
001F60  320005     BRA Z, 0x1F6C
001F62  802D00     MOV LCDDATA8, W0
001F64  A04000     BSET W0, #4
001F66  882D00     MOV W0, LCDDATA8
001F68  802D00     MOV LCDDATA8, W0
001F6A  370004     BRA 0x1F74
001F6C  802D00     MOV LCDDATA8, W0
001F6E  A14000     BCLR W0, #4
001F70  882D00     MOV W0, LCDDATA8
001F72  802D00     MOV LCDDATA8, W0
311:                   (W_LCDCON.LCD_Flagbits.F_Qm) ? FOR_SHOW(SHOW) : FOR_SHOW(HIDE);
001F74  804200     MOV W_LCDCON, W0
001F76  600064     AND W0, #0x4, W0
001F78  E00000     CP0 W0
001F7A  320005     BRA Z, 0x1F86
001F7C  802CC0     MOV LCDDATA4, W0
001F7E  A04000     BSET W0, #4
001F80  882CC0     MOV W0, LCDDATA4
001F82  802CC0     MOV LCDDATA4, W0
001F84  370004     BRA 0x1F8E
001F86  802CC0     MOV LCDDATA4, W0
001F88  A14000     BCLR W0, #4
001F8A  882CC0     MOV W0, LCDDATA4
001F8C  802CC0     MOV LCDDATA4, W0
312:                   (W_LCDCON.LCD_Flagbits.F_Vm) ? BACK_SHOW(SHOW) : BACK_SHOW(HIDE);
001F8E  804200     MOV W_LCDCON, W0
001F90  600068     AND W0, #0x8, W0
001F92  E00000     CP0 W0
001F94  320005     BRA Z, 0x1FA0
001F96  802C80     MOV LCDDATA0, W0
001F98  A04000     BSET W0, #4
001F9A  882C80     MOV W0, LCDDATA0
001F9C  802C80     MOV LCDDATA0, W0
001F9E  370004     BRA 0x1FA8
001FA0  802C80     MOV LCDDATA0, W0
001FA2  A14000     BCLR W0, #4
001FA4  882C80     MOV W0, LCDDATA0
001FA6  802C80     MOV LCDDATA0, W0
313:                   (W_LCDCON.LCD_Flagbits.F_Sign1) ? SIGN_SHOW(1) : SIGN_SHOW(0);
001FA8  804201     MOV W_LCDCON, W1
001FAA  200800     MOV #0x80, W0
001FAC  608000     AND W1, W0, W0
001FAE  E00000     CP0 W0
001FB0  320003     BRA Z, 0x1FB8
001FB2  B3C010     MOV.B #0x1, W0
001FB4  07FE13     RCALL SIGN_SHOW
001FB6  370002     BRA 0x1FBC
001FB8  EB4000     CLR.B W0
001FBA  07FE10     RCALL SIGN_SHOW
314:                   (W_LCDCON.LCD_Flagbits.F_Sign2) ? SIGN_SHOW(2) : SIGN_SHOW(0);
001FBC  804201     MOV W_LCDCON, W1
001FBE  201000     MOV #0x100, W0
001FC0  608000     AND W1, W0, W0
001FC2  E00000     CP0 W0
001FC4  320003     BRA Z, 0x1FCC
001FC6  B3C020     MOV.B #0x2, W0
001FC8  07FE09     RCALL SIGN_SHOW
001FCA  370002     BRA 0x1FD0
001FCC  EB4000     CLR.B W0
001FCE  07FE06     RCALL SIGN_SHOW
315:                   (W_LCDCON.LCD_Flagbits.F_Sign3) ? SIGN_SHOW(3) : SIGN_SHOW(0);    
001FD0  804201     MOV W_LCDCON, W1
001FD2  202000     MOV #0x200, W0
001FD4  608000     AND W1, W0, W0
001FD6  E00000     CP0 W0
001FD8  320003     BRA Z, 0x1FE0
001FDA  B3C030     MOV.B #0x3, W0
001FDC  07FDFF     RCALL SIGN_SHOW
001FDE  370002     BRA 0x1FE4
001FE0  EB4000     CLR.B W0
001FE2  07FDFC     RCALL SIGN_SHOW
316:                   (W_LCDCON.LCD_Flagbits.F_Sign4) ? SIGN_SHOW(4) : SIGN_SHOW(0);
001FE4  804201     MOV W_LCDCON, W1
001FE6  204000     MOV #0x400, W0
001FE8  608000     AND W1, W0, W0
001FEA  E00000     CP0 W0
001FEC  320003     BRA Z, 0x1FF4
001FEE  B3C040     MOV.B #0x4, W0
001FF0  07FDF5     RCALL SIGN_SHOW
001FF2  370002     BRA 0x1FF8
001FF4  EB4000     CLR.B W0
001FF6  07FDF2     RCALL SIGN_SHOW
317:                   DP_SHOW(W_LCDCON.LCD_Flagbits.F_DP);
001FF8  804200     MOV W_LCDCON, W0
001FFA  DE00CF     LSR W0, #15, W1
001FFC  804210     MOV 0x842, W0
001FFE  600063     AND W0, #0x3, W0
002000  400000     ADD W0, W0, W0
002002  708000     IOR W1, W0, W0
002004  784000     MOV.B W0, W0
002006  07FEA4     RCALL DP_SHOW
318:               
319:                   if (W_LCDCON.LCD_Flagbits.F_Num)
002008  804210     MOV 0x842, W0
00200A  600064     AND W0, #0x4, W0
00200C  E00000     CP0 W0
00200E  320004     BRA Z, 0x2018
320:                       NUMS_SHOW(dat, 0);
002010  EB4100     CLR.B W2
002012  BE001E     MOV.D [W14], W0
002014  07FE35     RCALL NUMS_SHOW
002016  370007     BRA 0x2026
321:                   else if (W_LCDCON.LCD_Flagbits.F_Time)
002018  804210     MOV 0x842, W0
00201A  600068     AND W0, #0x8, W0
00201C  E00000     CP0 W0
00201E  320002     BRA Z, 0x2024
322:                       TIME_SHOW();
002020  07FE6D     RCALL TIME_SHOW
002022  370001     BRA 0x2026
323:                   else
324:                       Nop();
002024  000000     NOP
325:                   W_LCDCON.LCD_Flag = 0; //清楚所有标志
002026  EF2840     CLR W_LCDCON
002028  EF2842     CLR 0x842
326:               }
00202A  FA8000     ULNK
327:               
328:               
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/INT.c  ---------------------------------------
1:                 #include "INT.h"
2:                 
3:                 void INT0_Init(void) {
0036D2  FA0000     LNK #0x0
4:                     TRISFbits.TRISF6 = 1; //设置为输入
0036D4  A8C2E8     BSET TRISF, #6
5:                     INTCON2bits.INT0EP = 1; //  1 = 下降沿中断  0 = 上升沿中断
0036D6  A80082     BSET INTCON2, #0
6:                     IPC0bits.INT0IP = 7; //优先级为2
0036D8  800520     MOV IPC0, W0
0036DA  B30070     IOR #0x7, W0
0036DC  880520     MOV W0, IPC0
7:                     IFS0bits.INT0IF = 0; //清除标志位
0036DE  A90084     BCLR IFS0, #0
8:                     IEC0bits.INT0IE = 1; //使能中断
0036E0  A80094     BSET IEC0, #0
9:                 }
0036E2  FA8000     ULNK
0036E4  060000     RETURN
10:                
11:                void INT0_Open(void) {
0036E6  FA0000     LNK #0x0
12:                    IFS0bits.INT0IF = 0; //清除标志位
0036E8  A90084     BCLR IFS0, #0
13:                    IEC0bits.INT0IE = 1;
0036EA  A80094     BSET IEC0, #0
14:                }
0036EC  FA8000     ULNK
0036EE  060000     RETURN
15:                
16:                void INT0_Close(void) {
0036F0  FA0000     LNK #0x0
17:                    IFS0bits.INT0IF = 0; //清除标志位
0036F2  A90084     BCLR IFS0, #0
18:                    IEC0bits.INT0IE = 0;
0036F4  A90094     BCLR IEC0, #0
19:                }
0036F6  FA8000     ULNK
20:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/I2C.c  ---------------------------------------
1:                 #include "I2C.h"
2:                 
3:                 volatile uint8_t i2c1_state;
4:                 I2C1_Buffer i2c_buf;
5:                 
6:                 void I2C_Init(void) {
0036FA  FA0000     LNK #0x0
7:                     TRISGbits.TRISG2 = 0; //将SCL1设置为输出口
0036FC  A942F0     BCLR TRISG, #2
8:                     TRISGbits.TRISG3 = 0; //将SCK1设置为输出口
0036FE  A962F0     BCLR TRISG, #3
9:                     I2C1BRG = 0x9D; //100kHz Fcy=16000000
003700  2009D0     MOV #0x9D, W0
003702  881020     MOV W0, I2C1BRG
10:                    I2C1CONbits.I2CEN = 1; //使能I2C1
003704  A8E207     BSET 0x207, #7
11:                    I2C1CONbits.I2CSIDL = 0; //模块在空闲模式下继续工作
003706  A9A207     BCLR 0x207, #5
12:                    I2C1CONbits.IPMIEN = 0; //禁止IPMI模式
003708  A96207     BCLR 0x207, #3
13:                    I2C1CONbits.A10M = 0; //7位从地址
00370A  A94207     BCLR 0x207, #2
14:                    IFS1bits.MI2C1IF = 0; //清楚Master标志位
00370C  A92086     BCLR IFS1, #1
15:                    IPC4bits.MI2C1IP = 5;
00370E  800561     MOV IPC4, W1
003710  2FF8F0     MOV #0xFF8F, W0
003712  608080     AND W1, W0, W1
003714  200500     MOV #0x50, W0
003716  700001     IOR W0, W1, W0
003718  880560     MOV W0, IPC4
16:                    IEC1bits.MI2C1IE = 1; //使能Master中断
00371A  A82096     BSET IEC1, #1
17:                    //    IEC1bits.SI2C1IE = 1;//使能Slave中断
18:                    //    IFS1bits.SI2C1IF = 0;//清楚Slave标志位
19:                    //    I2C1CONbits.I2CEN = 0; //关闭I2C1
20:                }
00371C  FA8000     ULNK
21:                
22:                //void Start_I2C(void) {
23:                //    //    IEC4bits.
24:                //    //    I2C1CONbits.I2CEN = 1;
25:                //    IFS1bits.MI2C1IF = 1;
26:                //}
27:                
28:                //void Stop_I2C(void) {
29:                //    IFS1bits.MI2C1IF = 0;
30:                //    I2C1CONbits.I2CEN = 0;
31:                //}
32:                
33:                //void Check_I2C(void) {
34:                //    if (I2C1STATbits.IWCOL) {//如果写冲突检测位为1，那么清楚错误位，并将状态设置为空闲
35:                //        I2C1STATbits.IWCOL = 0;
36:                //    }
37:                //}
38:                
39:                //void Clear_I2C_Sta(void) {
40:                //    i2c1_state = S_MASTER_IDLE;
41:                //}
42:                
43:                //void Send_I2C_Data(I2C1_Buffer* buf)
44:                //{
45:                //    buf
46:                //}
47:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/DeepSleep.c  ---------------------------------
1:                 #include <DeepSleep.h>
2:                 #include <xc.h>
3:                 #include <stdint.h>
4:                 
5:                 /************
6:                  * 低压/保持稳压器仅在调用休眠模式或深度休眠模式时
7:                 可用。它由LPCFG配置位（CW1<10>）控制，在固件
8:                 中由 RETEN 位（RCON<12>）控制。必须将 LPCFG
9:                 编程为 0 并将 RETEN 位置 1，才能使能该稳压器。
10:                 ************************************************/
11:                void DeepSleep(void) {
003720  FA0000     LNK #0x0
12:                    //    uint8_t Result;
13:                    //    if (RCONbits.WDTO) {
14:                    //        Result = 3;
15:                    //        RCONbits.WDTO = 0;
16:                    //        DSCONbits.RELEASE = 0;
17:                    //    } else if (RCONbits.EXTR) {
18:                    //        Result = 2;
19:                    //        RCONbits.EXTR = 0;
20:                    //        DSCONbits.RELEASE = 0;
21:                    //    } else if (RCONbits.DPSLP) {
22:                    //        Result = 1;
23:                    //        RCONbits.DPSLP = 0;
24:                    //        DSCONbits.RELEASE = 0;
25:                    //        if (DSWAKEbits.DSWDT) DSGPR0 = DSGPR0 + 1; /* count when wake from DSWDT */
26:                    //        if (DSWAKEbits.DSINT0) DSGPR1 = DSGPR1 + 1; /* count when wake from INT0  */
27:                    //    } else {
28:                    //        Result = 0; /* assume we are a Power On reset */
29:                    //        RCONbits.POR = 0;
30:                    //        DSGPR0 = 0;
31:                    //        DSGPR1 = 0;
32:                    //    }
33:                    //    if (Result == 0) {
34:                    RCONbits.RETEN = 1; // CONFIG1  #pragma config LPCFG = ON    // Low power regulator control->Disabled
003722  A88741     BSET 0x741, #4
35:                    //    while (!RCONbits.RETEN)
36:                    //        RCONbits.RETEN = 1;
37:                    //    asm("disi #4");
38:                    //    asm("bset DSCON, #15");
39:                    //    asm("nop");
40:                    //    asm("nop");
41:                    //    asm("btss INTTREG, #15");
42:                    //    asm("pwrsav #0");
43:                    RCONbits.DPSLP = 0; /* clear all previous deep sleep wake flags */
003724  A94741     BCLR 0x741, #2
44:                    DSWAKE = 0; /* clear all previous deep sleep wake flags */
003726  EF275A     CLR DSWAKE
45:                    /* enter deep sleep code cut and paste from data sheet */
46:                    asm("disi #4");
003728  FC0004     DISI #0x4
47:                    asm("bset  DSCON, #15");
00372A  A8E759     BSET 0x759, #7
48:                    asm("nop");
00372C  000000     NOP
49:                    asm("nop");
00372E  000000     NOP
50:                    asm("nop");    
003730  000000     NOP
51:                //    asm("bset  DSCON, #15");
52:                    asm("pwrsav #0");
003732  FE4000     PWRSAV #0
53:                    //    }
54:                }
003734  FA8000     ULNK
55:                
56:                
57:                
---  C:/Users/Administrator/Desktop/V1_1_7WCGforkjxm.X/BSP/CRC16.c  -------------------------------------
1:                 #include "CRC16.h"
2:                 //static const uint8_t aucCRCHi[] = {
3:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
4:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
5:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
6:                 //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
7:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
8:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
9:                 //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
10:                //    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
11:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
12:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
13:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
14:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
15:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
16:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
17:                //    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
18:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
19:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
20:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
21:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
22:                //    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
23:                //    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
24:                //    0x00, 0xC1, 0x81, 0x40
25:                //};
26:                //static const uint8_t aucCRCLo[] = {
27:                //    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
28:                //    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
29:                //    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
30:                //    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
31:                //    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
32:                //    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
33:                //    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
34:                //    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
35:                //    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
36:                //    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
37:                //    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
38:                //    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
39:                //    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
40:                //    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
41:                //    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
42:                //    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
43:                //    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
44:                //    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
45:                //    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
46:                //    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
47:                //    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
48:                //    0x41, 0x81, 0x80, 0x40
49:                //};
50:                ///*************************************
51:                //Function: crc16 
52:                //Description: 计算CRC16的数值，
53:                //Input: 需计算数据，数据长度 
54:                //Output: CRC16的结果值
55:                //*************************************/
56:                //uint16_t crc16(uint8_t * frame, uint16_t len )
57:                //{
58:                //    uint8_t ucCRCHi = 0xFF;
59:                //    uint8_t ucCRCLo = 0xFF;
60:                //    long iIndex;
61:                //    
62:                //    while(len--)
63:                //    {
64:                //        iIndex = ucCRCLo ^ (*frame);
65:                //        ucCRCLo = (uint8_t)( ucCRCHi ^ aucCRCHi[iIndex]);
66:                //        ucCRCHi = aucCRCLo[iIndex];
67:                //    }
68:                //    return (uint16_t)( ucCRCHi|(ucCRCLo<<8));
69:                //}
70:                
71:                ///****************************************************************************
72:                //名称: CRC16()
73:                //说明: CRC16校验程序
74:                //参数: 		*CRC_Buf:数据地址
75:                //                       CRC_Leni:数据长度
76:                //返回:                   CRC_Sumx:校验值
77:                // *****************************************************************************/
78:                //uint16_t CRC16_Check(uint8_t *CRC_Buf, uint8_t CRC_Leni) {
79:                //    uint8_t i, j;
80:                //    uint16_t CRC_Sumx;
81:                //
82:                //    CRC_Sumx = 0xFFFF;
83:                //    for (i = 0; i < CRC_Leni; i++) {
84:                //        CRC_Sumx ^= *(CRC_Buf + i); //异或
85:                //        for (j = 0; j < 8; j++) {
86:                //            if (CRC_Sumx & 0x01) {
87:                //                CRC_Sumx >>= 1;
88:                //                CRC_Sumx ^= 0xA001;
89:                //            } else {
90:                //                CRC_Sumx >>= 1;
91:                //            }
92:                //        }
93:                //    }
94:                //    return (CRC_Sumx);
95:                //}
96:                
97:                /****************************************************************************
98:                名称: CRC16()
99:                说明: CRC16校验程序
100:               参数: 		*CRC_Buf:数据地址
101:                                      CRC_Leni:数据长度
102:               返回:                   CRC_Sumx:校验值
103:                *****************************************************************************/
104:               uint16_t CRC16_Check(uint8_t *CRC_Buf, uint8_t CRC_Leni) {
003022  FA0008     LNK #0x8
003024  980720     MOV W0, [W14+4]
003026  984761     MOV.B W1, [W14+6]
105:                   uint8_t i, j;
106:                   uint16_t CRC_Sumx;
107:               
108:                   CRC_Sumx = 0xFFFF;
003028  EB8000     SETM W0
00302A  980710     MOV W0, [W14+2]
109:                   for (i = 0; i < CRC_Leni; i++) {
00302C  EB4000     CLR.B W0
00302E  784F00     MOV.B W0, [W14]
003030  370022     BRA 0x3076
003074  E84F1E     INC.B [W14], [W14]
003076  90406E     MOV.B [W14+6], W0
003078  78409E     MOV.B [W14], W1
00307A  50CF80     SUB.B W1, W0, [W15]
00307C  39FFDA     BRA NC, 0x3032
110:                       CRC_Sumx ^= *(CRC_Buf + i); //异或
003032  FB801E     ZE [W14], W0
003034  9000AE     MOV [W14+4], W1
003036  408000     ADD W1, W0, W0
003038  784010     MOV.B [W0], W0
00303A  FB8000     ZE W0, W0
00303C  90009E     MOV [W14+2], W1
00303E  688000     XOR W1, W0, W0
003040  980710     MOV W0, [W14+2]
111:                       for (j = 0; j < 8; j++) {
003042  EB4000     CLR.B W0
003044  984710     MOV.B W0, [W14+1]
003046  370013     BRA 0x306E
003068  90401E     MOV.B [W14+1], W0
00306A  E84000     INC.B W0, W0
00306C  984710     MOV.B W0, [W14+1]
00306E  90401E     MOV.B [W14+1], W0
003070  504FE7     SUB.B W0, #0x7, [W15]
003072  36FFEA     BRA LEU, 0x3048
112:                           if (CRC_Sumx & 0x01) {
003048  90001E     MOV [W14+2], W0
00304A  600061     AND W0, #0x1, W0
00304C  784000     MOV.B W0, W0
00304E  E00400     CP0.B W0
003050  320008     BRA Z, 0x3062
113:                               CRC_Sumx >>= 1;
003052  90001E     MOV [W14+2], W0
003054  D10000     LSR W0, W0
003056  980710     MOV W0, [W14+2]
114:                               CRC_Sumx ^= 0xA001;
003058  90009E     MOV [W14+2], W1
00305A  2A0010     MOV #0xA001, W0
00305C  688000     XOR W1, W0, W0
00305E  980710     MOV W0, [W14+2]
003060  370003     BRA 0x3068
115:                           } else {
116:                               CRC_Sumx >>= 1;
003062  90001E     MOV [W14+2], W0
003064  D10000     LSR W0, W0
003066  980710     MOV W0, [W14+2]
117:                           }
118:                       }
119:                   }
120:                   *(CRC_Buf + CRC_Leni) = CRC_Sumx & 0x00ff;//自动添加CRC的数据结果
00307E  90406E     MOV.B [W14+6], W0
003080  FB8000     ZE W0, W0
003082  9000AE     MOV [W14+4], W1
003084  408000     ADD W1, W0, W0
003086  90009E     MOV [W14+2], W1
003088  784081     MOV.B W1, W1
00308A  784801     MOV.B W1, [W0]
121:                   *(CRC_Buf + CRC_Leni + 1) = CRC_Sumx >> 8;
00308C  90406E     MOV.B [W14+6], W0
00308E  FB8000     ZE W0, W0
003090  E80000     INC W0, W0
003092  9000AE     MOV [W14+4], W1
003094  408000     ADD W1, W0, W0
003096  90009E     MOV [W14+2], W1
003098  DE08C8     LSR W1, #8, W1
00309A  784081     MOV.B W1, W1
00309C  784801     MOV.B W1, [W0]
122:                   return (CRC_Sumx);
00309E  90001E     MOV [W14+2], W0
123:               }
0030A0  FA8000     ULNK
0030A2  060000     RETURN
124:               
125:               /*************************************
126:               Function: Sum_Check 
127:               Description: 计算和校验的数值，
128:               Input: 需计算数据，数据长度 
129:               Output: 和校验的结果值
130:                *************************************/
131:               uint16_t Sum_Check(uint8_t *frame, uint8_t bytes) {
0030A4  FA0006     LNK #0x6
0030A6  980710     MOV W0, [W14+2]
0030A8  984741     MOV.B W1, [W14+4]
132:                   uint16_t cksum = 0;
0030AA  EB0000     CLR W0
0030AC  780F00     MOV W0, [W14]
133:               
134:                   while (bytes > 0) {
0030AE  37000A     BRA 0x30C4
0030C4  90404E     MOV.B [W14+4], W0
0030C6  E00400     CP0.B W0
0030C8  3AFFF3     BRA NZ, 0x30B0
135:                       cksum += *frame++;
0030B0  90001E     MOV [W14+2], W0
0030B2  784010     MOV.B [W0], W0
0030B4  FB8000     ZE W0, W0
0030B6  400F1E     ADD W0, [W14], [W14]
0030B8  90001E     MOV [W14+2], W0
0030BA  E80000     INC W0, W0
0030BC  980710     MOV W0, [W14+2]
136:                       bytes--;
0030BE  90404E     MOV.B [W14+4], W0
0030C0  E94000     DEC.B W0, W0
0030C2  984740     MOV.B W0, [W14+4]
137:                   }
138:                   return cksum;
0030CA  78001E     MOV [W14], W0
139:               }
0030CC  FA8000     ULNK
0030CE  060000     RETURN
140:               
141:               /*************************************
142:               Function: CheckIsRight  
143:               Description: 判断接受dat，根据fp校验，返回数据正确性
144:               Input: fp 选择校验函数，dat:检验的数据，bytes:字节数
145:               Output: 1：校验正确  0：校验错误
146:                *************************************/
147:               bool CheckIsRight(FP_CRC fp, uint8_t * dat, const uint8_t bytes) {
0030D0  FA0008     LNK #0x8
0030D2  980710     MOV W0, [W14+2]
0030D4  980721     MOV W1, [W14+4]
0030D6  984762     MOV.B W2, [W14+6]
148:                   uint16_t CRCtep = fp(dat, bytes); //CRC校验
0030D8  90011E     MOV [W14+2], W2
0030DA  9040EE     MOV.B [W14+6], W1
0030DC  90002E     MOV [W14+4], W0
0030DE  010002     CALL W2
0030E0  780F00     MOV W0, [W14]
149:                   return (CRCtep == (*(dat + bytes)+ (*(dat + bytes + 1) << 8))); //校验数据+CRC
0030E2  90406E     MOV.B [W14+6], W0
0030E4  FB8000     ZE W0, W0
0030E6  9000AE     MOV [W14+4], W1
0030E8  408000     ADD W1, W0, W0
0030EA  784010     MOV.B [W0], W0
0030EC  FB8080     ZE W0, W1
0030EE  90406E     MOV.B [W14+6], W0
0030F0  FB8000     ZE W0, W0
0030F2  E80000     INC W0, W0
0030F4  90012E     MOV [W14+4], W2
0030F6  410000     ADD W2, W0, W0
0030F8  784010     MOV.B [W0], W0
0030FA  FB8000     ZE W0, W0
0030FC  DD0048     SL W0, #8, W0
0030FE  408000     ADD W1, W0, W0
003100  68001E     XOR W0, [W14], W0
003102  A7F000     BTSC W0, #15
003104  EA0000     NEG W0, W0
003106  E90000     DEC W0, W0
003108  DE004F     LSR W0, #15, W0
00310A  784000     MOV.B W0, W0
150:               }
00310C  FA8000     ULNK
151:               
152:               
153:               
